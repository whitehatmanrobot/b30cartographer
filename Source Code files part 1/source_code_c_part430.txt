eAbsoluteSD(pSID, NULL, &dwAbsSDSize, NULL, &dwDaclSize, NULL, &dwSaclSize, NULL,  &dwOwnerSize, NULL, &dwPriGrpSize))
		{
			if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) 
			{
				hr = myHLastError();
				goto error;
			}
		}

		// allocate memory
		if(NULL==(pAbsSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwAbsSDSize)))
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		if(NULL==(pAbsDacl=(ACL * )LocalAlloc(LPTR, dwDaclSize)))
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		if(NULL==(pAbsSacl=(ACL * )LocalAlloc(LPTR, dwSaclSize)))
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		if(NULL==(pAbsOwner=(SID *)LocalAlloc(LPTR, dwOwnerSize)))
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		if(NULL==(pAbsPriGrp=(SID *)LocalAlloc(LPTR, dwPriGrpSize)))
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		// copy the SD to the memory buffers
		if(!MakeAbsoluteSD(pSID, pAbsSD, &dwAbsSDSize, pAbsDacl, &dwDaclSize, pAbsSacl, &dwSaclSize, pAbsOwner,  &dwOwnerSize, pAbsPriGrp, &dwPriGrpSize)) 
		{
			hr = myHLastError();
			goto error;
		}

		// get the current size info for the dacl
		memset(&aclsizeinfo, 0, sizeof(aclsizeinfo));
		if(!GetAclInformation(pAbsDacl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "GetAclInformation");
		}

		// figure out the new size
		dwNewAclSize=aclsizeinfo.AclBytesInUse
			+sizeof(ACCESS_ALLOWED_ACE) 
			-sizeof(DWORD) //ACCESS_ALLOWED_ACE::SidStart
			+GetLengthSid((pTokenUser->User).Sid);

		// allocate memory
		pNewDacl=(ACL *)LocalAlloc(LPTR, dwNewAclSize);

		if(NULL == pNewDacl)
		{
			hr=E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		}

		// init the header
		if(!InitializeAcl(pNewDacl, dwNewAclSize, ACL_REVISION_DS)) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "InitializeAcl");
		}

		// find the first ace in the dacl
		if(!GetAce(pAbsDacl, 0, (void **)&pFirstAce)) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "GetAce");
		}

		// add all the old aces
		if(!AddAce(pNewDacl, ACL_REVISION_DS, 0, pFirstAce, aclsizeinfo.AclBytesInUse-sizeof(ACL))) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "AddAce");
		}

		//delete ACEs 
		for(nIndex=0; nIndex < dwCount; nIndex++)
		{
			//the ACEs in pNewDacl is repacked after each deletion.  
			//the pdwIndex[] has to be adjusted
			if(!DeleteAce(pNewDacl, (pdwIndex[nIndex]-nIndex)))
			{
				hr = myHLastError();
				_JumpError(hr, error, "DeleteAce");
			}
		}

		// add the new ace for caller to allow FULL control other than DS_CONTROL 
        if(TRUE == fAddAce)
		{
		    if(!AddAccessAllowedAce(pNewDacl, ACL_REVISION_DS, ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS,  (pTokenUser->User).Sid))
		    {
				hr = myHLastError();
				_JumpError(hr, error, "AddAccessDeniedAce");
		    }
        }

		// stick the new dacl in the sd
		if(!SetSecurityDescriptorDacl(pAbsSD, TRUE, pNewDacl, FALSE)) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "SetSecurityDescriptorDacl");
		}

		// set the owner of the security descriptor as the caller
		if(!SetSecurityDescriptorOwner(
			pAbsSD,                      // SD
			(pTokenUser->User).Sid,      // SID for owner
			FALSE))                      // flag for default
		{
			hr = myHLastError();
			goto error;
		}


		//convert the absolute SD to its relative form
		if(!MakeSelfRelativeSD(pAbsSD, NULL, &dwRelSDSize))
		{
			if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) 
			{
				hr = myHLastError();
				goto error;
			}
		}

		// allocate memory
		if(NULL==(pNewSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwRelSDSize)))
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		// copy the SD to the new memory buffer
		if (!MakeSelfRelativeSD(pAbsSD, pNewSD, &dwRelSDSize)) 
		{
			hr = myHLastError();
			goto error;
		}

		//set the relative SID
		if(S_OK != (hr=CACertTypeSetSecurity(
						hNewCertType,
						pNewSD)))
			goto error;
	}

    *phCertType=hNewCertType;

    hNewCertType=NULL;

    hr=S_OK;

error:

	if(pdwIndex)
		LocalFree(pdwIndex);

    if (pNewDacl) 
        LocalFree(pNewDacl);

    if(hToken)
        CloseHandle(hToken);

    if(pTokenUser)
        LocalFree(pTokenUser);

    if(pSID)
        LocalFree(pSID);

    if (NULL!=pAbsSD) 
        LocalFree(pAbsSD);
    
    if (NULL!=pAbsDacl) 
        LocalFree(pAbsDacl);
    
    if (NULL!=pAbsSacl) 
        LocalFree(pAbsSacl);
    
    if (NULL!=pAbsOwner) 
        LocalFree(pAbsOwner);
    
    if (NULL!=pAbsPriGrp) 
        LocalFree(pAbsPriGrp);
    
    if (NULL!=pNewSD) 
        LocalFree(pNewSD);

    if(awszCN)
        CAFreeCertTypeProperty(hCertType, awszCN);

    if(hNewCertType)
        CACloseCertType(hNewCertType);

    return hr;
}

HRESULT
CAEnumNextCertType(
    IN  HCERTTYPE          hPrevCertType,
    OUT HCERTTYPE *        phCertTypeInfo
    )
{
    CCertTypeInfo *pInfo;
    if(hPrevCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hPrevCertType;

    return pInfo->Next((CCertTypeInfo **)phCertTypeInfo);
}

DWORD 
CACountCertTypes(IN  HCERTTYPE  hCertType)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return 0;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->Count();
}


HRESULT
CACloseCertType(IN HCERTTYPE hCertTypeInfo)
{
    CCertTypeInfo *pInfo;
    if(hCertTypeInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertTypeInfo;

    return pInfo->Release();
}


HRESULT
CAGetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetProperty(wszPropertyName, pawszPropertyValue);
}

HRESULT
CAGetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    OUT LPVOID      pPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetPropertyEx(wszPropertyName, pPropertyValue);
}


HRESULT 
CASetCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPWSTR *    awszPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetProperty(wszPropertyName, awszPropertyValue) ;
}


HRESULT 
CASetCertTypePropertyEx(
    IN  HCERTTYPE   hCertType,
    IN  LPCWSTR     wszPropertyName,
    IN  LPVOID      pPropertyValue)
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetPropertyEx(wszPropertyName, pPropertyValue) ;
}


HRESULT
CAFreeCertTypeProperty(
    IN  HCERTTYPE   hCertType,
    LPWSTR *        awszPropertyValue
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->FreeProperty(awszPropertyValue) ;
}


HRESULT
CAGetCertTypeExtensions(
    IN  HCERTTYPE           hCertType,
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    return CAGetCertTypeExtensionsEx(hCertType, 0, NULL, ppCertExtensions);
}


HRESULT
CAGetCertTypeExtensionsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwFlags,
    IN  LPVOID,             // pParam
    OUT PCERT_EXTENSIONS *  ppCertExtensions
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetExtensions(dwFlags, ppCertExtensions);
}


HRESULT
CAFreeCertTypeExtensions(
    IN  HCERTTYPE,          // hCertType
    IN PCERT_EXTENSIONS     pCertExtensions
    )
{

    //should alreays free via LocalFree since CryptUIWizCertRequest freed
    //it via LocalFree
    if(pCertExtensions)
    {
        LocalFree(pCertExtensions);
    }
    return S_OK;

#if 0
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->FreeExtensions(pCertExtensions) ;
#endif
}


HRESULT 
CASetCertTypeExtension(
    IN HCERTTYPE    hCertType,
    IN LPCWSTR      wszExtensionName,
    IN DWORD        dwFlags,
    IN LPVOID       pExtension
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetExtension(wszExtensionName, pExtension, dwFlags);
}


HRESULT 
CAGetCertTypeFlags(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwFlags
    )
{
    return CAGetCertTypeFlagsEx(hCertType, CERTTYPE_GENERAL_FLAG, pdwFlags);
}


HRESULT
CAGetCertTypeFlagsEx(
    IN  HCERTTYPE           hCertType,
    IN  DWORD               dwOption,
    OUT DWORD *             pdwFlags
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }

    if(pdwFlags == NULL)
    {
        return E_POINTER;
    }

    pInfo = (CCertTypeInfo *)hCertType;


    *pdwFlags = pInfo->GetFlags(dwOption);
    return S_OK;
}


HRESULT 
CASetCertTypeFlags(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwFlags
    )
{
    return CASetCertTypeFlagsEx(hCertType, CERTTYPE_GENERAL_FLAG, dwFlags);
}


HRESULT
CASetCertTypeFlagsEx(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwOption,
    IN DWORD               dwFlags
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetFlags(dwOption, dwFlags);
}


HRESULT 
CAGetCertTypeKeySpec(
    IN  HCERTTYPE           hCertType,
    OUT DWORD *             pdwKeySpec
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }

    if(pdwKeySpec == NULL)
    {
        return E_POINTER;
    }

    pInfo = (CCertTypeInfo *)hCertType;


    *pdwKeySpec = pInfo->GetKeySpec();
    return S_OK;
}





HRESULT 
CASetCertTypeKeySpec(
    IN HCERTTYPE           hCertType,
    IN DWORD               dwKeySpec
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    pInfo->SetKeySpec(dwKeySpec);
    return S_OK;
}

HRESULT
CAGetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    OUT OPTIONAL FILETIME * pftExpiration,
    OUT OPTIONAL FILETIME * pftOverlap
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetExpiration(pftExpiration, pftOverlap);


}

HRESULT
CASetCertTypeExpiration(
    IN  HCERTTYPE           hCertType,
    IN OPTIONAL FILETIME  * pftExpiration,
    IN OPTIONAL FILETIME  * pftOverlap
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetExpiration(pftExpiration, pftOverlap);

}


HRESULT 
CACertTypeSetSecurity(
                     IN HCERTTYPE               hCertType,
                     IN PSECURITY_DESCRIPTOR    pSD
                     )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->SetSecurity( pSD );
}


HRESULT 
CACertTypeGetSecurity(
                     IN  HCERTTYPE                  hCertType,
                     OUT PSECURITY_DESCRIPTOR *     ppSD
                     )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->GetSecurity( ppSD ) ;
}



HRESULT 
CACertTypeAccessCheck(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken
    )

{

    return CACertTypeAccessCheckEx(hCertType, ClientToken, CERTTYPE_ACCESS_CHECK_ENROLL);
}


CERTCLIAPI
HRESULT
WINAPI
CACertTypeAccessCheckEx(
    IN HCERTTYPE    hCertType,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->AccessCheck(ClientToken, dwOption);
}


CERTCLIAPI
HRESULT
WINAPI
CAInstallDefaultCertType(
    IN DWORD // dwFlags
    )
{
    return CCertTypeInfo::InstallDefaultTypes();
}


CERTCLIAPI
BOOL
WINAPI
CAIsCertTypeCurrent(
    IN DWORD,   // dwFlags
    IN LPWSTR   wszCertType   
    )
{
    BOOL			fCurrent=FALSE;
    HRESULT			hr=E_FAIL;
    DWORD			dwCT=0;
	DWORD			dwDefault=0;
	DWORD			dwCount=0;
	BOOL			fFound=FALSE;
	DWORD			dwFound=0;
    DWORD			dwVersion=0;
    CCertTypeInfo	*pInfo=NULL;
	HCERTTYPE		hNewCertType=NULL;

    HCERTTYPE		hCurCertType=NULL;
	LPWSTR			*awszCertTypeName=NULL;

	//get all the templates on the directory
    hr = CAEnumCertTypesEx(
                NULL,
				CT_ENUM_USER_TYPES | CT_ENUM_MACHINE_TYPES | CT_FLAG_NO_CACHE_LOOKUP,
                &hCurCertType);

	if((S_OK != hr) || (NULL==hCurCertType))
		goto error;

	dwCount = CACountCertTypes(hCurCertType);

	if(0 == dwCount)
        goto error;


	//enumrating all templates on the directory
    for(dwCT = 0; dwCT < dwCount; dwCT++ )       
    {
		if(awszCertTypeName)
		{
			CAFreeCertTypeProperty(hCurCertType, awszCertTypeName);
			awszCertTypeName=NULL;
		}

        //check if we have a new certificate template
        if(dwCT > 0)
        {
            hr = CAEnumNextCertType(hCurCertType, &hNewCertType);

            if((S_OK != hr) || (NULL == hNewCertType))
            {
				break;
            }

			CACloseCertType(hCurCertType);                

            hCurCertType=hNewCertType; 
        }
		
		//get the template name
        hr = CAGetCertTypePropertyEx(
                             hCurCertType, 
                             CERTTYPE_PROP_DN,
                             &awszCertTypeName);

        if((S_OK != hr) ||
           (NULL == awszCertTypeName) || 
           (NULL == awszCertTypeName[0])
          )
        {
            goto error;
        }

		//for all templates requested, verify against the default list
		if((NULL == wszCertType) || (0 == mylstrcmpiL(awszCertTypeName[0], wszCertType)))
		{
			if(wszCertType)
				fFound=TRUE;

			for(dwDefault=0; dwDefault < g_cDefaultCertTypes; dwDefault++)
			{
				if(0==mylstrcmpiL(awszCertTypeName[0], g_aDefaultCertTypes[dwDefault].wszName))
				{
					break;
				}
			}

			//match the default name list
			if(dwDefault < g_cDefaultCertTypes)
			{
				hr=CAGetCertTypePropertyEx(
								hCurCertType,
								CERTTYPE_PROP_REVISION,
								&dwVersion);

				if(S_OK != hr)
					goto error;

				if (dwVersion < g_aDefaultCertTypes[dwDefault].dwRevision) 
					goto error;

				pInfo = (CCertTypeInfo *)hCurCertType;
				if(!(pInfo->IsValidSecurityOwner()))
					goto error;

				//mark that we found a good default template
				dwFound++;
			}
		}
	}

	//all requested template has to be checked
	if(wszCertType)
	{
		if(FALSE == fFound)
			goto error;
	}
	else
	{
		if(dwFound != g_cDefaultCertTypes)
			goto error;
	}

	fCurrent=TRUE;

error:

	if(awszCertTypeName)
	{
		if(hCurCertType)
		{
			CAFreeCertTypeProperty(hCurCertType, awszCertTypeName);
		}
	}

    if(hCurCertType)
	{
        CACloseCertType(hCurCertType);
	}

    return fCurrent;
}



HANDLE
myEnterCriticalPolicySection(
    IN BOOL bMachine)
{
    HANDLE hPolicy = NULL;
    HRESULT hr = S_OK;
    
    // ?CriticalPolicySection calls are delay loaded. Protect with try/except

    __try
    {
	hPolicy = EnterCriticalPolicySection(bMachine);	   // Delayload wrapped
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // (S_OK == hr) does not mean EnterCriticalPolicySection succeeded.
    // It just means no exception was raised.

    if (myIsDelayLoadHResult(hr))
    {
	hPolicy = (HANDLE) (ULONG_PTR) (bMachine? 37 : 49);
	hr = S_OK;
    }
    return(hPolicy);
}


BOOL
myLeaveCriticalPolicySection(
    IN HANDLE hSection)
{
    HRESULT hr = S_OK;
    BOOL fOk = FALSE;
    
    // ?CriticalPolicySection calls are delay loaded. Protect with try/except

    __try
    {
        fOk = LeaveCriticalPolicySection(hSection);    // Delayload wrapped
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // (S_OK == hr) does not mean LeaveCriticalPolicySection succeeded.
    // It just means no exception was raised.

    if (myIsDelayLoadHResult(hr))
    {
	fOk = (HANDLE) (ULONG_PTR) 37 == hSection ||
	      (HANDLE) (ULONG_PTR) 49 == hSection;
	hr = S_OK;
    }
    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_COLUMN_REQUESTID),
    RESSTR(IDS_COLUMN_REQUESTRAWREQUEST),
    RESSTR(IDS_COLUMN_REQUESTRAWOLDCERTIFICATE),
    RESSTR(IDS_COLUMN_REQUESTATTRIBUTES),
    RESSTR(IDS_COLUMN_REQUESTTYPE),
    RESSTR(IDS_COLUMN_REQUESTFLAGS),
    RESSTR(IDS_COLUMN_REQUESTSTATUS),
    RESSTR(IDS_COLUMN_REQUESTSTATUSCODE),
    RESSTR(IDS_COLUMN_REQUESTDISPOSITION),
    RESSTR(IDS_COLUMN_REQUESTDISPOSITIONMESSAGE),
    RESSTR(IDS_COLUMN_REQUESTSUBMITTEDWHEN),
    RESSTR(IDS_COLUMN_REQUESTRESOLVEDWHEN),
    RESSTR(IDS_COLUMN_REQUESTREVOKEDWHEN),
    RESSTR(IDS_COLUMN_REQUESTREVOKEDEFFECTIVEWHEN),
    RESSTR(IDS_COLUMN_REQUESTREVOKEDREASON),
    RESSTR(IDS_COLUMN_REQUESTERNAME),
    RESSTR(IDS_COLUMN_REQUESTERADDRESS),
    RESSTR(IDS_COLUMN_REQUESTDISTINGUISHEDNAME),
    RESSTR(IDS_COLUMN_REQUESTRAWNAME),
    RESSTR(IDS_COLUMN_REQUESTNAMETYPE),
    RESSTR(IDS_COLUMN_REQUESTCOUNTRY),
    RESSTR(IDS_COLUMN_REQUESTORGANIZATION),
    RESSTR(IDS_COLUMN_REQUESTORGUNIT),
    RESSTR(IDS_COLUMN_REQUESTCOMMONNAME),
    RESSTR(IDS_COLUMN_REQUESTLOCALITY),
    RESSTR(IDS_COLUMN_REQUESTSTATE),
    RESSTR(IDS_COLUMN_REQUESTTITLE),
    RESSTR(IDS_COLUMN_REQUESTGIVENNAME),
    RESSTR(IDS_COLUMN_REQUESTINITIALS),
    RESSTR(IDS_COLUMN_REQUESTSURNAME),
    RESSTR(IDS_COLUMN_REQUESTDOMAINCOMPONENT),
    RESSTR(IDS_COLUMN_REQUESTEMAIL),
    RESSTR(IDS_COLUMN_REQUESTSTREETADDRESS),
    RESSTR(IDS_COLUMN_CERTIFICATEREQUESTID),
    RESSTR(IDS_COLUMN_CERTIFICATERAWCERTIFICATE),
    RESSTR(IDS_COLUMN_CERTIFICATECERTIFICATEHASH),
    RESSTR(IDS_COLUMN_CERTIFICATETYPE),
    RESSTR(IDS_COLUMN_CERTIFICATESERIALNUMBER),
    RESSTR(IDS_COLUMN_CERTIFICATEISSUERNAMEID),
    RESSTR(IDS_COLUMN_CERTIFICATENOTBEFOREDATE),
    RESSTR(IDS_COLUMN_CERTIFICATENOTAFTERDATE),
    RESSTR(IDS_COLUMN_CERTIFICATERAWPUBLICKEY),
    RESSTR(IDS_COLUMN_CERTIFICATEPUBLICKEYALGORITHM),
    RESSTR(IDS_COLUMN_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS),
    RESSTR(IDS_COLUMN_CERTIFICATEDISTINGUISHEDNAME),
    RESSTR(IDS_COLUMN_CERTIFICATERAWNAME),
    RESSTR(IDS_COLUMN_CERTIFICATENAMETYPE),
    RESSTR(IDS_COLUMN_CERTIFICATECOUNTRY),
    RESSTR(IDS_COLUMN_CERTIFICATEORGANIZATION),
    RESSTR(IDS_COLUMN_CERTIFICATEORGUNIT),
    RESSTR(IDS_COLUMN_CERTIFICATECOMMONNAME),
    RESSTR(IDS_COLUMN_CERTIFICATELOCALITY),
    RESSTR(IDS_COLUMN_CERTIFICATESTATE),
    RESSTR(IDS_COLUMN_CERTIFICATETITLE),
    RESSTR(IDS_COLUMN_CERTIFICATEGIVENNAME),
    RESSTR(IDS_COLUMN_CERTIFICATEINITIALS),
    RESSTR(IDS_COLUMN_CERTIFICATESURNAME),
    RESSTR(IDS_COLUMN_CERTIFICATEDOMAINCOMPONENT),
    RESSTR(IDS_COLUMN_CERTIFICATEEMAIL),
    RESSTR(IDS_COLUMN_CERTIFICATESTREETADDRESS),
    RESSTR(IDS_COLUMN_CERTIFICATEUNSTRUCTUREDNAME),
    RESSTR(IDS_COLUMN_CERTIFICATEUNSTRUCTUREDADDRESS),
    RESSTR(IDS_COLUMN_REQUESTUNSTRUCTUREDNAME),
    RESSTR(IDS_COLUMN_REQUESTUNSTRUCTUREDADDRESS),
    RESSTR(IDS_COLUMN_REQUESTDEVICESERIALNUMBER),
    RESSTR(IDS_COLUMN_CERTIFICATEDEVICESERIALNUMBER),
    RESSTR(IDS_FILESHARE_REMARK),
    RESSTR(IDS_COLUMN_CERTIFICATERAWSMIMECAPABILITIES),
    RESSTR(IDS_COLUMN_EXTREQUESTID),
    RESSTR(IDS_COLUMN_EXTNAME),
    RESSTR(IDS_COLUMN_EXTFLAGS),
    RESSTR(IDS_COLUMN_EXTRAWVALUE),
    RESSTR(IDS_COLUMN_ATTRIBREQUESTID),
    RESSTR(IDS_COLUMN_ATTRIBNAME),
    RESSTR(IDS_COLUMN_ATTRIBVALUE),
    RESSTR(IDS_COLUMN_CRLROWID),
    RESSTR(IDS_COLUMN_CRLNUMBER),
    RESSTR(IDS_COLUMN_CRLMINBASE),
    RESSTR(IDS_COLUMN_CRLNAMEID),
    RESSTR(IDS_COLUMN_CRLCOUNT),
    RESSTR(IDS_COLUMN_CRLTHISUPDATE),
    RESSTR(IDS_COLUMN_CRLNEXTUPDATE),
    RESSTR(IDS_COLUMN_CRLTHISPUBLISH),
    RESSTR(IDS_COLUMN_CRLNEXTPUBLISH),
    RESSTR(IDS_COLUMN_CRLEFFECTIVE),
    RESSTR(IDS_COLUMN_CRLPROPAGATIONCOMPLETE),
    RESSTR(IDS_COLUMN_CRLRAWCRL),
    RESSTR(IDS_CAPROP_FILEVERSION),
    RESSTR(IDS_CAPROP_PRODUCTVERSION),
    RESSTR(IDS_CAPROP_EXITCOUNT),
    RESSTR(IDS_CAPROP_EXITDESCRIPTION),
    RESSTR(IDS_CAPROP_POLICYDESCRIPTION),
    RESSTR(IDS_CAPROP_CANAME),
    RESSTR(IDS_CAPROP_SANITIZEDCANAME),
    RESSTR(IDS_CAPROP_SHAREDFOLDER),
    RESSTR(IDS_CAPROP_PARENTCA),
    RESSTR(IDS_CAPROP_CATYPE),
    RESSTR(IDS_CAPROP_CASIGCERTCOUNT),
    RESSTR(IDS_CAPROP_CASIGCERT),
    RESSTR(IDS_CAPROP_CASIGCERTCHAIN),
    RESSTR(IDS_CAPROP_CAXCHGCERTCOUNT),
    RESSTR(IDS_CAPROP_CAXCHGCERT),
    RESSTR(IDS_CAPROP_CAXCHGCERTCHAIN),
    RESSTR(IDS_CAPROP_BASECRL),
    RESSTR(IDS_CAPROP_DELTACRL),
    RESSTR(IDS_CAPROP_CACERTSTATE),
    RESSTR(IDS_CAPROP_CRLSTATE),
    RESSTR(IDS_CAPROP_CAPROPIDMAX),
    RESSTR(IDS_COLUMN_CERTIFICATESUBJECTKEYIDENTIFIER),
    RESSTR(IDS_UNKNOWN_ERROR_CODE),
    RESSTR(IDS_E_UNEXPECTED),
    RESSTR(IDS_SETUP_ERROR_EXPECTED_SECTION_NAME),
    RESSTR(IDS_SETUP_ERROR_BAD_SECTION_NAME_LINE),
    RESSTR(IDS_SETUP_ERROR_SECTION_NAME_TOO_LONG),
    RESSTR(IDS_SETUP_ERROR_GENERAL_SYNTAX),
    RESSTR(IDS_SETUP_ERROR_WRONG_INF_STYLE),
    RESSTR(IDS_SETUP_ERROR_SECTION_NOT_FOUND),
    RESSTR(IDS_SETUP_ERROR_LINE_NOT_FOUND),
    RESSTR(IDS_COLUMN_REQUESTRAWARCHIVEDKEY),
    RESSTR(IDS_COLUMN_REQUESTKEYRECOVERYHASHES),
    RESSTR(IDS_CAPROP_DNSNAME),
    RESSTR(IDS_COLUMN_PROPCERTIFICATETEMPLATE),
    RESSTR(IDS_COLUMN_REQUESTSIGNERPOLICIES),
    RESSTR(IDS_COLUMN_REQUESTSIGNERAPPLICATIONPOLICIES),
    RESSTR(IDS_COLUMN_PROPCERTIFICATEENROLLMENTFLAGS),
    RESSTR(IDS_COLUMN_PROPCERTIFICATEGENERALFLAGS),
    RESSTR(IDS_COLUMN_CERTIFICATEPUBLICKEYLENGTH),
    RESSTR(IDS_CAPROP_KRACERTUSEDCOUNT),
    RESSTR(IDS_CAPROP_KRACERTCOUNT),
    RESSTR(IDS_CAPROP_KRACERT),
    RESSTR(IDS_CAPROP_KRACERTSTATE),
    RESSTR(IDS_CAPROP_ROLESEPARATIONENABLED),
    RESSTR(IDS_CAPROP_ADVANCEDSERVER),
    RESSTR(IDS_COLUMN_CRLLASTPUBLISHED),
    RESSTR(IDS_COLUMN_CRLPUBLISHATTEMPTS),
    RESSTR(IDS_COLUMN_CRLPUBLISHFLAGS),
    RESSTR(IDS_COLUMN_CRLPUBLISHSTATUSCODE),
    RESSTR(IDS_COLUMN_CRLPUBLISHERROR),
    RESSTR(IDS_COLUMN_CALLERNAME),
    RESSTR(IDS_CAPROP_TEMPLATES),
    RESSTR(IDS_CAPROP_BASECRLPUBLISHSTATUS),
    RESSTR(IDS_CAPROP_DELTACRLPUBLISHSTATUS),
    RESSTR(IDS_CAPROP_CASIGCERTCRLCHAIN),
    RESSTR(IDS_CAPROP_CAXCHGCERTCRLCHAIN),
    RESSTR(IDS_COLUMN_CERTIFICATEUPN),
    RESSTR(IDS_E_DATA_MISALIGNMENT),
    RESSTR(IDS_CAPROP_CACERTSTATUSCODE),
    RESSTR(IDS_HTTP_STATUS_CONTINUE),
    RESSTR(IDS_HTTP_STATUS_SWITCH_PROTOCOLS),
    RESSTR(IDS_HTTP_STATUS_OK),
    RESSTR(IDS_HTTP_STATUS_CREATED),
    RESSTR(IDS_HTTP_STATUS_ACCEPTED),
    RESSTR(IDS_HTTP_STATUS_PARTIAL),
    RESSTR(IDS_HTTP_STATUS_NO_CONTENT),
    RESSTR(IDS_HTTP_STATUS_RESET_CONTENT),
    RESSTR(IDS_HTTP_STATUS_PARTIAL_CONTENT),
    RESSTR(IDS_HTTP_STATUS_AMBIGUOUS),
    RESSTR(IDS_HTTP_STATUS_MOVED),
    RESSTR(IDS_HTTP_STATUS_REDIRECT),
    RESSTR(IDS_HTTP_STATUS_REDIRECT_METHOD),
    RESSTR(IDS_HTTP_STATUS_NOT_MODIFIED),
    RESSTR(IDS_HTTP_STATUS_USE_PROXY),
    RESSTR(IDS_HTTP_STATUS_REDIRECT_KEEP_VERB),
    RESSTR(IDS_HTTP_STATUS_BAD_REQUEST),
    RESSTR(IDS_HTTP_STATUS_DENIED),
    RESSTR(IDS_HTTP_STATUS_PAYMENT_REQ),
    RESSTR(IDS_HTTP_STATUS_FORBIDDEN),
    RESSTR(IDS_HTTP_STATUS_NOT_FOUND),
    RESSTR(IDS_HTTP_STATUS_BAD_METHOD),
    RESSTR(IDS_HTTP_STATUS_NONE_ACCEPTABLE),
    RESSTR(IDS_HTTP_STATUS_PROXY_AUTH_REQ),
    RESSTR(IDS_HTTP_STATUS_REQUEST_TIMEOUT),
    RESSTR(IDS_HTTP_STATUS_CONFLICT),
    RESSTR(IDS_HTTP_STATUS_GONE),
    RESSTR(IDS_HTTP_STATUS_LENGTH_REQUIRED),
    RESSTR(IDS_HTTP_STATUS_PRECOND_FAILED),
    RESSTR(IDS_HTTP_STATUS_REQUEST_TOO_LARGE),
    RESSTR(IDS_HTTP_STATUS_URI_TOO_LONG),
    RESSTR(IDS_HTTP_STATUS_UNSUPPORTED_MEDIA),
    RESSTR(IDS_HTTP_STATUS_RETRY_WITH),
    RESSTR(IDS_HTTP_STATUS_SERVER_ERROR),
    RESSTR(IDS_HTTP_STATUS_NOT_SUPPORTED),
    RESSTR(IDS_HTTP_STATUS_BAD_GATEWAY),
    RESSTR(IDS_HTTP_STATUS_SERVICE_UNAVAIL),
    RESSTR(IDS_HTTP_STATUS_GATEWAY_TIMEOUT),
    RESSTR(IDS_HTTP_STATUS_VERSION_NOT_SUP),
    RESSTR(IDS_CAPROP_CAFORWARDCROSSCERT),
    RESSTR(IDS_CAPROP_CABACKWARDCROSSCERT),
    RESSTR(IDS_CAPROP_CAFORWARDCROSSCERTSTATE),
    RESSTR(IDS_CAPROP_CABACKWARDCROSSCERTSTATE),
    RESSTR(IDS_CAPROP_CACERTVERSION),
    RESSTR(IDS_CAPROP_SANITIZEDCASHORTNAME),
    RESSTR(IDS_CERTIFICATE_SERVICES),
    RESSTR(IDS_MSCEP),
    RESSTR(IDS_MSCEP_DES),
    RESSTR(IDS_COLUMN_REQUESTOFFICER),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\cainfoc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfoc.cpp
//
// Contents:    CCAInfo implemenation
//
// History:     16-Dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "cainfoc.h"
#include "certtype.h"
#include "csldap.h"

#include <lm.h>
#include <certca.h>
#include <polreg.h> 
#include <dsgetdc.h>
#include <winldap.h>
#include <cainfop.h>
#include <ntldap.h>

#define __dwFILE__	__dwFILE_CERTCLIB_CAINFOC_CPP__

#define wcLBRACE	L'{'
#define wcRBRACE	L'}'

LPCWSTR  g_wszEnrollmentServiceLocation = L"CN=Enrollment Services,CN=Public Key Services,CN=Services,";

#define LDAP_SECURITY_DESCRIPTOR_NAME L"NTSecurityDescriptor"

#define LDAP_CERTIFICATE_TEMPLATES_NAME L"certificateTemplates"

WCHAR *g_awszCAAttrs[] = {
                        CA_PROP_NAME, 
                        CA_PROP_DISPLAY_NAME,
                        CA_PROP_FLAGS,
                        CA_PROP_DNSNAME,
                        CA_PROP_DSLOCATION,
                        CA_PROP_CERT_DN,
                        CA_PROP_CERT_TYPES,
                        CA_PROP_SIGNATURE_ALGS,
                        CA_PROP_DESCRIPTION,
                        L"cACertificate",
                        L"objectClass",
                        LDAP_SECURITY_DESCRIPTOR_NAME,
                        NULL};


WCHAR *g_awszCANamedProps[] = {
                        CA_PROP_NAME, 
                        CA_PROP_DISPLAY_NAME,
                        CA_PROP_DNSNAME,
                        CA_PROP_DSLOCATION,
                        CA_PROP_CERT_DN,
                        CA_PROP_CERT_TYPES,
                        CA_PROP_SIGNATURE_ALGS,
                        CA_PROP_DESCRIPTION,
                        NULL};

LPWSTR g_awszSignatureAlgs[] = {
                        TEXT(szOID_RSA_MD2RSA),
                        TEXT(szOID_RSA_MD4RSA),
                        TEXT(szOID_RSA_MD5RSA),
                        TEXT(szOID_RSA_SHA1RSA),
                        NULL
                        };


//+--------------------------------------------------------------------------
// CCAInfo::~CCAInfo -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCAInfo::~CCAInfo()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCAInfo::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::_Cleanup()
{

    // Cleanup will only be called if there is no previous element
    // to reference this element, and the caller is also releaseing.

    // If there is a further element, release it.

    if (NULL != m_pNext)
    {
        m_pNext->Release();
	    m_pNext = NULL;
    }

    CCAProperty::DeleteChain(&m_pProperties);

    if (NULL != m_pCertificate)
    {
        CertFreeCertificateContext(m_pCertificate);
        m_pCertificate = NULL;
    }

    if (NULL != m_bstrDN)
    {
        CertFreeString(m_bstrDN);
        m_bstrDN = NULL;
    }

    if (NULL != m_pSD)
    {
        LocalFree(m_pSD);
        m_pSD = NULL;
    }
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCAInfo::_Cleanup -- add reference
//
// 
//+--------------------------------------------------------------------------

DWORD
CCAInfo::AddRef()
{

    return(InterlockedIncrement(&m_cRef));
}


//+--------------------------------------------------------------------------
// CCAInfo::Release -- release reference
//
// 
//+--------------------------------------------------------------------------

DWORD CCAInfo::Release()
{
    DWORD cRef;

    if (0 == (cRef = InterlockedDecrement(&m_cRef)))
    {
        delete this;
    }
    return(cRef);
}


//+--------------------------------------------------------------------------
// CCAInfo::Find -- Find CA Objects in the DS
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::Find(
    LPCWSTR wszQuery, 
    LPCWSTR wszScope,
    DWORD   dwFlags,
    CCAInfo **ppCAInfo)

{
    HRESULT hr = S_OK;
    LDAP *  pld = NULL;
    // Initialize LDAP session
    WCHAR * wszSearch = L"(objectCategory=pKIEnrollmentService)";
    DWORD   cSearchParam;

    CERTSTR bstrSearchParam = NULL;
    CERTSTR bstrScope = NULL;
    CERTSTR bstrConfig = NULL;
    CERTSTR bstrDomain = NULL;

    if (NULL == ppCAInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
    }


    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError4(
	    hr,
	    error,
	    "myDoesDSExist",
	    HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
	    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN),
	    HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE));

    __try
    {

        if(CA_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)
        {
            pld = (LDAP *)wszScope;
        }
        else
        {
	    // bind to ds
	    hr = myRobustLdapBindEx(
				0,		// dwFlags1
				RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
				LDAP_VERSION2,	// uVersion
				NULL,		// pwszDomainName
				&pld,
				NULL);		// ppwszForestDNSName
	    _LeaveIfError2(
			hr,
			"myRobustLdapBindEx",
			HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD));
	    if(wszScope)
	    {
		bstrScope = CertAllocString((LPWSTR)wszScope);
		if(bstrScope == NULL)
		{
		    hr = E_OUTOFMEMORY;
		    _LeaveError(hr, "CertAllocString");
		}
	    }
	}

	if(bstrScope == NULL)
	{
	    // If scope is not specified, set it to the
	    // current domain scope.
	    hr = CAGetAuthoritativeDomainDn(pld, &bstrDomain, &bstrConfig);
	    if(S_OK != hr)
	    {
		    _LeaveError(hr, "CAGetAuthoritativeDomainDn");
	    }
	    bstrScope = CertAllocStringLen(
					NULL,
					wcslen(bstrConfig) + wcslen(g_wszEnrollmentServiceLocation));
	    if(bstrScope == NULL)
	    {
		    hr = E_OUTOFMEMORY;
		    _LeaveError(hr, "CertAllocStringLen");
	    }
	    wcscpy(bstrScope, g_wszEnrollmentServiceLocation);
	    wcscat(bstrScope, bstrConfig);
	}


	if (NULL != wszQuery)
	{
            // If a query is specified, then combine it with the
            // objectCategory=pKIEnrollmentService query
            cSearchParam = 2 + wcslen(wszSearch) + wcslen(wszQuery) + 2;
            bstrSearchParam = CertAllocStringLen(NULL,cSearchParam);
            if(bstrSearchParam == NULL)
            {
                hr = E_OUTOFMEMORY;
                _LeaveError(hr, "CertAllocStringLen");
            }
            wcscpy(bstrSearchParam, L"(&");
            wcscat(bstrSearchParam, wszSearch);

            wcscat(bstrSearchParam, wszQuery);
            wcscat(bstrSearchParam, L")");
	}

        hr = _ProcessFind(pld,
                          (wszQuery? bstrSearchParam : wszSearch), 
                          bstrScope,
                          dwFlags,
                          ppCAInfo);
        if(hr != S_OK)
        {
	    _LeaveError(hr, "_ProcessFind");
        }

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != bstrScope)
    {
        CertFreeString(bstrScope);
    }

    if( NULL != bstrConfig)
    {
        CertFreeString(bstrConfig);
    }

    if( NULL != bstrDomain)
    {
        CertFreeString(bstrDomain);
    }

    if (NULL != bstrSearchParam)
    {
        CertFreeString(bstrSearchParam);
    }
    if(0 == (CA_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags))
    {
        if (NULL != pld)
        {
            ldap_unbind(pld);
        }
    }
    return(hr);
}




//+--------------------------------------------------------------------------
// CCAInfo::_ProcessFind -- ProcessFind CA Objects in the DS
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::_ProcessFind(
    LDAP *  pld,
    LPCWSTR wszQuery, 
    LPCWSTR wszScope,
    DWORD   dwFlags,
    CCAInfo **ppCAInfo)

{
    HRESULT hr = S_OK;
    ULONG   ldaperr;
    CCAInfo *pCAFirst = NULL;
    CCAInfo *pCACurrent = NULL;
    // Initialize LDAP session
    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                    GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    PLDAPControl server_controls[2] =
    {
	&se_info_control,
	NULL
    };

    LDAPMessage *SearchResult = NULL, *Entry;

    struct berval **apCerts;
    struct berval **apSD;

    PCCERT_CHAIN_CONTEXT    pChainContext = NULL;
    PCCERT_CONTEXT          pCert = NULL;
    DWORD cEntries;

    // search timeout
    struct l_timeval        timeout;

    if (NULL == ppCAInfo)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCAInfo = NULL;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"_ProcessFind(Query=%ws, Scope=%ws, Flags=%x)\n",
	wszQuery,
	wszScope,
	dwFlags));

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;


    // Perform search.
    ldaperr = ldap_search_ext_sW(pld, 
		  (LPWSTR)wszScope,
		  LDAP_SCOPE_SUBTREE,
		  (LPWSTR)wszQuery,
		  g_awszCAAttrs,
		  0,
		  (PLDAPControl *) server_controls,
		  NULL,
		  &timeout,
		  10000,
		  &SearchResult);
    if(ldaperr == LDAP_NO_SUCH_OBJECT)
    {
	// No entries were found.
	hr = S_OK;
	DBGPRINT((DBG_SS_CERTLIBI, "ldap_search_ext_sW: no entries\n"));
	goto error;
    }

    if(ldaperr != LDAP_SUCCESS)
    {
	hr = myHLdapError(pld, ldaperr, NULL);
	_JumpError(hr, error, "ldap_search_ext_sW");
    }
    cEntries = ldap_count_entries(pld, SearchResult);
    DBGPRINT((DBG_SS_CERTLIBI, "ldap_count_entries: %u entries\n", cEntries));
    if (0 == cEntries)
    {
	// No entries were found.
	hr = S_OK;
	goto error;
    }

    hr = S_OK;
    for(Entry = ldap_first_entry(pld, SearchResult); 
	Entry != NULL; 
	Entry = ldap_next_entry(pld, Entry))
    {
	CCAProperty *pProp;
	WCHAR ** pwszProp;
	WCHAR ** wszLdapVal;
	DWORD    dwCAFlags = 0;

	if(pCert)
	{
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;
	}

	if(pChainContext)
	{
	    CertFreeCertificateChain(pChainContext);
	    pChainContext = NULL;
	}

	wszLdapVal = ldap_get_values(pld, Entry, CA_PROP_FLAGS);
	if(wszLdapVal != NULL)  
	{
	    if(wszLdapVal[0] != NULL)
	    {
		dwCAFlags = wcstoul(wszLdapVal[0], NULL, 10);
	    }
	    ldap_value_free(wszLdapVal);
	}
	DBGPRINT((DBG_SS_CERTLIBI, "dwCAFlags=%x\n", dwCAFlags));

	// Filter of flags

	if(( 0 == (dwFlags & CA_FIND_INCLUDE_NON_TEMPLATE_CA)) &&  
	   ( 0 != (dwCAFlags & CA_FLAG_NO_TEMPLATE_SUPPORT)))
	{
	    // Don't include standalone CA's unless instructed to
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"Skipping non-template CA, dwCAFlags=%x\n",
		dwCAFlags));
	    continue;
	}

	// Get the CA Certificate
	apCerts = ldap_get_values_len(pld, Entry, L"cACertificate");
	if(apCerts && apCerts[0])
	{
	    pCert = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    (PBYTE)apCerts[0]->bv_val,
					    apCerts[0]->bv_len);
	    ldap_value_free_len(apCerts);
	}

	if(0 == (CA_FIND_INCLUDE_UNTRUSTED & dwFlags))
	{
	    if (NULL == pCert)
	    {
		DBGPRINT((DBG_SS_CERTLIBI, "Skipping cert-less CA\n"));
		continue;		// skip this CA
	    }

	    // Verify cert and chain...

	    hr = myVerifyCertContext(
			    pCert,
			    CA_VERIFY_FLAGS_IGNORE_OFFLINE,	// dwFlags
			    0,					// cUsageOids
			    NULL,				// apszUsageOids
			    (dwFlags & CA_FIND_LOCAL_SYSTEM)?
				HCCE_LOCAL_MACHINE : HCCE_CURRENT_USER,
			    NULL,			// hAdditionalStore
			    NULL);			// ppwszMissingIssuer
	    if (S_OK != hr)
	    {
		HRESULT hr2;
		WCHAR *pwszSubject = NULL;

		hr2 = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pCert->pCertInfo->Subject,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwszSubject);
		_PrintIfError(hr2, "myCertNameToStr");
		_PrintErrorStr(hr, "myVerifyCertContext", pwszSubject);
		if (NULL != pwszSubject)
		{
		    LocalFree(pwszSubject);
		}
		hr = S_OK;
		continue;		// skip this CA
	    }
	}


	// Is this the first one?
	if(pCACurrent)
	{
	    pCACurrent->m_pNext = new CCAInfo;
	    if(pCACurrent->m_pNext == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
	    }

	    pCACurrent = pCACurrent->m_pNext;
	}
	else
	{
	    pCAFirst = pCACurrent = new CCAInfo;
	    if(pCAFirst == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
	    }
	}

	pCACurrent->m_pCertificate = pCert;
	pCert = NULL;

	WCHAR* wszDN = ldap_get_dnW(pld, Entry);
	if(NULL == wszDN)
	{
	    hr = myHLdapLastError(pld, NULL);
	    _JumpError(hr, error, "ldap_get_dnW");
	}
					
	pCACurrent->m_bstrDN = CertAllocString(wszDN);

	//  ldap_get_dnW rtn value should be freed by calling ldap_memfree
	ldap_memfree(wszDN);

	// check success of CertAllocString
	if(pCACurrent->m_bstrDN == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocString");
	}

	// Add text properties from
	// DS lookup.

	for (pwszProp = g_awszCANamedProps; *pwszProp != NULL; pwszProp++)
	{
	    pProp = new CCAProperty(*pwszProp);
	    if(pProp == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
	    }

	    wszLdapVal = ldap_get_values(pld, Entry, *pwszProp);
	    hr = pProp->SetValue(wszLdapVal);
	    _PrintIfError(hr, "SetValue");

	    if(wszLdapVal)
	    {
		ldap_value_free(wszLdapVal);
	    }
	    if(hr == S_OK)
	    {
		hr = CCAProperty::Append(&pCACurrent->m_pProperties, pProp);
		_PrintIfError(hr, "Append");
	    }
	    if(hr != S_OK)
	    {
		CCAProperty::DeleteChain(&pProp);
		_JumpError(hr, error, "SetValue or Append");
	    }
	}

	pCACurrent->m_dwFlags = dwCAFlags;

	// Append the security descriptor...

	apSD = ldap_get_values_len(pld, Entry, LDAP_SECURITY_DESCRIPTOR_NAME);
	if(apSD != NULL)
	{
	    pCACurrent->m_pSD = LocalAlloc(LMEM_FIXED, (*apSD)->bv_len);
	    if(pCACurrent->m_pSD == NULL)
	    {
		hr = E_OUTOFMEMORY;
		ldap_value_free_len(apSD);
			_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(pCACurrent->m_pSD, (*apSD)->bv_val, (*apSD)->bv_len);
	    ldap_value_free_len(apSD);
	}

	pCACurrent->m_fNew = FALSE;
    }

    // May be null if none found.
    *ppCAInfo = pCAFirst;
    pCAFirst = NULL;


error:

    if(SearchResult)
    {
        ldap_msgfree(SearchResult);
    }

    if (NULL != pCAFirst)
    {
        delete pCAFirst;
    }
    if(pCert)
    {
        CertFreeCertificateContext(pCert);
    }

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::Create -- Create CA Object in the DS
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::Create(
    LPCWSTR wszName, 
    LPCWSTR wszScope, 
    CCAInfo **ppCAInfo)

{
    HRESULT hr = S_OK;
    CCAInfo *pCACurrent = NULL;
    LDAP *  pld = NULL;

    // Initialize LDAP session
    DWORD   cFullLocation;
    CERTSTR    bstrScope = NULL;


    LPWSTR cnVals[2];
    CCAProperty *pProp;

    if (NULL == ppCAInfo || NULL == wszName)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
    }

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	// bind to ds
	hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
	_LeaveIfError(hr, "myRobustLdapBindEx");
       
	if(wszScope)
	{
	    bstrScope = CertAllocString(wszScope);
	    if(bstrScope == NULL)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "CertAllocString");
	    }
	}
	else
	{
	    // If scope is not specified, set it to the
	    // current domain scope.
	    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrScope);
	    if(S_OK != hr)
	    {
		    _LeaveError(hr, "CAGetAuthoritativeDomainDn");
	    }

	}
	pCACurrent = new CCAInfo;
	if(pCACurrent == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "new");
	}


	cFullLocation = 4 + wcslen(wszName) + wcslen(g_wszEnrollmentServiceLocation) + wcslen(bstrScope);
	pCACurrent->m_bstrDN = CertAllocStringLen(NULL, cFullLocation);
	if(pCACurrent->m_bstrDN == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CertAllocStringLen");
	}
	wcscpy(pCACurrent->m_bstrDN, L"CN=");
	wcscat(pCACurrent->m_bstrDN, wszName);
	wcscat(pCACurrent->m_bstrDN, L",");
	wcscat(pCACurrent->m_bstrDN, g_wszEnrollmentServiceLocation);
	wcscat(pCACurrent->m_bstrDN, bstrScope);
	
	pProp = new CCAProperty(CA_PROP_NAME);

    if (pProp == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "new");
	}
       

	cnVals[0] = (LPWSTR)wszName;
	cnVals[1] = NULL;
	pProp->SetValue(cnVals);
	CCAProperty::Append(&pCACurrent->m_pProperties, pProp);
      
	pCACurrent->m_fNew = TRUE;
	*ppCAInfo = pCACurrent;
	pCACurrent = NULL;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != bstrScope)
    {
        CertFreeString(bstrScope);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    if (NULL != pCACurrent)
    {
        delete pCACurrent;
    }
    return(hr);
}


HRESULT 
CCAInfo::Update(VOID)
{

    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP *pld = NULL;
    LDAPMod objectClass,
             cnmod,
             displaymod,
             certmod,
             certdnmod,
             machinednsmod,
             certtypesmod,
             Flagsmod,
             sdmod,
             Descriptionmod;

    WCHAR *awszNull[1] = { NULL };
    DWORD cName;

    TCHAR *objectClassVals[3], *certdnVals[2];
    LDAPMod *mods[13];

    struct berval certberval;
    struct berval sdberval;
    struct berval *certVals[2], *sdVals[2];

    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION|
                                                  OWNER_SECURITY_INFORMATION |
                                                  GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    LDAPControl permissive_modify_control =
    {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };


    PLDAPControl    server_controls[3] =
                    {
                        &se_info_control,
                        &permissive_modify_control,
                        NULL
                    };

    // for now, modifies don't try to update owner/group
    CHAR sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION};
    LDAPControl se_info_control_dacl_only =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValueDaclOnly
        },
        TRUE
    };
    PLDAPControl    server_controls_dacl_only[3] =
                    {
                        &se_info_control_dacl_only,
                        &permissive_modify_control,
                        NULL
                    };

    WCHAR wszFlags[cwcDWORDSPRINTF], *awszFlags[2];
    DWORD               iMod = 0;

    certdnVals[0] = NULL;

    // Things we free and must put into known state
    cnmod.mod_values = NULL;
    displaymod.mod_values = NULL;
    machinednsmod.mod_values = NULL;
    certtypesmod.mod_values = NULL;
    Descriptionmod.mod_values = NULL;


    if (NULL == m_pCertificate)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	// bind to ds
	hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
	_LeaveIfError(hr, "myRobustLdapBindEx");

        objectClass.mod_op = LDAP_MOD_REPLACE;
        objectClass.mod_type = TEXT("objectclass");
        objectClass.mod_values = objectClassVals;
        objectClassVals[0] = wszDSTOPCLASSNAME;
        objectClassVals[1] = wszDSENROLLMENTSERVICECLASSNAME;
        objectClassVals[2] = NULL;
        mods[iMod++] = &objectClass;

        cnmod.mod_op = LDAP_MOD_REPLACE;
        cnmod.mod_type = CA_PROP_NAME;
        hr = GetProperty(CA_PROP_NAME, &cnmod.mod_values);
        if((hr != S_OK) || (cnmod.mod_values == NULL))
        {
            cnmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &cnmod;
            }

        }
        else
        {
            mods[iMod++] = &cnmod;
        }

        displaymod.mod_op = LDAP_MOD_REPLACE;
        displaymod.mod_type = CA_PROP_DISPLAY_NAME;
        hr = GetProperty(CA_PROP_DISPLAY_NAME, &displaymod.mod_values);
        if((hr != S_OK) || (displaymod.mod_values == NULL))
        {
            displaymod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &displaymod;
            }
        }
        else
        {
            mods[iMod++] = &displaymod;
        }


        Flagsmod.mod_op = LDAP_MOD_REPLACE;
        Flagsmod.mod_type = CERTTYPE_PROP_FLAGS;
        Flagsmod.mod_values = awszFlags;
        awszFlags[0] = wszFlags;
        awszFlags[1] = NULL;
        wsprintf(wszFlags, L"%lu", m_dwFlags);
        mods[iMod++] = &Flagsmod;

        certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        certmod.mod_type = TEXT("cACertificate");
        certmod.mod_bvalues = certVals;
        certVals[0] = &certberval;
        certVals[1] = NULL;
        certberval.bv_len = m_pCertificate->cbCertEncoded;
        certberval.bv_val = (char *)m_pCertificate->pbCertEncoded;
        mods[iMod++] = &certmod;

        certdnmod.mod_op = LDAP_MOD_REPLACE;
        certdnmod.mod_type = TEXT("cACertificateDN");
        certdnmod.mod_values = certdnVals;

        cName = CertNameToStr(X509_ASN_ENCODING,
                             &m_pCertificate->pCertInfo->Subject,
                             CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                             NULL,
                             0);


        if (0 == cName)
        {
	        hr = myHLastError();
	        _LeaveError(hr, "CertNameToStr");
        }
        certdnVals[0] = CertAllocStringLen(NULL, cName);
        if( certdnVals[0] == NULL)
        {
            hr = E_OUTOFMEMORY;
            _LeaveError(hr, "CertAllocStringLen");
        }

        if(0 == CertNameToStr(X509_ASN_ENCODING,
                 &m_pCertificate->pCertInfo->Subject,
                 CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
                 certdnVals[0],
                 cName))
        {
            hr = myHLastError();
            _LeaveError(hr, "CertNameToStr");
        }
        certdnVals[1] = NULL;
        mods[iMod++] = &certdnmod;



        machinednsmod.mod_op = LDAP_MOD_REPLACE;
        machinednsmod.mod_type = CA_PROP_DNSNAME;
        hr = GetProperty(CA_PROP_DNSNAME, &machinednsmod.mod_values);
        if((hr != S_OK) || (machinednsmod.mod_values == NULL))
        {
            machinednsmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &machinednsmod;
            }
        }
        else
        {
            mods[iMod++] = &machinednsmod;
        }

        certtypesmod.mod_op = LDAP_MOD_REPLACE;
        certtypesmod.mod_type = LDAP_CERTIFICATE_TEMPLATES_NAME;
        hr = GetProperty(CA_PROP_CERT_TYPES, &certtypesmod.mod_values);
        if((hr != S_OK) || (certtypesmod.mod_values == NULL))
        {
            certtypesmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &certtypesmod;
            }
        }
        else
        {
            mods[iMod++] = &certtypesmod;
        }

        sdmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        sdmod.mod_type = LDAP_SECURITY_DESCRIPTOR_NAME;
        sdmod.mod_bvalues = sdVals;
        sdVals[0] = &sdberval;
        sdVals[1] = NULL;

		if(NULL == m_pSD)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
            _LeaveError(hr, "SecurityDescriptor");
		}

        if(IsValidSecurityDescriptor(m_pSD))
        {
            sdberval.bv_len = GetSecurityDescriptorLength(m_pSD);
            sdberval.bv_val = (char *)m_pSD;
        }
        else
        {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
            _LeaveError(hr, "SecurityDescriptor");

        }
        mods[iMod++] = &sdmod;


        Descriptionmod.mod_op = LDAP_MOD_REPLACE;
        Descriptionmod.mod_type = CA_PROP_DESCRIPTION;
        hr = GetProperty(CA_PROP_DESCRIPTION, &Descriptionmod.mod_values);
        if((hr != S_OK) || (Descriptionmod.mod_values == NULL))
        {
            Descriptionmod.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[iMod++] = &Descriptionmod;
            }
        }
        else
        {
            mods[iMod++] = &Descriptionmod;
        }


        mods[iMod] = NULL;
	CSASSERT(ARRAYSIZE(mods) > iMod);

        hr = S_OK;

        if(m_fNew)
        {
	        DBGPRINT((DBG_SS_CERTLIBI, "Creating DS PKI Enrollment object: '%ws'\n", m_bstrDN));
            ldaperr = ldap_add_ext_sW(pld, m_bstrDN, mods, server_controls, NULL);
        }

        else
        {
            // don't attempt to set owner/group for pre-existing objects
	    DBGPRINT((DBG_SS_CERTLIBI, "Updating DS PKI Enrollment object: '%ws'\n", m_bstrDN));
            ldaperr = ldap_modify_ext_sW(pld, 
                  m_bstrDN,
                  &mods[2],
                  server_controls_dacl_only,
                  NULL);  // skip past objectClass and cn
            if(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
            {
                ldaperr = LDAP_SUCCESS;
            }
        }

        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
	    _LeaveError(ldaperr, m_fNew? "ldap_add_s" : "ldap_modify_sW");
        }
        m_fNew = FALSE;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != certdnVals[0])
    {
        CertFreeString(certdnVals[0]);
    }
    if (NULL != certtypesmod.mod_values && awszNull != certtypesmod.mod_values)
    {
        FreeProperty(certtypesmod.mod_values);
    }
    if (NULL != machinednsmod.mod_values && awszNull != machinednsmod.mod_values)
    {
        FreeProperty(machinednsmod.mod_values);
    }
    if (NULL != cnmod.mod_values && awszNull != cnmod.mod_values)
    {
        FreeProperty(cnmod.mod_values);
    }
    if (NULL != displaymod.mod_values && awszNull != displaymod.mod_values)
    {
        FreeProperty(displaymod.mod_values);
    }
    if (NULL != Descriptionmod.mod_values && awszNull != Descriptionmod.mod_values)
    {
        FreeProperty(Descriptionmod.mod_values);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}


HRESULT 
CCAInfo::Delete(VOID)
{
    LDAP *pld = NULL;
    HRESULT hr = S_OK;
    DWORD ldaperr;

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	// bind to ds
	hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
	_LeaveIfError(hr, "myRobustLdapBindEx");

        ldaperr = ldap_delete_s(pld, m_bstrDN);
	hr = myHLdapError(pld, ldaperr, NULL);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }


error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return (hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::FindDnsDomain -- Find CA Objects in the DS, given a scope specified
// by a dns domain name.
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::FindDnsDomain(
    LPCWSTR wszQuery, 
    LPCWSTR wszDnsDomain, 
    DWORD   dwFlags, 
    CCAInfo **ppCAInfo)
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszScope = NULL;
    DWORD cScope;

    if (NULL != wszDnsDomain)
    {
        cScope = 0;
        err = DNStoRFC1779Name(NULL, &cScope, wszDnsDomain);
        if(err != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
        cScope += 1;
        wszScope = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cScope);
        if (NULL == wszScope)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
        err = DNStoRFC1779Name(wszScope, &cScope, wszDnsDomain);
        if (ERROR_SUCCESS != err)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
    }
    hr = Find(wszQuery, wszScope, dwFlags, ppCAInfo);
    _JumpIfError4(
	    hr,
	    error,
	    "Find",
	    HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
	    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN),
	    HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD));

error:
    if (NULL != wszScope)
    {
        LocalFree(wszScope);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::CreateDnsDomain -- Find CA Objects in the DS, given a scope specified
// by a dns domain name.
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::CreateDnsDomain(
    LPCWSTR wszName, 
    LPCWSTR wszDnsDomain, 
    CCAInfo **ppCAInfo)
{
    HRESULT hr = S_OK;
    DWORD err;
    WCHAR *wszScope = NULL;
    DWORD cScope;

    if(wszDnsDomain)
    {
        cScope = 0;
        err = DNStoRFC1779Name(NULL, &cScope, wszDnsDomain);
        if(err != ERROR_INSUFFICIENT_BUFFER)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
        cScope += 1;
        wszScope = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cScope);
        if (NULL == wszScope)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }
        err = DNStoRFC1779Name(wszScope, &cScope, wszDnsDomain);
        if (ERROR_SUCCESS != err)
        {
            hr = myHError(err);
	    _JumpError(hr, error, "DNStoRFC1779Name");
        }
    }
    hr = Create(wszName, wszScope, ppCAInfo);
    _JumpIfError(hr, error, "Create");

error:
    if (NULL != wszScope)
    {
        LocalFree(wszScope);
    }
    return(hr);
}

//+--------------------------------------------------------------------------
// CCAInfo::Next -- Returns the next object in the chain of CA objects
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::Next(CCAInfo **ppCAInfo)
{
    HRESULT hr;
    
    if (NULL == ppCAInfo)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCAInfo = m_pNext;
    if (NULL != m_pNext)
    {
        m_pNext->AddRef();
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::GetProperty -- Retrieves the values of a property of the CA object
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::GetProperty(
    LPCWSTR wszPropertyName,
    LPWSTR **pawszProperties)
{
    HRESULT     hr;
    LPWSTR      *awszResult = NULL; 
    LPWSTR      pwszName=NULL;
    CCAProperty *pProp;
    LPCWSTR     wszProp = NULL;

    if (NULL == wszPropertyName || NULL == pawszProperties)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    if(LSTRCMPIS(wszPropertyName, L"machineDNSName") == 0)
    {
        wszProp = CA_PROP_DNSNAME;
    }
    else if(LSTRCMPIS(wszPropertyName, L"supportedCertificateTemplates") == 0)
    {
        wszProp = CA_PROP_CERT_TYPES;
    }
    else if(LSTRCMPIS(wszPropertyName, L"signatureAlgs") == 0)
    {
        wszProp = CA_PROP_SIGNATURE_ALGS;
    }
    else
    {
        wszProp = wszPropertyName;
    }

    hr = m_pProperties->Find(wszProp, &pProp);
    _JumpIfErrorStr(hr, error, "Find", wszProp);

    if (NULL != pProp)
    {
        hr = pProp->GetValue(pawszProperties);
        _JumpIfError(hr, error, "GetValue");
    }
    else
    {
        *pawszProperties = NULL;
    }

    if((LSTRCMPIS(wszPropertyName, CA_PROP_DISPLAY_NAME) == 0) &&
        ((*pawszProperties == NULL) || ((*pawszProperties)[0] == NULL)))
    {
        // DISPLAY_NAME is empty, so we try to return the display name
        // of the CA's certificate. if that also failed, just pass back the CN
        if(*pawszProperties != NULL)
        {
            LocalFree(*pawszProperties);
            *pawszProperties = NULL;
        }

        if(m_pCertificate)
        {
	    DWORD dwChar;

            dwChar = CertGetNameStringW(
				m_pCertificate,
				CERT_NAME_SIMPLE_DISPLAY_TYPE,
				0,
				NULL,
				NULL,
				0);
            if (0 != dwChar)
            {
                pwszName=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (dwChar));
                
                if(NULL==pwszName)
                {
                    hr=E_OUTOFMEMORY;
                    _JumpIfError(hr, error, "GetPropertyDisplayName");
                }

                dwChar = CertGetNameStringW(
				    m_pCertificate,
				    CERT_NAME_SIMPLE_DISPLAY_TYPE,
				    0,
				    NULL,
				    pwszName,
				    dwChar);
                if (0 != dwChar)
                {
                    awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(pwszName)+1)*sizeof(WCHAR)));
                    if (NULL==awszResult) 
                    {
                        hr=E_OUTOFMEMORY;
                        _JumpIfError(hr, error, "GetPropertyDisplayName");
                    }
                    awszResult[0]=(WCHAR *)(&awszResult[2]);
                    awszResult[1]=NULL;
                    wcscpy(awszResult[0], pwszName);
                    LocalFree(pwszName);
                    *pawszProperties=awszResult;
                    return S_OK;
                }
            }
        }

        hr = GetProperty(CA_PROP_NAME, pawszProperties);
        _JumpIfError(hr, error, "GetProperty");
    }


error:

    if(pwszName)
        LocalFree(pwszName);

    return(hr);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::SetProperty -- Sets the value of a property
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::SetProperty(
    LPCWSTR wszPropertyName,
    LPWSTR *awszProperties)
{
    HRESULT hr;
    CCAProperty *pProp;
    CCAProperty *pNewProp = NULL;

    if (NULL == wszPropertyName)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = m_pProperties->Find(wszPropertyName, &pProp);
    if (S_OK != hr)
    {
        pNewProp = new CCAProperty(wszPropertyName);
        if (NULL == pNewProp)
        {
            hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "new");
        }
        hr = pNewProp->SetValue(awszProperties);
	_JumpIfError(hr, error, "SetValue");

        hr = CCAProperty::Append(&m_pProperties, pNewProp);
	_JumpIfError(hr, error, "Append");
       
        pNewProp = NULL; // remove our reference if we gave it to m_pProperties
    }
    else
    {
	hr = pProp->SetValue(awszProperties);
	_JumpIfError(hr, error, "SetValue");
    }

error:
    if (NULL != pNewProp)
        CCAProperty::DeleteChain(&pNewProp);

    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::FreeProperty -- Free's a previously returned property array
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::FreeProperty(
    LPWSTR *pawszProperties)
{
    if (NULL != pawszProperties)
    {
        LocalFree(pawszProperties);
    }
    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCAInfo::GetCertificte -- get the CA certificate
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::GetCertificate(
    PCCERT_CONTEXT *ppCert)
{
    HRESULT hr;

    if (NULL == ppCert)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppCert = CertDuplicateCertificateContext(m_pCertificate);
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::SetCertificte -- get the CA certificate
//
// 
//+--------------------------------------------------------------------------

HRESULT
CCAInfo::SetCertificate(
    PCCERT_CONTEXT pCert)
{

    if (NULL != m_pCertificate)
    {
        CertFreeCertificateContext(m_pCertificate);
	m_pCertificate = NULL;
    }

    if (NULL != pCert)
    {
        m_pCertificate = CertDuplicateCertificateContext(pCert);
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
// CCAInfo::EnumCertTypesEx -- Enumerate cert types supported by this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::EnumSupportedCertTypesEx(
    LPCWSTR         wszScope,
    DWORD           dwFlags,
    CCertTypeInfo **ppCertTypes)
{
    HRESULT hr;
    LPWSTR * awszCertTypes = NULL;

    if (NULL == ppCertTypes)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    *ppCertTypes = NULL;

    hr = GetProperty(CA_PROP_CERT_TYPES, &awszCertTypes);
    _JumpIfError(hr, error, "GetProperty");


    if (NULL != awszCertTypes)
    {
	    // Build a filter based on all of the global
	    // entries in the cert list.

        hr = CCertTypeInfo::FindByNames(
                                        (LPCWSTR *)awszCertTypes,
                                        wszScope,
                                        dwFlags,
                                        ppCertTypes);
	    _JumpIfError(hr, error, "FindByNames");
    }

error:
    if (awszCertTypes)
    {
        FreeProperty(awszCertTypes);
    }

    return(hr);
}

//+--------------------------------------------------------------------------
// CCAInfo::EnumCertTypes -- Enumerate cert types supported by this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::EnumSupportedCertTypes(
    DWORD           dwFlags,
    CCertTypeInfo **ppCertTypes)
{
    return  CCAInfo::EnumSupportedCertTypesEx(NULL, dwFlags, ppCertTypes);
}

//+--------------------------------------------------------------------------
// CCAInfo::AddCertType -- Add a cert type to this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::AddCertType(
    CCertTypeInfo *pCertType)
{
    HRESULT hr;
    LPWSTR *awszCertTypes = NULL;
    LPWSTR *awszCertTypeName = NULL;
    LPWSTR *awszNewTypes = NULL;
    LPWSTR wszCertTypeShortName = NULL;
    DWORD  cTypes;

    if (NULL == pCertType)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = GetProperty(CA_PROP_CERT_TYPES, &awszCertTypes);
    _JumpIfError(hr, error, "GetProperty");

    hr = pCertType->GetProperty(CERTTYPE_PROP_DN, &awszCertTypeName);
    _JumpIfError(hr, error, "GetProperty");


    if (NULL == awszCertTypeName || NULL == awszCertTypeName[0])
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL CertTypeName");
    }

    if((NULL != (wszCertTypeShortName = wcschr(awszCertTypeName[0], L'|'))) ||
        (NULL != (wszCertTypeShortName = wcschr(awszCertTypeName[0], wcRBRACE))))
    {
        wszCertTypeShortName++;
    }

    if (NULL == awszCertTypes || NULL == awszCertTypes[0])
    {
        // no templates on the CA, add the new one and exit
        hr = SetProperty(CA_PROP_CERT_TYPES, awszCertTypeName);
        _JumpIfError(hr, error, "SetProperty");
    }
    else
    {
        // If cert type is already on ca, do nothing
        for (cTypes = 0; awszCertTypes[cTypes] != NULL; cTypes++)
        {
            if (0 == mylstrcmpiL(awszCertTypes[cTypes], awszCertTypeName[0]))
            {
                hr = S_OK;
                goto error;
            }
            if(wszCertTypeShortName)
            {
                if (0 == mylstrcmpiL(awszCertTypes[cTypes], wszCertTypeShortName))
                {
                    hr = S_OK;
                    goto error;
                }
            }
        }

        awszNewTypes = (WCHAR **) LocalAlloc(
				        LMEM_FIXED,
				        (cTypes + 2) * sizeof(WCHAR *));
        if (NULL == awszNewTypes)
        {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
        }

        CopyMemory(awszNewTypes, awszCertTypes, cTypes * sizeof(WCHAR *));

        awszNewTypes[cTypes] = awszCertTypeName[0];
        awszNewTypes[cTypes + 1] = NULL;

        hr = SetProperty(CA_PROP_CERT_TYPES, awszNewTypes);
        _JumpIfError(hr, error, "SetProperty");
    }

error:
    if (NULL != awszCertTypes)
    {
        FreeProperty(awszCertTypes);
    }
    if (NULL != awszCertTypeName)
    {
        FreeProperty(awszCertTypeName);
    }
    if (NULL != awszNewTypes)
    {
        LocalFree(awszNewTypes);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::RemoveCertType -- Remove a cert type from this CA
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::RemoveCertType(
    CCertTypeInfo *pCertType)
{
    HRESULT hr;
    WCHAR **awszCertTypes = NULL;
    WCHAR **awszCertTypeName = NULL;
    DWORD cTypes, cTypesNew;
    LPWSTR wszCertTypeName = NULL;
    LPWSTR wszCurrentCertTypeName = NULL;

    if (NULL == pCertType)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = GetProperty(CA_PROP_CERT_TYPES, &awszCertTypes);
    _JumpIfError(hr, error, "GetProperty");

    hr = pCertType->GetProperty(CERTTYPE_PROP_CN, &awszCertTypeName);
    _JumpIfError(hr, error, "GetProperty");
    
    if (NULL == awszCertTypeName || NULL == awszCertTypeName[0])
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL CertTypeName");
    }

    if (NULL == awszCertTypes || NULL == awszCertTypes[0])
    {
        hr = S_OK;
        goto error;
    }
    wszCertTypeName = wcschr(awszCertTypeName[0], wcRBRACE);
    if(wszCertTypeName != NULL)
    {
        wszCertTypeName++;
    }
    else
    {
        wszCertTypeName = awszCertTypeName[0];
    }

    cTypesNew = 0;

    // If cert type is already on ca, do nothing

    for (cTypes = 0; awszCertTypes[cTypes] != NULL; cTypes++)
    {
        if((NULL != (wszCurrentCertTypeName = wcschr(awszCertTypes[cTypes], L'|'))) ||
            (NULL != (wszCurrentCertTypeName = wcschr(awszCertTypes[cTypes], wcRBRACE))))

        {
            wszCurrentCertTypeName++;
        }
        else
        {
            wszCurrentCertTypeName = awszCertTypes[cTypes];
        }

        if (0 != mylstrcmpiL(wszCurrentCertTypeName, wszCertTypeName))
        {
            awszCertTypes[cTypesNew++] = awszCertTypes[cTypes];
        }
    }
    awszCertTypes[cTypesNew] = NULL;

    hr = SetProperty(CA_PROP_CERT_TYPES, awszCertTypes);
    _JumpIfError(hr, error, "SetProperty");

error:
    if (NULL != awszCertTypes)
    {
        FreeProperty(awszCertTypes);
    }
    if (NULL != awszCertTypeName)
    {
        FreeProperty(awszCertTypeName);
    }
    return(hr);
}



//+--------------------------------------------------------------------------
// CCAInfo::GetExpiration -- Get the expiration period
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::GetExpiration(
    DWORD *pdwExpiration, 
    DWORD *pdwUnits)   
{
    HRESULT hr;

    if (NULL == pdwExpiration || NULL == pdwUnits)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    *pdwExpiration = m_dwExpiration;
    *pdwUnits = m_dwExpUnits;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCAInfo::SetExpiration -- Set the expiration period
//
// 
//+--------------------------------------------------------------------------

HRESULT 
CCAInfo::SetExpiration(
    DWORD dwExpiration, 
    DWORD dwUnits)   
{
    m_dwExpiration = dwExpiration;
    m_dwExpUnits = dwUnits;
    return(S_OK);
}

//+--------------------------------------------------------------------------
// CCAInfo::GetSecurity --
//
// 
//+--------------------------------------------------------------------------


HRESULT CCAInfo::GetSecurity(PSECURITY_DESCRIPTOR * ppSD)
{
    PSECURITY_DESCRIPTOR pResult = NULL;

    DWORD   cbSD;

    if(ppSD == NULL)
    {
        return E_POINTER;
    }
    if(m_pSD == NULL)
    {
        *ppSD = NULL;
        return S_OK;
    }

    if(!IsValidSecurityDescriptor(m_pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(m_pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, m_pSD, cbSD);

    *ppSD = pResult;

    return S_OK;
}

//+--------------------------------------------------------------------------
// CCAInfo::GetSecurity --
//
// 
//+--------------------------------------------------------------------------


HRESULT CCAInfo::SetSecurity(PSECURITY_DESCRIPTOR pSD)
{
    PSECURITY_DESCRIPTOR pResult = NULL;

    DWORD   cbSD;

    if(pSD == NULL)
    {
        return E_POINTER;
    }

    if(!IsValidSecurityDescriptor(pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, pSD, cbSD);

    if(m_pSD)
    {
        LocalFree(m_pSD);
    }

    m_pSD = pResult;

    return S_OK;
}

HRESULT CCAInfo::AccessCheck(HANDLE ClientToken, DWORD dwOption)
{

    return CAAccessCheckpEx(ClientToken, m_pSD, dwOption);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\certdec.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certdec.cpp
//
// Contents:    Cert Server main & debug support
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>

#define __dwFILE__	__dwFILE_CERTCLIB_CERTDEC_CPP__


#if DBG_CERTSRV
# ifdef UNICODE
#  define szFMTTSTR		"ws"
# else
#  define szFMTTSTR		"hs"
# endif
#endif

// Read and decode uuencoded file into allocated memory.

HRESULT
DecodeFileW(
    IN TCHAR const *pszfn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN DWORD Flags)
{
    HANDLE hFile;
    HRESULT hr;
    CHAR *pchFile = NULL;
    BYTE *pbOut = NULL;
    DWORD cchFile;
    DWORD cbRead;
    DWORD cbOut;

    
    hFile = CreateFile(
		    pszfn,
		    GENERIC_READ,
		    FILE_SHARE_READ,
		    NULL,
		    OPEN_EXISTING,
		    0,
		    NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CreateFile");
    }
    if (FILE_TYPE_DISK != GetFileType(hFile))
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "GetFileType");
    }

    cchFile = GetFileSize(hFile, NULL);
    if (INVALID_FILE_SIZE == cchFile)
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetFileSize");
    }

    pchFile = (CHAR *) LocalAlloc(LMEM_FIXED, cchFile);
    if (NULL == pchFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!ReadFile(hFile, pchFile, cchFile, &cbRead, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "ReadFile");
    }

    CSASSERT(cbRead <= cchFile);
    if (cbRead != cchFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
        DBGPRINT((
	    DBG_SS_ERROR,
	    "ReadFile read %u bytes, requested %u\n",
	    cbRead,
	    cchFile));
	_JumpError(hr, error, "ReadFile(cbRead)");
    }

    if (CRYPT_STRING_BINARY == Flags)
    {
	pbOut = (BYTE *) pchFile;
	cbOut = cchFile;
	pchFile = NULL;
    }
    else
    {
	// Decode file contents.

	hr = myCryptStringToBinaryA(
                        pchFile,
                        cchFile,
                        Flags,
                        &pbOut,
                        &cbOut,
                        NULL,
                        NULL);
	_JumpIfError2(
		    hr,
		    error,
		    "myCryptStringToBinaryA",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }
    *pcbOut = cbOut;
    *ppbOut = pbOut;
    pbOut = NULL;
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (NULL != pchFile)
    {
	LocalFree(pchFile);
    }
    if (S_OK != hr)
    {
#if DBG_CERTSRV
	if (HRESULT_FROM_WIN32(ERROR_INVALID_DATA) != hr)
	{
	    WCHAR awchr[cwcHRESULTSTRING];

	    DBGPRINT((
		DBG_SS_ERROR,
		"DecodeFileW(%" szFMTTSTR "): error = %ws\n",
		pszfn,
		myHResultToString(awchr, hr)));
	}
#endif
	if (NULL != pbOut)
	{
	    LocalFree(pbOut);
	}
    }
    return(hr);
}


HRESULT
EncodeToFileW(
    IN TCHAR const *pszfn,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hr;
    DWORD cbWritten;
    DWORD cchFile;
    CHAR *pchFile = NULL;
    BOOL fForceOverWrite;

    fForceOverWrite = 0 != (DECF_FORCEOVERWRITE & Flags);
    Flags &= ~DECF_FORCEOVERWRITE;

    if (CRYPT_STRING_BINARY == Flags)
    {
	pchFile = (CHAR *) pbIn;
	cchFile = cbIn;
    }
    else
    {
	hr = myCryptBinaryToStringA(pbIn, cbIn, Flags, &pchFile);
	_JumpIfError(hr, error, "myCryptBinaryToStringA");

	cchFile = strlen(pchFile);
    }

    // Write encoded certificate to file

    hFile = CreateFile(
		    pszfn,
		    GENERIC_WRITE,
		    0,
		    NULL,
		    CREATE_NEW,
		    0,
		    NULL);

    if (INVALID_HANDLE_VALUE == hFile)
    {
	hr = myHLastError();
	if (fForceOverWrite && HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
	{
	    hFile = CreateFile(
			    pszfn,
			    GENERIC_WRITE,
			    0,
			    NULL,
			    CREATE_ALWAYS,
			    0,
			    NULL);
	}
	if (INVALID_HANDLE_VALUE == hFile)
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "CreateFile", pszfn);
	}
    }
    if (FILE_TYPE_DISK != GetFileType(hFile))
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "GetFileType");
    }

    if (!WriteFile(hFile, pchFile, cchFile, &cbWritten, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "WriteFile");
    }
    if (cbWritten != cchFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
        DBGPRINT((
	    DBG_SS_ERROR,
	    "WriteFile wrote %u bytes, requested %u\n",
	    cbWritten,
	    cchFile));
	_JumpError(hr, error, "WriteFile(cbWritten)");
    }
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    if (CRYPT_STRING_BINARY != Flags && NULL != pchFile)
    {
	LocalFree(pchFile);
    }
#if DBG_CERTSRV
    if (S_OK != hr)
    {
	WCHAR awchr[cwcHRESULTSTRING];

        DBGPRINT((
	    DBG_SS_ERROR,
	    "EncodeToFileW(%" szFMTTSTR "): error = %ws\n",
	    pszfn,
	    myHResultToString(awchr, hr)));
    }
#endif
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\cainfoc.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfoc.h
//
// Contents:    Declaration of CCAInfo
//
// History:     16-dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "cainfop.h"
#include <certca.h>
/////////////////////////////////////////////////////////////////////////////
// certcli

class CCertTypeInfo;

class CCAInfo
{
public:
    CCAInfo()
    {
        m_cRef = 1;
        m_pNext = NULL;
        m_pProperties = NULL;
        m_pCertificate = NULL;
        m_bstrDN = NULL;
        m_fNew = TRUE;

        m_dwExpiration = 1;

        m_dwExpUnits = CA_UNITS_YEARS;

        m_pSD = NULL;

        m_dwFlags = 0;		// make sure high 16 bits are clear!
    }

    ~CCAInfo();

    DWORD Release();

    // Perform a search, returning a chain of CCAInfo objects. 
static HRESULT Find(
                    LPCWSTR wszQuery, 
                    LPCWSTR wszScope,
                    DWORD   dwFlags,
                    CCAInfo **ppCAInfo
                    );


static HRESULT FindDnsDomain(
                             LPCWSTR wszQuery, 
                             LPCWSTR wszDNSDomain,
                             DWORD   dwFlags,                             
                             CCAInfo **ppCAInfo
                             );

    // Perform a search, returning a chain of CCAInfo objects. 
static HRESULT Create(LPCWSTR wszName, LPCWSTR wszScope, CCAInfo **ppCAInfo);
static HRESULT CreateDnsDomain(LPCWSTR wszName, LPCWSTR wszDNSDomain, CCAInfo **ppCAInfo);

    HRESULT Update(VOID);

    HRESULT Delete(VOID);

    HRESULT Next(CCAInfo **ppCAInfo);

    DWORD Count()
    {
        if(m_pNext)
        {
            return m_pNext->Count()+1;
        }
        return 1;
    }

    HRESULT GetProperty(LPCWSTR wszPropertyName, LPWSTR **pawszProperties);
    HRESULT SetProperty(LPCWSTR wszPropertyName, LPWSTR *awszProperties);
    HRESULT FreeProperty(LPWSTR * awszProperties);

    DWORD GetFlags(VOID)
    {
        return m_dwFlags;
    }
    VOID SetFlags(DWORD dwFlags)
    {
        m_dwFlags = (m_dwFlags & ~CA_MASK_SETTABLE_FLAGS) | (dwFlags & CA_MASK_SETTABLE_FLAGS);
    }

    HRESULT GetCertificate(PCCERT_CONTEXT *ppCert);   
    HRESULT SetCertificate(PCCERT_CONTEXT pCert);

    HRESULT GetExpiration(DWORD *pdwExpiration, DWORD *pdwUnits);   
    HRESULT SetExpiration(DWORD dwExpiration, DWORD dwUnits);


    HRESULT EnumSupportedCertTypes(DWORD dwFlags, CCertTypeInfo **ppCertTypes);

    HRESULT EnumSupportedCertTypesEx(LPCWSTR wszScope, DWORD dwFlags, CCertTypeInfo **ppCertTypes);

    HRESULT AddCertType(CCertTypeInfo *pCertTypes);

    HRESULT RemoveCertType(CCertTypeInfo *pCertTypes);

    HRESULT SetSecurity(IN PSECURITY_DESCRIPTOR         pSD);
    HRESULT GetSecurity(OUT PSECURITY_DESCRIPTOR *     ppSD);


    HRESULT AccessCheck(
        IN HANDLE       ClientToken,
        IN DWORD        dwOption
        );

    LPCWSTR GetDN() { return m_bstrDN; }

protected:
	PCCERT_CONTEXT m_pCertificate;

    static HRESULT _ProcessFind(
                            LDAP *  pld,
                            LPCWSTR wszQuery, 
                            LPCWSTR wszScope,
                            DWORD   dwFlags,
                            CCAInfo **ppCAInfo);


    HRESULT _Cleanup();

    DWORD AddRef();

    CCAProperty *   m_pProperties;

    LONG            m_cRef;

    CCAInfo *       m_pNext;

    CERTSTR         m_bstrDN;

    BOOL            m_fNew;

    DWORD           m_dwExpiration;      

    DWORD           m_dwExpUnits;

    DWORD           m_dwFlags;


    PSECURITY_DESCRIPTOR    m_pSD;

private:
};

#define CA_PROP_FLAGS                 L"flags"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\ctnotify.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2000
//
// File:        ctnotify.cpp
//
// Contents:    Cert Type Change Notification APIS
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <cainfop.h>
#include <ctnotify.h>
#include <certca.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_CTNOTIFY_CPP__


static WCHAR * s_wszLocation = L"CN=Certificate Templates,CN=Public Key Services,CN=Services,";

//-----------------------------------------------------------------------
//
//  CertTypeQueryProc
//
//      The thread to recieve change notification from DS
//
//-----------------------------------------------------------------------
DWORD WINAPI CertTypeQueryProc(LPVOID lpParameter)
{
    CERTTYPE_QUERY_INFO     *pCertTypeQueryInfo=NULL;
    ULONG                   ldaperr=0;
	BOOL					fFailed=FALSE;

    LDAPMessage             *results = NULL;

    if(NULL==lpParameter)
        return FALSE;

    pCertTypeQueryInfo = (CERTTYPE_QUERY_INFO *)lpParameter;

    //we wait for the notifications
    while(TRUE)
    {
        ldaperr = ldap_result(
            pCertTypeQueryInfo->pldap, 
            pCertTypeQueryInfo->msgID,      // message identifier
            LDAP_MSG_ONE,                   // retrieve one message at a time
            NULL,                           // no timeout
            &results);                      // receives the search results

		fFailed=FALSE;

        if ((ldaperr == (ULONG) -1) || (ldaperr == 0) || ((results) == NULL)) 
		{
			fFailed=TRUE;
		}
		else
		{
			if(LDAP_SUCCESS != ldap_result2error(pCertTypeQueryInfo->pldap, results, FALSE))
			{
				fFailed=TRUE;
			}
		}
    
		if(TRUE == fFailed)
        {
			pCertTypeQueryInfo->hr = myHLdapError(pCertTypeQueryInfo->pldap, ldaperr, NULL);

			if(!FAILED(pCertTypeQueryInfo->hr))
				pCertTypeQueryInfo->hr=E_FAIL;

			_PrintIfError(pCertTypeQueryInfo->hr, "CertTypeQueryProc");

			if(results)
			{
				ldap_msgfree(results);
				results=NULL;
			}

			break;
        }

        //some change has happened.
        (pCertTypeQueryInfo->dwChangeSequence)++;

        //make sure that we will never return 0
        if(0 == (pCertTypeQueryInfo->dwChangeSequence))
        {
            (pCertTypeQueryInfo->dwChangeSequence)++;
        }

        ldap_msgfree(results);
        results=NULL;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
//
// CACertTypeRegisterQuery
//
//---------------------------------------------------------------------------
HRESULT
CACertTypeRegisterQuery(
    IN	DWORD,              // dwFlag
    IN  LPVOID              pvldap,
    OUT HCERTTYPEQUERY      *phCertTypeQuery)
{
    HRESULT                 hr=E_INVALIDARG;
    LDAPControl             simpleControl;
    PLDAPControl            controlArray[2];
    LPWSTR                  rgwszAttribs[2];
    ULONG                   ldaperr=0;    
    DWORD                   dwThreadID=0;
    LDAP                    *pldap=NULL;   

    CERTSTR                 bstrConfig = NULL;
    CERTSTR                 bstrCertTemplatesContainer = NULL;
    //memory is freed via the thread proc
    CERTTYPE_QUERY_INFO     *pCertTypeQueryInfo=NULL;


    //assign the input parameter
    pldap = (LDAP *)pvldap;   


    if(NULL==phCertTypeQuery)
	    _JumpError(hr, error, "NULL param");

    pCertTypeQueryInfo=(CERTTYPE_QUERY_INFO *)LocalAlloc(LPTR, sizeof(CERTTYPE_QUERY_INFO));

    if(NULL==pCertTypeQueryInfo)
    {
        hr=E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }

    memset(pCertTypeQueryInfo, 0, sizeof(CERTTYPE_QUERY_INFO));

    //we start the change sequence as 1
    pCertTypeQueryInfo->dwChangeSequence = 1;
	pCertTypeQueryInfo->hr=S_OK;

    //bind to DS
    if(pldap)
    {
        pCertTypeQueryInfo->pldap=pldap;
    }
    else
    {
        // retrieve the ldap handle
        hr = myDoesDSExist(TRUE);
	_JumpIfError(hr, error, "myDoesDSExist");

        hr = myRobustLdapBindEx(
                        0,		// dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
                        0,		// uVersion
			NULL,		// pwszDomainName
                        &pCertTypeQueryInfo->pldap, 
                        NULL);		// ppwszForestDNSName
	_JumpIfError(hr , error, "myRobustLdapBindEx");

        pCertTypeQueryInfo->fUnbind=TRUE;
    }

    // retrieve the config string
    hr = CAGetAuthoritativeDomainDn(pCertTypeQueryInfo->pldap, NULL, &bstrConfig);
    _JumpIfError(hr, error, "CAGetAuthoritativeDomainDn");

    //build the template container DN
    bstrCertTemplatesContainer = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation));
    if(bstrCertTemplatesContainer == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrCertTemplatesContainer, s_wszLocation);
    wcscat(bstrCertTemplatesContainer, bstrConfig);

    // Set up the change notification control.
    simpleControl.ldctl_oid = LDAP_SERVER_NOTIFICATION_OID_W;
    simpleControl.ldctl_iscritical = TRUE;
    simpleControl.ldctl_value.bv_len = 0;
    simpleControl.ldctl_value.bv_val = NULL;
    controlArray[0] = &simpleControl;
    controlArray[1] = NULL;

    rgwszAttribs[0] = L"cn";
    rgwszAttribs[1] = NULL;
 

    // Start a persistent asynchronous search.
    ldaperr   = ldap_search_ext( 
                     pCertTypeQueryInfo->pldap,
                     (PWCHAR) bstrCertTemplatesContainer,   // Template container DN
                     LDAP_SCOPE_ONELEVEL,
                     L"ObjectClass=*",
                     rgwszAttribs,                          // Attributes to retrieve
                     1,                                     // Retrieve attributes only
                     (PLDAPControl *) controlArray,         // Server size controls
                     NULL,                                  // Client controls
                     0,                                     // Timeout
                     0,                                     // Sizelimit
                     (PULONG)&(pCertTypeQueryInfo->msgID)   // Receives identifier for results
                      );

    if (LDAP_SUCCESS != ldaperr) 
    {
	hr = myHLdapError(pCertTypeQueryInfo->pldap, ldaperr, NULL);
	_JumpError(hr, error, "ldap_search_ext");
    }

    //start a thread to wait for the notification
    pCertTypeQueryInfo->hThread = CreateThread(
                            NULL,
                            0,
                            CertTypeQueryProc,
                            pCertTypeQueryInfo,
                            0,          //execute immediately
                            &dwThreadID);  

    if(NULL == pCertTypeQueryInfo->hThread)
    {
        hr=myHError(GetLastError());
	    _JumpError(hr, error, "CreateThread");
    }

    *phCertTypeQuery=pCertTypeQueryInfo;

    pCertTypeQueryInfo=NULL;

    hr=S_OK;

error:

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if(bstrCertTemplatesContainer)
    {
        CertFreeString(bstrCertTemplatesContainer);
    }

    if(pCertTypeQueryInfo)
    {
        if(pCertTypeQueryInfo->fUnbind)
        {
            if(pCertTypeQueryInfo->pldap)
                ldap_unbind(pCertTypeQueryInfo->pldap);
        }

        if(pCertTypeQueryInfo->hThread)
            CloseHandle(pCertTypeQueryInfo->hThread);

        LocalFree(pCertTypeQueryInfo);

	pCertTypeQueryInfo=NULL;
    }

    return hr;

}


//---------------------------------------------------------------------------
//
// CACertTypeQuery
//
//---------------------------------------------------------------------------
HRESULT
CACertTypeQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery,
    OUT DWORD           *pdwChangeSequence)
{
    CERTTYPE_QUERY_INFO *pCertTypeQueryInfo=NULL;

    if((NULL==pdwChangeSequence) || (NULL==hCertTypeQuery))
        return E_INVALIDARG;

    pCertTypeQueryInfo = (CERTTYPE_QUERY_INFO *)hCertTypeQuery;

    *pdwChangeSequence = pCertTypeQueryInfo->dwChangeSequence;

    return (pCertTypeQueryInfo->hr);
}



//---------------------------------------------------------------------------
//
// CACertTypeUnregisterQuery
//
//---------------------------------------------------------------------------
HRESULT
CACertTypeUnregisterQuery(
    IN	HCERTTYPEQUERY  hCertTypeQuery)
{
    CERTTYPE_QUERY_INFO *pCertTypeQueryInfo=NULL;
    ULONG               ldaperr=0;
    HRESULT             hr=E_INVALIDARG;
    DWORD               dwWait=0;

    if(NULL==hCertTypeQuery)
	    _JumpError(hr, error, "NULL param");

    pCertTypeQueryInfo = (CERTTYPE_QUERY_INFO *)hCertTypeQuery;

    if(NULL == (pCertTypeQueryInfo->pldap))
	    _JumpError(hr, error, "NULL pldap");

    //abandom the in-progress asynchronous ldap_result call
    ldaperr=ldap_abandon(pCertTypeQueryInfo->pldap, pCertTypeQueryInfo->msgID);

    if(LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError(pCertTypeQueryInfo->pldap, ldaperr, NULL);
	_JumpError(hr, error, "ldap_abandon");
    }

    //wait for the thread to finish
    dwWait = WaitForSingleObject(pCertTypeQueryInfo->hThread, INFINITE);

    if(WAIT_OBJECT_0 != dwWait)
    {
        hr = myHError(GetLastError());
        _JumpError(hr, error, "WaitForSingleObject");
    }

    hr=S_OK;

error:

    //free the memory
    if(pCertTypeQueryInfo)
    {
        if(pCertTypeQueryInfo->fUnbind)
        {
            if(pCertTypeQueryInfo->pldap)
                ldap_unbind(pCertTypeQueryInfo->pldap);
        }

        if(pCertTypeQueryInfo->hThread)
            CloseHandle(pCertTypeQueryInfo->hThread);

        LocalFree(pCertTypeQueryInfo);

	pCertTypeQueryInfo=NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\ctnotify.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ctnotify.h
//
// Contents:    Declaration of ctnotify.cpp
//
// History:     10-17-00 xiaohs  Created
//
//---------------------------------------------------------------------------
#ifndef __CTNOTIFY_H__
#define __CTNOTIFY_H__

typedef struct _CERTTYPE_QUERY_INFO
{
    DWORD       dwChangeSequence;
    BOOL        fUnbind;
    LDAP        *pldap;
    ULONG       msgID;
    HANDLE      hThread;
	HRESULT		hr;
}CERTTYPE_QUERY_INFO;


#endif //__CTNOTIFY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\cainfop.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cainfop.cpp
//
// Contents:
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <certca.h>
#include <lm.h>
#include <cainfop.h>
#include <cainfoc.h>


#include <winldap.h>
#include <ntlsa.h>
#include <dsgetdc.h>
#include <accctrl.h>

#include "certacl.h"
#include "oidmgr.h"
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_CAINFOP_CPP__

CRITICAL_SECTION g_csDomainSidCache;
extern BOOL g_fInitDone;

//we only keep one copy of the localSystem's sid
PSID g_pLocalSid=NULL;


#define DOMAIN_SID_CACHE_INC 10

typedef struct _DOMAIN_SID_CACHE
{
    LPWSTR wszDomain;
    PSID   pSid;
} DOMAIN_SID_CACHE, *PDOMAIN_SID_CACHE;

PDOMAIN_SID_CACHE g_DomainSidCache = NULL;
DWORD             g_cDomainSidCache = 0;
DWORD             g_cMaxDomainSidCache = 0;


ULONG g_cDomainCache = 0;
PDS_DOMAIN_TRUSTS g_pDomainCache = NULL;


LPWSTR            g_pwszEnterpriseRoot = NULL;
DWORD myGetEnterpriseDnsName(OUT LPWSTR *pwszDomain);

HRESULT
CAGetAuthoritativeDomainDn(
    IN  LDAP*   LdapHandle,
    OUT CERTSTR *DomainDn,
    OUT CERTSTR *ConfigDn
    )
/*++

Routine Description:

    This routine simply queries the operational attributes for the
    domaindn and configdn.

    The strings returned by this routine must be freed by the caller
    using RtlFreeHeap() using the process heap.

Parameters:

    LdapHandle    : a valid handle to an ldap session

    DomainDn      : a pointer to a string to be allocated in this routine

    ConfigDn      : a pointer to a string to be allocated in this routine

Return Values:

    An error from the win32 error space.

    ERROR_SUCCESS and

    Other operation errors.

--*/
{
    HRESULT     hr=E_FAIL;

    BSTR        bstrDomainDN=NULL;
    BSTR        bstrConfigDN=NULL; 

    hr = myGetAuthoritativeDomainDn(LdapHandle, &bstrDomainDN, &bstrConfigDN);
    _JumpIfError(hr, error, "myGetAuthoritativeDomainDn");

    //convert BSTR to CERTSTR
    if(DomainDn)
    {
        (*DomainDn) = CertAllocString(bstrDomainDN);

        if(NULL == (*DomainDn))
        {
            hr=E_OUTOFMEMORY;
            _JumpError(hr, error, "CertAllocString");
        }
    }

    if(ConfigDn)
    {
        (*ConfigDn) = CertAllocString(bstrConfigDN);

        if(NULL == (*ConfigDn))
        {
            hr=E_OUTOFMEMORY;

            if(DomainDn)
            {
                if(*DomainDn)
                {
                    CertFreeString(*DomainDn);
                    *DomainDn=NULL;
                }
            }
            _JumpError(hr, error, "CertAllocString");
        }
    }

    hr=S_OK;

error:

    if(bstrDomainDN)
        SysFreeString(bstrDomainDN);

    if(bstrConfigDN)
        SysFreeString(bstrConfigDN);

    return hr;
}


DWORD
DNStoRFC1779Name(WCHAR *rfcDomain,
                 ULONG *rfcDomainLength,
                 LPCWSTR dnsDomain)
/*++

Routine Description:

    This routine takes the DNS-style name of a domain controller and
    contructs the corresponding RFC1779 style name, using the
    domainComponent prefix.

Parameters:

    rfcDomain        - this is the destination string
    rfcDomainLength  - this is the length in wchars of rfcDomain
    dnsDomain        - NULL-terminated dns name.

Return Values:

    ERROR_SUCCESS if succesful;
    ERROR_INSUFFICIENT_BUFFER if there is not enough space in the dst string -
    rfcDomainLength will set to number of characters needed.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    WCHAR *NextToken;
    ULONG length = 1;   // include the null character
    WCHAR Buffer[DNS_MAX_NAME_LENGTH+1];

    if (!rfcDomainLength || !dnsDomain) {
        return ERROR_INVALID_PARAMETER;
    }

    if (wcslen(dnsDomain) > DNS_MAX_NAME_LENGTH) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlCopyMemory(Buffer, dnsDomain, (wcslen(dnsDomain)+1)*sizeof(WCHAR));

    if (rfcDomain && *rfcDomainLength > 0) {
        RtlZeroMemory(rfcDomain, *rfcDomainLength*sizeof(WCHAR));
    }

    //
    // Start contructing the string
    //
    NextToken = wcstok(Buffer, L".");

    if ( NextToken )
    {
        //
        // Append the intial DC=
        //
        length += 3;
        if ( length <= *rfcDomainLength && rfcDomain )
        {
            wcscpy(rfcDomain, L"DC=");
        }
    }

    while ( NextToken )
    {
        length += wcslen(NextToken);

        if (length <= *rfcDomainLength && rfcDomain)
        {
            wcscat(rfcDomain, NextToken);
        }

        NextToken = wcstok(NULL, L".");

        if ( NextToken )
        {
            length += 4;

            if (length <= *rfcDomainLength && rfcDomain)
            {
                wcscat(rfcDomain, L",DC=");
            }
        }
    }


    if ( length > *rfcDomainLength )
    {
        WinError = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Return how much space was needed
    //
    *rfcDomainLength = length;

    return WinError;

}


VOID
FreeSidCache()
{
    if(g_pDomainCache)
    {
        NetApiBufferFree(g_pDomainCache);
        g_pDomainCache = NULL;
    }
}

DWORD myUpdateDomainSidCache()
{
    if(g_pDomainCache)
    {
        NetApiBufferFree(g_pDomainCache);
        g_pDomainCache = NULL;
    }

    return DsEnumerateDomainTrusts(
        NULL,
        DS_DOMAIN_VALID_FLAGS,
        &g_pDomainCache,
        &g_cDomainCache);
}

// if not found, returns OK with NULL *ppSid
DWORD myFindDomainSidInCache(
    IN LPCWSTR pcwszDomainName,
    OUT PSID* ppSid)
{
    DWORD dwErr = ERROR_SUCCESS;

    for(ULONG c=0; c<g_cDomainCache; c++)
    {
        // if name matches Netbios or DNS name, return sid
        if(g_pDomainCache[c].DomainSid) // some entries don't have SID
        { 
            if((g_pDomainCache[c].NetbiosDomainName && // one of the names might be null
                0 == _wcsicmp(pcwszDomainName, 
                              g_pDomainCache[c].NetbiosDomainName)) ||
                (g_pDomainCache[c].DnsDomainName &&
                 0 == _wcsicmp(pcwszDomainName, 
                              g_pDomainCache[c].DnsDomainName)))
            {
                *ppSid = (PSID)LocalAlloc(
                    LMEM_FIXED, 
                    GetLengthSid(g_pDomainCache[c].DomainSid));
                if(*ppSid == NULL)
                {
                    dwErr = ERROR_OUTOFMEMORY;
                }
                else
                {
                    if(!CopySid(
                        GetLengthSid(g_pDomainCache[c].DomainSid), 
                        *ppSid, 
                        g_pDomainCache[c].DomainSid))
					{
						LocalFree(*ppSid);
						*ppSid=NULL;
						dwErr=GetLastError();
					}
                }
                break;
            }
        }
    }

    return dwErr;
}

DWORD
myGetSidFromDomain(
    IN LPWSTR wszDomain,
    OUT PSID *ppDomainSid)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (!g_fInitDone)
    {
	return((DWORD) HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED));
    }

    __try
    {
        EnterCriticalSection(&g_csDomainSidCache);
        if(wszDomain == NULL)
        {
            dwErr = myGetEnterpriseDnsName(&wszDomain);
            if(dwErr != ERROR_SUCCESS)
            {
            _LeaveError(dwErr, "myGetEnterpriseDnsName");
            }
        }

        dwErr = myFindDomainSidInCache(wszDomain, ppDomainSid);
        _LeaveIfError(dwErr, "myFindDomainSidInCache");
        
        if(NULL == *ppDomainSid)
        {
            // not found in cache, update and try again
            dwErr = myUpdateDomainSidCache();
            _LeaveIfError(dwErr, "myUpdateDomainSidCache");

            dwErr = myFindDomainSidInCache(wszDomain, ppDomainSid);
            _LeaveIfError(dwErr, "myUpdateDomainSidCache");

            if(NULL == *ppDomainSid)
            {
                dwErr = (DWORD) E_FAIL;
                _LeaveErrorStr(dwErr, "SID not found", wszDomain);
            }
        }

    }
    __except(dwErr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    LeaveCriticalSection(&g_csDomainSidCache);

    return dwErr;
}

// CACleanup is called multiple times!

VOID
CACleanup()
{
    if (NULL != g_pwszEnterpriseRoot)
    {
	LocalFree(g_pwszEnterpriseRoot);
	g_pwszEnterpriseRoot = NULL;
    }
    if (NULL != g_pLocalSid)
    {
	FreeSid(g_pLocalSid);
	g_pLocalSid = NULL;
    }
    if (NULL != g_pwszEnterpriseRootOID)
    {
	LocalFree(g_pwszEnterpriseRootOID);
	g_pwszEnterpriseRootOID = NULL;
    }
    FreeSidCache();
}


DWORD
myGetEnterpriseDnsName(
    OUT WCHAR **ppwszDomain)
{
    HRESULT hr;
    LSA_HANDLE hPolicy = NULL;
    POLICY_DNS_DOMAIN_INFO *pDomainInfo = NULL;

    if (NULL == g_pwszEnterpriseRoot)
    {
	LSA_OBJECT_ATTRIBUTES oa;
	SECURITY_QUALITY_OF_SERVICE sqos;
	NTSTATUS dwStatus;

	sqos.Length = sizeof(sqos);
	sqos.ImpersonationLevel = SecurityImpersonation;
	sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
	sqos.EffectiveOnly = FALSE;

	InitializeObjectAttributes(&oa, NULL, 0, NULL, NULL);
	oa.SecurityQualityOfService = &sqos;

	dwStatus = LsaOpenPolicy(
			    NULL,
			    &oa,
			    POLICY_VIEW_LOCAL_INFORMATION,
			    &hPolicy);
	hr = LsaNtStatusToWinError(dwStatus);
	_JumpIfError(hr, error, "LsaOpenPolicy");

	dwStatus = LsaQueryInformationPolicy(
				    hPolicy,
                                    PolicyDnsDomainInformation,
                                    (VOID **) &pDomainInfo);
	hr = LsaNtStatusToWinError(dwStatus);
	_JumpIfError(hr, error, "LsaNtStatusToWinError");

	if (0 >= pDomainInfo->DnsForestName.Length ||
	    NULL == pDomainInfo->DnsForestName.Buffer)
	{
	    hr = ERROR_CANT_ACCESS_DOMAIN_INFO;
	    _JumpError(hr, error, "DomainInfo");
	}

        hr = myDupString(
		    pDomainInfo->DnsForestName.Buffer,
		    &g_pwszEnterpriseRoot);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = myDupString(g_pwszEnterpriseRoot, ppwszDomain);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pDomainInfo)
    {
        LsaFreeMemory(pDomainInfo);
    }
    if (NULL != hPolicy)
    {
        LsaClose(hPolicy);
    }
    return(hr);
}


CCAProperty::CCAProperty(LPCWSTR wszName)
{
    m_awszValues = NULL;
    m_pNext = NULL;
    m_wszName = CertAllocString(wszName);
}


CCAProperty::~CCAProperty()
{
    _Cleanup();
}


HRESULT CCAProperty::_Cleanup()
{

    // NOTE: this should only be called via
    // DeleteChain

    if(m_awszValues)
    {
        LocalFree(m_awszValues);
        m_awszValues = NULL;
    }

    if(m_wszName)
    {
        CertFreeString(m_wszName);
        m_wszName = NULL;
    }

    m_pNext = NULL;
    return S_OK;

}


HRESULT CCAProperty::Find(LPCWSTR wszName, CCAProperty **ppCAProp)
{
    if((wszName == NULL) || (ppCAProp == NULL))
    {
        return E_POINTER;
    }

    if(this == NULL)
    {
        return E_POINTER;
    }

    if((m_wszName != NULL) &&(mylstrcmpiL(wszName, m_wszName) == 0))
    {
        *ppCAProp = this;
        return S_OK;
    }

    if(m_pNext)
    {
        return m_pNext->Find(wszName, ppCAProp);
    }
    // Didn't find one
    *ppCAProp = NULL;
    return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
}


HRESULT CCAProperty::Append(CCAProperty **ppCAPropChain, CCAProperty *pNewProp)
{
    CCAProperty *pCurrent;

    if((ppCAPropChain == NULL) || (pNewProp == NULL))
    {
        return E_POINTER;
    }

    if(*ppCAPropChain == NULL)
    {
        *ppCAPropChain = pNewProp;
        return S_OK;
    }

    pCurrent = *ppCAPropChain;

    while(pCurrent->m_pNext != NULL)
    {
        pCurrent = pCurrent->m_pNext;
    }

    pCurrent->m_pNext = pNewProp;

    return S_OK;

}


HRESULT CCAProperty::GetValue(LPWSTR **pawszProperties)
{
    HRESULT hr;
    LPWSTR *awsz;

    if(pawszProperties == NULL)
    {
        return E_POINTER;
    }
    awsz = m_awszValues;
    m_awszValues = NULL;
    hr = SetValue(awsz);
    *pawszProperties = m_awszValues;
    m_awszValues = awsz;
    if(hr != S_OK)
    {
        *pawszProperties = NULL;
    }
    return hr;
}


HRESULT CCAProperty::SetValue(LPWSTR *awszProperties)
{
    DWORD cbStringTotal = 0;
    DWORD cStrings=1;
    WCHAR **pwszAttr;
    WCHAR *wszCurString;

    if(m_awszValues)
    {
        LocalFree(m_awszValues);
        m_awszValues = NULL;
    }
    if(NULL == awszProperties)
    {
        return S_OK;
    }

    for(pwszAttr = awszProperties; *pwszAttr != NULL; pwszAttr++)
    {
        cStrings += 1;
        cbStringTotal += (wcslen(*pwszAttr) + 1)*sizeof(WCHAR);
    }
    m_awszValues = (WCHAR **)LocalAlloc(LMEM_FIXED, cStrings*sizeof(WCHAR *) + cbStringTotal);

    if(m_awszValues == NULL)
    {
        return E_OUTOFMEMORY;
    }

    wszCurString = (WCHAR *)(m_awszValues + cStrings);

    cStrings = 0;

    for(pwszAttr = awszProperties; *pwszAttr != NULL; pwszAttr++)
    {
        m_awszValues[cStrings] = wszCurString;
        wcscpy(wszCurString, *pwszAttr);
        wszCurString += wcslen(wszCurString) + 1;
        cStrings += 1;
    }

    m_awszValues[cStrings] = NULL;

    return S_OK;
}


HRESULT CCAProperty::DeleteChain(CCAProperty **ppCAProp)
{
    if(ppCAProp == NULL)
    {
        return E_POINTER;
    }
    if(*ppCAProp == NULL)
    {
        return S_OK;
    }
    DeleteChain(&(*ppCAProp)->m_pNext);

    delete *ppCAProp;
    return S_OK;

}

HRESULT CCAProperty::LoadFromRegValue(HKEY hkReg, LPCWSTR wszValue)
{
    DWORD err;
    DWORD dwType;
    DWORD dwSize;
    HRESULT hr = S_OK;
    WCHAR *wszValues = NULL;


    if(m_awszValues)
    {
        LocalFree(m_awszValues);
        m_awszValues = NULL;
    }

    if((hkReg == NULL ) || (wszValue == NULL))
    {
        return E_POINTER;
    }


    err = RegQueryValueEx(hkReg,
                    wszValue,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = myHError(err);
        goto error;
    }

	if(sizeof(WCHAR) != dwSize)
	{
		switch(dwType)
		{
			case REG_SZ:
				//protect registry corruption.  Add the NULL terminator
				m_awszValues = (WCHAR **)LocalAlloc(LPTR, 2*sizeof(WCHAR *) + dwSize + sizeof(WCHAR));
				if(m_awszValues == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto error;
				}
				err = RegQueryValueEx(hkReg,
								wszValue,
								NULL,
								&dwType,
								(PBYTE)(m_awszValues+2),
								&dwSize);

				if(ERROR_SUCCESS != err)
				{
					hr = myHError(err);
					goto error;
				}
				m_awszValues[0] = (WCHAR *)(m_awszValues+2);
				m_awszValues[1] = NULL;

				break;

			case REG_MULTI_SZ:
				{
					WCHAR  *wszCur;
					DWORD cStrings = 1;

					//add the double NULL terminator
					wszValues = (WCHAR *)LocalAlloc(LPTR, dwSize + sizeof(WCHAR) + sizeof(WCHAR));
					if(wszValues == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto error;
					}
					err = RegQueryValueEx(hkReg,
									wszValue,
									NULL,
									&dwType,
									(PBYTE)wszValues,
									&dwSize);

					if(ERROR_SUCCESS != err)
					{
						hr = myHError(err);
						goto error;
					}
					wszCur = wszValues;
					while(wcslen(wszCur) > 0)
					{
						cStrings++;
						wszCur += wcslen(wszCur)+1;
					}
					m_awszValues = (WCHAR **)LocalAlloc(LMEM_FIXED, cStrings*sizeof(WCHAR *) + dwSize + sizeof(WCHAR) + sizeof(WCHAR));
					if(m_awszValues == NULL)
					{
						hr = E_OUTOFMEMORY;
						goto error;
					}

					CopyMemory((PBYTE)(m_awszValues + cStrings), wszValues, dwSize + sizeof(WCHAR) + sizeof(WCHAR));
					wszCur = (WCHAR *)(m_awszValues + cStrings);
					cStrings = 0;
					while(wcslen(wszCur) > 0)
					{
						m_awszValues[cStrings] = wszCur;
						cStrings++;
						wszCur += wcslen(wszCur)+1;
					}
					m_awszValues[cStrings] = NULL;
					break;
				}
			default:
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				goto error;

		}
	}

error:

    if(wszValues)
    {
        LocalFree(wszValues);
    }
    return hr;
}


HRESULT CCAProperty::UpdateToRegValue(HKEY hkReg, LPCWSTR wszValue)
{
    DWORD err;
    CERTSTR bstrRegValue = NULL;
    HRESULT hr = S_OK;

    if((hkReg == NULL ) || (wszValue == NULL))
    {
        return E_POINTER;
    }


    if(m_awszValues == NULL)
    {
        bstrRegValue = CertAllocString(TEXT(""));
        if(bstrRegValue == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    }
    else
    {
        LPWSTR *pwszCur = m_awszValues;
        LPWSTR wszCopy = NULL;
        DWORD cValues = 0;

        while(*pwszCur)
        {
            cValues += wcslen(*pwszCur) + 1;
            pwszCur++;
        }
        cValues++;
        bstrRegValue = CertAllocStringLen(NULL, cValues);
        if(bstrRegValue == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        pwszCur = m_awszValues;
        wszCopy =  bstrRegValue;
        while(*pwszCur)
        {
            CopyMemory(wszCopy, *pwszCur, sizeof(WCHAR)*(wcslen(*pwszCur)+1));
            wszCopy += (wcslen(*pwszCur)+1);
            pwszCur++;
        }
        *wszCopy = NULL;
    }
    err = RegSetValueEx(hkReg,
                    wszValue,
                    NULL,
                    REG_MULTI_SZ,
                    (PBYTE)bstrRegValue,
                    CertStringByteLen(bstrRegValue));
    if(ERROR_SUCCESS != err )
    {
        hr = myHError(err);
        goto error;
    }

error:

    if(bstrRegValue)
    {
        CertFreeString(bstrRegValue);
    }

    return hr;
}

HRESULT CertFreeString(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return E_POINTER;
    }
    WCHAR *pData = (WCHAR *)(((PBYTE)cstrString)-sizeof(UINT));
    LocalFree(pData);
    return S_OK;
}

CERTSTR CertAllocString(LPCWSTR wszString)
{
    if(wszString == NULL)
    {
        return NULL;
    }
    return CertAllocStringLen(wszString, wcslen(wszString)+1);
}


CERTSTR CertAllocStringLen(LPCWSTR wszString, UINT len)
{
    CERTSTR szResult;
    szResult = CertAllocStringByteLen(NULL, len*sizeof(WCHAR));
    if (NULL != szResult && NULL != wszString)
    {
        CopyMemory(szResult, wszString, min(wcslen(wszString)+1, len)*sizeof(WCHAR));
    }

    return szResult;
}

CERTSTR CertAllocStringByteLen(LPCSTR szString, UINT len)
{
    PBYTE  pbResult;

    pbResult = (PBYTE)LocalAlloc(LMEM_FIXED, len + sizeof(UINT) + sizeof(WCHAR));
    if (NULL == pbResult)
        return NULL;

    *((UINT *)pbResult) = len;
    pbResult += sizeof(UINT);

    *((UNALIGNED WCHAR *)(pbResult+len)) = L'\0';
    if(szString)
    {
        CopyMemory(pbResult, szString, min(len, strlen(szString)+1));
    }

    return (CERTSTR)pbResult;
}

UINT    CertStringLen(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return 0;
    }
    return(*((UINT *)((PBYTE)cstrString - sizeof(UINT))))/sizeof(WCHAR);
}

UINT    CertStringByteLen(CERTSTR cstrString)
{
    if(cstrString == NULL)
    {
        return 0;
    }
    return(*((UINT *)((PBYTE)cstrString - sizeof(UINT))));
}





HRESULT CAAccessCheckp(HANDLE ClientToken, PSECURITY_DESCRIPTOR pSD)
{
    return CAAccessCheckpEx(ClientToken, pSD, CERTTYPE_ACCESS_CHECK_ENROLL);
}


HRESULT CAAccessCheckpEx(HANDLE ClientToken, PSECURITY_DESCRIPTOR pSD, DWORD dwOption)
{

    HRESULT hr = S_OK;
    HANDLE        hClientToken = NULL;
    HANDLE        hHandle = NULL;

    PRIVILEGE_SET ps;
    DWORD         dwPSSize = sizeof(ps);
    GENERIC_MAPPING AccessMapping;
    BOOL          fAccessAllowed = FALSE;
    DWORD         grantAccess;
    PTOKEN_USER    pUserInfo = NULL;
    DWORD         cbUserInfo = 0;
    SID_IDENTIFIER_AUTHORITY IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    OBJECT_TYPE_LIST   aObjectTypeList[] = {
                                                {
                                                    ACCESS_OBJECT_GUID, // Level
                                                    0,                  // Sbz
                                                    const_cast<GUID *>(&GUID_ENROLL)
                                                }
                                            };
    DWORD              cObjectTypeList = sizeof(aObjectTypeList)/sizeof(aObjectTypeList[0]);


    OBJECT_TYPE_LIST   aAutoEnrollList[] = {
                                                {
                                                    ACCESS_OBJECT_GUID, // Level
                                                    0,                  // Sbz
                                                    const_cast<GUID *>(&GUID_AUTOENROLL)
                                                }
                                            };
    DWORD              cAutoEnrollList = sizeof(aAutoEnrollList)/sizeof(aAutoEnrollList[0]);


    if(pSD == NULL)
    {
        hr = E_ACCESSDENIED;
        goto error;
    }

    if(ClientToken == NULL)
    {
        hHandle = GetCurrentThread();
        if (NULL == hHandle)
        {
            hr = myHLastError();
        }
        else
        {

            if (!OpenThreadToken(hHandle,
                                 TOKEN_QUERY,
                                 TRUE,  // open as self
                                 &hClientToken))
            {
		hr = myHLastError();
                CloseHandle(hHandle);
                hHandle = NULL;
            }
        }
        if(hr != S_OK)
        {
            hHandle = GetCurrentProcess();
            if (NULL == hHandle)
            {
		hr = myHLastError();
            }
            else
            {
                HANDLE hProcessToken = NULL;
                hr = S_OK;


                if (!OpenProcessToken(hHandle,
                                     TOKEN_DUPLICATE,
                                     &hProcessToken))
                {
		    hr = myHLastError();
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                else
                {
                    if(!DuplicateToken(hProcessToken,
                                   SecurityImpersonation,
                                   &hClientToken))
                    {
			hr = myHLastError();
                        CloseHandle(hHandle);
                        hHandle = NULL;
                    }
                    CloseHandle(hProcessToken);
                }
            }
        }
    }
    else
    {
        hClientToken = ClientToken;
    }


    // First, we check the special case.  If the ClientToken
    // primary SID is for Local System, then we get the
    // real domain relative sid for this machine

    GetTokenInformation(hClientToken, TokenUser, NULL, 0, &cbUserInfo);
    if(cbUserInfo == 0)
    {
	hr = myHLastError();
        goto error;
    }
    pUserInfo = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, cbUserInfo);
    if(pUserInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!GetTokenInformation(hClientToken, TokenUser, pUserInfo, cbUserInfo, &cbUserInfo))
    {
	hr = myHLastError();
        goto error;
    }

    // Check it see if we're local-system
    if(0 == (CERTTYPE_ACCESS_CHECK_NO_MAPPING & dwOption))
    { 
    if(NULL == g_pLocalSid)
    {
        if(!AllocateAndInitializeSid(&IDAuthorityNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0,0,0,0,0,0,0, &g_pLocalSid))
        {
	        hr = myHLastError();
            g_pLocalSid=NULL;
            goto error;
        }
    }

    if(EqualSid(g_pLocalSid, pUserInfo->User.Sid))
    {
        // This is local system.
        // Derive the real token

        if(hClientToken != ClientToken)
        {
            CloseHandle(hClientToken);
        }
        hClientToken = NULL;

        if(!myNetLogonUser(NULL, NULL, NULL, &hClientToken))
        {
	    hr = myHLastError();
            goto error;
        }
    }
    }

    if(CERTTYPE_ACCESS_CHECK_ENROLL & dwOption)
    {
        if(!AccessCheckByType(
		  pSD,                      // security descriptor
		  NULL,                     // SID of object being checked
		  hClientToken,             // handle to client access token
		  ACTRL_DS_CONTROL_ACCESS,  // requested access rights 
		  aObjectTypeList,  // array of object types
		  cObjectTypeList,  // number of object type elements
		  &AccessMapping,   // map generic to specific rights
		  &ps,              // receives privileges used
		  &dwPSSize,        // size of privilege-set buffer
		  &grantAccess,     // retrieves mask of granted rights
		  &fAccessAllowed)) // retrieves results of access check
{
            hr = myHLastError();
	    _JumpIfError(hr, error, "AccessCheckByType");
        }
    }
    else
    {
        if(0 == (CERTTYPE_ACCESS_CHECK_AUTO_ENROLL & dwOption))
        {
            hr=E_INVALIDARG;
	        goto error;
        }

        if(!AccessCheckByType(
		  pSD,                      // security descriptor
		  NULL,                     // SID of object being checked
		  hClientToken,             // handle to client access token
		  ACTRL_DS_CONTROL_ACCESS,  // requested access rights 
		  aAutoEnrollList,  // array of object types
		  cAutoEnrollList,  // number of object type elements
		  &AccessMapping,   // map generic to specific rights
		  &ps,              // receives privileges used
		  &dwPSSize,        // size of privilege-set buffer
		  &grantAccess,     // retrieves mask of granted rights
		  &fAccessAllowed)) // retrieves results of access check
{
            hr = myHLastError();
	    _JumpIfError(hr, error, "AccessCheckByType");
        }
    }

    if(fAccessAllowed)
    {
        hr = S_OK;
    }
    else
    {
	    hr = myHLastError();
    }


error:
    if(pUserInfo)
    {
        LocalFree(pUserInfo);
    }
    if(hHandle)
    {
        CloseHandle(hHandle);
    }
    if(hClientToken != ClientToken)
    {
        if(hClientToken)
        {
            CloseHandle(hClientToken);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//	File:		debug.cpp
//
//	Contents:	Debug sub system APIs implementation
//
//----------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define DBG_CERTSRV_DEBUG_PRINT

#ifdef DBG_CERTSRV_DEBUG_PRINT

#include <stdarg.h>
#include <ntverp.h>
#include <common.ver>
#include <psapi.h>

#define __dwFILE__	__dwFILE_CERTCLIB_DEBUG_CPP__


#define dwPRINTMASK_FREELOG  (DWORD) (~(DBG_SS_INFO | DBG_SS_MODLOAD | DBG_SS_NOQUIET))
#if DBG_CERTSRV
#define dwPRINTMASK_DEFAULT  dwPRINTMASK_FREELOG
#else
#define dwPRINTMASK_DEFAULT  0
#endif

DWORD g_dwPrintMask = dwPRINTMASK_DEFAULT;

CRITICAL_SECTION g_DBGCriticalSection;
BOOL g_fDBGCSInit = FALSE;

FILE *g_pfLog;
FNLOGSTRING *s_pfnLogString = NULL;


const char *
DbgGetSSString(
    IN DWORD dwSubSystemId)
{
    char const *psz = NULL;

    if (MAXDWORD != dwSubSystemId)
    {
	switch (dwSubSystemId & ~DBG_SS_INFO)
	{
	    case DBG_SS_ERROR:	   psz = "CertError";	break;
	    case DBG_SS_ASSERT:	   psz = "CertAssert";	break;
	    case DBG_SS_CERTHIER:  psz = "CertHier";	break;
	    case DBG_SS_CERTREQ:   psz = "CertReq";	break;
	    case DBG_SS_CERTUTIL:  psz = "CertUtil";	break;
	    case DBG_SS_CERTSRV:   psz = "CertSrv";	break;
	    case DBG_SS_CERTADM:   psz = "CertAdm";	break;
	    case DBG_SS_CERTCLI:   psz = "CertCli";	break;
	    case DBG_SS_CERTDB:	   psz = "CertDB";	break;
	    case DBG_SS_CERTENC:   psz = "CertEnc";	break;
	    case DBG_SS_CERTEXIT:  psz = "CertExit";	break;
	    case DBG_SS_CERTIF:	   psz = "CertIF";	break;
	    case DBG_SS_CERTMMC:   psz = "CertMMC";	break;
	    case DBG_SS_CERTOCM:   psz = "CertOCM";	break;
	    case DBG_SS_CERTPOL:   psz = "CertPol";	break;
	    case DBG_SS_CERTVIEW:  psz = "CertView";	break;
	    case DBG_SS_CERTBCLI:  psz = "CertBCli";	break;
	    case DBG_SS_CERTJET:   psz = "CertJet";	break;
	    case DBG_SS_CERTLIBXE: psz = "CertLibXE";	break;
	    case DBG_SS_CERTLIB:   psz = "CertLib";	break;
            case DBG_SS_AUDIT:     psz = "CertAudit";   break;
	    default:		   psz = "Cert";	break;
	}
    }
    return(psz);
}


DWORD
myatolx(
    char const *psz)
{
    DWORD dw = 0;

    while (isxdigit(*psz))
    {
	char ch = *psz++;

	if (isdigit(ch))
	{
	    ch -= '0';
	}
	else if (isupper(ch))
	{
	    ch += 10 - 'A';
	}
	else
	{
	    ch += 10 - 'a';
	}
	dw = (dw << 4) | ch;
    }
    return(dw);
}


VOID
DbgLogDateTime(
    IN CHAR const *pszPrefix)
{
    if (NULL != g_pfLog)
    {
	WCHAR *pwszDate;
	FILETIME ft;
	SYSTEMTIME st;

	fprintf(g_pfLog, "%hs: ", pszPrefix);
	GetSystemTime(&st);
	if (SystemTimeToFileTime(&st, &ft))
	{
	    if (S_OK == myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszDate))
	    {
		fprintf(g_pfLog, "%ws", pwszDate);
		LocalFree(pwszDate);
	    }
	}
	fprintf(g_pfLog, "\n");
    }
}


VOID
DbgCloseLogFile()
{
    if(g_fDBGCSInit)
    {
        EnterCriticalSection(&g_DBGCriticalSection);
        if (NULL != g_pfLog)
        {
	    DbgLogDateTime("Closed Log");
	    fflush(g_pfLog);
	    fclose(g_pfLog);
	    g_pfLog = NULL;
        }
        LeaveCriticalSection(&g_DBGCriticalSection);
    }
}


char const szHeader[] = "\n========================================================================\n";

VOID
DbgOpenLogFile(
    OPTIONAL IN CHAR const *pszFile)
{
    if (NULL != pszFile)
    {
	BOOL fAppend = FALSE;
	UINT cch;
	char aszLogFile[MAX_PATH];

	if ('+' == *pszFile)
	{
	    pszFile++;
	    fAppend = TRUE;
	}
	if (NULL == strchr(pszFile, '\\'))
	{
	    cch = GetWindowsDirectoryA(aszLogFile, ARRAYSIZE(aszLogFile));
	    if (0 != cch)
	    {
		if (L'\\' != aszLogFile[cch - 1])
		{
		    strcat(aszLogFile, "\\");
		}
		strcat(aszLogFile, pszFile);
		pszFile = aszLogFile;
	    }
	}

	DbgCloseLogFile();

	if (g_fDBGCSInit)
	{
	    EnterCriticalSection(&g_DBGCriticalSection);
	    while (TRUE)
	    {
		g_pfLog = fopen(pszFile, fAppend? "at" : "wt");
		if (NULL == g_pfLog)
		{
		    _PrintError(E_FAIL, "fopen(Log)");
		}
		else
		{
		    if (fAppend)
		    {
			DWORD cbLogMax = 0;
			char const *pszEnvVar;

			pszEnvVar = getenv(szCERTSRV_LOGMAX);
			if (NULL != pszEnvVar)
			{
			    cbLogMax = myatolx(pszEnvVar);
			}
			if (CBLOGMAXAPPEND > cbLogMax)
			{
			    cbLogMax = CBLOGMAXAPPEND;
			}
			if (0 == fseek(g_pfLog, 0L, SEEK_END) &&
			    MAXDWORD != cbLogMax)
			{
			    LONG lcbLog = ftell(g_pfLog);
			    
			    if (0 > lcbLog || cbLogMax < (DWORD) lcbLog)
			    {
				fclose(g_pfLog);
				g_pfLog = NULL;
				fAppend = FALSE;
				continue;
			    }
			}
			fwrite(szHeader, SZARRAYSIZE(szHeader), 1, g_pfLog);
		    }
		    DbgLogDateTime("Opened Log");
		    fflush(g_pfLog);
		}
		break;
	    }
	    LeaveCriticalSection(&g_DBGCriticalSection);
	}
    }
}


static BOOL s_fFirst = TRUE;

VOID
DbgTerminate(VOID)
{
    if (g_fDBGCSInit)
    {
	DeleteCriticalSection(&g_DBGCriticalSection);
	g_fDBGCSInit = FALSE;
	s_fFirst = TRUE;
    }
}


VOID
DbgInit(
    IN BOOL fOpenDefaultLog,
    IN BOOL fReinit)
{
    if (fReinit || s_fFirst)
    {
	__try
	{
	    char const *pszEnvVar;
	    WCHAR wszProcess[MAX_PATH];

	    if (s_fFirst)
	    {
		InitializeCriticalSection(&g_DBGCriticalSection);
		g_fDBGCSInit = TRUE;
		s_fFirst = FALSE;		// Prevent infinite recursion
	    }

	    wszProcess[0] = L'\0';
	    GetModuleBaseName(
			GetCurrentProcess(),
			GetModuleHandle(NULL),
			wszProcess,
			ARRAYSIZE(wszProcess));
	    wszProcess[ARRAYSIZE(wszProcess) - 1] = L'\0';
	    g_dwPrintMask = dwPRINTMASK_DEFAULT;
	    if (0 == _wcsicmp(wszProcess, L"sysocmgr.exe"))
	    {
		g_dwPrintMask = dwPRINTMASK_FREELOG;
	    }
	    pszEnvVar = getenv(szCERTSRV_DEBUG);
	    if (NULL != pszEnvVar)
	    {
		g_dwPrintMask = myatolx(pszEnvVar);
	    }
	    else
	    {
		HRESULT hr;
		WCHAR *pwszActiveCA = NULL;
		DWORD PrintMask;
		DWORD PrintMaskCA;
		BOOL fRegSet = FALSE;
		
		hr = myGetCertRegDWValue(
				    NULL,
				    NULL,
				    NULL,
				    wszREGCERTSRVDEBUG,
				    &PrintMask);
		if (S_OK == hr)
		{
		    fRegSet = TRUE;
		}
		else
		{
		    PrintMask = 0;
		}
		PrintMaskCA = 0;
		hr = myGetCertRegStrValue(
				    NULL,
				    NULL,
				    NULL,
				    wszREGACTIVE,
				    &pwszActiveCA);
		if (S_OK == hr)
		{
		    hr = myGetCertRegDWValue(
				    pwszActiveCA,
				    NULL,
				    NULL,
				    wszREGCERTSRVDEBUG,
				    &PrintMaskCA);
		    if (S_OK == hr)
		    {
			fRegSet = TRUE;
		    }
		    else
		    {
			PrintMaskCA = 0;
		    }
		    LocalFree(pwszActiveCA);
		}
		if (fRegSet)
		{
		    g_dwPrintMask = PrintMask | PrintMaskCA;
		}
	    }
	    if (fOpenDefaultLog && NULL == g_pfLog)
	    {
		pszEnvVar = getenv(szCERTSRV_LOGFILE);
		DbgOpenLogFile(pszEnvVar);
	    }
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}
    }
}


BOOL
DbgIsSSActive(
    IN DWORD dwSSIn)
{
    DbgInit(TRUE, FALSE);
    if (MAXDWORD == dwSSIn)
    {
	return(TRUE);
    }
    if ((DBG_SS_INFO & dwSSIn) && 0 == (DBG_SS_INFO & g_dwPrintMask))
    {
	return(FALSE);
    }
    return(0 != (~DBG_SS_INFO & g_dwPrintMask & dwSSIn));
}


VOID
DbgLogStringInit(
    IN FNLOGSTRING *pfnLogString)
{
    if (NULL == s_pfnLogString)
    {
	s_pfnLogString = pfnLogString;
    }
}


VOID
DbgPrintfInit(
    OPTIONAL IN CHAR const *pszFile)
{
    BOOL fOpenLog = TRUE;
    
    if (NULL != pszFile)
    {
	if (0 == strcmp("+", pszFile))	// reinitialize debug print mask only
	{
	    DbgInit(FALSE, TRUE);
	    fOpenLog = FALSE;
	}
	else if (0 == strcmp("-", pszFile)) // close log file only
	{
	    DbgCloseLogFile();
	    fOpenLog = FALSE;
	}
    }
    if (fOpenLog)
    {
	DbgInit(NULL == pszFile, FALSE);
	DbgOpenLogFile(pszFile);
	DbgLogFileVersion("certcli.dll", szCSVER_STR);
    }
}


VOID
fputsStripCR(
    IN char const *psz,
    IN FILE *pf)
{
    while ('\0' != *psz)
    {
	DWORD i;

	i = strcspn(psz, "\r");
	if (0 != i)
	{
	    fprintf(pf, "%.*hs", i, psz);
	    psz += i;
	}
	if ('\r' == *psz)
	{
	    psz++;
	}
    }
}


VOID
DbgConvertWszToSz(
    IN UINT CodePage,
    OUT CHAR *pchBuf,
    IN LONG cchBuf,
    IN WCHAR const *pwsz)
{
    LONG cch;

    CSASSERT(5 < cchBuf);	// assumes room for at least "...\n\0"
    cch = WideCharToMultiByte(
		    CodePage,
		    0,          // dwFlags
		    pwsz,
		    -1,		// cchWideChar, -1 => null terminated
		    pchBuf,
		    cchBuf,
		    NULL,
		    NULL);
    if (0 == cch)
    {
	char *pchEnd = &pchBuf[cchBuf - 1];
	char *pch = pchBuf;

	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    WCHAR wc = *pwsz;
	    if (0xff00 & wc)
	    {
		wc = L'?';
	    }
	    if (pch >= pchEnd)
	    {
		pch -= 4;
		strcpy(pch, "...\n");
		break;
	    }
	    *pch++ = (char) wc;
	}
	*pch = '\0';
    }
}


//+-------------------------------------------------------------------------
//
//  Function:  DbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------

#define CCH_DEBUGMAX	4096

int
DbgPrintfVW(
    IN DWORD dwSubSystemId,
    IN WCHAR const *pwszFmt,
    va_list arglist)
{
    char ach[CCH_DEBUGMAX];
    int cwc = 0;
    BOOL fCritSecEntered = FALSE;

    ach[0] = '\0';
    _try
    {
	WCHAR awc[CCH_DEBUGMAX];
	DWORD cwcOut;
	CHAR const *pszPrefix;
	DWORD cwcPrefix;
	BOOL fDebuggerPresent;
	HANDLE hStdOut;
	BOOL fRedirected = FALSE;

	cwcPrefix = 0;
	pszPrefix = DbgGetSSString(dwSubSystemId);
	if (NULL != pszPrefix)
	{
	    while ('\0' != *pszPrefix)
	    {
		awc[cwcPrefix++] = (WCHAR) *pszPrefix++;
	    }
	    awc[cwcPrefix++] = L':';
	    awc[cwcPrefix++] = L' ';
	}
	awc[cwcPrefix] = L'\0';

	cwc = _vsnwprintf(
		    &awc[cwcPrefix],
		    ARRAYSIZE(awc) - cwcPrefix,
		    pwszFmt,
		    arglist);
	awc[ARRAYSIZE(awc) - 1] = L'\0';
	if (0 > cwc)
	{
	    wcscpy(&awc[ARRAYSIZE(awc) - 5], L"...\n");
	    cwc = ARRAYSIZE(awc) - 1;
	}
	else
	{
	    cwc += cwcPrefix;
	}

	hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if (INVALID_HANDLE_VALUE != hStdOut)
	{
	    // time for output -- where are we going, to a file or the console?
	    
	    switch (~FILE_TYPE_REMOTE & GetFileType(hStdOut))
	    {
		//case FILE_TYPE_PIPE:
		//case FILE_TYPE_DISK:
		default:
		    // if redirected to a pipe or file, don't use WriteConsole;
		    // it drops redirected output on the floor
		    fRedirected = TRUE;
		    break;

		case FILE_TYPE_UNKNOWN:
		    hStdOut = INVALID_HANDLE_VALUE;
		    break;
		    
		case FILE_TYPE_CHAR:
		    break;
	    }
	}

	EnterCriticalSection(&g_DBGCriticalSection);
	fCritSecEntered = TRUE;
	fDebuggerPresent = IsDebuggerPresent();
	if (!fDebuggerPresent)
	{
	    if (hStdOut != INVALID_HANDLE_VALUE)
	    {
		if (!fRedirected)
		{
		    WriteConsole(hStdOut, awc, cwc, &cwcOut, NULL);
		}
		else
		{
		    // WriteConsole drops the output on the floor when stdout
		    // is redirected to a file.

		    DbgConvertWszToSz(GetACP(), ach, sizeof(ach), awc);
		    fputsStripCR(ach, stdout);
		    fflush(stdout);
		}
	    }
	}

	// Log files should be UTF8 (for both g_pfLog and (*s_pfnLogString)!)

	DbgConvertWszToSz(CP_UTF8, ach, sizeof(ach), awc);
	if (NULL != g_pfLog)
	{
	    fputsStripCR(ach, g_pfLog);
	    fflush(g_pfLog);
	}

	// Suppress debug prints in free builds unless a debugger is attached:

	if (fDebuggerPresent || 0 != dwPRINTMASK_DEFAULT)
	{
	    OutputDebugString(awc);
	}
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
	// return failure
	cwc = 0;
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_DBGCriticalSection);
    }

    // Log files should be UTF8 (for both g_pfLog and (*s_pfnLogString)!)

    if ('\0' != ach[0] && NULL != s_pfnLogString)
    {
	(*s_pfnLogString)(ach);
    }
    return(cwc);
}


int WINAPIV
DbgPrintfW(
    IN DWORD dwSubSystemId,
    IN WCHAR const *pwszFmt,
    ...)
{
    int cwc = 0;
    DWORD dwErr;
    va_list arglist;

    dwErr = GetLastError();
    if (DbgIsSSActive(dwSubSystemId))
    {
	va_start(arglist, pwszFmt);
	cwc = DbgPrintfVW(dwSubSystemId, pwszFmt, arglist);
	va_end(arglist);
    }
    SetLastError(dwErr);
    return(cwc);
}


int WINAPIV
DbgPrintf(
    IN DWORD dwSubSystemId,
    IN LPCSTR pszFmt,
    ...)
{
    int cch = 0;
    DWORD dwErr;
    va_list arglist;
    WCHAR *pwszFmt = NULL;

    dwErr = GetLastError();
    if (DbgIsSSActive(dwSubSystemId))
    {
	if (myConvertSzToWsz(&pwszFmt, pszFmt, -1))
	{
	    va_start(arglist, pszFmt);
	    cch = DbgPrintfVW(dwSubSystemId, pwszFmt, arglist);
	    va_end(arglist);
	}
    }
    if (NULL != pwszFmt)
    {
	LocalFree(pwszFmt);
    }
    SetLastError(dwErr);
    return(cch);
}

#endif // DBG_CERTSRV_DEBUG_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\certtype.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certtype.cpp
//
// Contents:    CCertTypeInfo implemenation
//
// History:     16-Dec-97       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "certtype.h"
#include "oidmgr.h"

#include <cainfop.h>
#include <certca.h>
#include <polreg.h>
#include <sddl.h>
#include <userenv.h>
#include <lm.h>

#include <certmgrd.h>
#include <dsgetdc.h>
#include <ntldap.h>
#include "certacl.h"
#include "csldap.h"
#include "accctrl.h"

#define __dwFILE__	__dwFILE_CERTCLIB_CERTTYPE_CPP__

#define MAX_UUID_STRING_LEN 40
#define MAX_DS_PATH_STRING_LEN 256

extern HINSTANCE g_hInstance;

// the attribute list that we retrieve from the DS
WCHAR *g_awszCTAttrs[] = {
                        CERTTYPE_PROP_CN,
                        CERTTYPE_PROP_DN,
                        CERTTYPE_PROP_FRIENDLY_NAME,
                        CERTTYPE_PROP_EXTENDED_KEY_USAGE,
                        CERTTYPE_PROP_CSP_LIST,
                        CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                        CERTTYPE_PROP_FLAGS,
                        CERTTYPE_PROP_DEFAULT_KEYSPEC,
                        CERTTYPE_SECURITY_DESCRIPTOR_NAME,
                        CERTTYPE_PROP_KU,
                        CERTTYPE_PROP_MAX_DEPTH,
                        CERTTYPE_PROP_EXPIRATION,
                        CERTTYPE_PROP_OVERLAP,
                        CERTTYPE_PROP_REVISION,
                        CERTTYPE_PROP_MINOR_REVISION,        //starting of the V2 templates
                        CERTTYPE_PROP_RA_SIGNATURE,		
                        CERTTYPE_RPOP_ENROLLMENT_FLAG,	
                        CERTTYPE_PROP_PRIVATE_KEY_FLAG,	
                        CERTTYPE_PROP_NAME_FLAG,			
                        CERTTYPE_PROP_MIN_KEY_SIZE,		
                        CERTTYPE_PROP_SCHEMA_VERSION,	
                        CERTTYPE_PROP_OID,				
                        CERTTYPE_PROP_SUPERSEDE,			
                        CERTTYPE_PROP_RA_POLICY,			
                        CERTTYPE_PROP_POLICY,
                        CERTTYPE_PROP_RA_APPLICATION_POLICY,
                        CERTTYPE_PROP_APPLICATION_POLICY,
                        NULL};


// the attributes that can be mapped directly to the property
WCHAR *g_awszCTNamedProps[] = {
                        CERTTYPE_PROP_CN,
                        CERTTYPE_PROP_DN,
                        CERTTYPE_PROP_FRIENDLY_NAME,
                        CERTTYPE_PROP_EXTENDED_KEY_USAGE,
                        CERTTYPE_PROP_CRITICAL_EXTENSIONS,
                        NULL};

static WCHAR * s_wszLocation = L"CN=Certificate Templates,CN=Public Key Services,CN=Services,";

//
// This struct is used for _UpdateToDs.
//
typedef struct _CERT_TYPE_PROP_MOD
{
	LDAPMod	modData;	
	WCHAR	wszData[16];	//used by DWORD properties
	WCHAR	*awszData[2];
	DWORD	dwData;
} CERT_TYPE_PROP_MOD;

typedef struct _CERT_TYPE_PROP_INFO
{
	LPWSTR					pwszProperty;
	BOOL					fStringProperty;
} CERT_TYPE_PROP_INFO;

//v2 template attributes
CERT_TYPE_PROP_INFO	g_CTV2Properties[]={
    CERTTYPE_PROP_MINOR_REVISION,           FALSE,
	CERTTYPE_PROP_RA_SIGNATURE,				FALSE,		
	CERTTYPE_RPOP_ENROLLMENT_FLAG,			FALSE,	
	CERTTYPE_PROP_PRIVATE_KEY_FLAG,			FALSE,	
	CERTTYPE_PROP_NAME_FLAG,				FALSE,			
	CERTTYPE_PROP_MIN_KEY_SIZE,				FALSE,		
	CERTTYPE_PROP_SCHEMA_VERSION,			FALSE,	
	CERTTYPE_PROP_SUPERSEDE,				TRUE,			
	CERTTYPE_PROP_POLICY,					TRUE,
	CERTTYPE_PROP_OID,						TRUE,
	CERTTYPE_PROP_RA_POLICY,				TRUE,
    CERTTYPE_PROP_RA_APPLICATION_POLICY,    TRUE,
    CERTTYPE_PROP_APPLICATION_POLICY,       TRUE,
};	

DWORD	g_CTV2PropertiesCount=sizeof(g_CTV2Properties)/sizeof(g_CTV2Properties[0]);

#define	V2_PROPERTY_COUNT					13


//the following structure are for cert tempalte flag mappings
typedef struct _CERT_TYPE_FLAG_MAP
{
    DWORD   dwOldFlag;
    DWORD   dwNewFlag;
}CERT_TYPE_FLAG_MAP;


//enrollment flags
CERT_TYPE_FLAG_MAP  g_rgdwEnrollFlagMap[]={
    CT_FLAG_PUBLISH_TO_DS,                  CT_FLAG_PUBLISH_TO_DS,
    CT_FLAG_AUTO_ENROLLMENT,                CT_FLAG_AUTO_ENROLLMENT,
};


DWORD   g_cEnrollFlagMap=sizeof(g_rgdwEnrollFlagMap)/sizeof(g_rgdwEnrollFlagMap[0]);

//subject name flags
CERT_TYPE_FLAG_MAP  g_rgdwSubjectFlagMap[]={
    CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,      CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
    CT_FLAG_ADD_EMAIL,                      CT_FLAG_SUBJECT_REQUIRE_EMAIL | CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL,
    CT_FLAG_ADD_OBJ_GUID,                   CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID,

};


DWORD   g_cSubjectFlagMap=sizeof(g_rgdwSubjectFlagMap)/sizeof(g_rgdwSubjectFlagMap[0]);

//private key flags
CERT_TYPE_FLAG_MAP  g_rgdwPrivateKeyFlagMap[]={
    CT_FLAG_EXPORTABLE_KEY,                 CT_FLAG_EXPORTABLE_KEY,
};


DWORD   g_cPrivateKeyFlagMap=sizeof(g_rgdwPrivateKeyFlagMap)/sizeof(g_rgdwPrivateKeyFlagMap[0]);


//********************************************************************************
//
//      Default OIDs to install
//
//********************************************************************************
CERT_DEFAULT_OID_INFO g_rgDefaultOIDInfo[]={

    L"1.400", IDS_LOW_ASSURANCE_DISPLAY_NAME,    CERT_OID_TYPE_ISSUER_POLICY,
    L"1.401", IDS_MEDIUM_ASSURANCE_DISPLAY_NAME, CERT_OID_TYPE_ISSUER_POLICY,
    L"1.402", IDS_HIGH_ASSURANCE_DISPLAY_NAME,   CERT_OID_TYPE_ISSUER_POLICY,
};

DWORD   g_cDefaultOIDInfo=sizeof(g_rgDefaultOIDInfo)/sizeof(g_rgDefaultOIDInfo[0]);



//********************************************************************************
//
//      The certificate template description search table
//
//********************************************************************************
CERT_TYPE_DESCRIPTION	g_CTDescriptions[]={
    {
        0,
        CT_FLAG_PUBLISH_TO_KRA_CONTAINER,
        0,
        IDS_KRA_DESCRIPTION,
    },
    {
        CT_FLAG_IS_CROSS_CA,
        0,
        0,
        IDS_CROSS_CA_DESCRIPTION,
    },
    {
        CT_FLAG_IS_CA | CT_FLAG_MACHINE_TYPE,
        0,
        0,
        IDS_CA_DESCRIPTION,
    },
    {
        CT_FLAG_MACHINE_TYPE,
        0,
        CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID,
        IDS_EMAIL_REPLICATION_DESCRIPTION,
    },
    {
        CT_FLAG_MACHINE_TYPE,
        0,
        0,
        IDS_MACHINE_DESCRIPTION,
    },
    {
        0,
        0,
        0,
        IDS_END_USER_DESCRIPTION,
    }
};

DWORD	g_CTDescriptionCount=sizeof(g_CTDescriptions)/sizeof(g_CTDescriptions[0]);


LONG
ctRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD Reserved,
    IN LPWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition)
{
    DWORD err;
    HKEY hKeyT = NULL;
    
    if (HKEY_CURRENT_USER == hKey)
    {
	err = RegOpenCurrentUser(samDesired, &hKeyT);
	_JumpIfError(err, error, "RegOpenCurrentUser");

	hKey = hKeyT;
    }
    CSASSERT(NULL != lpSubKey);
    err = RegCreateKeyEx(
		    hKey,
		    lpSubKey,
		    Reserved,
		    lpClass,
		    dwOptions,
		    samDesired,
		    lpSecurityAttributes,
		    phkResult,
		    lpdwDisposition);
    _JumpIfError(err, error, "RegCreateKeyEx");

error:
    if (NULL != hKeyT)
    {
        RegCloseKey(hKeyT);
    }
    return(err);
}


LONG
ctRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult)
{
    DWORD err;
    HKEY hKeyT = NULL;
    
    if (HKEY_CURRENT_USER == hKey)
    {
	err = RegOpenCurrentUser(samDesired, &hKeyT);
	_JumpIfError(err, error, "RegOpenCurrentUser");

	hKey = hKeyT;
    }
    CSASSERT(NULL != lpSubKey);
    err = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);
    _JumpIfError(err, error, "RegOpenKeyEx");

error:
    if (NULL != hKeyT)
    {
        RegCloseKey(hKeyT);
    }
    return(err);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::~CCertTypeInfo -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertTypeInfo::~CCertTypeInfo()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_Cleanup()
{

    CCertTypeInfo *pNext = m_pNext;

    // Remove this one from the chain.
    if(m_pLast)
    {
        m_pLast->m_pNext = m_pNext;
    }
    if(m_pNext)
    {
        m_pNext->m_pLast = m_pLast;
    }
    m_pNext = NULL;
    m_pLast = NULL;
    if(m_KeyUsage.pbData)
    {
        LocalFree(m_KeyUsage.pbData);
        m_KeyUsage.pbData = NULL;
        m_KeyUsage.cbData = 0;
    }


    CCAProperty::DeleteChain(&m_pProperties);

    if(m_bstrType)
    {
        CertFreeString(m_bstrType);
        m_bstrType = NULL;
    }

    if(m_pSD)
    {
        LocalFree(m_pSD);
        m_pSD = NULL;
    }

    if(pNext)
    {
        // Release the next one
        pNext->Release();
    }

    return(S_OK);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::AddRef -- add reference
//
//
//+--------------------------------------------------------------------------

DWORD CCertTypeInfo::AddRef()
{

    return(InterlockedIncrement(&m_cRef));
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_Append --
//
//
//+--------------------------------------------------------------------------

CCertTypeInfo *
CCertTypeInfo::_Append(CCertTypeInfo **ppCertTypeInfo, CCertTypeInfo *pInfo)
{
    CCertTypeInfo ** ppCurrent = ppCertTypeInfo;


    while(*ppCurrent)
    {
        ppCurrent = &(*ppCurrent)->m_pNext;
    }
    *ppCurrent = pInfo;

    return *ppCurrent;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_FilterByFlags --
//
//
//+--------------------------------------------------------------------------

CCertTypeInfo *
CCertTypeInfo::_FilterByFlags(CCertTypeInfo **ppCertTypeInfo, DWORD dwFlags)
{

    CCertTypeInfo * pCTCurrent = NULL,
                  * pCTNext = NULL;

    if(ppCertTypeInfo == NULL)
    {
        return NULL;
    }

    pCTCurrent = *ppCertTypeInfo;
    *ppCertTypeInfo = NULL;

    while(pCTCurrent != NULL)
    {
        // Ownership of the pCTCurrent Reference is transfered
        // ot pCTNext here.
        pCTNext = pCTCurrent->m_pNext;
        pCTCurrent->m_pNext = NULL;
        pCTCurrent->m_pLast = NULL;

        if(((dwFlags & CT_ENUM_MACHINE_TYPES) != 0) &&
            ((pCTCurrent->m_dwFlags & CT_FLAG_MACHINE_TYPE)!= 0))
        {
            _Append(ppCertTypeInfo, pCTCurrent);
            pCTCurrent = NULL;
        }
        else if (((dwFlags & CT_ENUM_USER_TYPES) != 0) &&
                 ((pCTCurrent->m_dwFlags & CT_FLAG_MACHINE_TYPE) == 0))
        {
            _Append(ppCertTypeInfo, pCTCurrent);
            pCTCurrent = NULL;
        }

        if(pCTCurrent)
        {
            pCTCurrent->Release();
        }
        pCTCurrent = pCTNext;
    }

    return *ppCertTypeInfo;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::Release -- release reference
//
//
//+--------------------------------------------------------------------------

DWORD CCertTypeInfo::Release()
{
    DWORD cRef;
    if(0 == (cRef = InterlockedDecrement(&m_cRef)))
    {
        delete this;
    }
    return cRef;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadFromRegBase -- Load a certificate type object from the
// registry.
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadFromRegBase(LPCWSTR wszType, HKEY hCertTypes)
{
    CCAProperty     *pProp = NULL;
    HRESULT         hr = S_OK;
    DWORD           err;
    DWORD           iIndex;

    DWORD           dwType=0;
    DWORD           dwSize=0;
    DWORD           dwValue=0;
    HKEY            hkCertType = NULL;

    err = RegOpenKeyEx(hCertTypes,
                       wszType,
                       0,
                       KEY_ENUMERATE_SUB_KEYS |
                       KEY_EXECUTE |
                       KEY_QUERY_VALUE,
                       &hkCertType);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    pProp = new CCAProperty(CERTTYPE_PROP_FRIENDLY_NAME);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszDISPNAME);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }
    pProp = new CCAProperty(CERTTYPE_PROP_CSP_LIST);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszCSPLIST);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    pProp = new CCAProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszEXTKEYUSAGE);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }
    pProp = new CCAProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS);
    if(pProp == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = pProp->LoadFromRegValue(hkCertType, wszCRITICALEXTENSIONS);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = CCAProperty::Append(&m_pProperties, pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    pProp = NULL;

    err = RegQueryValueEx(hkCertType,
                    wszKEYUSAGE,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    m_KeyUsage.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, dwSize);
    if(m_KeyUsage.pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    err = RegQueryValueEx(hkCertType,
                    wszKEYUSAGE,
                    NULL,
                    &dwType,
                    m_KeyUsage.pbData,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    m_KeyUsage.cbData = dwSize;
    m_KeyUsage.cUnusedBits = 0;


    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszCTFLAGS,
                    NULL,
                    &dwType,
                    (PBYTE)&m_dwFlags,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_DWORD)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }
    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszCTREVISION,
                    NULL,
                    &dwType,
                    (PBYTE)&m_Revision,
                    &dwSize);

    if(err == ERROR_FILE_NOT_FOUND)
    {
        m_Revision = 0;
    }
    else
    {
        if(ERROR_SUCCESS != err)
        {
            hr = HRESULT_FROM_WIN32(err);
            goto error;
        }
        if(dwType != REG_DWORD)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            goto error;
        }
    }

    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszCTKEYSPEC,
                    NULL,
                    &dwType,
                    (PBYTE)&m_dwKeySpec,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_DWORD)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }


        // Get Depth
    dwSize = sizeof(DWORD);
    err = RegQueryValueEx(hkCertType,
                    wszBASICCONSTLEN,
                    NULL,
                    &dwType,
                    (PBYTE)&m_BasicConstraints.dwPathLenConstraint,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    m_BasicConstraints.fPathLenConstraint =
        (m_BasicConstraints.dwPathLenConstraint != -1);


    if(dwType != REG_DWORD)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    dwSize = sizeof(FILETIME);
    err = RegQueryValueEx(hkCertType,
                    wszEXPIRATION,
                    NULL,
                    &dwType,
                    (PBYTE)&m_ftExpiration,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    dwSize = sizeof(FILETIME);
    err = RegQueryValueEx(hkCertType,
                    wszOVERLAP,
                    NULL,
                    &dwType,
                    (PBYTE)&m_ftOverlap,
                    &dwSize);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    if(dwType != REG_BINARY)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    err = RegQueryValueEx(hkCertType,
                    wszSECURITY,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize);

    if((err == ERROR_SUCCESS) && (dwSize > 0))
    {

        if(dwType != REG_BINARY)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            goto error;
        }

        m_pSD = LocalAlloc(LMEM_FIXED, dwSize);
        if(m_pSD == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        err = RegQueryValueEx(hkCertType,
                        wszSECURITY,
                        NULL,
                        &dwType,
                        (PBYTE)m_pSD,
                        &dwSize);

        if((ERROR_SUCCESS != err) || (!IsValidSecurityDescriptor(m_pSD)))
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
            hr = HRESULT_FROM_WIN32(err);
            goto error;
        }
    }
	else
	{
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
	}

    m_fNew = FALSE;

    //we now retrieve the V2 template properties if there exits V2 properties
    dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == RegQueryValueEx(hkCertType, CERTTYPE_PROP_SCHEMA_VERSION, NULL,
                        &dwType, (PBYTE)&dwValue, &dwSize))
    {

        pProp=NULL;
        dwType=0;
        dwSize=0;
        dwValue=0;
        hr=S_OK;

        for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
        {
            if(g_CTV2Properties[iIndex].fStringProperty)
            {
                pProp = new CCAProperty(g_CTV2Properties[iIndex].pwszProperty);
                if(pProp == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }

                hr = pProp->LoadFromRegValue(hkCertType, g_CTV2Properties[iIndex].pwszProperty);
                if(hr != S_OK)
                {
                    goto error;
                }

                hr = CCAProperty::Append(&m_pProperties, pProp);
                if(hr != S_OK)
                {
                    goto error;
                }

                pProp=NULL;
            }
            else
            {
                //we are dealing with DWORD
                dwSize = sizeof(DWORD);
                err = RegQueryValueEx(hkCertType,
                                g_CTV2Properties[iIndex].pwszProperty,
                                NULL,
                                &dwType,
                                (PBYTE)&dwValue,
                                &dwSize);

                if(ERROR_SUCCESS != err)
                {
                    hr = HRESULT_FROM_WIN32(err);
                    goto error;
                }

                if(dwType != REG_DWORD)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    goto error;
                }

                 //assign dwValue to the corresponding data members
			    if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
				    m_dwMinorRevision = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
				    m_dwRASignature = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
				    m_dwEnrollmentFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
				    m_dwPrivateKeyFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
				    m_dwCertificateNameFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
				    m_dwMinimalKeySize = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
				    m_dwSchemaVersion = dwValue;
			    else
			    {
				    hr=E_UNEXPECTED;
				    goto error;
			    }

                dwType=0;
                dwValue=0;
            }
        }
    }

    hr=S_OK;

error:

    if(pProp)
    {
        CCAProperty::DeleteChain(&pProp);
    }

    if(hkCertType)
    {
        RegCloseKey(hkCertType);
    }

    return hr;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadCachedCTFromReg -- Load a certificate type object from the
// Registry based DS cache.
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadCachedCTFromReg(LPCWSTR wszType, HKEY hRoot)
{
    HRESULT      hr = S_OK;
    DWORD        err;

    HKEY         hkCertTypes = NULL;
    WCHAR        *awszName[2] ;



    err = ctRegOpenKeyEx(hRoot,
                       wszCERTTYPECACHE,
                       0,
                       KEY_ENUMERATE_SUB_KEYS |
                       KEY_EXECUTE |
                       KEY_QUERY_VALUE,
                       &hkCertTypes);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


	hr = _LoadFromRegBase(wszType, hkCertTypes);

	if(hr != S_OK)
	{
		goto error;
	}

    //
    // Derive the CN
    //
    //


    m_bstrType = CertAllocString(wszType);

	if(NULL == m_bstrType)
	{
		hr=E_OUTOFMEMORY;
		goto error;
	}

    awszName[0] = (LPWSTR)m_bstrType;
    awszName[1] = NULL;
    SetProperty(CERTTYPE_PROP_CN, awszName);


    awszName[0] = (LPWSTR)wszType;
    awszName[1] = NULL;
    SetProperty(CERTTYPE_PROP_DN, awszName);

    hr=S_OK;


error:

    if(hkCertTypes)
    {
        RegCloseKey(hkCertTypes);
    }

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_SetWszzProperty --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_SetWszzProperty(
    IN WCHAR const *pwszPropertyName,
    OPTIONAL IN WCHAR const *pwszzPropertyValue)
{
    HRESULT hr;
    WCHAR *rgpwsz[MAX_DEFAULT_STRING_COUNT];
    DWORD iIndex = 0;

    if (NULL != pwszzPropertyValue)
    {
        for ( ;
	     L'\0' != *pwszzPropertyValue;
	     pwszzPropertyValue += wcslen(pwszzPropertyValue) + 1)
        {
            rgpwsz[iIndex++] = const_cast<WCHAR *>(pwszzPropertyValue);
	    if (iIndex >= ARRAYSIZE(rgpwsz))
            {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "too many strings");
            }
        }
	rgpwsz[iIndex] = NULL;
    }
    hr = SetProperty(pwszPropertyName, 0 == iIndex? NULL : rgpwsz);
    _JumpIfError(hr, error, "SetProperty");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadFromDefaults --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadFromDefaults(
    PCERT_TYPE_DEFAULT pDefault,
    LPWSTR            wszDomain)
{
    HRESULT hr;
    WCHAR        *awszData[MAX_DEFAULT_STRING_COUNT];
    WCHAR        wszFriendlyName[MAX_DEFAULT_FRIENDLY_NAME];
    LPWSTR       wszDomainSid = NULL;
    PSID         pDomainSid = NULL;
    LPWSTR       wszFormattedSD = NULL;
    LPWSTR       pwszDefaultOID=NULL;
    WCHAR        **papwsz;

    if (NULL == pDefault)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    //CN
    m_bstrType = CertAllocString(pDefault->wszName);
    if (NULL == m_bstrType)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CertAllocString");
    }

    awszData[0] = pDefault->wszName;
    awszData[1] = NULL;
    hr = SetProperty(CERTTYPE_PROP_CN, awszData);
    _JumpIfError(hr, error, "SetProperty");

    //FriendlyName
    papwsz = NULL;
    if(0 != pDefault->idFriendlyName)
    {
        if (!::LoadString(
		    g_hInstance,
                    pDefault->idFriendlyName,
                    wszFriendlyName,
                    ARRAYSIZE(wszFriendlyName)))
        {
	    hr = myHLastError();
	    _JumpError(hr, error, "LoadString");
        }
	awszData[0] = wszFriendlyName;
	awszData[1] = NULL;
	papwsz = awszData;
    }
    hr = SetProperty(CERTTYPE_PROP_FRIENDLY_NAME, papwsz);
    _JumpIfError(hr, error, "SetProperty");

    hr = _SetWszzProperty(CERTTYPE_PROP_CSP_LIST, pDefault->wszCSPs);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, pDefault->wszEKU);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_CRITICAL_EXTENSIONS,
		    pDefault->wszCriticalExt);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_SUPERSEDE,
		    pDefault->wszSupersedeTemplates);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(CERTTYPE_PROP_RA_POLICY, pDefault->wszRAPolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_RA_APPLICATION_POLICY,
		    pDefault->wszRAAppPolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_POLICY,
		    pDefault->wszCertificatePolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    hr = _SetWszzProperty(
		    CERTTYPE_PROP_APPLICATION_POLICY,
		    pDefault->wszCertificateAppPolicy);
    _JumpIfError(hr, error, "_SetWszzProperty");

    //Temmplate OID
    papwsz = awszData;
    if (CT_FLAG_IS_DEFAULT & pDefault->dwFlags)
    {
        // We concatenate the predefined oid with the enterprise root.
        // Consider the NULL case valid since we should work with W2K schema

        hr = CAOIDBuildOID(0, pDefault->wszOID, &pwszDefaultOID);
	    //_JumpIfError(hr, error, "CAOIDBuildOID");
        if(S_OK != hr)
	{
	    papwsz = NULL;
	}
        else
	{
            awszData[0] = pwszDefaultOID;
	}
    }
    else
    {
        awszData[0] = pDefault->wszOID;
    }
    awszData[1] = NULL;
    hr = SetProperty(CERTTYPE_PROP_OID, papwsz);
    _JumpIfError(hr, error, "SetProperty");

    //key usages
    m_KeyUsage.pbData = (BYTE *) LocalAlloc(LMEM_FIXED, sizeof(pDefault->bKU));
    if (NULL == m_KeyUsage.pbData)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(m_KeyUsage.pbData, &pDefault->bKU, sizeof(pDefault->bKU));
    m_KeyUsage.cbData = sizeof(pDefault->bKU);
    m_KeyUsage.cUnusedBits = 0;

    //dw_Properties
    m_dwFlags = pDefault->dwFlags;
    m_Revision = pDefault->dwRevision;
    m_dwKeySpec = pDefault->dwKeySpec;
    m_dwMinorRevision = pDefault->dwMinorRevision;
    m_dwEnrollmentFlags=pDefault->dwEnrollmentFlags;
    m_dwPrivateKeyFlags=pDefault->dwPrivateKeyFlags;
    m_dwCertificateNameFlags=pDefault->dwCertificateNameFlags;
    m_dwMinimalKeySize=pDefault->dwMinimalKeySize;
    m_dwRASignature=pDefault->dwRASignature;
    m_dwSchemaVersion=pDefault->dwSchemaVersion;

    //basic contraints
    m_BasicConstraints.dwPathLenConstraint = pDefault->dwDepth;
    m_BasicConstraints.fPathLenConstraint =
        (m_BasicConstraints.dwPathLenConstraint != -1);


    ((LARGE_INTEGER UNALIGNED *)&m_ftExpiration)->QuadPart = -Int32x32To64(FILETIME_TICKS_PER_SECOND, pDefault->dwExpiration);
    ((LARGE_INTEGER UNALIGNED *)&m_ftOverlap)->QuadPart    = -Int32x32To64(FILETIME_TICKS_PER_SECOND, pDefault->dwOverlap);

    //DN
    awszData[0] = pDefault->wszName;
    awszData[1] = NULL;

    hr = SetProperty(CERTTYPE_PROP_DN, awszData);
    _JumpIfError(hr, error, "SetProperty");

    //SID
    hr = myGetSidFromDomain(wszDomain, &pDomainSid);
    if (S_OK != hr)
    {
        hr = HRESULT_FROM_WIN32(hr);
	_JumpError(hr, error, "myGetSidFromDomain");
    }
    if (!myConvertSidToStringSid(pDomainSid, &wszDomainSid))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myConvertSidToStringSid");
    }
    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_STRING |
			FORMAT_MESSAGE_ARGUMENT_ARRAY,
		    pDefault->wszSD,
		    0,
		    0,
		    (LPTSTR) &wszFormattedSD,
		    0,
		    (va_list *) &wszDomainSid))
    {
        hr = myHLastError();
	_JumpError(hr, error, "FormatMessage");
    }
    hr = myGetSDFromTemplate(wszFormattedSD, NULL, &m_pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

error:
    if (NULL != wszFormattedSD)
    {
        LocalFree(wszFormattedSD);
    }
    if (NULL != wszDomainSid)
    {
        LocalFree(wszDomainSid);
    }
    if (NULL != pDomainSid)
    {
        LocalFree(pDomainSid);
    }
    if (NULL != pwszDefaultOID)
    {
        LocalFree(pwszDefaultOID);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_LoadFromDSEntry -- ProcessFind CertTypes Objects in the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_LoadFromDSEntry(
    LDAP *  pld,
    LDAPMessage *Entry)
{
    HRESULT hr = S_OK;
    DWORD   iIndex;
    DWORD   dwValue=0;
    BOOL    fV2Schema=FALSE;

    struct berval **apExtension;
    struct berval **apSD;

    LPWSTR *awszValue = NULL;

    CCAProperty *pProp;
    WCHAR ** pwszProp;
    WCHAR ** wszLdapVal;

    // This is a fix so that CERTTYPE_PROP_DN is set to CERTTYPE_PROP_CN first.
    // The real DN is found and appended later, and will never be used or
    // returned in this case.

    wszLdapVal = ldap_get_values(pld, Entry, CERTTYPE_PROP_CN);
    if (NULL == wszLdapVal)
    {
		hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
		_JumpError(hr, error, "getCNFromDS");
    }

    if (NULL == wszLdapVal[0])
    {
		hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
		_JumpError(hr, error, "getCNFromDS");
    }

    SetProperty(CERTTYPE_PROP_DN, wszLdapVal);

	m_bstrType = CertAllocString(wszLdapVal[0]);
	if(NULL == m_bstrType)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocString");
	}

    ldap_value_free(wszLdapVal);

    // Add text properties from
    // DS lookup.

    for (pwszProp = g_awszCTNamedProps; *pwszProp != NULL; pwszProp++)
    {
        pProp = new CCAProperty(*pwszProp);
        if(pProp == NULL)
        {
	        hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "new");
        }

        wszLdapVal = ldap_get_values(pld, Entry, *pwszProp);
        hr = pProp->SetValue(wszLdapVal);
	    _PrintIfError(hr, "SetValue");

        if(wszLdapVal)
        {
	        ldap_value_free(wszLdapVal);
        }
        if(hr == S_OK)
        {
            hr = CCAProperty::Append(&m_pProperties, pProp);
	        _PrintIfError(hr, "Append");
        }

        if(hr != S_OK)
        {
	        CCAProperty::DeleteChain(&pProp);
	        _JumpError(hr, error, "SetValue or Append");
        }

    }
    pwszProp = NULL;

	// Append special properties

    // CSP list

    // Values of the form index,value
    wszLdapVal = ldap_get_values(pld, Entry, CERTTYPE_PROP_CSP_LIST);
    if(wszLdapVal)
    {
        LPWSTR wszValue;
        LPWSTR *pwszCurrent;
        DWORD  i;
        DWORD  cValues = 0;
        pwszCurrent = wszLdapVal;
        while(*pwszCurrent)
        {
            cValues++;
            pwszCurrent++;
        }
        pwszProp = (LPWSTR *)LocalAlloc(LMEM_FIXED, (cValues+1)*sizeof(LPWSTR));

        if(pwszProp == NULL)
        {
            ldap_value_free(wszLdapVal);
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "LocalAlloc");
        }
        ZeroMemory(pwszProp, (cValues+1)*sizeof(LPWSTR));

        pwszCurrent = wszLdapVal;
        while(*pwszCurrent)
        {
            i = wcstol(*pwszCurrent, &wszValue, 10);
            if(wszValue)
            {
                wszValue++;
            }
            if((i > 0) && (i <= cValues))
            {
                pwszProp[i-1] = wszValue;
            }
            pwszCurrent++;
        }
    }
    pProp = new CCAProperty(CERTTYPE_PROP_CSP_LIST);
    if(pProp == NULL)
    {
        if (NULL != pwszProp)
		{
			LocalFree(pwszProp);
		}
		if (NULL != wszLdapVal)
		{
			ldap_value_free(wszLdapVal);
		}
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "new");
    }
    hr = pProp->SetValue(pwszProp);
    _PrintIfError(hr, "SetValue");

    if (NULL != pwszProp)
    {
		LocalFree(pwszProp);
    }
    if (NULL != wszLdapVal)
    {
		ldap_value_free(wszLdapVal);
    }

    if(hr == S_OK)
    {
        hr = CCAProperty::Append(&m_pProperties, pProp);
		_PrintIfError(hr, "Append");
    }
    if(hr != S_OK)
    {

		CCAProperty::DeleteChain(&pProp);
		_JumpError(hr, error, "SetValue or Append");
    }



    // Append the security descriptor...

	apSD = ldap_get_values_len(pld, Entry, CERTTYPE_SECURITY_DESCRIPTOR_NAME);
    if(apSD != NULL)
    {
		
		if(0 == ((*apSD)->bv_len))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            ldap_value_free_len(apSD);
			_JumpError(hr, error, "LdapGetSecurityDescriptor");
		}
        
		m_pSD = LocalAlloc(LMEM_FIXED, (*apSD)->bv_len);
        if(m_pSD == NULL)
        {
            hr = E_OUTOFMEMORY;
            ldap_value_free_len(apSD);
		    _JumpError(hr, error, "LocalAlloc");
        }

        CopyMemory(m_pSD, (*apSD)->bv_val, (*apSD)->bv_len);
        ldap_value_free_len(apSD);
    }
	else
	{
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "LdapGetSecurityDescriptor");
	}

    m_dwFlags = 0;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_FLAGS);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_dwFlags = _wtol(awszValue[0]);
        }
        ldap_value_free(awszValue);
    }

    m_Revision = CERTTYPE_VERSION_BASE;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_REVISION);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_Revision = _wtol(awszValue[0]);
        }
        ldap_value_free(awszValue);
    }

    m_dwKeySpec = 0;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_DEFAULT_KEYSPEC);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_dwKeySpec = _wtol(awszValue[0]);
        }
        ldap_value_free(awszValue);
    }

    apExtension = ldap_get_values_len(pld, Entry, CERTTYPE_PROP_KU);
    if(apExtension != NULL)
    {
        m_KeyUsage.cbData = (*apExtension)->bv_len;
        m_KeyUsage.cUnusedBits = 0;
        m_KeyUsage.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, m_KeyUsage.cbData);
        if(m_KeyUsage.pbData == NULL)
        {
            hr = E_OUTOFMEMORY;
            ldap_value_free_len(apExtension);
		    _JumpError(hr, error, "LocalAlloc");

        }
        CopyMemory(m_KeyUsage.pbData, (*apExtension)->bv_val, (*apExtension)->bv_len);
        ldap_value_free_len(apExtension);
    }
    m_BasicConstraints.dwPathLenConstraint = 0;
    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_MAX_DEPTH);
    if(awszValue != NULL)
    {
        if(awszValue[0] != NULL)
        {
            m_BasicConstraints.dwPathLenConstraint = _wtoi(awszValue[0]);

           m_BasicConstraints.fPathLenConstraint =
                (m_BasicConstraints.dwPathLenConstraint != -1);
        }
        ldap_value_free(awszValue);
    }

    ZeroMemory(&m_ftExpiration, sizeof(m_ftExpiration));
    apExtension = ldap_get_values_len(pld, Entry, CERTTYPE_PROP_EXPIRATION);
    if(apExtension != NULL)
    {
        CopyMemory(&m_ftExpiration, (*apExtension)->bv_val, min((*apExtension)->bv_len, sizeof(m_ftExpiration)));
        ldap_value_free_len(apExtension);
    }

    ZeroMemory(&m_ftOverlap, sizeof(m_ftOverlap));
    apExtension = ldap_get_values_len(pld, Entry, CERTTYPE_PROP_OVERLAP);
    if(apExtension != NULL)
    {
        CopyMemory(&m_ftOverlap, (*apExtension)->bv_val, min((*apExtension)->bv_len, sizeof(m_ftOverlap)));
        ldap_value_free_len(apExtension);
    }

    m_fNew = FALSE;

    //we load the V2 template attributes if they exist
    awszValue=NULL;
    pProp=NULL;
    hr=S_OK;

    awszValue = ldap_get_values(pld, Entry, CERTTYPE_PROP_SCHEMA_VERSION);
    if((awszValue != NULL) && (awszValue[0] != NULL))
       fV2Schema=TRUE;

    if(awszValue)
    {
	    ldap_value_free(awszValue);
        awszValue=NULL;
    }

    if(fV2Schema)
    {
        for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
        {
            if(g_CTV2Properties[iIndex].fStringProperty)
            {
                pProp = new CCAProperty(g_CTV2Properties[iIndex].pwszProperty);
                if(pProp == NULL)
                {
	                hr = E_OUTOFMEMORY;
	                _JumpError(hr, error, "new");
                }

                awszValue = ldap_get_values(pld, Entry, g_CTV2Properties[iIndex].pwszProperty);
                hr = pProp->SetValue(awszValue);
	            _PrintIfError(hr, "SetValue");

                if(awszValue)
                {
	                ldap_value_free(awszValue);
                    awszValue=NULL;
                }

                if(hr == S_OK)
                {
                    hr = CCAProperty::Append(&m_pProperties, pProp);
	                _PrintIfError(hr, "Append");
                }

                if(hr != S_OK)
                {
	                CCAProperty::DeleteChain(&pProp);
	                _JumpError(hr, error, "SetValue or Append");
                }

                pProp=NULL;
            }
            else
            {

                dwValue=0;
                awszValue = ldap_get_values(pld, Entry, g_CTV2Properties[iIndex].pwszProperty);
                if((awszValue != NULL) && (awszValue[0] != NULL))
                {
                    dwValue = _wtol(awszValue[0]);
                    ldap_value_free(awszValue);
                    awszValue=NULL;
                }
                else
                {
                    if(awszValue)
                    {
                        ldap_value_free(awszValue);
                        awszValue=NULL;
                    }
                    hr=E_UNEXPECTED;
	                _JumpError(hr, error, "ldap get values");
                }

                 //assign dwValue to the corresponding data members
			    if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
				    m_dwMinorRevision = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
				    m_dwRASignature = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
				    m_dwEnrollmentFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
				    m_dwPrivateKeyFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
				    m_dwCertificateNameFlags = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
				    m_dwMinimalKeySize = dwValue;
			    else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
				    m_dwSchemaVersion = dwValue;
			    else
			    {
				    hr=E_UNEXPECTED;
		            _JumpError(hr, error, "Copy V2 attribute value");
			    }
            }
        }
    }


error:

    return(hr);
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_EnumFromDSCache -- Enumerate the CertType objects from the
// DS cache
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_EnumFromDSCache(
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{
    HRESULT			hr = S_OK;
    CCertTypeInfo	*pCTFirst = NULL;
    CCertTypeInfo	*pCTCurrent = NULL;
    DWORD			cTypes;
    DWORD			cMaxTypesLen;

    HKEY			hEnumKey = NULL;
    WCHAR			*wszTypeName = NULL;

    DWORD			err;
    DWORD			disp;
	DWORD			i;
	DWORD			dwSize=0;
	DWORD			dwType=0;
	FILETIME		ftTimestamp;
	FILETIME		ftTimestamp_After;



    if(ppCTInfo == NULL )
    {
        return E_POINTER;
    }

	*ppCTInfo=NULL;

    err = ctRegCreateKeyEx((dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                         NULL,
                         &hEnumKey,
                         &disp);


    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
		goto error;
    }

	//get the fist timestamp
    dwSize = sizeof(ftTimestamp);
    err = RegQueryValueEx(hEnumKey,
                    wszTIMESTAMP,
                    NULL,
                    &dwType,
                    (PBYTE)&ftTimestamp,
                    &dwSize);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	if(REG_BINARY != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

	//start reading all the sub keys
    err = RegQueryInfoKey(hEnumKey,
                          NULL,
                          NULL,
                          NULL,
                          &cTypes,
                          &cMaxTypesLen,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	cMaxTypesLen++;  // Terminating NULL

    wszTypeName = (WCHAR *)LocalAlloc(LMEM_FIXED, cMaxTypesLen*sizeof(WCHAR));
    if(wszTypeName == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i = 0;
        i < cTypes;
        i++)
    {
        DWORD cName;


        cName = cMaxTypesLen;
        err = RegEnumKeyEx(hEnumKey,
                           i,
                           wszTypeName,
                           &cName,
                           NULL,
                           NULL,
                           NULL,
                           NULL);

        if(ERROR_SUCCESS != err)
        {
			hr = HRESULT_FROM_WIN32(err);
			goto error;
        }


        pCTCurrent = new CCertTypeInfo;
        if(pCTCurrent == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        hr = pCTCurrent->_LoadCachedCTFromReg(wszTypeName,
                                                  (dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER);
        if(hr == S_OK)
        {
            if(dwFlags & CT_FIND_LOCAL_SYSTEM)
            {
                pCTCurrent->m_fLocalSystemCache = TRUE;
            }
            _Append(&pCTFirst, pCTCurrent);
            pCTCurrent = NULL;
        }

        if(pCTCurrent)
        {
            delete pCTCurrent;
            pCTCurrent = NULL;
        }
	}

	//read the second time stamp
    dwSize = sizeof(ftTimestamp_After);
    err = RegQueryValueEx(hEnumKey,
                    wszTIMESTAMP_AFTER,
                    NULL,
                    &dwType,
                    (PBYTE)&ftTimestamp_After,
                    &dwSize);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	if(REG_BINARY != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

	//compare the timestamp to make sure the data has not been tampered
	if(0 != CompareFileTime(&ftTimestamp, &ftTimestamp_After))
	{
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
	}

    // May be null if none found.
    _Append(ppCTInfo, pCTFirst);

    pCTFirst = NULL;

	hr=S_OK;


error:
    if(wszTypeName)
    {
        LocalFree(wszTypeName);
    }

    if(pCTFirst)
    {
        delete pCTFirst;
    }

    if(hEnumKey)
    {
        RegCloseKey(hEnumKey);
    }
    return hr;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_HasDSCacheExpired --
//
//  return E_FAIL: expired
//         S_OK:   not expired
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_HasDSCacheExpired(
                    DWORD               dwFlags
                    )

{
    HRESULT hr = S_OK;
    HKEY  hTimestampKey = NULL;
    DWORD err;
    DWORD disp;
    DWORD dwSize;
    DWORD dwType;

    LARGE_INTEGER ftTimestamp;
    FILETIME ftSystemTime;

    if(dwFlags & CT_FLAG_NO_CACHE_LOOKUP)
    {
        hr = E_FAIL;
        goto error;
    }

    err = ctRegCreateKeyEx((dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                         NULL,
                         &hTimestampKey,
                         &disp);


    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    dwSize = sizeof(FILETIME);
    err = RegQueryValueEx(hTimestampKey,
                    wszTIMESTAMP,
                    NULL,
                    &dwType,
                    (PBYTE)&ftTimestamp,
                    &dwSize);
    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	if(REG_BINARY != dwType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto error;
    }

    GetSystemTimeAsFileTime(&ftSystemTime);

	//the ftTimestamp time should always less than the current system clock.
	//has to reload otherwise

	if( 0 > CompareFileTime(&ftSystemTime, (FILETIME *)&ftTimestamp ))
	{
		// We need to reload.  System clock readjusted
		hr = E_FAIL;
	}
	else
	{
		ftTimestamp.QuadPart +=  Int32x32To64(CERTTYPE_REFRESH_PERIOD, FILETIME_TICKS_PER_SECOND);

		if( 0 < CompareFileTime(&ftSystemTime, (FILETIME *)&ftTimestamp ))
		{
			// Expired
			hr = E_FAIL;
		}
		else
		{
			// Not expried, so don't bother
			// renewing
			hr = S_OK;
		}

	}



error:


    if(hTimestampKey)
    {
        RegCloseKey(hTimestampKey);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// _DeleteAllKey
//
//
//+--------------------------------------------------------------------------
HRESULT	_DeleteAllKey(HKEY	hEnumKey)
{
	HRESULT		hr=E_FAIL;
    DWORD		cMaxTypesLen=0;
    DWORD		cTypes=0;
    DWORD		err=0;
	DWORD		i=0;

    LPWSTR		wszTypeName = NULL;

    err = RegQueryInfoKey(hEnumKey,
                          NULL,
                          NULL,
                          NULL,
                          &cTypes,
                          &cMaxTypesLen,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    //delete existing cache information
    if(cTypes != 0)
    {

        cMaxTypesLen++;  // Terminating NULL

        wszTypeName = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                  cMaxTypesLen * sizeof(WCHAR));

        if(wszTypeName == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        for(i = 0; i < cTypes; i++)
        {
            DWORD cName = cMaxTypesLen;

            err = RegEnumKeyEx(hEnumKey,
                               0,           // As we delete, the index changes
                               wszTypeName,
                               &cName,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

            if(ERROR_SUCCESS != err)
            {
				hr = HRESULT_FROM_WIN32(err);
				goto error;
            }

            err = RegDeleteKey(hEnumKey, wszTypeName);

			if(ERROR_SUCCESS != err)
			{
				hr = HRESULT_FROM_WIN32(err);
				goto error;
			}
        }
    }

	hr=S_OK;

error:

    if(wszTypeName)
    {
        LocalFree(wszTypeName);
    }

	return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_UpdateDSCache --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_UpdateDSCache(
                    DWORD               dwFlags,
                    CCertTypeInfo *     pCTInfo
                    )

{
    HRESULT hr = S_OK;

    HKEY    hEnumKey = NULL;

    DWORD	err;
    DWORD	disp;
    FILETIME ftSystemTime;

    CCertTypeInfo *     pCTCurrent = pCTInfo;

    err = ctRegCreateKeyEx((dwFlags & CA_FIND_LOCAL_SYSTEM)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hEnumKey,
                         &disp);


    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	//to work with multiple processes that access the registry at the same time,
	//mark the area dirty
    GetSystemTimeAsFileTime(&ftSystemTime);

    err = RegSetValueEx(hEnumKey,
                    wszTIMESTAMP_AFTER,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&ftSystemTime,
                    sizeof(ftSystemTime));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	//delete all sub keys
	if(S_OK != (hr=_DeleteAllKey(hEnumKey)))
		goto error;

	//delete time stamp value if it exists
	RegDeleteValue(hEnumKey, wszTIMESTAMP);

	//do the updates
    while(pCTCurrent)
    {
        hr=pCTCurrent->_BaseUpdateToReg(hEnumKey);

		if(S_OK != hr)
			goto error;

        pCTCurrent = pCTCurrent->m_pNext;
    }

	//mark the end of the update
    err = RegSetValueEx(hEnumKey,
                    wszTIMESTAMP,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&ftSystemTime,
                    sizeof(ftSystemTime));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

	hr=S_OK;

error:

    if(hEnumKey)
    {
		//delete all sub keys upon failure
		if(S_OK != hr)
		{
			RegDeleteValue(hEnumKey, wszTIMESTAMP_AFTER);
			_DeleteAllKey(hEnumKey);
			RegDeleteValue(hEnumKey, wszTIMESTAMP);
		}

        RegCloseKey(hEnumKey);
    }

    return hr;
}


//+--------------------------------------------------------------------------
// CCAInfo::_EnumScopeFromDS --
//
//      Scope means the base DN where the search starts
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_EnumScopeFromDS(
    LDAP *  pld,
    DWORD   dwFlags,
    LPCWSTR wszScope,
    CCertTypeInfo **    ppCTInfo)

{
    HRESULT hr = S_OK;
    ULONG   ldaperr;


static WCHAR * s_wszSearch = L"(objectCategory=pKICertificateTemplate)";

    CCertTypeInfo *pCTFirst = NULL;
    CCertTypeInfo *pCTCurrent = NULL;
    // Initialize LDAP session
    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION };

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    LDAPControl permissive_modify_control =
    {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };


    PLDAPControl    server_controls[3] =
                    {
                        &se_info_control,
                        &permissive_modify_control,
                        NULL
                    };

    LDAPMessage *SearchResult = NULL, *Entry;


    // search timeout
    struct l_timeval        timeout;

    if (NULL == ppCTInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
    }

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    while(TRUE)
    {
	    // Perform search.  Asking for all certificate template attributes.
        // should work with both V1 and V2 templates.
	    ldaperr = ldap_search_ext_sW(pld,
		          (LPWSTR)wszScope,
		          LDAP_SCOPE_SUBTREE,
		          s_wszSearch,
		          g_awszCTAttrs,
		          0,
                  (PLDAPControl *) server_controls,
                  NULL,
                  &timeout,
                  10000,
		          &SearchResult);
        if(ldaperr == LDAP_NO_SUCH_OBJECT)
	    {
	        // No entries were found.
	        hr = S_OK;
	        *ppCTInfo = NULL;
	        break;
	    }

	    if(ldaperr != LDAP_SUCCESS)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
	        break;
	    }
	    if(0 == ldap_count_entries(pld, SearchResult))
	    {
	        // No entries were found.
	        hr = S_OK;
	        *ppCTInfo = NULL;
	        break;
	    }

	    hr = S_OK;
	    for(Entry = ldap_first_entry(pld, SearchResult);
	        Entry != NULL;
	        Entry = ldap_next_entry(pld, Entry))
	    {

            pCTCurrent = new CCertTypeInfo;
            if(pCTCurrent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto error;
            }

            hr =  pCTCurrent->_LoadFromDSEntry(pld,Entry);

            //filter out only the V1 and V2 templates
            if(hr == S_OK)
            {
                if(pCTCurrent->m_dwSchemaVersion <= CERTTYPE_SCHEMA_VERSION_2)
                {
                    if(dwFlags & CT_FIND_LOCAL_SYSTEM)
                    {
                        pCTCurrent->m_fLocalSystemCache = TRUE;
                    }
                    _Append(&pCTFirst, pCTCurrent);
                    pCTCurrent = NULL;
                }
            }

            if(pCTCurrent)
            {
                delete pCTCurrent;
                pCTCurrent = NULL;
            }

	    }
        break;
    }

    if(hr == S_OK)
    {
		//we will update the Cache only if the pld handle is signed
		ULONG uInfo=0;
		
		if(LDAP_SUCCESS == ldap_get_option(pld, LDAP_OPT_SIGN, (void*) &uInfo))
		{
			if (uInfo == PtrToUlong(LDAP_OPT_ON)) 
			{
				_UpdateDSCache(dwFlags,
							   pCTFirst);
			}
		}
	}

	if(hr == S_OK)
	{
        _Append(ppCTInfo, pCTFirst);
        pCTFirst = NULL;
    }

error:

    if(SearchResult)
    {
        ldap_msgfree(SearchResult);
    }

    if (NULL != pCTFirst)
    {
        delete pCTFirst;
    }

    return(hr);
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_EnumFromDS -- Enumerate the CertType objects from the
// DS cache
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_EnumFromDS(
                    LDAP *              pld,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{
    HRESULT         hr = E_FAIL;
;
    LDAP            *mypld = NULL;

    CCertTypeInfo   *pCTFirst = NULL;

    CERTSTR         bstrCertTemplatesContainer = NULL;
    CERTSTR         bstrConfig = NULL;

    if (NULL == ppCTInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL param");
    }

	*ppCTInfo=NULL;

	//contact DS if local data has expired and there exists a DS
	while(TRUE)
	{
		if(S_OK != _HasDSCacheExpired(dwFlags))
		{
			//the cache has expired.
			if(S_OK != (hr = myDoesDSExist(TRUE)))
			{
				_JumpError(hr, error, "myDoesDSExist");
			}

			// bind to ds
			if(pld == NULL)
			{
				hr = myRobustLdapBindEx(
					0,		// dwFlags1
					RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
					LDAP_VERSION2,	// uVersion
					NULL,		// pwszDomainName
					&mypld,
					NULL);		// ppwszForestDNSName

				if (hr != S_OK)
				{
					_JumpError(hr, error, "myRobustLdapBindEx");
				}

				pld = mypld;
			}

			hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
			if(S_OK != hr)
			{
				_JumpError(hr, error, "CAGetAuthoritativeDomainDn");
			}

			bstrCertTemplatesContainer = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation));
			if(bstrCertTemplatesContainer == NULL)
			{
				hr = E_OUTOFMEMORY;
				_JumpError(hr, error, "CertAllocStringLen");
			}
			wcscpy(bstrCertTemplatesContainer, s_wszLocation);
			wcscat(bstrCertTemplatesContainer, bstrConfig);

			hr = _EnumScopeFromDS(pld,
							 dwFlags,
							 bstrCertTemplatesContainer,
							 &pCTFirst);

			break;
		}
		else
		{
			hr = _EnumFromDSCache(dwFlags, &pCTFirst);

			//we failed to read from the Cache, read from the directory
			if(S_OK != hr)
			{
				dwFlags = dwFlags | CT_FLAG_NO_CACHE_LOOKUP;

				continue;
			}

			break;
		}
	}

    if(hr == S_OK)
    {
        _FilterByFlags(&pCTFirst, dwFlags);
	    // May be null if none found.
        _Append(ppCTInfo, pCTFirst);
	    pCTFirst = NULL;
    }

error:

    if (NULL != bstrCertTemplatesContainer)
    {
        CertFreeString(bstrCertTemplatesContainer);
    }

    if(bstrConfig)
    {
        CertFreeString(bstrConfig);
    }

    if (NULL != mypld)
    {
        ldap_unbind(mypld);
    }
    return(hr);

}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_FindInDS -- Find the CertType objects in the
// DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_FindInDS(
                    LDAP *              pld,
                    LPCWSTR *           wszNames,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{

    HRESULT             hr = S_OK;
    BOOL                fFound = FALSE;
    LPCWSTR             *pwszCurrentName = NULL;


    CCertTypeInfo *     pCTCurrent = NULL;
    LPWSTR              *rgwszOID = NULL;


    if (NULL == ppCTInfo)
    {
        hr = E_POINTER;
	    _JumpError(hr, error, "NULL param");
    }



    hr = _EnumFromDS(pld,
                     dwFlags,
                     &pCTCurrent
                     );

    // Filter Scopes by given names.

    pwszCurrentName = wszNames;

    while(pwszCurrentName && *pwszCurrentName)
    {
        CCertTypeInfo * pCTNext = pCTCurrent,
                      **ppCTLast = &pCTCurrent;

        fFound=FALSE;

        while(pCTNext != NULL)
        {
            if(CT_FIND_BY_OID & dwFlags)
            {
                if(S_OK == CAGetCertTypePropertyEx((HCERTTYPE)pCTNext, CERTTYPE_PROP_OID, &rgwszOID))
                {
                    if(rgwszOID)
                    {
                        if(rgwszOID[0])
                        {
                            if(_wcsicmp(rgwszOID[0], *pwszCurrentName) == 0)
                                fFound=TRUE;
                        }
                    }
                }
            }
            else
            {
                if(mylstrcmpiL(pCTNext->m_bstrType, *pwszCurrentName) == 0)
                    fFound=TRUE;
            }

            if(rgwszOID)
            {
                CAFreeCertTypeProperty((HCERTTYPE)pCTNext, rgwszOID);
                rgwszOID=NULL;
            }

            if(fFound)
            {
                *ppCTLast = pCTNext->m_pNext;
                pCTNext->m_pNext = NULL;
                _Append(ppCTInfo, pCTNext);
                break;
            }
            ppCTLast = &pCTNext->m_pNext;
            pCTNext = pCTNext->m_pNext;
        }
        pwszCurrentName++;

    }



error:

    if(pCTCurrent)
    {
        delete pCTCurrent;
    }

    return(hr);

}

//+--------------------------------------------------------------------------
// CCertTypeInfo::Enum -- Enumerate the Cert Type objects
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Enum(
                    LPCWSTR             wszScope,
                    DWORD               dwFlags,
                    CCertTypeInfo **    ppCTInfo
                    )

{
    HRESULT hr = S_OK;
    CCertTypeInfo *pCTFirst = NULL;

    if(ppCTInfo == NULL )
    {
        return E_POINTER;
    }
    hr = _EnumFromDS(((CT_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)?(LDAP *)wszScope:NULL), dwFlags, &pCTFirst);

    if(hr != S_OK)
    {
        goto error;
    }


    _FilterByFlags(&pCTFirst, dwFlags);
    // May be null if none found.
    *ppCTInfo = pCTFirst;
    pCTFirst = NULL;




error:

    if(pCTFirst)
    {
        delete pCTFirst;
    }

    return hr;

}

//+--------------------------------------------------------------------------
// CCertTypeInfo::Find -- Find CertType Objects in the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::FindByNames(
    LPCWSTR *           wszNames,
    LPCWSTR             wszScope,
    DWORD               dwFlags,
    CCertTypeInfo **    ppCTInfo)

{
    HRESULT hr = S_OK;
    CCertTypeInfo *pCTFirst = NULL;






    if(ppCTInfo == NULL )
    {
        return E_POINTER;
    }

    hr = _FindInDS(((CT_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)?(LDAP *)wszScope:NULL),
                   wszNames,
                   dwFlags,
                   &pCTFirst);
    if(hr != S_OK)
    {
        goto error;
    }
    // May be null if none found.
    *ppCTInfo = pCTFirst;
    pCTFirst = NULL;




error:


    if(pCTFirst)
    {
        delete pCTFirst;
    }

    return hr;

}
//+--------------------------------------------------------------------------
// CCertTypeInfo::Create -- Create CertType Object in the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Create(
    LPCWSTR             wszCertType,
    LPCWSTR             wszScope,
    CCertTypeInfo **    ppCTInfo)

{
    HRESULT             hr = S_OK;
    CERT_TYPE_DEFAULT   certTypeDefault;
    CCertTypeInfo       *pCTCurrent = NULL;
    LPWSTR              pwszDomain = NULL;

    if((ppCTInfo == NULL )|| (wszCertType == NULL))
    {
        return E_POINTER;
    }

    memset(&certTypeDefault, 0, sizeof(CERT_TYPE_DEFAULT));

    pCTCurrent = new CCertTypeInfo;
    if(pCTCurrent == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //wszScope should always be NULL.
    if(wszScope)
    {
        hr = myDomainFromDn(wszScope, &pwszDomain);
	_JumpIfError(hr, error, "myDomainFromDn");
    }

    certTypeDefault.wszName=(LPWSTR)wszCertType;
    certTypeDefault.idFriendlyName=0;
    certTypeDefault.wszSD=ADMIN_GROUP_SD;
    certTypeDefault.dwKeySpec=AT_KEYEXCHANGE;
    certTypeDefault.dwRevision=CERTTYPE_VERSION_NEXT;
    //update the schema and revision.  If V3 properties were to be set, will
    //update the schema accordinlgy.
    certTypeDefault.dwSchemaVersion=CERTTYPE_SCHEMA_VERSION_2;
    certTypeDefault.dwCertificateNameFlags=CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME;
    certTypeDefault.dwExpiration=EXPIRATION_FIVE_YEARS;
    certTypeDefault.dwOverlap=OVERLAP_TWO_WEEKS;

    if(S_OK != (hr=I_CAOIDCreateNew(CERT_OID_TYPE_TEMPLATE,
                                0,
                                &(certTypeDefault.wszOID))))
        goto error;

    hr = pCTCurrent->_LoadFromDefaults(&certTypeDefault, pwszDomain);
    if(hr != S_OK)
    {
        goto error;
    }

    *ppCTInfo = pCTCurrent;
    pCTCurrent = NULL;
error:

    if(certTypeDefault.wszOID)
        LocalFree(certTypeDefault.wszOID);

    if(pCTCurrent)
    {
        delete pCTCurrent;
    }
    if(pwszDomain)
    {
        LocalFree(pwszDomain);
    }
    return hr;
}
//+--------------------------------------------------------------------------
// CCertTypeInfo::Update -- Update CertType Objects to the DS
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Update(VOID)

{
    HRESULT hr = S_OK;
    DWORD   err;
    HKEY    hCertTypeCache = NULL;
    DWORD   disp;

    m_dwFlags |= CT_FLAG_IS_MODIFIED;

    //we change the autoenroll flag based on the property set
    //for V2 or above template only
    if(m_dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
    {
        if( (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT & m_dwCertificateNameFlags) ||
            (CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT_ALT_NAME & m_dwCertificateNameFlags)  ||
            ((m_dwRASignature >= 2) && (0 == (CT_FLAG_PREVIOUS_APPROVAL_VALIDATE_REENROLLMENT & m_dwEnrollmentFlags)))
          )
        {
            //turn off autoenrollment flag
            m_dwEnrollmentFlags &= (~CT_FLAG_AUTO_ENROLLMENT);
        }
        else
        {
            //turn on autoenrollment flag
            m_dwEnrollmentFlags |= CT_FLAG_AUTO_ENROLLMENT;
        }
    }


    // Update to the DS
    hr = _UpdateToDS();
    if(hr != S_OK)
    {
        goto error;
    }

    // Now update to the local cache.

    err = ctRegCreateKeyEx(m_fLocalSystemCache?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hCertTypeCache,
                         &disp);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    hr = _BaseUpdateToReg(hCertTypeCache);

error:

    if(hCertTypeCache)
    {
        RegCloseKey(hCertTypeCache);
    }
    return hr;
}
//+--------------------------------------------------------------------------
// CCertTypeInfo::_BaseUpdateToReg -- Update CertType Objects to the registry
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::_BaseUpdateToReg(HKEY hKey)

{
    CCAProperty     *pProp;
    HRESULT         hr = S_OK;
    DWORD           err;
    DWORD           iIndex=0;
    DWORD           dwValue=0;

    WCHAR           ** awszFriendlyName = NULL;

    WCHAR           *  wszFriendlyName;
    HKEY            hkCertType = NULL;
    DWORD           disp;

    err = RegCreateKeyEx(hKey,
                         m_bstrType,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hkCertType,
                         &disp);

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    hr = GetProperty(CERTTYPE_PROP_FRIENDLY_NAME, &awszFriendlyName);
    if(hr != S_OK)
    {
        goto error;
    }


    if(awszFriendlyName && awszFriendlyName[0])
    {
        wszFriendlyName = awszFriendlyName[0];
    }
    else
    {
        wszFriendlyName = TEXT("");

    }
    err = RegSetValueEx(hkCertType,
                    wszDISPNAME,
                    NULL,
                    REG_SZ,
                    (PBYTE)wszFriendlyName,
                    sizeof(WCHAR)*(wcslen(wszFriendlyName)+1));
    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    hr = m_pProperties->Find(CERTTYPE_PROP_CSP_LIST, &pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = pProp->UpdateToRegValue(hkCertType, wszCSPLIST);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = m_pProperties->Find(CERTTYPE_PROP_EXTENDED_KEY_USAGE, &pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = pProp->UpdateToRegValue(hkCertType, wszEXTKEYUSAGE);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = m_pProperties->Find(CERTTYPE_PROP_CRITICAL_EXTENSIONS, &pProp);
    if(hr != S_OK)
    {
        goto error;
    }

    hr = pProp->UpdateToRegValue(hkCertType, wszCRITICALEXTENSIONS);
    if(hr != S_OK)
    {
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszKEYUSAGE,
                    NULL,
                    REG_BINARY,
                    m_KeyUsage.pbData,
                    m_KeyUsage.cbData);

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }



    err = RegSetValueEx(hkCertType,
                    wszCTFLAGS,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_dwFlags,
                    sizeof(m_dwFlags));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszCTREVISION,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_Revision,
                    sizeof(m_Revision));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszCTKEYSPEC,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_dwKeySpec,
                    sizeof(m_dwKeySpec));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
        // Is this a CA


        // Is this a CA
    if(!m_BasicConstraints.fPathLenConstraint)
    {
        m_BasicConstraints.dwPathLenConstraint = MAXDWORD;
    }

    err = RegSetValueEx(hkCertType,
                    wszBASICCONSTLEN,
                    NULL,
                    REG_DWORD,
                    (PBYTE)&m_BasicConstraints.dwPathLenConstraint,
                    sizeof(m_BasicConstraints.dwPathLenConstraint));

    if(ERROR_SUCCESS != err)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    err = RegSetValueEx(hkCertType,
                    wszEXPIRATION,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&m_ftExpiration,
                    sizeof(m_ftExpiration));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }
    err = RegSetValueEx(hkCertType,
                    wszOVERLAP,
                    NULL,
                    REG_BINARY,
                    (PBYTE)&m_ftOverlap,
                    sizeof(m_ftOverlap));

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    if( (NULL != m_pSD) && 
		(IsValidSecurityDescriptor(m_pSD))
	  )
    {
		DWORD cbSD = GetSecurityDescriptorLength(m_pSD);

		if(0 == cbSD)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
			goto error;
		}
		else
		{

			err = RegSetValueEx(hkCertType,
							wszSECURITY,
							NULL,
							REG_BINARY,
							(PBYTE)m_pSD,
							cbSD);
		}

    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		goto error;
	}

    if(ERROR_SUCCESS != err )
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    //update the V2 template attributes
    if(0 != m_dwSchemaVersion)
    {
        pProp=NULL;
        dwValue=0;

        for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
        {
            if(g_CTV2Properties[iIndex].fStringProperty)
            {
                hr = m_pProperties->Find(g_CTV2Properties[iIndex].pwszProperty, &pProp);
                if(hr != S_OK)
                {
                    goto error;
                }

                hr = pProp->UpdateToRegValue(hkCertType, g_CTV2Properties[iIndex].pwszProperty);
                if(hr != S_OK)
                {
                    goto error;
                }

                pProp=NULL;
            }
            else
            {
                //DWORD properties
				if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
			        dwValue= m_dwMinorRevision;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
					dwValue= m_dwRASignature;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
					dwValue= m_dwEnrollmentFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
					dwValue= m_dwPrivateKeyFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
					dwValue= m_dwCertificateNameFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
					dwValue= m_dwMinimalKeySize;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
					dwValue= m_dwSchemaVersion;
				else
				{
					hr=E_UNEXPECTED;
					goto error;
				}

                err = RegSetValueEx(hkCertType,
                                g_CTV2Properties[iIndex].pwszProperty,
                                NULL,
                                REG_DWORD,
                                (PBYTE)&dwValue,
                                sizeof(dwValue));

                if(ERROR_SUCCESS != err )
                {
                    hr = HRESULT_FROM_WIN32(err);
                    goto error;
                }
            }
        }
    }


error:
    if(awszFriendlyName)
    {
        FreeProperty(awszFriendlyName);
    }

    if(hkCertType)
    {
        RegCloseKey(hkCertType);
    }

    return hr;
}

HRESULT
CCertTypeInfo::_UpdateToDS(VOID)
{

    HRESULT hr = S_OK;
    ULONG   ldaperr;
    LDAP	*pld = NULL;
    LDAPMod modObjectClass,
             modCN,
             modFriendlyName,
             modEKU,
             modCSP,
             modCriticalExts,
             modFlags,
             modKeySpec,
             modSD,
             modKU,
             modMaxDepth,
             modExpiration,
             modOverlap,
             modRevision;
	
	CERT_TYPE_PROP_MOD	rgPropMod[V2_PROPERTY_COUNT];

    LPWSTR   *pwszCSPList = NULL;

	DWORD	iIndex=0;
    DWORD   cMod = 0;
	DWORD	cV2Mod = 0;
    LDAPMod *mods[15 + V2_PROPERTY_COUNT + 1];
    LDAPMod *SDMods[2]={NULL, NULL};     //the security mod
    LPWSTR  pwszOID = NULL;
    LPWSTR  pwszFriendlyName = NULL;

    WCHAR *awszNull[1] = { NULL };

    CERTSTR bstrConfig = NULL;
    CERTSTR bstrDN = NULL;

    TCHAR *valObjectClass[3];

    WCHAR wszFlags[16], *awszFlags[2];
    WCHAR wszRevision[16], *awszRevision[2];
    WCHAR wszKeySpec[16], *awszKeySpec[2];
    WCHAR wszDepth[16], *awszDepth[2];

    struct berval valSD, *avalSD[2];
    struct berval valKU, *avalKU[2];
    struct berval valExpiration, *avalExpiration[2];
    struct berval valOverlap, *avalOverlap[2];

    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, DACL_SECURITY_INFORMATION |
                                                 OWNER_SECURITY_INFORMATION |
                                                 GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    LDAPControl permissive_modify_control =
    {
        LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
        {
            0, NULL
        },
        FALSE
    };


    PLDAPControl    server_controls[3] =
                    {
                        &se_info_control,
                        &permissive_modify_control,
                        NULL
                    };

    modCN.mod_values = NULL;
    modFriendlyName.mod_values = NULL;
    modEKU.mod_values = NULL;
    modCSP.mod_values = NULL;
    modCriticalExts.mod_values = NULL;

    // short circuit calls to a nonexistant DS
    hr = myDoesDSExist(TRUE);
    _JumpIfError(hr, error, "myDoesDSExist");

    __try
    {
	// bind to ds
	hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
	_LeaveIfError(hr, "myRobustLdapBindEx");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	_JumpIfError(hr, error, "CAGetAuthoritativeDomainDn");

        bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation)+wcslen(m_bstrType)+4);
        if(bstrDN == NULL)
        {
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "CertAllocStringLen");
        }
        wcscpy(bstrDN, L"CN=");
        wcscat(bstrDN, m_bstrType);
        wcscat(bstrDN, L",");
        wcscat(bstrDN, s_wszLocation);
        wcscat(bstrDN, bstrConfig);

        modObjectClass.mod_op = LDAP_MOD_REPLACE;
        modObjectClass.mod_type = TEXT("objectclass");
        modObjectClass.mod_values = valObjectClass;
        valObjectClass[0] = wszDSTOPCLASSNAME;
        valObjectClass[1] = wszDSTEMPLATELASSNAME;
        valObjectClass[2] = NULL;
        mods[cMod++] = &modObjectClass;

        modCN.mod_op = LDAP_MOD_REPLACE;
        modCN.mod_type = CERTTYPE_PROP_CN;
        hr = GetProperty(CERTTYPE_PROP_CN, &modCN.mod_values);
        if((hr != S_OK) || (modCN.mod_values == NULL) || (modCN.mod_values[0] == NULL))
        {
            if(modCN.mod_values)
            {
                FreeProperty(modCN.mod_values);
            }

	        modCN.mod_values = awszNull;

            if(!m_fNew)
            {
                mods[cMod++] = &modCN;
            }
        }
        else
        {
            mods[cMod++] = &modCN;
        }

		//only support write once to display name
		if( (m_fNew) || (m_fUpdateDisplayName))
		{
			modFriendlyName.mod_op = LDAP_MOD_REPLACE;
			modFriendlyName.mod_type = CERTTYPE_PROP_FRIENDLY_NAME;
			hr = GetProperty(CERTTYPE_PROP_FRIENDLY_NAME, &modFriendlyName.mod_values);
			if((hr != S_OK) || (modFriendlyName.mod_values == NULL) || (modFriendlyName.mod_values[0] == NULL))
			{
				if(modFriendlyName.mod_values)
				{
					FreeProperty(modFriendlyName.mod_values);
				}
				modFriendlyName.mod_values = awszNull;
				/*if(!m_fNew)
				{
					mods[cMod++] = &modFriendlyName;
				}*/
			}
			else
			{
				//we copy the friendly name
				pwszFriendlyName = modFriendlyName.mod_values[0];
				mods[cMod++] = &modFriendlyName;
			}
		}

        modEKU.mod_op = LDAP_MOD_REPLACE;
        modEKU.mod_type = CERTTYPE_PROP_EXTENDED_KEY_USAGE;
        hr = GetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, &modEKU.mod_values);
        if((hr != S_OK) || (modEKU.mod_values == NULL) || (modEKU.mod_values[0] == NULL))
        {
            if(modEKU.mod_values)
            {
                FreeProperty(modEKU.mod_values);
            }
	        modEKU.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[cMod++] = &modEKU;
            }
        }
        else
        {
            mods[cMod++] = &modEKU;
        }

        modCSP.mod_op = LDAP_MOD_REPLACE;
        modCSP.mod_type = CERTTYPE_PROP_CSP_LIST;
        hr = GetProperty(CERTTYPE_PROP_CSP_LIST, &pwszCSPList);
        if((hr != S_OK) || (pwszCSPList == NULL) || (pwszCSPList[0] == NULL))
        {
	    modCSP.mod_values = awszNull;
            if(!m_fNew)
            {
                mods[cMod++] = &modCSP;
            }
        }
        else
        {
            DWORD cCSPs = 0;
            DWORD i;
            LPWSTR *pwszCurrent = pwszCSPList;
            while(*pwszCurrent)
            {
                cCSPs++;
                pwszCurrent++;
            }

            modCSP.mod_values = (LPWSTR *)LocalAlloc(LMEM_FIXED, sizeof(LPWSTR)*(cCSPs+1));
            if(modCSP.mod_values == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            ZeroMemory(modCSP.mod_values, sizeof(LPWSTR)*(cCSPs+1));

            i=0;
            pwszCurrent = pwszCSPList;
            while(*pwszCurrent)
            {

                modCSP.mod_values[i] = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(wcslen(*pwszCurrent)+6+cwcDWORDSPRINTF));
                if(modCSP.mod_values[i] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                wsprintf(modCSP.mod_values[i], L"%d,%ws",i+1, *pwszCurrent);
                pwszCurrent++;
                i++;
            }

            mods[cMod++] = &modCSP;
        }

        modCriticalExts.mod_op = LDAP_MOD_REPLACE;
        modCriticalExts.mod_type = CERTTYPE_PROP_CRITICAL_EXTENSIONS;
        hr = GetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, &modCriticalExts.mod_values);
        if((hr != S_OK) || (modCriticalExts.mod_values == NULL) || (modCriticalExts.mod_values[0] == NULL))
        {
            if(modCriticalExts.mod_values)
            {
                FreeProperty(modCriticalExts.mod_values);
            }
	        modCriticalExts.mod_values = awszNull;
            if(!m_fNew)
            {
            	mods[cMod++] = &modCriticalExts;
            }
        }
        else
        {
            mods[cMod++] = &modCriticalExts;
        }


        modFlags.mod_op = LDAP_MOD_REPLACE;
        modFlags.mod_type = CERTTYPE_PROP_FLAGS;
        modFlags.mod_values = awszFlags;
        awszFlags[0] = wszFlags;
        awszFlags[1] = NULL;
        wsprintf(wszFlags, L"%d", m_dwFlags);
        mods[cMod++] = &modFlags;

        modRevision.mod_op = LDAP_MOD_REPLACE;
        modRevision.mod_type = CERTTYPE_PROP_REVISION;
        modRevision.mod_values = awszRevision;
        awszRevision[0] = wszRevision;
        awszRevision[1] = NULL;
        wsprintf(wszRevision, L"%d", m_Revision);
        mods[cMod++] = &modRevision;

        modKeySpec.mod_op = LDAP_MOD_REPLACE;
        modKeySpec.mod_type = CERTTYPE_PROP_DEFAULT_KEYSPEC;
        modKeySpec.mod_values = awszKeySpec;
        awszKeySpec[0] = wszKeySpec;
        awszKeySpec[1] = NULL;
        wsprintf(wszKeySpec, L"%d", m_dwKeySpec);
        mods[cMod++] = &modKeySpec;


		if(NULL == m_pSD)
		{
			hr = E_UNEXPECTED;
			goto error;
		}

        modSD.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modSD.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
        modSD.mod_bvalues = avalSD;
        avalSD[0] = &valSD;
        avalSD[1] = NULL;
        if(IsValidSecurityDescriptor(m_pSD))
        {
            valSD.bv_len = GetSecurityDescriptorLength(m_pSD);

			if(0 == valSD.bv_len)
			{
				hr = E_UNEXPECTED;
				goto error;
			}

            valSD.bv_val = (char *)m_pSD;
            mods[cMod++] = &modSD;
            SDMods[0]=&modSD;
        }
        else
        {
			hr = E_UNEXPECTED;
			goto error;
        }

        modKU.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modKU.mod_type = CERTTYPE_PROP_KU;
        modKU.mod_bvalues = avalKU;
        avalKU[0] = &valKU;
        avalKU[1] = NULL;
        valKU.bv_len = m_KeyUsage.cbData;
        valKU.bv_val = (char *)m_KeyUsage.pbData;
        mods[cMod++] = &modKU;

        modMaxDepth.mod_op = LDAP_MOD_REPLACE;
        modMaxDepth.mod_type = CERTTYPE_PROP_MAX_DEPTH;
        modMaxDepth.mod_values = awszDepth;
        awszDepth[0] = wszDepth;
        awszDepth[1] = NULL;
        wsprintf(wszDepth, L"%d", m_BasicConstraints.dwPathLenConstraint);
        mods[cMod++] = &modMaxDepth;

        modExpiration.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modExpiration.mod_type = CERTTYPE_PROP_EXPIRATION;
        modExpiration.mod_bvalues = avalExpiration;
        avalExpiration[0] = &valExpiration;
        avalExpiration[1] = NULL;
        valExpiration.bv_len = sizeof(m_ftExpiration);
        valExpiration.bv_val = (char *)&m_ftExpiration;
        mods[cMod++] = &modExpiration;

        modOverlap.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
        modOverlap.mod_type = CERTTYPE_PROP_OVERLAP;
        modOverlap.mod_bvalues = avalOverlap;
        avalOverlap[0] = &valOverlap;
        avalOverlap[1] = NULL;
        valOverlap.bv_len = sizeof(m_ftOverlap);
        valOverlap.bv_val = (char *)&m_ftOverlap;
        mods[cMod++] = &modOverlap;
		
		//mark the end of V1 properties and start processing V2 properties
        // mods[cMod++] = NULL;
		cV2Mod=cMod;

		if(V2_PROPERTY_COUNT != g_CTV2PropertiesCount)
		{
			hr = E_UNEXPECTED;
			goto error;
		}

		memset(rgPropMod, 0, sizeof(CERT_TYPE_PROP_MOD) * V2_PROPERTY_COUNT);
		for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
		{
			rgPropMod[iIndex].modData.mod_op = LDAP_MOD_REPLACE;
			rgPropMod[iIndex].modData.mod_type = g_CTV2Properties[iIndex].pwszProperty;

			if(g_CTV2Properties[iIndex].fStringProperty)
			{
				//update the LPWSTR properties
				hr = GetPropertyEx(g_CTV2Properties[iIndex].pwszProperty,
								&(rgPropMod[iIndex].modData.mod_values));

				if((hr != S_OK) || (rgPropMod[iIndex].modData.mod_values == NULL) || (rgPropMod[iIndex].modData.mod_values[0] == NULL))
				{
					if(rgPropMod[iIndex].modData.mod_values)
					{
						FreeProperty(rgPropMod[iIndex].modData.mod_values);
					}

					rgPropMod[iIndex].modData.mod_values = awszNull;

					if(!m_fNew)
					{
						mods[cMod++] = &(rgPropMod[iIndex].modData);
					}
				}
				else
				{
                    //we copy the OID value
                    if(0 == wcscmp(CERTTYPE_PROP_OID, g_CTV2Properties[iIndex].pwszProperty))
                        pwszOID = rgPropMod[iIndex].modData.mod_values[0];

					mods[cMod++] = &(rgPropMod[iIndex].modData);
				}
			}
			else
			{
				//update the DWORD properties
				if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MINOR_REVISION)==0)
					rgPropMod[iIndex].dwData= m_dwMinorRevision;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_RA_SIGNATURE)==0)
					rgPropMod[iIndex].dwData= m_dwRASignature;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_RPOP_ENROLLMENT_FLAG)==0)
					rgPropMod[iIndex].dwData= m_dwEnrollmentFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_PRIVATE_KEY_FLAG)==0)
					rgPropMod[iIndex].dwData= m_dwPrivateKeyFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_NAME_FLAG)==0)
					rgPropMod[iIndex].dwData= m_dwCertificateNameFlags;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
					rgPropMod[iIndex].dwData= m_dwMinimalKeySize;
				else if(wcscmp(g_CTV2Properties[iIndex].pwszProperty, CERTTYPE_PROP_SCHEMA_VERSION)==0)
					rgPropMod[iIndex].dwData= m_dwSchemaVersion;
				else
				{
					hr=E_UNEXPECTED;
					goto error;
				}

				rgPropMod[iIndex].modData.mod_values = rgPropMod[iIndex].awszData;
				rgPropMod[iIndex].awszData[0] = rgPropMod[iIndex].wszData;
				rgPropMod[iIndex].awszData[1] = NULL;
				wsprintf(rgPropMod[iIndex].wszData, L"%d", rgPropMod[iIndex].dwData);
				mods[cMod++] = &(rgPropMod[iIndex].modData);
			}
		}

		//mark the end of V2 properties
        mods[cMod++] = NULL;

        //we should work with both V1 and V2 schema
        if(0 == m_dwSchemaVersion)
            mods[cV2Mod]=NULL;

	    //update the DS with V1 and V2 changes
        if(m_fNew)
        {
            ldaperr = ldap_add_ext_sW(pld, bstrDN, mods, server_controls, NULL);
			_PrintIfError(ldaperr, "ldap_add_s");
        }
        else
        {
            //we do the security descriptor first
            ldaperr = ldap_modify_ext_sW(pld,
                  bstrDN,
                  SDMods,
                  server_controls,
                  NULL);  // skip past objectClass and cn 

            if((LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr) || (LDAP_ALREADY_EXISTS == ldaperr))
            {
                ldaperr = LDAP_SUCCESS;
            }

            if(LDAP_SUCCESS ==ldaperr)
            {

                ldaperr = ldap_modify_ext_sW(pld,
                  bstrDN,
                  &mods[2],
                  server_controls,
                  NULL);  // skip past objectClass and cn

                if((LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr) || (LDAP_ALREADY_EXISTS == ldaperr))
                {
                    ldaperr = LDAP_SUCCESS;
                }
	        _PrintIfError(ldaperr, "ldap_modify_ext_sW");
           }
        }

        if (LDAP_SUCCESS != ldaperr)
        {
            //error out if this is a V2 template
            if(CERTTYPE_SCHEMA_VERSION_2 <= m_dwSchemaVersion )
            {
		        hr = myHLdapError(pld, ldaperr, NULL);
		        _LeaveError(ldaperr, m_fNew? "ldap_add_s" : "ldap_modify_sW");
            }

 	        //This will work with both W2K schema and W2K+ schema
	        mods[cV2Mod]=NULL;


      		if(m_fNew)
        	{
            	ldaperr = ldap_add_ext_sW(pld, bstrDN, mods, server_controls, NULL);
			    _PrintIfError(ldaperr, "ldap_add_s");
        	}
        	else
        	{
            		ldaperr = ldap_modify_ext_sW(pld,
                  		bstrDN,
                  		&mods[2],
                  		server_controls,
                  		NULL);  // skip past objectClass and cn
            		if((LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr) || (LDAP_ALREADY_EXISTS == ldaperr))
            		{
                		ldaperr = LDAP_SUCCESS;
            		}
			        _PrintIfError(ldaperr, "ldap_modify_ext_sW");
        	}

        	if (LDAP_SUCCESS != ldaperr)
        	{

			hr = myHLdapError(pld, ldaperr, NULL);
			_LeaveError(ldaperr, m_fNew? "ldap_add_s" : "ldap_modify_sW");
		    }
        }

        //we update the OID information on the DS
        if((pwszOID) && ((m_fNew) || (m_fUpdateDisplayName)))
        {
 	        //This will work with both W2K schema and W2K+ schema

            //we only update the OID friendly name for user created OIDs and
            //default V2 template
            if(CERTTYPE_SCHEMA_VERSION_2 <= m_dwSchemaVersion)
            {
                I_CAOIDAdd(
                        CERT_OID_TYPE_TEMPLATE,
                        0,
                        pwszOID);

                I_CAOIDSetProperty(
                        pwszOID,
                        CERT_OID_PROPERTY_DISPLAY_NAME,
                        pwszFriendlyName);
            }
        }

        m_fNew = FALSE;
        hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:


    if (NULL != modCN.mod_values && awszNull != modCN.mod_values)
    {
        FreeProperty(modCN.mod_values);
    }
    if (NULL != modFriendlyName.mod_values && awszNull != modFriendlyName.mod_values)
    {
        FreeProperty(modFriendlyName.mod_values);
    }
    if (NULL != modEKU.mod_values && awszNull != modEKU.mod_values)
    {
        FreeProperty(modEKU.mod_values);
    }
    if (NULL != pwszCSPList)
    {
        FreeProperty(pwszCSPList);
    }

    if((NULL != modCSP.mod_values) && (awszNull != modCSP.mod_values))
    {
        LPWSTR *pwszCurrent = modCSP.mod_values;
        while(*pwszCurrent)
        {
            LocalFree(*pwszCurrent++);
        }
        LocalFree(modCSP.mod_values);
    }

    if (NULL != modCriticalExts.mod_values && awszNull != modCriticalExts.mod_values)
    {
        FreeProperty(modCriticalExts.mod_values);
    }

	//free V2 properties
	for(iIndex=0; iIndex < V2_PROPERTY_COUNT; iIndex++)
	{
		if( (NULL != rgPropMod[iIndex].modData.mod_values) &&
			(awszNull != rgPropMod[iIndex].modData.mod_values) &&
			(g_CTV2Properties[iIndex].fStringProperty))
			FreeProperty(rgPropMod[iIndex].modData.mod_values);
	}


    if(bstrDN)
    {
        CertFreeString(bstrDN);
    }
    if(bstrConfig)
    {
        CertFreeString(bstrConfig);
    }

    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}




//+--------------------------------------------------------------------------
// CCertTypeInfo::Delete -- Delete CertType Object
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::Delete(VOID)
{
    HRESULT hr = S_OK;
    DWORD   err=0;
    HKEY    hCertTypeCache = NULL;
    DWORD   disp;
    LDAP    *pld = NULL;
    ULONG   ldaperr;

    CERTSTR bstrConfig = NULL;
    CERTSTR bstrDN = NULL;


    // Delete From DS;
    __try
    {
	// bind to ds
	hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
	_LeaveIfError(hr, "myRobustLdapBindEx");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	_LeaveIfError(hr, "CAGetAuthoritativeDomainDn");

        bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszLocation)+wcslen(m_bstrType)+4);
        if(bstrDN == NULL)
        {
            hr = E_OUTOFMEMORY;
	    _LeaveError(hr, "CertAllocStringLen");
        }
        wcscpy(bstrDN, L"CN=");
        wcscat(bstrDN, m_bstrType);
        wcscat(bstrDN, L",");
        wcscat(bstrDN, s_wszLocation);
        wcscat(bstrDN, bstrConfig);

        ldaperr = ldap_delete_s(pld, bstrDN);
	hr = myHLdapError(pld, ldaperr, NULL);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if(hr != S_OK)
    {
        goto error;
    }

    // Delete from local cache

    err = ctRegCreateKeyEx((m_fLocalSystemCache)?HKEY_LOCAL_MACHINE:HKEY_CURRENT_USER,
                         wszCERTTYPECACHE,
                         NULL,
                         TEXT(""),
                         REG_OPTION_NON_VOLATILE,
                           KEY_ENUMERATE_SUB_KEYS |
                           KEY_EXECUTE |
                           KEY_QUERY_VALUE,
                         NULL,
                         &hCertTypeCache,
                         &disp);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }


    err = RegDeleteKey(hCertTypeCache, m_bstrType);

    if(err != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(err);
        goto error;
    }

    hr=S_OK;

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

    if(hCertTypeCache)
    {
        RegCloseKey(hCertTypeCache);
    }
    if(bstrDN)
    {
        CertFreeString(bstrDN);
    }
    if(bstrConfig)
    {
        CertFreeString(bstrConfig);
    }
    return hr;

}




//+--------------------------------------------------------------------------
// CCertTypeInfo::Next -- Returns the next object in the chain of CA objects
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::Next(CCertTypeInfo **ppCTInfo)
{
    if(ppCTInfo == NULL)
    {
        return E_POINTER;
    }
    *ppCTInfo = m_pNext;
    if(m_pNext)
    {
        m_pNext->AddRef();
    }
    return S_OK;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetProperty -- Retrieves the values of a property of the CA object
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::GetProperty(
    LPCWSTR wszPropertyName,
    LPWSTR **pawszProperties)
{
    CCAProperty *pProp;
    HRESULT     hr;
    LPWSTR      *awszResult = NULL;
    UINT        idsDescription=IDS_UNKNOWN_DESCRIPTION;
    DWORD       dwIndex=0;
    DWORD       cbOID=0;

    if((wszPropertyName == NULL) || (pawszProperties == NULL))
    {
        return  E_POINTER;
    }

    //special case for eku for V2 template.  We return application policy
    //for EKU for V2 template
    if(m_dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
    {
        if(0==LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_EXTENDED_KEY_USAGE))
        {
            wszPropertyName=CERTTYPE_PROP_APPLICATION_POLICY;
        }

    }

    //special case for description, which is a derived property
    if(0==LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_DESCRIPTION))
    {
        WCHAR * wszDescription=NULL;

        //find the string that matches the template
        for(dwIndex=0; dwIndex < g_CTDescriptionCount; dwIndex++)
        {
            if(
                (g_CTDescriptions[dwIndex].dwGeneralValue == (CERT_TYPE_GENERAL_FILTER & GetFlags(CERTTYPE_GENERAL_FLAG))) &&
                (g_CTDescriptions[dwIndex].dwEnrollValue == (CERT_TYPE_ENROLL_FILTER & GetFlags(CERTTYPE_ENROLLMENT_FLAG))) &&
                (g_CTDescriptions[dwIndex].dwNameValue == (CERT_TYPE_NAME_FILTER & GetFlags(CERTTYPE_SUBJECT_NAME_FLAG)))
              )
            {
                idsDescription = g_CTDescriptions[dwIndex].idsDescription;
                break;
            }
        }

        // load the string and build a result like GetValue returns
        hr=myLoadRCString(g_hInstance, idsDescription, &wszDescription);

        if (S_OK!=hr)
            return hr;

        awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(wszDescription)+1)*sizeof(WCHAR)));
        if (NULL==awszResult)
        {
            LocalFree(wszDescription);
            return E_OUTOFMEMORY;
        }

        awszResult[0]=(WCHAR *)(&awszResult[2]);
        awszResult[1]=NULL;
        wcscpy(awszResult[0], wszDescription);
        LocalFree(wszDescription);
        *pawszProperties=awszResult;
        return S_OK;
    }

    // special case for friendly name, since in a multi-lingual enterprise,
    // the language in the DS may not be the one we want.

    if (0 == LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_FRIENDLY_NAME))
    {
        // find the common name
        hr = m_pProperties->Find(CERTTYPE_PROP_CN, &pProp);
        if (S_OK!=hr)
        {
            return hr;
        }
        hr = pProp->GetValue(&awszResult);

		if((NULL == awszResult) || (NULL == awszResult[0]))
		{
			hr = E_UNEXPECTED;
		}

        if (hr!=S_OK)
        {
			if(awszResult)
			{
				FreeProperty(awszResult);
				awszResult=NULL;
			}

            return hr;
        }

        // find the common name in our table

        unsigned int nIndex;
        for (nIndex=0; nIndex<g_cDefaultCertTypes; nIndex++)
        {
            if (0==mylstrcmpiL(awszResult[0] , g_aDefaultCertTypes[nIndex].wszName))
            {
                break;
            }
        }
        FreeProperty(awszResult);
        awszResult = NULL;

        // we found it
        if (g_cDefaultCertTypes!=nIndex)
        {
            WCHAR * wszFriendlyName;

            // load the string and build a result like GetValue returns
            hr=myLoadRCString(g_hInstance, g_aDefaultCertTypes[nIndex].idFriendlyName, &wszFriendlyName);
            if (S_OK!=hr)
            {
                return hr;
            }
            awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(wszFriendlyName)+1)*sizeof(WCHAR)));
            if (NULL==awszResult)
            {
                LocalFree(wszFriendlyName);
                return E_OUTOFMEMORY;
            }
            awszResult[0]=(WCHAR *)(&awszResult[2]);
            awszResult[1]=NULL;
            wcscpy(awszResult[0], wszFriendlyName);
            LocalFree(wszFriendlyName);
            *pawszProperties=awszResult;
            return S_OK;
        }
        else
        {
            PCCRYPT_OID_INFO    pOIDInfo=NULL;
            LPSTR               szOID=NULL;

            //this is a custom created certificate template.
            //so we have to find the friendly name based on the OID
            // find the OID for the template
            if(m_dwSchemaVersion >= CERTTYPE_SCHEMA_VERSION_2)
            {
                if(S_OK != (hr = m_pProperties->Find(CERTTYPE_PROP_OID, &pProp)))
                    return hr;

                hr = pProp->GetValue(&awszResult);
                if((NULL == awszResult) || (NULL==awszResult[0]))
                   hr = E_UNEXPECTED;

                if (S_OK != hr)
                {
                    if(awszResult)
                        FreeProperty(awszResult);
                    return hr;
                }

                //find the OID
                if(0 == (cbOID = WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszResult[0],
                                          -1,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL)))
                {
                    FreeProperty(awszResult);
                    hr = GetLastError();
                    return hr;
                }

                szOID=(LPSTR)LocalAlloc(LPTR, cbOID);

                if(NULL==szOID)
                {
                    FreeProperty(awszResult);
                    hr = E_OUTOFMEMORY;
                    return hr;
                }

                if(0 == WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszResult[0],
                                          -1,
                                          szOID,
                                          cbOID,
                                          NULL,
                                          NULL))
                {
                    hr = GetLastError();
                    FreeProperty(awszResult);
                    LocalFree(szOID);
                    return hr;
                }

                pOIDInfo=CryptFindOIDInfo(
                            CRYPT_OID_INFO_OID_KEY,
                            szOID,
                            CRYPT_TEMPLATE_OID_GROUP_ID);

                //free the OID property
                FreeProperty(awszResult);
                awszResult = NULL;

                LocalFree(szOID);
                szOID=NULL;

                if(pOIDInfo)
                {
                    if(pOIDInfo->pwszName)
                    {
                        awszResult=(WCHAR **)LocalAlloc(LPTR, (UINT)(sizeof(WCHAR *)*2+(wcslen(pOIDInfo->pwszName)+1)*sizeof(WCHAR)));
                        if (NULL==awszResult)
                            return E_OUTOFMEMORY;

                        awszResult[0]=(WCHAR *)(&awszResult[2]);
                        awszResult[1]=NULL;
                        wcscpy(awszResult[0], pOIDInfo->pwszName);
                        *pawszProperties=awszResult;
                        return S_OK;
                    }
                }
            }
        }
    }

    hr = m_pProperties->Find(wszPropertyName, &pProp);

    if(hr != S_OK)
    {
        return hr;
    }

    hr = pProp->GetValue(&awszResult);

    if(hr != S_OK)
    {
        return hr;
    }

    if(((awszResult == NULL) || (awszResult[0] == NULL)) &&
        (LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_FRIENDLY_NAME) == 0))
    {
        if(awszResult)
        {
            FreeProperty(awszResult);
            awszResult=NULL;
        }
        return GetProperty(CERTTYPE_PROP_CN, pawszProperties);
    }
    else
    {
        *pawszProperties = awszResult;
        return hr;
    }
}


//+--------------------------------------------------------------------------
// IsV2Property
//
//
//+--------------------------------------------------------------------------
BOOL    IsV2Property(LPCWSTR pwszPropertyName)
{
    DWORD   iIndex=0;
    BOOL    fV2=FALSE;

    for(iIndex=0; iIndex < g_CTV2PropertiesCount; iIndex++)
    {
        if(0==mylstrcmpiS(pwszPropertyName, g_CTV2Properties[iIndex].pwszProperty))
        {
            fV2=TRUE;
            break;
        }
    }

    return fV2;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetPropertyEx -- Retrieves the values of a property of the CA object
//
//
//+--------------------------------------------------------------------------
HRESULT CCertTypeInfo::GetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue)
{
    HRESULT hr=S_OK;

    if((NULL==wszPropertyName) || (NULL==pPropertyValue))
        return E_POINTER;

    //we only allow schema version to be returned for v1 templates
    if((0 == m_dwSchemaVersion) && (IsV2Property(wszPropertyName)))
    {
        if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0)
        {
            *((DWORD *)pPropertyValue)=CERTTYPE_SCHEMA_VERSION_1;
            return S_OK;
        }
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

	if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_MINOR_REVISION)==0)
		*((DWORD *)pPropertyValue)=m_dwMinorRevision;
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_RA_SIGNATURE)==0)
		*((DWORD *)pPropertyValue)=m_dwRASignature;
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
		*((DWORD *)pPropertyValue)=m_dwMinimalKeySize;
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0)
		*((DWORD *)pPropertyValue)=m_dwSchemaVersion;
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_REVISION)==0)
		*((DWORD *)pPropertyValue)=m_Revision;
	else
	{
		hr=GetProperty(wszPropertyName, (LPWSTR **)pPropertyValue);

	}

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::SetProperty -- set the values of a property of the CA object
//
//  Obsolete
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::SetProperty(LPCWSTR wszPropertyName, LPWSTR *awszProperties)
{
    CCAProperty *pProp=NULL;
    HRESULT     hr=E_FAIL;

    if(wszPropertyName == NULL)
    {
        return  E_POINTER;
    }

    hr = m_pProperties->Find(wszPropertyName, &pProp);

    if(hr != S_OK)
    {
        pProp = new CCAProperty(wszPropertyName);
		

        if(pProp == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr=pProp->SetValue(awszProperties);

		if(S_OK == hr)
		{
			hr=CCAProperty::Append(&m_pProperties, pProp);
		}

		if(S_OK != hr)
		{
			if(pProp)
				CCAProperty::DeleteChain(&pProp);
		}
    }
    else
    {
        hr=pProp->SetValue(awszProperties);
    }

    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::SetPropertyEx -- set the values of a property of the CA object
//
//  If CERTTYPE_PROP_CN is set, the certificate type is a clone if the existing one.
//
//+--------------------------------------------------------------------------
HRESULT CCertTypeInfo::SetPropertyEx(LPCWSTR wszPropertyName, LPVOID   pPropertyValue)
{
    HRESULT     hr=S_OK;
    LPWSTR      awszValue[2];

    LPWSTR      *awszCN=NULL;
    LPWSTR      *awszEKU=NULL;
    LPWSTR      pwszOID=NULL;

    if(NULL==wszPropertyName)
        return E_POINTER;

    //SCHEMA VERSION and DN are not settable
    if((LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0) ||
       (LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_DN)==0)
      )
      return E_UNEXPECTED;

    if((m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2) && (IsV2Property(wszPropertyName)))
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

    //check if CN is going to be changed
    if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_CN)==0)
    {
        if(NULL == pPropertyValue)
            return E_POINTER;

        if(NULL == ((LPWSTR *)pPropertyValue)[0])
            return E_POINTER;

        if(S_OK != (hr=GetPropertyEx(wszPropertyName, &awszCN)))
            return hr;
    }

	if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_MINOR_REVISION)==0)
		m_dwMinorRevision=*((DWORD *)pPropertyValue);
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_RA_SIGNATURE)==0)
		m_dwRASignature=*((DWORD *)pPropertyValue);
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_MIN_KEY_SIZE)==0)
		m_dwMinimalKeySize=*((DWORD *)pPropertyValue);
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_SCHEMA_VERSION)==0)
		m_dwSchemaVersion=*((DWORD *)pPropertyValue);
	else if(LSTRCMPIS(wszPropertyName, CERTTYPE_PROP_REVISION)==0)
		m_Revision=*((DWORD *)pPropertyValue);
	else
    {
        hr=SetProperty(wszPropertyName, (LPWSTR *)pPropertyValue);

        //check if CN is changed.
        if((S_OK == hr) && (awszCN))
        {
            if((awszCN[0]) && (0!=mylstrcmpiL(awszCN[0],((LPWSTR *)pPropertyValue)[0])))
            {
                if(m_bstrType)
                {
                    CertFreeString(m_bstrType);
                    m_bstrType = NULL;
                }

                m_bstrType = CertAllocString(((LPWSTR *)pPropertyValue)[0]);
                if(NULL==m_bstrType)
                    hr=E_OUTOFMEMORY;

                if(S_OK == hr)
                    hr=SetProperty(CERTTYPE_PROP_DN, (LPWSTR *)pPropertyValue);

                if(S_OK == hr)
                {
                    m_fNew=TRUE;
                    m_dwFlags &= CT_MASK_SETTABLE_FLAGS;
                    m_Revision=CERTTYPE_VERSION_NEXT;

                    //we upgrade the schema if necessary
                    //and move the EKU property to the application policy property
                    if(m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2)
                    {
                        if(S_OK == GetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, &awszEKU))
                            SetProperty(CERTTYPE_PROP_APPLICATION_POLICY, awszEKU);
                    	m_dwSchemaVersion=CERTTYPE_SCHEMA_VERSION_2;
                    }

                    //we get a new OID for the certificate template
                    hr=I_CAOIDCreateNew(CERT_OID_TYPE_TEMPLATE, 0, &pwszOID);

                    if(S_OK == hr)
                    {
                        awszValue[0]=pwszOID;
                        awszValue[1]=NULL;
                        hr=SetProperty(CERTTYPE_PROP_OID, awszValue);
                    }

                    //we then set the displayName property to NULL
                    if(S_OK == hr)
                    {
                        awszValue[0]=NULL;
                        hr=SetProperty(CERTTYPE_PROP_FRIENDLY_NAME, awszValue);
                    }

                }
            }
        }
    }

    if(awszEKU)
        FreeProperty(awszEKU);

    if(awszCN)
        FreeProperty(awszCN);

    if(pwszOID)
        LocalFree(pwszOID);

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::FreeProperty -- Free's a previously returned property array
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::FreeProperty(LPWSTR *pawszProperties)
{
    LocalFree(pawszProperties);
    return S_OK;
}


//+--------------------------------------------------------------------------
// MapFlags
//
//
//+--------------------------------------------------------------------------

DWORD   MapFlags(CERT_TYPE_FLAG_MAP *rgdwMap, DWORD cbSize, DWORD dwGeneralFlags)
{
    DWORD iIndex=0;
    DWORD dwFlags=0;

    for(iIndex=0; iIndex<cbSize; iIndex++)
    {
        if(rgdwMap[iIndex].dwOldFlag & dwGeneralFlags)
            dwFlags |= rgdwMap[iIndex].dwNewFlag;
    }

    return dwFlags;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetFlags
//
//
//+--------------------------------------------------------------------------

DWORD CCertTypeInfo::GetFlags(DWORD    dwOption)
{
    DWORD           dwFlags=0;
    DWORD           dwIndex=0;
    CCAProperty     *pProp=NULL;

    LPWSTR          *awszResult = NULL;

    //we want to map the flags for old schema
    if(0 == m_dwSchemaVersion)
    {
        switch(dwOption)
        {
            case CERTTYPE_ENROLLMENT_FLAG:
                   dwFlags = MapFlags(g_rgdwEnrollFlagMap, g_cEnrollFlagMap, m_dwFlags);
                break;

            case CERTTYPE_SUBJECT_NAME_FLAG:
                   dwFlags = MapFlags(g_rgdwSubjectFlagMap, g_cSubjectFlagMap, m_dwFlags);

                   //we will try to get the subject name flag from our table, since
                   //new CA policy module needs the extra flags
                   if(m_pProperties)
                   {
                       if(S_OK == m_pProperties->Find(CERTTYPE_PROP_CN, &pProp))
                       {
                            if(S_OK == pProp->GetValue(&awszResult))
                            {
                                if((awszResult) && (awszResult[0]))
                                {
                                    // find the common name in our table
                                    for(dwIndex=0; dwIndex < g_cDefaultCertTypes; dwIndex++)
                                    {
                                        if(0==mylstrcmpiL(awszResult[0] , g_aDefaultCertTypes[dwIndex].wszName))
                                        {
                                            dwFlags=g_aDefaultCertTypes[dwIndex].dwCertificateNameFlags;
                                            break;
                                        }
                                    }
                                }
                            }

                            if(awszResult)
                                FreeProperty(awszResult);
                       }
                    }
                break;

            case CERTTYPE_PRIVATE_KEY_FLAG:
                   dwFlags = MapFlags(g_rgdwPrivateKeyFlagMap, g_cPrivateKeyFlagMap, m_dwFlags);
                break;

            case CERTTYPE_GENERAL_FLAG:
                    dwFlags = m_dwFlags;
                break;
            default:
                    dwFlags = 0;
                break;
        }
    }
    else
    {
        //for schema, return directly.  We have additional flags in general flags
        //for V1 templates, which is correct for backward compatibility
        switch(dwOption)
        {
            case CERTTYPE_ENROLLMENT_FLAG:
                    dwFlags = m_dwEnrollmentFlags;
                break;

            case CERTTYPE_SUBJECT_NAME_FLAG:
                    dwFlags = m_dwCertificateNameFlags;
                break;

            case CERTTYPE_PRIVATE_KEY_FLAG:
                   dwFlags = m_dwPrivateKeyFlags;
                break;

            case CERTTYPE_GENERAL_FLAG:
                    dwFlags = m_dwFlags;
                break;

            default:
                    dwFlags = 0;
                break;
        }
    }

    return dwFlags;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::SetFlags
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::SetFlags(DWORD     dwOption, DWORD dwFlags)
{

    //we can not set flags for V1 template
    if(m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2)
        return E_UNEXPECTED;

    switch(dwOption)
    {
        case CERTTYPE_ENROLLMENT_FLAG:
                m_dwEnrollmentFlags = dwFlags;
            break;

        case CERTTYPE_SUBJECT_NAME_FLAG:
                m_dwCertificateNameFlags = dwFlags;
            break;

        case CERTTYPE_PRIVATE_KEY_FLAG:
               m_dwPrivateKeyFlags = dwFlags;
            break;

        case CERTTYPE_GENERAL_FLAG:
                m_dwFlags = (m_dwFlags & ~CT_MASK_SETTABLE_FLAGS) | (dwFlags & CT_MASK_SETTABLE_FLAGS);
            break;
        default:
            return E_INVALIDARG;
    }

    return S_OK;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_IsCritical -- Is a particular extension critical
//
//
//+--------------------------------------------------------------------------

BOOL CCertTypeInfo::_IsCritical(LPCWSTR wszExtension, LPCWSTR *awszCriticalExtensions)
{

    LPCWSTR * pwszCurCritical = awszCriticalExtensions;

    if((awszCriticalExtensions == NULL) ||
       (wszExtension == NULL))
    {
        return FALSE;
    }


    while(*pwszCurCritical)
    {
        if(wcscmp(*pwszCurCritical, wszExtension) == 0)
        {
            return TRUE;
        }
        pwszCurCritical++;

    }

    return FALSE;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::GetExtensions --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::GetExtensions(
    IN  DWORD             dwFlags,
    OUT PCERT_EXTENSIONS *ppCertExtensions)
{
    HRESULT hr = S_OK;
    PCERT_EXTENSIONS pExtensions = NULL;

    CERTSTR bstrBasicConstraints = NULL;
    CERTSTR bstrEKU = NULL;
    CERTSTR bstrCertType = NULL;
    CERTSTR bstrKU = NULL;
    CERTSTR bstrPolicies=NULL;
    CERTSTR bstrAppPolicies=NULL;

    DWORD   cbTotal=0;
    PBYTE   pbData=NULL;
    DWORD   i=0;
    LPCWSTR * awszCritical = NULL;

    if(ppCertExtensions == NULL)
    {
        return E_POINTER;
    }

    hr = GetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR **>(&awszCritical));
    _JumpIfError(hr, error, "GetProperty");

    // The extensions are built out of the
    // name extension, the eku, the ku,
    // the basic constraints, the certificate policy
    // and any additional extensions.

    if((0 == dwFlags) || (CT_EXTENSION_BASIC_CONTRAINTS & dwFlags))
    {
        hr = _GetBasicConstraintsValue(&bstrBasicConstraints);
        _JumpIfError(hr, error, "_GetBasicConstraintsValue");
        
        if((CT_EXTENSION_BASIC_CONTRAINTS & dwFlags) && (NULL == bstrBasicConstraints))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetBasicConstraintsValue");
        }
    }

    if((0 == dwFlags) || (CT_EXTENSION_EKU & dwFlags))
    {
        hr = _GetEKUValue(&bstrEKU);
        _JumpIfError(hr, error, "_GetEKUValue");

        if((CT_EXTENSION_EKU & dwFlags) && (NULL == bstrEKU))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetEKUValue");
        }
    }

    if((0 == dwFlags) || (CT_EXTENSION_KEY_USAGE & dwFlags))
    {
        hr = _GetKUValue(&bstrKU);
        _JumpIfError(hr, error, "_GetKUValue");

        if((CT_EXTENSION_KEY_USAGE & dwFlags) && (NULL == bstrKU))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetKUValue");
        }
    }

    
    if((0 == dwFlags) || (CT_EXTENSION_TEMPLATE & dwFlags))
    {   
        hr = _GetTypeExtensionValue(TRUE, &bstrCertType);
        _JumpIfError(hr, error, "_GetTypeExtensionValue");

        if((CT_EXTENSION_TEMPLATE & dwFlags) && (NULL == bstrCertType))
        {
            hr=CRYPT_E_NOT_FOUND;
            _JumpIfError(hr, error, "_GetTypeExtensionValue");
        }
    }

    //bstrPolicies will not be NULL only if the value is set (SCHEMA VERSION 2 or later)
    if(0!=m_dwSchemaVersion)
    {
        if((0 == dwFlags) || (CT_EXTENSION_ISSUANCE_POLICY & dwFlags))
        {
            hr = _GetPoliciesValue(CERTTYPE_PROP_POLICY, &bstrPolicies);
            _JumpIfError(hr, error, "_GetPoliciesValue");
        }
    }

    if((CT_EXTENSION_ISSUANCE_POLICY & dwFlags) && (NULL == bstrPolicies))
    {
        hr=CRYPT_E_NOT_FOUND;
        _JumpIfError(hr, error, "_GetPoliciesValue");
    }

    if(0!=m_dwSchemaVersion)
    {
        if((0 == dwFlags) || ( CT_EXTENSION_APPLICATION_POLICY & dwFlags))
        {
            hr = _GetPoliciesValue(CERTTYPE_PROP_APPLICATION_POLICY, &bstrAppPolicies);
            _JumpIfError(hr, error, "_GetAppPoliciesValue");
        }
    }

    if((CT_EXTENSION_APPLICATION_POLICY & dwFlags) && (NULL == bstrAppPolicies))
    {
        hr=CRYPT_E_NOT_FOUND;
        _JumpIfError(hr, error, "_GetAppPoliciesValue");
    }

    i = 0;

    cbTotal = sizeof(CERT_EXTENSIONS);
    if(bstrCertType)
    {
        cbTotal += CertStringByteLen(bstrCertType) + sizeof(CERT_EXTENSION);
        i++;
    }
    if(bstrEKU)
    {
        cbTotal += CertStringByteLen(bstrEKU) + sizeof(CERT_EXTENSION);
        i++;
    }
    if(bstrKU)
    {
        cbTotal += CertStringByteLen(bstrKU) + sizeof(CERT_EXTENSION);
        i++;
    }
    if(bstrBasicConstraints)
    {
        cbTotal += CertStringByteLen(bstrBasicConstraints) + sizeof(CERT_EXTENSION);
        i++;
    }

    if(bstrPolicies)
    {
        cbTotal += CertStringByteLen(bstrPolicies) + sizeof(CERT_EXTENSION);
        i++;
    }

    if(bstrAppPolicies)
    {
        cbTotal += CertStringByteLen(bstrAppPolicies) + sizeof(CERT_EXTENSION);
        i++;
    }

    pExtensions = (PCERT_EXTENSIONS)LocalAlloc(LMEM_FIXED, cbTotal);

    if(pExtensions == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pExtensions->rgExtension = (PCERT_EXTENSION)(pExtensions+1);
    pExtensions->cExtension = i;

    i = 0;
    pbData = (PBYTE)(pExtensions->rgExtension+pExtensions->cExtension);

    if(bstrCertType)
    {
        //decide to encode as V1 or V2 template extension
        pExtensions->rgExtension[i].fCritical = _IsCritical((m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2) ?
            TEXT(szOID_ENROLL_CERTTYPE_EXTENSION) : TEXT(szOID_CERTIFICATE_TEMPLATE), awszCritical);
        pExtensions->rgExtension[i].pszObjId = (m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2) ?
            szOID_ENROLL_CERTTYPE_EXTENSION: szOID_CERTIFICATE_TEMPLATE;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrCertType);
        CopyMemory(pbData, bstrCertType, CertStringByteLen(bstrCertType));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrEKU)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_ENHANCED_KEY_USAGE), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_ENHANCED_KEY_USAGE;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrEKU);
        CopyMemory(pbData, bstrEKU, CertStringByteLen(bstrEKU));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrKU)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_KEY_USAGE), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_KEY_USAGE;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrKU);
        CopyMemory(pbData, bstrKU, CertStringByteLen(bstrKU));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrBasicConstraints)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_BASIC_CONSTRAINTS2), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_BASIC_CONSTRAINTS2;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrBasicConstraints);
        CopyMemory(pbData, bstrBasicConstraints, CertStringByteLen(bstrBasicConstraints));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrPolicies)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_CERT_POLICIES), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_CERT_POLICIES;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrPolicies);
        CopyMemory(pbData, bstrPolicies, CertStringByteLen(bstrPolicies));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    if(bstrAppPolicies)
    {
        pExtensions->rgExtension[i].fCritical = _IsCritical(TEXT(szOID_APPLICATION_CERT_POLICIES), awszCritical);
        pExtensions->rgExtension[i].pszObjId = szOID_APPLICATION_CERT_POLICIES;
        pExtensions->rgExtension[i].Value.pbData = pbData;
        pExtensions->rgExtension[i].Value.cbData = CertStringByteLen(bstrAppPolicies);
        CopyMemory(pbData, bstrAppPolicies, CertStringByteLen(bstrAppPolicies));
        pbData += pExtensions->rgExtension[i].Value.cbData;
        i++;
    }

    *ppCertExtensions = pExtensions;

error:
    if(bstrCertType)
    {
        CertFreeString(bstrCertType);
    }
    if(bstrEKU)
    {
        CertFreeString(bstrEKU);
    }
    if(bstrKU)
    {
        CertFreeString(bstrKU);
    }
    if(bstrBasicConstraints)
    {
        CertFreeString(bstrBasicConstraints);
    }
    if(bstrPolicies)
    {
        CertFreeString(bstrPolicies);
    }
    if(bstrAppPolicies)
    {
        CertFreeString(bstrAppPolicies);
    }
    if(awszCritical)
    {
        FreeProperty(const_cast<LPWSTR *>(awszCritical));
    }
    return hr;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetTypeExtensionValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetTypeExtensionValue(IN BOOL fCheckVersion,
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT                 hr = S_OK;
    CERTSTR                 bstrOut = NULL;
    CERT_NAME_VALUE         Value;
    CERT_TEMPLATE_EXT       TemplateExt;
    DWORD                   cbCertTypeExtension=0;
    DWORD                   cbOID=0;

    LPSTR                   szOID=NULL;
    LPWSTR                  *rgwszOID=NULL;

    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    //check to see we need to encode with the new cert type extention
    if((FALSE == fCheckVersion)||(m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2))
    {
        Value.dwValueType = CERT_RDN_UNICODE_STRING;
        Value.Value.pbData = (PBYTE)m_bstrType;
        Value.Value.cbData = 0;
    }
    else
    {
        memset(&TemplateExt, 0, sizeof(TemplateExt));

        if(S_OK != (hr=GetPropertyEx(CERTTYPE_PROP_OID, &rgwszOID)))
            goto error;

        if((rgwszOID == NULL) || (rgwszOID[0] == NULL))
        {
             hr = E_INVALIDARG;
             goto error;
        }

        if(0 == (cbOID = WideCharToMultiByte(CP_ACP,
                                  0,
                                  rgwszOID[0],
                                  wcslen(rgwszOID[0])+1,
                                  szOID,
                                  0,
                                  NULL,
                                  NULL)))
        {
            hr = GetLastError();
            goto error;
        }

        szOID=(LPSTR)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, cbOID);

        if(NULL==szOID)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        if(0 == WideCharToMultiByte(CP_ACP,
                                  0,
                                  rgwszOID[0],
                                  wcslen(rgwszOID[0])+1,
                                  szOID,
                                  cbOID,
                                  NULL,
                                  NULL))
        {
            hr = GetLastError();
            goto error;
        }

        TemplateExt.pszObjId = szOID;
        TemplateExt.dwMajorVersion = m_Revision;
        TemplateExt.fMinorVersion = TRUE;
        TemplateExt.dwMinorVersion = m_dwMinorRevision;
    }

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          rgwszOID ? szOID_CERTIFICATE_TEMPLATE : X509_UNICODE_ANY_STRING,
                          rgwszOID ? ((LPVOID)(&TemplateExt)) : ((LPVOID)(&Value)),
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          rgwszOID ? szOID_CERTIFICATE_TEMPLATE : X509_UNICODE_ANY_STRING,
                          rgwszOID ? ((LPVOID)(&TemplateExt)) : ((LPVOID)(&Value)),
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }

    *bstrValue = bstrOut;
    bstrOut = NULL;

error:

    if(szOID)
        LocalFree(szOID);

    if(rgwszOID)
        FreeProperty(rgwszOID);

    if(bstrOut)
        CertFreeString(bstrOut);

    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetEKUValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetEKUValue(
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT hr = S_OK;
    CERTSTR bstrOut = NULL;
    DWORD cbEkuAscii;
    CERT_ENHKEY_USAGE Usage;

    DWORD iEku;

    DWORD cbCertTypeExtension;


    WCHAR **awszEku = NULL;
    CHAR *szCur;
    Usage.rgpszUsageIdentifier = NULL;


    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    hr = GetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE,&awszEku);
    if(hr != S_OK)
    {
        goto error;
    }

    if((awszEku == NULL) ||
        (awszEku[0] == NULL))
    {
         hr = S_OK;
         *bstrValue = NULL;
        goto error;
    }

    // Convert all of the widechar vals to multi byte
    // vals
    iEku =0;
    cbEkuAscii = 0;
    while(awszEku[iEku])
    {
        cbEkuAscii += WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszEku[iEku],
                                          wcslen(awszEku[iEku])+1,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL);
        iEku++;
    }

    Usage.rgpszUsageIdentifier = (LPSTR *)LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(char *)*iEku + cbEkuAscii);
    if(Usage.rgpszUsageIdentifier == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    szCur = (LPSTR)(Usage.rgpszUsageIdentifier+iEku);

    iEku =0;
    while(awszEku[iEku])
    {
        cbEkuAscii -= WideCharToMultiByte(CP_ACP,
                                          0,
                                          awszEku[iEku],
                                          wcslen(awszEku[iEku])+1,
                                          szCur,
                                          cbEkuAscii,
                                          NULL,
                                          NULL);
        Usage.rgpszUsageIdentifier[iEku] = szCur;
        szCur += strlen(szCur)+1;

        iEku++;
    }

    Usage.cUsageIdentifier = iEku;


    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          &Usage,
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          &Usage,
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(awszEku)
    {
        FreeProperty(awszEku);
    }

    if(bstrOut)
    {
        CertFreeString(bstrOut);
    }
    if(Usage.rgpszUsageIdentifier)
    {
        LocalFree(Usage.rgpszUsageIdentifier);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetKUValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetKUValue(
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT hr = S_OK;
    CERTSTR bstrOut = NULL;




    DWORD cbCertTypeExtension;


    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    if((m_KeyUsage.cbData == 0) ||
        (m_KeyUsage.pbData == NULL))
    {
         hr = S_OK;
         *bstrValue = NULL;
         goto error;
    }


    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE,
                          &m_KeyUsage,
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE,
                          &m_KeyUsage,
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(bstrOut)
    {
        CertFreeString(bstrOut);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::_GetBasicConstraintsValue --
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::_GetBasicConstraintsValue(
        OUT CERTSTR *  bstrValue
        )
{
    HRESULT hr = S_OK;
    CERTSTR bstrOut = NULL;




    DWORD cbCertTypeExtension;


    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    if((m_dwFlags & CT_FLAG_IS_CA) || (m_dwFlags & CT_FLAG_IS_CROSS_CA))
        m_BasicConstraints.fCA = TRUE;
    else
	    m_BasicConstraints.fCA = FALSE;

     if(!m_BasicConstraints.fCA)
    {
        hr = S_OK;
        *bstrValue = NULL;
        goto error;
    }

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_BASIC_CONSTRAINTS2,
                          &m_BasicConstraints,
                          NULL,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    bstrOut = CertAllocStringByteLen(NULL, cbCertTypeExtension);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_BASIC_CONSTRAINTS2,
                          &m_BasicConstraints,
                          (PBYTE)bstrOut,
                          &cbCertTypeExtension))
    {
        hr = myHLastError();
        goto error;
    }
    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(bstrOut)
    {
        CertFreeString(bstrOut);
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::__GetPoliciesValue --
//
//
//+--------------------------------------------------------------------------
HRESULT CCertTypeInfo::_GetPoliciesValue(IN LPCWSTR pwszPropertyName, OUT  CERTSTR *  bstrValue)
{
    HRESULT                     hr=S_OK;
    CERT_POLICIES_INFO          CertPolicyInfo;
    DWORD                       cbData=0;
    DWORD                       iCount=0;
    DWORD                       iIndex=0;
    LPWSTR                      pwsz=NULL;
    CERT_NAME_VALUE             nameValue;
    DWORD                       cbChar=0;
    DWORD                       i=0;

    LPWSTR                      *rgwszPolicy=NULL;
    LPWSTR                      *rgPolicy1=NULL;
    CERTSTR                     bstrOut = NULL;
    BYTE                        **ppbData=NULL;
    CERT_POLICY_INFO            *pPolicyInfo=NULL;
    CERT_POLICY_QUALIFIER_INFO  *pQualifierInfo=NULL;
    LPWSTR                      pwszCPS=NULL;

    if(bstrValue == NULL)
    {
        return E_POINTER;
    }

    //init the output
    *bstrValue=NULL;

    if(S_OK != (hr=GetPropertyEx(pwszPropertyName, &rgPolicy1)))
        goto error;

    iCount=0;
    if(rgPolicy1)
    {
        i=0;
        while(rgPolicy1[i])
        {
            i++;
            iCount++;
        }
    }


    if(0==iCount)
    {
         hr = S_OK;
         goto error;
    }

    //copy the pointers
    rgwszPolicy=(LPWSTR * )LocalAlloc(LPTR, sizeof(LPWSTR) * (iCount + 1));
    if (NULL == rgwszPolicy)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }


    iIndex=0;
    if(rgPolicy1)
    {
        i=0;
        while(rgPolicy1[i])
        {
            rgwszPolicy[iIndex]=rgPolicy1[i];
            i++;
            iIndex++;
        }
    }

    rgwszPolicy[iIndex]=NULL;

    memset(&CertPolicyInfo, 0, sizeof(CertPolicyInfo));


    //allocate memory
    pPolicyInfo=(CERT_POLICY_INFO  *)LocalAlloc(LPTR, iCount * sizeof(CERT_POLICY_INFO));

    pQualifierInfo=(CERT_POLICY_QUALIFIER_INFO  *)LocalAlloc(LPTR, iCount * sizeof(CERT_POLICY_QUALIFIER_INFO));

    ppbData=(BYTE **)LocalAlloc(LPTR, iCount * sizeof(BYTE *));

    if((NULL==pPolicyInfo) || (NULL==pQualifierInfo) ||(NULL==ppbData))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    for(iIndex=0; iIndex < iCount; iIndex++)
    {
        cbChar=0;
        cbData=0;
        ppbData[iIndex]=NULL;

        //the string is in the form of "oid;CPS"; we do not consider the CPS
        //part.  We obtain the CPS from the OID container
        pwsz=wcschr(rgwszPolicy[iIndex], L';');
        if(pwsz)
        {
            *pwsz=L'\0';
        }

		//only need the CPS for issuance policy
		if(0 == wcscmp(CERTTYPE_PROP_POLICY, pwszPropertyName))
		{
			if(S_OK == I_CAOIDGetProperty(rgwszPolicy[iIndex], CERT_OID_PROPERTY_CPS, &pwszCPS))
			{
				memset(&nameValue, 0, sizeof(nameValue));
				nameValue.dwValueType = CERT_RDN_UNICODE_STRING;
				nameValue.Value.cbData = 0;
				nameValue.Value.pbData = (PBYTE)(pwszCPS);

				if( !CryptEncodeObject(
						CRYPT_ASN_ENCODING,
						X509_UNICODE_ANY_STRING,
						&nameValue,
						NULL,
						&cbData
						) )
				{
					hr = myHLastError();
					goto error;
				}

				if(NULL==(ppbData[iIndex]=(BYTE *)LocalAlloc(LPTR, cbData)))
				{
					hr = E_OUTOFMEMORY;
					goto error;
				}


				if( !CryptEncodeObject(
						CRYPT_ASN_ENCODING,
						X509_UNICODE_ANY_STRING,
						&nameValue,
						ppbData[iIndex],
						&cbData
						) )
				{
					hr = myHLastError();
					goto error;
				}

				if(pwszCPS)
				   I_CAOIDFreeProperty(pwszCPS);

				pwszCPS=NULL;
			}
		}

        cbChar= WideCharToMultiByte(
                    CP_ACP,                // codepage
                    0,                      // dwFlags
                    rgwszPolicy[iIndex],
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        if(0 == cbChar)
        {
            hr=E_UNEXPECTED;
            goto error;
        }

        if(NULL==(pPolicyInfo[iIndex].pszPolicyIdentifier=(LPSTR)LocalAlloc(
                        LPTR, cbChar)))
        {
            hr=E_OUTOFMEMORY;
            goto error;
        }

        cbChar= WideCharToMultiByte(
                    CP_ACP,                // codepage
                    0,                      // dwFlags
                    rgwszPolicy[iIndex],
                    -1,
                    pPolicyInfo[iIndex].pszPolicyIdentifier,
                    cbChar,
                    NULL,
                    NULL);

        if(0 == cbChar)
        {
            hr=E_UNEXPECTED;
            goto error;
        }


        if(cbData)
        {
            pPolicyInfo[iIndex].cPolicyQualifier=1;
            pPolicyInfo[iIndex].rgPolicyQualifier=&(pQualifierInfo[iIndex]);
        }
        else
        {
            pPolicyInfo[iIndex].cPolicyQualifier=0;
            pPolicyInfo[iIndex].rgPolicyQualifier=NULL;
        }

        pQualifierInfo[iIndex].pszPolicyQualifierId=szOID_PKIX_POLICY_QUALIFIER_CPS;
        pQualifierInfo[iIndex].Qualifier.cbData=cbData;
        pQualifierInfo[iIndex].Qualifier.pbData=ppbData[iIndex];
    }


    //encode the extension
    CertPolicyInfo.cPolicyInfo=iCount;
    CertPolicyInfo.rgPolicyInfo=pPolicyInfo;

    cbData=0;
    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          &CertPolicyInfo,
                          NULL,
                          &cbData))
    {
        hr = myHLastError();
        goto error;
    }

    bstrOut = CertAllocStringByteLen(NULL, cbData);
    if(bstrOut == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          szOID_CERT_POLICIES,
                          &CertPolicyInfo,
                          (PBYTE)bstrOut,
                          &cbData))
    {
        hr = myHLastError();
        goto error;
    }

    *bstrValue = bstrOut;
    bstrOut = NULL;

error:
    if(pPolicyInfo)
    {
        for(iIndex=0; iIndex < iCount; iIndex++)
        {
            if(pPolicyInfo[iIndex].pszPolicyIdentifier)
                LocalFree(pPolicyInfo[iIndex].pszPolicyIdentifier);
        }

        LocalFree(pPolicyInfo);
    }

    if(pQualifierInfo)
        LocalFree(pQualifierInfo);

    if(ppbData)
    {
        for(iIndex=0; iIndex < iCount; iIndex++)
        {
            if(ppbData[iIndex])
                LocalFree(ppbData[iIndex]);
        }

        LocalFree(ppbData);
    }

    if(bstrOut)
        CertFreeString(bstrOut);

    if(rgwszPolicy)
        LocalFree(rgwszPolicy);

    if(rgPolicy1)
        FreeProperty(rgPolicy1);

    if(pwszCPS)
        I_CAOIDFreeProperty(pwszCPS);

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::GetSecurity --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::GetSecurity(PSECURITY_DESCRIPTOR * ppSD)
{
    PSECURITY_DESCRIPTOR pResult = NULL;
    DWORD   cbSD;

    if(ppSD == NULL)
    {
        return E_POINTER;
    }
    if(m_pSD == NULL)
    {
        *ppSD = NULL;
        return S_OK;
    }

    if(!IsValidSecurityDescriptor(m_pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(m_pSD);

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, m_pSD, cbSD);

    *ppSD = pResult;

    return S_OK;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetSecurity --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::SetSecurity(PSECURITY_DESCRIPTOR pSD)
{
    PSECURITY_DESCRIPTOR pResult = NULL;
    DWORD   cbSD;

    if(pSD == NULL)
    {
        return E_POINTER;
    }

    if(!IsValidSecurityDescriptor(pSD))
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }
    cbSD = GetSecurityDescriptorLength(pSD);

	if(0 == cbSD)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
    }

    pResult = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, cbSD);

    if(pResult == NULL)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(pResult, pSD, cbSD);

    if(m_pSD)
    {
        LocalFree(m_pSD);
    }

    m_pSD = pResult;

    return S_OK;
}



//+--------------------------------------------------------------------------
// CCertTypeInfo::AccessCheck -- Check for enroll and autoenroll access rights
//
//
//+--------------------------------------------------------------------------

HRESULT CCertTypeInfo::AccessCheck(HANDLE ClientToken, DWORD dwOption)
{
    //for autoenrollment, we only allow for V2 or later
    if((CERTTYPE_ACCESS_CHECK_AUTO_ENROLL & dwOption) && (m_dwSchemaVersion < CERTTYPE_SCHEMA_VERSION_2))
        return E_ACCESSDENIED;

    return CAAccessCheckpEx(ClientToken, m_pSD, dwOption);

}

//+--------------------------------------------------------------------------
// CCertTypeInfo::SetExtension -- Set the extension for this cert type
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::SetExtension(IN LPCWSTR wszExtensionName,
                                    IN LPVOID pExtension,
                                    IN DWORD  dwFlags)
{
    HRESULT hr = S_OK;
    LPCWSTR  * awszCritical = NULL;
    LPCWSTR  * pwszCurCritical = NULL;
    DWORD      cCritical = 0;

    if(wszExtensionName == NULL)
    {
        return E_POINTER;
    }

    if(wcscmp(wszExtensionName, TEXT(szOID_ENHANCED_KEY_USAGE)) == 0)
    {
        PCERT_ENHKEY_USAGE pEnhKeyUsage = (PCERT_ENHKEY_USAGE)pExtension;
        WCHAR **awszEKU;
        WCHAR *wszData;
        DWORD cbEKU, cStr;
        DWORD i;
        if(pExtension == NULL)
        {
            hr = SetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, NULL);
            return hr;
        }
        // Add an extra NULL to the end of the list of strings,
        // and convert them to WCHAR
        cbEKU = (pEnhKeyUsage->cUsageIdentifier +1)* sizeof(WCHAR *);
        for(i=0; i < pEnhKeyUsage->cUsageIdentifier; i++)
        {
            cbEKU += sizeof(WCHAR)*MultiByteToWideChar(CP_ACP,
                                  0,
                                  pEnhKeyUsage->rgpszUsageIdentifier[i],
                                  strlen(pEnhKeyUsage->rgpszUsageIdentifier[i])+1,
                                  NULL,
                                  0);
        }
        awszEKU = (WCHAR **)LocalAlloc(LMEM_FIXED, cbEKU);
        if(awszEKU == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        wszData = (WCHAR *)(awszEKU + (pEnhKeyUsage->cUsageIdentifier+1));
        cbEKU -= sizeof(WCHAR *)*(pEnhKeyUsage->cUsageIdentifier+1);
        for(i=0; i < pEnhKeyUsage->cUsageIdentifier; i++)
        {
            awszEKU[i] = wszData;
            cStr = MultiByteToWideChar(CP_ACP,
                                  0,
                                  pEnhKeyUsage->rgpszUsageIdentifier[i],
                                  strlen(pEnhKeyUsage->rgpszUsageIdentifier[i])+1,
                                  awszEKU[i],
                                  cbEKU);
            if(cStr <= 0)
            {
                hr = myHLastError();
                LocalFree(awszEKU);
                goto error;
            }
            cbEKU -= cStr*sizeof(WCHAR);
            wszData += cStr;

        }

        awszEKU[i] = NULL;
        hr = SetProperty(CERTTYPE_PROP_EXTENDED_KEY_USAGE, awszEKU);
        LocalFree(awszEKU);

    }
    else if (wcscmp(wszExtensionName, TEXT(szOID_KEY_USAGE)) == 0)
    {
        PCRYPT_BIT_BLOB pKeyUsage = (PCRYPT_BIT_BLOB)pExtension;

        if(m_KeyUsage.pbData)
        {
            LocalFree(m_KeyUsage.pbData);
            m_KeyUsage.pbData = NULL;
            m_KeyUsage.cbData = 0;
            m_KeyUsage.cUnusedBits = 0;
        }
        if(pExtension == NULL)
        {
            return S_OK;
        }

        m_KeyUsage.cbData = pKeyUsage->cbData;
        m_KeyUsage.cUnusedBits = pKeyUsage->cUnusedBits;
        if(pKeyUsage->pbData == NULL)
        {
            hr = S_OK;
            goto error;
        }

        m_KeyUsage.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, pKeyUsage->cbData);
        if(m_KeyUsage.pbData == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        CopyMemory(m_KeyUsage.pbData, pKeyUsage->pbData, pKeyUsage->cbData);
    }
    else if (wcscmp(wszExtensionName, TEXT(szOID_BASIC_CONSTRAINTS2)) == 0)
    {
        PCERT_BASIC_CONSTRAINTS2_INFO pInfo = (PCERT_BASIC_CONSTRAINTS2_INFO)pExtension;
        if(pExtension == NULL)
        {
            m_BasicConstraints.fCA = FALSE;
            m_BasicConstraints.fPathLenConstraint = FALSE;
            m_BasicConstraints.fPathLenConstraint = 0;
            return E_POINTER;
        }
        CopyMemory(&m_BasicConstraints, pInfo, sizeof(CERT_BASIC_CONSTRAINTS2_INFO));
    }
    else
    {
        hr = E_NOTIMPL;
        goto error;
    }

    //mark the critical for the extension
    hr = GetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR **>(&awszCritical));
    _JumpIfError(hr, error, "GetProperty");

    if(((dwFlags & CA_EXT_FLAG_CRITICAL) != 0) == _IsCritical(wszExtensionName, awszCritical))
    {
        // already in the right state, do nothing
        hr = S_OK;
        goto error;
    }

    // Count the critical extensions
    if(awszCritical)
    {
        for(pwszCurCritical = awszCritical; *pwszCurCritical != NULL; pwszCurCritical++)
            cCritical++;
    }
    else
    {
        cCritical=0;
    }

    if(dwFlags & CA_EXT_FLAG_CRITICAL)
    {
        LPCWSTR *awszNewCritical = (LPCWSTR *)LocalAlloc(LMEM_ZEROINIT, (cCritical + 2)*sizeof(LPWSTR));
        // We need to add a critical extension

        if(awszNewCritical == NULL)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr , error, "LocalAlloc");
        }

        if(awszCritical)
        {
            CopyMemory(awszNewCritical, awszCritical, cCritical*sizeof(LPWSTR));
        }

        awszNewCritical[cCritical] = wszExtensionName;
        hr = SetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR *>(awszNewCritical));

        LocalFree(awszNewCritical);
    }
    else
    {
        //only need to reset the critical extension if there were existing ones
        if(awszCritical)
        {

            LPCWSTR *awszNewCritical = (LPCWSTR *)LocalAlloc(LMEM_ZEROINIT, (cCritical)*sizeof(LPWSTR));
            DWORD i=0;
            if(awszNewCritical == NULL)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr , error, "LocalAlloc");
            }

            for(pwszCurCritical = awszCritical; *pwszCurCritical != NULL; pwszCurCritical++)
            {
                if(wcscmp(*pwszCurCritical, wszExtensionName) != 0)
                {
                    awszNewCritical[i++] = *pwszCurCritical;
                }
            }
            hr = SetProperty(CERTTYPE_PROP_CRITICAL_EXTENSIONS, const_cast<LPWSTR *>(awszNewCritical));

            LocalFree(awszNewCritical);
        }
    }

error:

    if(awszCritical)
    {
        FreeProperty(const_cast<LPWSTR *>(awszCritical));
    }
    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetExpiration --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::GetExpiration(
                          OUT OPTIONAL FILETIME  * pftExpiration,
                          OUT OPTIONAL FILETIME  * pftOverlap)
{
    HRESULT hr = S_OK;

    if(pftExpiration)
    {
        *pftExpiration = m_ftExpiration;
    }

    if(pftOverlap)
    {
        *pftOverlap = m_ftOverlap;
    }

    return hr;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::GetExpiration --
//
//
//+--------------------------------------------------------------------------


HRESULT CCertTypeInfo::SetExpiration(
                          IN OPTIONAL FILETIME  * pftExpiration,
                          IN OPTIONAL FILETIME  * pftOverlap)
{
    HRESULT hr = S_OK;

    if(pftExpiration)
    {
        m_ftExpiration = *pftExpiration;
    }

    if(pftOverlap)
    {
        m_ftOverlap = *pftOverlap;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//	IsDSInfoNewer
//
//+--------------------------------------------------------------------------
BOOL	IsDSInfoNewer(CCertTypeInfo         *pDSCertType,
				      CERT_TYPE_DEFAULT	    *pDefault)
{
    DWORD   dwSchemaVersion=0;
    DWORD   dwRevision=0;
    DWORD   dwMinorRevision=0;

    //no need to update the DS if something is wrong
    if((!pDSCertType) || (!pDefault))
        return TRUE;

    if((S_OK != pDSCertType->GetPropertyEx(CERTTYPE_PROP_SCHEMA_VERSION, &dwSchemaVersion))||
       (S_OK != pDSCertType->GetPropertyEx(CERTTYPE_PROP_REVISION, &dwRevision))||
       (S_OK != pDSCertType->GetPropertyEx(CERTTYPE_PROP_MINOR_REVISION, &dwMinorRevision))
      )
        return FALSE;

    //we consider in the order of schema version, major version (m_revision),
    //and minor revision
    if(dwSchemaVersion == pDefault->dwSchemaVersion)
    {
        if(dwRevision == pDefault->dwRevision)
        {
            return (dwMinorRevision >= pDefault->dwMinorRevision);
        }
        else
        {
            return (dwRevision >= pDefault->dwRevision);
        }
    }

    return (dwSchemaVersion >= pDefault->dwSchemaVersion);
}

//+--------------------------------------------------------------------------
// InstallDefaultOID()
//
//
//      Install default OIDs
//+--------------------------------------------------------------------------

HRESULT
InstallDefaultOID()
{
    HRESULT hr = E_FAIL;
    DWORD dwIndex = 0;
    LPWSTR pwszDefaultOID = NULL;
    WCHAR *pwszDisplayName = NULL;

    for (dwIndex = 0; dwIndex < g_cDefaultOIDInfo; dwIndex++)
    {
        hr = CAOIDBuildOID(
			0,
			g_rgDefaultOIDInfo[dwIndex].pwszOID,
			&pwszDefaultOID);
        _JumpIfError(hr, error, "CAOIDBuildOID");

        hr = I_CAOIDAdd(
		    g_rgDefaultOIDInfo[dwIndex].dwType,
		    0,
		    pwszDefaultOID);

        // CRYPT_E_EXISTS will be returned if the OID already exist
        if (CRYPT_E_EXISTS == hr)
	{
            hr = S_OK;
	}
        _JumpIfError(hr, error, "I_CAOIDADD");

	pwszDisplayName = myLoadResourceStringNoCache(
				g_hInstance,
				g_rgDefaultOIDInfo[dwIndex].idsDisplayName);
	if (NULL == pwszDisplayName)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myLoadResourceStringNoCache");
	}

        hr = I_CAOIDSetProperty(
                        pwszDefaultOID,
                        CERT_OID_PROPERTY_DISPLAY_NAME,
			pwszDisplayName);

        _JumpIfError(hr, error, "I_CAOIDSetProperty");

        if (NULL != pwszDefaultOID)
        {
            LocalFree(pwszDefaultOID);
            pwszDefaultOID = NULL;
        }
	if (NULL != pwszDisplayName)
	{
	    LocalFree(pwszDisplayName);
	    pwszDisplayName = NULL;
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszDefaultOID)
    {
        LocalFree(pwszDefaultOID);
    }
    if (NULL != pwszDisplayName)
    {
	LocalFree(pwszDisplayName);
    }
    return hr;
}


//+--------------------------------------------------------------------------
// GetRootDomEntitySid
//
//   Utility function to retrieve root domain SID based on end entity rid
//+--------------------------------------------------------------------------
static HRESULT GetRootDomEntitySid(SID ** ppSid, DWORD dwEntityRid)
{
    HRESULT			hr=E_FAIL;
    unsigned int	nSubAuthorities;
    unsigned int	nSubAuthIndex;

    SID				* psidRootDomEntity=NULL;
	PSID			pDomainSid=NULL;

    // initialize out params
    *ppSid=NULL;

    hr = myGetSidFromDomain(NULL, &pDomainSid);
    if (S_OK != hr)
    {
        hr = HRESULT_FROM_WIN32(hr);
		_JumpError(hr, error, "myGetSidFromDomain");
    }

    nSubAuthorities=*GetSidSubAuthorityCount(pDomainSid);

    // allocate storage for new Sid. account domain Sid + account Rid
    psidRootDomEntity=(SID *)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(nSubAuthorities+1)));

	if(NULL==psidRootDomEntity)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    // copy the first few peices into the SID
    if (!InitializeSid(psidRootDomEntity, 
            GetSidIdentifierAuthority(pDomainSid), 
            (BYTE)(nSubAuthorities+1)))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSid");
    }

    // copy existing subauthorities from account domain Sid into new Sid
    for (nSubAuthIndex=0; nSubAuthIndex < nSubAuthorities ; nSubAuthIndex++) {
        *GetSidSubAuthority(psidRootDomEntity, nSubAuthIndex)=
            *GetSidSubAuthority(pDomainSid, nSubAuthIndex);
    }

    // append Rid to new Sid
    *GetSidSubAuthority(psidRootDomEntity, nSubAuthorities)=dwEntityRid;

    *ppSid=psidRootDomEntity;
    psidRootDomEntity=NULL;
    hr=S_OK;

error:

	if (NULL != pDomainSid)
    {
        LocalFree(pDomainSid);
    }

    if (NULL!=psidRootDomEntity) 
	{
        LocalFree(psidRootDomEntity);
    }

    return hr;
}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_UpdateSecurity --
//
//		We need to add enterprise administrator full control and enroll access
//	to V1 template during template installation; we also need to move the 
//	ACTRL_DS_CONTROL_ACCESS from any accessed allowed ACEs, most likely for 
//	domain administrators as W2K installs them and add explict enroll allowed
//	to domain administrators; in addition, we need to remove domain user enroll
//	allowed from domain users from offline exchange user and exchange user 
//	signature templates.
//
//+--------------------------------------------------------------------------
HRESULT 
CCertTypeInfo::_UpdateSecurity()
{
	HRESULT							hr=E_FAIL;
    SECURITY_DESCRIPTOR_CONTROL		sdcon;
    DWORD							dwRevision;
    DWORD							dwNewAclSize;
    DWORD							dwAbsSDSize=0;
    DWORD							dwDaclSize=0;
    DWORD							dwSaclSize=0;
    DWORD							dwOwnerSize=0;
    DWORD							dwPriGrpSize=0;
    ACE_HEADER						*pFirstAce=NULL;
    DWORD							dwRelSDSize=0;
    ACL_SIZE_INFORMATION			aclsizeinfo;
    PACL							pAcl=NULL;
    BOOL							bAclPresent;
    BOOL							bDefaultAcl;
    unsigned int					nIndex;
	BOOL							fExchangeTemplate=FALSE;
	BOOL							fDSControlRemoved=FALSE;
	BOOL							fRemoveUserACE=FALSE;
	unsigned int					iRemove=0;

    PSECURITY_DESCRIPTOR			pAbsSD=NULL;
    ACL								*pAbsDacl=NULL;
    ACL								*pAbsSacl=NULL;
    SID								*pAbsOwner=NULL;
    SID								*pAbsPriGrp=NULL;
    ACL								*pNewDacl=NULL;
    PSECURITY_DESCRIPTOR			pNewSD=NULL;
	SID								*pTrustworthySid=NULL;
	SID								*pDomainAdminSid=NULL;
	SID								*pDomainUserSid=NULL;


	//make sure that we start with a valid security descriptor
    if(!IsValidSecurityDescriptor(m_pSD))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
    }

	//check if we are dealing with exchange template
	if(NULL == m_bstrType)
	{
		hr=E_INVALIDARG;
		_JumpError(hr, error, "InvalidBstrType");
	}

	if((0 == LSTRCMPIS(m_bstrType, wszCERTTYPE_EXCHANGE_USER)) ||
	   (0 == LSTRCMPIS(m_bstrType, wszCERTTYPE_EXCHANGE_USER_SIGNATURE))
	  )
	{
		fExchangeTemplate=TRUE;
	}

	//get the enterprise admin SID
    hr=GetRootDomEntitySid(&pTrustworthySid, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS);
    _JumpIfError(hr, error, "GetEntAdminSid");

	//get the root domain admin SID
    hr=GetRootDomEntitySid(&pDomainAdminSid, DOMAIN_GROUP_RID_ADMINS);
    _JumpIfError(hr, error, "GetDomainAdminSid");

	//get the root domain user SID
    hr=GetRootDomEntitySid(&pDomainUserSid, DOMAIN_GROUP_RID_USERS);
    _JumpIfError(hr, error, "GetDomainUserSid");

	// get the (D)ACL from the security descriptor
    if(!GetSecurityDescriptorDacl(m_pSD, &bAclPresent, &pAcl, &bDefaultAcl)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    if(FALSE == bAclPresent)
	{
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
	}

    if (NULL==pAcl)
	{
		// NULL acl -> allow all access, which should not happen
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    // find out how many ACEs
	memset(&aclsizeinfo, 0, sizeof(aclsizeinfo));
    if (!GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    // find domain admin sid in the acl
    for (nIndex=0; nIndex < aclsizeinfo.AceCount; nIndex++) 
	{
        ACE_HEADER					* pAceHeader=NULL;
        ACCESS_ALLOWED_ACE			* pAccessAce=NULL;
        ACCESS_ALLOWED_OBJECT_ACE	* pObjectAce=NULL;
        PSID						pSid=NULL;

        if (!GetAce(pAcl, nIndex, (void**)&pAceHeader)) 
		{
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

		// we are only interested in access allowed ace types
        if (ACCESS_ALLOWED_ACE_TYPE == pAceHeader->AceType) 
		{
			//get the pointer to the whole ACE
			pAccessAce=(ACCESS_ALLOWED_ACE *)pAceHeader;

			pSid=((BYTE *)&pAccessAce->SidStart);

			// make sure this is the sid we are looking for
			if (!EqualSid(pSid, pDomainAdminSid)) 
			{
				continue;
			}

			// remove ACTRL_DS_CONTROL_ACCESS
			if (pAccessAce->Mask & ACTRL_DS_CONTROL_ACCESS)
			{
				pAccessAce->Mask &= ~ACTRL_DS_CONTROL_ACCESS;
				fDSControlRemoved=TRUE;
			}
		}
		else
		{
			if ((TRUE == fExchangeTemplate) && (ACCESS_ALLOWED_OBJECT_ACE_TYPE == pAceHeader->AceType)) 
			{
				pObjectAce=(ACCESS_ALLOWED_OBJECT_ACE *)pAceHeader;

				if(ACE_OBJECT_TYPE_PRESENT == pObjectAce->Flags)
				{
					pSid=((BYTE *)&pObjectAce->SidStart)-sizeof(GUID);

					// confirm the GUID
					if (IsEqualGUID(pObjectAce->ObjectType, GUID_ENROLL)) 
					{
						// make sure this is the sid we are looking for
						if (EqualSid(pSid, pDomainUserSid)) 
						{
							if (pObjectAce->Mask & ACTRL_DS_CONTROL_ACCESS) 
							{
								pObjectAce->Mask &= ~ACTRL_DS_CONTROL_ACCESS;
							}

							//remember to remove this ACE
							fRemoveUserACE=TRUE;
							iRemove=nIndex;
						}
					}
				}
			}
		}
    }

	//make sure that we start with a valid security descriptor
    if(!IsValidSecurityDescriptor(m_pSD))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    // we have to be self-relative
    if(!GetSecurityDescriptorControl(m_pSD, &sdcon, &dwRevision)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorControl");
    }
        
	if(0 == (sdcon & SE_SELF_RELATIVE))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptorSelfRelative");
    }

	// get the sizes
    if(!MakeAbsoluteSD(m_pSD, NULL, &dwAbsSDSize, NULL, &dwDaclSize, NULL, &dwSaclSize, NULL,  &dwOwnerSize, NULL, &dwPriGrpSize))
	{
        if(ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
		{
            hr = myHLastError();
            _JumpError(hr, error, "MakeAbsoluteSD");
		}
	}

    // allocate memory
    pAbsSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwAbsSDSize);
	if(NULL == pAbsSD)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsDacl=(ACL * )LocalAlloc(LPTR, dwDaclSize);
	if(NULL == pAbsDacl)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsSacl=(ACL * )LocalAlloc(LPTR, dwSaclSize);
	if(NULL == pAbsSacl)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsOwner=(SID *)LocalAlloc(LPTR, dwOwnerSize);
	if(NULL == pAbsOwner)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsPriGrp=(SID *)LocalAlloc(LPTR, dwPriGrpSize);
	if(NULL == pAbsPriGrp)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}


    // copy the SD to the memory buffers
    if(!MakeAbsoluteSD(m_pSD, pAbsSD, &dwAbsSDSize, pAbsDacl, &dwDaclSize, pAbsSacl, &dwSaclSize, pAbsOwner,  &dwOwnerSize, pAbsPriGrp, &dwPriGrpSize)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "MakeAbsoluteSD");
    }
        
    // get the current size info for the dacl
	memset(&aclsizeinfo, 0, sizeof(aclsizeinfo));
    if(!GetAclInformation(pAbsDacl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    // figure out the new size
    dwNewAclSize=aclsizeinfo.AclBytesInUse
		+sizeof(_ACCESS_ALLOWED_OBJECT_ACE)
        -sizeof(GUID) //ACCESS_ALLOWED_OBJECT_ACE::InheritedObjectType
        -sizeof(DWORD) //ACCESS_ALLOWED_OBJECT_ACE::SidStart
        +GetLengthSid(pTrustworthySid)
		+sizeof(ACCESS_ALLOWED_ACE) 
		-sizeof(DWORD) //ACCESS_ALLOWED_ACE::SidStart
		+GetLengthSid(pTrustworthySid);

	if(fDSControlRemoved)
	{
		dwNewAclSize=dwNewAclSize
				+sizeof(_ACCESS_ALLOWED_OBJECT_ACE)
				-sizeof(GUID) //ACCESS_ALLOWED_OBJECT_ACE::InheritedObjectType
				-sizeof(DWORD) //ACCESS_ALLOWED_OBJECT_ACE::SidStart
				+GetLengthSid(pDomainAdminSid);
	}
    
    // allocate memory
    pNewDacl=(ACL *)LocalAlloc(LPTR, dwNewAclSize);

	if(NULL == pNewDacl)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    // init the header
    if(!InitializeAcl(pNewDacl, dwNewAclSize, ACL_REVISION_DS)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // find the first ace in the dacl
    if(!GetAce(pAbsDacl, 0, (void **)&pFirstAce)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetAce");
    }

    // add all the old aces
    if(!AddAce(pNewDacl, ACL_REVISION_DS, 0, pFirstAce, aclsizeinfo.AclBytesInUse-sizeof(ACL))) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "AddAce");
    }

	//remove the empty domain user ACE
	if(TRUE == fRemoveUserACE)
	{
		if(!DeleteAce(pNewDacl, iRemove))
		{
			hr = myHLastError();
			_JumpError(hr, error, "DeleteAce");
		}
	}

    // add the new ace for enterprise admin enrollment
    if(!AddAccessAllowedObjectAce(pNewDacl, ACL_REVISION_DS, 0, ACTRL_DS_CONTROL_ACCESS, (GUID *)&GUID_ENROLL, NULL, pTrustworthySid)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "AddAccessAllowedObjectAce");
    }

    // add the new ace for domain admin enrollment
	if(fDSControlRemoved)
	{
		if(!AddAccessAllowedObjectAce(pNewDacl, ACL_REVISION_DS, 0, ACTRL_DS_CONTROL_ACCESS, (GUID *)&GUID_ENROLL, NULL, pDomainAdminSid)) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "AddAccessAllowedObjectAce");
		}
	}

	// add the new ace for enterprise admin enrollment
	if(!AddAccessAllowedAce(pNewDacl, ACL_REVISION_DS, ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS,  pTrustworthySid))
	{
        hr = myHLastError();
        _JumpError(hr, error, "AddAccessDeniedAce");
    }

    // stick the new dacl in the sd
    if(!SetSecurityDescriptorDacl(pAbsSD, TRUE, pNewDacl, FALSE)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    // compact everything back together
    // get the size
    if(!MakeSelfRelativeSD(pAbsSD, NULL, &dwRelSDSize))
	{
        if(ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
		{
            hr = myHLastError();
            _JumpError(hr, error, "MakeSelfRelativeSD");
        }
	}

    // allocate memory
    pNewSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwRelSDSize);
	if(NULL == pNewSD)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    // copy the SD to the new memory buffer
    if(!MakeSelfRelativeSD(pAbsSD, pNewSD, &dwRelSDSize)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

    if(!IsValidSecurityDescriptor(pNewSD))
	{
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
	}

	// Whew! We made it!
	if(S_OK != (hr=SetSecurity(pNewSD)))
	{
		_JumpError(hr, error, "SetSecurity");
	}

	hr=S_OK;

error:

    if (NULL!=pDomainAdminSid) 
	{
        LocalFree(pDomainAdminSid);
    }

    if (NULL!=pDomainUserSid) 
	{
        LocalFree(pDomainUserSid);
    }

    if (NULL!=pTrustworthySid) 
	{
        LocalFree(pTrustworthySid);
    }

    if (NULL!=pNewSD) 
	{
        LocalFree(pNewSD);
    }

    if (NULL!=pNewDacl) 
	{
        LocalFree(pNewDacl);
    }

    if (NULL!=pAbsSD) 
	{
        LocalFree(pAbsSD);
    }

    if (NULL!=pAbsDacl) 
	{
        LocalFree(pAbsDacl);
    }

    if (NULL!=pAbsSacl) 
	{
        LocalFree(pAbsSacl);
    }

    if (NULL!=pAbsOwner) 
	{
        LocalFree(pAbsOwner);
    }

    if (NULL!=pAbsPriGrp) 
	{
        LocalFree(pAbsPriGrp);
    }
	return hr;

}


//+--------------------------------------------------------------------------
// CCertTypeInfo::_UpdateSecurityOwner --
//
//		We need to change the certificate templates ACL so that the owner and 
//	the group are enterprise domain admins
//
//+--------------------------------------------------------------------------
HRESULT 
CCertTypeInfo::_UpdateSecurityOwner()
{
	HRESULT							hr=E_FAIL;
    SECURITY_DESCRIPTOR_CONTROL		sdcon;
    DWORD							dwRevision=0;
    DWORD							dwAbsSDSize=0;
    DWORD							dwDaclSize=0;
    DWORD							dwSaclSize=0;
    DWORD							dwOwnerSize=0;
    DWORD							dwPriGrpSize=0;
    DWORD							dwRelSDSize=0;

    PSECURITY_DESCRIPTOR			pAbsSD=NULL;
    ACL								*pAbsDacl=NULL;
    ACL								*pAbsSacl=NULL;
    SID								*pAbsOwner=NULL;
    SID								*pAbsPriGrp=NULL;
	SID								*pTrustworthySid=NULL;
    PSECURITY_DESCRIPTOR			pNewSD=NULL;

	//make sure that we start with a valid security descriptor
    if(!IsValidSecurityDescriptor(m_pSD))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
    }

	//get the enterprise admin SID
    hr=GetRootDomEntitySid(&pTrustworthySid, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS);
    _JumpIfError(hr, error, "GetEntAdminSid");

	// we have to be self-relative
    if(!GetSecurityDescriptorControl(m_pSD, &sdcon, &dwRevision)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorControl");
    }
        
	if(0 == (sdcon & SE_SELF_RELATIVE))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptorSelfRelative");
    }

	// get the sizes
    if(!MakeAbsoluteSD(m_pSD, NULL, &dwAbsSDSize, NULL, &dwDaclSize, NULL, &dwSaclSize, NULL,  &dwOwnerSize, NULL, &dwPriGrpSize))
	{
        if(ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
		{
            hr = myHLastError();
            _JumpError(hr, error, "MakeAbsoluteSD");
		}
	}

    // allocate memory
    pAbsSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwAbsSDSize);
	if(NULL == pAbsSD)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsDacl=(ACL * )LocalAlloc(LPTR, dwDaclSize);
	if(NULL == pAbsDacl)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsSacl=(ACL * )LocalAlloc(LPTR, dwSaclSize);
	if(NULL == pAbsSacl)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsOwner=(SID *)LocalAlloc(LPTR, dwOwnerSize);
	if(NULL == pAbsOwner)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    pAbsPriGrp=(SID *)LocalAlloc(LPTR, dwPriGrpSize);
	if(NULL == pAbsPriGrp)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    // copy the SD to the memory buffers
    if(!MakeAbsoluteSD(m_pSD, pAbsSD, &dwAbsSDSize, pAbsDacl, &dwDaclSize, pAbsSacl, &dwSaclSize, pAbsOwner,  &dwOwnerSize, pAbsPriGrp, &dwPriGrpSize)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "MakeAbsoluteSD");
    }
        
    // stick the owner and group to the security descriptor
	if(!SetSecurityDescriptorOwner(pAbsSD, pTrustworthySid, FALSE))
	{
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

	if(!SetSecurityDescriptorGroup(pAbsSD, pTrustworthySid, FALSE))
	{
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    // compact everything back together
    // get the size
    if(!MakeSelfRelativeSD(pAbsSD, NULL, &dwRelSDSize))
	{
        if(ERROR_INSUFFICIENT_BUFFER != GetLastError()) 
		{
            hr = myHLastError();
            _JumpError(hr, error, "MakeSelfRelativeSD");
        }
	}

    // allocate memory
    pNewSD=(PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwRelSDSize);
	if(NULL == pNewSD)
	{
		hr=E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	}

    // copy the SD to the new memory buffer
    if(!MakeSelfRelativeSD(pAbsSD, pNewSD, &dwRelSDSize)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "MakeSelfRelativeSD");
    }

    if(!IsValidSecurityDescriptor(pNewSD))
	{
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
	}

	// Whew! We made it!
	if(S_OK != (hr=SetSecurity(pNewSD)))
	{
		_JumpError(hr, error, "SetSecurity");
	}

	hr=S_OK;

error:

    if (NULL!=pTrustworthySid) 
	{
        LocalFree(pTrustworthySid);
    }

    if (NULL!=pNewSD) 
	{
        LocalFree(pNewSD);
    }

    if (NULL!=pAbsSD) 
	{
        LocalFree(pAbsSD);
    }

    if (NULL!=pAbsDacl) 
	{
        LocalFree(pAbsDacl);
    }

    if (NULL!=pAbsSacl) 
	{
        LocalFree(pAbsSacl);
    }

    if (NULL!=pAbsOwner) 
	{
        LocalFree(pAbsOwner);
    }

    if (NULL!=pAbsPriGrp) 
	{
        LocalFree(pAbsPriGrp);
    }

	return hr;

}


//+--------------------------------------------------------------------------
// CCertTypeInfo::IsValidSecurityOwner --
//
//		Verify that enterprise admin should be the owner and group of the 
//	security descriptor of the templates
//
//+--------------------------------------------------------------------------
BOOL	CCertTypeInfo::IsValidSecurityOwner()
{
	BOOL							fValid=FALSE;
	HRESULT							hr=S_OK;
    SECURITY_DESCRIPTOR_CONTROL		sdcon;
    DWORD							dwRevision=0;
	PSID							pSidOwner=NULL;
	PSID							pSidGroup=NULL;
	BOOL							fOwnerDefault=FALSE;
	BOOL							fGroupDefault=FALSE;
	
	SID								*pTrustworthySid=NULL;

	//make sure that we start with a valid security descriptor
    if(!IsValidSecurityDescriptor(m_pSD))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
    }

	//get the enterprise admin SID
    hr=GetRootDomEntitySid(&pTrustworthySid, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS);
    _JumpIfError(hr, error, "GetEntAdminSid");

	// we have to be self-relative
    if(!GetSecurityDescriptorControl(m_pSD, &sdcon, &dwRevision)) 
	{
        hr=myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorControl");
    }
        
	if(0 == (sdcon & SE_SELF_RELATIVE))
    {
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptorSelfRelative");
    }

	// get the owner and group of the security desciptor
	if(!GetSecurityDescriptorOwner(m_pSD, &pSidOwner, &fOwnerDefault))
	{
        hr=myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorOwner");
    }

	if(NULL == pSidOwner)
	{
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
        _JumpError(hr, error, "GetSecurityDescriptorOwner");
	}

	if(!GetSecurityDescriptorGroup(m_pSD, &pSidGroup, &fGroupDefault))
	{
        hr=myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
	}

	if(NULL == pSidGroup)
	{
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
	}

	//compare the owner and group
	if(!EqualSid(pSidOwner, pTrustworthySid))
		goto error;

	if(!EqualSid(pSidGroup, pTrustworthySid))
		goto error;

	fValid=TRUE;

error:

    if (NULL!=pTrustworthySid) 
	{
        LocalFree(pTrustworthySid);
    }

	return fValid;
}

//+--------------------------------------------------------------------------
// CCertTypeInfo::InstallDefaultTypes --
//
//
//+--------------------------------------------------------------------------

HRESULT
CCertTypeInfo::InstallDefaultTypes(VOID)
{
    HRESULT hr = S_OK;
    DWORD i;
    LPWSTR wszContainer = NULL;
    LPWSTR wszDNRoot = NULL;
    HRESULT hrLastError = S_OK;
    BOOL fSecurityOwnerUpdateOnly = FALSE;

    ULONG ldaperr;
    LDAP *pld = NULL;
    LDAPMod objectClass;

    CCertTypeInfo *pDSTypes = NULL;
    CCertTypeInfo *pFindDSType = NULL;

    WCHAR *objectClassVals[3];
    LDAPMod *mods[2];
    CERTSTR bstrConfig = NULL;

    // bind to ds
    hr = myRobustLdapBindEx(
			0,			  // dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,		  // uVersion
			NULL,			  // pwszDomainName
			&pld,
			NULL);			  // ppwszForestDNSName
    _JumpIfError(hr, error, "myRobustLdapBindEx");

    hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
    _JumpIfError(hr, error, "CAGetAuthoritativeDomainDn");

    wszDNRoot = (LPWSTR)LocalAlloc(LMEM_FIXED, (wcslen(s_wszLocation) + wcslen(bstrConfig) +1)*sizeof(WCHAR));
    if(wszDNRoot == NULL)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(wszDNRoot, s_wszLocation);
    wcscat(wszDNRoot, bstrConfig);


    // Build the Public Key Services container
    mods[0] = &objectClass;
    mods[1] = NULL;

    objectClass.mod_op = 0;
    objectClass.mod_type = TEXT("objectclass");
    objectClass.mod_values = objectClassVals;

    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSCONTAINERCLASSNAME;
    objectClassVals[2] = NULL;

    wszContainer = wcsstr(wszDNRoot, L"CN=Public Key Services");
    if (NULL != wszContainer)
    {
        ldaperr = ldap_add_s(pld, wszContainer, mods);
        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
	    _JumpError(hr, error, "ldap_add_s");
        }
    }

    wszContainer = wcsstr(wszDNRoot, L"CN=Certificate Templates");
    if (NULL != wszContainer)
    {
        ldaperr = ldap_add_s(pld, wszContainer, mods);
        if (LDAP_SUCCESS != ldaperr && LDAP_ALREADY_EXISTS != ldaperr)
        {
	    _JumpError(hr, error, "ldap_add_s");
        }
    }

    // Grab the types currently in the DS (do not use local cache)
    hr = _EnumFromDS(
		pld,
		CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES |
		    CT_FLAG_NO_CACHE_LOOKUP,
		&pDSTypes);
    _JumpIfError(hr, error, "_EnumFromDS");

    for (i = 0; i < g_cDefaultCertTypes; i++)
    {
        CCertTypeInfo *pCTCurrent = NULL;
		fSecurityOwnerUpdateOnly=FALSE;

        // Find the current default type in our enumeration from the DS
        pFindDSType = pDSTypes;
        while (NULL != pFindDSType)
        {
            if (0 == mylstrcmpiL(
			g_aDefaultCertTypes[i].wszName,
			pFindDSType->m_bstrType))
            {
                break;
            }
            pFindDSType = pFindDSType->m_pNext;
        }

        // Don't bother to update cert types of our own or grater revision
        if (NULL != pFindDSType &&
	    IsDSInfoNewer(pFindDSType, &g_aDefaultCertTypes[i]))
        {
			//make sure the security descriptor is valid.  
			if(pFindDSType->IsValidSecurityOwner())
			{
				continue;
			}
			else
			{
				fSecurityOwnerUpdateOnly=TRUE;
			}
        }

		if(fSecurityOwnerUpdateOnly)
		{
			hr=pFindDSType->_UpdateSecurityOwner();

			if(S_OK != hr)
			{
				_PrintIfError(hr, "_UpdateSecurityOwner");
				goto NextTemplate;
			}

			hr=pFindDSType->_UpdateToDS();
			_PrintIfError(hr, "_UpdateToDS");
		}
		else
		{
			pCTCurrent = new CCertTypeInfo;
			if (NULL == pCTCurrent)
			{
				hr = E_OUTOFMEMORY;
				_JumpError(hr, error, "new");
			}

			// we need to build the key into the registry.
			hr = pCTCurrent->_LoadFromDefaults(&g_aDefaultCertTypes[i], NULL);

			//remember the error, but continue to update as many templates as possible
			if(S_OK != hr)
			{
				_PrintIfError(hr, "_LoadFromDefaults");
				goto NextTemplate;
			}

			//if there exists certificate templates
			if (NULL != pFindDSType) 
			{
				hr=pCTCurrent->SetSecurity(pFindDSType->m_pSD);

				if(S_OK != hr)
				{
					_PrintIfError(hr, "SetSecurity");
					goto NextTemplate;
				}

				if(0 == pFindDSType->m_dwSchemaVersion)
				{
					// We're updating a W2K cert type.  Since W2K only allows
					// modification of security descriptors for this and previous
					// builds, copy over the security descriptor.

					//we need to add full control ACE for enterprise admin
					hr=pCTCurrent->_UpdateSecurity();

					if(S_OK != hr)
					{
						_PrintIfError(hr, "_UpdateSecurity");
						goto NextTemplate;
					}
				}

				//we need to change the owner and security 
				hr=pCTCurrent->_UpdateSecurityOwner();

				if(S_OK != hr)
				{
					_PrintIfError(hr, "_UpdateSecurityOwner");
					goto NextTemplate;
				}

				pCTCurrent->m_fNew = FALSE;
				pCTCurrent->m_fUpdateDisplayName = TRUE;
			}

			hr=pCTCurrent->_UpdateToDS();
			_PrintIfError(hr, "_UpdateToDS");
		}

NextTemplate:

		if(pCTCurrent)
		{
			delete pCTCurrent;
			pCTCurrent=NULL;
		}

		if(S_OK != hr)
			hrLastError=hr;
    }


    // Flush the cache
    if (NULL != pDSTypes)
    {
        pDSTypes->Release();
        pDSTypes = NULL;
    }

    hr = _EnumFromDS(
		pld,
		CT_ENUM_MACHINE_TYPES |
		    CT_ENUM_USER_TYPES |
		    CT_FLAG_NO_CACHE_LOOKUP,
		&pDSTypes);
    _JumpIfError(hr, error, "_EnumFromDS");

    //install default issurance policy OIDs
    hr = InstallDefaultOID();
    _JumpIfError(hr, error, "InstallDefaultOID");

    hr=hrLastError;

error:
    if (NULL != pDSTypes)
    {
        pDSTypes->Release();
    }
    if (NULL != bstrConfig)
    {
        CertFreeString(bstrConfig);
    }
    if (NULL != wszDNRoot)
    {
        LocalFree(wszDNRoot);
    }
    if (NULL != pld)
    {
        ldap_unbind(pld);
        pld = NULL;
    }
    _PrintIfError(hr, "InstallDefaultTypes");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\logon.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       logon.cpp
//
//--------------------------------------------------------------------------

/*++

Copyright (c) 1995, 1996  Scott A. Field

Module Name:

    logon.c

Abstract:

    This module implements the network logon type by interfacing
    with the NT Lan Man Security Support Provider (NTLMSSP).

    If the logon succeds via the provided credentials, we duplicate
    the resultant Impersonation token to a Primary level token.
    This allows the result to be used in a call to CreateProcessAsUser

Author:

    Scott Field (sfield)    09-Jun-96

Revision History:

--*/
#include "pch.cpp"

#pragma hdrstop
#define SECURITY_WIN32



#include <windows.h>

#include <rpc.h>
#include <security.h>


BOOL
myNetLogonUser(
    LPTSTR UserName,
    LPTSTR DomainName,
    LPTSTR Password,
    PHANDLE phToken
    )
{
    SECURITY_STATUS SecStatus;
    CredHandle CredentialHandle1;
    CredHandle CredentialHandle2;

    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    SecPkgCredentials_Names sNames;

    ULONG ContextAttributes;

    ULONG PackageCount;
    ULONG PackageIndex;
    PSecPkgInfo PackageInfo;
    DWORD cbMaxToken;

    TimeStamp Lifetime;
    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    BOOL bSuccess = FALSE ; // assume this function will fail

    NegotiateBuffer.pvBuffer = NULL;
    NegotiateBuffer.cbBuffer = 0;
    ChallengeBuffer.pvBuffer = NULL;
    ChallengeBuffer.cbBuffer = 0;
    sNames.sUserName = NULL;
    ClientContextHandle.dwUpper = MAXDWORD;
    ClientContextHandle.dwLower = MAXDWORD;
    ServerContextHandle.dwUpper = MAXDWORD;
    ServerContextHandle.dwLower = MAXDWORD;
    CredentialHandle1.dwUpper = MAXDWORD;
    CredentialHandle1.dwLower = MAXDWORD;
    CredentialHandle2.dwUpper = MAXDWORD;
    CredentialHandle2.dwLower = MAXDWORD;


//
// << this section could be cached in a repeat caller scenario >>
//

    //
    // Get info about the security packages.
    //

    if(EnumerateSecurityPackages(
        &PackageCount,
        &PackageInfo
        ) != SEC_E_OK) return FALSE;

    //
    // loop through the packages looking for NTLM
    //

    cbMaxToken = 0;
    for(PackageIndex = 0 ; PackageIndex < PackageCount ; PackageIndex++ ) {
        if(PackageInfo[PackageIndex].Name != NULL) {
            if(LSTRCMPIS(PackageInfo[PackageIndex].Name, MICROSOFT_KERBEROS_NAME) == 0) {
                cbMaxToken = PackageInfo[PackageIndex].cbMaxToken;
                bSuccess = TRUE;
                break;
            }
        }
    }

    FreeContextBuffer( PackageInfo );

    if(!bSuccess) return FALSE;

    bSuccess = FALSE; // reset to assume failure

//
// << end of cached section >>
//

    //
    // Acquire a credential handle for the server side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_INBOUND,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    &CredentialHandle1,
                    &Lifetime
                    );

    if ( SecStatus != SEC_E_OK ) {
        goto cleanup;
    }


    //
    // Acquire a credential handle for the client side
    //

    ZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    if ( DomainName != NULL ) {
        AuthIdentity.Domain = DomainName;
        AuthIdentity.DomainLength = lstrlen(DomainName);
    }

    if ( UserName != NULL ) {
        AuthIdentity.User = UserName;
        AuthIdentity.UserLength = lstrlen(UserName);
    }

    if ( Password != NULL ) {
        AuthIdentity.Password = Password;
        AuthIdentity.PasswordLength = lstrlen(Password);
    }

#ifdef UNICODE
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
#else
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
#endif

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    MICROSOFT_KERBEROS_NAME,    // Package Name
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    (DomainName == NULL && UserName == NULL && Password == NULL) ?
                        NULL : &AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime
                    );

    if ( SecStatus != SEC_E_OK ) {
        goto cleanup;
    }

    SecStatus =  QueryCredentialsAttributes(&CredentialHandle1, SECPKG_CRED_ATTR_NAMES, &sNames);
    if ( SecStatus != SEC_E_OK ) {
        goto cleanup;
    }
    //
    // Get the NegotiateMessage (ClientSide)
    //

    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, NegotiateBuffer.cbBuffer );

    if ( NegotiateBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,                       // No Client context yet
                    sNames.sUserName,                       // target name
                    ISC_REQ_SEQUENCE_DETECT,
                    0,                          // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                       // No initial input token
                    0,                          // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != SEC_E_OK)
    {
        goto cleanup;
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //

    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( LMEM_FIXED, ChallengeBuffer.cbBuffer );

    if ( ChallengeBuffer.pvBuffer == NULL ) {
        goto cleanup;
    }

    SecStatus = AcceptSecurityContext(
                    &CredentialHandle1,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ISC_REQ_SEQUENCE_DETECT,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime
                    );
    if(SecStatus != SEC_E_OK)
    {
        goto cleanup;
    }


    if(QuerySecurityContextToken(&ServerContextHandle, phToken) != SEC_E_OK)
        goto cleanup;

    bSuccess = TRUE;

cleanup:

    //
    // Delete context
    //

    if((ClientContextHandle.dwUpper != MAXDWORD) ||
        (ClientContextHandle.dwLower != MAXDWORD))
    {
        DeleteSecurityContext( &ClientContextHandle );
    }
    if((ServerContextHandle.dwUpper != MAXDWORD) ||
        (ServerContextHandle.dwLower != MAXDWORD))
    {
        DeleteSecurityContext( &ServerContextHandle );
    }

    //
    // Free credential handles
    //
    if((CredentialHandle1.dwUpper != MAXDWORD) ||
        (CredentialHandle1.dwLower != MAXDWORD))
    {
        FreeCredentialsHandle( &CredentialHandle1 );
    }
    if((CredentialHandle2.dwUpper != MAXDWORD) ||
        (CredentialHandle2.dwLower != MAXDWORD))
    {
        FreeCredentialsHandle( &CredentialHandle2 );
    }

    if ( NegotiateBuffer.pvBuffer != NULL ) {

        //
        // NegotiateBuffer.cbBuffer may change on the error path --
        // use the original allocation size.
        //

        SecureZeroMemory( NegotiateBuffer.pvBuffer, cbMaxToken );
        LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {

        //
        // ChallengeBuffer.cbBuffer may change on the error path --
        // use the original allocation size.
        //

        SecureZeroMemory( ChallengeBuffer.pvBuffer, cbMaxToken );
        LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( sNames.sUserName != NULL ) {
        FreeContextBuffer( sNames.sUserName );
    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\dstest.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dstest.cpp
//
// Contents:    DS ping test
//
// History:     13-Mar-98       mattt created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <dsrole.h>
#include <dsgetdc.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <cainfop.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_DSTEST_CPP__


#define DS_RETEST_SECONDS   15

HRESULT
myDoesDSExist(
    IN BOOL fRetry)
{
    HRESULT hr = S_OK;

    static BOOL s_fKnowDSExists = FALSE;
    static HRESULT s_hrDSExists = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    static FILETIME s_ftNextTest = {0,0};
    
    if (s_fKnowDSExists && (s_hrDSExists != S_OK) && fRetry)
    //    s_fKnowDSExists = FALSE;	// force a retry
    {
        FILETIME ftCurrent;
        GetSystemTimeAsFileTime(&ftCurrent);

        // if Compare is < 0 (next < current), force retest
        if (0 > CompareFileTime(&s_ftNextTest, &ftCurrent))
            s_fKnowDSExists = FALSE;    
    }

    if (!s_fKnowDSExists)
    {
        FILETIME ftCurrentNew;
        GetSystemTimeAsFileTime(&ftCurrentNew);

	// set NEXT in 100ns increments

        ((LARGE_INTEGER *) &s_ftNextTest)->QuadPart = 
		((LARGE_INTEGER *) &ftCurrentNew)->QuadPart +
	    (__int64) (CVT_BASE * CVT_SECONDS) * DS_RETEST_SECONDS;

        // NetApi32 is delay loaded, so wrap to catch problems when it's not available
        __try
        {
            DOMAIN_CONTROLLER_INFO *pDCI;
            DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRole;
        
            // ensure we're not standalone
            pDsRole = NULL;
            hr = DsRoleGetPrimaryDomainInformation(	// Delayload wrapped
				    NULL,
				    DsRolePrimaryDomainInfoBasic,
				    (BYTE **) &pDsRole);

            _PrintIfError(hr, "DsRoleGetPrimaryDomainInformation");
            if (S_OK == hr &&
                (pDsRole->MachineRole == DsRole_RoleStandaloneServer ||
                 pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation))
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
		_PrintError(hr, "DsRoleGetPrimaryDomainInformation(no domain)");
            }

            if (NULL != pDsRole) 
	    {
                DsRoleFreeMemory(pDsRole);     // Delayload wrapped
	    }
            if (S_OK == hr)
            {
                // not standalone; return info on our DS

                pDCI = NULL;
                hr = DsGetDcName(    // Delayload wrapped
			    NULL,
			    NULL,
			    NULL,
			    NULL,
			    DS_DIRECTORY_SERVICE_PREFERRED,
			    &pDCI);
		_PrintIfError(hr, "DsGetDcName");
            
                if (S_OK == hr && 0 == (pDCI->Flags & DS_DS_FLAG))
                {
                    hr = HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
		    _PrintError(hr, "DsGetDcName(no domain info)");
                }
                if (NULL != pDCI)
                {
                   NetApiBufferFree(pDCI);    // Delayload wrapped
                }
            }
            s_fKnowDSExists = TRUE;
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }

        // else just allow users without netapi flounder with timeouts
        // if ds not available...

        s_hrDSExists = myHError(hr);
	_PrintIfError2(
		s_hrDSExists,
		"DsRoleGetPrimaryDomainInformation/DsGetDcName",
		HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE));
    }
    return(s_hrDSExists);
}


HRESULT
myRobustLdapBind(
    OUT LDAP **ppldap,
    IN BOOL dwFlags)	// RLBF_* -- must be BOOL to preserve signature
{
    DWORD dwFlags1 = 0;
    
    // for backward compatibility, TRUE implies RLBF_REQUIRE_GC
    
    CSASSERT(TRUE == RLBF_TRUE);
    if (RLBF_TRUE & dwFlags)
    {
	dwFlags |= RLBF_REQUIRE_GC;
	dwFlags &= ~RLBF_TRUE;
	dwFlags1 |= RLBF_TRUE;
    }
    return(myRobustLdapBindEx(
			dwFlags1,	// dwFlags1
			dwFlags,	// dwFlags2
			LDAP_VERSION2,
			NULL,
			ppldap,
			NULL));
}


HRESULT
DCSupportsSigning(
    IN LDAP *pld,
    OUT BOOL *pfSigningSupported)
{
    HRESULT hr;
    LDAPMessage *pSearchResult = NULL;
    LDAPMessage *pEntry;
    LDAP_TIMEVAL timeval;
    WCHAR **rgpwszValues;
    WCHAR *apwszAttrArray[2];
    WCHAR *pwszSupportedCapabilities = LDAP_OPATT_SUPPORTED_CAPABILITIES_W;

    *pfSigningSupported = FALSE;

    // Query for the ldap server oerational attributes to obtain the default
    // naming context.

    apwszAttrArray[0] = pwszSupportedCapabilities;
    apwszAttrArray[1] = NULL;	// this is the sentinel

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		    pld,
		    NULL,			// base
		    LDAP_SCOPE_BASE,
		    L"objectClass=*",
		    apwszAttrArray,
		    FALSE,			// attrsonly
		    &timeval,
		    &pSearchResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_st");

    pEntry = ldap_first_entry(pld, pSearchResult);
    if (NULL == pEntry)
    {
	hr = myHLdapLastError(pld, NULL);
	_JumpError(hr, error, "ldap_first_entry");
    }

    rgpwszValues = ldap_get_values(pld, pEntry, pwszSupportedCapabilities);
    if (NULL != rgpwszValues)
    {
	DWORD i;
	
	for (i = 0; NULL != rgpwszValues[i]; i++)
	{
	    if (0 == wcscmp(
			rgpwszValues[i],
			LDAP_CAP_ACTIVE_DIRECTORY_LDAP_INTEG_OID_W))
	    {
		*pfSigningSupported = TRUE;
		break;
	    }
	}
	ldap_value_free(rgpwszValues);
    }
    hr = S_OK;

error:
    if (NULL != pSearchResult)
    {
        ldap_msgfree(pSearchResult);
    }
    return(hr);
}


HRESULT
myRobustLdapBindEx(
    IN BOOL dwFlags1,   // TRUE --> RLBF_REQUIRE_GC -- both Flags must be BOOL
    IN BOOL dwFlags2,	// RLBF_* -- TRUE --> RLBF_ATTEMPT_REDISCOVER
    IN ULONG uVersion,
    OPTIONAL IN WCHAR const *pwszDomainName,
    OUT LDAP **ppldap,
    OPTIONAL OUT WCHAR **ppwszForestDNSName)
{
    HRESULT hr;
    BOOL fGC;
    BOOL fRediscover;
    ULONG ldaperr;
    DWORD GetDSNameFlags;
    LDAP *pld = NULL;
    DWORD LDAPFlags = myGetLDAPFlags();

    if (RLBF_TRUE & dwFlags1)
    {
	dwFlags2 |= RLBF_REQUIRE_GC;
    }
    if (RLBF_TRUE & dwFlags2)
    {
	dwFlags2 |= RLBF_ATTEMPT_REDISCOVER;
    }
    fGC = (RLBF_REQUIRE_GC & dwFlags2)? TRUE : FALSE;
    fRediscover = (RLBF_ATTEMPT_REDISCOVER & dwFlags2)? TRUE : FALSE;

    GetDSNameFlags = DS_RETURN_DNS_NAME;
    if (fGC)
    {
        GetDSNameFlags |= DS_GC_SERVER_REQUIRED;
    }

    // bind to ds

    while (TRUE)
    {

    if (NULL != pld)
    {
        ldap_unbind(pld);
    }

	pld = ldap_init(
		    const_cast<WCHAR *>(pwszDomainName),
		    (LDAPF_SSLENABLE & LDAPFlags)?
			(fGC? LDAP_SSL_GC_PORT : LDAP_SSL_PORT) :
			(fGC? LDAP_GC_PORT : LDAP_PORT));
	if (NULL == pld)
	{
	    hr = myHLdapLastError(NULL, NULL);
	    if (!fRediscover)
	    {
		_PrintError2(hr, "ldap_init", hr);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "ldap_init");
	}

	if (fRediscover)
	{
	   GetDSNameFlags |= DS_FORCE_REDISCOVERY;
	}
	ldaperr = ldap_set_option(
			    pld,
			    LDAP_OPT_GETDSNAME_FLAGS,
			    (VOID *) &GetDSNameFlags);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, NULL);
	    if (!fRediscover)
	    {
		_PrintError2(hr, "ldap_set_option", hr);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "ldap_set_option");
	}

	// if uVersion is 0, turn on TCP_KEEPALIVE

	if (0 == uVersion)
	{
	    ldaperr = ldap_set_option(pld, LDAP_OPT_TCP_KEEPALIVE, LDAP_OPT_ON);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "ldap_set_option", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError2(hr, error, "ldap_set_option", hr);
	    }

	    // set the uVersion to LDAP_VERSION3

	    uVersion = LDAP_VERSION3;
	}


	// set the client version.  No need to set LDAP_VERSION2 since 
	// this is the default

	if (LDAP_VERSION2 != uVersion)
	{
	    ldaperr = ldap_set_option(pld, LDAP_OPT_VERSION, &uVersion);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, NULL);
		if (!fRediscover)
		{
		    _PrintError2(hr, "ldap_set_option", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "ldap_set_option");
	    }
	}

	if (0 == (LDAPF_SIGNDISABLE & LDAPFlags) && IsWhistler())
	{
	    BOOL fSigningSupported = TRUE;

	    // if caller requires the related DS bug fix...

	    if (RLBF_REQUIRE_LDAP_INTEG & dwFlags2)
	    {
		hr = DCSupportsSigning(pld, &fSigningSupported);
		_JumpIfError(hr, error, "DCSupportsSigning");
	    }
	    if (fSigningSupported)
	    {
		ldaperr = ldap_set_option(pld, LDAP_OPT_SIGN, LDAP_OPT_ON);
		if (LDAP_SUCCESS != ldaperr)
		{
		    hr = myHLdapError2(pld, ldaperr, LDAP_PARAM_ERROR, NULL);
		    if (!fRediscover)
		    {
			_PrintError2(hr, "ldap_set_option", hr);
			fRediscover = TRUE;
			continue;
		    }
		    _JumpError(hr, error, "ldap_set_option");
		}
	    }
	    else
	    if (0 == (LDAPF_SSLENABLE & LDAPFlags) &&
		(RLBF_REQUIRE_SECURE_LDAP & dwFlags2))
	    {
		hr =  CERTSRV_E_DOWNLEVEL_DC_SSL_OR_UPGRADE;
		_JumpError(hr, error, "server missing required service pack");
	    }
	}

	ldaperr = ldap_bind_s(pld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
	if (LDAP_SUCCESS != ldaperr)
	{
	    hr = myHLdapError(pld, ldaperr, NULL);
	    if (!fRediscover)
	    {
		_PrintError2(hr, "ldap_bind_s", hr);
		fRediscover = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "ldap_bind_s");
	}

	if (NULL != ppwszForestDNSName)
	{
	    WCHAR *pwszDomainControllerName;

	    hr = myLdapGetDSHostName(pld, &pwszDomainControllerName);
	    if (S_OK != hr)
	    {
		if (!fRediscover)
		{
		    _PrintError2(hr, "myLdapGetDSHostName", hr);
		    fRediscover = TRUE;
		    continue;
		}
		_JumpError(hr, error, "myLdapGetDSHostName");
	    }
	    hr = myDupString(pwszDomainControllerName, ppwszForestDNSName);
	    _JumpIfError(hr, error, "myDupString");
	}
	break;
    }
    *ppldap = pld;
    pld = NULL;
    hr = S_OK;

error:
    if (NULL != pld)
    {
        ldap_unbind(pld);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\error.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        error.cpp
//
// Contents:    Cert Server error wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <assert.h>
#include <ntdsbmsg.h>
#include <delayimp.h>
#include <wininet.h>
#include "resource.h"

#define __dwFILE__	__dwFILE_CERTCLIB_ERROR_CPP__

#define DBG_CERTSRV_DEBUG_PRINT


#define CERTLIB_12BITERRORMASK  0x00000fff
#define CERTLIB_WIN32ERRORMASK  0x0000ffff


//+--------------------------------------------------------------------------
// Jet errors:

#define HRESULT_FROM_JETWARNING(jerr) \
        (ERROR_SEVERITY_WARNING | (FACILITY_NTDSB << 16) | jerr)

#define HRESULT_FROM_JETERROR(jerr) \
        (ERROR_SEVERITY_ERROR | (FACILITY_NTDSB << 16) | -jerr)

#define JETERROR_FROM_HRESULT(hr) \
        (-(LONG) (CERTLIB_WIN32ERRORMASK & (hr)))

#define ISJETERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) ~CERTLIB_WIN32ERRORMASK)

#define ISJETHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
					      (FACILITY_NTDSB << 16)))

#define wszJETERRORPREFIX       L"ESE"


//+--------------------------------------------------------------------------
// Setup API errors:

#define ISSETUPHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              APPLICATION_ERROR_MASK | \
                                              (FACILITY_NULL << 16)))

#define wszSETUPERRORPREFIX       L"INF"


//+--------------------------------------------------------------------------
// Win32 errors:

#define ISWIN32ERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == 0)

#define ISWIN32HRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_WARNING | \
					      (FACILITY_WIN32 << 16)))

#define WIN32ERROR_FROM_HRESULT(hr) \
        (CERTLIB_WIN32ERRORMASK & (hr))

#define wszWIN32ERRORPREFIX     L"WIN32"


//+--------------------------------------------------------------------------
// Http errors:

#define ISHTTPERROR(hr) \
    ((HRESULT) HTTP_STATUS_FIRST <= (hr) && (HRESULT) HTTP_STATUS_LAST >= (hr))

#define ISHTTPHRESULT(hr) \
    (ISWIN32HRESULT(hr) && ISHTTPERROR(WIN32ERROR_FROM_HRESULT(hr)))

#define wszHTTPERRORPREFIX     L"HTTP"


//+--------------------------------------------------------------------------
// Delayload errors:

#define DELAYLOAD_FROM_WIN32(hr)  VcppException(ERROR_SEVERITY_ERROR, (hr))

#define WIN32ERROR_FROM_DELAYLOAD(hr)  (CERTLIB_WIN32ERRORMASK & (hr))

#define ISDELAYLOADHRESULTFACILITY(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              (FACILITY_VISUALCPP << 16)))

// E_DELAYLOAD_MOD_NOT_FOUND    0xc06d007e
#define E_DELAYLOAD_MOD_NOT_FOUND   DELAYLOAD_FROM_WIN32(ERROR_MOD_NOT_FOUND)

// E_DELAYLOAD_PROC_NOT_FOUND   0xc06d007f
#define E_DELAYLOAD_PROC_NOT_FOUND  DELAYLOAD_FROM_WIN32(ERROR_PROC_NOT_FOUND)

#define ISDELAYLOADHRESULT(hr) \
        ((HRESULT) E_DELAYLOAD_MOD_NOT_FOUND == (hr) || \
         (HRESULT) E_DELAYLOAD_PROC_NOT_FOUND == (hr) || \
         HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) == (hr) || \
         HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND) == (hr))


//+--------------------------------------------------------------------------
// ASN encoding errors:

#define ISOSSERROR(hr) \
        ((~CERTLIB_12BITERRORMASK & (hr)) == CRYPT_E_OSS_ERROR)

#define OSSERROR_FROM_HRESULT(hr) \
        (CERTLIB_12BITERRORMASK & (hr))

#define wszOSSERRORPREFIX       L"ASN"


HRESULT
myJetHResult(
    IN HRESULT hr)
{
#if DBG_CERTSRV
    HRESULT hrIn = hr;
#endif
    if (S_OK != hr)
    {
        if (SUCCEEDED(hr))
        {
#if 0
            hr = HRESULT_FROM_JETWARNING(hr);
#else
            if (S_FALSE != hr)
            {
                _PrintError(hr, "JetHResult: mapping to S_FALSE");
            }
            CSASSERT(S_FALSE == hr);
            hr = S_FALSE;
#endif
        }
        else if (ISJETERROR(hr))
        {
            hr = HRESULT_FROM_JETERROR(hr);
        }
    }
#if DBG_CERTSRV
    if (S_OK != hrIn || S_OK != hr)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "myJetHResult(%x (%d)) --> %x (%d)\n",
	    hrIn,
	    hrIn,
	    hr,
            hr));
    }
#endif
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
myHExceptionCode(
    IN EXCEPTION_POINTERS const *pep)
{
    HRESULT hr = pep->ExceptionRecord->ExceptionCode;

#if (0 == i386)
    if ((HRESULT) STATUS_DATATYPE_MISALIGNMENT == hr)
    {
	hr = CERTSRV_E_ALIGNMENT_FAULT;
    }
#endif
    return(myHError(hr));
}


#ifdef DBG_CERTSRV_DEBUG_PRINT

VOID
myCaptureStackBackTrace(
    EXCEPTION_POINTERS const *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    ZeroMemory(aeip, cFrames * sizeof(aeip[0]));

#if i386 == 1
    ULONG ieip, *pebp;
    ULONG *pebpMax = (ULONG *) MAXLONG; // 2 * 1024 * 1024 * 1024; // 2 gig - 1
    ULONG *pebpMin = (ULONG *) (64 * 1024);	// 64k

    if (pep == NULL)
    {
        ieip = 0;
        cSkip++;                    // always skip current frame
        pebp = ((ULONG *) &pep) - 2;
    }
    else
    {
        ieip = 1;
        assert(cSkip == 0);
        aeip[0] = pep->ContextRecord->Eip;
        pebp = (ULONG *) pep->ContextRecord->Ebp;
    }
    if (pebp >= pebpMin && pebp < pebpMax)
    {
        __try
        {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                if (ieip >= cSkip)
                {
                    aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                ULONG *pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 || pebpNext >= pebpMax - 1)
                {
                    break;
                }
                pebp = pebpNext;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
#endif // i386 == 1
}

#endif // ifdef DBG_CERTSRV_DEBUG_PRINT


FNLOGEXCEPTION *s_pfnLogException = NULL;

VOID
myLogExceptionInit(
    OPTIONAL IN FNLOGEXCEPTION *pfnLogException)
{
    s_pfnLogException = pfnLogException;
}


HRESULT
myHExceptionCodePrint(
    IN EXCEPTION_POINTERS const *pep,
    OPTIONAL IN char const *pszFile,
    IN DWORD dwFile,
    IN DWORD dwLine)
{
    HRESULT hr;
#ifdef DBG_CERTSRV_DEBUG_PRINT

    if (DbgIsSSActive(DBG_SS_ERROR) &&
	(!myIsDelayLoadHResult(pep->ExceptionRecord->ExceptionCode) ||
	 DbgIsSSActive(DBG_SS_MODLOAD)))
    {
	WCHAR awc[35 + 3 * cwcDWORDSPRINTF];
	ULONG aeip[16];

	wsprintf(
	    awc,
	    L"0x%x @ 0x%p",
	    pep->ExceptionRecord->ExceptionFlags,
	    pep->ExceptionRecord->ExceptionAddress);

	if (NULL == pszFile)
	{
	    CSPrintErrorLineFileData(
		    awc,
		    __MAKELINEFILE__(dwFile, dwLine),
		    pep->ExceptionRecord->ExceptionCode);
	}
	else
	{
	    CSPrintError(
		    "Exception",
		    awc,
		    pszFile,
		    dwLine,
		    pep->ExceptionRecord->ExceptionCode,
		    S_OK);
	}
	myCaptureStackBackTrace(pep, 0, ARRAYSIZE(aeip), aeip);

	for (int i = 0; i < ARRAYSIZE(aeip); i++)
	{
	    if (0 == aeip[i])
	    {
		break;
	    }
	    DbgPrintf(MAXDWORD, "ln %x;", aeip[i]);
	}
	if (0 < i)
	{
	    DbgPrintf(MAXDWORD, "\n");
	}
    }
#endif // DBG_CERTSRV_DEBUG_PRINT

    hr = myHExceptionCode(pep);
    if (NULL != s_pfnLogException)
    {
	(*s_pfnLogException)(hr, pep, pszFile, dwFile, dwLine);
    }
    return(hr);
}


BOOL
myIsDelayLoadHResult(
    IN HRESULT hr)
{
    return(ISDELAYLOADHRESULT(hr));
}


#define wszCOLONSPACE   L": "

WCHAR const *
myHResultToStringEx(
    IN OUT WCHAR *awchr,
    IN HRESULT hr,
    IN BOOL fRaw)
{
    HRESULT hrd;
    WCHAR const *pwszType;
    LONG cwc;

    hrd = hr;
    pwszType = L"";
    if (ISJETERROR(hr))
    {
        pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISJETHRESULT(hr))
    {
        hrd = JETERROR_FROM_HRESULT(hr);
        pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISOSSERROR(hr))
    {
        hrd = OSSERROR_FROM_HRESULT(hr);
        pwszType = wszOSSERRORPREFIX wszCOLONSPACE;
    }
    else if (ISHTTPHRESULT(hr) || ISHTTPERROR(hr))
    {
        hrd = WIN32ERROR_FROM_HRESULT(hr);
        pwszType = wszWIN32ERRORPREFIX L"/" wszHTTPERRORPREFIX wszCOLONSPACE;
    }
    else if (ISWIN32HRESULT(hr) || ISWIN32ERROR(hr))
    {
        hrd = WIN32ERROR_FROM_HRESULT(hr);
        pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISDELAYLOADHRESULTFACILITY(hr))
    {
        hrd = WIN32ERROR_FROM_DELAYLOAD(hr);
        pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISSETUPHRESULT(hr))
    {
        pwszType = wszSETUPERRORPREFIX wszCOLONSPACE;
    }
    if (fRaw)
    {
        pwszType = L"";
    }

    cwc = _snwprintf(
		awchr,
		cwcHRESULTSTRING,
		L"0x%x (%ws%d)",
		hr,
		pwszType,
		hrd);
    if (0 > cwc || cwcHRESULTSTRING <= cwc)
    {
	awchr[cwcHRESULTSTRING - 1] = L'\0';
    }
    return(awchr);
}


WCHAR const *
myHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(myHResultToStringEx(awchr, hr, FALSE));
}


WCHAR const *
myHResultToStringRaw(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(myHResultToStringEx(awchr, hr, TRUE));
}


typedef struct _ERRORMAP
{
    HRESULT hr;
    UINT    idMessage;
} ERRORMAP;

ERRORMAP g_aSetup[] = {
  { ERROR_EXPECTED_SECTION_NAME, IDS_SETUP_ERROR_EXPECTED_SECTION_NAME, },
  { ERROR_BAD_SECTION_NAME_LINE, IDS_SETUP_ERROR_BAD_SECTION_NAME_LINE, },
  { ERROR_SECTION_NAME_TOO_LONG, IDS_SETUP_ERROR_SECTION_NAME_TOO_LONG, },
  { ERROR_GENERAL_SYNTAX,	 IDS_SETUP_ERROR_GENERAL_SYNTAX, },
  { ERROR_WRONG_INF_STYLE,	 IDS_SETUP_ERROR_WRONG_INF_STYLE, },
  { ERROR_SECTION_NOT_FOUND,	 IDS_SETUP_ERROR_SECTION_NOT_FOUND, },
  { ERROR_LINE_NOT_FOUND,	 IDS_SETUP_ERROR_LINE_NOT_FOUND, },
};

ERRORMAP s_aHttp[] =
{
  { HTTP_STATUS_CONTINUE,		IDS_HTTP_STATUS_CONTINUE },
  { HTTP_STATUS_SWITCH_PROTOCOLS,	IDS_HTTP_STATUS_SWITCH_PROTOCOLS },
  { HTTP_STATUS_OK,			IDS_HTTP_STATUS_OK },
  { HTTP_STATUS_CREATED,		IDS_HTTP_STATUS_CREATED },
  { HTTP_STATUS_ACCEPTED,		IDS_HTTP_STATUS_ACCEPTED },
  { HTTP_STATUS_PARTIAL,		IDS_HTTP_STATUS_PARTIAL },
  { HTTP_STATUS_NO_CONTENT,		IDS_HTTP_STATUS_NO_CONTENT },
  { HTTP_STATUS_RESET_CONTENT,		IDS_HTTP_STATUS_RESET_CONTENT },
  { HTTP_STATUS_PARTIAL_CONTENT,	IDS_HTTP_STATUS_PARTIAL_CONTENT },
  { HTTP_STATUS_AMBIGUOUS,		IDS_HTTP_STATUS_AMBIGUOUS },
  { HTTP_STATUS_MOVED,			IDS_HTTP_STATUS_MOVED },
  { HTTP_STATUS_REDIRECT,		IDS_HTTP_STATUS_REDIRECT },
  { HTTP_STATUS_REDIRECT_METHOD,	IDS_HTTP_STATUS_REDIRECT_METHOD },
  { HTTP_STATUS_NOT_MODIFIED,		IDS_HTTP_STATUS_NOT_MODIFIED },
  { HTTP_STATUS_USE_PROXY,		IDS_HTTP_STATUS_USE_PROXY },
  { HTTP_STATUS_REDIRECT_KEEP_VERB,	IDS_HTTP_STATUS_REDIRECT_KEEP_VERB },
  { HTTP_STATUS_BAD_REQUEST,		IDS_HTTP_STATUS_BAD_REQUEST },
  { HTTP_STATUS_DENIED,			IDS_HTTP_STATUS_DENIED },
  { HTTP_STATUS_PAYMENT_REQ,		IDS_HTTP_STATUS_PAYMENT_REQ },
  { HTTP_STATUS_FORBIDDEN,		IDS_HTTP_STATUS_FORBIDDEN },
  { HTTP_STATUS_NOT_FOUND,		IDS_HTTP_STATUS_NOT_FOUND },
  { HTTP_STATUS_BAD_METHOD,		IDS_HTTP_STATUS_BAD_METHOD },
  { HTTP_STATUS_NONE_ACCEPTABLE,	IDS_HTTP_STATUS_NONE_ACCEPTABLE },
  { HTTP_STATUS_PROXY_AUTH_REQ,		IDS_HTTP_STATUS_PROXY_AUTH_REQ },
  { HTTP_STATUS_REQUEST_TIMEOUT,	IDS_HTTP_STATUS_REQUEST_TIMEOUT },
  { HTTP_STATUS_CONFLICT,		IDS_HTTP_STATUS_CONFLICT },
  { HTTP_STATUS_GONE,			IDS_HTTP_STATUS_GONE },
  { HTTP_STATUS_LENGTH_REQUIRED,	IDS_HTTP_STATUS_LENGTH_REQUIRED },
  { HTTP_STATUS_PRECOND_FAILED,		IDS_HTTP_STATUS_PRECOND_FAILED },
  { HTTP_STATUS_REQUEST_TOO_LARGE,	IDS_HTTP_STATUS_REQUEST_TOO_LARGE },
  { HTTP_STATUS_URI_TOO_LONG,		IDS_HTTP_STATUS_URI_TOO_LONG },
  { HTTP_STATUS_UNSUPPORTED_MEDIA,	IDS_HTTP_STATUS_UNSUPPORTED_MEDIA },
  { HTTP_STATUS_RETRY_WITH,		IDS_HTTP_STATUS_RETRY_WITH },
  { HTTP_STATUS_SERVER_ERROR,		IDS_HTTP_STATUS_SERVER_ERROR },
  { HTTP_STATUS_NOT_SUPPORTED,		IDS_HTTP_STATUS_NOT_SUPPORTED },
  { HTTP_STATUS_BAD_GATEWAY,		IDS_HTTP_STATUS_BAD_GATEWAY },
  { HTTP_STATUS_SERVICE_UNAVAIL,	IDS_HTTP_STATUS_SERVICE_UNAVAIL },
  { HTTP_STATUS_GATEWAY_TIMEOUT,	IDS_HTTP_STATUS_GATEWAY_TIMEOUT },
  { HTTP_STATUS_VERSION_NOT_SUP,	IDS_HTTP_STATUS_VERSION_NOT_SUP },
};


DWORD
errLoadStaticMessage(
    IN HRESULT hr,
    IN ERRORMAP const *pmap,
    IN DWORD cmap,
    OUT WCHAR const **ppwszOut)
{
    DWORD cwc = 0;
    ERRORMAP const *pmapEnd;

    for (pmapEnd = &pmap[cmap]; pmap < pmapEnd; pmap++)
    {
	if (hr == pmap->hr)
	{
	    *ppwszOut = myLoadResourceString(pmap->idMessage);
	    if (NULL != *ppwszOut)
	    {
		cwc = wcslen(*ppwszOut);
	    }
	    break;
	}
    }
//error:
    return(cwc);
}


DWORD
errFormatMessage(
    IN HMODULE hMod,
    IN HRESULT hr,
    OUT WCHAR const **ppwszOut,
    OPTIONAL IN WCHAR const * const *ppwszArgs)
{
    DWORD dwFlags;

    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;
    if (NULL == hMod)
    {
	dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
	dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }
    if (NULL == ppwszArgs || NULL == ppwszArgs[0])
    {
	dwFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    else
    {
	dwFlags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
    }
    return(FormatMessage(
		dwFlags,
                hMod,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                (WCHAR *) ppwszOut,
                1,    
		(va_list *) ppwszArgs));
}


// Alloc and return error message string

WCHAR const *
myGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString)
{
    return(myGetErrorMessageTextEx(hr, fHResultString, NULL));
}


WCHAR const *
myGetErrorMessageText1(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const *pwszInsertionText)
{
    WCHAR const *apwszInsertionText[2];
    WCHAR const * const *papwsz = NULL;

    if (NULL != pwszInsertionText)
    {
	apwszInsertionText[0] = pwszInsertionText;
	apwszInsertionText[1] = NULL;
	papwsz = apwszInsertionText;
    }
    return(myGetErrorMessageTextEx(hr, fHResultString, papwsz));
}


WCHAR const *
myGetErrorMessageTextEx(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const * const *papwszInsertionText)
{
    static WCHAR s_wszUnknownDefault[] = L"Error";
    WCHAR const *pwszRet = NULL;
    WCHAR const *pwszRetStatic = NULL;
    WCHAR *pwszMsgT;
    WCHAR awchr[cwcHRESULTSTRING];
    DWORD cwc;
    DWORD cwcCopy;
    DWORD cwcUnexpected;
    WCHAR const *pwszUnexpected = NULL;
    WCHAR wszEmpty[] = L"";
    HMODULE hMod1 = NULL;
    HMODULE hMod2 = NULL;

    if (E_UNEXPECTED == hr)
    {
	pwszUnexpected = myLoadResourceString(IDS_E_UNEXPECTED); // L"Unexpected method call sequence."
    }
#if (0 == i386)
    else if (STATUS_DATATYPE_MISALIGNMENT == hr)
    {
	pwszUnexpected = myLoadResourceString(IDS_E_DATA_MISALIGNMENT); // L"Possible data alignment fault."
    }
#endif
    if (NULL == pwszUnexpected)
    {
	HRESULT hrHttp = hr;
	
	if (ISWIN32HRESULT(hrHttp))
	{
	    hrHttp = WIN32ERROR_FROM_HRESULT(hrHttp);
	}
	if (ISHTTPERROR(hrHttp))
	{
	    cwc = errLoadStaticMessage(
			    hrHttp,
			    s_aHttp,
			    ARRAYSIZE(s_aHttp),
			    &pwszUnexpected);
	}
    }
    if (NULL == pwszUnexpected)
    {
	pwszUnexpected = wszEmpty;
    }
    cwcUnexpected = wcslen(pwszUnexpected);

    cwc = errFormatMessage(NULL, hr, &pwszRet, papwszInsertionText);
    if (0 == cwc && ISDELAYLOADHRESULTFACILITY(hr))
    {
	cwc = errFormatMessage(
			NULL,
			WIN32ERROR_FROM_DELAYLOAD(hr),
			&pwszRet,
			papwszInsertionText);
    }
    if (0 == cwc && ISSETUPHRESULT(hr))
    {
	cwc = errLoadStaticMessage(
			    hr,
			    g_aSetup,
			    ARRAYSIZE(g_aSetup),
			    &pwszRetStatic);
	pwszRet = pwszRetStatic;
    }
    if (0 == cwc)
    {
        hMod1 = LoadLibrary(L"ntdsbmsg.dll");
        if (NULL != hMod1)
        {
            HRESULT hrEDB = hr;
            HRESULT hrFormat;
            BOOL fFirst = TRUE;

            while (TRUE)
            {
                cwc = errFormatMessage(hMod1, hrEDB, &pwszRet, papwszInsertionText);
                if (0 == cwc && FAILED(hrEDB) && fFirst)
                {
                    hrFormat = myHLastError();
                    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hrFormat)
                    {
                        hrEDB = myJetHResult(hrEDB);
                        if (hrEDB != hr)
                        {
                            fFirst = FALSE;
                            continue;
                        }
                    }
                }
                break;
            }
        }
    }
    if (0 == cwc)
    {
	HMODULE hModT = GetModuleHandle(L"wininet.dll");
        if (NULL != hModT)
        {
            HRESULT hrHttp = hr;
            HRESULT hrFormat;
            BOOL fFirst = TRUE;

            while (TRUE)
            {
		cwc = errFormatMessage(hModT, hrHttp, &pwszRet, papwszInsertionText);
                if (0 == cwc && ISWIN32HRESULT(hrHttp) && fFirst)
                {
                    hrFormat = myHLastError();
                    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hrFormat)
                    {
			hrHttp = WIN32ERROR_FROM_HRESULT(hrHttp);
                        if (hrHttp != hr)
                        {
                            fFirst = FALSE;
                            continue;
                        }
                    }
                }
                break;
            }
        }
    }
    if (0 == cwc)
    {
        hMod2 = LoadLibrary(L"cdosys.dll");
        if (NULL != hMod2)
        {
	    cwc = errFormatMessage(hMod2, hr, &pwszRet, papwszInsertionText);
        }
    }

    if (0 == cwc)	// couldn't find error, use default & error code
    {
	fHResultString = TRUE;
    }
    awchr[0] = L'\0';
    if (fHResultString)
    {
	myHResultToString(awchr, hr);
    }

    if (0 == cwc)
    {
	pwszRetStatic = myLoadResourceString(IDS_UNKNOWN_ERROR_CODE); // L"Error"
	if (NULL == pwszRetStatic)
	{
            pwszRetStatic = s_wszUnknownDefault;
        }
	pwszRet = pwszRetStatic;
    }

    // strip trailing \r\n

    cwcCopy = wcslen(pwszRet);
    if (2 <= cwcCopy &&
	L'\r' == pwszRet[cwcCopy - 2] &&
	L'\n' == pwszRet[cwcCopy - 1])
    {
	cwcCopy -= 2;
    }
    cwc = cwcCopy + 1 + cwcUnexpected + 1 + wcslen(awchr) + 1;
    pwszMsgT = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszMsgT)
    {
	_JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }
    CopyMemory(pwszMsgT, pwszRet, cwcCopy * sizeof(WCHAR));
    pwszMsgT[cwcCopy] = L'\0';

    if (0 != cwcUnexpected)
    {
	wcscat(pwszMsgT, L" ");
	wcscat(pwszMsgT, pwszUnexpected);
    }
    if (fHResultString)
    {
	wcscat(pwszMsgT, L" ");
	wcscat(pwszMsgT, awchr);
    }
    CSASSERT(wcslen(pwszMsgT) < cwc);
    if (NULL != pwszRet && pwszRetStatic != pwszRet)
    {
	LocalFree(const_cast<WCHAR *>(pwszRet));
    }
    pwszRet = pwszMsgT;

error:
    if (NULL != hMod1)
    {
        FreeLibrary(hMod1);
    }
    if (NULL != hMod2)
    {
        FreeLibrary(hMod2);
    }
    return(pwszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\deftypes.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        deftypes.cpp
//
// Contents:    Default cert types
//
// History:     12-Jan-98       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop
#include <winldap.h>

#include "certtype.h"
#include "certacl.h"

#include <cainfop.h>
#include <certca.h>
#include <polreg.h>
#include <clibres.h>


#define SMARTCARD_LOGON_CSPS  L"\0"

#define ENCRYPT_USER_CSPS  \
         MS_ENHANCED_PROV_W L"\0" \
         MS_DEF_PROV_W L"\0"

#define ENCRYPT_USER_2K_CSPS  \
         MS_ENHANCED_PROV_W L"\0" 

#define SIGN_USER_CSPS \
         MS_ENHANCED_PROV_W L"\0" \
         MS_DEF_PROV_W L"\0" \
         MS_DEF_DSS_PROV_W L"\0"

#define SSL_SERVER_CSPS \
         MS_DEF_RSA_SCHANNEL_PROV_W L"\0" 

#define WEB_SERVER_CSPS \
         MS_DEF_RSA_SCHANNEL_PROV_W L"\0" \
         MS_DEF_DH_SCHANNEL_PROV_W L"\0" 

#define CA_SERVER_CSPS \
         MS_ENHANCED_PROV_W L"\0" 

//we reserver the 1.1-1.500 as the default OIDs for certifcate types


CERT_TYPE_DEFAULT g_aDefaultCertTypes[] =
{
    {
         wszCERTTYPE_USER,				// wszName
         IDS_CERTTYPE_USER,				// idFriendlyName
         USER_GROUP_SD,					// wszSD
         ENCRYPT_USER_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0"
             TEXT(szOID_KP_EFS) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_EMAIL |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
			 CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,						// dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |			
             CT_FLAG_AUTO_ENROLLMENT |
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.1",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_USER_SIGNATURE,			// wszName
         IDS_CERTTYPE_USER_SIGNATURE,			// idFriendlyName
         USER_GROUP_SD,							// wszSD
         SIGN_USER_CSPS,					    // wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_EMAIL |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
	         CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,							// dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.2",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_SMARTCARD_USER,			// wszName
         IDS_CERTTYPE_SMARTCARD_USER,			// idFriendlyName
         ADMIN_GROUP_SD,						// wszSD
         SMARTCARD_LOGON_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_KP_SMARTCARD_LOGON) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
			 CERT_KEY_ENCIPHERMENT_KEY_USAGE,
	 // dwFlags
	     CT_FLAG_ADD_EMAIL |
	     CT_FLAG_PUBLISH_TO_DS |
	     CT_FLAG_ADD_TEMPLATE_NAME |
	     CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,						// dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 11,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |			
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY_SMART_CARD,		// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.3",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_USER_AS,					// wszName
         IDS_CERTTYPE_USER_AS,					// idFriendlyName
         USER_GROUP_SD,							// wszSD
         SIGN_USER_CSPS,					    // wszCSPs
         // wszEKU
	     TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,						    // dwKeySpec
         0,										// dwDepth
         NULL,									// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,					// dwExpiration
         OVERLAP_SIX_WEEKS,						// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.4",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_USER_SMARTCARD_LOGON,		// wszName
         IDS_CERTTYPE_USER_SMARTCARD_LOGON,		// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SMARTCARD_LOGON_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_KP_SMARTCARD_LOGON ) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
			 CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
	     CT_FLAG_ADD_TEMPLATE_NAME |
	     CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				        // dwKeySpec
         0,						                // dwDepth
         NULL,						            // wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				    // dwExpiration
         OVERLAP_SIX_WEEKS,				        // dwOverlap
         CERTTYPE_VERSION_BASE + 6,			    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY_SMART_CARD,		// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.5",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EFS,				// wszName
         IDS_CERTTYPE_EFS,				// idFriendlyName
         USER_GROUP_SD,					// wszSD  
         ENCRYPT_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_KP_EFS) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.6",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_ADMIN,				// wszName
         IDS_CERTTYPE_ADMIN,				// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         ENCRYPT_USER_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0"
             TEXT(szOID_KP_EFS) L"\0"
             TEXT(szOID_KP_CTL_USAGE_SIGNING) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_EMAIL |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_AUTO_ENROLLMENT |
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_EMAIL |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.7",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EFS_RECOVERY,			// wszName
         IDS_CERTTYPE_EFS_RECOVERY,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         ENCRYPT_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_EFS_RECOVERY) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
			 CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 6,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.8",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CODE_SIGNING,			// wszName
         IDS_CERTTYPE_CODE_SIGNING,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CODE_SIGNING) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				    // dwKeySpec
         0,								// dwDepth
         NULL,							// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,			// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
 		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.9",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_CTL_SIGNING,			// wszName
         IDS_CERTTYPE_CTL_SIGNING,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_KP_CTL_USAGE_SIGNING) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT ,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 3,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.10",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_ENROLLMENT_AGENT,			// wszName
         IDS_CERTTYPE_ENROLLMENT_AGENT,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,			// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.11",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
 		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_ENROLLMENT_AGENT_OFFLINE,		// wszName
         IDS_CERTTYPE_ENROLLMENT_AGENT_OFFLINE,		// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,			// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.12",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_MACHINE_ENROLLMENT_AGENT,		// wszName
         IDS_CERTTYPE_MACHINE_ENROLLMENT_AGENT,		// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SIGN_USER_CSPS,			// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 5,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.13",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_MACHINE,				// wszName
         IDS_CERTTYPE_MACHINE,				// idFriendlyName
         MACHINE_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 5,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
             CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.14",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_DC,				// wszName
         IDS_CERTTYPE_DC,				// idFriendlyName
         DOMAIN_CONTROLLERS_GROUP_SD,			// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ADD_OBJ_GUID |
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID |
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.15",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_WEBSERVER,				// wszName
         IDS_CERTTYPE_WEBSERVER,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         WEB_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.16",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CA,				// wszName
         IDS_CERTTYPE_ROOT_CA,				// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         CA_SERVER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
	     myCASIGN_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_CA |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,					// dwKeySpec
         MAXDWORD,					// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 5,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 0,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.17",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_SUBORDINATE_CA,			// wszName
         IDS_CERTTYPE_SUBORDINATE_CA,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         CA_SERVER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
	     myCASIGN_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_CA |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,					// dwKeySpec
         MAXDWORD,					// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 5,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.18",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
 		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
   },
    {
         wszCERTTYPE_IPSEC_INTERMEDIATE_ONLINE,		// wszName
         IDS_CERTTYPE_IPSEC_INTERMEDIATE_ONLINE,	// idFriendlyName
         IPSEC_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_IPSEC_KP_IKE_INTERMEDIATE) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 8,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN |
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.19",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_IPSEC_INTERMEDIATE_OFFLINE,	// wszName
         IDS_CERTTYPE_IPSEC_INTERMEDIATE_OFFLINE,	// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_IPSEC_KP_IKE_INTERMEDIATE) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 7,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.20",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_ROUTER_OFFLINE,			// wszName
         IDS_CERTTYPE_ROUTER_OFFLINE,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.21",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CEP_ENCRYPTION,			// wszName
         IDS_CERTTYPE_CEP_ENCRYPTION,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         SSL_SERVER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_ENROLLMENT_AGENT) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_TWO_YEARS,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 4,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
             0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.22",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EXCHANGE_USER,			// wszName
         IDS_CERTTYPE_EXCHANGE_USER,			// idFriendlyName
         ADMIN_GROUP_SD,					// wszSD
         ENCRYPT_USER_CSPS,					// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,				// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 7,			// Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
			 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.23",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_EXCHANGE_USER_SIGNATURE,		// wszName
         IDS_CERTTYPE_EXCHANGE_USER_SIGNATURE,		// idFriendlyName
         ADMIN_GROUP_SD,					// wszSD
         SIGN_USER_CSPS,				// wszCSPs
         // wszEKU
             TEXT(szOID_PKIX_KP_EMAIL_PROTECTION) L"\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE,
         // dwFlags
             CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT |
             CT_FLAG_ADD_TEMPLATE_NAME |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,					// dwKeySpec
         0,						// dwDepth
         NULL,						// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				// dwOverlap
         CERTTYPE_VERSION_BASE + 6,				    // Revision
         1,                                     // Minor Revision
		 // dwEnrollmentFlags
			 0,
		 // dwPrivateKeyFlags	
			 0,
		 // dwCertificateNameFlags	 
			 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_1,				// dwSchemaVersion;			     
		 L"1.24",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CROSS_CA,			// wszName
         IDS_CERTTYPE_CROSS_CA,			// idFriendlyName
         ADMIN_GROUP_SD,				// wszSD
         CA_SERVER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
	     myCASIGN_KEY_USAGE,
         // dwFlags
             CT_FLAG_IS_CROSS_CA |
             CT_FLAG_EXPORTABLE_KEY |
             CT_FLAG_IS_DEFAULT,
         AT_SIGNATURE,								// dwKeySpec
         MAXDWORD,					// dwDepth
         TEXT(szOID_BASIC_CONSTRAINTS2) L"\0",		// wszCriticalExtensions
         EXPIRATION_FIVE_YEARS,						// dwExpiration
         OVERLAP_SIX_WEEKS,							// dwOverlap
         CERTTYPE_VERSION_NEXT + 5,					// Revision
         0,                                         // Minor Revision
		 // dwEnrollmentFlags
         CT_FLAG_PUBLISH_TO_DS,
		 // dwPrivateKeyFlags	
	     CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
		 CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 1,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
		 L"1.25",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 TEXT(szOID_KP_QUALIFIED_SUBORDINATION) L"\0",	// *wszRAAppPolicy;				     
		 NULL,									// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_CA_EXCHANGE,			    // wszName
         IDS_CERTTYPE_CA_EXCHANGE,			    // idFriendlyName
         ADMIN_GROUP_SD,				        // wszSD
         ENCRYPT_USER_CSPS,				// wszCSPs
         // wszEKU
             L"\0\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,							// dwKeySpec
         0,											// dwDepth
         NULL,										// wszCriticalExtensions
         EXPIRATION_ONE_WEEK,						// dwExpiration
         OVERLAP_ONE_DAY,							// dwOverlap
         CERTTYPE_VERSION_NEXT + 6,						// Revision
         0,                                         // Minor Revision
		 // dwEnrollmentFlags
         CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS,
		 // dwPrivateKeyFlags	
         0,
		 // dwCertificateNameFlags	 
         CT_FLAG_ENROLLEE_SUPPLIES_SUBJECT,
		 CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
		 L"1.26",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 TEXT(szOID_KP_CA_EXCHANGE) L"\0",		// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_KEY_RECOVERY_AGENT,	    // wszName
         IDS_CERTTYPE_KEY_RECOVERY_AGENT,	    // idFriendlyName
         ADMIN_GROUP_SD,			            // wszSD
         ENCRYPT_USER_2K_CSPS,					// wszCSPs
         // wszEKU
            L"\0\0",
         // bKU
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
			 CT_FLAG_IS_DEFAULT |
             CT_FLAG_AUTO_ENROLLMENT,
         AT_KEYEXCHANGE,								// dwKeySpec
         0,										    // dwDepth
         NULL,		                                // wszCriticalExtensions
         EXPIRATION_TWO_YEARS,						// dwExpiration
         OVERLAP_SIX_WEEKS,							// dwOverlap
         CERTTYPE_VERSION_NEXT + 5,						// Revision
         0,                                         // Minor Revision
		 // dwEnrollmentFlags
         CT_FLAG_AUTO_ENROLLMENT |
         CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
         CT_FLAG_PEND_ALL_REQUESTS |
         CT_FLAG_PUBLISH_TO_KRA_CONTAINER,
		 // dwPrivateKeyFlags	
		 CT_FLAG_EXPORTABLE_KEY,
		 // dwCertificateNameFlags	 
		 CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH |
		 CT_FLAG_SUBJECT_ALT_REQUIRE_UPN,
		 CERTTYPE_2K_KEY,					    // dwMinimalKeySize;				 
		 0,										// dwRASignature;				 
		 CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
		 L"1.27",								// *wszOID;						 
		 NULL,									// *wszSupersedeTemplates;		 
		 NULL,									// *wszRAPolicy;				     
		 NULL,									// *wszCertificatePolicy;
		 NULL,									// *wszRAAppPolicy;				     
		 TEXT(szOID_KP_KEY_RECOVERY_AGENT) L"\0",	// *wszCertificateAppPolicy;
   },
   {
         wszCERTTYPE_DC_AUTH,				    // wszName
         IDS_CERTTYPE_DC_AUTH,				    // idFriendlyName
         V2_DOMAIN_CONTROLLERS_GROUP_SD,	    // wszSD
         SSL_SERVER_CSPS,				        // wszCSPs
         // wszEKU
            L"\0\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,			    	// dwKeySpec
         0,						            // dwDepth
         TEXT(szOID_SUBJECT_ALT_NAME2) L"\0",	 // wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				    // dwOverlap
         CERTTYPE_VERSION_NEXT + 10,			// Revision
         0,                                 // Minor Revision
	     // dwEnrollmentFlags
             CT_FLAG_AUTO_ENROLLMENT,
	     // dwPrivateKeyFlags	
		     0,
	     // dwCertificateNameFlags	 
		     CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
	     CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
	     0,										// dwRASignature;				 
	     CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
	     L"1.28",								// *wszOID;						 
         wszCERTTYPE_DC L"\0",					// *wszSupersedeTemplates;		 
	     NULL,									// *wszRAPolicy;				     
	     NULL,									// *wszCertificatePolicy;
	     NULL,									// *wszRAAppPolicy;				     
	     TEXT(szOID_KP_SMARTCARD_LOGON)  L"\0"
         TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
         TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",	// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_DS_EMAIL_REPLICATION,		// wszName
         IDS_CERTTYPE_DS_EMAIL_REPLICATION,		// idFriendlyName
         V2_DOMAIN_CONTROLLERS_GROUP_SD,		// wszSD
         SSL_SERVER_CSPS,				        // wszCSPs
         // wszEKU
            L"\0\0",
         // bKU
             CERT_DIGITAL_SIGNATURE_KEY_USAGE |
             CERT_KEY_ENCIPHERMENT_KEY_USAGE,
         // dwFlags
             CT_FLAG_AUTO_ENROLLMENT |
             CT_FLAG_MACHINE_TYPE |
             CT_FLAG_IS_DEFAULT,
         AT_KEYEXCHANGE,			    	// dwKeySpec
         0,						            // dwDepth
         TEXT(szOID_SUBJECT_ALT_NAME2) L"\0",	// wszCriticalExtensions
         EXPIRATION_ONE_YEAR,				// dwExpiration
         OVERLAP_SIX_WEEKS,				    // dwOverlap
         CERTTYPE_VERSION_NEXT + 15,				// Revision
         0,                                 // Minor Revision
	     // dwEnrollmentFlags
             CT_FLAG_PUBLISH_TO_DS |
             CT_FLAG_INCLUDE_SYMMETRIC_ALGORITHMS |
             CT_FLAG_AUTO_ENROLLMENT,
	     // dwPrivateKeyFlags	
		     0,
	     // dwCertificateNameFlags	 
			 CT_FLAG_SUBJECT_ALT_REQUIRE_DIRECTORY_GUID |
             CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,
	     CERTTYPE_MINIMAL_KEY,					// dwMinimalKeySize;				 
	     0,										// dwRASignature;				 
	     CERTTYPE_SCHEMA_VERSION_2,				// dwSchemaVersion;			     
	     L"1.29",								// *wszOID;						 
         wszCERTTYPE_DC L"\0",					// *wszSupersedeTemplates;		 
	     NULL,									// *wszRAPolicy;				     
	     NULL,									// *wszCertificatePolicy;
	     NULL,									// *wszRAAppPolicy;				     
	     TEXT(szOID_DS_EMAIL_REPLICATION)  L"\0",	// *wszCertificateAppPolicy;
    },
    {
         wszCERTTYPE_WORKSTATION,		// wszName
         IDS_CERTTYPE_WORKSTATION,		// idFriendlyName
         MACHINE_GROUP_SD,			// wszSD
         SSL_SERVER_CSPS,			// wszCSPs

        // wszEKU
	    L"\0\0",

        // bKU
	    CERT_DIGITAL_SIGNATURE_KEY_USAGE |
            CERT_KEY_ENCIPHERMENT_KEY_USAGE,

        // dwFlags
            CT_FLAG_AUTO_ENROLLMENT |
            CT_FLAG_MACHINE_TYPE |
            CT_FLAG_ADD_TEMPLATE_NAME |
            CT_FLAG_IS_DEFAULT,

        AT_KEYEXCHANGE,				// dwKeySpec
        0,					// dwDepth
        NULL,					// wszCriticalExtensions
        EXPIRATION_ONE_YEAR,			// dwExpiration
        OVERLAP_SIX_WEEKS,			// dwOverlap
        CERTTYPE_VERSION_NEXT + 1,		// Revision
        0,					// Minor Revision

	// dwEnrollmentFlags
	    CT_FLAG_AUTO_ENROLLMENT,

	// dwPrivateKeyFlags
	    0,

	// dwCertificateNameFlags
	    CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,

	CERTTYPE_MINIMAL_KEY,			// dwMinimalKeySize
	0,					// dwRASignature
	CERTTYPE_SCHEMA_VERSION_2,		// dwSchemaVersion
	L"1.30",				// wszOID
	NULL,					// wszSupersedeTemplates
	NULL,					// wszRAPolicy
	NULL,					// wszCertificatePolicy
	NULL,					// wszRAAppPolicy

	// wszCertificateAppPolicy
	    TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
    },
    {
	wszCERTTYPE_RASIASSERVER,		// wszName
        IDS_CERTTYPE_RASIASSERVER,		// idFriendlyName
        RASIASSERVER_GROUP_SD,			// wszSD
        SSL_SERVER_CSPS,			// wszCSPs

	// wszEKU
	    L"\0\0",

        // bKU
	    CERT_DIGITAL_SIGNATURE_KEY_USAGE |
            CERT_KEY_ENCIPHERMENT_KEY_USAGE,

	// dwFlags
            CT_FLAG_AUTO_ENROLLMENT |
            CT_FLAG_MACHINE_TYPE |
            CT_FLAG_ADD_TEMPLATE_NAME |
	    CT_FLAG_IS_DEFAULT,

        AT_KEYEXCHANGE,				// dwKeySpec
        0,					// dwDepth
        NULL,					// wszCriticalExtensions
        EXPIRATION_ONE_YEAR,			// dwExpiration
        OVERLAP_SIX_WEEKS,			// dwOverlap
        CERTTYPE_VERSION_NEXT + 1,		// Revision
        0,					// Minor Revision

	// dwEnrollmentFlags
	    CT_FLAG_AUTO_ENROLLMENT,

	// dwPrivateKeyFlags
	    0,

	// dwCertificateNameFlags
	    CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME |
	    CT_FLAG_SUBJECT_ALT_REQUIRE_DNS,

	CERTTYPE_MINIMAL_KEY,			// dwMinimalKeySize
	0,					// dwRASignature
	CERTTYPE_SCHEMA_VERSION_2,		// dwSchemaVersion
	L"1.31",				// wszOID
	NULL,					// wszSupersedeTemplates
	NULL,					// wszRAPolicy
	NULL,					// wszCertificatePolicy
	NULL,					// wszRAAppPolicy

	// wszCertificateAppPolicy
	    TEXT(szOID_PKIX_KP_SERVER_AUTH) L"\0"
	    TEXT(szOID_PKIX_KP_CLIENT_AUTH) L"\0",
    },
};

DWORD g_cDefaultCertTypes = ARRAYSIZE(g_aDefaultCertTypes);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\oidmgr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        oidmgr.h
//
// Contents:    Declaration of oidmgr.cpp
//
// History:     2-17-00 xiaohs  Created
//
//---------------------------------------------------------------------------
#ifndef __OIDMGR_H__
#define __OIDMGR_H__


//---------------------------------------------------------------------------
//
//  Constants
//
//---------------------------------------------------------------------------


#define OID_CONTAINER_PROP_OID          OID_PROP_OID
#define OID_CONTAINER_PROP_GUID         L"objectGUID"

#define wszOID_DOT                      L"."
#define wszOID_ENTERPRISE_ROOT          TEXT(szOID_ENTERPRISE_OID_ROOT)

//the GUID string is in the form of 3_Byte.3_Byte.3_Byte.3_Byte.3_Byte.1_Byte
#define DWORD_STRING_LENGTH             12
#define GUID_STRING_LENGTH              6 * (DWORD_STRING_LENGTH + 1)

//OID flags/types definition
#define CERT_OID_SETTABLE_FLAGS         0xFFFF0000

#define CERT_OID_MD5_HASH_SIZE			16
//the lenght of oid component that is part of the CN
#define CERT_OID_IDENTITY_LENGTH        16

#define	UPPER_BITS			            0xF0
#define	LOWER_BITS			            0x0F

#define OID_RANDOM_CREATION_TRIAL       50
//the number of attribute for the enterprise OID class
#define OID_ATTR_COUNT                  6

//we reserver the 1.1-1.500 as the default OIDs for certifcate types
#define OID_RESERVE_DEFAULT_ONE         1
#define OID_RESERVR_DEFAULT_TWO         500

//---------------------------------------------------------------------------
//
//  Data type defines
//
//---------------------------------------------------------------------------
#define OID_ATTR_OID                    0x01
#define OID_ATTR_TYPE                   0x02
#define OID_ATTR_DISPLAY_NAME           0x04
#define OID_ATTR_CPS                    0x08

#define OID_ATTR_ALL                    (OID_ATTR_OID | OID_ATTR_TYPE | OID_ATTR_DISPLAY_NAME | OID_ATTR_CPS)

typedef struct _ENT_OID_INFO
{
    DWORD       dwAttr;
    LPWSTR      pwszOID;
    DWORD       dwType;
    LPWSTR      pwszDisplayName;
    LPWSTR      pwszCPS;
}ENT_OID_INFO;


extern LPWSTR g_pwszEnterpriseRootOID;

//---------------------------------------------------------------------------
//
//  Function Prototypes
//
//---------------------------------------------------------------------------
HRESULT     I_CAOIDCreateNew(DWORD dwType, DWORD   dwFlag,   LPWSTR	*ppwszOID);

HRESULT     CAOIDRetrieveEnterpriseRoot(DWORD   dwFlag, LPWSTR  *ppwszOID);

HRESULT     CAOIDBuildOID(DWORD dwFlag, LPCWSTR  pwszEndOID, LPWSTR *ppwszOID);

HRESULT     I_CAOIDSetProperty(LPCWSTR pwszOID, DWORD   dwProperty, LPVOID  pPropValue);

HRESULT     I_CAOIDAdd(DWORD   dwType,  DWORD  dwFlag, LPCWSTR  pwszOID);

HRESULT
I_CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue);

HRESULT
I_CAOIDFreeProperty(
    IN LPVOID  pPropValue);




#endif //__OIDMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\oidmgr.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        oidmgr.cpp
//
// Contents:    DS OID management functions.
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <winldap.h>
#include <ntldap.h>
#include <cainfop.h>
#include <oidmgr.h>
#include <certca.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTCLIB_OIDMGR_CPP__


//the global critical section
CRITICAL_SECTION        g_csOidURL;
extern BOOL             g_fOidURL;
ULARGE_INTEGER          g_ftOidTime;
BOOL                    g_fFailedTime=FALSE;

//the # of seconds in which we will not re-find a DC
#define     CA_OID_MGR_FAIL_PERIOD              5
#define     FILETIME_TICKS_PER_SECOND           10000000

//the cache of the enterprise root oid
LPWSTR   g_pwszEnterpriseRootOID=NULL;  

static WCHAR * s_wszOIDContainerSearch = L"(&(CN=OID)(objectCategory=" wszDSOIDCLASSNAME L"))";
static WCHAR * s_wszOIDContainerDN = L"CN=OID,CN=Public Key Services,CN=Services,";
 
WCHAR *g_awszOIDContainerAttrs[] = {OID_CONTAINER_PROP_OID,
                                    OID_CONTAINER_PROP_GUID,
                                    NULL};

//---------------------------------------------------------------------------
//
//  myTimeOutRobustBind
//
//	We will not attempt a LDAP bind if we have failed in the past pre-defined
//	seconds.
//
//---------------------------------------------------------------------------
HRESULT
myTimeOutRobustLdapBind(OUT LDAP **ppldap)
{
	HRESULT				hr=E_FAIL;
    FILETIME            ftTime;
	
    //the critical section has to be initalized
    if (!g_fOidURL)
	    return(HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED));

    EnterCriticalSection(&g_csOidURL);

    //check if the previous failure has happened with 10 seconds
    if(TRUE == g_fFailedTime)
    {
        //get the current time
        GetSystemTimeAsFileTime(&ftTime);

        g_ftOidTime.QuadPart += FILETIME_TICKS_PER_SECOND * CA_OID_MGR_FAIL_PERIOD;

        if(0 > CompareFileTime(&ftTime, (LPFILETIME)&g_ftOidTime))
        {
            g_ftOidTime.QuadPart -= FILETIME_TICKS_PER_SECOND * CA_OID_MGR_FAIL_PERIOD;

            hr=HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);

            _JumpError2(hr , error, "myDoesDSExist", HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));
        }
        else
        {
            //clear up the error recording
            g_fFailedTime=FALSE;
        }
    }

    //retrieve the ldap handle and the config string
    hr = myDoesDSExist(TRUE);
    _JumpIfError2(hr, error, "myDoesDSExist", HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));

    hr = myRobustLdapBindEx(
			0,		// dwFlags1
			RLBF_REQUIRE_SECURE_LDAP, // dwFlags2
			LDAP_VERSION2,	// uVersion
			NULL,		// pwszDomainName
			ppldap,
			NULL);		// ppwszForestDNSName
    _JumpIfError(hr, error, "myRobustLdapBindEx");

error:
	//remember the time if we failed due to lack of domain
    if((S_OK != hr) && (FALSE==g_fFailedTime))
    {
        GetSystemTimeAsFileTime((LPFILETIME)&(g_ftOidTime));
        g_fFailedTime=TRUE;
    }

    LeaveCriticalSection(&g_csOidURL);

	return hr;
}

//---------------------------------------------------------------------------
//
//  CAOIDIsValidRootOID
//
//		
//		Pre .Net RC1, the enterprise root OID is derived from the GUID of CN=OID
//	container in the format of DWORD.DWORD.DWORD.DWORD.  The new Son of RFC2459 
//	defines a mandatory maximum length to the element of an OID of 2^28.
//
//		The new format will be xxx.xxx.xxx.xxx.xxx.xxx, each element is a 3 byte
//	date from the GUID (16 bytes).  The last element is one byte only.
//
//---------------------------------------------------------------------------
BOOL	CAOIDIsValidRootOID(LPWSTR	pwszOID)
{
	BOOL	fValid=FALSE;
	LPWSTR	pwsz=NULL;
	DWORD	dwCount=0;

	if(NULL == pwszOID)
		goto error;

	pwsz=pwszOID;

	while(L'\0' != (*pwsz))
	{
		if(L'.' == (*pwsz))
		{
			dwCount++;
		}

		pwsz++;
	}


	if(14 != dwCount)
		goto error;

	fValid=TRUE;


error:

	return fValid;
}

//---------------------------------------------------------------------------
//
//  CAOIDAllocAndCopy
//
//---------------------------------------------------------------------------
HRESULT CAOIDAllocAndCopy(LPWSTR    pwszSrc,
                          LPWSTR    *ppwszDest)
{
    if((NULL==ppwszDest) || (NULL==pwszSrc))
        return E_INVALIDARG;

    *ppwszDest=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * (wcslen(pwszSrc) + 1));
    if(NULL==(*ppwszDest))
        return E_OUTOFMEMORY;

    wcscpy(*ppwszDest, pwszSrc);
    return S_OK;
}

//---------------------------------------------------------------------------
//
//  CAOIDGetRandom
//
//  We build a random x1.x2 string.  X is a 32 bit unsigned integer.  x1 > 1
//  and x2 > 500.
//---------------------------------------------------------------------------
HRESULT CAOIDGetRandom(LPWSTR   *ppwszRandom)
{
    HRESULT         hr=E_FAIL;
    DWORD           dwRandom1=0;
    DWORD           dwRandom2=0;
    DWORD           cbData=sizeof(DWORD);
    WCHAR           wszRandom1[DWORD_STRING_LENGTH];
    WCHAR           wszRandom2[DWORD_STRING_LENGTH];

    HCRYPTPROV      hProv=NULL;
    
    //there is a bug in cryptAcquireContextW that if container is NULL, provider
    //can not be ansi.
	if(!CryptAcquireContextA(
                &hProv,
                NULL,
                MS_DEF_PROV_A,
                PROV_RSA_FULL,
                CRYPT_VERIFYCONTEXT))
    {
        hr= myHLastError();
        _JumpError(hr, error, "CryptAcquireContextA");
    }

	//accoring to RFC2459 which bounds the OID size,
	//elements in an arc must be between 0->2^28. 

	if(cbData > 3)
		cbData=3;

	if(!CryptGenRandom(hProv, cbData, (BYTE *)&dwRandom1))
    {
        hr= myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }

	if(!CryptGenRandom(hProv, cbData, (BYTE *)&dwRandom2))
    {
        hr= myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }

    if(dwRandom1 <= OID_RESERVE_DEFAULT_ONE)
        dwRandom1 +=OID_RESERVE_DEFAULT_ONE;
    
    if(dwRandom2 <= OID_RESERVR_DEFAULT_TWO)
        dwRandom2 += OID_RESERVR_DEFAULT_TWO;

    wszRandom1[0]=L'\0';
    wsprintf(wszRandom1, L"%lu", dwRandom1);
    wszRandom2[0]=L'\0';
    wsprintf(wszRandom2, L"%lu", dwRandom2);

    *ppwszRandom=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
        (wcslen(wszRandom1) + wcslen(wszOID_DOT) + wcslen(wszRandom2) + 1));

    if(NULL==(*ppwszRandom))
    {
        hr= E_OUTOFMEMORY;
        _JumpError(hr, error, "CryptGenRandom");
    }

    wcscpy(*ppwszRandom, wszRandom1);
    wcscat(*ppwszRandom, wszOID_DOT);
    wcscat(*ppwszRandom, wszRandom2);

    hr=S_OK;

error:
    
    if(hProv)
        CryptReleaseContext(hProv, 0);

    return hr;
}

//----------------------------------------------------------------------------------
//
//  CAOIDMapGUIDToOID
//
//  GUID (16 byte) string is in the form of 3_Byte.3_Byte.3_Byte.3_Byte.3_Byte.1_Byte
//  12 characters are sufficient to present a 2^32 value.
//----------------------------------------------------------------------------------
HRESULT     CAOIDMapGUIDToOID(LDAP_BERVAL *pGuidVal, LPWSTR   *ppwszGUID)
{
    HRESULT     hr=E_INVALIDARG;
    DWORD       iIndex=0;
    WCHAR       wszString[DWORD_STRING_LENGTH];
	DWORD		dwData=0;
	BYTE		*pbData=NULL;

    *ppwszGUID=NULL;

	//a GUID should be 16 byte
    if(16 != (pGuidVal->bv_len))
	    _JumpError(hr, error, "ArgumentCheck");
    
    *ppwszGUID=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * GUID_STRING_LENGTH);
    if(NULL==(*ppwszGUID))
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }

	pbData=(BYTE *)(pGuidVal->bv_val);

    for(iIndex=0; iIndex < 6; iIndex++)
    {
        wszString[0]=L'\0';
		dwData=0;

		//the 5th index (6th element) is only one byte 15th index (16th) bypte
		if(iIndex == 5)
		{
			dwData=(DWORD)(pbData[iIndex * 3]);
		}
		else
		{
			dwData=(((DWORD)(pbData[iIndex * 3])) << 16) + 
				   (((DWORD)(pbData[iIndex * 3 + 1])) << 8) + 
					((DWORD)(pbData[iIndex * 3 + 2]));
		}

        wsprintf(wszString, L"%lu", dwData);
        
        if(0==iIndex)
        {
            wcscpy(*ppwszGUID, wszString);
        }
        else
        {
            wcscat(*ppwszGUID, wszOID_DOT);
            wcscat(*ppwszGUID, wszString);
        }
    }

    hr = S_OK;

error:
    return hr;
    
}
//--------------------------------------------------------------------------
//
//	  FormatMessageUnicode
//
//--------------------------------------------------------------------------
HRESULT	FormatMessageUnicode(LPWSTR	*ppwszFormat,LPWSTR pwszString,...)
{
	va_list		argList;
	DWORD		cbMsg=0;

    // format message into requested buffer
    va_start(argList, pwszString);

    cbMsg = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        pwszString,
        0,                  // dwMessageId
        0,                  // dwLanguageId
        (LPWSTR) (ppwszFormat),
        0,                  // minimum size to allocate
        &argList);

    va_end(argList);

	if(0 != cbMsg)
	    return S_OK;

	return E_INVALIDARG;
}

//---------------------------------------------------------------------------
//
//  DoesOIDExist
//
//
//---------------------------------------------------------------------------
BOOL    DoesOIDExist(LDAP       *pld, 
                     LPWSTR     bstrConfig, 
                     LPCWSTR     pwszOID)
{
    BOOL                fExit=FALSE;
    struct l_timeval    timeout;
    ULONG               ldaperr=0;
    DWORD               dwCount=0;
    LPWSTR              awszAttr[2];

    CERTSTR             bstrDN = NULL;
    LDAPMessage         *SearchResult = NULL;
    LPWSTR              pwszFilter = NULL;

    if(NULL==pwszOID)
        goto error;

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszOIDContainerDN));
    if(NULL == bstrDN)
        goto error;

    wcscpy(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, bstrConfig);

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    awszAttr[0]=OID_PROP_OID;
    awszAttr[1]=NULL;
    
    if(S_OK != FormatMessageUnicode(&pwszFilter, L"(%1!s!=%2!s!)",
                                    OID_PROP_OID, pwszOID))
        goto error;

    __try
    {
	    ldaperr = ldap_search_stW(
                  pld, 
		          (LPWSTR)bstrDN,
		          LDAP_SCOPE_ONELEVEL,
		          pwszFilter,
		          awszAttr,
		          0,
                  &timeout,
		          &SearchResult);

        if(LDAP_SUCCESS != ldaperr)
            goto error;

        dwCount = ldap_count_entries(pld, SearchResult);

        if(0 != dwCount)
            fExit=TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
error:
    if(pwszFilter)
        LocalFree((HLOCAL)pwszFilter);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if(bstrDN)
        CertFreeString(bstrDN);

    return fExit;
}
//---------------------------------------------------------------------------
//
// CAOIDUpdateDS
//
//
//---------------------------------------------------------------------------
HRESULT     CAOIDUpdateDS(LDAP          *pld, 
                          LPWSTR        pwszConfig, 
                          ENT_OID_INFO  *pOidInfo)
{
    HRESULT         hr=E_INVALIDARG;
    BOOL            fNew=FALSE;
    ULONG           ldaperr=0;
    LDAPMod         modObjectClass,
                    modCN,
                    modType,
                    modOID,
                    modDisplayName,
                    modCPS;
    LDAPMod         *mods[OID_ATTR_COUNT + 1];
    DWORD           cMod=0;
    WCHAR           wszType[DWORD_STRING_LENGTH];
    LPWSTR          awszObjectClass[3],
                    awszCN[2],
                    awszType[2],
                    awszOID[2],
                    awszDisplayName[2],
                    awszCPS[2];
    CHAR            sdBerValue[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION | 
                                                  OWNER_SECURITY_INFORMATION | 
                                                  GROUP_SECURITY_INFORMATION};
    LDAPControl     se_info_control =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValue
                            },
                            TRUE
                        };

    LDAPControl     permissive_modify_control =
                        {
                            LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                            {
                                0, NULL
                            },
                            FALSE
                        };

    PLDAPControl    server_controls[3] =
                        {
                            &se_info_control,
                            &permissive_modify_control,
                            NULL
                        };
    CHAR            sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION};
    LDAPControl     se_info_control_dacl_only =
                        {
                            LDAP_SERVER_SD_FLAGS_OID_W,
                            {
                                5, sdBerValueDaclOnly
                            },
                            TRUE
                        };
    PLDAPControl    server_controls_dacl_only[3] =
                        {
                            &se_info_control_dacl_only,
                            &permissive_modify_control,
                            NULL
                        };



    CERTSTR         bstrDN = NULL;
    LPWSTR          pwszCN = NULL;

    if(NULL== (pOidInfo->pwszOID))
        _JumpError(hr , error, "ArgumentCheck");

    //if we are changing the OID value, we are creating a new oid
    fNew = OID_ATTR_OID & (pOidInfo->dwAttr);

    //set up the base DN
    if(S_OK != (hr = myOIDHashOIDToString(pOidInfo->pwszOID,  &pwszCN)))
        _JumpError(hr , error, "myOIDHashOIDToString");

    bstrDN = CertAllocStringLen(NULL, wcslen(pwszConfig) + wcslen(s_wszOIDContainerDN)+wcslen(pwszCN)+4);
    if(bstrDN == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrDN, L"CN=");
    wcscat(bstrDN, pwszCN);
    wcscat(bstrDN, L",");
    wcscat(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, pwszConfig);

    //set up all the mods
    modObjectClass.mod_op = LDAP_MOD_REPLACE;
    modObjectClass.mod_type = L"objectclass";
    modObjectClass.mod_values = awszObjectClass;
    awszObjectClass[0] = wszDSTOPCLASSNAME;
    awszObjectClass[1] = wszDSOIDCLASSNAME;
    awszObjectClass[2] = NULL;
    mods[cMod++] = &modObjectClass;

    modCN.mod_op = LDAP_MOD_REPLACE;
    modCN.mod_type =  L"cn";
    modCN.mod_values = awszCN;
    awszCN[0] = pwszCN;
    awszCN[1] = NULL;
    mods[cMod++] = &modCN;

    modOID.mod_op = LDAP_MOD_REPLACE;
    modOID.mod_type = OID_PROP_OID;
    modOID.mod_values = awszOID;
    awszOID[0] = pOidInfo->pwszOID;
    awszOID[1] = NULL;
    mods[cMod++] = &modOID;

    if(OID_ATTR_DISPLAY_NAME & (pOidInfo->dwAttr))
    {
        modDisplayName.mod_op = LDAP_MOD_REPLACE;
        modDisplayName.mod_type = OID_PROP_DISPLAY_NAME;

        if(pOidInfo->pwszDisplayName)
        {
            modDisplayName.mod_values = awszDisplayName;
            awszDisplayName[0] = pOidInfo->pwszDisplayName;
            awszDisplayName[1] = NULL;
        }
        else
            modDisplayName.mod_values = NULL;

	    if(!fNew)
        	mods[cMod++] = &modDisplayName;
    }

    if(OID_ATTR_CPS & (pOidInfo->dwAttr))
    {
        modCPS.mod_op = LDAP_MOD_REPLACE;
        modCPS.mod_type = OID_PROP_CPS;

        if(pOidInfo->pwszCPS)
        {
            modCPS.mod_values = awszCPS;
            awszCPS[0] = pOidInfo->pwszCPS;
            awszCPS[1] = NULL;
        }
        else
            modCPS.mod_values = NULL;

	    if(!fNew)
        	mods[cMod++] = &modCPS;
    }

    if(OID_ATTR_TYPE & (pOidInfo->dwAttr))
    {
        modType.mod_op = LDAP_MOD_REPLACE;
        modType.mod_type = OID_PROP_TYPE;
        modType.mod_values = awszType;
        awszType[0] = wszType;
        awszType[1] = NULL;
        wsprintf(wszType, L"%d", pOidInfo->dwType);
        mods[cMod++] = &modType;
    }

    mods[cMod++]=NULL;

	//update the DS 
    __try
    {
        if(fNew)
        {
            ldaperr = ldap_add_ext_sW(pld, bstrDN, mods, server_controls, NULL);
		    _PrintIfError(ldaperr, "ldap_add_s");
        }
        else
        {
            ldaperr = ldap_modify_ext_sW(
                  pld, 
                  bstrDN,
                  &mods[2],
                  server_controls_dacl_only,
                  NULL);  // skip past objectClass and cn

            if(LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
                ldaperr = LDAP_SUCCESS;

		    _PrintIfError(ldaperr, "ldap_modify_ext_sW");
        }

        if ((LDAP_SUCCESS != ldaperr) && (LDAP_ALREADY_EXISTS != ldaperr))
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
	    _JumpError(ldaperr, error, fNew? "ldap_add_s" : "ldap_modify_sW");
        }

        hr=S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if(pwszCN)
        LocalFree(pwszCN);

    if(bstrDN)
        CertFreeString(bstrDN);

    return hr;
}

//---------------------------------------------------------------------------
//
//  CAOIDRetrieveEnterpriseRootWithConfig
//
//  Get the enterpriseRoot from the displayName attribute of the container.
//  If the attribute is missing, add the one with GUID of the container.
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT
CAOIDRetrieveEnterpriseRootWithConfig(
    LDAP *pld,
    LPWSTR pwszConfig,
    DWORD, // dwFlag
    LPWSTR *ppwszOID)
{
    HRESULT             hr=E_INVALIDARG;
    struct l_timeval    timeout;
    ULONG               ldaperr=0;
    DWORD               dwCount=0;
    LDAPMessage         *Entry=NULL;
    LDAPMod             *mods[2];
    LDAPMod             modOIDName;
    LPWSTR              valOIDName[2];
    CHAR                sdBerValueDaclOnly[] = {0x30, 0x03, 0x02, 0x01,  DACL_SECURITY_INFORMATION};
    LDAPControl         se_info_control_dacl_only =
                            {
                                LDAP_SERVER_SD_FLAGS_OID_W,
                                {
                                    5, sdBerValueDaclOnly
                                },
                                TRUE
                            };
    LDAPControl         permissive_modify_control =
                            {
                                LDAP_SERVER_PERMISSIVE_MODIFY_OID_W,
                                {
                                    0, NULL
                                },
                                FALSE
                            };
    PLDAPControl        server_controls_dacl_only[3] =
                            {
                                &se_info_control_dacl_only,
                                &permissive_modify_control,
                                NULL
                            };


    CERTSTR             bstrOIDContainer = NULL;
    LDAPMessage         *SearchResult = NULL;
    WCHAR               **wszLdapVal = NULL;
    LDAP_BERVAL         **pGuidVal = NULL;
    LPWSTR              pwszGUID = NULL;

    __try
    {

        if(NULL==ppwszOID)
            _JumpError(hr , error, "ArgumentCheck");

        *ppwszOID=NULL;

        //retrive the displayName attribute of the container if available
        bstrOIDContainer = CertAllocStringLen(NULL, wcslen(pwszConfig) + wcslen(s_wszOIDContainerDN));
        if(NULL == bstrOIDContainer)
        {
            hr = E_OUTOFMEMORY;
	        _JumpError(hr, error, "CertAllocStringLen");
        }
    
        wcscpy(bstrOIDContainer, s_wszOIDContainerDN);
        wcscat(bstrOIDContainer, pwszConfig);

        timeout.tv_sec = csecLDAPTIMEOUT;
        timeout.tv_usec = 0;
    
	    ldaperr = ldap_search_stW(
			  pld, 
		          (LPWSTR)bstrOIDContainer,
		          LDAP_SCOPE_BASE,
		          s_wszOIDContainerSearch,
		          g_awszOIDContainerAttrs,
		          0,
			  &timeout,
		          &SearchResult);

        if(LDAP_SUCCESS != ldaperr)
        {
	    hr = myHLdapError(pld, ldaperr, NULL);
	    _JumpError(hr, error, "ldap_search_stW");
        }

        dwCount = ldap_count_entries(pld, SearchResult);

        //we should only find one container
        if((1 != dwCount) || (NULL == (Entry = ldap_first_entry(pld, SearchResult))))
	    {
	        // No entries were found.
		hr = myHLdapError(pld, LDAP_NO_SUCH_OBJECT, NULL);
	        _JumpError(hr, error, "ldap_search_stW");
	    }

        wszLdapVal = ldap_get_values(pld, Entry, OID_CONTAINER_PROP_OID);

        //make sure the displayName is a valud enterprise OID
        if(wszLdapVal && wszLdapVal[0])
        {
			if(CAOIDIsValidRootOID(wszLdapVal[0]))
			{
				hr=CAOIDAllocAndCopy(wszLdapVal[0], ppwszOID);

				//cache the enterprise root
				if((S_OK == hr) && (g_fOidURL))
				{
					EnterCriticalSection(&g_csOidURL);

					CAOIDAllocAndCopy(*ppwszOID, &g_pwszEnterpriseRootOID);

					LeaveCriticalSection(&g_csOidURL);
				}

				goto error;
			}
        }

        //no displayName is present or valid, we have to derive the displayName
        //from the GUID of the container
        pGuidVal = ldap_get_values_len(pld, Entry, OID_CONTAINER_PROP_GUID);

        if((NULL==pGuidVal) || (NULL==pGuidVal[0]))
        {
	    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
            _JumpError(hr, error, "getGUIDFromDS");
        }

        if(S_OK != (hr=CAOIDMapGUIDToOID(pGuidVal[0], &pwszGUID)))
            _JumpError(hr, error, "CAOIDMapGUIDToOID");

        //contantenate the strings
        *ppwszOID=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
                (wcslen(wszOID_ENTERPRISE_ROOT) + wcslen(wszOID_DOT) + wcslen(pwszGUID) + 1));

        if(NULL==(*ppwszOID))
        {
            hr=E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        wcscpy(*ppwszOID, wszOID_ENTERPRISE_ROOT);
        wcscat(*ppwszOID, wszOID_DOT);
        wcscat(*ppwszOID, pwszGUID);

        //cache the newly created displayName to the DS
        //no need to check for error since this is just a performance enhancement
        valOIDName[0]=*ppwszOID;
        valOIDName[1]=NULL;

        modOIDName.mod_op = LDAP_MOD_REPLACE;
        modOIDName.mod_type = OID_CONTAINER_PROP_OID;
        modOIDName.mod_values = valOIDName;

        mods[0]=&modOIDName;
        mods[1]=NULL;

        ldap_modify_ext_sW(
                pld, 
                bstrOIDContainer,
                mods,
                server_controls_dacl_only,
                NULL); 

        //cache the oid root in memory

		if (g_fOidURL)
		{
			EnterCriticalSection(&g_csOidURL);

			CAOIDAllocAndCopy(*ppwszOID, &g_pwszEnterpriseRootOID);

			LeaveCriticalSection(&g_csOidURL);
		}

        hr = S_OK;

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:

    if(pwszGUID)
        LocalFree(pwszGUID);

    if(pGuidVal)
        ldap_value_free_len(pGuidVal);

    if(wszLdapVal)
        ldap_value_free(wszLdapVal);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if (bstrOIDContainer)
        CertFreeString(bstrOIDContainer);

    return hr;
}


//---------------------------------------------------------------------------
//
//  CAOIDRetrieveEnterpriseRoot
//
//  Get the enterpriseRoot from the displayName attribute of the container.
//  If the attribute is missing, add the one with GUID of the container.
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT     CAOIDRetrieveEnterpriseRoot(DWORD   dwFlag, LPWSTR  *ppwszOID)
{
    HRESULT             hr=E_INVALIDARG;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;


    if(NULL==ppwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    //retrieve the memory cache if available
	if (g_fOidURL)
	{

		EnterCriticalSection(&g_csOidURL);

		if(g_pwszEnterpriseRootOID)
		{
			hr=CAOIDAllocAndCopy(g_pwszEnterpriseRootOID, ppwszOID);

			LeaveCriticalSection(&g_csOidURL);

			goto error;
		}

		LeaveCriticalSection(&g_csOidURL);
	}


    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");


	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}


    hr = CAOIDRetrieveEnterpriseRootWithConfig(pld, bstrConfig,
                                            dwFlag, ppwszOID);
error:
    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}

//---------------------------------------------------------------------------
//
//  CAOIDBuildOIDWithRoot
//
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT
CAOIDBuildOIDWithRoot(
    DWORD, // dwFlag
    LPCWSTR pwszRoot,
    LPCWSTR  pwszEndOID,
    LPWSTR *ppwszOID)
{
    HRESULT     hr=E_INVALIDARG;

    if(NULL==pwszRoot)
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    *ppwszOID=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
            (wcslen(pwszRoot) + wcslen(wszOID_DOT) + wcslen(pwszEndOID) + 1));

    if(NULL==(*ppwszOID))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr , error, "LocalAlloc");
    }

    wcscpy(*ppwszOID, pwszRoot);
    wcscat(*ppwszOID, wszOID_DOT);
    wcscat(*ppwszOID, pwszEndOID);

    hr= S_OK;

error:

    return hr;
}


//---------------------------------------------------------------------------
//
//  CAOIDBuildOID
//
//
//  Free memory via LocalFree().
//---------------------------------------------------------------------------
HRESULT     CAOIDBuildOID(DWORD dwFlag, LPCWSTR  pwszEndOID, LPWSTR *ppwszOID)
{
    HRESULT     hr=E_INVALIDARG;

    LPWSTR      pwszRoot=NULL;

    if((NULL==ppwszOID) || (NULL==pwszEndOID))
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    if(S_OK != (hr=CAOIDRetrieveEnterpriseRoot(0, &pwszRoot)))
         _JumpError(hr , error, "RetrieveEnterpriseRoot");

    hr= CAOIDBuildOIDWithRoot(dwFlag, pwszRoot, pwszEndOID, ppwszOID);

error:

    if(pwszRoot)
        LocalFree(pwszRoot);

    return hr;
}

//------------------------------------------------------------------------
//	   Convert the byte to its Hex presentation.
//
//
//------------------------------------------------------------------------
ULONG	ByteToHex(BYTE	byte,	LPWSTR	wszZero, LPWSTR wszA)
{
	ULONG	uValue=0;

	if(((ULONG)byte)<=9)
	{
		uValue=((ULONG)byte)+ULONG(*wszZero);	
	}
	else
	{
		uValue=(ULONG)byte-10+ULONG(*wszA);

	}

	return uValue;

}
//--------------------------------------------------------------------------
//
//	  ConvertByteToWstr
//
//		If fSpace is TRUE, we add a space every 2 bytes.
//--------------------------------------------------------------------------
HRESULT ConvertByteToWstr(BYTE			*pbData, 
						  DWORD			cbData, 
						  LPWSTR		*ppwsz)
{
	HRESULT hr=E_INVALIDARG;
	DWORD	dwBufferSize=0;
	DWORD	dwBufferIndex=0;
	DWORD	dwEncodedIndex=0;

	LPWSTR	pwszZero=L"0";
	LPWSTR	pwszA=L"A";

	if(!pbData || !ppwsz)
        _JumpError(hr , error, "ArgumentCheck");

	//calculate the memory needed, in bytes
	//we need 2 wchars per byte, along with the NULL terminator
	dwBufferSize=sizeof(WCHAR)*(cbData*2+1);

	*ppwsz=(LPWSTR)LocalAlloc(LPTR, dwBufferSize);

	if(NULL==(*ppwsz))
    {
        hr=E_OUTOFMEMORY;
        _JumpError(hr , error, "LocalAlloc");
    }

	dwBufferIndex=0;

	//format the wchar buffer one byte at a time
	for(dwEncodedIndex=0; dwEncodedIndex<cbData; dwEncodedIndex++)
	{

		//format the higher 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 (pbData[dwEncodedIndex]&UPPER_BITS)>>4,
			 pwszZero, pwszA);

		dwBufferIndex++;

		//format the lower 4 bits
		(*ppwsz)[dwBufferIndex]=(WCHAR)ByteToHex(
			 pbData[dwEncodedIndex]&LOWER_BITS,
			 pwszZero, pwszA);

		dwBufferIndex++;

	}

	//add the NULL terminator to the string
	(*ppwsz)[dwBufferIndex]=L'\0';

	hr=S_OK;

error:

    return hr;

}

//---------------------------------------------------------------------------
// myOIDHashOIDToString
//
//  Map the OID to a hash string in the format of oid.hash. 
//---------------------------------------------------------------------------

HRESULT
myOIDHashOIDToString(
    IN WCHAR const *pwszOID,
    OUT WCHAR **ppwsz)
{
    HRESULT     hr=E_INVALIDARG;
    BYTE	pbHash[CERT_OID_MD5_HASH_SIZE];
    DWORD	cbData=CERT_OID_MD5_HASH_SIZE;
    LPCWSTR     pwszChar=NULL;
    DWORD       dwIDLength=CERT_OID_IDENTITY_LENGTH;

    LPWSTR      pwszHash=NULL;

    if((NULL==pwszOID) || (NULL==ppwsz))
        _JumpError(hr , error, "ArgumentCheck");

    *ppwsz=NULL;

    hr = myVerifyObjId(pwszOID);
    _JumpIfErrorStr2(hr, error, "myVerifyObjId", pwszOID, E_INVALIDARG);

    if(!CryptHashCertificate(
			NULL,
			CALG_MD5,
			0,
			(BYTE * )pwszOID,
			sizeof(WCHAR) * wcslen(pwszOID),
			pbHash,
			&cbData))
    {
        hr= myHLastError();
        _JumpError(hr , error, "CryptHashCertificate");
    }

    //convert the hash to a string
    if(S_OK != (hr=ConvertByteToWstr(pbHash, CERT_OID_MD5_HASH_SIZE, &pwszHash)))
        _JumpError(hr , error, "ConvertByteToWstr");

    //find the last component of the oid.  Take the first 16 characters
    pwszChar=wcsrchr(pwszOID, L'.');

    if(NULL==pwszChar)
        pwszChar=pwszOID;
    else
	pwszChar++;

    if(dwIDLength > wcslen(pwszChar))
        dwIDLength=wcslen(pwszChar);

    //the result string is oid.hash
    *ppwsz=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * 
        (dwIDLength + wcslen(pwszHash) + wcslen(wszOID_DOT) +1));
    if(NULL==*ppwsz)
    {
        hr= E_OUTOFMEMORY;
        _JumpError(hr , error, "LocalAlloc");
    }

    wcsncpy(*ppwsz, pwszChar, dwIDLength);
    (*ppwsz)[dwIDLength]=L'\0';
    wcscat(*ppwsz, wszOID_DOT);
    wcscat(*ppwsz, pwszHash);
    
    hr=S_OK;

error:

    if(pwszHash)
        LocalFree(pwszHash);
    
    return hr;
}


//---------------------------------------------------------------------------
// I_CAOIDCreateNew
// Create a new OID based on the enterprise base
//
// Returns S_OK if successful.
//---------------------------------------------------------------------------
HRESULT
I_CAOIDCreateNew(
    DWORD dwType,
    DWORD, // dwFlag
    LPWSTR *ppwszOID)
{
    HRESULT             hr=E_INVALIDARG;
    ENT_OID_INFO        oidInfo;
    DWORD               iIndex=0;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    LPWSTR              pwszRoot = NULL;
    LPWSTR              pwszNewOID = NULL;
    LPWSTR              pwszRandom = NULL;

    if(NULL==ppwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    *ppwszOID=NULL;

    //retrieve the root oid if available
	if (g_fOidURL)
	{
		EnterCriticalSection(&g_csOidURL);

		if(g_pwszEnterpriseRootOID)
		{
			if(S_OK != (hr=CAOIDAllocAndCopy(g_pwszEnterpriseRootOID, &pwszRoot)))
			{
				LeaveCriticalSection(&g_csOidURL);
				goto error;
			}
		}

		LeaveCriticalSection(&g_csOidURL);
	}


    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");


	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    if(NULL==pwszRoot)
    {
        if(S_OK != (hr = CAOIDRetrieveEnterpriseRootWithConfig(pld, bstrConfig, 0, &pwszRoot)))
            _JumpError(hr , error, "CAOIDRetrieveEnterpriseRootWithConfig");
    }

    //we try to generate a random x1.x2 oid.  x > 1 and x2 > 500
    for(iIndex=0; iIndex < OID_RANDOM_CREATION_TRIAL; iIndex++)
    {
        if(S_OK != (hr = CAOIDGetRandom(&pwszRandom)))
            _JumpError(hr , error, "CAOIDGetRandom");

        if(S_OK != (hr = CAOIDBuildOIDWithRoot(0, pwszRoot, pwszRandom, &pwszNewOID)))
            _JumpError(hr , error, "CAOIDBuildOIDWithRoot");

        if(!DoesOIDExist(pld, bstrConfig, pwszNewOID))
            break;

        LocalFree(pwszRandom);
        pwszRandom=NULL;

        LocalFree(pwszNewOID);
        pwszNewOID=NULL;
    }

    if(iIndex == OID_RANDOM_CREATION_TRIAL)
    {
        hr=E_FAIL;
        _JumpError(hr , error, "CAOIDGetRandom");
    }

    //update the oid information on the DS
    memset(&oidInfo, 0, sizeof(ENT_OID_INFO));
    oidInfo.dwAttr=OID_ATTR_ALL;
    oidInfo.dwType=dwType;
    oidInfo.pwszOID=pwszNewOID;

    if(S_OK != (hr=CAOIDUpdateDS(pld, bstrConfig, &oidInfo)))
        _JumpError(hr , error, "CAOIDUpdateDS");

    *ppwszOID=pwszNewOID;
    pwszNewOID=NULL;

    hr=S_OK;

error:
    if(pwszRandom)
        LocalFree(pwszRandom);

    if(pwszNewOID)
        LocalFree(pwszNewOID);

    if(pwszRoot)
        LocalFree(pwszRoot);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}


//---------------------------------------------------------------------------
//
// CAOIDCreateNew
//
//---------------------------------------------------------------------------
HRESULT
CAOIDCreateNew(
    IN  DWORD   dwType,
    IN	DWORD   dwFlag,
    OUT LPWSTR	*ppwszOID)
{
    return I_CAOIDCreateNew(dwType, dwFlag, ppwszOID);
}

//---------------------------------------------------------------------------
// I_CAOIDSetProperty
// Set a property on an oid.  
//
//
// Returns S_OK if successful.
//---------------------------------------------------------------------------
HRESULT
I_CAOIDSetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    IN  LPVOID  pPropValue)
{
    HRESULT             hr=E_INVALIDARG;
    ENT_OID_INFO        oidInfo;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;


    if(NULL==pwszOID)
        _JumpError(hr , error, "ArgumentCheck");


    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //make sure the OID exist on the DS
    if(!DoesOIDExist(pld, bstrConfig, pwszOID))
    {
        hr=NTE_NOT_FOUND;
        _JumpErrorStr(hr, error, "DoesOIDExist", pwszOID);
    }
    
    //update the oid information on the DS
    memset(&oidInfo, 0, sizeof(ENT_OID_INFO));

    oidInfo.pwszOID=(LPWSTR)pwszOID;
    switch(dwProperty)
    {
        case CERT_OID_PROPERTY_DISPLAY_NAME:
                oidInfo.dwAttr = OID_ATTR_DISPLAY_NAME;
                oidInfo.pwszDisplayName=(LPWSTR)pPropValue;
            break;
        case CERT_OID_PROPERTY_CPS:
                oidInfo.dwAttr = OID_ATTR_CPS;
                oidInfo.pwszCPS=(LPWSTR)pPropValue;
           break;
        default:
                hr=E_INVALIDARG;
                _JumpError(hr , error, "ArgumentCheck");
    }
        
    hr=CAOIDUpdateDS(pld, bstrConfig, &oidInfo);

error:

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}

//---------------------------------------------------------------------------
//
// CAOIDSetProperty
//
//---------------------------------------------------------------------------
HRESULT
CAOIDSetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    IN  LPVOID  pPropValue)
{
    return I_CAOIDSetProperty(pwszOID, dwProperty, pPropValue);
}


//---------------------------------------------------------------------------
// I_CAOIDAdd
//
// Returns S_OK if successful.
// Returns CRYPT_E_EXISTS if the OID alreay exits in the DS repository
//---------------------------------------------------------------------------
HRESULT
I_CAOIDAdd(
    IN	DWORD       dwType,
    IN  DWORD,      // dwFlag
    IN  LPCWSTR	    pwszOID)
{
    HRESULT             hr=E_INVALIDARG;
    ENT_OID_INFO        oidInfo;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;


    if(NULL==pwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //make sure the OID does not exist on the DS
    if(DoesOIDExist(pld, bstrConfig, pwszOID))
    {
        hr=CRYPT_E_EXISTS;
        _JumpErrorStr(hr, error, "OID Exists", pwszOID);
    }

    //update the oid information on the DS
    memset(&oidInfo, 0, sizeof(ENT_OID_INFO));
    oidInfo.dwAttr=OID_ATTR_ALL;
    oidInfo.dwType=dwType;
    oidInfo.pwszOID=(LPWSTR)pwszOID;

    hr=CAOIDUpdateDS(pld, bstrConfig, &oidInfo);

error:

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}


//---------------------------------------------------------------------------
// CAOIDAdd
//
// Returns S_OK if successful.
// Returns CRYPT_E_EXISTS if the OID alreay exits in the DS repository
//---------------------------------------------------------------------------
HRESULT
CAOIDAdd(
    IN	DWORD       dwType,
    IN  DWORD       dwFlag,
    IN  LPCWSTR	    pwszOID)
{
    return I_CAOIDAdd(dwType, dwFlag, pwszOID);
}

//---------------------------------------------------------------------------
//
// I_CAOIDDelete
//
//---------------------------------------------------------------------------
HRESULT
I_CAOIDDelete(
    IN LPCWSTR	pwszOID)
{

    HRESULT             hr=E_INVALIDARG;
    ULONG               ldaperr=0;

    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    CERTSTR             bstrDN = NULL;
    LPWSTR              pwszCN = NULL;
    

    if(NULL==pwszOID)
        _JumpError(hr , error, "ArgumentCheck");

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //set up the base DN
    if(S_OK != (hr = myOIDHashOIDToString((LPWSTR)pwszOID,  &pwszCN)))
        _JumpError(hr , error, "myOIDHashOIDToString");

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszOIDContainerDN)+wcslen(pwszCN)+4);
    if(bstrDN == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrDN, L"CN=");
    wcscat(bstrDN, pwszCN);
    wcscat(bstrDN, L",");
    wcscat(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, bstrConfig);

    ldaperr = ldap_delete_s(pld, bstrDN);

    if(LDAP_NO_SUCH_OBJECT == ldaperr)
        ldaperr = LDAP_SUCCESS;

    hr = myHLdapError(pld, ldaperr, NULL);

error:
    if(pwszCN)
        LocalFree(pwszCN);

    if(bstrDN)
        CertFreeString(bstrDN);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}



//---------------------------------------------------------------------------
//
// CAOIDDelete
//
//---------------------------------------------------------------------------
HRESULT
CAOIDDelete(
    IN LPCWSTR	pwszOID)
{
    return I_CAOIDDelete(pwszOID);
}

//---------------------------------------------------------------------------
//
// I_CAOIDGetProperty
//
//---------------------------------------------------------------------------
HRESULT
I_CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue)
{
    HRESULT             hr=E_INVALIDARG;
    ULONG               ldaperr=0;
    DWORD               dwCount=0;
    struct l_timeval    timeout;
    LPWSTR              awszAttr[4];
    LDAPMessage         *Entry=NULL;

    WCHAR               **wszLdapVal = NULL;
    LPWSTR              pwszFilter = NULL;
    LDAPMessage         *SearchResult = NULL;
    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    CERTSTR             bstrDN = NULL;
    LPWSTR              pwszCN = NULL;
    

    if((NULL==pwszOID) || (NULL==pPropValue))
        _JumpError(hr , error, "ArgumentCheck");

    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");

	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    //set up the base DN
    if(S_OK != (hr = myOIDHashOIDToString((LPWSTR)pwszOID,  &pwszCN)))
        _JumpError(hr , error, "myOIDHashOIDToString");

    bstrDN = CertAllocStringLen(NULL, wcslen(bstrConfig) + wcslen(s_wszOIDContainerDN)+wcslen(pwszCN)+4);
    if(bstrDN == NULL)
    {
        hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "CertAllocStringLen");
    }
    wcscpy(bstrDN, L"CN=");
    wcscat(bstrDN, pwszCN);
    wcscat(bstrDN, L",");
    wcscat(bstrDN, s_wszOIDContainerDN);
    wcscat(bstrDN, bstrConfig);

    //search for the OID, asking for all its attributes
    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    awszAttr[0]=OID_PROP_TYPE;
    awszAttr[1]=OID_PROP_DISPLAY_NAME;
    awszAttr[2]=OID_PROP_CPS;
    awszAttr[3]=NULL;

    if(S_OK != (hr=FormatMessageUnicode(&pwszFilter, L"(%1!s!=%2!s!)",
                                    OID_PROP_OID, pwszOID)))
    _JumpError(hr , error, "FormatMessageUnicode");

    ldaperr = ldap_search_stW(
		      pld, 
		      (LPWSTR)bstrDN,
		      LDAP_SCOPE_BASE,
		      pwszFilter,
		      awszAttr,
		      0,
		      &timeout,
		      &SearchResult);

    if(LDAP_SUCCESS != ldaperr)
    {
	hr = myHLdapError2(pld, ldaperr, LDAP_NO_SUCH_OBJECT, NULL);
	_JumpErrorStr2(
		hr,
		error,
		"ldap_search_stW",
		pwszFilter,
		HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND));
    }

    dwCount = ldap_count_entries(pld, SearchResult);

    //we should only find one container
    if((1 != dwCount) || (NULL == (Entry = ldap_first_entry(pld, SearchResult))))
	{
	    // No entries were found.
	    hr = myHLdapError(pld, LDAP_NO_SUCH_OBJECT, NULL);
	    _JumpError(hr, error, "ldap_search_stW");
	}

    switch(dwProperty)
    {
        case CERT_OID_PROPERTY_DISPLAY_NAME:
                wszLdapVal = ldap_get_values(pld, Entry, OID_PROP_DISPLAY_NAME);
                
                if(wszLdapVal && wszLdapVal[0])
                {
                    hr=CAOIDAllocAndCopy(wszLdapVal[0], (LPWSTR *)pPropValue);
                }
                else
		    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);

            break;
        case CERT_OID_PROPERTY_CPS:

                wszLdapVal = ldap_get_values(pld, Entry, OID_PROP_CPS);
                
                if(wszLdapVal && wszLdapVal[0])
                {
                    hr=CAOIDAllocAndCopy(wszLdapVal[0], (LPWSTR *)pPropValue);
                }
                else
		    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);

            break;
        case CERT_OID_PROPERTY_TYPE:
                wszLdapVal = ldap_get_values(pld, Entry, OID_PROP_TYPE);
                
                if(wszLdapVal && wszLdapVal[0])
                {
                    *((DWORD *)pPropValue)=_wtol(wszLdapVal[0]);
                    hr=S_OK;
                }
                else
		    hr = myHLdapError(pld, LDAP_NO_SUCH_ATTRIBUTE, NULL);
            break;
        default:
                hr=E_INVALIDARG;
    }

    if(hr != S_OK)
        _JumpError(hr , error, "GetAttibuteValue");

error:

    if(wszLdapVal)
        ldap_value_free(wszLdapVal);

    if(pwszFilter)
        LocalFree((HLOCAL)pwszFilter);

    if(SearchResult)
        ldap_msgfree(SearchResult);

    if(pwszCN)
        LocalFree(pwszCN);

    if(bstrDN)
        CertFreeString(bstrDN);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}


//---------------------------------------------------------------------------
//
// CAOIDGetProperty
//
//---------------------------------------------------------------------------
HRESULT
CAOIDGetProperty(
    IN  LPCWSTR pwszOID,
    IN  DWORD   dwProperty,
    OUT LPVOID  pPropValue)
{
    return I_CAOIDGetProperty(pwszOID, dwProperty, pPropValue);
}

//---------------------------------------------------------------------------
//
// I_CAOIDFreeProperty
//
//---------------------------------------------------------------------------
HRESULT
I_CAOIDFreeProperty(
    IN LPVOID  pPropValue)
{
    if(pPropValue)
        LocalFree(pPropValue);

    return S_OK;
}


//---------------------------------------------------------------------------
//
// CAOIDFreeProperty
//
//---------------------------------------------------------------------------
HRESULT
CAOIDFreeProperty(
    IN LPVOID  pPropValue)
{

    return I_CAOIDFreeProperty(pPropValue);
}

//---------------------------------------------------------------------------
//
// CAOIDGetLdapURL
//
// Get the LDAP URL for the DS OID repository in the format of 
// LDAP:///DN of the Repository/all attributes?one?filter.
//---------------------------------------------------------------------------
HRESULT
CAOIDGetLdapURL(
    IN  DWORD   dwType,
    IN  DWORD,  // dwFlag
    OUT LPWSTR  *ppwszURL)
{
    HRESULT             hr=E_INVALIDARG;
    LPWSTR              wszFilterFormat=L"ldap:///%1!s!%2!s!?%3!s!,%4!s!,%5!s!,%6!s!,%7!s!?one?%8!s!=%9!d!";
    LPWSTR              pwsz=NULL;

    LPWSTR              pwszURL=NULL;
    LDAP                *pld = NULL;
    CERTSTR             bstrConfig = NULL;
    

    if(NULL==ppwszURL)
        _JumpError(hr , error, "ArgumentCheck");


    //retrieve the ldap handle and the config string
    if(S_OK != (hr = myTimeOutRobustLdapBind(&pld)))
        _JumpError(hr , error, "myTimeRobustLdapBind");


	hr = CAGetAuthoritativeDomainDn(pld, NULL, &bstrConfig);
	if(S_OK != hr)
	{
        _JumpError(hr , error, "CAGetAuthoritativeDomainDn");
	}

    if(S_OK != (hr=FormatMessageUnicode(
                    &pwszURL, 
                    wszFilterFormat,
                    s_wszOIDContainerDN, 
                    bstrConfig,
                    OID_PROP_TYPE,
                    OID_PROP_OID,
                    OID_PROP_DISPLAY_NAME,
                    OID_PROP_CPS,
                    OID_PROP_LOCALIZED_NAME,
                    OID_PROP_TYPE,
                    dwType
                    )))
        _JumpError(hr , error, "FormatMessageUnicode");

    //we eliminate the filter if dwType is CERT_OID_TYPE_ALL
    if(CERT_OID_TYPE_ALL == dwType)
    {
        pwsz=wcsrchr(pwszURL, L'?');

        if(NULL==pwsz)
        {
            //something serious is wrong
            hr=E_UNEXPECTED;
            _JumpError(hr , error, "FormatMessageUnicode");
        }

        *pwsz=L'\0';
    }

    *ppwszURL=pwszURL;
    pwszURL=NULL;

    hr=S_OK;

error:
    
    if(pwszURL)
        LocalFree((HLOCAL)pwszURL);

    if(bstrConfig)
        CertFreeString(bstrConfig);

    if (pld)
        ldap_unbind(pld);

    return hr;
}


//---------------------------------------------------------------------------
//
// CAOIDFreeLdapURL
//
//---------------------------------------------------------------------------
HRESULT
CAOIDFreeLdapURL(
    IN LPCWSTR      pwszURL)
{
    if(pwszURL)
        LocalFree((HLOCAL)pwszURL);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certclib"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include "certlib.h"

#ifndef MAXDWORD
#define MAXDWORD MAXULONG
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\serial.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        serial.cpp
//
// Contents:    serial number string encode/decode implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#define __dwFILE__	__dwFILE_CERTCLIB_SERIAL_CPP__


HRESULT
ObsoleteMultiByteIntegerToWszBuf(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT WCHAR *pwszOut)
{
    return MultiByteIntegerToWszBuf(
                fOctetString,
                cbIn,
                pbIn,
                pcbOut,
                pwszOut);
}

HRESULT
ObsoleteMultiByteIntegerToBstr(
    IN BOOL fOctetString,
    IN DWORD cbIn,
    IN BYTE const *pbIn,
    OUT BSTR *pstrOut)
{
    return MultiByteIntegerToBstr(
                fOctetString,
                cbIn,
                pbIn,
                pstrOut);
}

BOOL
AsciiToNibble(
    IN WCHAR wc,
    BYTE *pb)
{
    BOOL fOk = TRUE;

    do
    {
	wc -= L'0';
	if (wc <= 9)
	{
	    break;
	}
	wc += (WCHAR) (L'0' - L'a' + 10);
	if (wc <= 15)
	{
	    break;
	}
	wc += L'a' - L'A';
	if (wc <= 15)
	{
	    break;
	}
	fOk = FALSE;
    } while (FALSE);

    *pb = (BYTE) wc;
    return(fOk);
}


__inline BOOL
IsMultiByteSkipChar(
    IN WCHAR wc)
{
    return(L' ' == wc || L'\t' == wc);
}


// WszToMultiByteIntegerBuf - convert a big endian null-terminated ascii-hex
// encoded WCHAR string of even length to a little-endian integer blob.
// If fOctetString is TRUE, preserve endian order, as in a hex dump

HRESULT
WszToMultiByteIntegerBuf(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    IN OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE *pbOut)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD cbOut;

    cbOut = 0;
    hr = E_INVALIDARG;

    if (fOctetString)
    {
	for (pwsz = pwszIn; L'\0' != *pwsz; )
	{
	    BYTE blo, bhi;

	    while (IsMultiByteSkipChar(*pwsz))
	    {
		pwsz++;
	    }
	    if (!AsciiToNibble(*pwsz, &bhi))
	    {
		_JumpError2(
			hr,
			error,
			"WszToMultiByteInteger: bad string",
			E_INVALIDARG);
	    }
	    pwsz++;

	    while (IsMultiByteSkipChar(*pwsz))
	    {
		pwsz++;
	    }
	    if (!AsciiToNibble(*pwsz, &blo))
	    {
		_JumpError(hr, error, "WszToMultiByteInteger: bad string");
	    }
	    pwsz++;

	    cbOut++;
	    if (NULL != pbOut)
	    {
		if (cbOut > *pcbOut)
		{
		    hr = TYPE_E_BUFFERTOOSMALL;
		    _JumpError(hr, error, "WszToMultiByteInteger: overflow");
		}
		*pbOut++ = blo | (bhi << 4);
	    }
	}
    }
    else
    {
	for (pwsz = &pwszIn[wcslen(pwszIn) - 1]; pwsz >= pwszIn; )
	{
	    BYTE blo, bhi;

	    while (pwsz >= pwszIn && IsMultiByteSkipChar(*pwsz))
	    {
		pwsz--;
	    }
	    if (pwsz < pwszIn)
	    {
		break;
	    }
	    if (!AsciiToNibble(*pwsz, &blo))
	    {
		_JumpError(hr, error, "WszToMultiByteInteger: bad string");
	    }
	    pwsz--;

	    while (pwsz >= pwszIn && IsMultiByteSkipChar(*pwsz))
	    {
		pwsz--;
	    }
	    if (pwsz < pwszIn || !AsciiToNibble(*pwsz, &bhi))
	    {
		_JumpError(hr, error, "WszToMultiByteInteger: bad string");
	    }
	    pwsz--;

	    cbOut++;
	    if (NULL != pbOut)
	    {
		if (cbOut > *pcbOut)
		{
		    hr = TYPE_E_BUFFERTOOSMALL;
		    _JumpError(hr, error, "WszToMultiByteInteger: overflow");
		}
		*pbOut++ = blo | (bhi << 4);
	    }
	}
    }
    *pcbOut = cbOut;
    hr = S_OK;

error:
    return(hr);
}


// WszToMultiByteInteger - convert a big endian null-terminated ascii-hex
// encoded WCHAR string of even length to a little-endian integer blob.
// If fOctetString is TRUE, preserve endian order, as in a hex dump

HRESULT
WszToMultiByteInteger(
    IN BOOL fOctetString,
    IN WCHAR const *pwszIn,
    OUT DWORD *pcbOut,
    OUT BYTE **ppbOut)
{
    HRESULT hr = S_OK;

    *pcbOut = 0;
    *ppbOut = NULL;

    while (TRUE)
    {
	hr = WszToMultiByteIntegerBuf(fOctetString, pwszIn, pcbOut, *ppbOut);
	if (S_OK != hr)
	{
	    if (NULL != *ppbOut)
	    {
		LocalFree(*ppbOut);
		*ppbOut = NULL;
	    }
	    _JumpError2(hr, error, "WszToMultiByteIntegerBuf", E_INVALIDARG);
	}
	if (NULL != *ppbOut)
	{
	    break;
	}
	*ppbOut = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbOut);
	if (NULL == *ppbOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

error:
    return(hr);
}


HRESULT
caTranslateFileTimePeriodToPeriodUnits(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT DWORD *pcPeriodUnits,
    OUT PERIODUNITS **prgPeriodUnits)
{
    HRESULT hr;
    LLFILETIME llft;
    LONGLONG llRemain;
    DWORD i;
    DWORD cPeriodUnits;
    PERIODUNITS *rgPeriodUnits;
#define IC_YEARS	0
#define IC_MONTHS	1
#define IC_WEEKS	2
#define IC_DAYS		3
#define IC_HOURS	4
#define IC_MINUTES	5
#define IC_SECONDS	6
#define IC_MAX		7
    LONG alCount[IC_MAX];
    static const enum ENUM_PERIOD s_aenumPeriod[] =
    {
	ENUM_PERIOD_YEARS,
	ENUM_PERIOD_MONTHS,
	ENUM_PERIOD_WEEKS,
	ENUM_PERIOD_DAYS,
	ENUM_PERIOD_HOURS,
	ENUM_PERIOD_MINUTES,
	ENUM_PERIOD_SECONDS,
    };
    
    llft.ft = *pftGMT;
    if (0 <= llft.ll)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Not a time period");
    }
    llft.ll = -llft.ll;
    llft.ll /= CVT_BASE; // now in seconds

    ZeroMemory(alCount, sizeof(alCount));
    alCount[IC_DAYS] = (LONG) (llft.ll / (60 * 60 * 24));

    llRemain = llft.ll - (LONGLONG) alCount[IC_DAYS] * (60 * 60 * 24);
    if (fExact || 4 > alCount[IC_DAYS])	// if less than 96 hrs
    {
	alCount[IC_HOURS] = (LONG) llRemain / (60 * 60);
	if (fExact || 2 > alCount[IC_HOURS])	// if less than 120 mins
	{
	    alCount[IC_MINUTES] = ((LONG) llRemain / 60) % 60;
	    if (fExact || 2 > alCount[IC_MINUTES]) // if less than 120 secs
	    {
		alCount[IC_SECONDS] = (LONG) llRemain % 60;
	    }
	}
    }

    if (0 != alCount[IC_DAYS])
    {
	if (0 == (alCount[IC_DAYS] % 365))
	{
	    alCount[IC_YEARS] = alCount[IC_DAYS] / 365;
	    alCount[IC_DAYS] = 0;
	}
	else if (0 == (alCount[IC_DAYS] % 30))
	{
	    alCount[IC_MONTHS] = alCount[IC_DAYS] / 30;
	    alCount[IC_DAYS] = 0;
	}
	else if (0 == (alCount[IC_DAYS] % 7))
	{
	    alCount[IC_WEEKS] = alCount[IC_DAYS] / 7;
	    alCount[IC_DAYS] = 0;
	}
    }
    cPeriodUnits = 0;
    for (i = 0; i < IC_MAX; i++)
    {
	if (0 != alCount[i])
	{
	    cPeriodUnits++;
	}
    }
    if (0 == cPeriodUnits)
    {
	cPeriodUnits++;
    }
    rgPeriodUnits = (PERIODUNITS *) LocalAlloc(
				LMEM_FIXED,
				cPeriodUnits * sizeof(rgPeriodUnits[0]));
    if (NULL == rgPeriodUnits)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pcPeriodUnits = cPeriodUnits;
    *prgPeriodUnits = rgPeriodUnits;

    cPeriodUnits = 0;
    for (i = 0; i < IC_MAX; i++)
    {
	if (0 != alCount[i] || (0 == cPeriodUnits && i + 1 == IC_MAX))
	{
	    rgPeriodUnits[cPeriodUnits].lCount = alCount[i];
	    rgPeriodUnits[cPeriodUnits].enumPeriod = s_aenumPeriod[i];
	    cPeriodUnits++;
	}
    }
    CSASSERT(cPeriodUnits == *pcPeriodUnits);
    hr = S_OK;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "db.h"
#include "backup.h"

#define __dwFILE__	__dwFILE_CERTDB_BACKUP_CPP__


#if DBG
LONG g_cCertDBBackup;
LONG g_cCertDBBackupTotal;
#endif

CCertDBBackup::CCertDBBackup()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBBackup));
    DBGCODE(InterlockedIncrement(&g_cCertDBBackupTotal));
    m_pdb = NULL;
    m_pcs = NULL;
    m_fFileOpen = FALSE;
    m_fBegin = FALSE;
    m_fTruncated = FALSE;
    m_cRef = 1;
}


CCertDBBackup::~CCertDBBackup()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBBackup));
    _Cleanup();
}


VOID
CCertDBBackup::_Cleanup()
{
    HRESULT hr;

    if (NULL != m_pdb)
    {
	if (m_fFileOpen)
	{
	    CloseFile();
	}
	if (m_fBegin)
	{
	    hr = ((CCertDB *) m_pdb)->BackupEnd();
	    _PrintIfError(hr, "BackupEnd");
	    m_fBegin = FALSE;
	}
	if (NULL != m_pcs)
	{
	    hr = ((CCertDB *) m_pdb)->ReleaseSession(m_pcs);
	    _PrintIfError(hr, "ReleaseSession");
	    m_pcs = NULL;
	}
	m_pdb->Release();
	m_pdb = NULL;
    }
}


HRESULT
CCertDBBackup::Open(
    IN LONG grbitJet,
    IN CERTSESSION *pcs,
    IN ICertDB *pdb)
{
    HRESULT hr;

    _Cleanup();

    if (NULL == pcs || NULL == pdb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_pdb = pdb;
    m_pdb->AddRef();

    m_grbitJet = grbitJet;

    CSASSERT(0 == pcs->cTransact);
    hr = ((CCertDB *) m_pdb)->BackupBegin(m_grbitJet);
    _JumpIfError(hr, error, "BackupBegin");

    m_pcs = pcs;
    m_fBegin = TRUE;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(hr);
}


STDMETHODIMP
CCertDBBackup::GetDBFileList(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr;

    hr = E_UNEXPECTED;
    if (!m_fBegin)
    {
	_JumpError(hr, error, "!m_fBegin");
    }
    if (NULL == pcwcList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = ((CCertDB *) m_pdb)->BackupGetDBFileList(pcwcList, pwszzList);
    _JumpIfError(hr, error, "BackupGetDBFileList");

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::GetLogFileList(
    IN OUT DWORD *pcwcList,
    OPTIONAL OUT WCHAR *pwszzList)
{
    HRESULT hr;

    if (!m_fBegin)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "!m_fBegin");
    }
    if (NULL == pcwcList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = ((CCertDB *) m_pdb)->BackupGetLogFileList(pcwcList, pwszzList);
    _JumpIfError(hr, error, "BackupGetLogFileList");

error:
    return(hr);
}



STDMETHODIMP
CCertDBBackup::OpenFile(
    IN WCHAR const *pwszFile,
    OPTIONAL OUT ULARGE_INTEGER *pliSize)
{
    HRESULT hr;

    hr = E_UNEXPECTED;
    if (!m_fBegin)
    {
	_JumpError(hr, error, "!m_fBegin");
    }
    if (m_fFileOpen)
    {
	_JumpError(hr, error, "m_fFileOpen");
    }
    if (m_fTruncated)
    {
	_JumpError(hr, error, "m_fTruncated");
    }

    hr = ((CCertDB *) m_pdb)->BackupOpenFile(pwszFile, &m_hFileDB, pliSize);
    _JumpIfErrorStr(hr, error, "BackupOpenFile", pwszFile);

    m_fFileOpen = TRUE;

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::ReadFile(
    IN OUT DWORD *pcb,
    OUT    BYTE *pb)
{
    HRESULT hr;

    if (!m_fFileOpen)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "!m_fFileOpen");
    }
    if (NULL == pcb || NULL == pb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = ((CCertDB *) m_pdb)->BackupReadFile(m_hFileDB, pb, *pcb, pcb);
    _JumpIfError(hr, error, "BackupReadFile");

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::CloseFile()
{
    HRESULT hr;

    if (!m_fFileOpen)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "!m_fFileOpen");
    }

    hr = ((CCertDB *) m_pdb)->BackupCloseFile(m_hFileDB);
    _JumpIfError(hr, error, "BackupCloseFile");

    m_fFileOpen = FALSE;

error:
    return(hr);
}


STDMETHODIMP
CCertDBBackup::TruncateLog()
{
    HRESULT hr;

    hr = E_UNEXPECTED;
    if (!m_fBegin)
    {
	_JumpError(hr, error, "!m_fBegin");
    }
    if (m_fFileOpen)
    {
	_JumpError(hr, error, "m_fFileOpen");
    }

    hr = ((CCertDB *) m_pdb)->BackupTruncateLog();
    _JumpIfError(hr, error, "BackupTruncateLog");

    m_fTruncated = TRUE;

error:
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CCertDBBackup::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertDBBackup *>(this);
    }
    else if (iid == IID_ICertDBBackup)
    {
	*ppv = static_cast<ICertDBBackup *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CCertDBBackup::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertDBBackup::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CCertDBBackup::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_ICertDBBackup,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\backup.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CCertDBBackup: public ICertDBBackup
{
public:
    CCertDBBackup();
    ~CCertDBBackup();

public:

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ICertDBBackup
    STDMETHOD(GetDBFileList)(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    STDMETHOD(GetLogFileList)(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    STDMETHOD(OpenFile)(
	IN WCHAR const *pwszFile,
	OPTIONAL OUT ULARGE_INTEGER *pliSize);

    STDMETHOD(ReadFile)(
	IN OUT DWORD *pcb,
	OUT    BYTE *pb);

    STDMETHOD(CloseFile)();

    STDMETHOD(TruncateLog)();

    // CCertDBBackup
    HRESULT Open(
	IN LONG grbitJet,
	IN CERTSESSION *pcs,
	IN ICertDB *pdb);

private:
    VOID _Cleanup();

    ICertDB     *m_pdb;
    CERTSESSION *m_pcs;

    LONG         m_grbitJet;
    BOOL         m_fBegin;
    BOOL         m_fFileOpen;
    BOOL         m_fTruncated;
    JET_HANDLE   m_hFileDB;

    // Reference count
    long         m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\certdb.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certdb.cpp
//
// Contents:    Cert Server Database Access implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "db.h"
#include "backup.h"
#include "restore.h"


// for new jet snapshotting
#ifndef _DISABLE_VSS_
#include <vss.h>
#include <vswriter.h>
#include "jetwriter.h"
#endif

#define __dwFILE__	__dwFILE_CERTDB_CERTDB_CPP__


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertDB, CCertDB)
    OBJECT_ENTRY(CLSID_CCertDBRestore, CCertDBRestore)
END_OBJECT_MAP()

#ifndef _DISABLE_VSS_

class myVssWriter : public CVssJetWriter
{
public:
// override OnIdentify
    bool STDMETHODCALLTYPE OnIdentify(IN IVssCreateWriterMetadata *pMetadata);
};

const GUID cGuidCertSrvWriter = {0x6f5b15b5,0xda24,0x4d88,{0xb7, 0x37, 0x63, 0x06, 0x3e, 0x3a, 0x1f, 0x86}}; // 6f5b15b5-da24-4d88-b737-63063e3a1f86
myVssWriter* g_pWriter = NULL;

// our class overrides a single method (bug 454582)
bool myVssWriter::OnIdentify(IVssCreateWriterMetadata* pMetadata)
{
   HRESULT hr; 

   // specify how we want restore to happen
   hr = pMetadata->SetRestoreMethod
	(
        VSS_RME_RESTORE_AT_REBOOT,
	NULL,
	NULL,
	VSS_WRE_NEVER,
	true);
   _JumpIfError(hr, error, "SetRestoreMethod");

   // generate other metadata
   if (!CVssJetWriter::OnIdentify(pMetadata))
   {
       hr = myHLastError();
       _JumpError(hr, error, "::OnIdentify");
   }

error:
   return (hr == S_OK);
}

#endif


HRESULT
InitGlobalWriterState(VOID)
{
   HRESULT hr;

#ifndef _DISABLE_VSS_
   if (NULL == g_pWriter && IsWhistler())
   {
       // create writer object

       g_pWriter = new myVssWriter; // CVssJetWriter;
       if (NULL == g_pWriter)
       {
	   hr = E_OUTOFMEMORY;
	   _JumpError(hr, error, "new CVssJetWriter");
       }

       hr = g_pWriter->Initialize(
			cGuidCertSrvWriter,		// id of writer
			L"Certificate Authority",	// name of writer, should match FilesNotToBackup key
			TRUE,				// system service
			TRUE,				// bootable state
			NULL,				// files to include
			NULL);				// files to exclude
       _JumpIfError(hr, error, "CVssJetWriter::Initialize");
   }
#endif
   hr = S_OK;

#ifndef _DISABLE_VSS_
error:
#endif
   return hr;
}
 


HRESULT
UnInitGlobalWriterState(VOID)
{
#ifndef _DISABLE_VSS_
    if (NULL != g_pWriter)
    {
	g_pWriter->Uninitialize();
	delete g_pWriter;
	g_pWriter = NULL;
    }
#endif
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\column.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "column.h"
#include "enum.h"
#include "db.h"
#include "row.h"
#include "dbw.h"

#define __dwFILE__	__dwFILE_CERTDB_COLUMN_CPP__


#if DBG
LONG g_cCertDBColumn;
LONG g_cCertDBColumnTotal;
#endif

CEnumCERTDBCOLUMN::CEnumCERTDBCOLUMN()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBColumn));
    DBGCODE(InterlockedIncrement(&g_cCertDBColumnTotal));
    m_pdb = NULL;
    m_ielt = 0;
    m_dwTable = CVRC_TABLE_REQCERT;
    m_cRef = 1;
}


CEnumCERTDBCOLUMN::~CEnumCERTDBCOLUMN()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBColumn));
    if (NULL != m_pdb)
    {
	m_pdb->Release();
	m_pdb = NULL;
    }
}


HRESULT
CEnumCERTDBCOLUMN::Open(
    IN DWORD    dwTable,	// CVRC_TABLE_*
    IN ICertDB *pdb)
{
    HRESULT hr;
    
    if (NULL == pdb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_dwTable = dwTable;
    m_pdb = pdb;
    m_pdb->AddRef();
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Next(
    /* [in] */  ULONG         celt,
    /* [out] */ CERTDBCOLUMN *rgelt,
    /* [out] */ ULONG        *pceltFetched)
{
    HRESULT hr;
    DWORD ieltNext;

    if (NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->EnumCertDBColumnNext(
						m_dwTable,
						m_ielt,
						celt,
						rgelt,
						&ieltNext,
						pceltFetched);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "EnumCertDBColumnNext");
    }
    m_ielt = ieltNext;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Skip(
    /* [in] */  LONG  celt,
    /* [out] */ LONG *pielt)
{
    HRESULT hr;

    if (NULL == pielt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_ielt += celt;
    *pielt = m_ielt;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Reset(VOID)
{
    m_ielt = 0;
    return(S_OK);
}


STDMETHODIMP
CEnumCERTDBCOLUMN::Clone(
    /* [out] */ IEnumCERTDBCOLUMN **ppenum)
{
    HRESULT hr;
    LONG iDummy;
    IEnumCERTDBCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = m_pdb->EnumCertDBColumn(m_dwTable, &penum);
    _JumpIfError(hr, error, "EnumCertDBColumn");

    if (0 != m_ielt)
    {
	penum->Skip(m_ielt, &iDummy);
    }

error:
    if (NULL != ppenum)
    {
	*ppenum = penum;
    }
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTDBCOLUMN::QueryInterface(const IID& iid, void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTDBCOLUMN *>(this);
    }
    else if (iid == IID_IEnumCERTDBCOLUMN)
    {
	*ppv = static_cast<IEnumCERTDBCOLUMN *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBCOLUMN::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBCOLUMN::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CEnumCERTDBCOLUMN::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_IEnumCERTDBCOLUMN,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\column.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CEnumCERTDBCOLUMN: public IEnumCERTDBCOLUMN
{
public:
    CEnumCERTDBCOLUMN();
    ~CEnumCERTDBCOLUMN();

public:

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTDBCOLUMN


    STDMETHOD(Next)(
	/* [in] */  ULONG         celt,		// celt OR (CVRC_TABLE_* | 0)
	/* [out] */ CERTDBCOLUMN *rgelt,
	/* [out] */ ULONG        *pceltFetched);
    
    STDMETHOD(Skip)(
	/* [in] */  LONG  celt,
	/* [out] */ LONG *pielt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTDBCOLUMN **ppenum);


    HRESULT Open(
	IN DWORD    dwTable,	// CVRC_TABLE_*
	IN ICertDB *pdb);
	
private:
    ICertDB *m_pdb;
    ULONG    m_ielt;
    ULONG    m_dwTable;

    // Reference count
    long     m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\dbtable.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbtable.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"


// To Add a column to one of these tables:
// 1) Add a wszPROP<COLNAME> #define to ..\include\csprop.h and run mkcsinc.bat
// 2) Add a IDS_COLUMN_<COLNAME> #define to ..\certcli\resource.h and add the
//    display name to ..\certcli\certcli.rc.  Add an entry to g_aColTable in
//   ..\certcli\column.cpp that maps wszPROP<COLNAME> to IDS_COLUMN_<COLNAME>.
// 3) Add a DT?_<COLNAME> to the appropriate list of #defines in dbtable.h.
//    Renumber subsequent #defines if inserting into the table.
//    Change DT?_MAX.
//    Add a #define sz<COLNAME> "$ColName" ansi internal column name.
//    If the column is to be indexed, add a #define sz<TABLE>_<COLNAME>
//    "$<Table><ColName>Index"
//    The internal names of text columns and their indexes must begin with '$'.
//    The internal names of computed DWORD columns must begin with '?'.
// 4) Find a similar column type in the same table array (g_adt<Table>) in
//    dbtable.cpp, and copy the entry.  If inserting, fix subsequent
//    #if (DT?_<xxx> != CONSTANT) expressions to match the dbtable.h changes.
//    Fix the #if (DT?_MAX != CONSTANT) expression.
//    For the new g_adt<Table> entry, use NULL for pszIndexName if unindexed.
//
// Running the new certdb.dll on a machine will automatically create the new
// column(s) and indexes, and leave them empty.
//
// If DBTF_COLUMNRENAMED is set, the old column name is appended to
// pszFieldName.  When starting the database, if the old column exists, the
// old column data is copied to the new column FOR EVERY ROW.  Upon successful
// completion, the old column is deleted.
//
// Special case processing exists to convert ansi text column data to Unicode.
// Special case processing exists for a few missing columns: Key Length is
// computed, for example.
//
// If DBTF_INDEXRENAMED is set, the old index name is appended to pszIndexName.
// When starting the database, if the old index exists, it is deleted.


//---------------------------------------------------------------------------
//
// Requests Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtRequests[] =
{
#if (DTR_REQUESTID != 0)
#error -- bad DTR_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTREQUESTID,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXPRIMARY,			// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTID,				// pszFieldName
        szREQUEST_REQUESTIDINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed | JET_bitColumnAutoincrement, // dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRAWREQUEST != 1)
#error -- bad DTR_REQUESTRAWREQUEST index
#endif
    {	// ColumnType: BLOB
	wszPROPREQUESTRAWREQUEST,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWREQUEST,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWREQUEST,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWREQUEST,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRAWARCHIVEDKEY != 2)
#error -- bad DTR_REQUESTRAWARCHIVEDKEY index
#endif
    {	// ColumnType: BLOB
	wszPROPREQUESTRAWARCHIVEDKEY,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWREQUEST,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWARCHIVEDKEY,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWREQUEST,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTKEYRECOVERYHASHES != 3)
#error -- bad DTR_REQUESTKEYRECOVERYHASHES index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTKEYRECOVERYHASHES,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_MEDIUM,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szKEYRECOVERYHASHES,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_MEDIUM,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRAWOLDCERTIFICATE != 4)
#error -- bad DTR_REQUESTRAWOLDCERTIFICATE index
#endif
    {	// ColumnType: BLOB
	wszPROPREQUESTRAWOLDCERTIFICATE,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWCERTIFICATE,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWOLDCERTIFICATE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWCERTIFICATE,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTATTRIBUTES != 5)
#error -- bad DTR_REQUESTATTRIBUTES index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTATTRIBUTES,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_ATTRSTRING,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTATTRIBUTES,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_ATTRSTRING,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTTYPE != 6)
#error -- bad DTR_REQUESTTYPE index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTTYPE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTTYPE,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTFLAGS != 7)
#error -- bad DTR_REQUESTFLAGS index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTFLAGS,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTFLAGS,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTSTATUSCODE != 8)
#error -- bad DTR_REQUESTSTATUSCODE index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTSTATUSCODE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSTATUSCODE,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTDISPOSITION != 9)
#error -- bad DTR_REQUESTDISPOSITION index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTDISPOSITION,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDISPOSITION,				// pszFieldName
        szREQUEST_DISPOSITIONINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTDISPOSITIONMESSAGE != 10)
#error -- bad DTR_REQUESTDISPOSITIONMESSAGE index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTDISPOSITIONMESSAGE,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_DISPSTRING,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDISPOSITIONMESSAGE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_DISPSTRING,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTSUBMITTEDWHEN != 11)
#error -- bad DTR_REQUESTSUBMITTEDWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTSUBMITTEDWHEN,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSUBMITTEDWHEN,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTRESOLVEDWHEN != 12)
#error -- bad DTR_REQUESTRESOLVEDWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTRESOLVEDWHEN,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRESOLVEDWHEN,				// pszFieldName
        szREQUEST_RESOLVEDWHENINDEX "\0" szREQUEST_RESOLVEDWHENINDEX_OLD, // pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTREVOKEDWHEN != 13)
#error -- bad DTR_REQUESTREVOKEDWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTREVOKEDWHEN,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREVOKEDWHEN,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTREVOKEDEFFECTIVEWHEN != 14)
#error -- bad DTR_REQUESTREVOKEDEFFECTIVEWHEN index
#endif
    {	// ColumnType: FILETIME
	wszPROPREQUESTREVOKEDEFFECTIVEWHEN,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREVOKEDEFFECTIVEWHEN,			// pszFieldName
        szREQUEST_REVOKEDEFFECTIVEWHENINDEX "\0" szREQUEST_REVOKEDEFFECTIVEWHENINDEX_OLD, // pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTREVOKEDREASON != 15)
#error -- bad DTR_REQUESTREVOKEDREASON index
#endif
    {	// ColumnType: DWORD
	wszPROPREQUESTREVOKEDREASON,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREVOKEDREASON,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_REQUESTERNAME != 16)
#error -- bad DTR_REQUESTERNAME index
#endif
    {	// ColumnType: STRING
	wszPROPREQUESTERNAME,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_REQUESTNAME,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szREQUESTERNAME,			// pszFieldName
        szREQUEST_REQUESTERNAMEINDEX,		// pszIndexName
        CB_DBMAXTEXT_REQUESTNAME,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_CALLERNAME != 17)
#error -- bad DTR_CALLERNAME index
#endif
    {	// ColumnType: STRING
	wszPROPCALLERNAME,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_REQUESTNAME,		// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szCALLERNAME,				// pszFieldName
        szREQUEST_CALLERNAMEINDEX,		// pszIndexName
        CB_DBMAXTEXT_REQUESTNAME,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_SIGNERPOLICIES != 18)
#error -- bad DTR_SIGNERPOLICIES index
#endif
    {	// ColumnType: STRING
	wszPROPSIGNERPOLICIES,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_MEDIUM,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSIGNERPOLICIES,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_MEDIUM,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_SIGNERAPPLICATIONPOLICIES != 19)
#error -- bad DTR_SIGNERAPPLICATIONPOLICIES index
#endif
    {	// ColumnType: STRING
	wszPROPSIGNERAPPLICATIONPOLICIES,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_MEDIUM,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSIGNERAPPLICATIONPOLICIES,		// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_MEDIUM,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_OFFICER != 20)
#error -- bad DTR_OFFICER index
#endif
    {	// ColumnType: DWORD
	wszPROPOFFICER,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_COMPUTED,				// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szOFFICER,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_DISTINGUISHEDNAME != 21)
#error -- bad DTR_DISTINGUISHEDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPDISTINGUISHEDNAME,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_DN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDISTINGUISHEDNAME,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_DN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_RAWNAME != 22)
#error -- bad DTR_RAWNAME index
#endif
    {	// ColumnType: BLOB
	wszPROPRAWNAME,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szRAWNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_COUNTRY != 23)
#error -- bad DTR_COUNTRY index
#endif
    {	// ColumnType: STRING
	wszPROPCOUNTRY,				// pwszPropName
	TEXT(szOID_COUNTRY_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szCOUNTRY,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_ORGANIZATION != 24)
#error -- bad DTR_ORGANIZATION index
#endif
    {	// ColumnType: STRING
	wszPROPORGANIZATION,			// pwszPropName
	TEXT(szOID_ORGANIZATION_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szORGANIZATION,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_ORGUNIT != 25)
#error -- bad DTR_ORGUNIT index
#endif
    {	// ColumnType: STRING
	wszPROPORGUNIT,				// pwszPropName
	TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),	// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szORGANIZATIONALUNIT,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_COMMONNAME != 26)
#error -- bad DTR_COMMONNAME index
#endif
    {	// ColumnType: STRING
	wszPROPCOMMONNAME,			// pwszPropName
	TEXT(szOID_COMMON_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szCOMMONNAME,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_LOCALITY != 27)
#error -- bad DTR_LOCALITY index
#endif
    {	// ColumnType: STRING
	wszPROPLOCALITY,			// pwszPropName
	TEXT(szOID_LOCALITY_NAME),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szLOCALITY,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_STATE != 28)
#error -- bad DTR_STATE index
#endif
    {	// ColumnType: STRING
	wszPROPSTATE,				// pwszPropName
	TEXT(szOID_STATE_OR_PROVINCE_NAME),	// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSTATEORPROVINCE,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_TITLE != 29)
#error -- bad DTR_TITLE index
#endif
    {	// ColumnType: STRING
	wszPROPTITLE,				// pwszPropName
	TEXT(szOID_TITLE),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szTITLE,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_GIVENNAME != 30)
#error -- bad DTR_GIVENNAME index
#endif
    {	// ColumnType: STRING
	wszPROPGIVENNAME,			// pwszPropName
	TEXT(szOID_GIVEN_NAME),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szGIVENNAME,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_INITIALS != 31)
#error -- bad DTR_INITIALS index
#endif
    {	// ColumnType: STRING
	wszPROPINITIALS,			// pwszPropName
	TEXT(szOID_INITIALS),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szINITIALS,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_SURNAME != 32)
#error -- bad DTR_SURNAME index
#endif
    {	// ColumnType: STRING
	wszPROPSURNAME,				// pwszPropName
	TEXT(szOID_SUR_NAME),			// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSURNAME,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_DOMAINCOMPONENT != 33)
#error -- bad DTR_DOMAINCOMPONENT index
#endif
    {	// ColumnType: STRING
	wszPROPDOMAINCOMPONENT,			// pwszPropName
	TEXT(szOID_DOMAIN_COMPONENT),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDOMAINCOMPONENT,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_EMAIL != 34)
#error -- bad DTR_EMAIL index
#endif
    {	// ColumnType: STRING
	wszPROPEMAIL,				// pwszPropName
	TEXT(szOID_RSA_emailAddr),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szEMAIL,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_STREETADDRESS != 35)
#error -- bad DTR_STREETADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPSTREETADDRESS,			// pwszPropName
	TEXT(szOID_STREET_ADDRESS),		// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szSTREETADDRESS,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_UNSTRUCTUREDNAME != 36)
#error -- bad DTR_UNSTRUCTUREDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDNAME,		// pwszPropName
	TEXT(szOID_RSA_unstructName),		// pwszPropNameObjId
	DBTF_SUBJECT | DBTF_SOFTFAIL,		// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szUNSTRUCTUREDNAME,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_UNSTRUCTUREDADDRESS != 37)
#error -- bad DTR_UNSTRUCTUREDADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDADDRESS,		// pwszPropName
	TEXT(szOID_RSA_unstructAddr),		// pwszPropNameObjId
	DBTF_SUBJECT | DBTF_SOFTFAIL,		// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szUNSTRUCTUREDADDRESS,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_DEVICESERIALNUMBER != 38)
#error -- bad DTR_DEVICESERIALNUMBER index
#endif
    {	// ColumnType: STRING
	wszPROPDEVICESERIALNUMBER,		// pwszPropName
	TEXT(szOID_DEVICE_SERIAL_NUMBER),	// pwszPropNameObjId
	DBTF_SUBJECT | DBTF_SOFTFAIL,		// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_REQUESTS,				// dwTable
	szDEVICESERIALNUMBER,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTR_MAX != 39)
#error -- bad DTR_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// Certificates Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtCertificates[] =
{
#if (DTC_REQUESTID != 0)
#error -- bad DTC_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPCERTIFICATEREQUESTID,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXPRIMARY,			// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szREQUESTID,				// pszFieldName
	szCERTIFICATE_REQUESTIDINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_RAWCERTIFICATE != 1)
#error -- bad DTC_RAWCERTIFICATE index
#endif
    {	// ColumnType: BLOB
	wszPROPRAWCERTIFICATE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWCERTIFICATE,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szRAWCERTIFICATE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXRAWCERTIFICATE,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEHASH != 2)
#error -- bad DTC_CERTIFICATEHASH index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATEHASH,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL,			// dwFlags
	cchHASHMAX * sizeof(WCHAR),		// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATEHASH,			// pszFieldName
        szCERTIFICATE_HASHINDEX,		// pszIndexName
        cchHASHMAX * sizeof(WCHAR),		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATETEMPLATE != 3)
#error -- bad DTC_CERTIFICATETEMPLATE index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATETEMPLATE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SOFTFAIL,	// dwFlags
	CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATETEMPLATE,			// pszFieldName
	szCERTIFICATE_TEMPLATEINDEX,		// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEENROLLMENTFLAGS != 4)
#error -- bad DTC_CERTIFICATEENROLLMENTFLAGS index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEENROLLMENTFLAGS,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SOFTFAIL,	// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATEENROLLMENTFLAGS,		// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEGENERALFLAGS != 5)
#error -- bad DTC_CERTIFICATEGENERALFLAGS index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEGENERALFLAGS,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SOFTFAIL,	// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCERTIFICATEGENERALFLAGS,		// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATESERIALNUMBER != 6)
#error -- bad DTC_CERTIFICATESERIALNUMBER index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATESERIALNUMBER,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	cchSERIALNUMBERMAX * sizeof(WCHAR),	// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSERIALNUMBER,				// pszFieldName
	szCERTIFICATE_SERIALNUMBERINDEX "\0" szCERTIFICATE_SERIALNUMBERINDEX_OLD,	// pszIndexName
	cchSERIALNUMBERMAX * sizeof(WCHAR),	// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEISSUERNAMEID != 7)
#error -- bad DTC_CERTIFICATEISSUERNAMEID index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEISSUERNAMEID,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szISSUERNAMEID,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATENOTBEFOREDATE != 8)
#error -- bad DTC_CERTIFICATENOTBEFOREDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCERTIFICATENOTBEFOREDATE,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE,			// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szNOTBEFORE,				// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATENOTAFTERDATE != 9)
#error -- bad DTC_CERTIFICATENOTAFTERDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCERTIFICATENOTAFTERDATE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_INDEXIGNORENULL | DBTF_INDEXRENAMED, // dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szNOTAFTER,				// pszFieldName
        szCERTIFICATE_NOTAFTERINDEX "\0" szCERTIFICATE_NOTAFTERINDEX_OLD, // pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATESUBJECTKEYIDENTIFIER != 10)
#error -- bad DTC_CERTIFICATESUBJECTKEYIDENTIFIER index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATESUBJECTKEYIDENTIFIER,	// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_COLUMNRENAMED,			// dwFlags
	cchHASHMAX * sizeof(WCHAR),		// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSUBJECTKEYIDENTIFIER "\0" szSUBJECTKEYIDENTIFIER_OLD, // pszFieldName
        NULL,					// pszIndexName
        cchHASHMAX * sizeof(WCHAR),		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATERAWPUBLICKEY != 11)
#error -- bad DTC_CERTIFICATERAWPUBLICKEY index
#endif
    {	// ColumnType: BLOB
	wszPROPCERTIFICATERAWPUBLICKEY,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEY,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEPUBLICKEYLENGTH != 12)
#error -- bad DTC_CERTIFICATEPUBLICKEYLENGTH index
#endif
    {   // ColumnType: DWORD
	wszPROPCERTIFICATEPUBLICKEYLENGTH,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEYLENGTH,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEPUBLICKEYALGORITHM != 13)
#error -- bad DTC_CERTIFICATEPUBLICKEYALGORITHM index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATEPUBLICKEYALGORITHM,	// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEYALGORITHM,			// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypText,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS != 14)
#error -- bad DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS index
#endif
    {	// ColumnType: BLOB
	wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS, // pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szPUBLICKEYPARAMS,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_CERTIFICATEUPN != 15)
#error -- bad DTC_CERTIFICATEUPN index
#endif
    {	// ColumnType: STRING
	wszPROPCERTIFICATEUPN,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_INDEXIGNORENULL,// dwFlags
	CB_DBMAXTEXT_REQUESTNAME,		// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szUPN,					// pszFieldName
        szCERTIFICATE_UPNINDEX,			// pszIndexName
        CB_DBMAXTEXT_REQUESTNAME,		// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_DISTINGUISHEDNAME != 16)
#error -- bad DTC_DISTINGUISHEDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPDISTINGUISHEDNAME,		// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szDISTINGUISHEDNAME,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_DN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_RAWNAME != 17)
#error -- bad DTC_RAWNAME index
#endif
    {	// ColumnType: BLOB
	wszPROPRAWNAME,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_SUBJECT,				// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szRAWNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXBINARY,				// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongBinary,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_COUNTRY != 18)
#error -- bad DTC_COUNTRY index
#endif
    {	// ColumnType: STRING
	wszPROPCOUNTRY,				// pwszPropName
	TEXT(szOID_COUNTRY_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCOUNTRY,				// pszFieldName
        NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_ORGANIZATION != 19)
#error -- bad DTC_ORGANIZATION index
#endif
    {	// ColumnType: STRING
	wszPROPORGANIZATION,			// pwszPropName
	TEXT(szOID_ORGANIZATION_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szORGANIZATION,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_ORGUNIT != 20)
#error -- bad DTC_ORGUNIT index
#endif
    {	// ColumnType: STRING
	wszPROPORGUNIT,				// pwszPropName
	TEXT(szOID_ORGANIZATIONAL_UNIT_NAME),	// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szORGANIZATIONALUNIT,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_COMMONNAME != 21)
#error -- bad DTC_COMMONNAME index
#endif
    {	// ColumnType: STRING
	wszPROPCOMMONNAME,			// pwszPropName
	TEXT(szOID_COMMON_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szCOMMONNAME,				// pszFieldName
        szCERTIFICATE_COMMONNAMEINDEX,		// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_LOCALITY != 22)
#error -- bad DTC_LOCALITY index
#endif
    {	// ColumnType: STRING
	wszPROPLOCALITY,			// pwszPropName
	TEXT(szOID_LOCALITY_NAME),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szLOCALITY,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_STATE != 23)
#error -- bad DTC_STATE index
#endif
    {	// ColumnType: STRING
	wszPROPSTATE,				// pwszPropName
	TEXT(szOID_STATE_OR_PROVINCE_NAME),	// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSTATEORPROVINCE,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_TITLE != 24)
#error -- bad DTC_TITLE index
#endif
    {	// ColumnType: STRING
	wszPROPTITLE,				// pwszPropName
	TEXT(szOID_TITLE),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szTITLE,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_GIVENNAME != 25)
#error -- bad DTC_GIVENNAME index
#endif
    {	// ColumnType: STRING
	wszPROPGIVENNAME,			// pwszPropName
	TEXT(szOID_GIVEN_NAME),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szGIVENNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_INITIALS != 26)
#error -- bad DTC_INITIALS index
#endif
    {	// ColumnType: STRING
	wszPROPINITIALS,			// pwszPropName
	TEXT(szOID_INITIALS),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szINITIALS,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_SURNAME != 27)
#error -- bad DTC_SURNAME index
#endif
    {	// ColumnType: STRING
	wszPROPSURNAME,				// pwszPropName
	TEXT(szOID_SUR_NAME),			// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSURNAME,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_DOMAINCOMPONENT != 28)
#error -- bad DTC_DOMAINCOMPONENT index
#endif
    {	// ColumnType: STRING
	wszPROPDOMAINCOMPONENT,			// pwszPropName
	TEXT(szOID_DOMAIN_COMPONENT),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szDOMAINCOMPONENT,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_EMAIL != 29)
#error -- bad DTC_EMAIL index
#endif
    {	// ColumnType: STRING
	wszPROPEMAIL,				// pwszPropName
	TEXT(szOID_RSA_emailAddr),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szEMAIL,				// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_STREETADDRESS != 30)
#error -- bad DTC_STREETADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPSTREETADDRESS,			// pwszPropName
	TEXT(szOID_STREET_ADDRESS),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT,	// dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szSTREETADDRESS,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_UNSTRUCTUREDNAME != 31)
#error -- bad DTC_UNSTRUCTUREDNAME index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDNAME,		// pwszPropName
	TEXT(szOID_RSA_unstructName),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT | DBTF_SOFTFAIL, // dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szUNSTRUCTUREDNAME,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_UNSTRUCTUREDADDRESS != 32)
#error -- bad DTC_UNSTRUCTUREDADDRESS index
#endif
    {	// ColumnType: STRING
	wszPROPUNSTRUCTUREDADDRESS,		// pwszPropName
	TEXT(szOID_RSA_unstructAddr),		// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT | DBTF_SOFTFAIL, // dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szUNSTRUCTUREDADDRESS,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_DEVICESERIALNUMBER != 33)
#error -- bad DTC_DEVICESERIALNUMBER index
#endif
    {	// ColumnType: STRING
	wszPROPDEVICESERIALNUMBER,		// pwszPropName
	TEXT(szOID_DEVICE_SERIAL_NUMBER),	// pwszPropNameObjId
	DBTF_POLICYWRITEABLE | DBTF_SUBJECT | DBTF_SOFTFAIL, // dwFlags
        CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_CERTIFICATES,			// dwTable
	szDEVICESERIALNUMBER,			// pszFieldName
        NULL,					// pszIndexName
        CB_DBMAXTEXT_RDN,			// dbcolumnMax
        0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTC_MAX != 34)
#error -- bad DTC_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// Request Attributes Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtRequestAttributes[] =
{
#if (DTA_REQUESTID != 0)
#error -- bad DTA_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPATTRIBREQUESTID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_ATTRIBUTES,			// dwTable
	szREQUESTID,				// pszFieldName
	szATTRIBUTE_REQUESTIDINDEX,		// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTA_ATTRIBUTENAME != 1)
#error -- bad DTA_ATTRIBUTENAME index
#endif
    {	// ColumnType: STRING
	wszPROPATTRIBNAME,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXREQUESTID,			// dwFlags
        CB_DBMAXTEXT_ATTRNAME,			// dwcbMax
	TABLE_ATTRIBUTES,			// dwTable
	szATTRIBUTENAME,			// pszFieldName
	szATTRIBUTE_REQUESTIDNAMEINDEX,		// pszIndexName
	CB_DBMAXTEXT_ATTRNAME,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypText,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTA_ATTRIBUTEVALUE != 2)
#error -- bad DTA_ATTRIBUTEVALUE index
#endif
    {	// ColumnType: STRING
	wszPROPATTRIBVALUE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
        CB_DBMAXTEXT_ATTRVALUE,			// dwcbMax
	TABLE_ATTRIBUTES,			// dwTable
	szATTRIBUTEVALUE,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_ATTRVALUE,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongText,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTA_MAX != 3)
#error -- bad DTA_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// Name Extensions Table:
//
//---------------------------------------------------------------------------

#if 0
WCHAR const wszDummy[] = L"Dummy Prop Name";

DBTABLE g_adtNameExtensions[] =
{
    {	// ColumnType: DWORD
	wszDummy,				// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_NAMES,				// dwTable
	szNAMEID,				// pszFieldName
	NULL,					// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
    {	// ColumnType: STRING
	wszDummy,				// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
        CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_NAMES,				// dwTable
	szEXTENSIONNAME,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypText,				// dbcoltyp
	0,					// dbcolumnid
    },
    {	// ColumnType: STRING
	wszDummy,				// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXTEXT_RDN,			// dwcbMax
	TABLE_NAMES,				// dwTable
	szEXTENSIONVALUE,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_RDN,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongText,			// dbcoltyp
	0,					// dbcolumnid
    },
    DBTABLE_NULL	// Termination marker
};
#endif


//---------------------------------------------------------------------------
//
// Certificate Extensions Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtCertExtensions[] =
{
#if (DTE_REQUESTID != 0)
#error -- bad DTE_REQUESTID index
#endif
    {	// ColumnType: DWORD
	wszPROPEXTREQUESTID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szREQUESTID,				// pszFieldName
	szEXTENSION_REQUESTIDINDEX,		// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_EXTENSIONNAME != 1)
#error -- bad DTE_EXTENSIONNAME index
#endif
    {	// ColumnType: STRING
	wszPROPEXTNAME,				// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXREQUESTID,			// dwFlags
	CB_DBMAXTEXT_OID,			// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szEXTENSIONNAME,			// pszFieldName
	szEXTENSION_REQUESTIDNAMEINDEX,		// pszIndexName
	CB_DBMAXTEXT_OID,			// dbcolumnMax
	0,					// dbgrbit
	JET_coltypText,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_EXTENSIONFLAGS != 2)
#error -- bad DTE_EXTENSIONFLAGS index
#endif
    {	// ColumnType: DWORD
	wszPROPEXTFLAGS,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szEXTENSIONFLAGS,			// pszFieldName
	NULL,					// pszIndexName
	0,					// dbcolumnMax
	JET_bitColumnFixed,			// dbgrbit
	JET_coltypLong,				// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_EXTENSIONRAWVALUE != 3)
#error -- bad DTE_EXTENSIONRAWVALUE index
#endif
    {	// ColumnType: BLOB
	wszPROPEXTRAWVALUE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXBINARY,				// dwcbMax
	TABLE_EXTENSIONS,			// dwTable
	szEXTENSIONRAWVALUE,			// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXBINARY,				// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongBinary,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTE_MAX != 4)
#error -- bad DTE_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


//---------------------------------------------------------------------------
//
// CRL Table:
//
//---------------------------------------------------------------------------

DBTABLE g_adtCRLs[] =
{
#if (DTL_ROWID != 0)
#error -- bad DTL_ROWID index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLROWID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_INDEXPRIMARY,			// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLROWID,				// pszFieldName
        szCRL_ROWIDINDEX,			// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed | JET_bitColumnAutoincrement, // dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NUMBER != 1)
#error -- bad DTL_NUMBER index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLNUMBER,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNUMBER,				// pszFieldName
	szCRL_CRLNUMBERINDEX,			// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_MINBASE != 2)
#error -- bad DTL_MINBASE index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLMINBASE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLMINBASE,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NAMEID != 3)
#error -- bad DTL_NAMEID index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLNAMEID,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNAMEID,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_COUNT != 4)
#error -- bad DTL_COUNT index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLCOUNT,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLCOUNT,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_THISUPDATEDATE != 5)
#error -- bad DTL_THISUPDATEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLTHISUPDATE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLTHISUPDATE,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NEXTUPDATEDATE != 6)
#error -- bad DTL_NEXTUPDATEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLNEXTUPDATE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNEXTUPDATE,			// pszFieldName
	szCRL_CRLNEXTUPDATEINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_THISPUBLISHDATE != 7)
#error -- bad DTL_THISPUBLISHDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLTHISPUBLISH,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLTHISPUBLISH,			// pszFieldName
        NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_NEXTPUBLISHDATE != 8)
#error -- bad DTL_NEXTPUBLISHDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLNEXTPUBLISH,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLNEXTPUBLISH,			// pszFieldName
        szCRL_CRLNEXTPUBLISHINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_EFFECTIVEDATE != 9)
#error -- bad DTL_EFFECTIVEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLEFFECTIVE,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLEFFECTIVE,				// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PROPAGATIONCOMPLETEDATE != 10)
#error -- bad DTL_PROPAGATIONCOMPLETEDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLPROPAGATIONCOMPLETE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPROPAGATIONCOMPLETE,		// pszFieldName
	szCRL_CRLPROPAGATIONCOMPLETEINDEX,	// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_LASTPUBLISHEDDATE != 11)
#error -- bad DTL_LASTPUBLISHEDDATE index
#endif
    {	// ColumnType: FILETIME
	wszPROPCRLLASTPUBLISHED,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(DATE),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLLASTPUBLISHED,			// pszFieldName
	szCRL_CRLLASTPUBLISHEDINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypDateTime,			// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHATTEMPTS != 12)
#error -- bad DTL_PUBLISHATTEMPTS index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLPUBLISHATTEMPTS,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHATTEMPTS,			// pszFieldName
	szCRL_CRLPUBLISHATTEMPTSINDEX,		// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHFLAGS != 13)
#error -- bad DTL_PUBLISHFLAGS index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLPUBLISHFLAGS,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHFLAGS,			// pszFieldName
	NULL,					// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHSTATUSCODE != 14)
#error -- bad DTL_PUBLISHSTATUSCODE index
#endif
    {	// ColumnType: DWORD
	wszPROPCRLPUBLISHSTATUSCODE,		// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	sizeof(LONG),				// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHSTATUSCODE,			// pszFieldName
	szCRL_CRLPUBLSTATUSCODEISHINDEX,	// pszIndexName
        0,					// dbcolumnMax
        JET_bitColumnFixed,			// dbgrbit
        JET_coltypLong,				// dbcoltyp
        0					// dbcolumnid
    },
#if (DTL_PUBLISHERROR != 15)
#error -- bad DTL_PUBLISHERROR index
#endif
    {	// ColumnType: STRING
	wszPROPCRLPUBLISHERROR,			// pwszPropName
	NULL,					// pwszPropNameObjId
	DBTF_COLUMNRENAMED,			// dwFlags
	CB_DBMAXTEXT_DISPSTRING,		// dwcbMax
	TABLE_CRLS,				// dwTable
	szCRLPUBLISHERROR "\0" szCRLPUBLISHERROR_OLD, // pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXTEXT_DISPSTRING,		// dwcbMax
	0,					// dbgrbit
        JET_coltypLongText,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTL_RAWCRL != 16)
#error -- bad DTL_RAWCRL index
#endif
    {	// ColumnType: BLOB
	wszPROPCRLRAWCRL,			// pwszPropName
	NULL,					// pwszPropNameObjId
	0,					// dwFlags
	CB_DBMAXRAWCRL,				// dwcbMax
	TABLE_CRLS,				// dwTable
	szRAWCRL,				// pszFieldName
	NULL,					// pszIndexName
	CB_DBMAXRAWCRL,				// dbcolumnMax
	0,					// dbgrbit
	JET_coltypLongBinary,			// dbcoltyp
	0,					// dbcolumnid
    },
#if (DTL_MAX != 17)
#error -- bad DTL_MAX index
#endif
    DBTABLE_NULL	// Termination marker
};


DBAUXDATA g_dbauxRequests = {
    szREQUESTTABLE,				// pszTable
    szREQUEST_REQUESTIDINDEX,			// pszRowIdIndex
    NULL,					// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtRequests[DTR_REQUESTID],		// pdtRowId
    NULL,					// pdtName
    NULL,					// pdtFlags
    NULL,					// pdtValue
    NULL,					// pdtIssuerNameId
};


DBAUXDATA g_dbauxCertificates = {
    szCERTIFICATETABLE,				// pszTable
    szCERTIFICATE_REQUESTIDINDEX,		// pszRowIdIndex
    NULL,					// pszRowIdNameIndex
    szCERTIFICATE_SERIALNUMBERINDEX,		// pszNameIndex
    &g_adtCertificates[DTC_REQUESTID],		// pdtRowId
    &g_adtCertificates[DTC_CERTIFICATESERIALNUMBER],// pdtName
    NULL,					// pdtFlags
    NULL,					// pdtValue
    &g_adtCertificates[DTC_CERTIFICATEISSUERNAMEID],// pdtIssuerNameId
};


DBAUXDATA g_dbauxAttributes = {
    szREQUESTATTRIBUTETABLE,			// pszTable
    szATTRIBUTE_REQUESTIDINDEX,			// pszRowIdIndex
    szATTRIBUTE_REQUESTIDNAMEINDEX,		// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtRequestAttributes[DTA_REQUESTID],	// pdtRowId
    &g_adtRequestAttributes[DTA_ATTRIBUTENAME],	// pdtName
    NULL,					// pdtFlags
    &g_adtRequestAttributes[DTA_ATTRIBUTEVALUE],// pdtValue
    NULL,					// pdtIssuerNameId
};


DBAUXDATA g_dbauxExtensions = {
    szCERTIFICATEEXTENSIONTABLE,		// pszTable
    szEXTENSION_REQUESTIDINDEX,			// pszRowIdIndex
    szEXTENSION_REQUESTIDNAMEINDEX,		// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtCertExtensions[DTE_REQUESTID],	// pdtRowId
    &g_adtCertExtensions[DTE_EXTENSIONNAME],	// pdtName
    &g_adtCertExtensions[DTE_EXTENSIONFLAGS],	// pdtFlags
    &g_adtCertExtensions[DTE_EXTENSIONRAWVALUE],// pdtValue
    NULL,					// pdtIssuerNameId
};


DBAUXDATA g_dbauxCRLs = {
    szCRLTABLE,					// pszTable
    szCRL_ROWIDINDEX,				// pszRowIdIndex
    NULL,					// pszRowIdNameIndex
    NULL,					// pszNameIndex
    &g_adtCRLs[DTL_ROWID],			// pdtRowId
    NULL,					// pdtName
    NULL,					// pdtFlags
    NULL,					// pdtValue
    &g_adtCRLs[DTL_NAMEID],			// pdtIssuerNameId
};


DBCREATETABLE const g_actDataBase[] = {
  { szCERTIFICATETABLE,          &g_dbauxCertificates, g_adtCertificates },
  { szREQUESTTABLE,		 &g_dbauxRequests,     g_adtRequests },
  { szREQUESTATTRIBUTETABLE,     &g_dbauxAttributes,   g_adtRequestAttributes },
//{ szNAMEEXTENSIONTABLE,        &g_dbauxNameExtensions, g_adtNameExtensions },
  { szCERTIFICATEEXTENSIONTABLE, &g_dbauxExtensions,   g_adtCertExtensions },
  { szCRLTABLE,                  &g_dbauxCRLs,         g_adtCRLs },
  { NULL,			 NULL,		       NULL },
};


// Note: Ordered DUPTABLE must include all Names Table columns.

DUPTABLE const g_dntr[] =
{
    { "Country",             wszPROPSUBJECTCOUNTRY, },
    { "Organization",        wszPROPSUBJECTORGANIZATION, },
    { "OrganizationalUnit",  wszPROPSUBJECTORGUNIT, },
    { "CommonName",          wszPROPSUBJECTCOMMONNAME, },
    { "Locality",            wszPROPSUBJECTLOCALITY, },
    { "StateOrProvince",     wszPROPSUBJECTSTATE, },
    { "Title",               wszPROPSUBJECTTITLE, },
    { "GivenName",           wszPROPSUBJECTGIVENNAME, },
    { "Initials",            wszPROPSUBJECTINITIALS, },
    { "SurName",             wszPROPSUBJECTSURNAME, },
    { "DomainComponent",     wszPROPSUBJECTDOMAINCOMPONENT, },
    { "EMailAddress",        wszPROPSUBJECTEMAIL, },
    { "StreetAddress",       wszPROPSUBJECTSTREETADDRESS, },
    { "UnstructuredName",    wszPROPSUBJECTUNSTRUCTUREDNAME, },
    { "UnstructuredAddress", wszPROPSUBJECTUNSTRUCTUREDADDRESS, },
    { "DeviceSerialNumber",  wszPROPSUBJECTDEVICESERIALNUMBER, },
    { NULL,		     NULL },
};


DWORD g_aColumnViewQueue[] =
{
    DTI_REQUESTTABLE | DTR_REQUESTID,
    DTI_REQUESTTABLE | DTR_REQUESTERNAME,
    DTI_REQUESTTABLE | DTR_REQUESTSUBMITTEDWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTSTATUSCODE,
    DTI_REQUESTTABLE | DTR_REQUESTDISPOSITIONMESSAGE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATETEMPLATE,
    DTI_REQUESTTABLE | DTR_COMMONNAME,
    DTI_REQUESTTABLE | DTR_EMAIL,
    DTI_REQUESTTABLE | DTR_ORGUNIT,
    DTI_REQUESTTABLE | DTR_ORGANIZATION,
    DTI_REQUESTTABLE | DTR_LOCALITY,
    DTI_REQUESTTABLE | DTR_STATE,
    DTI_REQUESTTABLE | DTR_COUNTRY,
    DTI_REQUESTTABLE | DTR_REQUESTRAWREQUEST,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWOLDCERTIFICATE,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY,
    //DTI_REQUESTTABLE | DTR_REQUESTKEYRECOVERYHASHES,
    //DTI_REQUESTTABLE | DTR_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_TITLE,
    //DTI_REQUESTTABLE | DTR_GIVENNAME,
    //DTI_REQUESTTABLE | DTR_INITIALS,
    //DTI_REQUESTTABLE | DTR_SURNAME,
    //DTI_REQUESTTABLE | DTR_DOMAINCOMPONENT,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDNAME,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDADDRESS,
    //DTI_REQUESTTABLE | DTR_DEVICESERIALNUMBER,
    //DTI_REQUESTTABLE | DTR_RAWNAME,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,
    //DTI_REQUESTTABLE | DTR_REQUESTATTRIBUTES,
    //DTI_REQUESTTABLE | DTR_REQUESTTYPE,
    //DTI_REQUESTTABLE | DTR_REQUESTFLAGS,
    //DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
    //DTI_REQUESTTABLE | DTR_CALLERNAME,
    //DTI_REQUESTTABLE | DTR_SIGNERPOLICIES,
    //DTI_REQUESTTABLE | DTR_SIGNERAPPLICATIONPOLICIES,
    //DTI_REQUESTTABLE | DTR_OFFICER,
    //DTI_REQUESTTABLE | DTR_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_REQUESTID,
    //DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEENROLLMENTFLAGS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEGENERALFLAGS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTBEFOREDATE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATESUBJECTKEYIDENTIFIER,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEY,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYLENGTH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYALGORITHM,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEUPN,
    //DTI_CERTIFICATETABLE | DTC_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_RAWNAME,
    //DTI_CERTIFICATETABLE | DTC_COUNTRY,
    //DTI_CERTIFICATETABLE | DTC_ORGANIZATION,
    //DTI_CERTIFICATETABLE | DTC_ORGUNIT,
    //DTI_CERTIFICATETABLE | DTC_COMMONNAME,
    //DTI_CERTIFICATETABLE | DTC_LOCALITY,
    //DTI_CERTIFICATETABLE | DTC_STATE,
    //DTI_CERTIFICATETABLE | DTC_TITLE,
    //DTI_CERTIFICATETABLE | DTC_GIVENNAME,
    //DTI_CERTIFICATETABLE | DTC_INITIALS,
    //DTI_CERTIFICATETABLE | DTC_SURNAME,
    //DTI_CERTIFICATETABLE | DTC_DOMAINCOMPONENT,
    //DTI_CERTIFICATETABLE | DTC_EMAIL,
    //DTI_CERTIFICATETABLE | DTC_STREETADDRESS,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDNAME,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDADDRESS,
    //DTI_CERTIFICATETABLE | DTC_DEVICESERIALNUMBER,
};
DWORD g_cColumnViewQueue = ARRAYSIZE(g_aColumnViewQueue);


DWORD g_aColumnViewLog[] =
{
    DTI_REQUESTTABLE | DTR_REQUESTID,
    DTI_REQUESTTABLE | DTR_REQUESTERNAME,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTBEFOREDATE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATETEMPLATE,
    DTI_CERTIFICATETABLE | DTC_COMMONNAME,
    DTI_CERTIFICATETABLE | DTC_EMAIL,
    DTI_CERTIFICATETABLE | DTC_ORGUNIT,
    DTI_CERTIFICATETABLE | DTC_ORGANIZATION,
    DTI_CERTIFICATETABLE | DTC_LOCALITY,
    DTI_CERTIFICATETABLE | DTC_STATE,
    DTI_CERTIFICATETABLE | DTC_COUNTRY,
    DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
    //DTI_CERTIFICATETABLE | DTC_TITLE,
    //DTI_CERTIFICATETABLE | DTC_GIVENNAME,
    //DTI_CERTIFICATETABLE | DTC_INITIALS,
    //DTI_CERTIFICATETABLE | DTC_SURNAME,
    //DTI_CERTIFICATETABLE | DTC_DOMAINCOMPONENT,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDNAME,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDADDRESS,
    //DTI_CERTIFICATETABLE | DTC_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWREQUEST,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWOLDCERTIFICATE,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY,
    //DTI_REQUESTTABLE | DTR_REQUESTKEYRECOVERYHASHES,
    //DTI_REQUESTTABLE | DTR_REQUESTATTRIBUTES,
    //DTI_REQUESTTABLE | DTR_REQUESTTYPE,
    //DTI_REQUESTTABLE | DTR_REQUESTFLAGS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUSCODE,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITIONMESSAGE,
    //DTI_REQUESTTABLE | DTR_REQUESTSUBMITTEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
    //DTI_REQUESTTABLE | DTR_CALLERNAME,
    //DTI_REQUESTTABLE | DTR_SIGNERPOLICIES,
    //DTI_REQUESTTABLE | DTR_SIGNERAPPLICATIONPOLICIES,
    //DTI_REQUESTTABLE | DTR_OFFICER,
    //DTI_REQUESTTABLE | DTR_DISTINGUISHEDNAME,
    //DTI_REQUESTTABLE | DTR_RAWNAME,
    //DTI_REQUESTTABLE | DTR_COUNTRY,
    //DTI_REQUESTTABLE | DTR_ORGANIZATION,
    //DTI_REQUESTTABLE | DTR_ORGUNIT,
    //DTI_REQUESTTABLE | DTR_COMMONNAME,
    //DTI_REQUESTTABLE | DTR_LOCALITY,
    //DTI_REQUESTTABLE | DTR_STATE,
    //DTI_REQUESTTABLE | DTR_TITLE,
    //DTI_REQUESTTABLE | DTR_GIVENNAME,
    //DTI_REQUESTTABLE | DTR_INITIALS,
    //DTI_REQUESTTABLE | DTR_SURNAME,
    //DTI_REQUESTTABLE | DTR_DOMAINCOMPONENT,
    //DTI_REQUESTTABLE | DTR_EMAIL,
    //DTI_REQUESTTABLE | DTR_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDNAME,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDADDRESS,
    //DTI_REQUESTTABLE | DTR_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_REQUESTID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEENROLLMENTFLAGS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEGENERALFLAGS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATESUBJECTKEYIDENTIFIER,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEY,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYLENGTH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYALGORITHM,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEUPN,
    //DTI_CERTIFICATETABLE | DTC_RAWNAME,
};
DWORD g_cColumnViewLog = ARRAYSIZE(g_aColumnViewLog);


DWORD g_aColumnViewRevoked[] =
{
    DTI_REQUESTTABLE | DTR_REQUESTID,
    DTI_REQUESTTABLE | DTR_REQUESTERNAME,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTBEFOREDATE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATENOTAFTERDATE,
    DTI_CERTIFICATETABLE | DTC_CERTIFICATETEMPLATE,
    DTI_CERTIFICATETABLE | DTC_COMMONNAME,
    DTI_CERTIFICATETABLE | DTC_EMAIL,
    DTI_CERTIFICATETABLE | DTC_ORGUNIT,
    DTI_CERTIFICATETABLE | DTC_ORGANIZATION,
    DTI_CERTIFICATETABLE | DTC_LOCALITY,
    DTI_CERTIFICATETABLE | DTC_STATE,
    DTI_CERTIFICATETABLE | DTC_COUNTRY,
    DTI_CERTIFICATETABLE | DTC_RAWCERTIFICATE,
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDEFFECTIVEWHEN,
    DTI_REQUESTTABLE | DTR_REQUESTREVOKEDREASON,
    //DTI_CERTIFICATETABLE | DTC_TITLE,
    //DTI_CERTIFICATETABLE | DTC_GIVENNAME,
    //DTI_CERTIFICATETABLE | DTC_INITIALS,
    //DTI_CERTIFICATETABLE | DTC_SURNAME,
    //DTI_CERTIFICATETABLE | DTC_DOMAINCOMPONENT,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDNAME,
    //DTI_CERTIFICATETABLE | DTC_UNSTRUCTUREDADDRESS,
    //DTI_CERTIFICATETABLE | DTC_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_DISTINGUISHEDNAME,
    //DTI_CERTIFICATETABLE | DTC_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWREQUEST,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWOLDCERTIFICATE,
    //DTI_REQUESTTABLE | DTR_REQUESTRAWARCHIVEDKEY,
    //DTI_REQUESTTABLE | DTR_REQUESTKEYRECOVERYHASHES,
    //DTI_REQUESTTABLE | DTR_REQUESTATTRIBUTES,
    //DTI_REQUESTTABLE | DTR_REQUESTTYPE,
    //DTI_REQUESTTABLE | DTR_REQUESTFLAGS,
    //DTI_REQUESTTABLE | DTR_REQUESTSTATUSCODE,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION,
    //DTI_REQUESTTABLE | DTR_REQUESTDISPOSITIONMESSAGE,
    //DTI_REQUESTTABLE | DTR_REQUESTSUBMITTEDWHEN,
    //DTI_REQUESTTABLE | DTR_REQUESTRESOLVEDWHEN,
    //DTI_REQUESTTABLE | DTR_CALLERNAME,
    //DTI_REQUESTTABLE | DTR_SIGNERPOLICIES,
    //DTI_REQUESTTABLE | DTR_SIGNERAPPLICATIONPOLICIES,
    //DTI_REQUESTTABLE | DTR_OFFICER,
    //DTI_REQUESTTABLE | DTR_DISTINGUISHEDNAME,
    //DTI_REQUESTTABLE | DTR_RAWNAME,
    //DTI_REQUESTTABLE | DTR_COUNTRY,
    //DTI_REQUESTTABLE | DTR_ORGANIZATION,
    //DTI_REQUESTTABLE | DTR_ORGUNIT,
    //DTI_REQUESTTABLE | DTR_COMMONNAME,
    //DTI_REQUESTTABLE | DTR_LOCALITY,
    //DTI_REQUESTTABLE | DTR_STATE,
    //DTI_REQUESTTABLE | DTR_TITLE,
    //DTI_REQUESTTABLE | DTR_GIVENNAME,
    //DTI_REQUESTTABLE | DTR_INITIALS,
    //DTI_REQUESTTABLE | DTR_SURNAME,
    //DTI_REQUESTTABLE | DTR_DOMAINCOMPONENT,
    //DTI_REQUESTTABLE | DTR_EMAIL,
    //DTI_REQUESTTABLE | DTR_STREETADDRESS,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDNAME,
    //DTI_REQUESTTABLE | DTR_UNSTRUCTUREDADDRESS,
    //DTI_REQUESTTABLE | DTR_DEVICESERIALNUMBER,
    //DTI_CERTIFICATETABLE | DTC_REQUESTID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEENROLLMENTFLAGS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEGENERALFLAGS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEISSUERNAMEID,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATESUBJECTKEYIDENTIFIER,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEY,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYLENGTH,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEPUBLICKEYALGORITHM,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS,
    //DTI_CERTIFICATETABLE | DTC_CERTIFICATEUPN,
    //DTI_CERTIFICATETABLE | DTC_RAWNAME,
};
DWORD g_cColumnViewRevoked = ARRAYSIZE(g_aColumnViewRevoked);


DWORD g_aColumnViewExtension[] =
{
    DTI_EXTENSIONTABLE | DTE_REQUESTID,
    DTI_EXTENSIONTABLE | DTE_EXTENSIONNAME,
    DTI_EXTENSIONTABLE | DTE_EXTENSIONFLAGS,
    DTI_EXTENSIONTABLE | DTE_EXTENSIONRAWVALUE,
};
DWORD g_cColumnViewExtension = ARRAYSIZE(g_aColumnViewExtension);


DWORD g_aColumnViewAttribute[] =
{
    DTI_ATTRIBUTETABLE | DTA_REQUESTID,
    DTI_ATTRIBUTETABLE | DTA_ATTRIBUTENAME,
    DTI_ATTRIBUTETABLE | DTA_ATTRIBUTEVALUE,
};
DWORD g_cColumnViewAttribute = ARRAYSIZE(g_aColumnViewAttribute);


DWORD g_aColumnViewCRL[] =
{
    DTI_CRLTABLE | DTL_ROWID,
    DTI_CRLTABLE | DTL_NUMBER,
    DTI_CRLTABLE | DTL_MINBASE,
    DTI_CRLTABLE | DTL_NAMEID,
    DTI_CRLTABLE | DTL_COUNT,
    DTI_CRLTABLE | DTL_THISUPDATEDATE,
    DTI_CRLTABLE | DTL_NEXTUPDATEDATE,
    DTI_CRLTABLE | DTL_THISPUBLISHDATE,
    DTI_CRLTABLE | DTL_NEXTPUBLISHDATE,
    DTI_CRLTABLE | DTL_EFFECTIVEDATE,
    DTI_CRLTABLE | DTL_PROPAGATIONCOMPLETEDATE,
    DTI_CRLTABLE | DTL_LASTPUBLISHEDDATE,
    DTI_CRLTABLE | DTL_PUBLISHATTEMPTS,
    DTI_CRLTABLE | DTL_PUBLISHFLAGS,
    DTI_CRLTABLE | DTL_PUBLISHSTATUSCODE,
    DTI_CRLTABLE | DTL_PUBLISHERROR,
    DTI_CRLTABLE | DTL_RAWCRL,
};
DWORD g_cColumnViewCRL = ARRAYSIZE(g_aColumnViewCRL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\db.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "db.h"
#include "column.h"
#include "row.h"
#include "view.h"
#include "backup.h"
#include "restore.h"
#include "dbw.h"
#include <mimeole.h>

#define __dwFILE__	__dwFILE_CERTDB_DB_CPP__

// Table and Index Density (in percent), for page splits:
// Create tables and indexes with PCDENSITYSET.
// Reset to PCDENSITYRESET if below PCDENSITYMIN or above PCDENSITYMAX.
// Windows 2000 used 50% for indexes, 100% for tables (and primary indexes)!?!

#define PCDENSITYSET	0	// use reasonable default (80%?)
#define PCDENSITYMIN	60
#define PCDENSITYRESET	80	// reset to 80% if out of range
#define PCDENSITYMAX	95

#define ULTABLEPAGES	4

#define SEEKPOS_FIRST		0
#define SEEKPOS_LAST		1
#define SEEKPOS_INDEXFIRST	2
#define SEEKPOS_INDEXLAST	3

LONG g_cCertDB = 0;
LONG g_cCertDBTotal = 0;
LONG g_cXactCommit = 0;
LONG g_cXactAbort = 0;
LONG g_cXactTotal = 0;

char *g_pszDBFile = NULL;

typedef struct _DBJETPARM {
    DWORD paramid;
    DWORD lParam;
    char *pszParam;
    BOOL fString;
} DBJETPARM;

#define LANGID_DBFIXED	MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) // 0x409

#define CB_PROPFASTBUF	128


DBJETPARM g_aParm[] = {

#define JP_LOGPATH	0
    { JET_paramLogFilePath,        0,               NULL, TRUE },

#define JP_SYSTEMPATH	1
    { JET_paramSystemPath,         0,               NULL, TRUE },

#define JP_TEMPPATH	2
    { JET_paramTempPath,           0,               NULL, TRUE },

#define JP_EVENTSOURCE	3
    { JET_paramEventSource,        0,               NULL, TRUE },

#define JP_SESSIONMAX	4
    { JET_paramMaxSessions,        0,               NULL, FALSE },

#define JP_CACHESIZEMIN	5
    { JET_paramCacheSizeMin,	   64,		    NULL, FALSE },

#define JP_CACHESIZEMAX	6
    { JET_paramCacheSizeMax,	   512,		    NULL, FALSE },

#define JP_VERPAGESMAX	7
#define VERPAGESMULTIPLIER	64	// 64 * 16k units ==> 1mb per session
    { JET_paramMaxVerPages, VERPAGESMULTIPLIER * DBSESSIONCOUNTDEFAULT, NULL, FALSE },

#define JP_MAXCURSORS	8
#define MAXCURSORSMULTIPLIER	20 // 5 per table * 4 tables per session ==> 20
    { JET_paramMaxCursors,	   1024,	    NULL, FALSE },

#define JP_LOGBUFFERS	9
    { JET_paramLogBuffers,         41,              NULL, FALSE },

#define JP_LOGFILESIZE	10
    { JET_paramLogFileSize,        1024,            NULL, FALSE },

    { JET_paramRecovery,           0,               "on", TRUE },
    { JET_paramMaxTemporaryTables, 5,               NULL, FALSE },
    { JET_paramAssertAction,       JET_AssertBreak, NULL, FALSE },
    { JET_paramBaseName,           0,               szDBBASENAMEPARM, TRUE } // "edb"
};
#define CDBPARM	(sizeof(g_aParm)/sizeof(g_aParm[0]))


VOID
DBFreeParms()
{
    if (NULL != g_aParm[JP_LOGPATH].pszParam)
    {
	LocalFree(g_aParm[JP_LOGPATH].pszParam);
	g_aParm[JP_LOGPATH].pszParam = NULL;
    }
    if (NULL != g_aParm[JP_SYSTEMPATH].pszParam)
    {
	LocalFree(g_aParm[JP_SYSTEMPATH].pszParam);
	g_aParm[JP_SYSTEMPATH].pszParam = NULL;
    }
    if (NULL != g_aParm[JP_TEMPPATH].pszParam)
    {
	LocalFree(g_aParm[JP_TEMPPATH].pszParam);
	g_aParm[JP_TEMPPATH].pszParam = NULL;
    }
    if (NULL != g_aParm[JP_EVENTSOURCE].pszParam)
    {
	LocalFree(g_aParm[JP_EVENTSOURCE].pszParam);
	g_aParm[JP_EVENTSOURCE].pszParam = NULL;
    }
}


HRESULT
DBInitParms(
    IN DWORD cSession,
    IN DWORD DBFlags,
    OPTIONAL IN WCHAR const *pwszEventSource,
    OPTIONAL IN WCHAR const *pwszLogDir,
    OPTIONAL IN WCHAR const *pwszSystemDir,
    OPTIONAL IN WCHAR const *pwszTempDir,
    OUT JET_INSTANCE *pInstance)
{
    HRESULT hr = E_OUTOFMEMORY;
    HKEY hKey = NULL;
    DBJETPARM const *pjp;
    DWORD cwc;
    DWORD cwcT;
    WCHAR *pwszPath = NULL;
    WCHAR *pwszValueName = NULL;
    char *pszValue = NULL;
    BYTE *pbValue = NULL;
    DWORD i;

    DBFreeParms();

    cwc = 0;
    if (NULL != pwszLogDir)
    {
	cwcT = wcslen(pwszLogDir) + 1;
	if (cwc < cwcT)
	{
	    cwc = cwcT;
	}
    }
    if (NULL != pwszSystemDir)
    {
	cwcT = wcslen(pwszSystemDir) + 1;
	if (cwc < cwcT)
	{
	    cwc = cwcT;
	}
    }
    if (NULL != pwszTempDir)
    {
	cwcT = wcslen(pwszTempDir) + 1;
	if (cwc < cwcT)
	{
	    cwc = cwcT;
	}
    }
    if (0 != cwc)
    {
	pwszPath = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (cwc + 1));
	if (NULL == pwszPath)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    if (NULL != pwszLogDir)
    {
	wcscpy(pwszPath, pwszLogDir);
	wcscat(pwszPath, L"\\");
	CSASSERT(wcslen(pwszPath) <= cwc);
	if (!ConvertWszToSz(&g_aParm[JP_LOGPATH].pszParam, pwszPath, -1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(LogDir)");
	}
    }

    if (NULL != pwszSystemDir)
    {
	wcscpy(pwszPath, pwszSystemDir);
	wcscat(pwszPath, L"\\");
	CSASSERT(wcslen(pwszPath) <= cwc);
	if (!ConvertWszToSz(&g_aParm[JP_SYSTEMPATH].pszParam, pwszPath, -1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(SystemDir)");
	}
    }

    if (NULL != pwszTempDir)
    {
	wcscpy(pwszPath, pwszTempDir);
	wcscat(pwszPath, L"\\");
	CSASSERT(wcslen(pwszPath) <= cwc);
	if (!ConvertWszToSz(&g_aParm[JP_TEMPPATH].pszParam, pwszPath, -1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(TempDir)");
	}
    }

    if (NULL != pwszEventSource)
    {
	if (!ConvertWszToSz(
			&g_aParm[JP_EVENTSOURCE].pszParam,
			pwszEventSource,
			-1))
	{
	    _JumpError(hr, error, "ConvertWszToSz(EventSource)");
	}
    }

    g_aParm[JP_SESSIONMAX].lParam = cSession + 1;
    if (8 * cSession > g_aParm[JP_CACHESIZEMIN].lParam)
    {
	g_aParm[JP_CACHESIZEMIN].lParam = 8 * cSession;
    }
    if (8 * 8 * cSession > g_aParm[JP_CACHESIZEMAX].lParam)
    {
	g_aParm[JP_CACHESIZEMAX].lParam = 8 * 8 * cSession;
    }
    if (DBFLAGS_MAXCACHESIZEX100 & DBFlags)
    {
	// real fix is not to set this at all, but setting it to a large number
	// should suffice

	g_aParm[JP_CACHESIZEMAX].lParam *= 100;
    }
    if (VERPAGESMULTIPLIER * cSession > g_aParm[JP_VERPAGESMAX].lParam)
    {
	g_aParm[JP_VERPAGESMAX].lParam = VERPAGESMULTIPLIER * cSession;
    }
    if (MAXCURSORSMULTIPLIER * cSession > g_aParm[JP_MAXCURSORS].lParam)
    {
	g_aParm[JP_MAXCURSORS].lParam = MAXCURSORSMULTIPLIER * cSession;
    }

    if (DBFLAGS_LOGBUFFERSLARGE & DBFlags)
    {
	// default was 41

	g_aParm[JP_LOGBUFFERS].lParam = 256;
    }
    if (DBFLAGS_LOGBUFFERSHUGE & DBFlags)
    {
	// should be logfilesize (1024k) - 64k, specified in 512b units

	g_aParm[JP_LOGBUFFERS].lParam = 480;
    }
    if (DBFLAGS_LOGFILESIZE16MB & DBFlags)
    {
	// 16x the size we usually run with (16 * 1MB)

	g_aParm[JP_LOGFILESIZE].lParam = 16 * 1024;
    }
    for (pjp = g_aParm; pjp < &g_aParm[CDBPARM]; pjp++)
    {
	if (!pjp->fString || NULL != pjp->pszParam)
	{
	    _dbgJetSetSystemParameter(
				  pInstance,
				  0,
				  pjp->paramid,
				  pjp->lParam,
				  pjp->pszParam);
	}
    }
    if (DBFLAGS_CIRCULARLOGGING & DBFlags)
    {
	DBGPRINT((DBG_SS_CERTDB, "JetSetSystemParameter(Circular Log)\n"));
	_dbgJetSetSystemParameter(
			    pInstance,
			    0,
			    JET_paramCircularLog,
			    TRUE,
			    NULL);
    }
    if (DBFLAGS_LAZYFLUSH & DBFlags)
    {
	DBGPRINT((DBG_SS_CERTDB, "JetSetSystemParameter(Lazy Flush)\n"));
	_dbgJetSetSystemParameter(
			    pInstance,
			    0,
			    JET_paramCommitDefault,	
			    JET_bitCommitLazyFlush,
			    NULL);
    }


    if (DBFLAGS_CHECKPOINTDEPTH60MB & DBFlags)
    {
	// 60MB -- triple the size we usually run with (20MB)

	DBGPRINT((DBG_SS_CERTDB, "JetSetSystemParameter(CheckPoint Depth)\n"));
	_dbgJetSetSystemParameter(
			    pInstance,
			    0,
			    JET_paramCheckpointDepthMax,	
			    60 * 1024 * 1024,
			    NULL);
    }
    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    wszREGKEYCONFIGPATH_BS wszREGKEYDBPARAMETERS,
		    0,
		    KEY_READ,
		    &hKey);
    _PrintIfErrorStr2(
		hr,
		"RegOpenKeyEx",
		wszREGKEYCONFIGPATH_BS wszREGKEYDBPARAMETERS,
		hr);
    if (S_OK == hr)
    {
	DWORD cValue;
	DWORD cwcValueNameLenMax;
	DWORD cbValueLenMax;
#define CBPAD	(2 * sizeof(WCHAR) - 1)
	
	hr = RegQueryInfoKey(
		    hKey,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    NULL,
		    &cValue,
		    &cwcValueNameLenMax,
		    &cbValueLenMax,
		    NULL,
		    NULL);
	_JumpIfError(hr, error, "RegQueryInfoKey");

	pwszValueName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(WCHAR) * (cwcValueNameLenMax + 1));
	if (NULL == pwszValueName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, cbValueLenMax + CBPAD);
	if (NULL == pbValue)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	for (i = 0; i < cValue; i++)
	{
	    DWORD dwType;
	    DWORD cbValue;
	    LONG ParamId;
	    LONG lParam;
	    BOOL fValid;
	    
	    cwc = cwcValueNameLenMax + 1;
	    cbValue = cbValueLenMax;
	    if (!RegEnumValue(
			hKey,
			i,
			pwszValueName,
			&cwc,
			NULL,
			&dwType,
			pbValue,
			&cbValue))
	    {
		hr = myHLastError();
		_JumpIfError(hr, error, "VirtualAlloc");
	    }
	    ParamId = myWtoI(pwszValueName, &fValid);
	    if (!fValid)
	    {
		hr = E_INVALIDARG;
		_JumpErrorStr(hr, error, "fValid", pwszValueName);
	    }
	    lParam = 0;
	    if (NULL != pszValue)
	    {
		LocalFree(pszValue);
		pszValue = NULL;
	    }
	    switch (dwType)
	    {
		case REG_DWORD:
		    if (sizeof(lParam) != cbValue)
		    {
			hr = E_INVALIDARG;
			_JumpErrorStr(hr, error, "cbValue", pwszValueName);
		    }
		    lParam = *(LONG *) pbValue;
		    break;

		case REG_SZ:
		    ZeroMemory(&pbValue[cbValue], CBPAD);
		    if (!ConvertWszToSz(&pszValue, (WCHAR const *) pbValue, -1))
		    {
			_JumpError(hr, error, "ConvertWszToSz");
		    }
		    break;

		default:
		    hr = E_INVALIDARG;
		    _JumpErrorStr(hr, error, "dwType", pwszValueName);
	    }
	    CONSOLEPRINT3((
		DBG_SS_CERTDB,
		"JetSetSystemParameter(%u, %u, %hs)\n",
		ParamId,
		lParam,
		pszValue));
	    _dbgJetSetSystemParameter(
				pInstance,
				0,
				ParamId,
				lParam,
				pszValue);
	}
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    if (NULL != pszValue)
    {
        LocalFree(pszValue);
    }
    if (NULL != pwszValueName)
    {
        LocalFree(pwszValueName);
    }
    if (NULL != pbValue)
    {
        LocalFree(pbValue);
    }
    return(hr);
}


#if DBG_CERTSRV

WCHAR const *
wszCSFFlags(
    IN LONG Flags)
{
    static WCHAR s_awc[256];

    wsprintf(s_awc, L"{%x", Flags);

    if (CSF_INUSE & Flags)                 dbgcat(s_awc, L"InUse");
    if (CSF_READONLY & Flags)              dbgcat(s_awc, L"ReadOnly");
    if (CSF_CREATE & Flags)                dbgcat(s_awc, L"Create");
    if (CSF_VIEW & Flags)                  dbgcat(s_awc, L"View");
    if (CSF_VIEWRESET & Flags)             dbgcat(s_awc, L"ViewReset");

    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszCSTFlags(
    IN LONG Flags)
{
    static WCHAR s_awc[256];

    wsprintf(s_awc, L"{%x", Flags);

    if (CST_SEEKINDEXRANGE & Flags)        dbgcat(s_awc, L"IndexRange");
    if (CST_SEEKNOTMOVE & Flags)           dbgcat(s_awc, L"SeekNotMove");
    if (CST_SEEKUSECURRENT & Flags)        dbgcat(s_awc, L"UseCurrent");
    if (0 == (CST_SEEKUSECURRENT & Flags)) dbgcat(s_awc, L"SkipCurrent");
    if (CST_SEEKASCEND & Flags)            dbgcat(s_awc, L"Ascend");
    if (0 == (CST_SEEKASCEND & Flags))     dbgcat(s_awc, L"Descend");

    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszTable(
    IN DWORD dwTable)
{
    WCHAR const *pwsz;

    switch (dwTable)
    {
	case TABLE_REQUESTS:
	    pwsz = wszREQUESTTABLE;
	    break;

	case TABLE_CERTIFICATES:
	    pwsz = wszCERTIFICATETABLE;
	    break;

	case TABLE_ATTRIBUTES:
	    pwsz = wszREQUESTATTRIBUTETABLE;
	    break;

	case TABLE_EXTENSIONS:
	    pwsz = wszCERTIFICATEEXTENSIONTABLE;
	    break;

	case TABLE_CRLS:
	    pwsz = wszCRLTABLE;
	    break;

	default:
	    pwsz = L"???";
	    break;
    }
    return(pwsz);
}


WCHAR const *
wszSeekOperator(
    IN LONG SeekOperator)
{
    WCHAR const *pwsz;
    static WCHAR s_wszBuf[10 + cwcDWORDSPRINTF];

    switch (CVR_SEEK_MASK & SeekOperator)
    {
	case CVR_SEEK_NONE: pwsz = L"None"; break;
	case CVR_SEEK_EQ:   pwsz = L"==";   break;
	case CVR_SEEK_LT:   pwsz = L"<";    break;
	case CVR_SEEK_LE:   pwsz = L"<=";   break;
	case CVR_SEEK_GE:   pwsz = L">=";   break;
	case CVR_SEEK_GT:   pwsz = L">";    break;
	default:
	    wsprintf(s_wszBuf, L"???=%x", SeekOperator);
	    pwsz = s_wszBuf;
	    break;
    }
    if (s_wszBuf != pwsz && (CVR_SEEK_NODELTA & SeekOperator))
    {
	wcscpy(s_wszBuf, pwsz);
	wcscat(s_wszBuf, L",NoDelta");
	pwsz = s_wszBuf;
    }

    return(pwsz);
}


WCHAR const *
wszSortOperator(
    IN LONG SortOrder)
{
    WCHAR const *pwsz;
    static WCHAR s_wszBuf[10 + cwcDWORDSPRINTF];

    switch (SortOrder)
    {
	case CVR_SORT_NONE:    pwsz = L"None";    break;
	case CVR_SORT_ASCEND:  pwsz = L"Ascend";  break;
	case CVR_SORT_DESCEND: pwsz = L"Descend"; break;
	default:
	    wsprintf(s_wszBuf, L"???=%x", SortOrder);
	    pwsz = s_wszBuf;
	    break;
    }
    return(pwsz);
}


VOID
dbDumpFileTime(
    IN DWORD dwSubSystemId,
    IN CHAR const *pszPrefix,
    IN FILETIME const *pft)
{
    HRESULT hr;
    WCHAR *pwsz;

    hr = myGMTFileTimeToWszLocalTime(pft, TRUE, &pwsz);
    if (S_OK == hr)
    {
	DBGPRINT((dwSubSystemId, "%hs%ws\n", pszPrefix, pwsz));
	LocalFree(pwsz);
    }
}


VOID
dbDumpValue(
    IN DWORD dwSubSystemId,
    OPTIONAL IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue)
{
    if (NULL != pdt && NULL != pbValue && ISTEXTCOLTYP(pdt->dbcoltyp))
    {
	cbValue += sizeof(WCHAR);
    }
    if (JET_coltypDateTime == pdt->dbcoltyp && sizeof(FILETIME) == cbValue)
    {
	dbDumpFileTime(dwSubSystemId, "", (FILETIME const *) pbValue);
    }
    DBGDUMPHEX((dwSubSystemId, DH_NOADDRESS, pbValue, cbValue));
}


VOID
CCertDB::DumpRestriction(
    IN DWORD dwSubSystemId,
    IN LONG i,
    IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    WCHAR wszColumn[5 + cwcDWORDSPRINTF];
    DBTABLE const *pdt;
    WCHAR const *pwszTable = L"???";
    WCHAR const *pwszCol;

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    if (S_OK != hr)
    {
	_PrintError(hr, "_MapPropIdIndex");
	wsprintf(wszColumn, L"???=%x", pcvr->ColumnIndex);
	pdt = NULL;
	pwszCol = wszColumn;
    }
    else
    {
	pwszCol = pdt->pwszPropName;
	pwszTable = wszTable(pdt->dwTable);
    }


    DBGPRINT((
	dwSubSystemId,
	"Restriction[%d]: Col=%ws.%ws\n"
	    "        Seek='%ws' Sort=%ws cb=%x, pb=%x\n",
	i,
	pwszTable,
	pwszCol,
	wszSeekOperator(pcvr->SeekOperator),
	wszSortOperator(pcvr->SortOrder),
	pcvr->cbValue,
	pcvr->pbValue));
    dbDumpValue(dwSubSystemId, pdt, pcvr->pbValue, pcvr->cbValue);
}


VOID
dbDumpColumn(
    IN DWORD dwSubSystemId,
    IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue)
{
    DBGPRINT((dwSubSystemId, "Column: cb=%x pb=%x\n", cbValue, pbValue));
    dbDumpValue(dwSubSystemId, pdt, pbValue, cbValue);
}


DBAUXDATA const *
dbGetAuxTable(
    IN CERTSESSION *pcs,
    IN JET_TABLEID  tableid)
{
    DBAUXDATA const *pdbaux;

    CSASSERT(IsValidJetTableId(tableid));
    if (tableid == pcs->aTable[CSTI_CERTIFICATE].TableId)
    {
	pdbaux = &g_dbauxCertificates;
    }
    else if (tableid == pcs->aTable[CSTI_ATTRIBUTE].TableId)
    {
	pdbaux = &g_dbauxAttributes;
    }
    else if (tableid == pcs->aTable[CSTI_EXTENSION].TableId)
    {
	pdbaux = &g_dbauxExtensions;
    }
    else
    {
	CSASSERT(tableid == pcs->aTable[CSTI_PRIMARY].TableId);

	pdbaux = &g_dbauxRequests;
	switch (CSF_TABLEMASK & pcs->SesFlags)
	{
	    case TABLE_CERTIFICATES:
		pdbaux = &g_dbauxCertificates;
		break;

	    case TABLE_ATTRIBUTES:
		pdbaux = &g_dbauxAttributes;
		break;

	    case TABLE_EXTENSIONS:
		pdbaux = &g_dbauxExtensions;
		break;

	    case TABLE_CRLS:
		pdbaux = &g_dbauxCRLs;
		break;
	}
    }
    return(pdbaux);
}


HRESULT
CCertDB::_DumpRowId(
    IN CHAR const  *psz,
    IN CERTSESSION *pcs,
    IN JET_TABLEID  tableid)
{
    HRESULT hr;

#define DBG_SS_DUMPREQUESTID	DBG_SS_CERTDBI

    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    if (DbgIsSSActive(DBG_SS_DUMPREQUESTID))
    {
	DWORD cb;
	DWORD dwTmp;
	DBAUXDATA const *pdbaux = dbGetAuxTable(pcs, tableid);
	WCHAR awchr[cwcHRESULTSTRING];

	cb = sizeof(dwTmp);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtRowId,
			pdbaux->pdtRowId->dbcolumnid,
			NULL,
			&cb,
			(BYTE *) &dwTmp);
	if (S_OK != hr)
	{
	    DBGPRINT((
		    DBG_SS_DUMPREQUESTID,
		    "%hs: %hs.RowId: pcs=%d: %ws\n",
		    psz,
		    pdbaux->pszTable,
		    pcs->RowId,
		    myHResultToString(awchr, hr)));
	    _JumpError2(hr, error, "_RetrieveColumn", hr);
	}

	DBGPRINT((
		DBG_SS_DUMPREQUESTID,
		"%hs: %hs.RowId: pcs=%d dbcol=%d\n",
		psz,
		pdbaux->pszTable,
		pcs->RowId,
		dwTmp));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::_DumpColumn(
    IN CHAR const    *psz,
    IN CERTSESSION   *pcs,
    IN JET_TABLEID    tableid,
    IN DBTABLE const *pdt,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn)
{
    HRESULT hr;
    BYTE rgbFastBuf[CB_PROPFASTBUF];
    DWORD cb;
    BYTE *pb = rgbFastBuf;

    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    CSASSERT(0 != pdt->dbcolumnid);
    if (DbgIsSSActive(DBG_SS_CERTDBI))
    {
	DBAUXDATA const *pdbaux = dbGetAuxTable(pcs, tableid);
	BOOL fIsText;

	cb = sizeof(rgbFastBuf);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdt,
			pdt->dbcolumnid,
			pIComputedColumn,
			&cb,
			pb);
	if (S_OK != hr)
	{
	    if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
	    {
		_JumpError(hr, error, "_RetrieveColumn");
	    }
            CSASSERT(sizeof(rgbFastBuf) < cb);

	    pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
            if (NULL == pb)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdt,
			    pdt->dbcolumnid,
			    pIComputedColumn,
			    &cb,
			    pb);
	    _JumpIfError(hr, error, "_RetrieveColumn");
	}

	fIsText = ISTEXTCOLTYP(pdt->dbcoltyp);

	DBGPRINT((
		DBG_SS_CERTDBI,
		"%hs: _DumpColumn(%hs, %hs): Value:%hs%ws%hs\n",
		psz,
		pdbaux->pszTable,
		pdt->pszFieldName,
		fIsText? " '" : "",
		fIsText? (WCHAR *) pb : L"",
		fIsText? "'" : ""));
	dbDumpValue(DBG_SS_CERTDBI, pdt, pb, cb);
    }
    hr = S_OK;

error:
    if (NULL != pb && rgbFastBuf != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}
#endif // DBG_CERTSRV



CCertDB::CCertDB()
{
    HRESULT hr;
    
    InterlockedIncrement(&g_cCertDB);
    InterlockedIncrement(&g_cCertDBTotal);
    m_Instance = 0;
    m_fDBOpen = FALSE;
    m_fDBRestart = FALSE;
    m_fPendingShutDown = FALSE;
    m_fFoundOldColumns = FALSE;
    m_fAddedNewColumns = FALSE;
    m_aSession = NULL;
    m_cSession = 0;
    m_cbPage = 0;
    m_cCritSec = 0;
    __try
    {
	InitializeCriticalSection(&m_critsecSession);
	m_cCritSec++;
	InitializeCriticalSection(&m_critsecAutoIncTables);
	m_cCritSec++;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
}


CCertDB::~CCertDB()
{
    ShutDown(0);
    if (0 < m_cCritSec)
    {
	DeleteCriticalSection(&m_critsecSession);
	if (1 < m_cCritSec)
	{
	    DeleteCriticalSection(&m_critsecAutoIncTables);
	}
    }
    InterlockedDecrement(&g_cCertDB);
}


STDMETHODIMP
CCertDB::Open(
    /* [in] */ DWORD DBFlags,
    /* [in] */ DWORD cSession,
    /* [in] */ WCHAR const *pwszEventSource,
    /* [in] */ WCHAR const *pwszDBFile,
    /* [in] */ WCHAR const *pwszLogDir,
    /* [in] */ WCHAR const *pwszSystemDir,
    /* [in] */ WCHAR const *pwszTempDir)
{
    HRESULT hr;
    DWORD i;
    DBCREATETABLE const *pct;
    JET_GRBIT grbit;
    DWORD CreateFlags;
    CERTSESSION *pcs = NULL;

    if (NULL == pwszDBFile ||
	NULL == pwszLogDir ||
	NULL == pwszSystemDir ||
	NULL == pwszTempDir)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    if (0 == (DBFLAGS_DISABLESNAPSHOTBACKUP & DBFlags))
    {
	hr = InitGlobalWriterState();
	_JumpIfError(hr, error, "InitGlobalWriterState");
    }

    m_fDBOpen = FALSE;
    m_fDBRestart = FALSE;
    m_fDBReadOnly = (DBFLAGS_READONLY & DBFlags)? TRUE : FALSE;

    CSASSERT(NULL == m_aSession); // code assumes we do not have session
    m_cSession = 0;
    m_aSession = (CERTSESSION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cSession * sizeof(m_aSession[0]));
    hr = E_OUTOFMEMORY;
    if (NULL == m_aSession)
    {
	_JumpError(hr, error, "LocalAlloc(m_aSession)");
    }
    for (i = 0; i < cSession; i++)
    {
	m_aSession[i].SesId = MAXDWORD;
	m_aSession[i].DBId = MAXDWORD;
    }

    if (!ConvertWszToSz(&g_pszDBFile, pwszDBFile, -1))
    {
	_JumpError(hr, error, "ConvertWszToSz(DBFile)");
    }

    hr = DBInitParms(
		cSession,
                DBFlags,
		pwszEventSource,
		pwszLogDir,
		pwszSystemDir,
		pwszTempDir,
		&m_Instance);
    _JumpIfError(hr, error, "DBInitParms");

    hr = _dbgJetInit(&m_Instance);
    if ((HRESULT) JET_errLogFileSizeMismatchDatabasesConsistent == hr ||
	(HRESULT) JET_errLogFileSizeMismatch == hr)
    {
	_PrintError(hr, "JetInit(old log file size)");
	_dbgJetSetSystemParameter(
			    &m_Instance,
			    0,
			    JET_paramLogFileSize,
			    1000,
			    NULL);
	hr = _dbgJetInit(&m_Instance);
    }
    _JumpIfError(
	    hr,
	    error,
	    (HRESULT) JET_errFileAccessDenied == hr?
		"JetInit(Server already running?)" :
		"JetInit(JetSetSystemParameter problem?)");

    for (i = 0; i < cSession; i++)
    {
	hr = _dbgJetBeginSession(m_Instance, &m_aSession[i].SesId, NULL, NULL);
	_JumpIfError(hr, error, "_dbgJetBeginSession");

	m_cSession++;

	if (0 == i)
	{
	    CreateFlags = 0;
	    grbit = m_fDBReadOnly?
		JET_bitDbReadOnly : JET_bitDbDeleteCorruptIndexes;

	    hr = _dbgJetAttachDatabase(
			        m_aSession[i].SesId,
			        g_pszDBFile,
				grbit);
	    if ((HRESULT) JET_errFileNotFound == hr &&
		(DBFLAGS_CREATEIFNEEDED & DBFlags))
	    {
		DBGPRINT((DBG_SS_CERTDB, "Creating Database\n"));
		CreateFlags |= CF_DATABASE;
	    }
	    else
	    if ((HRESULT) JET_wrnCorruptIndexDeleted == hr)
	    {
		// Rebuild deleted indexes over Unicode columns...

		DBGPRINT((DBG_SS_CERTDB, "Creating Database Indexes\n"));
		CreateFlags |= CF_MISSINGINDEXES;
	    }
	    else
	    if ((HRESULT) JET_wrnDatabaseAttached != hr)
	    {
		_JumpIfError(hr, error, "JetAttachDatabase");
	    }
	    if (m_fDBReadOnly)
	    {
		if (CreateFlags)
		{
		    hr = E_ACCESSDENIED;
		    _JumpError(hr, error, "ReadOnly");
		}
	    }
	    else
	    {
		CreateFlags |= CF_MISSINGTABLES | CF_MISSINGCOLUMNS;
		hr = _Create(CreateFlags, g_pszDBFile);
		_JumpIfError(hr, error, "_Create");
	    }
	}

	hr = _dbgJetOpenDatabase(
			  m_aSession[i].SesId,
			  g_pszDBFile,
			  NULL,
			  &m_aSession[i].DBId,
			  0);
	_JumpIfError(hr, error, "JetOpenDatabase");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    for (pct = g_actDataBase; NULL != pct->pszTableName; pct++)
    {
	hr = _BuildColumnIds(pcs, pct->pszTableName, pct->pdt);
	_JumpIfError(hr, error, "_BuildColumnIds");
    }
    if (!m_fDBReadOnly)
    {
	for (pct = g_actDataBase; NULL != pct->pszTableName; pct++)
	{
	    hr = _ConvertOldColumnData(
				pcs,
				pct->pszTableName,
				pct->pdbaux,
				pct->pdt);
	    _JumpIfError(hr, error, "_ConvertOldColumnData");
	}
    }
    m_fDBOpen = TRUE;

error:
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    hr = myJetHResult(hr);
    if (S_OK == hr && m_fDBRestart)
    {
	hr = S_FALSE;	// Restart required for DB changes to take effect.
	_PrintError(hr, "m_fDBRestart");
    }
    return(hr);
}


STDMETHODIMP
CCertDB::ShutDown(
    /* [in] */ DWORD dwFlags)
{
    HRESULT hr;

    // Fix Jet failure after upgrade. When starting certsrv calls Open twice, 
    // first to trigger the db upgrade, then the real open. m_fFoundOldColumns
    // doesn't get cleared so the second open attempts another upgrade and fails.
    m_fFoundOldColumns = FALSE;

    if (CDBSHUTDOWN_PENDING == dwFlags)
    {
	m_fPendingShutDown = TRUE;
	hr = _dbgJetStopService();	// fail all future Jet calls
	_PrintIfError(hr, "JetStopService");
    }
    else
    {
	hr = S_OK;
	if (NULL != m_aSession)
	{
	    DBGPRINT((DBG_SS_CERTDB, "Database shutdown...\n"));

#if 0	// Avoid useless thread context asserts

	    DWORD i;

	    for (i = 0; i < m_cSession; i++)
	    {
		hr = _dbgJetEndSession(
				    m_aSession[i].SesId,
				    JET_bitForceSessionClosed);
		_PrintIfError(hr, "JetEndSession");
	    }
#endif

	    hr = _dbgJetTerm2(m_Instance, JET_bitTermComplete);
	    if (S_OK != hr)
	    {
		_PrintError(hr, "JetTerm2");
		hr = _dbgJetTerm2(m_Instance, JET_bitTermAbrupt);
		_PrintIfError(hr, "JetTerm2(Abrupt)");
	    }
	    DBGPRINT((DBG_SS_CERTDB, "Database shutdown complete\n"));

	    LocalFree(m_aSession);
	    m_aSession = NULL;
	}
	if (NULL != g_pszDBFile)
	{
	    LocalFree(g_pszDBFile);
	    g_pszDBFile = NULL;
	}
	DBFreeParms();
	UnInitGlobalWriterState();
    }

//error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BeginTransaction(
    IN CERTSESSION *pcs,
    IN BOOL fPrepareUpdate)
{
    HRESULT hr;
    BOOL fTransacted = FALSE;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (0 != pcs->cTransact)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "Nested transaction");
    }
    CSASSERTTHREAD(pcs);
    hr = _dbgJetBeginTransaction(pcs->SesId);
    _JumpIfError(hr, error, "JetBeginTransaction");

    fTransacted = TRUE;

    if (fPrepareUpdate)
    {
        CSASSERTTHREAD(pcs);
	for (i = 0; i < CSTI_MAX; i++)
	{
	    if (IsValidJetTableId(pcs->aTable[i].TableId))
	    {
		hr = _dbgJetPrepareUpdate(
				    pcs->SesId,
				    pcs->aTable[i].TableId,
				    JET_prepReplace);
		_JumpIfError(hr, error, "JetPrepareUpdate");
	    }
	}
    }
    pcs->cTransact++;
    InterlockedIncrement(&g_cXactTotal);
    hr = S_OK;

error:
    if (S_OK != hr && fTransacted)
    {
	HRESULT hr2;

	CSASSERTTHREAD(pcs);
	hr2 = _Rollback(pcs);
	_PrintIfError(hr2, "_Rollback");
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CommitTransaction(
    IN CERTSESSION *pcs,
    IN BOOL fCommit,
    IN BOOL fLazyFlush)
{
    HRESULT hr;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(0 != pcs->cTransact);

    if (fCommit)
    {
	if (0 == (CSF_DELETE & pcs->SesFlags))
	{
	    for (i = 0; i < CSTI_MAXDIRECT; i++)
	    {
		if (IsValidJetTableId(pcs->aTable[i].TableId))
		{
		    hr = _UpdateTable(pcs, pcs->aTable[i].TableId);
		    _JumpIfError(hr, error, "_UpdateTable");
		}
	    }
	}
	CSASSERTTHREAD(pcs);
	hr = _dbgJetCommitTransaction(pcs->SesId, fLazyFlush?JET_bitCommitLazyFlush:0);
	_JumpIfError(hr, error, "JetCommitTransaction");
    }
    else
    {
	hr = _Rollback(pcs);
	_JumpIfError(hr, error, "_Rollback");
    }
    pcs->cTransact--;
    if (fCommit)
    {
	InterlockedIncrement(&g_cXactCommit);
    }
    else
    {
	InterlockedIncrement(&g_cXactAbort);
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_AllocateSession(
    OUT CERTSESSION **ppcs)
{
    HRESULT hr;
    DWORD i;
    BOOL fEnterCritSec = FALSE;

    CSASSERT(NULL != ppcs);

    *ppcs = NULL;

    if (0 == m_cCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
	_JumpError(hr, error, "InitializeCriticalSection failure");
    }
    EnterCriticalSection(&m_critsecSession);
    fEnterCritSec = TRUE;

    for (i = 0; 0 != m_aSession[i].SesFlags; i++)
    {
	if (i + 1 == m_cSession)
	{
	    hr = CERTSRV_E_NO_DB_SESSIONS;
	    _JumpIfError(hr, error, "no more sessions");
	}
    }
    *ppcs = &m_aSession[i];
    CSASSERT(0 == (*ppcs)->RowId);
    (*ppcs)->SesFlags = CSF_INUSE;
    (*ppcs)->dwThreadId = GetCurrentThreadId();
    ZeroMemory((*ppcs)->aTable, sizeof((*ppcs)->aTable));
    hr = S_OK;

error:
    if (fEnterCritSec)
    {
	LeaveCriticalSection(&m_critsecSession);
    }
    return(hr);
}


HRESULT
CCertDB::_OpenTableRow(
    IN CERTSESSION *pcs,
    IN DBAUXDATA const *pdbaux,
    OPTIONAL IN CERTVIEWRESTRICTION const *pcvr,
    OUT CERTSESSIONTABLE *pTable,
    OUT DWORD *pdwRowIdMismatch)
{
    HRESULT hr;
    DWORD dwRowId;
    DWORD cb;

    CSASSERT(NULL == pTable->TableId);
    CSASSERT(0 == pTable->TableFlags);
    *pdwRowIdMismatch = 0;

    if (CSF_CREATE & pcs->SesFlags)
    {
	CSASSERT(NULL == pcvr);
        CSASSERTTHREAD(pcs);
	hr = _dbgJetOpenTable(
			   pcs->SesId,
			   pcs->DBId,
			   pdbaux->pszTable,
			   NULL,
			   0,
			   0,
			   &pTable->TableId);
	_JumpIfError(hr, error, "JetOpenTable");
    }
    else
    {
	if (NULL == pcvr)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
	}
	hr = _OpenTable(pcs, pdbaux, pcvr, pTable);
	if (S_FALSE == hr)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	}
	_JumpIfError2(hr, error, "_OpenTable", CERTSRV_E_PROPERTY_EMPTY);
    }

    if (!((CSF_READONLY | CSF_DELETE) & pcs->SesFlags))
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetPrepareUpdate(
			    pcs->SesId,
			    pTable->TableId,
			    (CSF_CREATE & pcs->SesFlags)?
				JET_prepInsert : JET_prepReplace);
	_JumpIfError(hr, error, "JetPrepareUpdate");
    }

    // Requests table RequestId column is JET_bitColumnAutoincrement.
    // Certificates table RequestId column is manually initialized here.
    //
    // When creating a Certificates table row, the RequestId column must be
    // set from pcs->RowId, which must already have been set by first creating
    // the Requests table row.
    //
    // When opening an existing row in either table, just fetch the column.

    CSASSERTTHREAD(pcs);
    hr = _dbgJetRetrieveColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtRowId->dbcolumnid,
			&dwRowId,
			sizeof(dwRowId),
			&cb,
			JET_bitRetrieveCopy,
			NULL);
    if ((HRESULT) JET_wrnColumnNull == hr)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
    }
    _PrintIfError2(hr, "JetRetrieveColumn", CERTSRV_E_PROPERTY_EMPTY);
    if (S_OK != hr || 0 == dwRowId)
    {
	CSASSERT(CSF_CREATE & pcs->SesFlags);
	if (0 == (CSF_CREATE & pcs->SesFlags))
	{
	    if (S_OK == hr)
	    {
		hr = CERTSRV_E_PROPERTY_EMPTY;
	    }
	    _JumpError(hr, error, "JetRetrieveColumn");
	}
	dwRowId = pcs->RowId;
	hr = _dbgJetSetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtRowId->dbcolumnid,
			&dwRowId,
			sizeof(dwRowId),
			0,
			NULL);
	_JumpIfError(hr, error, "JetSetColumn");
    }
    else if (0 == pcs->RowId)
    {
	pcs->RowId = dwRowId;
    }

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_OpenTableRow:%hs %hs --> RowId=%d(dwRowId(RetrieveColumn)=%d)\n",
	    (CSF_CREATE & pcs->SesFlags)? " (Create)" : "",
	    pdbaux->pszTable,
	    pcs->RowId,
            dwRowId));
    CSASSERT(0 != pcs->RowId);
    if (pcs->RowId > dwRowId)
    {
	*pdwRowIdMismatch = dwRowId;
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "Missing autoincrement RowId");
    }
    CSASSERT(pcs->RowId == dwRowId);

error:
    if (S_OK != hr)
    {
	if (IsValidJetTableId(pTable->TableId))
	{
	    HRESULT hr2;

            CSASSERTTHREAD(pcs);
	    hr2 = _dbgJetCloseTable(pcs->SesId, pTable->TableId);
	    _PrintIfError(hr2, "JetCloseTable");
	}
	ZeroMemory(pTable, sizeof(*pTable));
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::OpenTables(
    IN CERTSESSION *pcs,
    OPTIONAL IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    BOOL fCertTableFirst = FALSE;
    BOOL fCertTableLast = FALSE;
    CERTVIEWRESTRICTION cvrRowId;
    CERTVIEWRESTRICTION const *pcvrPrimary;
    CERTVIEWRESTRICTION const *pcvrCertificates;
    BOOL fEnterCritSec = FALSE;
    DBAUXDATA const *pdbauxPrimary;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    pcvrPrimary = pcvr;
    pcvrCertificates = NULL;
    pdbauxPrimary = &g_dbauxRequests;
    if (TABLE_REQCERTS == (CSF_TABLEMASK & pcs->SesFlags))
    {
	fCertTableLast = TRUE;
	if (NULL != pcvr)
	{
	    cvrRowId.SeekOperator = CVR_SEEK_EQ;
	    cvrRowId.SortOrder = CVR_SORT_ASCEND;
	    cvrRowId.pbValue = (BYTE *) &pcs->RowId;
	    cvrRowId.cbValue = sizeof(pcs->RowId);

	    switch (DTI_TABLEMASK & pcvr->ColumnIndex)
	    {
		case DTI_REQUESTTABLE:
		    pcvrCertificates = &cvrRowId;
		    cvrRowId.ColumnIndex = DTI_CERTIFICATETABLE | DTC_REQUESTID;
		    break;

		case DTI_CERTIFICATETABLE:
		    fCertTableLast = FALSE;
		    fCertTableFirst = TRUE;
		    pcvrCertificates = pcvr;
		    pcvrPrimary = &cvrRowId;
		    cvrRowId.ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTID;
		    break;

		default:
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "ColumnIndex Table");
	    }
	}
    }
    else
    {
	switch (CSF_TABLEMASK & pcs->SesFlags)
	{
	    case TABLE_ATTRIBUTES:
		pdbauxPrimary = &g_dbauxAttributes;
		break;

	    case TABLE_EXTENSIONS:
		pdbauxPrimary = &g_dbauxExtensions;
		break;

	    case TABLE_CRLS:
		pdbauxPrimary = &g_dbauxCRLs;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad table");
	}
    }

    if (1 >= m_cCritSec)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DLL_INIT_FAILED);
	_JumpError(hr, error, "InitializeCriticalSection failure");
    }

    EnterCriticalSection(&m_critsecAutoIncTables);
    fEnterCritSec = TRUE;

    hr = S_OK;
    __try
    {
	DWORD dwRowIdMismatch;

	if (fCertTableFirst)
	{
	    hr = _OpenTableRow(
			pcs,
			&g_dbauxCertificates,
			pcvrCertificates,
			&pcs->aTable[CSTI_CERTIFICATE],
			&dwRowIdMismatch);
	    _LeaveIfError2(hr, "_OpenTableRow", CERTSRV_E_PROPERTY_EMPTY);

	    CSASSERT(0 != pcs->RowId);
	    CSASSERT(IsValidJetTableId(pcs->aTable[CSTI_CERTIFICATE].TableId));
	    DBGPRINT((
		DBG_SS_CERTDBI,
		"OpenTables: %hs: %ws\n",
		g_dbauxCertificates.pszTable,
		wszCSTFlags(pcs->aTable[CSTI_CERTIFICATE].TableFlags)));
	}

	hr = _OpenTableRow(
		pcs,
		pdbauxPrimary,
		pcvrPrimary,
		&pcs->aTable[CSTI_PRIMARY],
		&dwRowIdMismatch);
	_LeaveIfError2(hr, "_OpenTableRow", CERTSRV_E_PROPERTY_EMPTY);

	CSASSERT(0 != pcs->RowId);
	CSASSERT(IsValidJetTableId(pcs->aTable[CSTI_PRIMARY].TableId));
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "OpenTables: %hs: %ws\n",
	    g_dbauxRequests.pszTable,
	    wszCSTFlags(pcs->aTable[CSTI_PRIMARY].TableFlags)));

	if (fCertTableLast)
	{
	    while (TRUE)
	    {
		hr = _OpenTableRow(
			    pcs,
			    &g_dbauxCertificates,
			    pcvrCertificates,
			    &pcs->aTable[CSTI_CERTIFICATE],
			    &dwRowIdMismatch);
		_PrintIfError(hr, "_OpenTableRow");
		if (S_OK == hr || 0 == dwRowIdMismatch)
		{
		    break;
		}
	    }
	    _PrintIfError(hr, "_OpenTableRow");
	    if (S_OK == hr)
	    {
		CSASSERT(IsValidJetTableId(pcs->aTable[CSTI_CERTIFICATE].TableId));
		DBGPRINT((
		    DBG_SS_CERTDBI,
		    "OpenTables: %hs: %ws\n",
		    g_dbauxCertificates.pszTable,
		    wszCSTFlags(pcs->aTable[CSTI_CERTIFICATE].TableFlags)));
	    }
	    hr = S_OK;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (S_OK != hr)
    {
        __try
        {
	    HRESULT hr2;
	    DWORD i;

	    for (i = 0; i < CSTI_MAX; i++)
	    {
		if (NULL != pcs)
		{
		    CSASSERTTHREAD(pcs);
		    if (IsValidJetTableId(pcs->aTable[i].TableId))
		    {
			hr2 = _dbgJetCloseTable(
					    pcs->SesId,
					    pcs->aTable[i].TableId);
			_PrintIfError(hr2, "JetCloseTable");
		    }
		    ZeroMemory(&pcs->aTable[i], sizeof(pcs->aTable[i]));
		}
	    }
	}
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }
    if (fEnterCritSec)
    {
        LeaveCriticalSection(&m_critsecAutoIncTables);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CloseTables(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    for (i = 0; i < CSTI_MAX; i++)
    {
	if (IsValidJetTableId(pcs->aTable[i].TableId))
	{
	    hr2 = CloseTable(pcs, pcs->aTable[i].TableId);
	    _PrintIfError(hr2, "CloseTable");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::Delete(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    for (i = 0; i < CSTI_MAXDIRECT; i++)
    {
	if (IsValidJetTableId(pcs->aTable[i].TableId))
	{
	    hr2 = _dbgJetDelete(pcs->SesId, pcs->aTable[i].TableId);
	    _PrintIfError(hr2, "JetDelete");
	    if (S_OK == hr)
	    {
		hr = hr2;
	    }
	}
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_UpdateTable(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid)
{
    HRESULT hr;

    CSASSERT(IsValidJetTableId(tableid));
    CSASSERTTHREAD(pcs);
    hr = _dbgJetUpdate(pcs->SesId, tableid, NULL, 0, NULL);
    _JumpIfError(hr, error, "JetUpdate");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CloseTable(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid)
{
    HRESULT hr;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }    
    CSASSERT(IsValidJetTableId(tableid));
    CSASSERTTHREAD(pcs);
    hr = _dbgJetCloseTable(pcs->SesId, tableid);
    _JumpIfError(hr, error, "JetCloseTable");

error:
    return(myJetHResult(hr));
}


STDMETHODIMP
CCertDB::OpenRow(
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD RowId,
    /* [in] */ WCHAR const *pwszSerialNumberOrCertHash,	// OPTIONAL
    /* [out] */ ICertDBRow **pprow)
{
    HRESULT hr;
    ICertDBRow *prow = NULL;
    DWORD SesFlags = 0;
    CERTSESSION *pcs = NULL;
    CERTVIEWRESTRICTION cvr;
    CERTVIEWRESTRICTION *pcvr;

    if (NULL == pprow)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pprow = NULL;

    switch (PROPTABLE_MASK & dwFlags)
    {
	case PROPTABLE_REQCERT:
	    SesFlags |= TABLE_REQCERTS;
	    cvr.ColumnIndex = DTI_REQUESTTABLE | DTC_REQUESTID;
	    break;

	case PROPTABLE_ATTRIBUTE:
	    SesFlags |= TABLE_ATTRIBUTES;
	    cvr.ColumnIndex = DTI_ATTRIBUTETABLE | DTA_REQUESTID;
	    break;

	case PROPTABLE_EXTENSION:
	    SesFlags |= TABLE_EXTENSIONS;
	    cvr.ColumnIndex = DTI_EXTENSIONTABLE | DTE_REQUESTID;
	    break;

	case PROPTABLE_CRL:
	    SesFlags |= TABLE_CRLS;
	    cvr.ColumnIndex = DTI_CRLTABLE | DTL_ROWID;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad table");
    }
    if ((PROPOPEN_CERTHASH & dwFlags) && NULL == pwszSerialNumberOrCertHash)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad PROPOPEN_CERTHASH");
    }
    if (PROPTABLE_REQCERT != (PROPTABLE_MASK & dwFlags) &&
	NULL != pwszSerialNumberOrCertHash)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad pwszSerialNumberOrCertHash");
    }
    if ((PROPOPEN_READONLY | PROPOPEN_DELETE) ==
	((PROPOPEN_READONLY | PROPOPEN_DELETE) & dwFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "delete + read-only");
    }

    if (0 == RowId && NULL == pwszSerialNumberOrCertHash)
    {
	if ((PROPOPEN_READONLY | PROPOPEN_DELETE) & dwFlags)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "OpenRow: create vs. delete or read-only");
	}
	SesFlags |= CSF_CREATE;
	pcvr = NULL;
    }
    else
    {
	cvr.SeekOperator = CVR_SEEK_EQ;
	cvr.SortOrder = CVR_SORT_ASCEND;
	if (NULL != pwszSerialNumberOrCertHash)
	{
	    cvr.ColumnIndex = (PROPOPEN_CERTHASH & dwFlags)?
		(DTI_CERTIFICATETABLE | DTC_CERTIFICATEHASH) :
		(DTI_CERTIFICATETABLE | DTC_CERTIFICATESERIALNUMBER);

	    cvr.cbValue = wcslen(pwszSerialNumberOrCertHash) * sizeof(WCHAR);
	    cvr.pbValue = (BYTE *) pwszSerialNumberOrCertHash;
	}
	else
	{
	    cvr.cbValue = sizeof(RowId);
	    cvr.pbValue = (BYTE *) &RowId;
	}
	pcvr = &cvr;
    }

    if (PROPOPEN_READONLY & dwFlags)
    {
	SesFlags |= CSF_READONLY;
    }
    else
    {
	if (PROPOPEN_DELETE & dwFlags)
	{
	    SesFlags |= CSF_DELETE;
	}
	if (m_fDBReadOnly)
	{
	    hr = E_ACCESSDENIED;
	    _JumpError(hr, error, "OpenRow: read-only DB");
	}
    }

    prow = new CCertDBRow;
    if (NULL == prow)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CCertDBRow");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    pcs->RowId = RowId;
    pcs->SesFlags |= SesFlags;
    pcs->prow = prow;

    hr = ((CCertDBRow *) prow)->Open(pcs, this, pcvr);
    _JumpIfError2(hr, error, "Open", CERTSRV_E_PROPERTY_EMPTY);

    *pprow = prow;
    prow = NULL;
    pcs = NULL;

error:
    if (NULL != prow)
    {
	prow->Release();
    }
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    return(hr);
}


STDMETHODIMP
CCertDB::OpenView(
    /* [in] */  DWORD ccvr,
    /* [in] */  CERTVIEWRESTRICTION const *acvr,
    /* [in] */  DWORD ccolOut,
    /* [in] */  DWORD const *acolOut,
    /* [in] */  DWORD const dwFlags,
    /* [out] */ IEnumCERTDBRESULTROW **ppenum)
{
    HRESULT hr;
    IEnumCERTDBRESULTROW *penum = NULL;
    CERTSESSION *pcs;

    if ((NULL == acvr && 0 != ccvr) || NULL == acolOut || NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTDBRESULTROW(0 != (CDBOPENVIEW_WORKERTHREAD & dwFlags));
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTDBRESULTROW");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    pcs->SesFlags |= CSF_READONLY | CSF_VIEW;
    pcs->pview = penum;

    hr = ((CEnumCERTDBRESULTROW *) penum)->Open(
					pcs,
					this,
					ccvr,
					acvr,
					ccolOut,
					acolOut);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    penum = NULL;

error:
    if (NULL != penum)
    {
	penum->Release();
    }
    return(hr);
}


HRESULT
CCertDB::OpenBackup(
    /* [in] */  LONG grbitJet,
    /* [out] */ ICertDBBackup **ppBackup)
{
    HRESULT hr;
    ICertDBBackup *pBackup = NULL;
    CERTSESSION *pcs = NULL;

    if (NULL == ppBackup)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppBackup = NULL;

    pBackup = new CCertDBBackup;
    if (NULL == pBackup)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CCertDBBackup");
    }

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    hr = ((CCertDBBackup *) pBackup)->Open(grbitJet, pcs, this);
    _JumpIfError(hr, error, "Open");

    *ppBackup = pBackup;
    pBackup = NULL;
    pcs = NULL;
    hr = S_OK;

error:
    if (NULL != pBackup)
    {
	pBackup->Release();
    }
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    return(hr);
}


HRESULT
CCertDB::ReleaseSession(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    HRESULT hr2;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(CSF_INUSE & pcs->SesFlags);
    while (0 != pcs->cTransact)
    {
        CSASSERTTHREAD(pcs);
	hr2 = _dbgJetRollback(pcs->SesId, 0);
	if (S_OK == hr)
	{
	    hr = hr2;
	}
	_JumpIfError(hr2, loop, "JetRollback");

	DBGPRINT((
	    (CSF_READONLY & pcs->SesFlags)? DBG_SS_CERTDBI : DBG_SS_CERTDB,
	    "ReleaseSession: Rollback transaction: %x\n",
	    pcs->cTransact));
loop:
	CSASSERT(0 == pcs->cTransact);
	pcs->cTransact--;
	InterlockedIncrement(&g_cXactAbort);
    }
    //EnterCriticalSection(&m_critsecSession);
    pcs->RowId = 0;
    pcs->prow = NULL;
    pcs->SesFlags = 0;		// turn off CSF_INUSE -- must be LAST!
    //LeaveCriticalSection(&m_critsecSession);

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_Rollback(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    DWORD i;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    CSASSERT(CSF_INUSE & pcs->SesFlags);

    for (i = 0; i < CSTI_MAX; i++)
    {
	pcs->aTable[i].TableId = 0;
    }

    CSASSERTTHREAD(pcs);
    hr = _dbgJetRollback(pcs->SesId, 0);
    _JumpIfError(hr, error, "JetRollback");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupBegin(
    IN LONG grbitJet)
{
    HRESULT hr;

    hr = _dbgJetBeginExternalBackup(grbitJet);
    _JumpIfError(hr, error, "JetBeginExternalBackup");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_BackupGetFileList(
    IN     BOOL   fDBFiles,
    IN OUT DWORD *pcwcList,
    OUT    WCHAR *pwszzList)		// OPTIONAL
{
    HRESULT hr;
    CHAR buf[12];
    CHAR *pszz = buf;
    DWORD cbbuf = ARRAYSIZE(buf);
    DWORD cbActual;
    WCHAR *pwszz = NULL;
    DWORD cwc;
    WCHAR *pwsz;

    while (TRUE)
    {
	if (fDBFiles)
	{
	    hr = _dbgJetGetAttachInfo(pszz, cbbuf, &cbActual);
	    _JumpIfError(hr, error, "JetGetAttachInfo");
	}
	else
	{
	    hr = _dbgJetGetLogInfo(pszz, cbbuf, &cbActual);
	    _JumpIfError(hr, error, "JetGetLogInfo");
	}
	if (cbbuf >= cbActual)
	{
	    break;
	}
	CSASSERT(buf == pszz);
	pszz = (CHAR *) LocalAlloc(LMEM_FIXED, cbActual);
	if (NULL == pszz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	cbbuf = cbActual;
    }
    if (!ConvertSzToWsz(&pwszz, pszz, cbActual))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertSzToWsz");
    }

    pwsz = pwszz;
    do
    {
	cwc = wcslen(pwsz);
	pwsz += cwc + 1;
    } while (0 != cwc);
    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszz);	// includes double trailing L'\0's
    if (NULL != pwszzList)
    {
	CopyMemory(pwszzList, pwszz, min(cwc, *pcwcList) * sizeof(WCHAR));
	if (cwc > *pcwcList)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
    }
    *pcwcList = cwc;
    _JumpIfError(hr, error, "Buffer Overflow");

error:
    if (NULL != pszz && buf != pszz)
    {
	LocalFree(pszz);
    }
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupGetDBFileList(
    IN OUT DWORD *pcwcList,
    OUT    WCHAR *pwszzList)		// OPTIONAL
{
    HRESULT hr;

    hr = _BackupGetFileList(TRUE, pcwcList, pwszzList);
    _JumpIfError(hr, error, "_BackupGetFileList");

error:
    return(hr);
}


HRESULT
CCertDB::BackupGetLogFileList(
    IN OUT DWORD *pcwcList,
    OUT    WCHAR *pwszzList)		// OPTIONAL
{
    HRESULT hr;

    hr = _BackupGetFileList(FALSE, pcwcList, pwszzList);
    _JumpIfError(hr, error, "_BackupGetFileList");

error:
    return(hr);
}


HRESULT
CCertDB::BackupOpenFile(
    IN WCHAR const *pwszFile,
    OUT JET_HANDLE *phFileDB,
    OPTIONAL OUT ULARGE_INTEGER *pliSize)
{
    HRESULT hr;
    CHAR *pszFile = NULL;

    if (!ConvertWszToSz(&pszFile, pwszFile, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(pwszFile)");
    }
    hr = _dbgJetOpenFile(
		    pszFile,
		    phFileDB,
		    &pliSize->LowPart,
		    &pliSize->HighPart);
    _JumpIfErrorStr(hr, error, "JetOpenFile", pwszFile);

error:
    if (NULL != pszFile)
    {
	LocalFree(pszFile);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupReadFile(
    IN  JET_HANDLE hFileDB,
    OUT BYTE *pb,
    IN  DWORD cb,
    OUT DWORD *pcb)
{
    HRESULT hr;
    BYTE *pbAlloc = NULL;
    BYTE *pbRead;

    if (0 == m_cbPage)
    {
	SYSTEM_INFO si;

	GetSystemInfo(&si);
	m_cbPage = si.dwPageSize;
    }
    if ((m_cbPage - 1) & cb)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad read size");
	
    }
    pbRead = pb;

    // If the caller's buffer is not page aligned, allocate an aligned buffer
    // and copy the data.

    if ((m_cbPage - 1) & (DWORD_PTR) pb)
    {
	pbAlloc = (BYTE *) VirtualAlloc(NULL, cb, MEM_COMMIT, PAGE_READWRITE);
	if (NULL == pbAlloc)
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "VirtualAlloc");
	}
	pbRead = pbAlloc;
    }

    hr = _dbgJetReadFile(hFileDB, pbRead, cb, pcb);
    _JumpIfError(hr, error, "JetReadFile");

    if (NULL != pbAlloc)
    {
	CopyMemory(pb, pbAlloc, *pcb);
    }

error:
    if (NULL != pbAlloc)
    {
	VirtualFree(pbAlloc, 0, MEM_RELEASE);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupCloseFile(
    IN JET_HANDLE hFileDB)
{
    HRESULT hr;

    hr = _dbgJetCloseFile(hFileDB);
    _JumpIfError(hr, error, "JetCloseFile");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupTruncateLog()
{
    HRESULT hr;

    hr = _dbgJetTruncateLog();
    _JumpIfError(hr, error, "JetTruncateLog");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::BackupEnd()
{
    HRESULT hr;

    hr = _dbgJetEndExternalBackup();
    _JumpIfError(hr, error, "JetEndExternalBackup");

error:
    return(myJetHResult(hr));
}


DBTABLE const *
CCertDB::_MapTable(
    IN WCHAR const *pwszPropName,
    IN DBTABLE const *pdt)
{
    while (NULL != pdt->pwszPropName)
    {
        if (0 == (DBTF_MISSING & pdt->dwFlags) &&
	    (0 == mylstrcmpiS(pwszPropName, pdt->pwszPropName) ||
             (NULL != pdt->pwszPropNameObjId &&
	      0 == mylstrcmpiS(pwszPropName, pdt->pwszPropNameObjId))))
	{
	    return(pdt);
	}
	pdt++;
    }
    return(NULL);
}


HRESULT
CCertDB::_MapPropIdIndex(
    IN DWORD ColumnIndex,
    OUT DBTABLE const **ppdt,
    OPTIONAL OUT DWORD *pType)
{
    HRESULT hr;
    DBTABLE const *pdt = NULL;
    DWORD iCol = DTI_COLUMNMASK & ColumnIndex;

    switch (DTI_TABLEMASK & ColumnIndex)
    {
	case DTI_REQUESTTABLE:
	    if (DTR_MAX > iCol)
	    {
		pdt = g_adtRequests;
	    }
	    break;

	case DTI_CERTIFICATETABLE:
	    if (DTC_MAX > iCol)
	    {
		pdt = g_adtCertificates;
	    }
	    break;

	case DTI_ATTRIBUTETABLE:
	    if (DTA_MAX > iCol)
	    {
		pdt = g_adtRequestAttributes;
	    }
	    break;

	case DTI_EXTENSIONTABLE:
	    if (DTE_MAX > iCol)
	    {
		pdt = g_adtCertExtensions;
	    }
	    break;

	case DTI_CRLTABLE:
	    if (DTL_MAX > iCol)
	    {
		pdt = g_adtCRLs;
	    }
	    break;
    }
    if (NULL == pdt)
    {
	hr = E_INVALIDARG;
	DBGPRINT((
	    DBG_SS_CERTDB,
	    "_MapPropIdIndex(%x) -> %x\n",
	    ColumnIndex,
	    hr));
	_JumpError(hr, error, "column index");
    }
    pdt += iCol;
    if (NULL != pType)
    {
	switch (pdt->dbcoltyp)
	{
	    case JET_coltypDateTime:
		*pType = PROPTYPE_DATE;
		break;

	    case JET_coltypLong:
		*pType = PROPTYPE_LONG;
		break;

	    case JET_coltypText:
	    case JET_coltypLongText:
		*pType = PROPTYPE_STRING;
		break;

	    case JET_coltypLongBinary:
	    default:
		*pType = PROPTYPE_BINARY;
		break;
	}
	if (NULL != pdt->pszIndexName &&
	    0 == (DBTF_INDEXREQUESTID & pdt->dwFlags))
	{
	    *pType |= PROPFLAGS_INDEXED;
	}
    }
    DBGPRINT((
	DBG_SS_CERTDBI,
	"_MapPropIdIndex(%x) -> %ws.%ws\n",
	ColumnIndex,
	wszTable(pdt->dwTable),
	pdt->pwszPropName));
    hr = S_OK;

error:
    *ppdt = pdt;
    return(hr);
}


HRESULT
CCertDB::_MapTableToIndex(
    IN DBTABLE const *pdt,
    OUT DWORD *pColumnIndex)
{
    HRESULT hr;
    DBTABLE const *pdtBase;
    DWORD Column;
    DWORD cColumnMax;
    DWORD iCol;

    Column = 0;
    switch (pdt->dwTable)
    {
	case TABLE_REQUESTS:
	    Column = DTI_REQUESTTABLE;
	    cColumnMax = DTR_MAX;
	    pdtBase = g_adtRequests;
	    break;

	case TABLE_CERTIFICATES:
	    Column = DTI_CERTIFICATETABLE;
	    cColumnMax = DTC_MAX;
	    pdtBase = g_adtCertificates;
	    break;

	case TABLE_ATTRIBUTES:
	    Column = DTI_ATTRIBUTETABLE;
	    cColumnMax = DTA_MAX;
	    pdtBase = g_adtRequestAttributes;
	    break;

	case TABLE_EXTENSIONS:
	    Column = DTI_EXTENSIONTABLE;
	    cColumnMax = DTE_MAX;
	    pdtBase = g_adtCertExtensions;
	    break;

	case TABLE_CRLS:
	    Column = DTI_CRLTABLE;
	    cColumnMax = DTL_MAX;
	    pdtBase = g_adtCRLs;
	    break;
	    
	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "pdt->dwTable");
    }
    for (iCol = 0; ; iCol++)
    {
	if (iCol >= cColumnMax)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "iCol");
	}
	if (pdt->pwszPropName == pdtBase[iCol].pwszPropName)
	{
	    break;
	}
    }
    Column |= iCol;
    hr = S_OK;

error:
    DBGPRINT((
	DBG_SS_CERTDBI,
	"_MapTableToIndex(%ws.%ws) -> col=%x, hr=%x\n",
	wszTable(pdt->dwTable),
	pdt->pwszPropName,
	Column,
	hr));
    *pColumnIndex = Column;
    return(hr);
}


HRESULT
CCertDB::MapPropId(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    OUT DBTABLE *pdtOut)
{
    DBTABLE const *pdt = NULL;
    WCHAR wszPrefix[2 * (sizeof(wszPROPSUBJECTDOT) / sizeof(WCHAR))];
    DWORD dwTable;
    HRESULT hr = S_OK;
    DBTABLE const *pdbTable;
    WCHAR const *pwszStart;
    BOOL fSubject = FALSE;
    BOOL fRequest = FALSE;

    if (NULL == pwszPropName || NULL == pdtOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    dwTable = PROPTABLE_MASK & dwFlags;
    CSASSERT(
	PROPTABLE_REQUEST == dwTable ||
	PROPTABLE_CERTIFICATE == dwTable ||
	PROPTABLE_CRL == dwTable);

    // Check to see if the request is for L"Subject.".

    pwszStart = pwszPropName;

    if (PROPTABLE_CRL != dwTable)
    {
	while (!fSubject)
	{
	    WCHAR const *pwsz;

	    pwsz = wcschr(pwszStart, L'.');

	    if (NULL == pwsz ||
		pwsz - pwszStart + 2 > sizeof(wszPrefix)/sizeof(WCHAR))
	    {
		pwsz = pwszStart;
		break;
	    }
	    pwsz++;		// skip past L'.'

	    CopyMemory(
		wszPrefix,
		pwszStart,
		(SAFE_SUBTRACT_POINTERS(pwsz, pwszStart) * sizeof(WCHAR)));
	    wszPrefix[pwsz - pwszStart] = L'\0';

	    if (!fSubject)
	    {
		pwszStart = pwsz;
		if (0 == LSTRCMPIS(wszPrefix, wszPROPSUBJECTDOT))
		{
		    fSubject = TRUE;
		    continue;
		}
		else
		if (!fRequest &&
		    PROPTABLE_REQUEST == dwTable &&
		    0 == LSTRCMPIS(wszPrefix, wszPROPREQUESTDOT))
		{
		    fRequest = TRUE;
		    continue;
		}
	    }
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "Invalid prefix", pwszPropName);
	}
    }

    pdbTable = NULL;

    // Search the requested table for a matching property name or property
    // objectid string.

    switch (dwTable)
    {
	case PROPTABLE_REQUEST:
	    pdbTable = g_adtRequests;
	    break;

	case PROPTABLE_CERTIFICATE:
	    pdbTable = g_adtCertificates;
	    break;

	case PROPTABLE_CRL:
	    pdbTable = g_adtCRLs;
	    break;
    }
    CSASSERT(NULL != pdbTable);

    pdt = _MapTable(pwszStart, pdbTable);
    if (NULL == pdt || (fSubject && 0 == (DBTF_SUBJECT & pdt->dwFlags)))
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpErrorStr(
		hr,
		error,
		PROPTABLE_REQUEST == dwTable?
		    "unknown Request property" :
		    PROPTABLE_CERTIFICATE == dwTable?
			"unknown Certificate property" :
			"unknown CRL property",
		pwszPropName);
    }
    *pdtOut = *pdt;	// structure copy
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::TestShutDownState()
{
    HRESULT hr;
    
    if (m_fPendingShutDown)
    {
	hr = HRESULT_FROM_WIN32(ERROR_SHUTDOWN_IN_PROGRESS);
	_JumpError(hr, error, "m_fPendingShutDown");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::SetProperty(
    IN CERTSESSION *pcs,
    IN DBTABLE const *pdt,
    IN DWORD cbProp,
    IN BYTE const *pbProp)	// OPTIONAL
{
    HRESULT hr;
    JET_TABLEID tableid;

    if (NULL == pcs ||
	NULL == pdt ||
	(NULL == pbProp && !ISTEXTCOLTYP(pdt->dbcoltyp)))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    DBGPRINT((
	DBG_SS_CERTDBI,
	"SetProperty for %hs into table %d\n",
	pdt->pszFieldName,
	pdt->dwTable));

    if (ISTEXTCOLTYP(pdt->dbcoltyp))
    {
    	DBGPRINT((DBG_SS_CERTDBI, "SetProperty setting string %ws\n", pbProp));
    }
    if (JET_coltypDateTime == pdt->dbcoltyp)
    {
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "SetProperty setting date: %x:%x\n",
	    ((DWORD *) pbProp)[0],
	    ((DWORD *) pbProp)[1]));
    }

    switch (pdt->dwTable)
    {
	case TABLE_CRLS:
	case TABLE_REQUESTS:
            tableid = pcs->aTable[CSTI_PRIMARY].TableId;
	    break;

	case TABLE_CERTIFICATES:
            tableid = pcs->aTable[CSTI_CERTIFICATE].TableId;
	    break;

        default:
	    hr = E_INVALIDARG;
            _JumpError(hr, error, "unknown table type");
    }
    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpErrorStr(hr, error, "tableid", pdt->pwszPropName);
    }
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdt,
		pdt->dbcolumnid,
		cbProp,
		pbProp);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdt->pwszPropName);

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::GetProperty(
    IN     CERTSESSION *pcs,
    IN     DBTABLE const *pdt,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
    IN OUT DWORD *pcbProp,
    OUT    BYTE *pbProp)	// OPTIONAL
{
    HRESULT hr;
    JET_TABLEID tableid;

    if (NULL == pcs || NULL == pdt || NULL == pcbProp)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    DBGPRINT((
	DBG_SS_CERTDBI,
	"GetProperty for %hs from table %d\n",
	pdt->pszFieldName,
	pdt->dwTable));

    if ((CSF_TABLEMASK & pcs->SesFlags) != pdt->dwTable)
    {
	if (TABLE_REQCERTS != (CSF_TABLEMASK & pcs->SesFlags) ||
	    (TABLE_REQUESTS != pdt->dwTable &&
	     TABLE_CERTIFICATES != pdt->dwTable))
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "mismatched table");
	}
    }
    if (TABLE_CERTIFICATES == pdt->dwTable)
    {
	tableid = pcs->aTable[CSTI_CERTIFICATE].TableId;
    }
    else
    {
	tableid = pcs->aTable[CSTI_PRIMARY].TableId;
    }
    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpErrorStr(hr, error, "tableid", pdt->pwszPropName);
    }
    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdt,
		    pdt->dbcolumnid,
		    pIComputedColumn,
		    pcbProp,
		    pbProp);
    _JumpIfErrorStr3(
		hr,
		error,
		"_RetrieveColumn",
		pdt->pwszPropName,
		CERTSRV_E_PROPERTY_EMPTY,
		HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW));

    if (ISTEXTCOLTYP(pdt->dbcoltyp))
    {
        DBGPRINT((DBG_SS_CERTDBI, "GetProperty returning string %ws\n", pbProp));
    }

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::CopyRequestNames(
    IN CERTSESSION *pcs)
{
    HRESULT hr = S_OK;
    DBTABLE dt;
    DWORD cbProp;
    BYTE *pbProp = NULL;
    DWORD i;

    BYTE rgbFastBuf[CB_PROPFASTBUF];

    if (NULL == pcs)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    for (i = 0; NULL != g_dntr[i].pszFieldName; i++)
    {
        hr = MapPropId(g_dntr[i].pwszPropName, PROPTABLE_REQUEST, &dt);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    hr = S_OK;
	    continue;		// Optional column doesn't exist
	}
        _JumpIfError(hr, error, "MapPropId");

        // re-point at fastbuf
        pbProp = rgbFastBuf;
        cbProp = sizeof(rgbFastBuf);

        hr = GetProperty(pcs, &dt, NULL, &cbProp, pbProp);
        if (S_OK != hr)
        {
            if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
            {
                if (CERTSRV_E_PROPERTY_EMPTY == hr)
                {
                    hr = S_OK;
                    continue;
                }
                _JumpIfError(hr, error, "GetProperty");
            }
            CSASSERT (ARRAYSIZE(rgbFastBuf) < cbProp);

	    DBGPRINT((
		    DBG_SS_CERTDB,
		    "FastBuf miss: CopyRequestNames(cbProp=%u)\n",
		    cbProp));

	    pbProp = (BYTE *) LocalAlloc(LMEM_FIXED, cbProp);
            if (NULL == pbProp)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }

            hr = GetProperty(pcs, &dt, NULL, &cbProp, pbProp);
            _JumpIfError(hr, error, "GetProperty");
        } // have data in hand

        hr = MapPropId(g_dntr[i].pwszPropName, PROPTABLE_CERTIFICATE, &dt);
        _JumpIfError(hr, error, "MapPropId");

        hr = SetProperty(pcs, &dt, cbProp, pbProp);
        _JumpIfError(hr, error, "SetProperty");

        if (NULL != pbProp && rgbFastBuf != pbProp)
	{
            LocalFree(pbProp);
	}
        pbProp = NULL;
    }

error:
    if (NULL != pbProp && rgbFastBuf != pbProp)
    {
        LocalFree(pbProp);
    }
    return(hr);
}


STDMETHODIMP
CCertDB::EnumCertDBColumn(
    /* [in] */ DWORD dwTable,
    /* [out] */ IEnumCERTDBCOLUMN **ppenum)
{
    HRESULT hr;
    IEnumCERTDBCOLUMN *penum = NULL;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;

    penum = new CEnumCERTDBCOLUMN;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTDBCOLUMN");
    }

    hr = ((CEnumCERTDBCOLUMN *) penum)->Open(dwTable, this);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != penum)
    {
	penum->Release();
    }
    return(hr);
}

STDMETHODIMP
CCertDB::GetDefaultColumnSet(
    /* [in] */       DWORD  iColumnSetDefault,
    /* [in] */       DWORD  cColumnIds,
    /* [out] */      DWORD *pcColumnIds,
    /* [out, ref] */ DWORD *pColumnIds)		// OPTIONAL
{
    HRESULT hr;
    DWORD *pcol;
    DWORD ccol;

    if (NULL == pcColumnIds)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    switch (iColumnSetDefault)
    {
	case CV_COLUMN_LOG_FAILED_DEFAULT:
	case CV_COLUMN_QUEUE_DEFAULT:
	    pcol = g_aColumnViewQueue;
	    ccol = g_cColumnViewQueue;
	    break;

	case CV_COLUMN_LOG_REVOKED_DEFAULT:
	    pcol = g_aColumnViewRevoked;
	    ccol = g_cColumnViewRevoked;
	    break;

	case CV_COLUMN_LOG_DEFAULT:
	    pcol = g_aColumnViewLog;
	    ccol = g_cColumnViewLog;
	    break;

	case CV_COLUMN_EXTENSION_DEFAULT:
	    pcol = g_aColumnViewExtension;
	    ccol = g_cColumnViewExtension;
	    break;

	case CV_COLUMN_ATTRIBUTE_DEFAULT:
	    pcol = g_aColumnViewAttribute;
	    ccol = g_cColumnViewAttribute;
	    break;

	case CV_COLUMN_CRL_DEFAULT:
	    pcol = g_aColumnViewCRL;
	    ccol = g_cColumnViewCRL;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "iColumnSetDefault");
    }

    *pcColumnIds = ccol;
    hr = S_OK;

    if (NULL != pColumnIds)
    {
	if (ccol > cColumnIds)
	{
	    ccol = cColumnIds;
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	}
	CopyMemory(pColumnIds, pcol, ccol * sizeof(*pColumnIds));
    }

error:
    return(hr);
}


HRESULT
CCertDB::GetColumnType(
    IN  LONG ColumnIndex,
    OUT DWORD *pType)
{
    HRESULT hr;
    DBTABLE const *pdt;

    if (NULL == pType)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _MapPropIdIndex(ColumnIndex, &pdt, pType);
    _JumpIfError(hr, error, "_MapPropIdIndex");

error:
    return(hr);
}


HRESULT
CCertDB::EnumCertDBColumnNext(
    IN  DWORD         dwTable,	// CVRC_TABLE_*
    IN  ULONG         ielt,
    IN  ULONG         celt,
    OUT CERTDBCOLUMN *rgelt,
    OUT ULONG        *pielt,
    OUT ULONG        *pceltFetched)
{
    HRESULT hr;
    ULONG ieltEnd;
    ULONG ieltMax;
    ULONG TableIndex;
    CERTDBCOLUMN *pelt;
    WCHAR const *pwszPrefix;
    WCHAR const *pwszDisplayName;

    if (NULL == rgelt || NULL == pielt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    switch (dwTable)
    {
	case CVRC_TABLE_REQCERT:
	    TableIndex = DTI_REQUESTTABLE;
	    ieltMax = DTR_MAX + DTC_MAX;
	    break;

	case CVRC_TABLE_EXTENSIONS:
	    TableIndex = DTI_EXTENSIONTABLE;
	    ieltMax = DTE_MAX;
	    break;

	case CVRC_TABLE_ATTRIBUTES:
	    TableIndex = DTI_ATTRIBUTETABLE;
	    ieltMax = DTA_MAX;
	    break;

	case CVRC_TABLE_CRL:
	    TableIndex = DTI_CRLTABLE;
	    ieltMax = DTL_MAX;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad table");
    }

    if (ieltMax + ielt < celt)
    {
	celt = ieltMax - ielt;
    }
    ieltEnd = ielt + celt;

    ZeroMemory(rgelt, celt * sizeof(rgelt[0]));

    hr = S_OK;
    for (pelt = rgelt; pelt < &rgelt[celt]; ielt++, pelt++)
    {
	DBTABLE const *pdt;
	ULONG ieltBase = 0;

	if (ieltMax <= ielt)
	{
	    if (pelt == rgelt)
	    {
		hr = S_FALSE;
	    }
	    break;
	}
	pwszPrefix = NULL;

	if (CVRC_TABLE_REQCERT == dwTable)
	{
	    if (DTR_MAX > ielt)
	    {
		pwszPrefix = wszPROPREQUESTDOT;
		TableIndex = DTI_REQUESTTABLE;
	    }
	    else
	    {
		ieltBase = DTR_MAX;
		TableIndex = DTI_CERTIFICATETABLE;
	    }
	}

	pelt->Index = TableIndex | (ielt - ieltBase);

	hr = _MapPropIdIndex(pelt->Index, &pdt, &pelt->Type);
	_JumpIfError(hr, error, "_MapPropIdIndex");

	pelt->cbMax = pdt->dwcbMax;
	hr = _DupString(pwszPrefix, pdt->pwszPropName, &pelt->pwszName);
	_JumpIfError(hr, error, "_DupString");

	hr = myGetColumnDisplayName(pelt->pwszName, &pwszDisplayName);
	_PrintIfError(hr, "myGetColumnDisplayName");
	if (S_OK != hr)
	{
	    pwszDisplayName = pelt->pwszName;
	}

	hr = _DupString(NULL, pwszDisplayName, &pelt->pwszDisplayName);
	_JumpIfError(hr, error, "_DupString");
    }

    *pceltFetched = SAFE_SUBTRACT_POINTERS(pelt, rgelt);
    *pielt = ielt;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	if (NULL != rgelt)
	{
	    for (pelt = rgelt; pelt < &rgelt[celt]; pelt++)
	    {
		if (NULL != pelt->pwszName)
		{
		    CoTaskMemFree(pelt->pwszName);
		    pelt->pwszName = NULL;
		}
		if (NULL != pelt->pwszDisplayName)
		{
		    CoTaskMemFree(pelt->pwszDisplayName);
		    pelt->pwszDisplayName = NULL;
		}
	    }
	}
    }
    return(hr);
}


HRESULT
CCertDB::EnumCertDBResultRowNext(
    IN  CERTSESSION                   *pcs,
    IN  DWORD                          ccvr,
    IN  CERTVIEWRESTRICTION const     *pcvr,
    IN  DWORD                          ccolOut,
    IN  DWORD const                   *acolOut,
    IN  LONG                           cskip,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
    IN  ULONG                          celt,
    OUT CERTDBRESULTROW               *rgelt,
    OUT ULONG                         *pceltFetched,
    OUT LONG			      *pcskipped)
{
    HRESULT hr;
    DWORD iRow;
    LONG cskipped;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "EnumCertDBResultRowNext called: cskip: %d\n", cskip));

    if (NULL == pcvr ||
	NULL == acolOut ||
	NULL == rgelt ||
	NULL == pceltFetched ||
	NULL == pcskipped)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pcskipped = 0;
    hr = S_OK;
    for (iRow = 0; iRow < celt; iRow++)
    {
	hr = TestShutDownState();
	_JumpIfError(hr, error, "TestShutDownState");

	hr = _GetResultRow(
			pcs,
			ccvr,
			pcvr,
			cskip,
			ccolOut,
			acolOut,
			pIComputedColumn,
			&rgelt[iRow],
			&cskipped);
	if (S_FALSE == hr)
	{
	    *pcskipped += cskipped;
	    break;
	}
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "EnumCertDBResultRowNext: rowid %u\n", rgelt[iRow].rowid));

	_JumpIfError(hr, error, "_GetResultRow");

	*pcskipped += cskipped;
	cskip = 0;
    }
    *pceltFetched = iRow;
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "EnumCertDBResultRowNext: %u rows, hr=%x\n",
	    *pceltFetched,
	    hr));

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	ReleaseResultRow(celt, rgelt);
    }
    return(hr);
}


HRESULT
CCertDB::_CompareColumnValue(
    IN CERTSESSION               *pcs,
    IN CERTVIEWRESTRICTION const *pcvr,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn)
{
    HRESULT hr;
    JET_TABLEID tableid;
    DBTABLE const *pdt;
    WCHAR *pwszValue = NULL;
    BOOL fMatch;
    int r;

    BYTE rgbFastBuf[256];
    BYTE *pbProp = rgbFastBuf;
    DWORD cb = sizeof(rgbFastBuf);

    // if SEEK_NONE, short circuit tests
    if (CVR_SEEK_NONE == (CVR_SEEK_MASK & pcvr->SeekOperator))
    {
        return S_OK;
    }

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    _JumpIfError(hr, error, "_MapPropIdIndex");

    if (TABLE_CERTIFICATES == pdt->dwTable)
    {
	tableid = pcs->aTable[CSTI_CERTIFICATE].TableId;
    }
    else
    {
	tableid = pcs->aTable[CSTI_PRIMARY].TableId;
    }
    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }

    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdt,
		    pdt->dbcolumnid,
		    pIComputedColumn,
		    &cb,
		    rgbFastBuf);
    
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
        {
            if (CERTSRV_E_PROPERTY_EMPTY == hr)
            {
                _PrintError2(hr, "_RetrieveColumn", hr);
                hr = S_FALSE;
            }
            _JumpError2(hr, error, "_RetrieveColumn", S_FALSE);
        }
        
        // buffer not big enough, dyn-alloc
        CSASSERT(ARRAYSIZE(rgbFastBuf) < cb);

	DBGPRINT((
		DBG_SS_CERTDB,
		"FastBuf miss: _CompareColumnValue(cbProp=%u)\n",
		cb));
        
	pbProp = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
        if (NULL == pbProp)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        
        hr = _RetrieveColumn(
			pcs,
			tableid,
			pdt,
			pdt->dbcolumnid,
			pIComputedColumn,
			&cb,
			pbProp);
        _JumpIfError(hr, error, "_RetrieveColumn");
        
    } // we have data in-hand

#if DBG_CERTSRV
    DumpRestriction(DBG_SS_CERTDBI, -1, pcvr);
    dbDumpColumn(DBG_SS_CERTDBI, pdt, pbProp, cb);
#endif

    fMatch = FALSE;
    switch (pdt->dbcoltyp)
    {
	case JET_coltypLong:
	    if (cb == pcvr->cbValue && sizeof(LONG) == cb)
	    {
		LONG lRestriction;
		LONG lColumn;

		lRestriction = *(LONG *) pcvr->pbValue;
		lColumn = *(LONG *) pbProp;
		switch (CVR_SEEK_MASK & pcvr->SeekOperator)
		{
		    case CVR_SEEK_EQ:
			fMatch = lColumn == lRestriction;
			break;

		    case CVR_SEEK_LT:
			fMatch = lColumn < lRestriction;
			break;

		    case CVR_SEEK_LE:
			fMatch = lColumn <= lRestriction;
			break;

		    case CVR_SEEK_GE:
			fMatch = lColumn >= lRestriction;
			break;

		    case CVR_SEEK_GT:
			fMatch = lColumn > lRestriction;
			break;
		}
		DBGPRINT((
			DBG_SS_CERTDBI,
			"_CompareColumnValue(lColumn=%x %ws lRestriction=%x) -> fMatch=%x\n",
			lColumn,
			wszSeekOperator(pcvr->SeekOperator),
			lRestriction,
			fMatch));
	    }
	    break;

	case JET_coltypDateTime:
	    if (cb == pcvr->cbValue && sizeof(FILETIME) == cb)
	    {
		r = CompareFileTime(
				(FILETIME *) pcvr->pbValue,
				(FILETIME *) pbProp);
		switch (CVR_SEEK_MASK & pcvr->SeekOperator)
		{
		    case CVR_SEEK_EQ:
			fMatch = 0 == r;
			break;

		    case CVR_SEEK_LT:
			fMatch = 0 < r;
			break;

		    case CVR_SEEK_LE:
			fMatch = 0 <= r;
			break;

		    case CVR_SEEK_GE:
			fMatch = 0 >= r;
			break;

		    case CVR_SEEK_GT:
			fMatch = 0 > r;
			break;
		}
#if DBG_CERTSRV
		dbDumpFileTime(
			    DBG_SS_CERTDBI,
			    "Column: ",
			    (FILETIME const *) pbProp);
		dbDumpFileTime(
			    DBG_SS_CERTDBI,
			    "Restriction: ",
			    (FILETIME const *) pcvr->pbValue);
#endif
		DBGPRINT((
			DBG_SS_CERTDBI,
			"_CompareColumnValue(ftColumn=%08x:%08x %ws ftRestriction=%08x:%08x) -> r=%d, fMatch=%x\n",
			((LARGE_INTEGER *) pbProp)->HighPart,
			((LARGE_INTEGER *) pbProp)->LowPart,
			wszSeekOperator(pcvr->SeekOperator),
			((LARGE_INTEGER *) pcvr->pbValue)->HighPart,
			((LARGE_INTEGER *) pcvr->pbValue)->LowPart,
			r,
			fMatch));
	    }
	    break;

	case JET_coltypText:
	case JET_coltypLongText:
	    CSASSERT(
		(1 + wcslen((WCHAR const *) pcvr->pbValue)) * sizeof(WCHAR) ==
		pcvr->cbValue);
	    CSASSERT(wcslen((WCHAR const *) pbProp) * sizeof(WCHAR) == cb);
	    r = mylstrcmpiL((WCHAR const *) pcvr->pbValue, (WCHAR const *) pbProp); //pwszValue
	    switch (CVR_SEEK_MASK & pcvr->SeekOperator)
	    {
		case CVR_SEEK_EQ:
		    fMatch = 0 == r;
		    break;

		case CVR_SEEK_LT:
		    fMatch = 0 < r;
		    break;

		case CVR_SEEK_LE:
		    fMatch = 0 <= r;
		    break;

		case CVR_SEEK_GE:
		    fMatch = 0 >= r;
		    break;

		case CVR_SEEK_GT:
		    fMatch = 0 > r;
		    break;
	    }
	    DBGPRINT((
		    DBG_SS_CERTDBI,
		    "_CompareColumnValue(pwszColumn=%ws %ws pwszRestriction=%ws) -> r=%d, fMatch=%x\n",
		    pbProp, //pwszValue,
		    wszSeekOperator(pcvr->SeekOperator),
		    pcvr->pbValue,
		    r,
		    fMatch));
	    break;

	case JET_coltypLongBinary:
	    if (CVR_SEEK_EQ != (CVR_SEEK_MASK & pcvr->SeekOperator))
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Bad dbcoltyp");
	    }
	    fMatch = cb == pcvr->cbValue &&
		    0 == memcmp(pcvr->pbValue, pbProp, cb);
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Bad dbcoltyp");
    }

    if (!fMatch)
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "No match", S_FALSE);
    }

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pbProp && rgbFastBuf != pbProp)
    {
	LocalFree(pbProp);
    }
    return(hr);
}


HRESULT
CCertDB::_MakeSeekKey(
    IN CERTSESSION   *pcs,
    IN JET_TABLEID    tableid,
    IN DBTABLE const *pdt,
    IN BYTE const    *pbValue,
    IN DWORD          cbValue)
{
    HRESULT hr;
    JET_GRBIT grbitKey = JET_bitNewKey;

    CSASSERT(IsValidJetTableId(tableid));
    if (DBTF_INDEXREQUESTID & pdt->dwFlags)
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetMakeKey(
			pcs->SesId,
			tableid,
			&pcs->RowId,
			sizeof(pcs->RowId),
			grbitKey);
	_JumpIfError(hr, error, "JetMakeKey(RowId)");

	DBGPRINT((DBG_SS_CERTDBI, "_MakeSeekKey key(RowId):\n"));
	DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, (BYTE *) &pcs->RowId, sizeof(pcs->RowId)));
	grbitKey = 0;
    }

    CSASSERTTHREAD(pcs);
    hr = _dbgJetMakeKey(pcs->SesId, tableid, pbValue, cbValue, grbitKey);
    _JumpIfErrorStr(hr, error, "JetMakeKey", pdt->pwszPropName);

    DBGPRINT((DBG_SS_CERTDBI, "_MakeSeekKey key:\n"));
    DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, pbValue, cbValue));

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_SeekTable(
    IN CERTSESSION                    *pcs,
    IN JET_TABLEID                     tableid,
    IN CERTVIEWRESTRICTION const      *pcvr,
    IN DBTABLE const                  *pdt,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
    IN DWORD                           dwPosition,
    OUT DWORD                         *pTableFlags
    DBGPARM(IN DBAUXDATA const        *pdbaux))
{
    HRESULT hr;
    DBSEEKDATA SeekData;
    BYTE *pbValue;
    DWORD cbValue;
    BYTE abRangeKey[JET_cbKeyMost];
    DWORD cbRangeKey;

    *pTableFlags = 0;

    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    hr = _JetSeekFromRestriction(pcvr, dwPosition, &SeekData);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_FALSE;
    }
    _JumpIfError2(hr, error, "_JetSeekFromRestriction", S_FALSE);

    cbValue = pcvr->cbValue;
    pbValue = pcvr->pbValue;

    if (ISTEXTCOLTYP(pdt->dbcoltyp) &&
        NULL != pbValue &&
        cbValue == -1)
    {
        cbValue = wcslen((WCHAR const *) pbValue) * sizeof(WCHAR);
    }

    // If we need to set an index limit, seek to the limit location, and save
    // a copy of the key until after the initial record is located.

    if (CST_SEEKINDEXRANGE & SeekData.SeekFlags)
    {
	hr = _MakeSeekKey(pcs, tableid, pdt, pbValue, cbValue);
	_JumpIfError(hr, error, "_MakeSeekKey");

	CSASSERTTHREAD(pcs);
	hr = _dbgJetSeek(pcs->SesId, tableid, SeekData.grbitSeekRange);
	if ((HRESULT) JET_errRecordNotFound == hr)
	{
	    // No record exists past the data we're interested in.
	    // Just use the end of the index as the limit.

	    _PrintError2(hr, "JetSeek(Range Limit): no key, index end is limit", hr);
	    SeekData.SeekFlags &= ~CST_SEEKINDEXRANGE;
	    hr = S_OK;
	}
	else if ((HRESULT) JET_wrnSeekNotEqual == hr)
	{
	    _PrintError2(hr, "JetSeek(Range): ignoring key not equal", hr);
	    hr = S_OK;		// Ignore inexact match when seeking >= or <=
	}
	//_JumpIfError2(hr, error, "JetSeek(IndexRange)", S_FALSE);
	_JumpIfError(hr, error, "JetSeek(IndexRange)");
    }

    // If we found a valid key at the limit location, save it now.

    cbRangeKey = 0;
    if (CST_SEEKINDEXRANGE & SeekData.SeekFlags) 
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetRetrieveKey(
			pcs->SesId,
			tableid,
			abRangeKey,
			ARRAYSIZE(abRangeKey),
			&cbRangeKey,
			0);
	_JumpIfError(hr, error, "JetRetrieveKey");

	DBGPRINT((DBG_SS_CERTDBI, "RetrieveKey(Range):\n"));
	DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, abRangeKey, cbRangeKey));
    }

    // Locate the initial record: seek to a key or move to one end of the index

    if (CST_SEEKNOTMOVE & SeekData.SeekFlags)
    {
        hr = _MakeSeekKey(pcs, tableid, pdt, pbValue, cbValue);
        _JumpIfError(hr, error, "_MakeSeekKey");
        
        CSASSERTTHREAD(pcs);
        hr = _dbgJetSeek(pcs->SesId, tableid, SeekData.grbitInitial);
        if ((HRESULT) JET_errRecordNotFound == hr)
        {
            // Routine GetAttribute/Extension call:

            _PrintError2(hr, "JetSeek: Property EMPTY", hr);
            hr = S_FALSE;
        }
        else if ((HRESULT) JET_wrnSeekNotEqual == hr)
        {
            hr = S_OK;		// Ignore inexact match when seeking >= or <=
        }
        _JumpIfError2(hr, error, "JetSeek(Initial)", S_FALSE);
    }
    else
    {
        // grbitInitial is a move count here, not a grbit

        CSASSERTTHREAD(pcs);
        hr = _dbgJetMove(pcs->SesId, tableid, SeekData.grbitInitial, 0);
        if ((HRESULT) JET_errNoCurrentRecord == hr)
        {
            // Routine Enumerate call:

            // _JumpIfError(hr, error, "JetMove: no more elements");
            hr = S_FALSE;
        }
        _JumpIfError2(hr, error, "JetMove(End)", S_FALSE);

        // If moving the cursor to the last element, we want to position
	// ourselves to step over the end again (skip the last element).
	//
        // If moving to the first element, we want to position ourselves on the
	// first element and use it before stepping

	if (SEEKPOS_FIRST == dwPosition || SEEKPOS_INDEXFIRST == dwPosition)
	{
	    SeekData.SeekFlags |= CST_SEEKUSECURRENT;
	}
    }

    // We're done seeking around; set the index limit from the saved key.

    if (CST_SEEKINDEXRANGE & SeekData.SeekFlags)
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetMakeKey(
			pcs->SesId,
			tableid,
			abRangeKey,
			cbRangeKey,
			JET_bitNormalizedKey);
	_JumpIfError(hr, error, "JetMakeKey");

	DBGPRINT((DBG_SS_CERTDBI, "RangeKey:\n"));
	DBGDUMPHEX((DBG_SS_CERTDBI, DH_NOADDRESS, abRangeKey, cbRangeKey));

        CSASSERTTHREAD(pcs);
	hr = _dbgJetSetIndexRange(
			pcs->SesId,
			tableid,
			SeekData.grbitRange);
	if ((HRESULT) JET_errNoCurrentRecord == hr)
	{
	    // No records to enumerate:
	    _PrintError2(hr, "JetSetIndexRange: no records to enumerate", hr);
	    hr = S_FALSE;
	}
	_JumpIfError2(hr, error, "JetSetIndexRange", S_FALSE);
    }

    DBGCODE(_DumpRowId("post-_SeekTable", pcs, tableid));
    DBGCODE(_DumpColumn("post-_SeekTable", pcs, tableid, pdt, pIComputedColumn));

    *pTableFlags = SeekData.SeekFlags;

error:
    if (S_FALSE == hr)
    {
	DWORD dwPosition2 = dwPosition;

	switch (dwPosition)
	{
	    case SEEKPOS_FIRST:
		dwPosition2 = SEEKPOS_INDEXFIRST;
		break;

	    case SEEKPOS_LAST:
		dwPosition2 = SEEKPOS_INDEXLAST;
		break;
	}
	if (dwPosition2 != dwPosition)
	{
	    hr = _SeekTable(
			pcs,
			tableid,
			pcvr,
			pdt,
			pIComputedColumn,
			dwPosition2,
			pTableFlags
			DBGPARM(pdbaux));
	    _PrintIfError2(hr, "_SeekTable: recurse on index first/last", S_FALSE);
	}
    }
#if DBG_CERTSRV
    if (S_OK != hr)
    {
	DumpRestriction(DBG_SS_CERTDBI, 0, pcvr);
    }
#endif
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_MoveTable(
    IN  CERTSESSION                   *pcs,
    IN  DWORD                          ccvr,
    IN  CERTVIEWRESTRICTION const     *pcvr,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
    IN  LONG	                       cskip,
    OUT LONG	                      *pcskipped)
{
    HRESULT hr;
    DWORD cb;
    DBAUXDATA const *pdbaux;
    DBTABLE const *pdt;
    DWORD icvr;
    LONG lSeek;
    LONG skipIncrement;
    LONG cskipRemain;
    BOOL fHitEnd = FALSE;
    LONG cskippeddummy;
    CERTSESSIONTABLE *pTable;
    CERTSESSIONTABLE *pTable2;

    *pcskipped = 0;
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_MoveTable called(ccvr=%d, cskip=%d, flags=%ws)\n",
	    ccvr,
	    cskip,
	    wszCSFFlags(pcs->SesFlags)));

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    _JumpIfError(hr, error, "_MapPropIdIndex");

    pTable = &pcs->aTable[CSTI_PRIMARY];
    pTable2 = NULL;

    switch (DTI_TABLEMASK & pcvr->ColumnIndex)
    {
	case DTI_REQUESTTABLE:
	    pdbaux = &g_dbauxRequests;
	    pTable2 = &pcs->aTable[CSTI_CERTIFICATE];
	    break;

	case DTI_CERTIFICATETABLE:
	    pdbaux = &g_dbauxCertificates;
	    pTable = &pcs->aTable[CSTI_CERTIFICATE];
	    pTable2 = &pcs->aTable[CSTI_PRIMARY];
	    break;

	case DTI_EXTENSIONTABLE:
	    pdbaux = &g_dbauxExtensions;
	    break;

	case DTI_ATTRIBUTETABLE:
	    pdbaux = &g_dbauxAttributes;
	    break;

	case DTI_CRLTABLE:
	    pdbaux = &g_dbauxCRLs;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "ColumnIndex Table");
    }

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_MoveTable(Table=%hs, TableFlags=%ws)\n",
	    pdbaux->pszTable,
	    wszCSTFlags(pTable->TableFlags)));

    if (NULL != pTable2 && IsValidJetTableId(pTable2->TableId))
    {
	DBGPRINT((
		DBG_SS_CERTDBI,
		"_MoveTable(Table2=%hs, TableFlags2=%ws)\n",
		&g_dbauxCertificates == pdbaux?
		    g_dbauxRequests.pszTable :
		    g_dbauxCertificates.pszTable,
		wszCSTFlags(pTable2->TableFlags)));
    }

    switch (pcvr->SortOrder)
    {
	case CVR_SORT_DESCEND:
	    lSeek = JET_MovePrevious;
	    break;

	case CVR_SORT_NONE:
	default:
	    CSASSERT(!"bad pcvr->SortOrder");	// shouldn't get this far
	    // FALL THROUGH

	case CVR_SORT_ASCEND:
	    lSeek = JET_MoveNext;
	    break;
    }

    // Add one to the skip count for the implicit Next operation.  Next
    // always moves forward one, even when a negative skip count moves
    // backward.  The net result may be a forward or backward skip.

    cskipRemain = cskip + 1;
    skipIncrement = 1;
    if (0 > cskipRemain)
    {
	CSASSERT(JET_MoveNext == -1 * JET_MovePrevious);
	lSeek *= -1;		// Seek in opposite direction
	cskipRemain *= -1;	// make the skip count positive
	skipIncrement = -1;
    }
    CSASSERT(0 <= cskipRemain);

    while (0 != cskipRemain)
    {
	DBGPRINT((
		DBG_SS_CERTDBI,
		"_MoveTable loop: ccvr=%d, cskipRemain=%d, lSeek=%d, flags=%ws\n",
		ccvr,
		cskipRemain,
		lSeek,
		wszCSFFlags(pcs->SesFlags)));

	DBGCODE(_DumpRowId("_MoveTable(loop top)", pcs, pTable->TableId));

	if (CSF_VIEW & pcs->SesFlags)
	{
	    hr = TestShutDownState();
	    _JumpIfError(hr, error, "TestShutDownState");
	}

	if (CSF_VIEWRESET & pcs->SesFlags)
	{
	    hr = _SeekTable(
			pcs,
			pTable->TableId,
			pcvr,
			pdt,
			pIComputedColumn,
			SEEKPOS_FIRST,
			&pTable->TableFlags
			DBGPARM(pdbaux));
	    _JumpIfError(hr, error, "_SeekTable");

	    pcs->SesFlags &= ~CSF_VIEWRESET;
	}
	if (0 == (CST_SEEKUSECURRENT & pTable->TableFlags))
	{
            CSASSERTTHREAD(pcs);
	    hr = _dbgJetMove(pcs->SesId, pTable->TableId, lSeek, 0);
	    if ((HRESULT) JET_errNoCurrentRecord == hr)
	    {
		_PrintIfError2(hr, "JetMove: no more elements", hr);

		if (fHitEnd)
		{
		    // we hit the end trying to backstep! We're done
		    hr = S_FALSE;
		    _JumpError2(
			    hr,
			    error,
			    "JetMove: db backstep hit beginning",
			    hr);
		}
		fHitEnd = TRUE;

		// NOTE: Tough case
		//
		// We just hit the end of the database index, which could be a
		// virtual end or the real end.  To recover, we call _SeekTable
		// to position ourselves at the last legal element computed by
		// the 1st restriction, then allow this routine to rewind until
		// we position ourselves on the very last legal element as
		// computed by 2nd through Nth restrictions.

		// Routine Seek call to position at end of enumeration

	        hr = _SeekTable(
			    pcs,
			    pTable->TableId,
			    pcvr,
			    pdt,
			    pIComputedColumn,
			    SEEKPOS_LAST,	// cursor at end
			    &pTable->TableFlags
			    DBGPARM(pdbaux));
	        _JumpIfError(hr, error, "_SeekTable moving to last elt");

		// now fall through, allow other restrictions to test for 1st
		// valid element

	        lSeek *= -1;			// Seek in opposite direction
	        cskipRemain = 1;		// one valid element
		pcskipped = &cskippeddummy;	// stop counting skipped rows
	    }
	    _JumpIfError2(hr, error, "JetMove", S_FALSE);

	    DBGCODE(_DumpRowId("_MoveTable(post-move)", pcs, pTable->TableId));

	    hr = _CompareColumnValue(pcs, pcvr, pIComputedColumn);
	    _JumpIfError2(hr, error, "_CompareColumnValue", S_FALSE);
	}
	pTable->TableFlags &= ~CST_SEEKUSECURRENT;

	// Fetch RowId from the first table, form a key for the second
	// table and seek to the corresponding record in the second table.

	cb = sizeof(pcs->RowId);
	hr = _RetrieveColumn(
			pcs,
			pTable->TableId,
			pdbaux->pdtRowId,
			pdbaux->pdtRowId->dbcolumnid,
			NULL,
			&cb,
			(BYTE *) &pcs->RowId);
	_JumpIfError(hr, error, "_RetrieveColumn");

	DBGPRINT((
		DBG_SS_CERTDBI,
		"_MoveTable(Primary) %hs --> RowId=%d\n",
		pdbaux->pszTable,
		pcs->RowId));

	if (NULL != pTable2 && IsValidJetTableId(pTable2->TableId))
	{
	    CSASSERTTHREAD(pcs);
	    hr = _dbgJetMakeKey(
			    pcs->SesId,
			    pTable2->TableId,
			    &pcs->RowId,
			    sizeof(pcs->RowId),
			    JET_bitNewKey);
	    _JumpIfError(hr, error, "JetMakeKey");

	    hr = _dbgJetSeek(pcs->SesId, pTable2->TableId, JET_bitSeekEQ);
	    if ((HRESULT) JET_errRecordNotFound == hr)
	    {
		// Database is inconsistent
		hr = S_FALSE;
	    }
	    _JumpIfError2(hr, error, "JetSeek", S_FALSE);

	    DBGPRINT((
		    DBG_SS_CERTDBI,
		    "_MoveTable(Secondary) %hs --> RowId=%d\n",
		    &g_dbauxCertificates == pdbaux?
			g_dbauxRequests.pszTable :
			g_dbauxCertificates.pszTable,
		    pcs->RowId));
	}

	// Now verify that any addtional restrictions are satisfied

	for (icvr = 1; icvr < ccvr; icvr++)
	{
#if 0
	    printf(
		"RowId=%u, cvr[%u]: seek=%x, *pb=%x\n",
		pcs->RowId,
		icvr,
		pcvr[icvr].SeekOperator,
		*(DWORD *) pcvr[icvr].pbValue);
#endif
	    hr = _CompareColumnValue(pcs, &pcvr[icvr], pIComputedColumn);
	    if (S_FALSE == hr)
	    {
		break;		// skip row silently
	    }
	    _JumpIfError(hr, error, "_CompareColumnValue");
	}
	if (icvr >= ccvr)
	{
	    *pcskipped += skipIncrement;
	    cskipRemain--;	// found a matching row
	}
    } // while (cskipRemain)

error:
    // if we nailed the end and rewound, return failure
    if (fHitEnd && S_OK == hr)
    {
        hr = S_FALSE;
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_GetResultRow(
    IN  CERTSESSION                   *pcs,
    IN  DWORD                          ccvr,
    IN  CERTVIEWRESTRICTION const     *pcvr,
    IN  LONG			       cskip,
    IN  DWORD                          ccolOut,
    IN  DWORD const                   *acolOut,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
    OUT CERTDBRESULTROW               *pelt,
    OUT LONG                          *pcskipped)
{
    HRESULT hr;
    DWORD iCol;
    BYTE *pbProp = NULL;
    BYTE *pbT;
    DWORD cbAlloc = 0;
    DWORD cbProp;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_GetResultRow(ccvr=%d, ccolOut=%d, cskip=%d, flags=%ws)\n",
	    ccvr,
	    ccolOut,
	    cskip,
	    wszCSFFlags(pcs->SesFlags)));

    // This may move past the end of the database index entries.
    // In that case, we're positioned at the end of the index.

    hr = _MoveTable(pcs, ccvr, pcvr, pIComputedColumn, cskip, pcskipped);
    _JumpIfError2(hr, error, "_MoveTable", S_FALSE);

    DBGPRINT((DBG_SS_CERTDBI, "_GetResultRow: RowId=%d\n", pcs->RowId));

    pelt->acol = (CERTDBRESULTCOLUMN *) CoTaskMemAlloc(
					    ccolOut * sizeof(pelt->acol[0]));
    if (NULL == pelt->acol)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "alloc acol");
    }

    ZeroMemory(pelt->acol, ccolOut * sizeof(pelt->acol[0]));
    pelt->rowid = pcs->RowId;
    pelt->ccol = ccolOut;

    for (iCol = 0; iCol < ccolOut; iCol++)
    {
	DBTABLE const *pdt;
	CERTDBRESULTCOLUMN *pCol;

	pCol = &pelt->acol[iCol];
	pCol->Index = acolOut[iCol];

	hr = _MapPropIdIndex(pCol->Index, &pdt, &pCol->Type);
	_JumpIfError(hr, error, "_MapPropIdIndex");

	while (TRUE)
	{
	    cbProp = cbAlloc;
	    hr = GetProperty(pcs, pdt, pIComputedColumn, &cbProp, pbProp);
	    if (CERTSRV_E_PROPERTY_EMPTY == hr)
	    {
		break;		// leave 0 size, NULL pointer
	    }
	    if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
	    {
		_JumpIfError(hr, error, "GetProperty");
	    }

	    if (cbAlloc >= cbProp)
	    {
		CSASSERT(S_OK == hr);
		CSASSERT(0 != cbProp && NULL != pbProp);
		break;		// property value is in cbProp, pbProp
	    }

	    // Property value is too large for the buffer -- grow it
	    if (NULL == pbProp)
	    {
		pbT = (BYTE *) LocalAlloc(LMEM_FIXED, cbProp);
	    }
	    else
	    {
		pbT = (BYTE *) LocalReAlloc(pbProp, cbProp, LMEM_MOVEABLE);
	    }
	    if (NULL == pbT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc/LocalReAlloc property");
	    }
	    pbProp = pbT;
	    cbAlloc = cbProp;
	}
	if (CERTSRV_E_PROPERTY_EMPTY != hr)
	{
	    BYTE const *pb = pbProp;

	    if (PROPTYPE_STRING == (PROPTYPE_MASK & pCol->Type))
	    {
		CSASSERT(L'\0' == *(WCHAR *) &pbProp[cbProp]);
		cbProp += sizeof(WCHAR);    // include NULL term
	    }
	    pCol->cbValue = cbProp;
	    pCol->pbValue = (BYTE *) CoTaskMemAlloc(cbProp);
	    if (NULL == pCol->pbValue)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "CoTaskMemAlloc");
	    }
	    CopyMemory(pCol->pbValue, pb, pCol->cbValue);
	}
	DBGPRINT((
		DBG_SS_CERTDBI,
		"_GetResultRow: fetch %ws.%ws: type=%x cb=%x\n",
		wszTable(pdt->dwTable),
		pdt->pwszPropName,
		pCol->Type,
		pCol->cbValue));
    }
    hr = S_OK;

error:
    if (NULL != pbProp)
    {
	LocalFree(pbProp);
    }
    return(hr);
}


HRESULT
CCertDB::ReleaseResultRow(
    IN     ULONG            celt,
    IN OUT CERTDBRESULTROW *rgelt)
{
    HRESULT hr;
    DWORD iRow;
    DWORD iCol;
    CERTDBRESULTROW *pResultRow;

    if (NULL == rgelt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    for (iRow = 0; iRow < celt; iRow++)
    {
	pResultRow = &rgelt[iRow];
	if (NULL != pResultRow->acol)
	{
	    for (iCol = 0; iCol < pResultRow->ccol; iCol++)
	    {
		if (NULL != pResultRow->acol[iCol].pbValue)
		{
		    CoTaskMemFree(pResultRow->acol[iCol].pbValue);
		    pResultRow->acol[iCol].pbValue = NULL;
		}
	    }
	    CoTaskMemFree(pResultRow->acol);
	    pResultRow->acol = NULL;
	}
	pResultRow->ccol = 0;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertDB::EnumerateSetup(
    IN     CERTSESSION *pcs,
    IN OUT DWORD       *pFlags,
    OUT    JET_TABLEID *ptableid)
{
    HRESULT hr;
    JET_TABLEID tableid = 0;
    DBAUXDATA const *pdbaux;

    if (NULL == pcs || NULL == ptableid)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    switch (*pFlags)
    {
	case CIE_TABLE_ATTRIBUTES:
	    pdbaux = &g_dbauxAttributes;
	    break;

	case CIE_TABLE_EXTENSIONS:
	    pdbaux = &g_dbauxExtensions;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "*pFlags");
    }

    CSASSERTTHREAD(pcs);
    hr = _dbgJetOpenTable(
			pcs->SesId,
			pcs->DBId,
			pdbaux->pszTable,
			NULL,
			0,
			0,
			&tableid);
    _JumpIfError(hr, error, "JetOpenTable");

    CSASSERTTHREAD(pcs);
    hr = _dbgJetSetCurrentIndex2(
			    pcs->SesId,
			    tableid,
			    pdbaux->pszRowIdIndex,
			    JET_bitMoveFirst);
    _JumpIfError(hr, error, "JetSetCurrentIndex2");

    CSASSERTTHREAD(pcs);
    hr = _dbgJetMakeKey(
		    pcs->SesId,
		    tableid,
		    &pcs->RowId,
		    sizeof(pcs->RowId),
		    JET_bitNewKey);
    _JumpIfError(hr, error, "JetMakeKey");

    *pFlags |= CIE_RESET;
    CSASSERT(IsValidJetTableId(tableid));
    *ptableid = tableid;
    tableid = 0;

error:
    if (IsValidJetTableId(tableid))
    {
        CSASSERTTHREAD(pcs);
	_dbgJetCloseTable(pcs->SesId, tableid);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_EnumerateMove(
    IN     CERTSESSION     *pcs,
    IN OUT DWORD           *pFlags,
    IN     DBAUXDATA const *pdbaux,
    IN     JET_TABLEID      tableid,
    IN     LONG	            cskip)
{
    HRESULT hr;
    DWORD cb;
    DWORD RowId;
    LONG lSeek;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_EnumerateMove(cskip=%d, flags=%x%hs)\n",
	    cskip,
	    *pFlags,
	    (CIE_RESET & *pFlags)? " Reset" : ""));

    CSASSERT(IsValidJetTableId(tableid));
    if (CIE_RESET & *pFlags)
    {
        CSASSERTTHREAD(pcs);
	hr = _dbgJetSeek(pcs->SesId, tableid, JET_bitSeekEQ);
	if ((HRESULT) JET_errRecordNotFound == hr)
	{
	    hr = S_FALSE;
	}
	_JumpIfError2(hr, error, "JetSeek", S_FALSE);

	*pFlags &= ~CIE_RESET;
    }
    else
    {
	// Add one to the skip count for the implicit Next operation.  Next
	// always moves forward one, even when a negative skip count moves
	// backward.  The net result may be a forward or backward skip.

	cskip++;
    }

    if (0 != cskip)
    {
	lSeek = JET_MoveNext * cskip;
	CSASSERT(JET_MoveNext == -1 * JET_MovePrevious);

        CSASSERTTHREAD(pcs);
	hr = _dbgJetMove(pcs->SesId, tableid, lSeek, 0);
	if ((HRESULT) JET_errNoCurrentRecord == hr)
	{
	    hr = S_FALSE;
	}
	_JumpIfError2(hr, error, "JetMove", S_FALSE);

	// Make sure this entry is for the same request:

	cb = sizeof(RowId);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtRowId,
			pdbaux->pdtRowId->dbcolumnid,
			NULL,
			&cb,
			(BYTE *) &RowId);
	_JumpIfError(hr, error, "_RetrieveColumn");

	if (RowId != pcs->RowId)
	{
	    hr = S_FALSE;
	    goto error;
	}
    }
    hr = S_OK;

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::EnumerateNext(
    IN     CERTSESSION *pcs,
    IN OUT DWORD       *pFlags,
    IN     JET_TABLEID  tableid,
    IN     LONG         cskip,
    IN     ULONG        celt,
    OUT    CERTDBNAME  *rgelt,
    OUT    ULONG       *pceltFetched)
{
    HRESULT hr;
    DWORD cb;
    CERTDBNAME *pelt;
    WCHAR wszTmp[MAX_PATH];
    DBAUXDATA const *pdbaux;

    if (NULL == pcs || NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    ZeroMemory(rgelt, celt * sizeof(rgelt[0]));

    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    switch (CIE_TABLE_MASK & *pFlags)
    {
	case CIE_TABLE_ATTRIBUTES:
	    pdbaux = &g_dbauxAttributes;
	    break;

	case CIE_TABLE_EXTENSIONS:
	    pdbaux = &g_dbauxExtensions;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "*pFlags");
    }

    hr = S_OK;
    for (pelt = rgelt; pelt < &rgelt[celt]; pelt++)
    {
	hr = _EnumerateMove(pcs, pFlags, pdbaux, tableid, cskip);
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfError(hr, error, "_EnumerateMove");

	cskip = 0;

	cb = sizeof(wszTmp);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtName,
			pdbaux->pdtName->dbcolumnid,
			NULL,
			&cb,
			(BYTE *) wszTmp);
	_JumpIfError(hr, error, "_RetrieveColumn");

	CSASSERT(0 == (cb % sizeof(WCHAR)));    // integer # of wchars
	CSASSERT(L'\0' == wszTmp[cb / sizeof(WCHAR)]);    // zero term

	hr = _DupString(NULL, wszTmp, &pelt->pwszName);
	_JumpIfError(hr, error, "_DupString");
    }

    *pceltFetched = SAFE_SUBTRACT_POINTERS(pelt, rgelt);

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	if (NULL != rgelt)
	{
	    for (pelt = rgelt; pelt < &rgelt[celt]; pelt++)
	    {
		if (NULL != pelt->pwszName)
		{
		    CoTaskMemFree(pelt->pwszName);
		    pelt->pwszName = NULL;
		}
	    }
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::EnumerateClose(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid)
{
    HRESULT hr;

    if (NULL == pcs)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    CSASSERTTHREAD(pcs);
    hr = _dbgJetCloseTable(pcs->SesId, tableid);
    _JumpIfError(hr, error, "JetCloseTable");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_BuildColumnIds(
    IN CERTSESSION *pcs,
    IN CHAR const *pszTableName,
    IN DBTABLE *pdt)
{
    HRESULT hr;
    JET_TABLEID tableid;
    JET_COLUMNDEF columndef;
    BOOL fOpen = FALSE;

    hr = _dbgJetOpenTable(
                   pcs->SesId,
                   pcs->DBId,
                   pszTableName,
                   NULL,
                   0,
                   0,
                   &tableid);
    _JumpIfError(hr, error, "JetOpenTable");
    fOpen = TRUE;

    CSASSERT(IsValidJetTableId(tableid));
    for ( ; NULL != pdt->pwszPropName; pdt++)
    {
	if (DBTF_COMPUTED & pdt->dwFlags)
	{
	    ZeroMemory(&columndef, sizeof(columndef));
	    columndef.cbStruct = sizeof(columndef);
	    //columndef.columnid = 0;
	    columndef.coltyp = JET_coltypLong;
	    columndef.cbMax = sizeof(LONG);
	    //columndef.grbit = 0;
	}
	else
	{
	    hr = _dbgJetGetColumnInfo(
				pcs->SesId,
				pcs->DBId,
				pszTableName,
				pdt->pszFieldName,
				&columndef,
				sizeof(columndef),
				JET_ColInfo);
	    if ((HRESULT) JET_errColumnNotFound == hr &&
		(DBTF_SOFTFAIL & pdt->dwFlags))
	    {
		pdt->dwFlags |= DBTF_MISSING;
		pdt->dbcolumnid = MAXDWORD;

		DBGPRINT((
		    DBG_SS_CERTDB,
		    "_BuildColumnIds: %hs.%hs Ignoring missing column\n",
		    pszTableName,
		    pdt->pszFieldName));
		hr = S_OK;
		continue;
	    }
	    _JumpIfError(hr, error, "JetGetColumnInfo");
	}
	pdt->dbcolumnid = columndef.columnid;

	CSASSERT(
	    pdt->dbcoltyp == columndef.coltyp ||
	    (ISTEXTCOLTYP(pdt->dbcoltyp) && ISTEXTCOLTYP(columndef.coltyp)));

	if (JET_coltypText == pdt->dbcoltyp)
	{
	    CSASSERT(pdt->dwcbMax == pdt->dbcolumnMax);
	    CSASSERT(0 != pdt->dbcolumnMax);
	    CSASSERT(CB_DBMAXTEXT_MAXINTERNAL >= pdt->dbcolumnMax);
	}
	else if (JET_coltypLongText == pdt->dbcoltyp)
	{
	    CSASSERT(pdt->dwcbMax == pdt->dbcolumnMax);
	    CSASSERT(CB_DBMAXTEXT_MAXINTERNAL < pdt->dbcolumnMax);
	}
	else if (JET_coltypLongBinary == pdt->dbcoltyp)
	{
	    CSASSERT(pdt->dwcbMax == pdt->dbcolumnMax);
	    CSASSERT(0 != pdt->dbcolumnMax);
	}
	else if (JET_coltypDateTime == pdt->dbcoltyp)
	{
	    CSASSERT(sizeof(DATE) == pdt->dwcbMax);
	    CSASSERT(0 == pdt->dbcolumnMax);
	}
	else if (JET_coltypLong == pdt->dbcoltyp)
	{
	    CSASSERT(sizeof(LONG) == pdt->dwcbMax);
	    CSASSERT(0 == pdt->dbcolumnMax);
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTDB,
		"_BuildColumnIds: %hs.%hs Unknown column type %u\n",
		pszTableName,
		pdt->pszFieldName,
		pdt->dbcoltyp));
	    CSASSERT(!"Unknown column type");
	}
	if (pdt->dwcbMax != columndef.cbMax)
	{
	    DBGPRINT((
		DBG_SS_CERTDB,
		"_BuildColumnIds: %hs.%hs length %u, expected %u\n",
		pszTableName,
		pdt->pszFieldName,
		columndef.cbMax,
		pdt->dwcbMax));

	    // max size can only be increased...

	    if (pdt->dwcbMax > columndef.cbMax)
	    {
		JET_DDLMAXCOLUMNSIZE jdmcs;

		jdmcs.szTable = const_cast<char *>(pszTableName);
		jdmcs.szColumn = const_cast<char *>(pdt->pszFieldName);
		jdmcs.cbMax = pdt->dwcbMax;

		hr = _dbgJetConvertDDL(
				pcs->SesId,
				pcs->DBId,
				opDDLConvIncreaseMaxColumnSize,
				&jdmcs,
				sizeof(jdmcs));
		_PrintIfError(hr, "JetConvertDDL");
		if (S_OK == hr)
		{
		    m_fDBRestart = TRUE;
		    DBGPRINT((
			DBG_SS_CERTDB,
			"Increased Column Size: %hs.%hs: %x->%x\n",
			jdmcs.szTable,
			jdmcs.szColumn,
			columndef.cbMax,
			jdmcs.cbMax));
		}
	    }
	}
	pdt->dbcolumnidOld = MAXDWORD;
	if (chTEXTPREFIX == *pdt->pszFieldName ||
	    (DBTF_COLUMNRENAMED & pdt->dwFlags))
	{
	    char const *pszFieldName = &pdt->pszFieldName[1];
	    
	    if (DBTF_COLUMNRENAMED & pdt->dwFlags)
	    {
		pszFieldName += strlen(pszFieldName) + 1;
	    }
	    CSASSERT(
		chTEXTPREFIX != *pszTableName ||
		ISTEXTCOLTYP(columndef.coltyp));

	    hr = _dbgJetGetColumnInfo(
				pcs->SesId,
				pcs->DBId,
				pszTableName,
				pszFieldName,
				&columndef,
				sizeof(columndef),
				JET_ColInfo);
	    if (S_OK == hr)
	    {
		CSASSERT(
		    chTEXTPREFIX != *pszTableName ||
		    ISTEXTCOLTYP(columndef.coltyp));

		DBGPRINT((
		    DBG_SS_CERTDB,
		    "Found Old Column: %hs.%hs: %x\n",
		    pszTableName,
		    pszFieldName,
		    columndef.columnid));

		pdt->dwFlags |= DBTF_OLDCOLUMNID;
		pdt->dbcolumnidOld = columndef.columnid;
		m_fFoundOldColumns = TRUE;
	    }
	    hr = S_OK;
	}
    }

error:
    if (fOpen)
    {
	HRESULT hr2;

	hr2 = _dbgJetCloseTable(pcs->SesId, tableid);
	_PrintIfError(hr2, "JetCloseTable");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_AddKeyLengthColumn(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD DBGPARMREFERENCED(RowId),
    IN DBTABLE const *pdtPublicKey,
    IN DBTABLE const *pdtPublicKeyAlgorithm,
    IN DBTABLE const *pdtPublicKeyParameters,
    IN DBTABLE const *pdtPublicKeyLength,
    IN DBAUXDATA const *DBGPARMREFERENCED(pdbaux),
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    DWORD cb;
    DWORD KeyLength;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;

    ZeroMemory(&PublicKeyInfo, sizeof(PublicKeyInfo));

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Computing %hs[%d].%hs\n",
	    pdbaux->pszTable,
	    RowId,
	    pdtPublicKeyLength->pszFieldName));

    cb = sizeof(KeyLength);
    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdtPublicKeyLength,
		    pdtPublicKeyLength->dbcolumnid,
		    NULL,
		    &cb,
		    (BYTE *) &KeyLength);
    if (S_OK == hr)
    {
	goto error;		// already set -- skip this column
    }
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpError(hr, error, "_RetrieveColumn");
    }

    // Fetch the public key algorithm ObjId & copy as ansi to alloc'd memory.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtPublicKeyAlgorithm,
		    pdtPublicKeyAlgorithm->dbcolumnid,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtPublicKeyAlgorithm->pwszPropName);

    if (!ConvertWszToSz(
		&PublicKeyInfo.Algorithm.pszObjId,
		(WCHAR const *) *ppbBuf,
		-1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(LogDir)");
    }

    // Fetch the public key algorithm paramaters, and copy to alloc'd memory.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtPublicKeyParameters,
		    pdtPublicKeyParameters->dbcolumnid,
		    &PublicKeyInfo.Algorithm.Parameters.cbData,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtPublicKeyParameters->pwszPropName);

    PublicKeyInfo.Algorithm.Parameters.pbData = (BYTE *) LocalAlloc(
				LMEM_FIXED,
				PublicKeyInfo.Algorithm.Parameters.cbData);
    if (NULL == PublicKeyInfo.Algorithm.Parameters.pbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz(LogDir)");
    }
    CopyMemory(
	    PublicKeyInfo.Algorithm.Parameters.pbData,
	    *ppbBuf,
	    PublicKeyInfo.Algorithm.Parameters.cbData);

    // Fetch the public key, and leave in dynamic buffer.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtPublicKey,
		    pdtPublicKey->dbcolumnid,
		    &PublicKeyInfo.PublicKey.cbData,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtPublicKey->pwszPropName);

    PublicKeyInfo.PublicKey.pbData = *ppbBuf;
    KeyLength = CertGetPublicKeyLength(X509_ASN_ENCODING, &PublicKeyInfo);

    // Store the key length in the new column
    
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdtPublicKeyLength,
		pdtPublicKeyLength->dbcolumnid,
		sizeof(KeyLength),
		(BYTE const *) &KeyLength);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdtPublicKeyLength->pwszPropName);

    DBGPRINT((
	DBG_SS_CERTDB,
	"Computed %hs[%d].%hs: %u\n",
	pdbaux->pszTable,
	RowId,
	pdtPublicKeyLength->pszFieldName,
	KeyLength));

error:
    if (NULL != PublicKeyInfo.Algorithm.pszObjId)
    {
	LocalFree(PublicKeyInfo.Algorithm.pszObjId);
    }
    if (NULL != PublicKeyInfo.Algorithm.Parameters.pbData)
    {
	LocalFree(PublicKeyInfo.Algorithm.Parameters.pbData);
    }
    return(hr);
}


HRESULT
CCertDB::_AddCallerName(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD DBGPARMREFERENCED(RowId),
    IN DBTABLE const *pdtCallerName,
    IN DBTABLE const *pdtRequesterName,
    IN DBAUXDATA const *DBGPARMREFERENCED(pdbaux),
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    DWORD cb;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Copying %hs[%d].%hs\n",
	    pdbaux->pszTable,
	    RowId,
	    pdtCallerName->pszFieldName));

    cb = 0;
    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdtCallerName,
		    pdtCallerName->dbcolumnid,
		    NULL,
		    &cb,
		    NULL);
    if (S_OK == hr)
    {
	goto error;		// already set -- skip this column
    }
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpError(hr, error, "_RetrieveColumn");
    }

    // Fetch the ReqesterName

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtRequesterName,
		    pdtRequesterName->dbcolumnid,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtRequesterName->pwszPropName);

    // Store the RequesterName as the CallerName in the new column
    
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdtCallerName,
		pdtCallerName->dbcolumnid,
		cb,
		*ppbBuf);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdtCallerName->pwszPropName);

    DBGPRINT((
	DBG_SS_CERTDB,
	"Copied %hs[%d].%hs: %ws\n",
	pdbaux->pszTable,
	RowId,
	pdtCallerName->pszFieldName,
	*ppbBuf));

error:
    return(hr);
}


HRESULT
CCertDB::_SetHashColumnIfEmpty(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD DBGPARMREFERENCED(RowId),
    IN DBTABLE const *pdtHash,
    IN DBAUXDATA const *DBGPARMREFERENCED(pdbaux),
    IN BYTE const *pbHash,
    IN DWORD cbHash)
{
    HRESULT hr;
    DWORD cb;
    BSTR strHash = NULL;

    cb = 0;
    hr = _RetrieveColumn(
		    pcs,
		    tableid,
		    pdtHash,
		    pdtHash->dbcolumnid,
		    NULL,
		    &cb,
		    NULL);
    if (S_OK == hr)
    {
	goto error;	// already set -- skip this column...
    }
    if (CERTSRV_E_PROPERTY_EMPTY != hr)
    {
	_JumpError(hr, error, "_RetrieveColumn");

    }
    hr = MultiByteIntegerToBstr(TRUE, cbHash, pbHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    // Store the computed hash.
    
    hr = _SetColumn(
		pcs->SesId,
		tableid,
		pdtHash,
		pdtHash->dbcolumnid,
		wcslen(strHash) * sizeof(WCHAR),
		(BYTE const *) strHash);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdtHash->pwszPropName);

    DBGPRINT((
	DBG_SS_CERTDB,
	"Derived %hs[%d].%hs: %ws\n",
	pdbaux->pszTable,
	RowId,
	pdtHash->pszFieldName,
	strHash));

error:
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
CCertDB::_AddCertColumns(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD RowId,
    IN DBTABLE const *pdtCertHash,
    IN DBTABLE const *pdtSKI,
    IN DBTABLE const *pdtCert,
    IN DBAUXDATA const *pdbaux,
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cb;
    BYTE *pbSKI = NULL;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Deriving from %hs[%d].%hs\n",
	    pdbaux->pszTable,
	    RowId,
	    pdtCert->pszFieldName));

    // Fetch the Cert

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdtCert,
		    pdtCert->dbcolumnid,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this row
    }
    _JumpIfErrorStr(
		hr,
		error,
		"_RetrieveColumnBuffer",
		pdtCert->pwszPropName);

    pcc = CertCreateCertificateContext(X509_ASN_ENCODING, *ppbBuf, *pcbBuf);
    if (NULL == pcc)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertCreateCertificateContext");
    }
    if (NULL != pdtCertHash)
    {
	cb = sizeof(abHash);
	if (!CertGetCertificateContextProperty(
				    pcc,
				    CERT_SHA1_HASH_PROP_ID,
				    abHash,
				    &cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertGetCertificateContextProperty");
	}

	hr = _SetHashColumnIfEmpty(
			    pcs,
			    tableid,
			    RowId,
			    pdtCertHash,
			    pdbaux,
			    abHash,
			    cb);
	_JumpIfError(hr, error, "_SetHashColumnIfEmpty");
    }
    if (NULL != pdtSKI)
    {
	hr = myGetPublicKeyHash(
			pcc->pCertInfo,
			&pcc->pCertInfo->SubjectPublicKeyInfo,
			&pbSKI,
			&cb);
	_JumpIfError(hr, error, "myGetPublicKeyHash");

	hr = _SetHashColumnIfEmpty(
			    pcs,
			    tableid,
			    RowId,
			    pdtSKI,
			    pdbaux,
			    pbSKI,
			    cb);
	_JumpIfError(hr, error, "_SetHashColumnIfEmpty");
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    if (NULL != pbSKI)
    {
	LocalFree(pbSKI);
    }
    return(hr);
}


HRESULT
CCertDB::_ConvertColumnData(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DWORD DBGPARMREFERENCED(RowId),
    IN DBTABLE const *pdt,
    IN DBAUXDATA const *DBGPARMREFERENCED(pdbaux),
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    WCHAR *pwszNew = NULL;
    BYTE const *pbNew;
    DWORD cb;

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Converting %hs[%d].%hs:\n",
	    pdbaux->pszTable,
	    RowId,
	    pdt->pszFieldName));

    // Fetch old column.  Grows the buffer if necessary.

    hr = _RetrieveColumnBuffer(
		    pcs,
		    tableid,
		    pdt,
		    pdt->dbcolumnidOld,
		    &cb,
		    ppbBuf,
		    pcbBuf);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;		// No old data -- skip this column
    }
    _JumpIfErrorStr(hr, error, "_RetrieveColumnBuffer", pdt->pwszPropName);

    if (DBTF_COLUMNRENAMED & pdt->dwFlags)
    {
	pbNew = *ppbBuf;
    }
    else
    {
	if (!ConvertSzToWsz(&pwszNew, (char *) *ppbBuf, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertSzToWsz");
	}
	pbNew = (BYTE const *) pwszNew;
	cb = wcslen(pwszNew) * sizeof(WCHAR);
    }

    // Store the converted string in the Unicode column
    
    hr = _SetColumn(pcs->SesId, tableid, pdt, pdt->dbcolumnid, cb, pbNew);
    _JumpIfErrorStr(hr, error, "_SetColumn", pdt->pwszPropName);

    if (JET_coltypLong != pdt->dbcoltyp)
    {
	// Clear out the old column

	hr = _SetColumn(pcs->SesId, tableid, pdt, pdt->dbcolumnidOld, 0, NULL);
	_JumpIfErrorStr(hr, error, "_SetColumn(Clear old)", pdt->pwszPropName);
    }

    DBGPRINT((
	DBG_SS_CERTDB,
	"Converted %hs[%d].%hs: %ws\n",
	pdbaux->pszTable,
	RowId,
	pdt->pszFieldName,
	ISTEXTCOLTYP(pdt->dbcoltyp)? (WCHAR const *) pbNew : L""));
    if (!ISTEXTCOLTYP(pdt->dbcoltyp))
    {
	DBGDUMPHEX((DBG_SS_CERTDB, DH_NOADDRESS, pbNew, cb));
    }

error:
    if (NULL != pwszNew)
    {
	LocalFree(pwszNew);
    }
    return(hr);
}


DBTABLE *
dbFindColumn(
    IN DBTABLE *adt,
    IN char const *pszFieldName)
{
    DBTABLE *pdt;
    DBTABLE *pdtRet = NULL;

    for (pdt = adt; NULL != pdt->pwszPropName; pdt++)
    {
	if (0 == _stricmp(pszFieldName, pdt->pszFieldName))
	{
	    pdtRet = pdt;
	    break;
	}
    }
    return(pdtRet);
}


HRESULT
CCertDB::_ConvertOldColumnData(
    IN CERTSESSION *pcs,
    IN CHAR const *pszTableName,
    IN DBAUXDATA const *pdbaux,
    IN DBTABLE *adt)
{
    HRESULT hr;
    HRESULT hr2;
    JET_TABLEID tableid;
    BOOL fOpen = FALSE;
    BOOL fTransacted = FALSE;
    DBTABLE *pdt;
    DWORD RowId;
    DWORD cb;
    BYTE *pbBuf = NULL;
    DWORD cbBuf = 0;
    BOOL fZeroIssuerNameId = FALSE;
    DWORD IssuerNameId;
    DBTABLE *pdtPublicKeyLength = NULL;
    DBTABLE *pdtPublicKey = NULL;
    DBTABLE *pdtPublicKeyAlgorithm = NULL;
    DBTABLE *pdtPublicKeyParameters = NULL;
    DBTABLE *pdtCallerName = NULL;
    DBTABLE *pdtRequesterName;
    DBTABLE *pdtCert = NULL;
    DBTABLE *pdtCertHash;
    DBTABLE *pdtSKI;

    hr = _dbgJetOpenTable(
                   pcs->SesId,
                   pcs->DBId,
                   pszTableName,
                   NULL,
                   0,
                   0,
                   &tableid);
    _JumpIfError(hr, error, "JetOpenTable");

    fOpen = TRUE;

    // Step through the RowId index for this table.

    CSASSERT(IsValidJetTableId(tableid));
    hr = _dbgJetSetCurrentIndex2(
			    pcs->SesId,
			    tableid,
			    pdbaux->pszRowIdIndex,
			    JET_bitMoveFirst);
    _JumpIfError(hr, error, "JetSetCurrentIndex2");

    if (NULL != pdbaux->pdtIssuerNameId)
    {
	cb = sizeof(IssuerNameId);
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdbaux->pdtIssuerNameId,
			pdbaux->pdtIssuerNameId->dbcolumnid,
			NULL,
			&cb,
			(BYTE *) &IssuerNameId);
	if (CERTSRV_E_PROPERTY_EMPTY == hr)
	{
	    fZeroIssuerNameId = TRUE;
	}
        else
        {
            // swallow error if empty database

	    _PrintIfErrorStr2(
		    hr,
		    "_RetrieveColumn",
		    pdbaux->pdtIssuerNameId->pwszPropName,
		    myJetHResult(JET_errNoCurrentRecord));
	}
    }

    pdtPublicKeyLength = dbFindColumn(adt, szPUBLICKEYLENGTH);
    if (NULL != pdtPublicKeyLength)
    {
	pdtPublicKey = dbFindColumn(adt, szPUBLICKEY);
	pdtPublicKeyAlgorithm = dbFindColumn(adt, szPUBLICKEYALGORITHM);
	pdtPublicKeyParameters = dbFindColumn(adt, szPUBLICKEYPARAMS);
	if (NULL == pdtPublicKey ||
	    NULL == pdtPublicKeyAlgorithm ||
	    NULL == pdtPublicKeyParameters)
	{
	    pdtPublicKeyLength = NULL;
	}
	else
	{
	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdtPublicKeyLength,
			    pdtPublicKeyLength->dbcolumnid,
			    NULL,
			    &cb,
			    NULL);
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		pdtPublicKeyLength = NULL;
	    }
	}
    }

    pdtRequesterName = NULL;
    pdtCallerName = dbFindColumn(adt, szCALLERNAME);
    if (NULL != pdtCallerName)
    {
	DBTABLE *pdtDisposition;

	pdtRequesterName = dbFindColumn(adt, szREQUESTERNAME);
	pdtDisposition = dbFindColumn(adt, szDISPOSITION);
	if (NULL == pdtRequesterName || NULL == pdtDisposition)
	{
	    pdtCallerName = NULL;
	}
	else
	{
	    // Find the first row containing a bonafide request:

	    for (;;)
	    {
		BOOL fSkip;
		LONG Disposition;

		cb = sizeof(Disposition);
		hr = _RetrieveColumn(
				pcs,
				tableid,
				pdtDisposition,
				pdtDisposition->dbcolumnid,
				NULL,
				&cb,
				(BYTE *) &Disposition);
		if (S_OK != hr)
		{
		    _PrintError(hr, "_RetrieveColumn");
		    pdtCallerName = NULL;
		    break;
		}
		switch (Disposition)
		{
		    case DB_DISP_PENDING:
		    case DB_DISP_DENIED:
		    case DB_DISP_ISSUED:
		    case DB_DISP_REVOKED:
			fSkip = FALSE;
			break;

		    default:
			fSkip = TRUE;
			break;
		}
		if (!fSkip)
		{
		    break;
		}
		hr = _dbgJetMove(pcs->SesId, tableid, JET_MoveNext, 0);
		if (S_OK != hr)
		{
		    _PrintError(hr, "JetMove");
		    pdtCallerName = NULL;
		    break;
		}
	    }
	    if (NULL != pdtCallerName)
	    {
		// Update all rows only if this row's CallerName is empty
		// and RequesterName is NOT empty.

		hr = _RetrieveColumn(
				pcs,
				tableid,
				pdtCallerName,
				pdtCallerName->dbcolumnid,
				NULL,
				&cb,
				NULL);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    pdtCallerName = NULL;
		}
		else
		{
		    hr = _RetrieveColumn(
				    pcs,
				    tableid,
				    pdtRequesterName,
				    pdtRequesterName->dbcolumnid,
				    NULL,
				    &cb,
				    NULL);
		    if (S_OK != hr)
		    {
			pdtCallerName = NULL;
		    }
		}
	    }
	    hr = _dbgJetSetCurrentIndex2(
				    pcs->SesId,
				    tableid,
				    pdbaux->pszRowIdIndex,
				    JET_bitMoveFirst);
	    _JumpIfError(hr, error, "JetSetCurrentIndex2");
	}
    }

    pdtCertHash = NULL;
    pdtSKI = NULL;
    pdtCert = dbFindColumn(adt, szRAWCERTIFICATE);
    if (NULL != pdtCert)
    {
	pdtCertHash = dbFindColumn(adt, szCERTIFICATEHASH);
	pdtSKI = dbFindColumn(adt, szSUBJECTKEYIDENTIFIER);
	if (NULL == pdtCertHash || NULL == pdtSKI)
	{
	    pdtCert = NULL;
	}
	else
	{
	    // Update all rows only if the first row's CertHash is empty,
	    // and the first row's Cert column is NOT empty.

	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdtCertHash,
			    pdtCertHash->dbcolumnid,
			    NULL,
			    &cb,
			    NULL);
	    if (CERTSRV_E_PROPERTY_EMPTY != hr)
	    {
		pdtCert = NULL;
	    }
	    else
	    {
		hr = _RetrieveColumn(
				pcs,
				tableid,
				pdtCert,
				pdtCert->dbcolumnid,
				NULL,
				&cb,
				NULL);
		if (S_OK != hr)
		{
		    pdtCert = NULL;
		}
	    }
	}
    }

    if (NULL != pdtPublicKeyLength ||
	NULL != pdtCallerName ||
	NULL != pdtCert ||
	m_fFoundOldColumns ||
	fZeroIssuerNameId)
    {
	DBGPRINT((DBG_SS_CERTDB, "Updating %hs table.\n", pdbaux->pszTable));

	while (TRUE)
	{
	    // Fetch RowId from the table.

	    cb = sizeof(pcs->RowId);
	    hr = _RetrieveColumn(
			    pcs,
			    tableid,
			    pdbaux->pdtRowId,
			    pdbaux->pdtRowId->dbcolumnid,
			    NULL,
			    &cb,
			    (BYTE *) &RowId);
	    if (S_OK != hr)
	    {
		if (myJetHResult(JET_errNoCurrentRecord) == hr)
		{
		    hr = S_OK;	// Table is empty
		    break;
		}
		_JumpError(hr, error, "_RetrieveColumn");
	    }

	    hr = _dbgJetBeginTransaction(pcs->SesId);
	    _JumpIfError(hr, error, "JetBeginTransaction");

	    fTransacted = TRUE;

	    // Transact each row.
	    //
	    // If fZeroIssuerNameId, set EMPTY IssuerNameId columns to zero.
	    //
	    // if the first row's public key length column was empty
	    //  Read the public key column, compute the size and store it
	    //
	    // if the first row's CallerName was empty
	    //  Copy RequesterName to CallerName
	    //
	    // if m_fFoundOldColumns
	    //  For each text column, do the following:
	    //   Retrieve old string from the old column,
	    //   Convert to Unicode (if old column was Ansi),
	    //   Write the Unicode string to the new column,
	    //   Set the old column to NULL.

	    hr = _dbgJetPrepareUpdate(
				pcs->SesId,
				tableid,
				JET_prepReplace);
	    _JumpIfError(hr, error, "JetPrepareUpdate");

	    if (fZeroIssuerNameId)
	    {
		cb = sizeof(IssuerNameId);
		hr = _RetrieveColumn(
				pcs,
				tableid,
				pdbaux->pdtIssuerNameId,
				pdbaux->pdtIssuerNameId->dbcolumnid,
				NULL,
				&cb,
				(BYTE *) &IssuerNameId);
		if (CERTSRV_E_PROPERTY_EMPTY != hr)
		{
		    _JumpIfError(hr, error, "_RetrieveColumn");
		}
		else
		{
		    // Only set EMPTY columns!

		    IssuerNameId = 0;

		    hr = _SetColumn(
				pcs->SesId,
				tableid,
				pdbaux->pdtIssuerNameId,
				pdbaux->pdtIssuerNameId->dbcolumnid,
				sizeof(IssuerNameId),
				(BYTE const *) &IssuerNameId);
		    _JumpIfError(hr, error, "_SetColumn");
		}
	    }

	    // Convert old columns first.
	    
	    if (m_fFoundOldColumns)
	    {
		for (pdt = adt; NULL != pdt->pwszPropName; pdt++)
		{
		    if (DBTF_OLDCOLUMNID & pdt->dwFlags)
		    {
			hr = _ConvertColumnData(
					pcs,
					tableid,
					RowId,
					pdt,
					pdbaux,
					&pbBuf,
					&cbBuf);
			_JumpIfErrorStr(
				hr,
				error,
				"_ConvertColumnData",
				pdt->pwszPropName);
		    }
		}
	    }

	    // Now compute new columns.

	    if (NULL != pdtPublicKeyLength)
	    {
		hr = _AddKeyLengthColumn(
				    pcs,
				    tableid,
				    RowId,
				    pdtPublicKey,
				    pdtPublicKeyAlgorithm,
				    pdtPublicKeyParameters,
				    pdtPublicKeyLength,
				    pdbaux,
				    &pbBuf,
				    &cbBuf);
		_JumpIfError(hr, error, "_AddKeyLengthColumn");
	    }
	    if (NULL != pdtCallerName)
	    {
		hr = _AddCallerName(
				pcs,
				tableid,
				RowId,
				pdtCallerName,
				pdtRequesterName,
				pdbaux,
				&pbBuf,
				&cbBuf);
		_JumpIfError(hr, error, "_AddCallerName");
	    }
	    if (NULL != pdtCert)
	    {
		hr = _AddCertColumns(
				pcs,
				tableid,
				RowId,
				pdtCertHash,
				pdtSKI,
				pdtCert,
				pdbaux,
				&pbBuf,
				&cbBuf);
		_JumpIfError(hr, error, "_AddCertHash");
	    }

	    // Done with this row.

	    hr = _dbgJetUpdate(pcs->SesId, tableid, NULL, 0, NULL);
	    _JumpIfError(hr, error, "JetUpdate");

	    hr = _dbgJetCommitTransaction(pcs->SesId, 0);
	    _JumpIfError(hr, error, "JetCommitTransaction");

	    fTransacted = FALSE;

	    hr = _dbgJetMove(pcs->SesId, tableid, JET_MoveNext, 0);
	    if ((HRESULT) JET_errNoCurrentRecord == hr)
	    {
		hr = S_OK;
		break;
	    }
	}
    }

    if (m_fFoundOldColumns)
    {
	hr = _dbgJetBeginTransaction(pcs->SesId);
	_JumpIfError(hr, error, "JetBeginTransaction");

	fTransacted = TRUE;

	for (pdt = adt; NULL != pdt->pwszPropName; pdt++)
	{
	    char const *pszFieldName;
	    
	    if (0 == (DBTF_OLDCOLUMNID & pdt->dwFlags))
	    {
		continue;
	    }

	    pszFieldName = &pdt->pszFieldName[1];
	    if (DBTF_COLUMNRENAMED & pdt->dwFlags)
	    {
		pszFieldName += strlen(pszFieldName) + 1;
	    }
	    DBGPRINT((
		    DBG_SS_CERTDB,
		    "Deleting column %hs.%hs\n",
		    pdbaux->pszTable,
		    pszFieldName));

	    hr = _dbgJetDeleteColumn(pcs->SesId, tableid, pszFieldName);
	    _PrintIfError(hr, "JetDeleteColumn");
	    if ((HRESULT) JET_errColumnInUse == hr)
	    {
		hr = S_OK;	// we'll delete the column next time we restart
	    }
	    _JumpIfError(hr, error, "JetDeleteColumn");
	}

	hr = _dbgJetCommitTransaction(pcs->SesId, 0);
	_JumpIfError(hr, error, "JetCommitTransaction");

	fTransacted = FALSE;
    }
    hr = S_OK;

error:
    if (NULL != pbBuf)
    {
	LocalFree(pbBuf);
    }
    if (fTransacted)
    {
	hr2 = _Rollback(pcs);
	_PrintIfError(hr2, "_Rollback");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    if (fOpen)
    {
	hr2 = _dbgJetCloseTable(pcs->SesId, tableid);
	_PrintIfError(hr2, "JetCloseTable");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_SetColumn(
    IN JET_SESID SesId,
    IN JET_TABLEID tableid,
    IN DBTABLE const *pdt,
    IN JET_COLUMNID columnid,
    IN DWORD cbProp,
    OPTIONAL IN BYTE const *pbProp)
{
    HRESULT hr;

    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    if (DBTF_COMPUTED & pdt->dwFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "Computed");
    }
    hr = _dbgJetSetColumn(SesId, tableid, columnid, pbProp, cbProp, 0, NULL);
    if ((HRESULT) JET_wrnColumnMaxTruncated == hr)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
    _JumpIfError(hr, error, "JetSetColumn");

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::SetAttribute(
    IN CERTSESSION *pcs,
    IN WCHAR const *pwszAttributeName,
    IN DWORD cbValue,
    IN BYTE const *pbValue)	// OPTIONAL
{
    return(_SetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_ATTRIBUTE],
		    pwszAttributeName,
		    NULL,
		    cbValue,
		    pbValue));
}


HRESULT
CCertDB::GetAttribute(
    IN     CERTSESSION *pcs,
    IN     WCHAR const *pwszAttributeName,
    IN OUT DWORD *pcbValue,
    OUT    BYTE *pbValue)	// OPTIONAL
{
    return(_GetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_ATTRIBUTE],
		    pwszAttributeName,
		    NULL,
		    pcbValue,
		    pbValue));
}


HRESULT
CCertDB::SetExtension(
    IN CERTSESSION *pcs,
    IN WCHAR const *pwszExtensionName,
    IN DWORD dwExtFlags,
    IN DWORD cbValue,
    IN BYTE const *pbValue)	// OPTIONAL
{
    return(_SetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_EXTENSION],
		    pwszExtensionName,
		    &dwExtFlags,
		    cbValue,
		    pbValue));
}


HRESULT
CCertDB::GetExtension(
    IN     CERTSESSION *pcs,
    IN     WCHAR const *pwszExtensionName,
    OUT    DWORD *pdwExtFlags,
    IN OUT DWORD *pcbValue,
    OUT    BYTE *pbValue)	// OPTIONAL
{
    return(_GetIndirect(
		    pcs,
		    &pcs->aTable[CSTI_EXTENSION],
		    pwszExtensionName,
		    pdwExtFlags,
		    pcbValue,
		    pbValue));
}


HRESULT
CCertDB::_JetSeekFromRestriction(
    IN CERTVIEWRESTRICTION const *pcvr,
    IN DWORD dwPosition,
    OUT DBSEEKDATA *pSeekData)
{
    HRESULT hr;
    BOOL fAscend;
    DBSEEKDATA SeekFirst;	// seek to first element matching restriction
    DBSEEKDATA SeekLast;	// seek to last element matching restriction
    DBSEEKDATA SeekIndexFirst;	// seek to first index element
    DBSEEKDATA SeekIndexLast;	// seek to last index element
    DBSEEKDATA *pSeek;
    BOOL fValid;

    // SeekLast.SeekFlags: where to seek to retrieve end-of-range key
    // SeekLast.grbitSeekRange: where to set the cursor initially: move or seek
    // SeekLast.grbitRange: other flags to be ingested while setting range:
    // (bitRange UpperLimit, Inclusive)

#if DBG_CERTSRV
    DumpRestriction(DBG_SS_CERTDBI, 0, pcvr);
#endif

    fAscend = (CVR_SORT_DESCEND != pcvr->SortOrder);
    CSASSERT(
	CVR_SORT_NONE == pcvr->SortOrder ||
	CVR_SORT_ASCEND == pcvr->SortOrder ||
	CVR_SORT_DESCEND == pcvr->SortOrder);

    ZeroMemory(&SeekFirst, sizeof(SeekFirst));
    ZeroMemory(&SeekLast, sizeof(SeekLast));
    ZeroMemory(&SeekIndexFirst, sizeof(SeekIndexFirst));
    ZeroMemory(&SeekIndexLast, sizeof(SeekIndexLast));

    switch (CVR_SEEK_MASK & pcvr->SeekOperator)
    {
	case CVR_SEEK_EQ:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT |
					CST_SEEKNOTMOVE |
					CST_SEEKINDEXRANGE;

		SeekFirst.grbitSeekRange = JET_bitSeekEQ;
		SeekFirst.grbitInitial = JET_bitSeekEQ;

		SeekFirst.grbitRange = JET_bitRangeUpperLimit |
					    JET_bitRangeInclusive;
        
		SeekLast.SeekFlags = CST_SEEKINDEXRANGE;
		SeekLast.grbitSeekRange = JET_bitSeekGT;
		SeekLast.grbitInitial = (JET_GRBIT) JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeUpperLimit;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKNOTMOVE | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekEQ;
		SeekFirst.grbitInitial = JET_bitSeekGT;
		SeekFirst.grbitRange = JET_bitRangeInclusive;

		SeekLast.SeekFlags = CST_SEEKINDEXRANGE;
		SeekLast.grbitSeekRange = JET_bitSeekEQ;
		SeekLast.grbitInitial = (JET_GRBIT) JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeInclusive;
	    }
	    break;

	case CVR_SEEK_LT:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekGE;
		SeekFirst.grbitInitial = JET_MoveFirst;
		SeekFirst.grbitRange = JET_bitRangeUpperLimit;

		SeekLast.SeekFlags = CST_SEEKINDEXRANGE;
		SeekLast.grbitSeekRange = JET_bitSeekGE;
		SeekLast.grbitInitial = (JET_GRBIT) JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeUpperLimit;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGE;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveFirst;

		SeekIndexFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexFirst.grbitInitial = JET_MoveLast;
	    }
	    break;

	case CVR_SEEK_LE:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekGT;
		SeekFirst.grbitInitial = JET_MoveFirst;
		SeekFirst.grbitRange = JET_bitRangeUpperLimit;

		SeekLast.SeekFlags = CST_SEEKINDEXRANGE; // !CST_SEEKUSECURRENT
		SeekLast.grbitSeekRange = JET_bitSeekGT;
		SeekLast.grbitInitial = (JET_GRBIT) JET_MovePrevious;
		SeekLast.grbitRange = JET_bitRangeUpperLimit;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGT;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveFirst;

		SeekIndexFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexFirst.grbitInitial = JET_MoveLast;
	    }
	    break;

	case CVR_SEEK_GE:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGE;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveLast;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekLT;
		SeekFirst.grbitInitial = JET_MoveLast;
		// Implied: SeekFirst.grbitRange = JET_bitRangeLowerLimit;

		SeekLast.SeekFlags = CST_SEEKNOTMOVE;
		SeekLast.grbitInitial = JET_bitSeekLT;

		SeekIndexLast.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexLast.grbitInitial = JET_MoveFirst;
	    }
	    break;

	case CVR_SEEK_GT:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKNOTMOVE;
		SeekFirst.grbitInitial = JET_bitSeekGT;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveLast;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT | CST_SEEKINDEXRANGE;
		SeekFirst.grbitSeekRange = JET_bitSeekLE;
		SeekFirst.grbitInitial = JET_MoveLast;
		// Implied: SeekFirst.grbitRange = JET_bitRangeLowerLimit;

		SeekLast.SeekFlags = CST_SEEKNOTMOVE;
		SeekLast.grbitInitial = JET_bitSeekLE;

		SeekIndexLast.SeekFlags = CST_SEEKUSECURRENT;
		SeekIndexLast.grbitInitial = JET_MoveFirst;
	    }
	    break;

	case CVR_SEEK_NONE:
	    if (fAscend)
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekFirst.grbitInitial = JET_MoveFirst;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveLast;
	    }
	    else
	    {
		SeekFirst.SeekFlags = CST_SEEKUSECURRENT;
		SeekFirst.grbitInitial = JET_MoveLast;

		//SeekLast.SeekFlags = 0; // not CST_SEEKUSECURRENT
		SeekLast.grbitInitial = JET_MoveFirst;
	    }
	    break;

	default:
	    CSASSERT(!"bad pcvr->SeekOperator"); // shouldn't get this far
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Seek value");
    }

    fValid = TRUE;
    switch (dwPosition)
    {
	case SEEKPOS_FIRST:
	    pSeek = &SeekFirst;
	    break;

	case SEEKPOS_LAST:
	    pSeek = &SeekLast;
	    break;

	case SEEKPOS_INDEXFIRST:
	    pSeek = &SeekIndexFirst;
	    fValid = 0 != pSeek->SeekFlags;
	    break;

	case SEEKPOS_INDEXLAST:
	    pSeek = &SeekIndexLast;
	    fValid = 0 != pSeek->SeekFlags;
	    break;

	default:
	    CSASSERT(!"bad dwPosition"); // shouldn't get this far
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwPosition value");
    }
    if (!fValid)
    {
	// For this SeekOperator, if seeking to the first or last matching
	// restriction failed, there's no point in seeking to the index end.

	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "pSeek->SeekFlags", hr);
    }
    *pSeekData = *pSeek;		// structure copy
    if (fAscend)
    {
        pSeekData->SeekFlags |= CST_SEEKASCEND;
    }

    hr = S_OK;
    DBGPRINT((
	DBG_SS_CERTDBI,
	"_JetSeekFromRestriction: SeekFlags=%ws, grbitStart=%ws\n",
	wszCSTFlags(pSeekData->SeekFlags),
	(CST_SEEKNOTMOVE & pSeekData->SeekFlags)?
		wszSeekgrbit(pSeekData->grbitInitial) :
		wszMovecrow(pSeekData->grbitInitial)));

    if (CST_SEEKINDEXRANGE & pSeekData->SeekFlags)
    {
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "_JetSeekFromRestriction: grbitSeekRange=%ws, grbitRange=%ws\n",
	    wszSeekgrbit(pSeekData->grbitSeekRange),
	    wszSetIndexRangegrbit(pSeekData->grbitRange)));
    }

error:
    return(hr);
}


HRESULT
CCertDB::_OpenTable(
    IN CERTSESSION *pcs,
    IN DBAUXDATA const *pdbaux,
    IN CERTVIEWRESTRICTION const *pcvr,
    IN OUT CERTSESSIONTABLE *pTable)
{
    HRESULT hr;
    DBTABLE const *pdt;
    BOOL fOpened = FALSE;

    hr = _MapPropIdIndex(pcvr->ColumnIndex, &pdt, NULL);
    _JumpIfError(hr, error, "_MapPropIdIndex");

    if (NULL == pdt->pszIndexName)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Column not indexed");
    }

    if (!IsValidJetTableId(pTable->TableId))
    {
	CSASSERTTHREAD(pcs);
	hr = _dbgJetOpenTable(
			   pcs->SesId,
			   pcs->DBId,
			   pdbaux->pszTable,
			   NULL,
			   0,
			   0,
			   &pTable->TableId);
	_JumpIfError(hr, error, "JetOpenTable");

	fOpened = TRUE;

	// Find RowId and/or Named column.
	// It's more efficient to pass NULL for primary index name.

	CSASSERTTHREAD(pcs);
	hr = _dbgJetSetCurrentIndex2(
				pcs->SesId,
				pTable->TableId,
				(DBTF_INDEXPRIMARY & pdt->dwFlags)?
				    NULL : pdt->pszIndexName,
				JET_bitMoveFirst);
	_JumpIfError(hr, error, "JetSetCurrentIndex2");

	DBGPRINT((
		DBG_SS_CERTDBI,
		"_OpenTable Table=%hs, Index=%hs\n",
		pdbaux->pszTable,
		pdt->pszIndexName));

    }
    hr = _SeekTable(
		pcs,
		pTable->TableId,
		pcvr,
		pdt,
		NULL,
		SEEKPOS_FIRST,
		&pTable->TableFlags
		DBGPARM(pdbaux));
    _JumpIfError2(hr, error, "_SeekTable", S_FALSE);

error:
    if (S_OK != hr && S_FALSE != hr && fOpened)
    {
	if (IsValidJetTableId(pTable->TableId))
	{
	    HRESULT hr2;

            CSASSERTTHREAD(pcs);
	    hr2 = _dbgJetCloseTable(pcs->SesId, pTable->TableId);
	    _PrintIfError(hr2, "JetCloseTable");
	}
	ZeroMemory(pTable, sizeof(*pTable));
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_SetIndirect(
    IN CERTSESSION *pcs,
    IN OUT CERTSESSIONTABLE *pTable,
    IN WCHAR const *pwszNameValue,
    OPTIONAL IN DWORD const *pdwExtFlags,
    IN DWORD cbValue,
    OPTIONAL IN BYTE const *pbValue)
{
    HRESULT hr;
    DBAUXDATA const *pdbaux;
    BOOL fExisting = FALSE;
    BOOL fDelete;
    CERTVIEWRESTRICTION cvr;
    
    if (NULL == pcs || NULL == pwszNameValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    fDelete = NULL == pbValue;
    if (NULL == pdwExtFlags)
    {
        pdbaux = &g_dbauxAttributes;
        cvr.ColumnIndex = DTI_ATTRIBUTETABLE | DTA_ATTRIBUTENAME;
    }
    else
    {
	if (0 != *pdwExtFlags)
	{
	    fDelete = FALSE;
	}
        pdbaux = &g_dbauxExtensions;
        cvr.ColumnIndex = DTI_EXTENSIONTABLE | DTE_EXTENSIONNAME;
    }
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "IN: _SetIndirect(%hs.%ws) cb = %x%ws\n",
	    pdbaux->pszTable,
	    pwszNameValue,
	    cbValue,
	    fDelete? L" DELETE" : L""));
    
    cvr.SeekOperator = CVR_SEEK_EQ;
    cvr.SortOrder = CVR_SORT_NONE;
    cvr.cbValue = wcslen(pwszNameValue) * sizeof(WCHAR);
    cvr.pbValue = (BYTE *) pwszNameValue;
    
    hr = _OpenTable(pcs, pdbaux, &cvr, pTable);
    if (S_FALSE != hr)
    {
	_JumpIfError(hr, error, "_OpenTable");

	fExisting = TRUE;
    }
    _PrintIfError2(hr, "_OpenTable", S_FALSE);
    
    if (fDelete)
    {
        if (fExisting)
	{
	    CSASSERTTHREAD(pcs);
	    hr = _dbgJetDelete(pcs->SesId, pTable->TableId);
	    _JumpIfError(hr, error, "JetDelete");
	}
    }
    else
    {
	CSASSERTTHREAD(pcs);
	hr = _dbgJetPrepareUpdate(
			    pcs->SesId,
			    pTable->TableId,
			    !fExisting? JET_prepInsert : JET_prepReplace);
	_JumpIfError(hr, error, "JetPrepareUpdate");
    
	if (!fExisting)
	{
	    // No existing row -- insert a new one:

	    // Set RowId

	    hr = _SetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtRowId,
			pdbaux->pdtRowId->dbcolumnid,
			sizeof(pcs->RowId),
			(BYTE const *) &pcs->RowId);
	    _JumpIfError(hr, error, "_SetColumn");
	    
	    
	    // Set row's name column

	    hr = _SetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtName,
			pdbaux->pdtName->dbcolumnid,
			wcslen(pwszNameValue) * sizeof(WCHAR),	// cch
			(BYTE const *) pwszNameValue /*szTmp*/);
	    _JumpIfError(hr, error, "_SetColumn");
	    
	}
    
	if (NULL != pdwExtFlags)
	{
	    // Set or update flags
	    
	    hr = _SetColumn(
			pcs->SesId,
			pTable->TableId,
			pdbaux->pdtFlags,
			pdbaux->pdtFlags->dbcolumnid,
			sizeof(*pdwExtFlags),
			(BYTE const *) pdwExtFlags);
	    _JumpIfError(hr, error, "_SetColumn");
	}
	
	
	// Set or update value
	
	hr = _SetColumn(
		    pcs->SesId,
		    pTable->TableId,
		    pdbaux->pdtValue,
		    pdbaux->pdtValue->dbcolumnid,
		    cbValue,
		    pbValue);
	_JumpIfError(hr, error, "_SetColumn");
	
	CSASSERTTHREAD(pcs);
	hr = _dbgJetUpdate(pcs->SesId, pTable->TableId, NULL, 0, NULL);
	_JumpIfError(hr, error, "JetUpdate");
    }
    
error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_GetIndirect(
    IN CERTSESSION *pcs,
    IN OUT CERTSESSIONTABLE *pTable,
    IN WCHAR const *pwszNameValue,
    OPTIONAL OUT DWORD *pdwExtFlags,
    IN OUT DWORD *pcbValue,
    OPTIONAL OUT BYTE *pbValue)
{
    HRESULT hr;
    DBAUXDATA const *pdbaux;
    CERTVIEWRESTRICTION cvr;

    if (NULL == pcs || NULL == pwszNameValue || NULL == pcbValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == pdwExtFlags)
    {
	pdbaux = &g_dbauxAttributes;
	cvr.ColumnIndex = DTI_ATTRIBUTETABLE | DTA_ATTRIBUTENAME;
    }
    else
    {
	pdbaux = &g_dbauxExtensions;
	cvr.ColumnIndex = DTI_EXTENSIONTABLE | DTE_EXTENSIONNAME;
    }
    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "IN: _GetIndirect(%hs.%ws) cb = %x\n",
	    pdbaux->pszTable,
	    pwszNameValue,
	    *pcbValue));

    cvr.SeekOperator = CVR_SEEK_EQ;
    cvr.SortOrder = CVR_SORT_NONE;
    cvr.cbValue = wcslen(pwszNameValue) * sizeof(WCHAR);
    cvr.pbValue = (BYTE *) pwszNameValue;

    hr = _OpenTable(pcs, pdbaux, &cvr, pTable);
    if (S_FALSE == hr)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
    }
    _JumpIfError2(hr, error, "_OpenTable", CERTSRV_E_PROPERTY_EMPTY);

    if (NULL != pdwExtFlags)
    {
	DWORD cb;

	// Get flags column

	cb = sizeof(*pdwExtFlags);
	hr = _RetrieveColumn(
			pcs,
			pTable->TableId,
			pdbaux->pdtFlags,
			pdbaux->pdtFlags->dbcolumnid,
			NULL,
			&cb,
			(BYTE *) pdwExtFlags);
	_JumpIfError(hr, error, "_RetrieveColumn");

	DBGPRINT((
		DBG_SS_CERTDBI,
		"_GetIndirect(%hs): Flags = %x\n",
		pdbaux->pszTable,
		*pdwExtFlags));
    }


    // Get value column

    hr = _RetrieveColumn(
                    pcs,
		    pTable->TableId,
		    pdbaux->pdtValue,
		    pdbaux->pdtValue->dbcolumnid,
		    NULL,
                    pcbValue,
                    pbValue);
    if (CERTSRV_E_PROPERTY_EMPTY == hr && NULL != pdwExtFlags)
    {
	// return zero length property value and S_OK, so the caller can see
	// the extension flags.
	
	*pcbValue = 0;
	hr = S_OK;
    }
    _JumpIfErrorStr(hr, error, "_RetrieveColumn", pwszNameValue);

    DBGPRINT((
	    DBG_SS_CERTDBI,
	    "OUT: _GetIndirect(%hs.%ws) cb = %x\n",
	    pdbaux->pszTable,
	    pwszNameValue,
	    *pcbValue));

error:
    return(myJetHResult(hr));
}


#define CB_FETCHDELTA	256

// Fetch a column.  Loop if we have to grow the buffer.

HRESULT
CCertDB::_RetrieveColumnBuffer(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DBTABLE const *pdt,
    IN JET_COLUMNID columnid,
    OUT DWORD *pcbProp,
    IN OUT BYTE **ppbBuf,
    IN OUT DWORD *pcbBuf)
{
    HRESULT hr;
    BYTE *pbBuf = *ppbBuf;
    DWORD cbBuf = *pcbBuf;
    DWORD cb;

    cb = cbBuf;
    while (TRUE)
    {
	if (NULL == pbBuf)
	{
	    // If cbBuf == 0, allocate CB_FETCHDELTA bytes.
	    // Otherwise, allocate column size *plus* CB_FETCHDELTA bytes.
	    // Ensures we make no more than two calls to _RetrieveColumn.

	    cb += CB_FETCHDELTA;
	    pbBuf = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	    if (NULL == pbBuf)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    DBGPRINT((
		DBG_SS_CERTDBI,
		"Grow buffer: %x --> %x\n", cbBuf, cb));
	    cbBuf = cb;
	}
	cb = cbBuf;
	hr = _RetrieveColumn(
			pcs,
			tableid,
			pdt,
			columnid,
			NULL,
			&cb,
			pbBuf);
	if (S_OK == hr)
	{
	    *pcbProp = cb;
	    break;		// data fit in the buffer
	}
	if (HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW) != hr)
	{
	    _JumpError2(hr, error, "_RetrieveColumn", CERTSRV_E_PROPERTY_EMPTY);
	}

	// Data won't fit.  Grow the buffer.

	CSASSERT(NULL != pbBuf);
	LocalFree(pbBuf);
	pbBuf = NULL;
    }
    CSASSERT(S_OK == hr);

error:
    *ppbBuf = pbBuf;
    *pcbBuf = cbBuf;
    return(hr);
}


HRESULT
CCertDB::_RetrieveColumn(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DBTABLE const *pdt,
    IN JET_COLUMNID columnid,
    OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp)
{
    HRESULT hr;
    DWORD cbActual;
    DWORD cbTotal;
    DWORD ColumnIdComputed;
    DWORD ColumnIdAlt;
    DWORD PropTypeAlt;
    BYTE *pbPropAltBuf = NULL;
    DBTABLE const *pdtAlt = NULL;

    if (!IsValidJetTableId(tableid))
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "tableid");
    }
    ColumnIdComputed = 0;
    ColumnIdAlt = 0;
    PropTypeAlt = 0;
    if (DBTF_COMPUTED & pdt->dwFlags)
    {
	CSASSERT(JET_coltypLong == pdt->dbcoltyp);
	CSASSERT(0 == columnid);
	if (NULL == pIComputedColumn)
	{
	    hr = (HRESULT) JET_wrnColumnNull;
	    cbActual = 0;
	    _PrintErrorStr(
		CERTSRV_E_PROPERTY_EMPTY,
		"pIComputedColumn NULL",
		pdt->pwszPropName);
	}
	else
	{
	    DWORD PropTypeT;

	    hr = _MapTableToIndex(pdt, &ColumnIdComputed);
	    _JumpIfError(hr, error, "_MapTableToIndex");

	    hr = pIComputedColumn->GetAlternateColumnId(
					    ColumnIdComputed,
					    &ColumnIdAlt,
					    &PropTypeAlt);
	    _JumpIfError(hr, error, "GetAlternateColumnId");

	    hr = _MapPropIdIndex(ColumnIdAlt, &pdtAlt, &PropTypeT);
	    _JumpIfError(hr, error, "_MapPropIdIndex");

	    if (pdt->dwTable != pdtAlt->dwTable)
	    {
		hr = CERTSRV_E_PROPERTY_EMPTY;
		_JumpError(hr, error, "pdtAlt->dwTable");
	    }

	    if (PropTypeAlt != (PROPTYPE_MASK & PropTypeT))
	    {
		hr = CERTSRV_E_PROPERTY_EMPTY;
		_JumpError(hr, error, "PropTypeAlt");
	    }
	    hr = (HRESULT) JET_wrnBufferTruncated;
	    cbActual = sizeof(LONG);
	}
    }
    else
    {
	hr = _dbgJetRetrieveColumn(
			    pcs->SesId,
			    tableid,
			    columnid,
			    NULL,
			    0,
			    &cbActual,
			    JET_bitRetrieveCopy,
			    NULL);
    }
    if ((HRESULT) JET_wrnColumnNull == hr)
    {
	// Routine GetProperty call:
	// _JumpIfError(hr, error, "JetRetrieveColumn: Property EMPTY");
	hr = CERTSRV_E_PROPERTY_EMPTY;
	goto error;
    }
    if ((HRESULT) JET_wrnBufferTruncated != hr)
    {
	_JumpIfError2(hr, error, "JetRetrieveColumn", JET_errNoCurrentRecord);
    }

    if (cbActual == 0)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError(hr, error, "JetRetrieveColumn: cbActual=0: Property EMPTY");
    }

    cbTotal = cbActual;

    if (ISTEXTCOLTYP(pdt->dbcoltyp))
    {
	DBGPRINT((DBG_SS_CERTDBI, "Size of text %d\n", cbActual));
	cbTotal += sizeof(WCHAR);
    }
    if (NULL == pbProp || cbTotal > *pcbProp)
    {
	*pcbProp = cbTotal;
	hr = S_OK;
	if (NULL != pbProp)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    //_PrintError(hr, "output buffer too small");
	}
	goto error;
    }

    if (DBTF_COMPUTED & pdt->dwFlags)
    {
	DWORD cbPropAlt;
	DWORD cbPropAltBuf = 0;

	CSASSERT(JET_coltypLong == pdt->dbcoltyp);
	CSASSERT(0 == columnid);
	CSASSERT(NULL != pIComputedColumn);

	// Fetch the alternate column

	hr = _RetrieveColumnBuffer(
			pcs,
			tableid,
			pdtAlt,
			pdtAlt->dbcolumnid,
			&cbPropAlt,
			&pbPropAltBuf,
			&cbPropAltBuf);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "_RetrieveColumnBuffer",
		    pdtAlt->pwszPropName);

	hr = pIComputedColumn->ComputeColumnValue(
					ColumnIdComputed,
					ColumnIdAlt,
					PropTypeAlt,
					cbPropAlt,
					pbPropAltBuf,
					(DWORD *) pbProp);
	_JumpIfError(hr, error, "ComputeColumnValue");

	DBGCODE(_DumpRowId("ComputeColumnValue", pcs, tableid));

	CSASSERT(sizeof(LONG) == cbActual);
	hr = S_OK;
    }
    else
    {
	hr = _dbgJetRetrieveColumn(
			    pcs->SesId,
			    tableid,
			    columnid,
			    pbProp,
			    cbActual,
			    &cbActual,
			    JET_bitRetrieveCopy,
			    NULL);
	_JumpIfError(hr, error, "JetRetrieveColumn");
    }

    *pcbProp = cbActual;

    if (ISTEXTCOLTYP(pdt->dbcoltyp))
    {
	*(WCHAR *) &pbProp[cbActual] = L'\0';
    }

error:
    if (NULL != pbPropAltBuf)
    {
	LocalFree(pbPropAltBuf);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_CreateIndex(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN CHAR const *pszIndexName,
    IN CHAR const *pchKey,
    IN DWORD cbKey,
    IN DWORD flags)
{
    HRESULT hr;

    CSASSERT(IsValidJetTableId(tableid));
    hr = _dbgJetCreateIndex(
                     pcs->SesId,
                     tableid,
                     pszIndexName,
                     flags,
                     pchKey,
                     cbKey,
                     PCDENSITYSET);
    _JumpIfError3(
		hr,
		error,
		"JetCreateIndex",
		(HRESULT) JET_errIndexDuplicate,
		(HRESULT) JET_errIndexHasPrimary);

    DBGPRINT((
	DBG_SS_CERTDBI,
	"CreateIndex: %x:%hs idx=%hs len=%x flags=%x\n",
	tableid,
	pszIndexName,
	pchKey,
	cbKey,
	flags));

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_AddColumn(
    IN CERTSESSION *pcs,
    IN JET_TABLEID tableid,
    IN DBTABLE const *pdt)
{
    HRESULT hr;
    JET_COLUMNDEF columndef;
    JET_COLUMNID columnid;

    CSASSERT(IsValidJetTableId(tableid));
    ZeroMemory(&columndef, sizeof(columndef));
    columndef.cbStruct = sizeof(columndef);
    columndef.cp = CP_UNICODE; // CP_UNICODE(1200) instead of CP_USASCII(1252)
    columndef.langid = LANGID_DBFIXED;
    columndef.wCountry = 1;
    columndef.coltyp = pdt->dbcoltyp;
    columndef.cbMax = pdt->dbcolumnMax;
    columndef.grbit = pdt->dbgrbit;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"AddColumn: %x:%hs coltyp=%x cbMax=%x grbit=%x\n",
	tableid,
	pdt->pszFieldName,
	pdt->dbcoltyp,
	pdt->dbcolumnMax,
	pdt->dbgrbit));

    hr = _dbgJetAddColumn(
		       pcs->SesId,	
		       tableid,
		       pdt->pszFieldName,
		       &columndef,
		       NULL,
		       0,
		       &columnid);
    CSASSERT((HRESULT) JET_wrnColumnMaxTruncated != hr);
    _JumpIfErrorStr3(
		hr,
		error,
		"JetAddColumn",
		pdt->pwszPropName,
		(HRESULT) JET_errColumnDuplicate,
		(HRESULT) JET_errColumnRedundant);

error:
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_CreateTable(
    IN DWORD CreateFlags,		// CF_*
    IN CERTSESSION *pcs,
    IN DBCREATETABLE const *pct)
{
    HRESULT hr;
    JET_TABLEID tableid;
    BOOL fTableOpen;
    CHAR achCol[MAX_PATH];
    DBTABLE const *pdt;
    JET_DDLINDEXDENSITY IndexDensity;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"_CreateTable(%x, %hs)\n",
	CreateFlags,
	pct->pszTableName));

    fTableOpen = FALSE;
    if (CF_MISSINGTABLES & CreateFlags)
    {
	hr = _dbgJetCreateTable(
			    pcs->SesId,
			    pcs->DBId,
			    pct->pszTableName,
			    ULTABLEPAGES,
			    PCDENSITYSET,
			    &tableid);
	if ((HRESULT) JET_errTableDuplicate != hr)
	{
	    _JumpIfError(hr, error, "JetCreateTable");

	    if (!(CF_DATABASE & CreateFlags))
	    {
		DBGPRINT((
		    DBG_SS_CERTDB,
		    "Created Missing Table: %hs:%x\n",
		    pct->pszTableName,
		    tableid));
	    }
	    hr = _dbgJetCloseTable(pcs->SesId, tableid);
	    _JumpIfError(hr, error, "JetCloseTable");
	}
    }

    hr = _dbgJetOpenTable(
		    pcs->SesId,
		    pcs->DBId,
		    pct->pszTableName,
		    NULL,			// pvParameters
		    0,				// cbParameters
		    JET_bitTableDenyRead,	// grbit
		    &tableid);
    _JumpIfError(hr, error, "JetOpenTable");
    fTableOpen = TRUE;

    CSASSERT(IsValidJetTableId(tableid));
    DBGPRINT((DBG_SS_CERTDBI, "OpenTable: %hs: %x\n", pct->pszTableName, tableid));

    if (CF_MISSINGTABLES & CreateFlags)
    {
	ULONG aulDensity[2];

	hr = _dbgJetGetTableInfo(
			    pcs->SesId,
			    tableid,
			    aulDensity,
			    sizeof(aulDensity),
			    JET_TblInfoSpaceAlloc);
	_JumpIfError(hr, error, "JetGetTableInfo");

	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Table Density: %hs: %u\n",
	    pct->pszTableName,
	    aulDensity[1]));

#if 0
	// Modifying the table density does not change the density returned by
	// JetGetTableInfo.  Instead, it modifies the primary index density,
	// which has the same effect.  There's no point in making this call,
	// because it would modify the primary index density, so we wouldn't
	// notice a restart is required when the primary index density is
	// examined below.

	if (PCDENSITYMIN > aulDensity[1] || PCDENSITYMAX < aulDensity[1])
	{
	    IndexDensity.szTable = const_cast<char *>(pct->pszTableName);
	    IndexDensity.szIndex = NULL;
	    IndexDensity.ulDensity = PCDENSITYRESET;

	    // This call doesn't seem to modify the table density returned
	    // by JetGetTableInfo.  Instead, it modifies the primary index
	    // density, which has the same effect.
	    // Make the call anyway, just in case there ever is a distinction.

	    hr = _dbgJetConvertDDL(
			    pcs->SesId,
			    pcs->DBId,
			    opDDLConvChangeIndexDensity,
			    &IndexDensity,
			    sizeof(IndexDensity));
	    _PrintIfError(hr, "JetConvertDDL");
	    if (S_OK == hr)
	    {
		m_fDBRestart = TRUE;
		DBGPRINT((
		    DBG_SS_CERTDB,
		    "Changed Table Density: %hs: %x->%x\n",
		    IndexDensity.szTable,
		    aulDensity[1],
		    IndexDensity.ulDensity));
	    }
	}
#endif
    }

    if (NULL != pct->pdt)
    {
	HRESULT hrDuplicate;
	HRESULT hrRedundant;
	HRESULT hrHasPrimary;
	
	if ((CF_DATABASE | CF_MISSINGTABLES | CF_MISSINGCOLUMNS) & CreateFlags)
	{
	    hrDuplicate = myJetHResult(JET_errColumnDuplicate);
	    hrRedundant = myJetHResult(JET_errColumnRedundant);

	    for (pdt = pct->pdt; NULL != pdt->pwszPropName; pdt++)
	    {
		if (0 == (DBTF_COMPUTED & pdt->dwFlags))
		{
		    hr = _AddColumn(pcs, tableid, pdt);
		    if (hrDuplicate == hr || hrRedundant == hr)
		    {
			_PrintError2(hr, "_AddColumn", hr);
			hr = S_OK;
		    }
		    else
		    if (S_OK == hr && !(CF_DATABASE & CreateFlags))
		    {
			m_fAddedNewColumns = TRUE;
			DBGPRINT((
			    DBG_SS_CERTDB,
			    "Added Missing Column: %hs.%hs\n",
			    pct->pszTableName,
			    pdt->pszFieldName));
		    }
		    _JumpIfErrorStr(hr, error, "_AddColumn", pdt->pwszPropName);
		}
	    }
	}
	if ((CF_DATABASE | CF_MISSINGTABLES | CF_MISSINGCOLUMNS | CF_MISSINGINDEXES) & CreateFlags)
	{
	    hrDuplicate = myJetHResult(JET_errIndexDuplicate);
	    hrHasPrimary = myJetHResult(JET_errIndexHasPrimary);

	    for (pdt = pct->pdt; NULL != pdt->pwszPropName; pdt++)
	    {
		if (NULL != pdt->pszIndexName)
		{
		    DWORD dwCreateIndexFlags = 0;
		    char *psz = achCol;
		    ULONG ulDensity;
		    
		    if (DBTF_INDEXPRIMARY & pdt->dwFlags)
		    {
			dwCreateIndexFlags |= JET_bitIndexPrimary;
		    }
		    if (DBTF_INDEXUNIQUE & pdt->dwFlags)
		    {
			dwCreateIndexFlags |= JET_bitIndexUnique;
		    }
		    if (DBTF_INDEXIGNORENULL & pdt->dwFlags)
		    {
			dwCreateIndexFlags |= JET_bitIndexIgnoreNull;
		    }
		    
		    if (DBTF_INDEXREQUESTID & pdt->dwFlags)
		    {
			psz += sprintf(psz, "+%hs", szREQUESTID) + 1;
		    }
		    psz += sprintf(psz, "+%hs", pdt->pszFieldName) + 1;
		    *psz++ = '\0';  // double terminate
		    
	    
		    if (ISTEXTCOLTYP(pdt->dbcoltyp))
		    {
			// if text field, include 2-byte langid
			*(WORD UNALIGNED *) psz = LANGID_DBFIXED;
			psz += sizeof(WORD);
			*psz++ = '\0';  // double terminate
			*psz++ = '\0';  // double terminate
		    }
		    
		    hr = _CreateIndex(
				    pcs,
				    tableid,
				    pdt->pszIndexName,
				    achCol,
				    SAFE_SUBTRACT_POINTERS(psz, achCol),
				    dwCreateIndexFlags);
		    if (hrDuplicate == hr ||
			(hrHasPrimary == hr &&
			 (DBTF_INDEXPRIMARY & pdt->dwFlags)))
		    {
			_PrintError2(hr, "_CreateIndex", hr);
			hr = S_OK;
		    }
		    else
		    if (S_OK == hr && !(CF_DATABASE & CreateFlags))
		    {
			DBGPRINT((
			    DBG_SS_CERTDB,
			    "Added Missing Index: %hs.%hs\n",
			    pct->pszTableName,
			    pdt->pszIndexName));
			if (chTEXTPREFIX == *pdt->pszIndexName ||
			    (DBTF_INDEXRENAMED & pdt->dwFlags))
			{
                            char const *pszIndexName = &pdt->pszIndexName[1];
			    
			    CSASSERTTHREAD(pcs);
			    if (DBTF_INDEXRENAMED & pdt->dwFlags)
			    {
				pszIndexName += strlen(pszIndexName) + 1;
			    }
			    hr = _dbgJetDeleteIndex(
						pcs->SesId,
						tableid,
						pszIndexName);
			    _PrintIfError2(hr, "JetDeleteIndex", hr);
			    if (S_OK == hr)
			    {
				DBGPRINT((
				    DBG_SS_CERTDB,
				    "Deleted index %hs.%hs\n",
				    pct->pszTableName,
				    pszIndexName));
			    }
			    hr = S_OK;
			}
		    }
		    _JumpIfError(hr, error, "_CreateIndex");

		    hr = _dbgJetGetIndexInfo(
					pcs->SesId,
					pcs->DBId,
					pct->pszTableName,
					pdt->pszIndexName,
					&ulDensity,
					sizeof(ulDensity),
					JET_IdxInfoSpaceAlloc);
		    _JumpIfError(hr, error, "JetGetIndexInfo");

		    DBGPRINT((
			DBG_SS_CERTDBI,
			"Index Density: %hs.%hs: %u\n",
			pct->pszTableName,
			pdt->pszIndexName,
			ulDensity));
		    if (PCDENSITYMIN > ulDensity || PCDENSITYMAX < ulDensity)
		    {
			IndexDensity.szTable = const_cast<char *>(pct->pszTableName);
			IndexDensity.szIndex = const_cast<char *>(pdt->pszIndexName);
			IndexDensity.ulDensity = PCDENSITYRESET;

			hr = _dbgJetConvertDDL(
					pcs->SesId,
					pcs->DBId,
					opDDLConvChangeIndexDensity,
					&IndexDensity,
					sizeof(IndexDensity));
			_PrintIfError(hr, "JetConvertDDL");
			if (S_OK == hr)
			{
			    m_fDBRestart = TRUE;
			    DBGPRINT((
				DBG_SS_CERTDB,
				"Changed Index Density: %hs.%hs: %x->%x\n",
				IndexDensity.szTable,
				IndexDensity.szIndex,
				ulDensity,
				IndexDensity.ulDensity));
			}
		    }
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (fTableOpen)
    {
	HRESULT hr2;

	hr2 = _dbgJetCloseTable(pcs->SesId, tableid);
	if (S_OK == hr)
	{
	    hr = hr2;
	    _JumpIfError(hr, error, "JetCloseTable");
	}
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_Create(
    IN DWORD CreateFlags,		// CF_*
    IN CHAR const *pszDataBaseName)
{
    HRESULT hr;
    DBCREATETABLE const *pct;
    CERTSESSION *pcs = NULL;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"_Create(%x, %hs)\n",
	CreateFlags,
	pszDataBaseName));

    hr = _AllocateSession(&pcs);
    _JumpIfError(hr, error, "_AllocateSession");

    if (CF_DATABASE & CreateFlags)
    {
	hr = _dbgJetCreateDatabase(
				pcs->SesId,
				pszDataBaseName,
				NULL,
				&pcs->DBId,
				0);
	_JumpIfError(hr, error, "JetCreateDatabase");

	hr = _dbgJetCloseDatabase(pcs->SesId, pcs->DBId, 0);
	_JumpIfError(hr, error, "JetCloseDatabase");
    }

    hr = _dbgJetOpenDatabase(
                      pcs->SesId,
                      pszDataBaseName,
                      NULL,
                      &pcs->DBId,
                      JET_bitDbExclusive);
    _JumpIfError(hr, error, "JetOpenDatabase");

    hr = _dbgJetBeginTransaction(pcs->SesId);
    _JumpIfError(hr, error, "JetBeginTransaction");

    for (pct = g_actDataBase; NULL != pct->pszTableName; pct++)
    {
	hr = _CreateTable(CreateFlags, pcs, pct);
	_JumpIfError(hr, error, "_CreateTable");
    }

    hr = _dbgJetCommitTransaction(pcs->SesId, 0);
    _JumpIfError(hr, error, "JetCommitTransaction");

    hr = _dbgJetCloseDatabase(pcs->SesId, pcs->DBId, 0);
    _JumpIfError(hr, error, "JetCloseDatabase");

error:
    if (NULL != pcs)
    {
	ReleaseSession(pcs);
    }
    return(myJetHResult(hr));
}


HRESULT
CCertDB::_DupString(
    OPTIONAL IN WCHAR const *pwszPrefix,
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut)
{
    DWORD cbPrefix;
    DWORD cb;
    HRESULT hr;

    cbPrefix = 0;
    if (NULL != pwszPrefix)
    {
	cbPrefix = wcslen(pwszPrefix) * sizeof(WCHAR);
    }
    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) CoTaskMemAlloc(cbPrefix + cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc");
    }
    if (NULL != pwszPrefix)
    {
	CopyMemory(*ppwszOut, pwszPrefix, cbPrefix);
    }
    CopyMemory((BYTE *) *ppwszOut + cbPrefix, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\db.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        db.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols


typedef struct _DBSEEKDATA
{
    DWORD     SeekFlags;	    // CST_*

    JET_GRBIT grbitSeekRange;	// JetSeek flags if CST_SEEKINDEXRANGE
                                // this is where to seek to retrieve
				// end-of-range key

    JET_GRBIT grbitInitial;	// JetMove or JetSeek flags: set initial cursor
                                // Where to set the cursor initially

    JET_GRBIT grbitRange;	// JetSetIndexRange flags if CST_SEEKINDEXRANGE
                                // other flags to be ingested while setting
				// range (bitRange UpperLimit, Inclusive)
} DBSEEKDATA;


// _Create() CreateFlags:

#define CF_DATABASE		0x00000001
#define CF_MISSINGTABLES	0x00000002
#define CF_MISSINGCOLUMNS	0x00000004
#define CF_MISSINGINDEXES	0x00000008

#ifdef DBG_CERTSRV
#define CSASSERTTHREAD(pcs)  \
{ \
    DWORD dwThreadId = GetCurrentThreadId(); \
    if ((pcs)->dwThreadId != dwThreadId) \
    { \
	DBGPRINT((DBG_SS_CERTDB, "Session tid=%d, Current tid=%d\n", (pcs)->dwThreadId, dwThreadId)); \
    } \
    CSASSERT((pcs)->dwThreadId == dwThreadId); \
}
#endif

HRESULT
InitGlobalWriterState(VOID);

HRESULT
UnInitGlobalWriterState(VOID);

VOID
DBFreeParms();

HRESULT
DBInitParms(
    IN DWORD cSession,
    IN DWORD DBFlags,
    OPTIONAL IN WCHAR const *pwszEventSource,
    OPTIONAL IN WCHAR const *pwszLogDir,
    OPTIONAL IN WCHAR const *pwszSystemDir,
    OPTIONAL IN WCHAR const *pwszTempDir,
    OUT JET_INSTANCE *pInstance);

#if DBG_CERTSRV

VOID
dbgcat(
    IN OUT WCHAR *pwszBuf,
    IN WCHAR const *pwszAdd);

WCHAR const *
wszSeekgrbit(
    JET_GRBIT grbit);

WCHAR const *
wszMovecrow(
    IN LONG cRow);

WCHAR const *
wszSetIndexRangegrbit(
    JET_GRBIT grbit);

WCHAR const *
wszMakeKeygrbit(
    JET_GRBIT grbit);

WCHAR const *
wszCSFFlags(
    IN LONG Flags);

WCHAR const *
wszCSTFlags(
    IN LONG Flags);

WCHAR const *
wszSeekOperator(
    IN LONG SeekOperator);

WCHAR const *
wszSortOperator(
    IN LONG SortOrder);

VOID
dbDumpValue(
    IN DWORD dwSubSystemId,
    OPTIONAL IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue);

VOID
dbDumpColumn(
    IN DWORD dwSubSystemId,
    IN DBTABLE const *pdt,
    IN BYTE const *pbValue,
    IN DWORD cbValue);

#endif // DBG_CERTSRV


class CCertDB:
    public ICertDB,
    //public ISupportErrorInfoImpl<&IID_ICertDB>,
    public CComObjectRoot,
    public CComCoClass<CCertDB, &CLSID_CCertDB>
{
public:
    CCertDB();
    ~CCertDB();

BEGIN_COM_MAP(CCertDB)
    COM_INTERFACE_ENTRY(ICertDB)
    //COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertDB) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertDB,
    wszCLASS_CERTDB TEXT(".1"),
    wszCLASS_CERTDB,
    IDS_CERTDB_DESC,
    THREADFLAGS_BOTH)

// ICertDB
public:
    STDMETHOD(Open)(
	/* [in] */ DWORD Flags,
	/* [in] */ DWORD cSession,
	/* [in] */ WCHAR const *pwszEventSource,
	/* [in] */ WCHAR const *pwszDBFile,
	/* [in] */ WCHAR const *pwszLogDir,
	/* [in] */ WCHAR const *pwszSystemDir,
	/* [in] */ WCHAR const *pwszTempDir);

    STDMETHOD(ShutDown)(
	/* [in] */ DWORD dwFlags);

    STDMETHOD(OpenRow)(
	/* [in] */ DWORD dwFlags,
	/* [in] */ DWORD RowId,
	/* [in] */ WCHAR const *pwszSerialNumberOrCertHash,	// OPTIONAL
	/* [out] */ ICertDBRow **pprow);

    STDMETHOD(OpenView)(
	/* [in] */  DWORD ccvr,
	/* [in] */  CERTVIEWRESTRICTION const *acvr,
	/* [in] */  DWORD ccolOut,
	/* [in] */  DWORD const *acolOut,
	/* [in] */  DWORD const dwFlags,
	/* [out] */ IEnumCERTDBRESULTROW **ppenum);

    STDMETHOD(EnumCertDBColumn)(
	/* [in] */  DWORD dwTable,
	/* [out] */ IEnumCERTDBCOLUMN **ppenum);

    STDMETHOD(OpenBackup)(
	/* [in] */  LONG grbitJet,
	/* [out] */ ICertDBBackup **ppBackup);

    STDMETHOD(GetDefaultColumnSet)(
        /* [in] */       DWORD  iColumnSetDefault,
        /* [in] */       DWORD  cColumnIds,
        /* [out] */      DWORD *pcColumnIds,
	/* [out, ref] */ DWORD *pColumnIds);

// CCertDB
    HRESULT BeginTransaction(
	IN CERTSESSION *pcs,
	IN BOOL fPrepareUpdate);

    HRESULT CommitTransaction(
	IN CERTSESSION *pcs,
	IN BOOL fCommit,
        IN BOOL fSoftCommit);

    HRESULT ReleaseSession(
	IN CERTSESSION *pcs);

    HRESULT BackupBegin(
	IN LONG grbitJet);

    HRESULT BackupGetDBFileList(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    HRESULT BackupGetLogFileList(
	IN OUT DWORD *pcwcList,
	OUT    WCHAR *pwszzList);		// OPTIONAL

    HRESULT BackupOpenFile(
	IN WCHAR const *pwszFile,
	OUT JET_HANDLE *phFileDB,
	OPTIONAL OUT ULARGE_INTEGER *pliSize);

    HRESULT BackupReadFile(
	IN  JET_HANDLE hFileDB,
	OUT BYTE *pb,
	IN  DWORD cb,
	OUT DWORD *pcb);

    HRESULT BackupCloseFile(
	IN JET_HANDLE hFileDB);

    HRESULT BackupTruncateLog();

    HRESULT BackupEnd();

    HRESULT SetProperty(
	IN CERTSESSION *pcs,
	IN DBTABLE const *pdt,
	IN DWORD cbProp,
	IN BYTE const *pbProp);		// OPTIONAL

    HRESULT GetProperty(
	IN     CERTSESSION *pcs,
	IN     DBTABLE const *pdt,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
	IN OUT DWORD *pcbProp,
	OUT    BYTE *pbProp);		// OPTIONAL

    HRESULT SetAttribute(
	IN CERTSESSION *pcs,
	IN WCHAR const *pwszAttributeName,
	IN DWORD cbValue,
	IN BYTE const *pbValue);	// OPTIONAL

    HRESULT GetAttribute(
	IN     CERTSESSION *pcs,
	IN     WCHAR const *pwszAttributeName,
	IN OUT DWORD *pcbValue,
	OUT    BYTE *pbValue);		// OPTIONAL

    HRESULT SetExtension(
	IN CERTSESSION *pcs,
	IN WCHAR const *pwszExtensionName,
	IN DWORD dwExtFlags,
	IN DWORD cbValue,
	IN BYTE const *pbValue);	// OPTIONAL

    HRESULT GetExtension(
	IN     CERTSESSION *pcs,
	IN     WCHAR const *pwszExtensionName,
	OUT    DWORD *pdwExtFlags,
	IN OUT DWORD *pcbValue,
	OUT    BYTE *pbValue);		// OPTIONAL

    HRESULT CopyRequestNames(
	IN CERTSESSION *pcs);

    HRESULT GetColumnType(
	IN  LONG ColumnIndex,
	OUT DWORD *pType);

    HRESULT EnumCertDBColumnNext(
	IN  DWORD         dwTable,
	IN  ULONG         ielt,
	IN  ULONG         celt,
	OUT CERTDBCOLUMN *rgelt,
	OUT ULONG        *pielt,
	OUT ULONG        *pceltFetched);

    HRESULT EnumCertDBResultRowNext(
	IN  CERTSESSION                   *pcs,
	IN  DWORD                          ccvr,
	IN  CERTVIEWRESTRICTION const     *acvr,
	IN  DWORD                          ccolOut,
	IN  DWORD const                   *acolOut,
	IN  LONG                           cskip,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
	IN  ULONG                          celt,
	OUT CERTDBRESULTROW               *rgelt,
	OUT ULONG                         *pceltFetched,
	OUT LONG		          *pcskipped);

    HRESULT ReleaseResultRow(
	IN     ULONG            celt,
	IN OUT CERTDBRESULTROW *rgelt);

    HRESULT EnumerateSetup(
	IN     CERTSESSION *pcs,
	IN OUT DWORD       *pFlags,
	OUT    JET_TABLEID *ptableid);

    HRESULT EnumerateNext(
	IN     CERTSESSION *pcs,
	IN OUT DWORD       *pFlags,
	IN     JET_TABLEID  tableid,
	IN     LONG         cskip,
	IN     ULONG        celt,
	OUT    CERTDBNAME  *rgelt,
	OUT    ULONG       *pceltFetched);

    HRESULT EnumerateClose(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid);

    HRESULT OpenTables(
	IN CERTSESSION *pcs,
	OPTIONAL IN CERTVIEWRESTRICTION const *pcvr);

    HRESULT CloseTables(
	IN CERTSESSION *pcs);

    HRESULT Delete(
	IN CERTSESSION *pcs);

    HRESULT CloseTable(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid);

    HRESULT MapPropId(
	IN  WCHAR const *pwszPropName,
	IN  DWORD dwFlags,
	OUT DBTABLE *pdtOut);

    HRESULT TestShutDownState();

#if DBG_CERTSRV
    VOID DumpRestriction(
	IN DWORD dwSubSystemId,
	IN LONG i,
	IN CERTVIEWRESTRICTION const *pcvr);
#endif // DBG_CERTSRV

private:
    HRESULT _AllocateSession(
	OUT CERTSESSION **ppcs);

    HRESULT _BackupGetFileList(
	IN           BOOL   fDBFiles,
	IN OUT       DWORD *pcwcList,
	OPTIONAL OUT WCHAR *pwszzList);

    HRESULT _CreateTable(
	IN DWORD CreateFlags,		// CF_*
	IN CERTSESSION *pcs,
	IN DBCREATETABLE const *pct);

    HRESULT _Create(
	IN DWORD CreateFlags,		// CF_*
	IN CHAR const *pszDatBaseName);

    HRESULT _CreateIndex(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN CHAR const *pszIndexName,
	IN CHAR const *pchKey,
	IN DWORD cbKey,
	IN DWORD flags);

    HRESULT _AddColumn(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DBTABLE const *pdt);

    HRESULT _BuildColumnIds(
	IN CERTSESSION *pcs,
	IN CHAR const *pszTableName,
	IN DBTABLE *pdt);

    HRESULT _ConvertOldColumnData(
	IN CERTSESSION *pcs,
	IN CHAR const *pszTableName,
	IN DBAUXDATA const *pdbaux,
	IN DBTABLE *pdt);

    HRESULT _ConvertColumnData(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdt,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _AddKeyLengthColumn(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdtPublicKey,
	IN DBTABLE const *pdtPublicKeyAlgorithm,
	IN DBTABLE const *pdtPublicKeyParameters,
	IN DBTABLE const *pdtPublicKeyLength,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _AddCallerName(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdtCallerName,
	IN DBTABLE const *pdtRequesterName,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _SetHashColumnIfEmpty(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdtHash,
	IN DBAUXDATA const *pdbaux,
	IN BYTE const *pbHash,
	IN DWORD cbHash);

    HRESULT _AddCertColumns(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DWORD RowId,
	IN DBTABLE const *pdtCertHash,
	IN DBTABLE const *pdtSKI,
	IN DBTABLE const *pdtCert,
	IN DBAUXDATA const *pdbaux,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _SetColumn(
	IN JET_SESID SesId,
	IN JET_TABLEID tableid,
	IN DBTABLE const *pdt,
	IN JET_COLUMNID columnid,
	IN DWORD cbProp,
	IN BYTE const *pbProp);		// OPTIONAL

    HRESULT _OpenTableRow(
	IN CERTSESSION *pcs,
	IN DBAUXDATA const *pdbaux,
	OPTIONAL IN CERTVIEWRESTRICTION const *pcvr,
	OUT CERTSESSIONTABLE *pTable,
	OUT DWORD *pdwRowIdMismatch);

    HRESULT _UpdateTable(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid);

    HRESULT _OpenTable(
	IN CERTSESSION *pcs,
	IN DBAUXDATA const *pdbaux,
	IN CERTVIEWRESTRICTION const *pcvr,
	IN OUT CERTSESSIONTABLE *pTable);

    HRESULT _SetIndirect(
	IN CERTSESSION *pcs,
	IN OUT CERTSESSIONTABLE *pTable,
	IN WCHAR const *pwszName,
	IN DWORD const *pdwExtFlags,	// OPTIONAL
	IN DWORD cbValue,
	IN BYTE const *pbValue);	// OPTIONAL

    HRESULT _GetIndirect(
	IN CERTSESSION *pcs,
	IN OUT CERTSESSIONTABLE *pTable,
	IN WCHAR const *pwszName,
	OUT DWORD *pdwExtFlags,	// OPTIONAL
	IN OUT DWORD *pcbValue,
	OUT BYTE *pbValue);		// OPTIONAL

    DBTABLE const *_MapTable(
	IN WCHAR const *pwszPropName,
	IN DBTABLE const *pdt);

    HRESULT _MapPropIdIndex(
	IN DWORD ColumnIndex,
	OUT DBTABLE const **ppdt,
	OPTIONAL OUT DWORD *pType);

    HRESULT _MapTableToIndex(
	IN DBTABLE const *pdt,
	OUT DWORD *pColumnIndex);

    HRESULT _RetrieveColumnBuffer(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DBTABLE const *pdt,
	IN JET_COLUMNID columnid,
	IN OUT DWORD *pcbProp,
	IN OUT BYTE **ppbBuf,
	IN OUT DWORD *pcbBuf);

    HRESULT _RetrieveColumn(
	IN CERTSESSION *pcs,
	IN JET_TABLEID tableid,
	IN DBTABLE const *pdt,
	IN JET_COLUMNID columnid,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
	IN OUT DWORD *pcbData,
	OUT BYTE *pbData);

    HRESULT _CompareColumnValue(
	IN CERTSESSION               *pcs,
	IN CERTVIEWRESTRICTION const *pcvr,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn);

    HRESULT _EnumerateMove(
	IN     CERTSESSION     *pcs,
	IN OUT DWORD           *pFlags,
	IN     DBAUXDATA const *pdbaux,
	IN     JET_TABLEID      tableid,
	IN     LONG	        cskip);

    HRESULT _MakeSeekKey(
	IN CERTSESSION   *pcs,
	IN JET_TABLEID    tableid,
	IN DBTABLE const *pdt,
	IN BYTE const    *pbValue,
	IN DWORD          cbValue);

    HRESULT _SeekTable(
	IN  CERTSESSION                   *pcs,
	IN  JET_TABLEID                    tableid,
	IN  CERTVIEWRESTRICTION const     *pcvr,
	IN  DBTABLE const                 *pdt,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
	IN  DWORD                          dwPosition,
	OUT DWORD                         *pTableFlags
	DBGPARM(IN DBAUXDATA const        *pdbaux));

    HRESULT _MoveTable(
	IN  CERTSESSION                   *pcs,
	IN  DWORD                          ccvr,
	IN  CERTVIEWRESTRICTION const     *acvr,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
	IN  LONG		           cskip,
	OUT LONG		          *pcskipped);

    HRESULT _GetResultRow(
	IN  CERTSESSION                   *pcs,
	IN  DWORD                          ccvr,
	IN  CERTVIEWRESTRICTION const     *acvr,
	IN  LONG		           cskip,
	IN  DWORD                          ccolOut,
	IN  DWORD const                   *acolOut,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn,
	OUT CERTDBRESULTROW               *pelt,
	OUT LONG                          *pcskipped);

    HRESULT _JetSeekFromRestriction(
	IN  CERTVIEWRESTRICTION const *pcvr,
	IN  DWORD dwPosition,
	OUT DBSEEKDATA *pSeekData);

    HRESULT _DupString(
	OPTIONAL IN WCHAR const *pwszPrefix,
	IN          WCHAR const *pwszIn,
	OUT         WCHAR **ppwszOut);

    HRESULT _Rollback(
	IN CERTSESSION *pcs);

#if DBG_CERTSRV
    HRESULT _DumpRowId(
	IN CHAR const  *psz,
	IN CERTSESSION *pcs,
	IN JET_TABLEID  tableid);

    HRESULT _DumpColumn(
	IN CHAR const    *psz,
	IN CERTSESSION   *pcs,
	IN JET_TABLEID    tableid,
	IN DBTABLE const *pdt,
	OPTIONAL IN ICertDBComputedColumn *pIComputedColumn);
#endif // DBG_CERTSRV

    BOOL             m_fDBOpen;
    BOOL             m_fDBReadOnly;
    BOOL             m_fDBRestart;
    BOOL             m_fFoundOldColumns;
    BOOL             m_fAddedNewColumns;
    JET_INSTANCE     m_Instance;
    CERTSESSION     *m_aSession;
    DWORD            m_cSession;
    DWORD            m_cbPage;
    CRITICAL_SECTION m_critsecSession;
    CRITICAL_SECTION m_critsecAutoIncTables;
    BOOL	     m_cCritSec;
    BOOL	     m_fPendingShutDown;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\dbtable.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbtable.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#ifndef __DBTABLE_H__
#define __DBTABLE_H__ 1


#define DTR_REQUESTID				0
#define DTR_REQUESTRAWREQUEST			1
#define DTR_REQUESTRAWARCHIVEDKEY		2
#define DTR_REQUESTKEYRECOVERYHASHES		3
#define DTR_REQUESTRAWOLDCERTIFICATE		4
#define DTR_REQUESTATTRIBUTES			5
#define DTR_REQUESTTYPE				6
#define DTR_REQUESTFLAGS			7
#define DTR_REQUESTSTATUSCODE			8
#define DTR_REQUESTDISPOSITION			9
#define DTR_REQUESTDISPOSITIONMESSAGE		10
#define DTR_REQUESTSUBMITTEDWHEN		11
#define DTR_REQUESTRESOLVEDWHEN			12
#define DTR_REQUESTREVOKEDWHEN			13
#define DTR_REQUESTREVOKEDEFFECTIVEWHEN		14
#define DTR_REQUESTREVOKEDREASON		15
#define DTR_REQUESTERNAME			16
#define DTR_CALLERNAME				17
#define DTR_SIGNERPOLICIES			18
#define DTR_SIGNERAPPLICATIONPOLICIES		19
#define DTR_OFFICER				20
#define DTR_DISTINGUISHEDNAME			21
#define DTR_RAWNAME				22
#define DTR_COUNTRY				23
#define DTR_ORGANIZATION			24
#define DTR_ORGUNIT				25
#define DTR_COMMONNAME				26
#define DTR_LOCALITY				27
#define DTR_STATE				28
#define DTR_TITLE				29
#define DTR_GIVENNAME				30
#define DTR_INITIALS				31
#define DTR_SURNAME				32
#define DTR_DOMAINCOMPONENT			33
#define DTR_EMAIL				34
#define DTR_STREETADDRESS			35
#define DTR_UNSTRUCTUREDNAME			36
#define DTR_UNSTRUCTUREDADDRESS			37
#define DTR_DEVICESERIALNUMBER			38
#define DTR_MAX					39


#define DTC_REQUESTID					0
#define DTC_RAWCERTIFICATE				1
#define DTC_CERTIFICATEHASH				2
#define DTC_CERTIFICATETEMPLATE				3
#define DTC_CERTIFICATEENROLLMENTFLAGS			4
#define DTC_CERTIFICATEGENERALFLAGS			5
#define DTC_CERTIFICATESERIALNUMBER			6
#define DTC_CERTIFICATEISSUERNAMEID			7
#define DTC_CERTIFICATENOTBEFOREDATE			8
#define DTC_CERTIFICATENOTAFTERDATE			9
#define DTC_CERTIFICATESUBJECTKEYIDENTIFIER		10
#define DTC_CERTIFICATERAWPUBLICKEY			11
#define DTC_CERTIFICATEPUBLICKEYLENGTH			12
#define DTC_CERTIFICATEPUBLICKEYALGORITHM		13
#define DTC_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS	14
#define DTC_CERTIFICATEUPN				15
#define DTC_DISTINGUISHEDNAME				16
#define DTC_RAWNAME					17
#define DTC_COUNTRY					18
#define DTC_ORGANIZATION				19
#define DTC_ORGUNIT					20
#define DTC_COMMONNAME					21
#define DTC_LOCALITY					22
#define DTC_STATE					23
#define DTC_TITLE					24
#define DTC_GIVENNAME					25
#define DTC_INITIALS					26
#define DTC_SURNAME					27
#define DTC_DOMAINCOMPONENT				28
#define DTC_EMAIL					29
#define DTC_STREETADDRESS				30
#define DTC_UNSTRUCTUREDNAME				31
#define DTC_UNSTRUCTUREDADDRESS				32
#define DTC_DEVICESERIALNUMBER				33
#define DTC_MAX						34


#define DTA_REQUESTID				0
#define DTA_ATTRIBUTENAME			1
#define DTA_ATTRIBUTEVALUE			2
#define DTA_MAX					3


#define DTE_REQUESTID				0
#define DTE_EXTENSIONNAME			1
#define DTE_EXTENSIONFLAGS			2
#define DTE_EXTENSIONRAWVALUE			3
#define DTE_MAX					4


#define DTL_ROWID				0
#define DTL_NUMBER				1
#define DTL_MINBASE				2
#define DTL_NAMEID				3
#define DTL_COUNT				4
#define DTL_THISUPDATEDATE			5
#define DTL_NEXTUPDATEDATE			6
#define DTL_THISPUBLISHDATE			7
#define DTL_NEXTPUBLISHDATE			8
#define DTL_EFFECTIVEDATE			9
#define DTL_PROPAGATIONCOMPLETEDATE		10
#define DTL_LASTPUBLISHEDDATE			11
#define DTL_PUBLISHATTEMPTS			12
#define DTL_PUBLISHFLAGS			13
#define DTL_PUBLISHSTATUSCODE			14
#define DTL_PUBLISHERROR			15
#define DTL_RAWCRL				16
#define DTL_MAX					17


#define DTI_REQUESTTABLE			0x00001000
#define DTI_CERTIFICATETABLE			0x00002000
#define DTI_ATTRIBUTETABLE			0x00003000
#define DTI_EXTENSIONTABLE			0x00004000
#define DTI_CRLTABLE				0x00005000
#define DTI_TABLEMASK				0x0000f000
#define DTI_TABLESHIFT				12
#define DTI_COLUMNMASK				((1 << DTI_TABLESHIFT) - 1)


#define ISTEXTCOLTYP(coltyp) \
	(JET_coltypText == (coltyp) || JET_coltypLongText == (coltyp))

#define IsValidJetTableId(tableid) (0 != (tableid) && 0xffffffff != (tableid))


const DWORD DBTF_POLICYWRITEABLE = 0x00000001;
const DWORD DBTF_INDEXPRIMARY	 = 0x00000002;	// Primary DB Index
const DWORD DBTF_INDEXREQUESTID	 = 0x00000004;	// Combine Index with RequestID
const DWORD DBTF_SUBJECT	 = 0x00000008;	// Is a "Subject." property
const DWORD DBTF_INDEXUNIQUE     = 0x00000010;  // Force uniqueness constraint
const DWORD DBTF_INDEXIGNORENULL = 0x00000020;  // don't index NULLs
const DWORD DBTF_SOFTFAIL        = 0x00000040;  // optional column (it's new)
const DWORD DBTF_MISSING         = 0x00000080;  // optional column is missing
const DWORD DBTF_OLDCOLUMNID     = 0x00000100;  // old column id still exists
const DWORD DBTF_COLUMNRENAMED   = 0x00000200;  // renamed, old name appended
const DWORD DBTF_INDEXRENAMED    = 0x00000400;  // renamed, old name appended
const DWORD DBTF_COMPUTED	 = 0x00000800;  // computed column

typedef struct _DBTABLE
{
    WCHAR const *pwszPropName;
    WCHAR const *pwszPropNameObjId;
    DWORD        dwFlags;
    DWORD        dwcbMax;	// maximum allowed strlen/wcslen(value string)
    DWORD        dwTable;
    CHAR const  *pszFieldName;
    CHAR const  *pszIndexName;
    DWORD        dbcolumnMax;
    JET_GRBIT    dbgrbit;
    JET_COLTYP   dbcoltyp;
    JET_COLUMNID dbcolumnid;
    JET_COLUMNID dbcolumnidOld;	// Old column Id if DBTF_OLDCOLUMNID
} DBTABLE;

#define DBTABLE_NULL \
    { NULL, NULL, 0, 0, 0, NULL, NULL, 0, 0, 0, 0 } // Termination marker


typedef struct _DUPTABLE
{
    CHAR const  *pszFieldName;
    WCHAR const *pwszPropName;
} DUPTABLE;


typedef struct _DBAUXDATA
{
    char const    *pszTable;
    char const    *pszRowIdIndex;
    char const    *pszRowIdNameIndex;
    char const    *pszNameIndex;
    DBTABLE const *pdtRowId;
    DBTABLE const *pdtName;
    DBTABLE const *pdtFlags;
    DBTABLE const *pdtValue;
    DBTABLE const *pdtIssuerNameId;
} DBAUXDATA;


typedef struct _DBCREATETABLE {
    char const *pszTableName;
    DBAUXDATA  *pdbaux;
    DBTABLE    *pdt;
} DBCREATETABLE;


const DWORD TABLE_REQCERTS	= 0;
const DWORD TABLE_REQUESTS	= 1;
const DWORD TABLE_CERTIFICATES	= 2;
const DWORD TABLE_ATTRIBUTES	= 3;
const DWORD TABLE_EXTENSIONS	= 4;
const DWORD TABLE_CRLS		= 5;

const DWORD CSF_TABLEMASK =       0x0000000f;
const DWORD CSF_TABLESET =        0x00000010;
const DWORD CSF_INUSE =           0x00000020;
const DWORD CSF_READONLY =        0x00000040;
const DWORD CSF_CREATE =          0x00000080;
const DWORD CSF_DELETE =          0x00000100;
const DWORD CSF_VIEW =            0x00000200;
const DWORD CSF_VIEWRESET =       0x00000400;


const DWORD CST_SEEKINDEXRANGE =  0x00000001;
const DWORD CST_SEEKNOTMOVE =     0x00000002;
const DWORD CST_SEEKUSECURRENT =  0x00000004;
const DWORD CST_SEEKASCEND =      0x00000008;


const DWORD CVF_NOMOREDATA  = 0x00010000;
const DWORD CVF_COLUMNVALUE = 0x00020000;

char const szCERTIFICATE_REQUESTIDINDEX[] = "CertificateReqIdIndex";
char const szCERTIFICATE_COMMONNAMEINDEX[] = "$CertificateCommonNameIndex";
#define szCERTIFICATE_SERIALNUMBERINDEX "$CertificateSerialNumberIndex2"
#define szCERTIFICATE_SERIALNUMBERINDEX_OLD "$CertificateSerialNumberIndex"
char const szCERTIFICATE_HASHINDEX[] = "$CertificateHashIndex";
char const szCERTIFICATE_TEMPLATEINDEX[] = "$CertificateTemplateIndex";
#define szCERTIFICATE_NOTAFTERINDEX "CertificateNotAfterIndex"
#define szCERTIFICATE_NOTAFTERINDEX_OLD "$CertificateNotAfterIndex"
char const szCERTIFICATE_UPNINDEX[] = "$CertificateUPNIndex";

char const szREQUEST_REQUESTIDINDEX[] = "RequestReqIdIndex";
char const szREQUEST_DISPOSITIONINDEX[] = "RequestDispositionIndex";
char const szREQUEST_REQUESTERNAMEINDEX[] = "$RequestRequesterNameIndex";
char const szREQUEST_CALLERNAMEINDEX[] = "$RequestCallerNameIndex";
#define szREQUEST_RESOLVEDWHENINDEX "RequestResolvedWhenIndex"
#define szREQUEST_RESOLVEDWHENINDEX_OLD "$RequestResolvedWhenIndex"
#define szREQUEST_REVOKEDEFFECTIVEWHENINDEX "RequestRevokedEffectiveWhenIndex"
#define szREQUEST_REVOKEDEFFECTIVEWHENINDEX_OLD "$RequestRevokedEffectiveWhenIndex"

char const szEXTENSION_REQUESTIDINDEX[] = "ExtensionReqIdIndex";
char const szEXTENSION_REQUESTIDNAMEINDEX[] = "$ExtensionReqIdNameIndex";

char const szATTRIBUTE_REQUESTIDINDEX[] = "AttributeReqIdIndex";
char const szATTRIBUTE_REQUESTIDNAMEINDEX[] = "$AttributeReqIdNameIndex";

char const szCRL_ROWIDINDEX[] = "CRLRowIdIndex";
char const szCRL_CRLNUMBERINDEX[] = "CRLCRLNumberIndex";
char const szCRL_CRLNEXTUPDATEINDEX[] = "CRLCRLNextUpdateIndex";
char const szCRL_CRLNEXTPUBLISHINDEX[] = "CRLCRLNextPublishIndex";
char const szCRL_CRLPROPAGATIONCOMPLETEINDEX[] = "CRLCRLPropagationCompleteIndex";
char const szCRL_CRLLASTPUBLISHEDINDEX[] = "CRLLastPublishedIndex";
char const szCRL_CRLPUBLISHATTEMPTSINDEX[] = "CRLPublishAttemptsIndex";
char const szCRL_CRLPUBLSTATUSCODEISHINDEX[] = "CRLPublishStatusCodeIndex";


char const szCERTIFICATETABLE[] = "Certificates";
char const szREQUESTTABLE[] = "Requests";
char const szCERTIFICATEEXTENSIONTABLE[] = "CertificateExtensions";
char const szREQUESTATTRIBUTETABLE[] = "RequestAttributes";
char const szCRLTABLE[] = "CRLs";

#define wszCERTIFICATETABLE		L"Certificates"
#define wszREQUESTTABLE			L"Requests"
#define wszCERTIFICATEEXTENSIONTABLE	L"CertificateExtensions"
#define wszREQUESTATTRIBUTETABLE	L"RequestAttributes"
#define wszCRLTABLE			L"CRLs"

#define chTEXTPREFIX		'$'

#define szREQUESTID		"RequestID"
#define szRAWREQUEST		"RawRequest"
#define szRAWARCHIVEDKEY	"RawArchivedKey"
#define szKEYRECOVERYHASHES	"$KeyRecoveryHashes"
#define szRAWOLDCERTIFICATE	"RawOldCertificate"
#define szREQUESTATTRIBUTES	"$RequestAttributes"
#define szREQUESTTYPE		"RequestType"
#define szREQUESTFLAGS		"RequestFlags"
#define szSTATUSCODE		"StatusCode"
#define szDISPOSITION		"Disposition"
#define szDISPOSITIONMESSAGE	"$DispositionMessage"
#define szSUBMITTEDWHEN		"SubmittedWhen"
#define szRESOLVEDWHEN		"ResolvedWhen"
#define szREVOKEDWHEN		"RevokedWhen"
#define szREVOKEDEFFECTIVEWHEN	"RevokedEffectiveWhen"
#define szREVOKEDREASON		"RevokedReason"
#define szREQUESTERNAME		"$RequesterName"
#define szCALLERNAME		"$CallerName"
#define szSIGNERPOLICIES	"$SignerPolicies"
#define szSIGNERAPPLICATIONPOLICIES "$SignerApplicationPolicies"
#define szOFFICER		"?Officer"
#define szDISTINGUISHEDNAME	"$DistinguishedName"
#define szRAWNAME		"RawName"

#define szCOUNTRY		"$Country"
#define szORGANIZATION		"$Organization"
#define szORGANIZATIONALUNIT	"$OrganizationalUnit"
#define szCOMMONNAME		"$CommonName"
#define szLOCALITY		"$Locality"
#define szSTATEORPROVINCE	"$StateOrProvince"
#define szTITLE			"$Title"
#define szGIVENNAME		"$GivenName"
#define szINITIALS		"$Initials"
#define szSURNAME		"$SurName"
#define szDOMAINCOMPONENT	"$DomainComponent"
#define szEMAIL			"$EMail"
#define szSTREETADDRESS		"$StreetAddress"
#define szUNSTRUCTUREDNAME	"$UnstructuredName"
#define szUNSTRUCTUREDADDRESS	"$UnstructuredAddress"
#define szDEVICESERIALNUMBER	"$DeviceSerialNumber"


//#define szREQUESTID		"RequestID"
#define szRAWCERTIFICATE	"RawCertificate"
#define szCERTIFICATETEMPLATE	"$CertificateTemplate"
#define szCERTIFICATEENROLLMENTFLAGS	"EnrollmentFlags"
#define szCERTIFICATEGENERALFLAGS	"GeneralFlags"
#define szCERTIFICATEHASH	"$CertificateHash2"	// 2nd revision
#define szSERIALNUMBER		"$SerialNumber"
#define szISSUERNAMEID		"IssuerNameID"
#define szNOTBEFORE		"NotBefore"
#define szNOTAFTER		"NotAfter"
#define szUPN			"$UPN"
#define szSUBJECTKEYIDENTIFIER	"$SubjectKeyIdentifier"
#define szSUBJECTKEYIDENTIFIER_OLD "$CertificateHash"	// 2nd revision
#define szPUBLICKEY		"PublicKey"
#define szPUBLICKEYLENGTH	"PublicKeyLength"
#define szPUBLICKEYALGORITHM	"$PublicKeyAlgorithm"
#define szPUBLICKEYPARAMS	"PublicKeyParams"

//#define szDISTINGUISHEDNAME	"$DistinguishedName"
//#define szRAWNAME		"RawName"

//#define szCOUNTRY		"Country"
//#define ...

//#define szREQUESTID		"RequestID"
#define szATTRIBUTENAME		"$AttributeName"
#define szATTRIBUTEVALUE	"$AttributeValue"

//#define szREQUESTID		"RequestID"
#define szEXTENSIONNAME		"$ExtensionName"
#define szEXTENSIONFLAGS	"ExtensionFlags"
#define szEXTENSIONRAWVALUE	"ExtensionRawValue"

#define szCRLROWID		"RowId"
#define szCRLNUMBER		"Number"
#define szCRLMINBASE		"MinBase"
#define szCRLNAMEID		"NameId"
#define szCRLCOUNT		"Count"
#define szCRLTHISUPDATE		"ThisUpdate"
#define szCRLNEXTUPDATE		"NextUpdate"
#define szCRLTHISPUBLISH	"ThisPublish"
#define szCRLNEXTPUBLISH	"NextPublish"
#define szCRLEFFECTIVE		"Effective"
#define szCRLPROPAGATIONCOMPLETE "PropgationComplete"
#define szCRLLASTPUBLISHED	"CRLLastPublished"
#define szCRLPUBLISHATTEMPTS	"CRLPublishAttempts"
#define szCRLPUBLISHFLAGS	"CRLPublishFlags"
#define szCRLPUBLISHSTATUSCODE	"CRLPublishStatusCode"
#define szCRLPUBLISHERROR	"$CRLPublishError"
#define szCRLPUBLISHERROR_OLD	"CRLPublishError"
#define szRAWCRL		"RawCRL"

#define CSTI_PRIMARY		0
#define CSTI_CERTIFICATE	1
#define CSTI_ATTRIBUTE		2
#define CSTI_EXTENSION		3
#define CSTI_MAX		4
#define CSTI_MAXDIRECT		(CSTI_CERTIFICATE + 1)

typedef struct _CERTSESSIONTABLE
{
    JET_TABLEID		TableId;
    DWORD		TableFlags;
} CERTSESSIONTABLE;

typedef struct _CERTSESSION
{
    JET_SESID             SesId;
    JET_DBID              DBId;
    DWORD	          RowId;
    DWORD	          SesFlags;
    CERTSESSIONTABLE      aTable[CSTI_MAX];
    DWORD                 cTransact;
    ICertDBRow           *prow;
    IEnumCERTDBRESULTROW *pview;
    DWORD                 dwThreadId;
} CERTSESSION;


extern DBTABLE g_adtRequests[];
extern DBTABLE g_adtCertificates[];
extern DBTABLE g_adtRequestAttributes[];
//extern DBTABLE g_adtNameExtensions[];
extern DBTABLE g_adtCertExtensions[];
extern DBTABLE g_adtCRLs[];

extern DBAUXDATA g_dbauxRequests;
extern DBAUXDATA g_dbauxCertificates;
extern DBAUXDATA g_dbauxAttributes;
extern DBAUXDATA g_dbauxExtensions;
extern DBAUXDATA g_dbauxCRLs;

extern DBCREATETABLE const g_actDataBase[];

extern DUPTABLE const g_dntr[];

extern DWORD g_aColumnViewQueue[];
extern DWORD g_cColumnViewQueue;

extern DWORD g_aColumnViewLog[];
extern DWORD g_cColumnViewLog;

extern DWORD g_aColumnViewRevoked[];
extern DWORD g_cColumnViewRevoked;

extern DWORD g_aColumnViewExtension[];
extern DWORD g_cColumnViewExtension;

extern DWORD g_aColumnViewAttribute[];
extern DWORD g_cColumnViewAttribute;

extern DWORD g_aColumnViewCRL[];
extern DWORD g_cColumnViewCRL;

#endif // #ifndef __DBTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\dbw.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbw.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "dbw.h"

#if DBG

BOOL g_fDebugJet = TRUE;
#define DBGJET(args)		if (g_fDebugJet) { DBGPRINT(args); }
#define DBGJETDUMPHEX(jerr, flags, pb, cb) \
    if (JET_errSuccess == (jerr) && g_fDebugJet && NULL != (pb) && 0 != (cb)) \
    { \
	DBGDUMPHEX((DBG_SS_CERTJETI, (flags), (pb), (cb))); \
    }


#define CTABLEMAX 40
JET_TABLEID g_at[CTABLEMAX];
DWORD g_ct = 0;

DWORD
TableIndex(
    JET_TABLEID tableid)
{
    DWORD i;

    for (i = 0; i < g_ct; i++)
    {
	if (g_at[i] == tableid)
	{
	    return(i);
	}
    }
    if (g_ct < CTABLEMAX)
    {
	g_at[g_ct++] = tableid;
	DBGJET((DBG_SS_CERTJETI, "TableIndex(%x) --> %x\n", tableid, i));
	return(i);
    }
    return((DWORD) -1);
}


VOID
dbgcat(
    IN OUT WCHAR *pwszBuf,
    IN WCHAR const *pwszAdd)
{
    wcscat(pwszBuf, NULL == wcschr(pwszBuf, L':')? L": " : L", ");
    wcscat(pwszBuf, pwszAdd);
}


WCHAR const *
wszOpenDatabase(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[12];

    wsprintf(s_awc, L"{%x}", grbit);
    return(s_awc);
}


WCHAR const *
wszAttachDatabase(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[12];

    wsprintf(s_awc, L"{%x}", grbit);
    return(s_awc);
}


WCHAR const *
wszSeekgrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[64];	// 1 + 2 + 6 * 2 + 5 * 2 + 13

    wsprintf(s_awc, L"{%x", grbit);
    if (JET_bitSeekEQ & grbit) dbgcat(s_awc, L"EQ");
    if (JET_bitSeekLT & grbit) dbgcat(s_awc, L"LT");
    if (JET_bitSeekLE & grbit) dbgcat(s_awc, L"LE");
    if (JET_bitSeekGE & grbit) dbgcat(s_awc, L"GE");
    if (JET_bitSeekGT & grbit) dbgcat(s_awc, L"GT");
    if (JET_bitSetIndexRange & grbit) dbgcat(s_awc, L"SetIndexRange");
    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszMovecrow(
    IN LONG cRow)
{
    static WCHAR s_awc[16];

    switch (cRow)
    {
	case JET_MoveFirst:    wcscpy(s_awc, L"First");    break;
	case JET_MovePrevious: wcscpy(s_awc, L"Previous"); break;
	case JET_MoveNext:     wcscpy(s_awc, L"Next");     break;
	case JET_MoveLast:     wcscpy(s_awc, L"Last");     break;
	default:
	    wsprintf(s_awc, L"%d", cRow);
	    break;
    }
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszMovegrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[16];

    if (JET_bitMoveKeyNE & grbit) wcscpy(s_awc, L"MoveKeyNE");
    if (0 == grbit) wcscpy(s_awc, L"0");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszSetIndexRangegrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[64];	// 1 + 2 + 6 * 2 + 5 * 2 + 13

    wsprintf(s_awc, L"{%x", grbit);
    if (JET_bitRangeInclusive & grbit)       dbgcat(s_awc, L"Inclusive");
    if (0 == ((JET_bitRangeInclusive | JET_bitRangeRemove) & grbit))
					     dbgcat(s_awc, L"Exclusive");

    if (JET_bitRangeUpperLimit & grbit)      dbgcat(s_awc, L"UpperLimit");
    if (0 == ((JET_bitRangeUpperLimit | JET_bitRangeRemove) & grbit))
					     dbgcat(s_awc, L"LowerLimit");

    if (JET_bitRangeInstantDuration & grbit) dbgcat(s_awc, L"InstantDuration");
    if (JET_bitRangeRemove & grbit)          dbgcat(s_awc, L"Remove");
    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


WCHAR const *
wszMakeKeygrbit(
    JET_GRBIT grbit)
{
    static WCHAR s_awc[128];

    wsprintf(s_awc, L"{%x", grbit);
    if (JET_bitNewKey & grbit)            dbgcat(s_awc, L"NewKey");
    if (JET_bitStrLimit & grbit)          dbgcat(s_awc, L"StrLimit");
    if (JET_bitSubStrLimit & grbit)       dbgcat(s_awc, L"SubStrLimit");
    if (JET_bitNormalizedKey & grbit)     dbgcat(s_awc, L"NormalizedKey");
    if (JET_bitKeyDataZeroLength & grbit) dbgcat(s_awc, L"KeyDataZeroLength");
    wcscat(s_awc, L"}");
    CSASSERT(wcslen(s_awc) < ARRAYSIZE(s_awc));
    return(s_awc);
}


JET_ERR JET_API
_dbgJetInit(
    JET_INSTANCE *pinstance)
{
    JET_ERR jerr;

    jerr = JetInit(pinstance);
    DBGJET((DBG_SS_CERTJETI, "JetInit() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetTerm(
    JET_INSTANCE instance)
{
    JET_ERR jerr;

    jerr = JetTerm(instance);
    DBGJET((DBG_SS_CERTJETI, "JetTerm() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetTerm2(
    JET_INSTANCE instance,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetTerm2(instance, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetTerm2() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetStopService()
{
    JET_ERR jerr;

    jerr = JetStopService();
    DBGJET((DBG_SS_CERTJETI, "JetStopService() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBackup(
    const char *szBackupPath,
    JET_GRBIT grbit,
    JET_PFNSTATUS pfnStatus)
{
    JET_ERR jerr;

    jerr = JetBackup(szBackupPath, grbit, pfnStatus);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetBackup(%hs, %x, %x) --> %d\n",
	szBackupPath,
	grbit,
	pfnStatus,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRestore(
    const char *sz,
    JET_PFNSTATUS pfn)
{
    JET_ERR jerr;

    jerr = JetRestore(sz, pfn);
    DBGJET((DBG_SS_CERTJETI, "JetRestore(%hs, %x) --> %d\n", sz, pfn, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRestore2(
    const char *sz,
    const char *szDest,
    JET_PFNSTATUS pfn)
{
    JET_ERR jerr;

    jerr = JetRestore2(sz, szDest, pfn);
    DBGJET((DBG_SS_CERTJETI, "JetRestore2(%hs, %hs, %x) --> %d\n", sz, szDest, pfn, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetSetSystemParameter(
    JET_INSTANCE *pinstance,
    JET_SESID sesid,
    unsigned long paramid,
    unsigned long lParam,
    const char *sz)
{
    JET_ERR jerr;
    char szlong[32];
    char const *sz2;

    sz2 = sz;
    if (NULL == sz2)
    {
	sprintf(szlong, "0x%x", lParam);
	sz2 = szlong;
    }
    jerr = JetSetSystemParameter(pinstance, sesid, paramid, lParam, sz);
    DBGJET((DBG_SS_CERTJETI, "JetSetSystemParameter(%x, %hs) --> %d\n", paramid, sz2, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBeginSession(
    JET_INSTANCE instance,
    JET_SESID *psesid,
    const char *szUserName,
    const char *szPassword)
{
    JET_ERR jerr;

    jerr = JetBeginSession(instance, psesid, szUserName, szPassword);
    DBGJET((DBG_SS_CERTJETI, "JetBeginSession() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetEndSession(
    JET_SESID sesid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetEndSession(sesid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetEndSession() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCreateDatabase(
    JET_SESID sesid,
    const char *szFilename,
    const char *szConnect,
    JET_DBID *pdbid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetCreateDatabase(sesid, szFilename, szConnect, pdbid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetCreateDatabase() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCreateTable(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    unsigned long lPages,
    unsigned long lDensity,
    JET_TABLEID *ptableid)
{
    JET_ERR jerr;

    jerr = JetCreateTable(
		    sesid,
		    dbid,
		    szTableName,
		    lPages,
		    lDensity,
		    ptableid);
    DBGJET((DBG_SS_CERTJETI, "JetCreateTable(%hs):%x --> %d\n", szTableName, TableIndex(*ptableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetTableInfo(
    JET_SESID sesid,
    JET_TABLEID tableid,
    void *pvResult,
    unsigned long cbMax,
    unsigned long InfoLevel)
{
    JET_ERR jerr;

    jerr = JetGetTableInfo(sesid, tableid, pvResult, cbMax, InfoLevel);
    DBGJET((DBG_SS_CERTJETI, "JetGetTableInfo(%x, %p, %x, %x) --> %d\n", TableIndex(tableid), pvResult, cbMax, InfoLevel, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetColumnInfo(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    const char *szColumnName,
    void *pvResult,
    unsigned long cbMax,
    unsigned long InfoLevel)
{
    JET_ERR jerr;

    jerr = JetGetColumnInfo(
			sesid,
			dbid,
			szTableName,
			szColumnName,
			pvResult,
			cbMax,
			InfoLevel);
    DBGJET((DBG_SS_CERTJETI, "JetGetColumnInfo(%hs, %hs, %x) --> %d\n", szTableName, szColumnName, InfoLevel, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetConvertDDL(
    JET_SESID sesid,
    JET_DBID ifmp,
    JET_OPDDLCONV convtyp,
    void *pvData,
    unsigned long cbData)
{
    JET_ERR jerr;

    jerr = JetConvertDDL(sesid, ifmp, convtyp, pvData, cbData);

    if (opDDLConvIncreaseMaxColumnSize == convtyp)
    {
	JET_DDLMAXCOLUMNSIZE *pjdmcs = (JET_DDLMAXCOLUMNSIZE *) pvData;

	DBGJET((DBG_SS_CERTJETI, "JetConvertDDL(%hs, %hs, %x) --> %d\n", pjdmcs->szTable, pjdmcs->szColumn, pjdmcs->cbMax, jerr));
    }
    else
    if (opDDLConvChangeIndexDensity == convtyp)
    {
	JET_DDLINDEXDENSITY *pjdid = (JET_DDLINDEXDENSITY *) pvData;

	DBGJET((DBG_SS_CERTJETI, "JetConvertDDL(%hs, %hs, %x) --> %d\n", pjdid->szTable, pjdid->szIndex, pjdid->ulDensity, jerr));
    }
    else
    {
	DBGJET((DBG_SS_CERTJETI, "JetConvertDDL(%x, %p, %x) --> %d\n", convtyp, pvData, cbData, jerr));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetAddColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szColumn,
    const JET_COLUMNDEF *pcolumndef,
    const void *pvDefault,
    unsigned long cbDefault,
    JET_COLUMNID *pcolumnid)
{
    JET_ERR jerr;

    jerr = JetAddColumn(
		    sesid,
		    tableid,
		    szColumn,
		    pcolumndef,
		    pvDefault,
		    cbDefault,
		    pcolumnid);
    DBGJET((DBG_SS_CERTJETI, "JetAddColumn(%x, %hs):%x --> %d\n", TableIndex(tableid), szColumn, *pcolumnid, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetDeleteColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szColumnName)
{
    JET_ERR jerr;

    jerr = JetDeleteColumn(sesid, tableid, szColumnName);
    DBGJET((DBG_SS_CERTJETI, "JetDeleteColumn(%x, %hs) --> %d\n", TableIndex(tableid), szColumnName, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCreateIndex(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szIndexName,
    JET_GRBIT grbit,
    const char *szKey,
    unsigned long cbKey,
    unsigned long lDensity)
{
    JET_ERR jerr;

    jerr = JetCreateIndex(
		    sesid,
		    tableid,
		    szIndexName,
		    grbit,
		    szKey,
		    cbKey,
		    lDensity);
    DBGJET((DBG_SS_CERTJETI, "JetCreateIndex(%x, %hs, %x) --> %d\n", TableIndex(tableid), szIndexName, grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetDeleteIndex(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szIndexName)
{
    JET_ERR jerr;

    jerr = JetDeleteIndex(sesid, tableid, szIndexName);
    DBGJET((DBG_SS_CERTJETI, "JetDeleteIndex(%x, %hs) --> %d\n", TableIndex(tableid), szIndexName, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetIndexInfo(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    const char *szIndexName,
    void *pvResult,
    unsigned long cbResult,
    unsigned long InfoLevel)
{
    JET_ERR jerr;

    jerr = JetGetIndexInfo(
		    sesid,
		    dbid,
		    szTableName,
		    szIndexName,
		    pvResult,
		    cbResult,
		    InfoLevel);
    DBGJET((DBG_SS_CERTJETI, "JetGetIndexInfo(%hs, %hs, %p, %x, %x) --> %d\n", szTableName, szIndexName, pvResult, cbResult, InfoLevel, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBeginTransaction(
    JET_SESID sesid)
{
    JET_ERR jerr;

    jerr = JetBeginTransaction(sesid);
    DBGJET((DBG_SS_CERTJETI, "JetBeginTransaction() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCommitTransaction(
    JET_SESID sesid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetCommitTransaction(sesid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetCommitTransaction(%x) --> %d\n", grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRollback(
    JET_SESID sesid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetRollback(sesid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetRollback(%x) --> %d\n", grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetOpenDatabase(
    JET_SESID sesid,
    const char *szFilename,
    const char *szConnect,
    JET_DBID *pdbid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetOpenDatabase(sesid, szFilename, szConnect, pdbid, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetOpenDatabase(%hs, %ws):%x --> %d\n",
	szFilename,
	wszOpenDatabase(grbit),
	*pdbid,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetAttachDatabase(
    JET_SESID sesid,
    const char *szFilename,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetAttachDatabase(sesid, szFilename, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetAttachDatabase(%hs, %ws) --> %d\n",
	szFilename,
	wszAttachDatabase(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCloseDatabase(
    JET_SESID sesid,
    JET_DBID dbid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetCloseDatabase(sesid, dbid, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetCloseDatabase() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetOpenTable(
    JET_SESID sesid,
    JET_DBID dbid,
    const char *szTableName,
    const void *pvParameters,
    unsigned long cbParameters,
    JET_GRBIT grbit,
    JET_TABLEID *ptableid)
{
    JET_ERR jerr;

    jerr = JetOpenTable(
		    sesid,
		    dbid,
		    szTableName,
		    pvParameters,
		    cbParameters,
		    grbit,
		    ptableid);
    DBGJET((DBG_SS_CERTJETI, "JetOpenTable(%hs):%x --> %d\n", szTableName, TableIndex(*ptableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCloseTable(
    JET_SESID sesid,
    JET_TABLEID tableid)
{
    JET_ERR jerr;

    jerr = JetCloseTable(sesid, tableid);
    DBGJET((DBG_SS_CERTJETI, "JetCloseTable(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetUpdate(
    JET_SESID sesid,
    JET_TABLEID tableid,
    void *pvBookmark,
    unsigned long cbBookmark,
    unsigned long *pcbActual)
{
    JET_ERR jerr;

    jerr = JetUpdate(sesid, tableid, pvBookmark, cbBookmark, pcbActual);
    DBGJET((DBG_SS_CERTJETI, "JetUpdate(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetDelete(
    JET_SESID sesid,
    JET_TABLEID tableid)
{
    JET_ERR jerr;

    jerr = JetDelete(sesid, tableid);
    DBGJET((DBG_SS_CERTJETI, "JetDelete(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetRetrieveColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    JET_COLUMNID columnid,
    void *pvData,
    unsigned long cbData,
    unsigned long *pcbActual,
    JET_GRBIT grbit,
    JET_RETINFO *pretinfo)
{
    JET_ERR jerr;

    jerr = JetRetrieveColumn(
			sesid,
			tableid,
			columnid,
			pvData,
			cbData,
			pcbActual,
			grbit,
			pretinfo);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetRetrieveColumn(%x, %x, %x) cb:%x->%x--> %d\n",
	TableIndex(tableid),
	columnid,
	grbit,
	cbData,
	*pcbActual,
	jerr));

    if (NULL != pvData)
    {
	DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, min(cbData, *pcbActual));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetSetColumn(
    JET_SESID sesid,
    JET_TABLEID tableid,
    JET_COLUMNID columnid,
    const void *pvData,
    unsigned long cbData,
    JET_GRBIT grbit,
    JET_SETINFO *psetinfo)
{
    JET_ERR jerr;

    jerr = JetSetColumn(
		    sesid,
		    tableid,
		    columnid,
		    pvData,
		    cbData,
		    grbit,
		    psetinfo);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetSetColumn(%x, %x, %x) cb:%x --> %d\n",
	TableIndex(tableid),
	columnid,
	grbit,
	cbData,
	jerr));

    DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, cbData);
    return(jerr);
}


JET_ERR JET_API
_dbgJetPrepareUpdate(
    JET_SESID sesid,
    JET_TABLEID tableid,
    unsigned long prep)
{
    JET_ERR jerr;

    jerr = JetPrepareUpdate(sesid, tableid, prep);
    DBGJET((DBG_SS_CERTJETI, "JetPrepareUpdate(%x, %x) --> %d\n", TableIndex(tableid), prep, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetSetCurrentIndex2(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const char *szIndexName,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetSetCurrentIndex2(sesid, tableid, szIndexName, grbit);
    DBGJET((DBG_SS_CERTJETI, "JetSetCurrentIndex2(%x) --> %d\n", TableIndex(tableid), jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetMove(
    JET_SESID sesid,
    JET_TABLEID tableid,
    long cRow,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetMove(sesid, tableid, cRow, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetMove(%x, %ws, %ws) --> %d\n",
	TableIndex(tableid),
	wszMovecrow(cRow),
	wszMovegrbit(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetMakeKey(
    JET_SESID sesid,
    JET_TABLEID tableid,
    const void *pvData,
    unsigned long cbData,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetMakeKey(sesid, tableid, pvData, cbData, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetMakeKey(%x, %ws) --> %d\n",
	TableIndex(tableid),
	wszMakeKeygrbit(grbit),
	jerr));
    DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, cbData);
    return(jerr);
}


JET_ERR JET_API
_dbgJetSeek(
    JET_SESID sesid,
    JET_TABLEID tableid,
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetSeek(sesid, tableid, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetSeek(%x, %ws) --> %d\n",
	TableIndex(tableid),
	wszSeekgrbit(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetBeginExternalBackup(
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetBeginExternalBackup(grbit);
    DBGJET((DBG_SS_CERTJETI, "JetBeginExternalBackup(%x) --> %d\n", grbit, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetAttachInfo(
    void *pv,
    unsigned long cbMax,
    unsigned long *pcbActual)
{
    JET_ERR jerr;

    jerr = JetGetAttachInfo(pv, cbMax, pcbActual);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetGetAttachInfo(%x, %x, -> %x) --> %d\n",
	pv,
	cbMax,
	*pcbActual,
	jerr));
    if (NULL != pv)
    {
	DBGJETDUMPHEX(jerr, 0, (BYTE const *) pv, min(cbMax, *pcbActual));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetOpenFile(
    const char *szFileName,
    JET_HANDLE	*phfFile,
    unsigned long *pulFileSizeLow,
    unsigned long *pulFileSizeHigh)
{
    JET_ERR jerr;

    jerr = JetOpenFile(szFileName, phfFile, pulFileSizeLow, pulFileSizeHigh);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetOpenFile(%hs, -> %x, %x, %x) --> %d\n",
	szFileName,
	*phfFile,
	*pulFileSizeLow,
	*pulFileSizeHigh,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetReadFile(
    JET_HANDLE hfFile,
    void *pv,
    unsigned long cb,
    unsigned long *pcb)
{
    JET_ERR jerr;

    jerr = JetReadFile(hfFile, pv, cb, pcb);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetReadFile(%x, %x, %x, -> %x) --> %d\n",
	hfFile,
	pv,
	cb,
	*pcb,
	jerr));
    return(jerr);
}


#if 0
JET_ERR JET_API
_dbgJetAsyncReadFile(
    JET_HANDLE hfFile,
    void* pv,
    unsigned long cb,
    JET_OLP *pjolp)
{
    JET_ERR jerr;

    jerr = JetAsyncReadFile(hfFile, pv, cb, pjolp);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetAsyncReadFile(%x, %x, %x, %x) --> %d\n",
	hfFile,
	pv,
	cb,
	pjolp,
	jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetCheckAsyncReadFile(
    void *pv,
    int cb,
    unsigned long pgnoFirst)
{
    JET_ERR jerr;

    jerr = JetCheckAsyncReadFile(pv, cb, pgnoFirst);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetCheckAsyncReadFile(%x, %x, %x) --> %d\n",
	pv,
	cb,
	pgnoFirst,
	jerr));
    return(jerr);
}
#endif


JET_ERR JET_API
_dbgJetCloseFile(
    JET_HANDLE hfFile)
{
    JET_ERR jerr;

    jerr = JetCloseFile(hfFile);
    DBGJET((DBG_SS_CERTJETI, "JetCloseFile(%x) --> %d\n", hfFile, jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetGetLogInfo(
    void *pv,
    unsigned long cbMax,
    unsigned long *pcbActual)
{
    JET_ERR jerr;

    jerr = JetGetLogInfo(pv, cbMax, pcbActual);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetGetLogInfo(%x, %x, %x, -> %x) --> %d\n",
	pv,
	cbMax,
	*pcbActual,
	jerr));
    if (NULL != pv)
    {
	DBGJETDUMPHEX(jerr, 0, (BYTE const *) pv, min(cbMax, *pcbActual));
    }
    return(jerr);
}


JET_ERR JET_API
_dbgJetTruncateLog(void)
{
    JET_ERR jerr;

    jerr = JetTruncateLog();
    DBGJET((DBG_SS_CERTJETI, "JetTruncateLog() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetEndExternalBackup(void)
{
    JET_ERR jerr;

    jerr = JetEndExternalBackup();
    DBGJET((DBG_SS_CERTJETI, "JetEndExternalBackup() --> %d\n", jerr));
    return(jerr);
}


JET_ERR JET_API
_dbgJetExternalRestore(
    char *szCheckpointFilePath,
    char *szLogPath,
    JET_RSTMAP *rgstmap,
    long crstfilemap,
    char *szBackupLogPath,
    long genLow,
    long genHigh,
    JET_PFNSTATUS pfn)
{
    JET_ERR jerr;

    jerr = JetExternalRestore(
			szCheckpointFilePath,
			szLogPath,
			rgstmap,
			crstfilemap,
			szBackupLogPath,
			genLow,
			genHigh,
			pfn);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetExternalRestore(%hs, %hs, %x, %x, %hs, %x, %x, %x) --> %d\n",
	szCheckpointFilePath,
	szLogPath,
	rgstmap,
	crstfilemap,
	szBackupLogPath,
	genLow,
	genHigh,
	pfn,
	jerr));
    return(jerr);
}


JET_ERR JET_API 
_dbgJetSetIndexRange(
    JET_SESID sesid, 
    JET_TABLEID tableid, 
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetSetIndexRange(sesid, tableid, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetSetIndexRange(%x, %ws) --> %d\n",
	TableIndex(tableid),
	wszSetIndexRangegrbit(grbit),
	jerr));
    return(jerr);
}


JET_ERR JET_API 
_dbgJetRetrieveKey(
    JET_SESID sesid, 
    JET_TABLEID tableid, 
    void *pvData, 
    unsigned long cbData, 
    unsigned long *pcbActual, 
    JET_GRBIT grbit)
{
    JET_ERR jerr;

    jerr = JetRetrieveKey(sesid, tableid, pvData, cbData, pcbActual, grbit);
    DBGJET((
	DBG_SS_CERTJETI,
	"JetRetrieveKey(%x, %x, -> %x) --> %d\n",
	TableIndex(tableid),
	cbData,
	*pcbActual,
	jerr));
    DBGJETDUMPHEX(jerr, 0, (BYTE const *) pvData, min(*pcbActual, cbData));
    return(jerr);
}

#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\dbw.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        dbw.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#if !defined(__DBW_H__)
#define __DBW_H__

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

JET_ERR JET_API _dbgJetInit(JET_INSTANCE *pinstance);

JET_ERR JET_API _dbgJetTerm(JET_INSTANCE instance);

JET_ERR JET_API _dbgJetTerm2(JET_INSTANCE instance, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetStopService();

JET_ERR JET_API _dbgJetBackup(const char *szBackupPath, JET_GRBIT grbit, JET_PFNSTATUS pfnStatus);

JET_ERR JET_API _dbgJetRestore(const char *sz, JET_PFNSTATUS pfn);

JET_ERR JET_API _dbgJetRestore2(const char *sz, const char *szDest, JET_PFNSTATUS pfn);

JET_ERR JET_API _dbgJetSetSystemParameter(JET_INSTANCE *pinstance, JET_SESID sesid, unsigned long paramid, unsigned long lParam, const char *sz);

JET_ERR JET_API _dbgJetBeginSession(JET_INSTANCE instance, JET_SESID *psesid, const char *szUserName, const char *szPassword);

JET_ERR JET_API _dbgJetEndSession(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetCreateDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetCreateTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, unsigned long lPages, unsigned long lDensity, JET_TABLEID *ptableid);

JET_ERR JET_API _dbgJetGetTableInfo(JET_SESID sesid, JET_TABLEID tableid, void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API _dbgJetGetColumnInfo(JET_SESID sesid, JET_DBID dbid, const char *szTableName, const char *szColumnName, void *pvResult, unsigned long cbMax, unsigned long InfoLevel);

JET_ERR JET_API _dbgJetConvertDDL(JET_SESID sesid, JET_DBID ifmp, JET_OPDDLCONV convtyp, void *pvData, unsigned long cbData);

JET_ERR JET_API _dbgJetAddColumn(JET_SESID sesid, JET_TABLEID tableid, const char *szColumn, const JET_COLUMNDEF *pcolumndef, const void *pvDefault, unsigned long cbDefault, JET_COLUMNID *pcolumnid);

JET_ERR JET_API _dbgJetDeleteColumn(JET_SESID sesid, JET_TABLEID tableid, const char *szColumnName);

JET_ERR JET_API _dbgJetCreateIndex(JET_SESID sesid, JET_TABLEID tableid, const char *szIndexName, JET_GRBIT grbit, const char *szKey, unsigned long cbKey, unsigned long lDensity);

JET_ERR JET_API _dbgJetDeleteIndex(JET_SESID sesid, JET_TABLEID tableid, const char *szIndexName);

JET_ERR JET_API _dbgJetGetIndexInfo(JET_SESID sesid, JET_DBID dbid, const char *szTableName, const char *szIndexName, void *pvResult, unsigned long cbResult, unsigned long InfoLevel);

JET_ERR JET_API _dbgJetBeginTransaction(JET_SESID sesid);

JET_ERR JET_API _dbgJetCommitTransaction(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetRollback(JET_SESID sesid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetOpenDatabase(JET_SESID sesid, const char *szFilename, const char *szConnect, JET_DBID *pdbid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetAttachDatabase(JET_SESID sesid, const char *szFilename, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetCloseDatabase(JET_SESID sesid, JET_DBID dbid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetOpenTable(JET_SESID sesid, JET_DBID dbid, const char *szTableName, const void *pvParameters, unsigned long cbParameters, JET_GRBIT grbit, JET_TABLEID *ptableid);

JET_ERR JET_API _dbgJetCloseTable(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API _dbgJetUpdate(JET_SESID sesid, JET_TABLEID tableid, void *pvBookmark, unsigned long cbBookmark, unsigned long *pcbActual);

JET_ERR JET_API _dbgJetDelete(JET_SESID sesid, JET_TABLEID tableid);

JET_ERR JET_API _dbgJetRetrieveColumn(JET_SESID sesid, JET_TABLEID tableid, JET_COLUMNID columnid, void *pvData, unsigned long cbData, unsigned long *pcbActual, JET_GRBIT grbit, JET_RETINFO *pretinfo);

JET_ERR JET_API _dbgJetSetColumn(JET_SESID sesid, JET_TABLEID tableid, JET_COLUMNID columnid, const void *pvData, unsigned long cbData, JET_GRBIT grbit, JET_SETINFO *psetinfo);

JET_ERR JET_API _dbgJetPrepareUpdate(JET_SESID sesid, JET_TABLEID tableid, unsigned long prep);

JET_ERR JET_API _dbgJetSetCurrentIndex2(JET_SESID sesid, JET_TABLEID tableid, const char *szIndexName, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetMove(JET_SESID sesid, JET_TABLEID tableid, long cRow, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetMakeKey(JET_SESID sesid, JET_TABLEID tableid, const void *pvData, unsigned long cbData, JET_GRBIT grbit);
JET_ERR JET_API _dbgJetSeek(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetSetIndexRange(JET_SESID sesid, JET_TABLEID tableid, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetRetrieveKey(JET_SESID sesid, JET_TABLEID tableid, void *pvData, unsigned long cbData, unsigned long *pcbActual, JET_GRBIT grbit);

JET_ERR JET_API _dbgJetBeginExternalBackup(JET_GRBIT grbit);

JET_ERR JET_API _dbgJetGetAttachInfo(void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual);

JET_ERR JET_API _dbgJetOpenFile(const char *szFileName,
	JET_HANDLE	*phfFile,
	unsigned long *pulFileSizeLow,
	unsigned long *pulFileSizeHigh);

JET_ERR JET_API _dbgJetReadFile(JET_HANDLE hfFile,
	void *pv,
	unsigned long cb,
	unsigned long *pcb);

#if 0
JET_ERR JET_API _dbgJetAsyncReadFile(
	JET_HANDLE hfFile,
	void* pv,
	unsigned long cb,
	JET_OLP *pjolp);

JET_ERR JET_API _dbgJetCheckAsyncReadFile(void *pv, int cb, unsigned long pgnoFirst);
#endif

JET_ERR JET_API _dbgJetCloseFile(JET_HANDLE hfFile);

JET_ERR JET_API _dbgJetGetLogInfo(void *pv,
	unsigned long cbMax,
	unsigned long *pcbActual);

JET_ERR JET_API _dbgJetTruncateLog(void);

JET_ERR JET_API _dbgJetEndExternalBackup(void);

JET_ERR JET_API _dbgJetExternalRestore(char *szCheckpointFilePath, char *szLogPath, JET_RSTMAP *rgstmap, long crstfilemap, char *szBackupLogPath, long genLow, long genHigh, JET_PFNSTATUS pfn);

#else // DBG

#define _dbgJetInit			JetInit
#define _dbgJetTerm			JetTerm
#define _dbgJetTerm2			JetTerm2
#define _dbgJetStopService		JetStopService
#define _dbgJetBackup			JetBackup
#define _dbgJetRestore			JetRestore
#define _dbgJetRestore2			JetRestore2
#define _dbgJetSetSystemParameter	JetSetSystemParameter
#define _dbgJetBeginSession		JetBeginSession
#define _dbgJetEndSession		JetEndSession
#define _dbgJetCreateDatabase		JetCreateDatabase
#define _dbgJetCreateTable		JetCreateTable
#define _dbgJetGetTableInfo		JetGetTableInfo
#define _dbgJetGetColumnInfo		JetGetColumnInfo
#define _dbgJetConvertDDL		JetConvertDDL
#define _dbgJetAddColumn		JetAddColumn
#define _dbgJetDeleteColumn		JetDeleteColumn
#define _dbgJetCreateIndex		JetCreateIndex
#define _dbgJetDeleteIndex		JetDeleteIndex
#define _dbgJetGetIndexInfo		JetGetIndexInfo
#define _dbgJetBeginTransaction		JetBeginTransaction
#define _dbgJetCommitTransaction	JetCommitTransaction
#define _dbgJetRollback			JetRollback
#define _dbgJetAttachDatabase		JetAttachDatabase
#define _dbgJetOpenDatabase		JetOpenDatabase
#define _dbgJetCloseDatabase		JetCloseDatabase
#define _dbgJetOpenTable		JetOpenTable
#define _dbgJetCloseTable		JetCloseTable
#define _dbgJetUpdate			JetUpdate
#define _dbgJetDelete			JetDelete
#define _dbgJetRetrieveColumn		JetRetrieveColumn
#define _dbgJetSetColumn		JetSetColumn
#define _dbgJetPrepareUpdate		JetPrepareUpdate
#define _dbgJetSetCurrentIndex2		JetSetCurrentIndex2
#define _dbgJetMove			JetMove
#define _dbgJetMakeKey			JetMakeKey
#define _dbgJetSeek			JetSeek
#define _dbgJetSetIndexRange		JetSetIndexRange
#define _dbgJetRetrieveKey		JetRetrieveKey
#define _dbgJetBeginExternalBackup	JetBeginExternalBackup
#define _dbgJetGetAttachInfo		JetGetAttachInfo
#define _dbgJetOpenFile			JetOpenFile
#define _dbgJetReadFile			JetReadFile
#if 0
#define _dbgJetAsyncReadFile		JetAsyncReadFile
#define _dbgJetCheckAsyncReadFile	JetCheckAsyncReadFile
#endif
#define _dbgJetCloseFile		JetCloseFile
#define _dbgJetGetLogInfo		JetGetLogInfo
#define _dbgJetTruncateLog		JetTruncateLog
#define _dbgJetEndExternalBackup	JetEndExternalBackup
#define _dbgJetExternalRestore		JetExternalRestore

#endif // DBG

#ifdef __cplusplus
}
#endif

#endif /* __DBW_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\enum.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        enum.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CEnumCERTDBNAME: public IEnumCERTDBNAME
{
public:
    CEnumCERTDBNAME();
    ~CEnumCERTDBNAME();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTDBNAME
    STDMETHOD(Next)(
	/* [in] */  ULONG       celt,
	/* [out] */ CERTDBNAME *rgelt,
	/* [out] */ ULONG      *pceltFetched);
    
    STDMETHOD(Skip)(
	/* [in] */  LONG  celt,
	/* [out] */ LONG *pielt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTDBNAME **ppenum);

    // CEnumCERTDBNAME
    HRESULT Open(
	IN ICertDBRow *prow,
	IN JET_TABLEID tableid,
	IN DWORD Flags);

private:
    VOID _Cleanup();

    ICertDBRow *m_prow;
    JET_TABLEID m_tableid;
    DWORD       m_Flags;
    BOOL        m_fNoMoreData;
    LONG        m_ielt;
    LONG        m_cskip;

    // Reference count
    long        m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        resource.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certdb.rc
//
#define IDS_CERTDB_DESC		1
#define IDS_CERTDBRESTORE_DESC	2



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\enum.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        enum.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "row.h"
#include "enum.h"
#include "db.h"
#include "dbw.h"

#define __dwFILE__	__dwFILE_CERTDB_ENUM_CPP__


#if DBG
LONG g_cCertDBName;
LONG g_cCertDBNameTotal;
#endif

CEnumCERTDBNAME::CEnumCERTDBNAME()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBName));
    DBGCODE(InterlockedIncrement(&g_cCertDBNameTotal));
    m_prow = NULL;
    m_cRef = 1;
}


CEnumCERTDBNAME::~CEnumCERTDBNAME()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBName));
    _Cleanup();
}


// CEnumCERTDBNAME implementation
VOID
CEnumCERTDBNAME::_Cleanup()
{
    if (NULL != m_prow)
    {
	((CCertDBRow *) m_prow)->EnumerateClose(m_tableid);
	m_prow->Release();
    }
}


HRESULT
CEnumCERTDBNAME::Open(
    IN ICertDBRow *prow,
    IN JET_TABLEID tableid,
    IN DWORD Flags)
{
    HRESULT hr;
    
    if (NULL == prow)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    prow->AddRef();

    m_fNoMoreData = FALSE;
    m_prow = prow;
    m_tableid = tableid;
    m_Flags = Flags;
    m_ielt = 0;
    m_cskip = 0;
    hr = S_OK;

error:
    return(hr);
}


// IEnumCERTDBNAME implementation
STDMETHODIMP
CEnumCERTDBNAME::Next(
    /* [in] */  ULONG       celt,
    /* [out] */ CERTDBNAME *rgelt,
    /* [out] */ ULONG      *pceltFetched)
{
    HRESULT hr;

    if (NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pceltFetched = 0;
    if (NULL == m_prow)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prow");
    }
    if (m_fNoMoreData)
    {
	hr = S_FALSE;
	goto error;
    }

    CSASSERT(0 <= m_ielt);
    CSASSERT(0 <= m_ielt + m_cskip);
    DBGPRINT((
	DBG_SS_CERTDBI,
	"Enum::Next(celt=%d) ielt=%d, skip=%d\n",
	celt,
	m_ielt,
	m_cskip));

    hr = ((CCertDBRow *) m_prow)->EnumerateNext(
					&m_Flags,
					m_tableid,
					m_cskip,
					celt,
					rgelt,
					pceltFetched);
    if (S_FALSE == hr)
    {
	m_fNoMoreData = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumerateNext");
    }
    m_ielt += m_cskip;
    m_ielt += *pceltFetched;
    m_cskip = 0;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBNAME::Skip(
    /* [in] */  LONG  celt,
    /* [out] */ LONG *pielt)
{
    HRESULT hr;
    LONG cskipnew;
    
    if (NULL == pielt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_prow)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prow");
    }
    cskipnew = m_cskip + celt;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Enum::Skip(%d) ielt=%d: %d --> %d, skip=%d --> %d\n",
	celt,
	m_ielt,
	m_ielt + m_cskip,
	m_ielt + cskipnew,
	m_cskip,
	cskipnew));

    CSASSERT(0 <= m_ielt);
    if (0 > cskipnew)
    {
	if (0 > m_ielt + cskipnew)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Skip back to before start");
	}
	m_fNoMoreData = FALSE;
    }

    *pielt = m_ielt + cskipnew;
    m_cskip = cskipnew;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBNAME::Reset(VOID)
{
    HRESULT hr;
    LONG iDummy;

    hr = Skip(-(m_ielt + m_cskip), &iDummy);
    _JumpIfError(hr, error, "Skip");

    CSASSERT(0 == iDummy);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBNAME::Clone(
    /* [out] */ IEnumCERTDBNAME **ppenum)
{
    HRESULT hr;
    LONG iDummy;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_prow)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_prow");
    }

    hr = ((CCertDBRow *) m_prow)->EnumCertDBName(
					    CIE_TABLE_MASK & m_Flags,
					    ppenum);
    _JumpIfError(hr, error, "EnumerateCertDBName");

    (*ppenum)->Skip(m_ielt + m_cskip, &iDummy);

error:
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTDBNAME::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTDBNAME *>(this);
    }
    else if (iid == IID_IEnumCERTDBNAME)
    {
	*ppv = static_cast<IEnumCERTDBNAME *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBNAME::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBNAME::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CEnumCERTDBNAME::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_IEnumCERTDBNAME,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#define __DIR__		"certdb"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include "certdb.h"
#include <esent.h>
#include <certsrv.h>
#include "dbtable.h"
#include "certlib.h"
#include "csdisp.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\restore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        restore.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "db.h"
#include "dbw.h"
#include "restore.h"

#define __dwFILE__	__dwFILE_CERTDB_RESTORE_CPP__


#if DBG
LONG g_cCertDBRestore;
LONG g_cCertDBRestoreTotal;
#endif

CCertDBRestore::CCertDBRestore()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBRestore));
    DBGCODE(InterlockedIncrement(&g_cCertDBRestoreTotal));
}


CCertDBRestore::~CCertDBRestore()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBRestore));
    _Cleanup();
}


VOID
CCertDBRestore::_Cleanup()
{
}


HRESULT
CCertDBRestore::RecoverAfterRestore(
    IN DWORD cSession,
    IN DWORD DBFlags,
    IN WCHAR const *pwszEventSource,
    IN WCHAR const *pwszLogDir,
    IN WCHAR const *pwszSystemDir,
    IN WCHAR const *pwszTempDir,
    IN WCHAR const *pwszCheckPointFile,
    IN WCHAR const *pwszLogPath,
    IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    IN WCHAR const *pwszBackupLogPath,
    IN DWORD genLow,
    IN DWORD genHigh)
{
    HRESULT hr;
    LONG i;
    char *pszCheckPointFile = NULL;
    char *pszLogPath = NULL;
    char *pszBackupLogPath = NULL;
    JET_RSTMAP *arstmap = NULL;
    JET_INSTANCE Instance = 0;

    // Call into JET to let it munge the databases.  Note that the JET
    // interpretation of LogPath and BackupLogPath is totally wierd, and we
    // want to pass in LogPath to both parameters.

    hr = E_OUTOFMEMORY;

    if ((NULL != pwszCheckPointFile &&
	 !ConvertWszToSz(&pszCheckPointFile, pwszCheckPointFile, -1)) ||
	(NULL != pwszLogPath &&
	 !ConvertWszToSz(&pszLogPath, pwszLogPath, -1)) ||
	(NULL != pwszBackupLogPath &&
	 !ConvertWszToSz(&pszBackupLogPath, pwszBackupLogPath, -1)))
    {
	_JumpError(hr, error, "ConvertWszToSz");
    }
    arstmap = (JET_RSTMAP *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    crstmap * sizeof(*arstmap));
    if (NULL == arstmap)
    {
	_JumpError(hr, error, "ConvertWszToSz");
    }
    for (i = 0; i < crstmap; i++)
    {
	if (!ConvertWszToSz(
			&arstmap[i].szDatabaseName,
			rgrstmap[i].pwszDatabaseName,
			-1) ||
	    !ConvertWszToSz(
			&arstmap[i].szNewDatabaseName,
			rgrstmap[i].pwszNewDatabaseName,
			-1))
	{
	    _JumpError(hr, error, "ConvertWszToSz");
	}
    }

    hr = DBInitParms(
		cSession,
                DBFlags,
		pwszEventSource,
		pwszLogDir,
		pwszSystemDir,
		pwszTempDir,
		&Instance);
    _JumpIfError(hr, error, "DBInitParms");

    hr = _dbgJetExternalRestore(
			pszCheckPointFile,
			pszLogPath, 	
			arstmap,
			crstmap,
			pszLogPath,
			genLow,
			genHigh,
			NULL);
    hr = myJetHResult(hr);
    _JumpIfError(hr, error, "JetExternalRestore");

error:
    DBFreeParms();
    if (NULL != arstmap)
    {
	for (i = 0; i < crstmap; i++)
	{
	    if (NULL != arstmap[i].szDatabaseName)
	    {
		LocalFree(arstmap[i].szDatabaseName);
	    }
	    if (NULL != arstmap[i].szNewDatabaseName)
	    {
		LocalFree(arstmap[i].szNewDatabaseName);
	    }
	}
	LocalFree(arstmap);
    }
    if (NULL != pszCheckPointFile)
    {
	LocalFree(pszCheckPointFile);
    }
    if (NULL != pszLogPath)
    {
	LocalFree(pszLogPath);
    }
    if (NULL != pszBackupLogPath)
    {
	LocalFree(pszBackupLogPath);
    }
    return(hr);
}


STDMETHODIMP
CCertDBRestore::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_ICertDBRestore,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\restore.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        restore.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CCertDBRestore:
    public ICertDBRestore,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CCertDBRestore, &CLSID_CCertDBRestore>
{
public:
    CCertDBRestore();
    ~CCertDBRestore();

BEGIN_COM_MAP(CCertDBRestore)
    COM_INTERFACE_ENTRY(ICertDBRestore)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertDBRestore) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertDBRestore,
    wszCLASS_CERTDBRESTORE TEXT(".1"),
    wszCLASS_CERTDBRESTORE,
    IDS_CERTDBRESTORE_DESC,
    THREADFLAGS_BOTH)

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // ICertDBRestore
public:
    STDMETHOD(RecoverAfterRestore)(
	/* [in] */ DWORD cSession,
	/* [in] */ DWORD DBFlags,
	/* [in] */ WCHAR const *pwszEventSource,
	/* [in] */ WCHAR const *pwszLogDir,
	/* [in] */ WCHAR const *pwszSystemDir,
	/* [in] */ WCHAR const *pwszTempDir,
	/* [in] */ WCHAR const *pwszCheckPointFile,
	/* [in] */ WCHAR const *pwszLogPath,
	/* [in] */ CSEDB_RSTMAPW rgrstmap[],
	/* [in] */ LONG crstmap,
	/* [in] */ WCHAR const *pwszBackupLogPath,
	/* [in] */ DWORD genLow,
	/* [in] */ DWORD genHigh);

private:
    VOID _Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\row.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

class CCertDBRow: public ICertDBRow
{
public:
    CCertDBRow();
    ~CCertDBRow();

public:

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ICertDBRow
    STDMETHOD(BeginTransaction)();

    STDMETHOD(CommitTransaction)(
	/* [in] */ DWORD dwCommitFlags);

    STDMETHOD(GetRowId)(
	/* [out] */ DWORD *pRowId);

    STDMETHOD(Delete)();

    STDMETHOD(SetProperty)(
	/* [in] */ WCHAR const *pwszPropName,
	/* [in] */ DWORD dwFlags,
	/* [in] */ DWORD cbProp,
	/* [in] */ BYTE const *pbProp);		// OPTIONAL

    STDMETHOD(GetProperty)(
	/* [in] */ WCHAR const *pwszPropName,
	/* [in] */ DWORD dwFlags,
	/* [in] */ ICertDBComputedColumn *pIComputedColumn,
	/* [in, out] */ DWORD *pcbProp,
	/* [out] */ BYTE *pbProp);		// OPTIONAL

    STDMETHOD(SetExtension)(
	/* [in] */ WCHAR const *pwszExtensionName,
	/* [in] */ DWORD dwExtFlags,
	/* [in] */ DWORD cbValue,
	/* [in] */ BYTE const *pbValue);	// OPTIONAL

    STDMETHOD(GetExtension)(
	/* [in] */ WCHAR const *pwszExtensionName,
	/* [out] */ DWORD *pdwExtFlags,
	/* [in, out] */ DWORD *pcbValue,
	/* [out] */ BYTE *pbValue);		// OPTIONAL

    STDMETHOD(CopyRequestNames)();

    STDMETHOD(EnumCertDBName)(
	/* [in] */  DWORD dwFlags,
	/* [out] */ IEnumCERTDBNAME **ppenum);

    // CCertDBRow
    HRESULT Open(
	IN CERTSESSION *pcs,
	IN ICertDB *pdb,
	OPTIONAL IN CERTVIEWRESTRICTION const *pcvr);

    HRESULT EnumerateNext(
	IN OUT DWORD      *pFlags,
	IN     JET_TABLEID tableid,
	IN     LONG        cskip,
	IN     ULONG       celt,
	OUT    CERTDBNAME *rgelt,
	OUT    ULONG      *pceltFetched);

    HRESULT EnumerateClose(
	IN JET_TABLEID tableid);

private:
    VOID _Cleanup();

    HRESULT _SetPropertyA(
	IN WCHAR const *pwszPropName,
	IN DWORD dwFlags,
	IN DWORD cbProp,
	IN BYTE const *pbProp);

    HRESULT _GetPropertyA(
	IN WCHAR const *pwszPropName,
	IN DWORD dwFlags,
	IN ICertDBComputedColumn *pIComputedColumn,
	IN OUT DWORD *pcbProp,
	OPTIONAL OUT BYTE *pbProp);

    BOOL _VerifyPropertyLength(
	IN DWORD dwFlags,
	IN DWORD cbProp,
	IN BYTE const *pbProp);

    HRESULT _VerifyPropertyValue(
	IN DWORD dwFlags,
	IN DWORD cbProp,
	IN JET_COLTYP coltyp,
	IN DWORD cbMax);

    HRESULT _CommitTransaction(
        IN BOOL fCommit, 
        IN BOOL fLazyFlush);

    ICertDB *m_pdb;
    CERTSESSION *m_pcs;

    // Reference count
    long m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\view.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.h
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------


#include "resource.h"       // main symbols

// defines for multi-thread handling
typedef enum
{
    ENUMTHREAD_OPEN = 0,
    ENUMTHREAD_NEXT,
    ENUMTHREAD_CLEANUP,
    ENUMTHREAD_END
} ENUMTHREADCALLS;


class CEnumCERTDBRESULTROW: public IEnumCERTDBRESULTROW
{
public:
    CEnumCERTDBRESULTROW(BOOL fThreading = TRUE);
    ~CEnumCERTDBRESULTROW();

    // IUnknown
    STDMETHODIMP QueryInterface(const IID& iid, void **ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumCERTDBRESULTROW
    STDMETHOD(Next)(
	/* [in] */  ICertDBComputedColumn *pIComputedColumn,
	/* [in] */  ULONG            celt,
	/* [out] */ CERTDBRESULTROW *rgelt,
	/* [out] */ ULONG           *pceltFetched);

    STDMETHOD(ReleaseResultRow)(
	/* [in] */      ULONG            celt,
	/* [in, out] */ CERTDBRESULTROW *rgelt);
    
    STDMETHOD(Skip)(
	/* [in] */  LONG  celt,
	/* [out] */ LONG *pielt);
    
    STDMETHOD(Reset)(VOID);
    
    STDMETHOD(Clone)(
	/* [out] */ IEnumCERTDBRESULTROW **ppenum);

    // CEnumCERTDBRESULTROW
    HRESULT Open(
	IN CERTSESSION *pcs,
	IN ICertDB *pdb,
	IN DWORD ccvr,
	IN CERTVIEWRESTRICTION const *acvr,
	IN DWORD ccolOut,
	IN DWORD const *acolOut);

private:
    VOID _Cleanup();

    HRESULT _SetTable(
	IN LONG ColumnIndex,
	OUT LONG *pColumnIndexDefault);

    HRESULT _SaveRestrictions(
	IN DWORD ccvrIn,
	IN CERTVIEWRESTRICTION const *acvrIn,
	IN LONG ColumnIndexDefault);

    // multi-thread handling
    static DWORD WINAPI _ViewWorkThreadFunctionHelper(LPVOID lp);
    HRESULT _HandleThreadError();
    HRESULT _ThreadOpen(DWORD dwCallerThreadID);
    HRESULT _ThreadNext(DWORD dwCallerThreadID);
    VOID    _ThreadCleanup(DWORD dwCallerThreadID);
    DWORD   _ViewWorkThreadFunction(VOID);

    ICertDB             *m_pdb;
    CERTSESSION         *m_pcs;
    CERTVIEWRESTRICTION *m_aRestriction;
    DWORD                m_cRestriction;
    DWORD                m_ccolOut;
    DWORD               *m_acolOut;
    BOOL                 m_fNoMoreData;
    LONG                 m_ieltMax;
    LONG                 m_ielt;
    LONG                 m_cskip;

    // thread stuff
    HANDLE               m_hWorkThread;
    HANDLE               m_hViewEvent;
    HANDLE               m_hReturnEvent;
    HRESULT              m_hrThread;
    ENUMTHREADCALLS      m_enumViewCall;
    VOID                *m_pThreadParam;
    BOOL                 m_fThreading;
//#if DBG_CERTSRV
    DWORD                m_dwCallerThreadId;
//#endif

    // Reference count
    long                 m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\view.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        view.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "column.h"
#include "enum.h"
#include "db.h"
#include "row.h"
#include "view.h"

#define __dwFILE__	__dwFILE_CERTDB_VIEW_CPP__


#if DBG_CERTSRV
#define  THREAD_TIMEOUT    INFINITE
#else
#define  THREAD_TIMEOUT    INFINITE    // used to be 10000ms=10 seconds
#endif

#if DBG
LONG g_cCertDBResultRow;
LONG g_cCertDBResultRowTotal;
#endif

#ifdef DBG_CERTSRV_DEBUG_PRINT
DWORD s_ssDB = DBG_SS_CERTDBI;
#endif

#if DBG_CERTSRV
VOID
dbDumpFileTime(
    IN DWORD dwSubSystemId,
    IN CHAR const *pszPrefix,
    IN FILETIME const *pft);
#endif

typedef struct
{
    CERTSESSION *pcs;
    ICertDB *pdb;
    DWORD ccvr;
    CERTVIEWRESTRICTION const *acvr;
    DWORD ccolOut;
    DWORD const *acolOut;
} THREAD_PARAM_OPEN;

typedef struct
{
    ICertDBComputedColumn *pIComputedColumn;
    ULONG                  celt;
    CERTDBRESULTROW       *rgelt;
    ULONG                 *pceltFetched;
} THREAD_PARAM_NEXT;



CEnumCERTDBRESULTROW::CEnumCERTDBRESULTROW(
    IN BOOL fThreading) :
    m_fThreading(fThreading)
{
    DBGCODE(InterlockedIncrement(&g_cCertDBResultRow));
    DBGCODE(InterlockedIncrement(&g_cCertDBResultRowTotal));
    m_pdb = NULL;
    m_pcs = NULL;
    m_aRestriction = NULL;
    m_acolOut = NULL;
    m_cRef = 1;
    m_ieltMax = 0;
    m_hWorkThread = NULL;
    m_hViewEvent = NULL;
    m_hrThread = S_OK;
    m_hReturnEvent = NULL;
    m_enumViewCall = ENUMTHREAD_END;
    m_pThreadParam = NULL;
//#if DBG_CERTSRV
    m_dwCallerThreadId = 0;
//#endif
}


CEnumCERTDBRESULTROW::~CEnumCERTDBRESULTROW()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBResultRow));
    _Cleanup();
}


// The following is the worker thread procedure to handle calls.
// All view calls will be made in this thread.

DWORD WINAPI
CEnumCERTDBRESULTROW::_ViewWorkThreadFunctionHelper(
    LPVOID lpParam)
{
    HRESULT hr = S_OK;

    DBGPRINT((s_ssDB, "worker thread (tid=%d) is created.\n", GetCurrentThreadId()));

    if (NULL == lpParam)
    {
        hr = E_POINTER;
        _PrintError(hr, "null pointer, kill worker thread unexpectedly");
        ExitThread(hr);
    }

    // call real one

    return (((CEnumCERTDBRESULTROW*)lpParam)->_ViewWorkThreadFunction());
}


DWORD
CEnumCERTDBRESULTROW::_ViewWorkThreadFunction(VOID)
{
    HRESULT  hr = S_OK;

    while (TRUE)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hViewEvent, INFINITE))
        {
            switch (m_enumViewCall)
            {
                case ENUMTHREAD_OPEN:
                    // call open
                    m_hrThread = _ThreadOpen(m_dwCallerThreadId);
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                break;

                case ENUMTHREAD_NEXT:
                    // call next
                    m_hrThread = _ThreadNext(m_dwCallerThreadId);
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                break;

                case ENUMTHREAD_CLEANUP:
                    // call cleanup
                    _ThreadCleanup(m_dwCallerThreadId);
                    m_hrThread = S_OK;
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                break;

                case ENUMTHREAD_END:
                    DBGPRINT((s_ssDB, "End worker thread (tid=%d)\n", GetCurrentThreadId()));
                    ExitThread(hr);
                break;

                default:
                    // unexpected
                    DBGPRINT((DBG_SS_CERTDB, "Unexpected event from (tid=%d)\n", m_dwCallerThreadId));
                    m_hrThread = E_UNEXPECTED;
                    if (!SetEvent(m_hReturnEvent))
                    {
                        hr = myHLastError();
                        _PrintError(hr, "SetEvent");
                    }
                    CSASSERT(FALSE);
                break;
            }
        }
    }
    return(hr);
}


VOID
CEnumCERTDBRESULTROW::_Cleanup()
{
    HRESULT hr;

    if (!m_fThreading)
    {
        CSASSERT(NULL == m_hWorkThread);
        _ThreadCleanup(0);	// no work thread, call directly
    }
    else
    {
        if (NULL != m_hWorkThread &&
            NULL != m_hViewEvent &&
            NULL != m_hReturnEvent)
        {
	    // ask work thread to do clean up
	    m_enumViewCall = ENUMTHREAD_CLEANUP;
//#if DBG_CERTSRV
	    m_dwCallerThreadId = GetCurrentThreadId();
	    DBGPRINT((
		s_ssDB,
		"CEnumCERTDBRESULTROW::_Cleanup(tid=%d) (this=0x%x)\n",
		m_dwCallerThreadId,
		this));
//#endif
	    //set cleanup event
	    if (!SetEvent(m_hViewEvent))
	    {
		hr = myHLastError();
		_PrintError(hr, "SetEvent");
	    }
	    else
	    {
		hr = _HandleThreadError();
		_PrintIfError(hr, "_HandleThreadError");
	    }

	    // ask the thread end
	    m_enumViewCall = ENUMTHREAD_END;
	    if (!SetEvent(m_hViewEvent))
	    {
		hr = myHLastError();
		_PrintError(hr, "SetEvent(thread still alive");
	    }
	    else
	    {
		if (WAIT_OBJECT_0 != WaitForSingleObject(m_hWorkThread, THREAD_TIMEOUT))
		{
		    hr = myHLastError();
		    _PrintError(hr, "Thread is not killed");
		}
	    }
	    if (GetExitCodeThread(m_hWorkThread, (DWORD *) &hr))
	    {
		_PrintIfError(hr, "Work thread error");
	    }

            m_pThreadParam = NULL; //may not be necessary, but safe
	}
	if (NULL != m_hWorkThread)
	{
	    CloseHandle(m_hWorkThread);
	    m_hWorkThread = NULL;
	}
	if (NULL != m_hViewEvent)
	{
	    CloseHandle(m_hViewEvent);
	    m_hViewEvent = NULL;
	}
	if (NULL != m_hReturnEvent)
	{
	    CloseHandle(m_hReturnEvent);
	    m_hReturnEvent = NULL;
	}
    }
    if (NULL != m_pdb)
    {
	m_pdb->Release();
	m_pdb = NULL;
    }
}


VOID
CEnumCERTDBRESULTROW::_ThreadCleanup(
    IN DWORD /* dwCallerThreadID */ )
{
    HRESULT hr;
    DWORD i;

    if (NULL != m_pdb)
    {
	if (NULL != m_pcs)
	{
	    hr = ((CCertDB *) m_pdb)->CloseTables(m_pcs);
	    _PrintIfError(hr, "CloseTables");

	    hr = ((CCertDB *) m_pdb)->CommitTransaction(m_pcs, FALSE, FALSE);
	    _PrintIfError(hr, "CommitTransaction");

	    hr = ((CCertDB *) m_pdb)->ReleaseSession(m_pcs);
	    _PrintIfError(hr, "ReleaseSession");
	    m_pcs = NULL;
	}
	if (NULL != m_aRestriction)
	{
	    for (i = 0; i < m_cRestriction; i++)
	    {
		if (NULL != m_aRestriction[i].pbValue)
		{
		    LocalFree(m_aRestriction[i].pbValue);
		}
	    }
	    LocalFree(m_aRestriction);
	    m_aRestriction = NULL;
	}
	if (NULL != m_acolOut)
	{
	    LocalFree(m_acolOut);
	    m_acolOut = NULL;
	}
    }
}


HRESULT
CEnumCERTDBRESULTROW::_HandleThreadError()
{
    HRESULT hr = S_OK;
    HANDLE ahEvents[] = { m_hReturnEvent, m_hWorkThread };

    // need to handle error
    DWORD dwWaitState = WaitForMultipleObjects(
                            ARRAYSIZE(ahEvents),
                            ahEvents,
                            FALSE,
                            THREAD_TIMEOUT);

    // reset
    m_pThreadParam = NULL;
//#if DBG_CERTSRV
    //m_dwCallerThreadId = 0;
//#endif

    if (WAIT_OBJECT_0 == dwWaitState)
    {
        // signaled from work thread
        hr = m_hrThread;
    }
    else if (WAIT_OBJECT_0 + 1 == dwWaitState)
    {
        // work thread ended unexpectedly
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "work thread is ended unexpectedly");
    }
    else if (WAIT_TIMEOUT == dwWaitState)
    {
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
        _JumpError(hr, error, "WaitForSingleObject(timeout)");
    }
    else if (WAIT_FAILED == dwWaitState)
    {
        hr = myHLastError();
        _JumpError(hr, error, "WaitForSingleObject");
    }

error:
    return(hr);
}


// Truncate FILETIME to next lower minute and add lMinuteCount minutes (if !0)

HRESULT
myMakeExprDateMinuteRound(
    IN OUT FILETIME *pft,
    IN LONG lMinuteCount)
{
    HRESULT hr;
    SYSTEMTIME st;

#if DBG_CERTSRV
    dbDumpFileTime(DBG_SS_CERTDBI, "MinuteRound(IN):  ", pft);
#endif
    FileTimeToSystemTime(pft, &st);
    st.wSecond = 0;
    st.wMilliseconds = 0;

    if (!SystemTimeToFileTime(&st, pft))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SystemTimeToFileTime");
    }
    if (0 != lMinuteCount)
    {
	myMakeExprDateTime(pft, lMinuteCount, ENUM_PERIOD_MINUTES);
    }
#if DBG_CERTSRV
    dbDumpFileTime(DBG_SS_CERTDBI, "MinuteRound(OUT): ", pft);
#endif
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTDBRESULTROW::_SetTable(
    IN LONG ColumnIndex,
    OUT LONG *pColumnIndexDefault)
{
    HRESULT hr;
    DWORD dwTable;
    LONG ColumnIndexDefault;
    
    if (0 > ColumnIndex)
    {
	switch (ColumnIndex)
	{
	    case CV_COLUMN_LOG_DEFAULT:
	    case CV_COLUMN_LOG_FAILED_DEFAULT:
	    case CV_COLUMN_LOG_REVOKED_DEFAULT:
	    case CV_COLUMN_QUEUE_DEFAULT:
		ColumnIndex = DTI_REQUESTTABLE;
		break;

	    case CV_COLUMN_EXTENSION_DEFAULT:
		ColumnIndex = DTI_EXTENSIONTABLE;
		break;

	    case CV_COLUMN_ATTRIBUTE_DEFAULT:
		ColumnIndex = DTI_ATTRIBUTETABLE;
		break;

	    case CV_COLUMN_CRL_DEFAULT:
		ColumnIndex = DTI_CRLTABLE;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad negative ColumnIndex");
	}
    }
    if (~(DTI_COLUMNMASK | DTI_TABLEMASK) & ColumnIndex)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "invalid bits");
    }
    switch (DTI_TABLEMASK & ColumnIndex)
    {
	case DTI_REQUESTTABLE:
	case DTI_CERTIFICATETABLE:
	    dwTable = TABLE_REQCERTS;
	    ColumnIndexDefault = DTI_REQUESTTABLE | DTR_REQUESTID;
	    break;

	case DTI_EXTENSIONTABLE:
	    dwTable = TABLE_EXTENSIONS;
	    ColumnIndexDefault = DTI_EXTENSIONTABLE | DTE_REQUESTID;
	    break;

	case DTI_ATTRIBUTETABLE:
	    dwTable = TABLE_ATTRIBUTES;
	    ColumnIndexDefault = DTI_ATTRIBUTETABLE | DTA_REQUESTID;
	    break;

	case DTI_CRLTABLE:
	    dwTable = TABLE_CRLS;
	    ColumnIndexDefault = DTI_CRLTABLE | DTL_ROWID;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad table");
    }
    if (CSF_TABLESET & m_pcs->SesFlags)
    {
	if ((CSF_TABLEMASK & m_pcs->SesFlags) != dwTable)
	{
	    DBGPRINT((
		DBG_SS_CERTVIEW,
		"_SetTable: Table=%x <- %x\n",
		CSF_TABLEMASK & m_pcs->SesFlags,
		dwTable));
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "mixed tables");
	}
    }
    else
    {
	CSASSERT(0 == (CSF_TABLEMASK & m_pcs->SesFlags));
	m_pcs->SesFlags |= CSF_TABLESET | dwTable;
    }
    *pColumnIndexDefault = ColumnIndexDefault;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTDBRESULTROW::_SaveRestrictions(
    IN DWORD ccvrIn,
    IN CERTVIEWRESTRICTION const *acvrIn,
    IN LONG ColumnIndexDefault)
{
    HRESULT hr;
    DWORD ccvrAlloc;
    CERTVIEWRESTRICTION const *pcvr;
    CERTVIEWRESTRICTION const *pcvrEnd;
    CERTVIEWRESTRICTION const *pcvrIndexed;
    CERTVIEWRESTRICTION *pcvrDst;
    BOOL fFoundSortOrder;
    BOOL fDefault;
    DWORD dwDefaultValue;
    DWORD Type;
    FILETIME ft;
    
    ccvrAlloc = ccvrIn;
    pcvrIndexed = NULL;
    fFoundSortOrder = FALSE;
    Type = 0;
    pcvrEnd = &acvrIn[ccvrIn];
    for (pcvr = acvrIn; pcvr < pcvrEnd; pcvr++)     // for each restriction
    {
        fDefault = 0 > (LONG) pcvr->ColumnIndex;
        if (!fDefault)
        {
            hr = ((CCertDB *) m_pdb)->GetColumnType(pcvr->ColumnIndex, &Type);
            _JumpIfError(hr, error, "GetColumnType");
        }
	if (fDefault || (PROPFLAGS_INDEXED & Type))
	{
	    if (!fFoundSortOrder && CVR_SORT_NONE != pcvr->SortOrder)
	    {
		// if the first indexed column with sort order, save this one.

		fFoundSortOrder = TRUE;
		pcvrIndexed = pcvr;
	    }
	    else
	    if (NULL == pcvrIndexed)
	    {
		// if the first indexed column, save this one.

		pcvrIndexed = pcvr;
	    }
	}
	if (CVR_SORT_NONE != pcvr->SortOrder && pcvrIndexed != pcvr)
	{
	    hr = E_INVALIDARG;
	    DBGPRINT((DBG_SS_CERTDB, "_SaveRestrictions(%x)\n", pcvr->ColumnIndex));
	    _JumpError(hr, error, "multiple SortOrders or non-indexed column");
	}
        if (!fDefault &&
            PROPTYPE_DATE == (PROPTYPE_MASK & Type) &&
            CVR_SEEK_EQ == pcvr->SeekOperator)
        {
            ccvrAlloc++;	// Turn Date == value into a range restriction
        }
    }
    if (NULL == pcvrIndexed)
    {
        ccvrAlloc++;	// No indexed column: add RequestId >= 0
    }

    m_aRestriction = (CERTVIEWRESTRICTION *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					ccvrAlloc * sizeof(m_aRestriction[0]));
    if (NULL == m_aRestriction)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    m_cRestriction = ccvrAlloc;
    
    pcvrDst = m_aRestriction;
    
    // If no indexed restriction, add one.
    if (NULL == pcvrIndexed)
    {
        pcvrDst->ColumnIndex = ColumnIndexDefault;
        pcvrDst->SeekOperator = CVR_SEEK_NONE;
        pcvrDst->SortOrder = CVR_SORT_ASCEND;
        pcvrDst->cbValue = 0;
        pcvrDst->pbValue = NULL;

        pcvrDst++;
    }

    for (pcvr = acvrIn; pcvr < pcvrEnd; pcvr++)
    {
        CERTVIEWRESTRICTION const *pcvrSrc = pcvr;
        BYTE *pbValue;
        
        // Swap the first restriction with the first indexed restriction
        
        if (NULL != pcvrIndexed)
        {
            if (pcvrSrc == acvrIn)
            {
                pcvrSrc = pcvrIndexed;
            }
            else if (pcvrSrc == pcvrIndexed)
            {
                pcvrSrc = acvrIn;
            }
        }
        *pcvrDst = *pcvrSrc;

        if (pcvrSrc == pcvrIndexed && CVR_SORT_NONE == pcvrSrc->SortOrder)
	{
	    pcvrDst->SortOrder = CVR_SORT_ASCEND;
	}
        pcvrDst->pbValue = NULL;
        
        fDefault = 0 > (LONG) pcvr->ColumnIndex;
        if (fDefault)
        {
            pcvrDst->SeekOperator = CVR_SEEK_GE; // default seek operator
	    dwDefaultValue = 1;			 // default RequestId/Rowid
	    switch (pcvr->ColumnIndex)
	    {
		case CV_COLUMN_QUEUE_DEFAULT:
		case CV_COLUMN_LOG_DEFAULT:
		case CV_COLUMN_LOG_FAILED_DEFAULT:
		case CV_COLUMN_LOG_REVOKED_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_REQUESTTABLE | DTR_REQUESTDISPOSITION;
		    if (CV_COLUMN_QUEUE_DEFAULT == pcvr->ColumnIndex)
		    {
			dwDefaultValue = DB_DISP_QUEUE_MAX;
			pcvrDst->SeekOperator = CVR_SEEK_LE;
		    }
		    else if (CV_COLUMN_LOG_DEFAULT == pcvr->ColumnIndex)
		    {
			dwDefaultValue = DB_DISP_LOG_MIN;
		    }
		    else if (CV_COLUMN_LOG_REVOKED_DEFAULT == pcvr->ColumnIndex)
		    {
			dwDefaultValue = DB_DISP_REVOKED;
			pcvrDst->SeekOperator = CVR_SEEK_EQ;
		    }
		    else
		    {
			dwDefaultValue = DB_DISP_LOG_FAILED_MIN;
		    }
		    break;

		case CV_COLUMN_EXTENSION_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_EXTENSIONTABLE | DTE_REQUESTID;
		    break;

		case CV_COLUMN_ATTRIBUTE_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_ATTRIBUTETABLE | DTA_REQUESTID;
		    break;

		case CV_COLUMN_CRL_DEFAULT:
		    pcvrDst->ColumnIndex = DTI_CRLTABLE | DTL_ROWID;
		    break;

		default:
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "bad default restriction column");
		    break;
	    }
            pcvrDst->cbValue = sizeof(dwDefaultValue);
            pbValue = (BYTE *) &dwDefaultValue;
        }
        else
        {
            // To handle rounding errors, modify date restrictions as follows:
            //
            // DateColumn == Constant ==> two restrictions:
            //     DateColumn < Ceiling(Constant) &&
            //     DateColumn >= Floor(Constant)
            //
            // DateColumn > Constant ==> DateColumn >= Ceiling(Constant)
            // DateColumn >= Constant ==> DateColumn >= Floor(Constant)
            //
            // DateColumn < Constant ==> DateColumn < Floor(Constant) 
            // DateColumn <= Constant ==> DateColumn < Ceiling(Constant)
            
            hr = ((CCertDB *) m_pdb)->GetColumnType(
						pcvrDst->ColumnIndex,
						&Type);
            _JumpIfError(hr, error, "GetColumnType");
            
            pbValue = pcvrSrc->pbValue;

            if (PROPTYPE_DATE == (PROPTYPE_MASK & Type) &&
                0 == (CVR_SEEK_NODELTA & pcvrDst->SeekOperator) &&
                CVR_SEEK_NONE != (CVR_SEEK_MASK & pcvrDst->SeekOperator))
            {
                LONG lMinuteCount = 0;	// assume truncate to lower minute

                if(NULL == pcvrSrc->pbValue)
                {
                    hr = E_INVALIDARG;
                    _JumpError(hr, error, "restriction value is null");
                }
		ft = *(FILETIME *) pcvrSrc->pbValue;
                pbValue = (BYTE *) &ft;
                
                switch (CVR_SEEK_MASK & pcvrDst->SeekOperator)
                {
		    FILETIME ftCeiling;

		    case CVR_SEEK_EQ:
			ftCeiling = ft;
			hr = myMakeExprDateMinuteRound(&ftCeiling, 1);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			pcvrDst->pbValue = (BYTE *) LocalAlloc(
							    LMEM_FIXED,
							    sizeof(ft));
			if (NULL == pcvrDst->pbValue)
			{
			    hr = E_OUTOFMEMORY;
			    _JumpError(hr, error, "LocalAlloc");
			}
			CopyMemory(pcvrDst->pbValue, &ftCeiling, pcvrDst->cbValue);
			pcvrDst->SeekOperator = CVR_SEEK_LT | CVR_SEEK_NODELTA;
			pcvrDst++;
			
			*pcvrDst = *pcvrSrc;
			pcvrDst->pbValue = NULL;
			pcvrDst->SeekOperator = CVR_SEEK_GE | CVR_SEEK_NODELTA;
			hr = myMakeExprDateMinuteRound(&ft, 0);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			break;
			
		    case CVR_SEEK_GT:
			lMinuteCount = 1;	// round to next higher minute
			// FALL THROUGH

		    case CVR_SEEK_GE:
			pcvrDst->SeekOperator = CVR_SEEK_GE | CVR_SEEK_NODELTA;
			hr = myMakeExprDateMinuteRound(&ft, lMinuteCount);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			break;

		    case CVR_SEEK_LE:
			lMinuteCount = 1;	// round to next higher minute
			// FALL THROUGH

		    case CVR_SEEK_LT:
			pcvrDst->SeekOperator = CVR_SEEK_LT | CVR_SEEK_NODELTA;
			hr = myMakeExprDateMinuteRound(&ft, lMinuteCount);
			_JumpIfError(hr, error, "myMakeExprDateMinuteRound");

			break;

		    default:
			hr = E_INVALIDARG;
			_JumpError(hr, error, "invalid seek operator");
			
                }
            }
        }
        
        // either nonzero or SEEK_NONE

        CSASSERT((0 != pcvrDst->cbValue) || ((CVR_SEEK_MASK & pcvrDst->SeekOperator) == CVR_SEEK_NONE));

        if (0 != pcvrDst->cbValue)
        {
            pcvrDst->pbValue = (BYTE *) LocalAlloc(LMEM_FIXED, pcvrDst->cbValue);
            if (NULL == pcvrDst->pbValue)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "alloc value");
            }
            CopyMemory(pcvrDst->pbValue, pbValue, pcvrDst->cbValue);
        }
        pcvrDst++;
    }
    CSASSERT(pcvrDst == &m_aRestriction[m_cRestriction]);

#if DBG_CERTSRV
    pcvrEnd = &m_aRestriction[m_cRestriction];
    for (pcvr = m_aRestriction; pcvr < pcvrEnd; pcvr++)
    {
	((CCertDB *) m_pdb)->DumpRestriction(
				DBG_SS_CERTDBI,
				SAFE_SUBTRACT_POINTERS(pcvr, m_aRestriction),
				pcvr);
    }
#endif // DBG_CERTSRV

    hr = S_OK;

error:
    return(hr);
}



HRESULT
CEnumCERTDBRESULTROW::Open(
    IN CERTSESSION *pcs,
    IN ICertDB *pdb,
    IN DWORD ccvr,
    IN CERTVIEWRESTRICTION const *acvr,
    IN DWORD ccolOut,
    IN DWORD const *acolOut)
{
    HRESULT hr;
    THREAD_PARAM_OPEN  tpOpen;

    CSASSERT(NULL == m_hViewEvent);
    CSASSERT(NULL == m_hReturnEvent);
    CSASSERT(NULL == m_hWorkThread);

    if (NULL != m_hViewEvent ||
        NULL != m_hReturnEvent ||
        NULL != m_hWorkThread)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "unexpected thread sync. state");
    }

    hr = ((CCertDB *) pdb)->TestShutDownState();
    _JumpIfError(hr, error, "TestShutDownState");

    // call cleanup before worker thread is created

    _Cleanup();

    tpOpen.pcs = pcs;
    tpOpen.pdb = pdb;
    tpOpen.ccvr = ccvr;
    tpOpen.acvr = acvr;
    tpOpen.ccolOut = ccolOut;
    tpOpen.acolOut = acolOut;
    m_pThreadParam = (void*)&tpOpen;
//#if DBG_CERTSRV
    m_dwCallerThreadId = GetCurrentThreadId();
    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::Open(tid=%d) (this=0x%x)\n", m_dwCallerThreadId, this));
//#endif

    if (m_fThreading)
    {
        m_hViewEvent = CreateEvent(
                            NULL,  //child inheritance
                            FALSE,  //manual reset
                            FALSE, //initial signaled
                            NULL); //name
        if (NULL == m_hViewEvent)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateEvent");
        }

        m_hReturnEvent = CreateEvent(
                            NULL,  //child inheritance
                            FALSE,  //manual reset
                            FALSE, //initial signaled
                            NULL); //name
        if (NULL == m_hReturnEvent)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateEvent");
        }

        m_hWorkThread = CreateThread(
			NULL,  //no child inheritance
			0,     //use default stack size
			_ViewWorkThreadFunctionHelper, // thread function
			this,  //pass this pointer
			0,     //run immediately
			&pcs->dwThreadId); //session thread id is overwritten
        if (NULL == m_hWorkThread)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateThread");
        }

        m_enumViewCall = ENUMTHREAD_OPEN;
        //set open event
        if (!SetEvent(m_hViewEvent))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetEvent");
        }
        else
        {
            hr = _HandleThreadError();
        }
    }
    else
    {
        // don't go through worker thread

        hr = _ThreadOpen(0);
    }
    //hr = S_OK;

error:
    return(hr);
}

HRESULT
CEnumCERTDBRESULTROW::_ThreadOpen(
    IN DWORD /* dwCallerThreadID */ )
{
    HRESULT hr;
    THREAD_PARAM_OPEN *ptpOpen = (THREAD_PARAM_OPEN *)m_pThreadParam;
    LONG ColumnIndexDefault = DTI_REQUESTTABLE | DTR_REQUESTID;
    DWORD i;

    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::ThreadOpen(tid=%d) from (tid=%d)\n", GetCurrentThreadId(), m_dwCallerThreadId));

    CSASSERT(NULL != ptpOpen);
    CSASSERTTHREAD(ptpOpen->pcs);

    if (NULL == ptpOpen->pcs ||
	NULL == ptpOpen->pdb ||
	(NULL == ptpOpen->acvr && 0 != ptpOpen->ccvr) ||
	NULL == ptpOpen->acolOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    m_fNoMoreData = FALSE;
    m_pcs = ptpOpen->pcs;
    m_pdb = ptpOpen->pdb;
    m_pdb->AddRef();
    m_ielt = 0;
    m_cskip = 0;

    CSASSERT(0 == m_pcs->cTransact);
    if (NULL != ptpOpen->acolOut)
    {
	for (i = 0; i < ptpOpen->ccolOut; i++)
	{
	    hr = _SetTable(ptpOpen->acolOut[i], &ColumnIndexDefault);
	    _JumpIfError(hr, error, "_SetTable");
	}
    }
    for (i = 0; i < ptpOpen->ccvr; i++)
    {
	hr = _SetTable(ptpOpen->acvr[i].ColumnIndex, &ColumnIndexDefault);
	_JumpIfError(hr, error, "_SetTable");
    }

    hr = _SaveRestrictions(ptpOpen->ccvr, ptpOpen->acvr, ColumnIndexDefault);
    _JumpIfError(hr, error, "_SaveRestrictions");

    m_ccolOut = ptpOpen->ccolOut;
    if (NULL != ptpOpen->acolOut)
    {
	m_acolOut = (DWORD *) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(m_acolOut[0]) * m_ccolOut);
	if (NULL == m_acolOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "alloc output columns");
	}
	CopyMemory(m_acolOut, ptpOpen->acolOut, sizeof(m_acolOut[0]) * m_ccolOut);
    }

    //if (!(CSF_READONLY & ptpOpen->pcs->SesFlags))
    {
	hr = ((CCertDB *) m_pdb)->BeginTransaction(m_pcs, FALSE);
	_JumpIfError(hr, error, "BeginTransaction");
    }
    hr = ((CCertDB *) m_pdb)->OpenTables(m_pcs, &m_aRestriction[0]);
    _PrintIfError2(hr, "OpenTables", CERTSRV_E_PROPERTY_EMPTY);

    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	m_fNoMoreData = TRUE;
	m_ieltMax = 0;
	hr = S_OK;
    }
    _JumpIfError(hr, error, "OpenTables");

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Next(
    /* [in] */  ICertDBComputedColumn *pIComputedColumn,
    /* [in] */  ULONG            celt,
    /* [out] */ CERTDBRESULTROW *rgelt,
    /* [out] */ ULONG           *pceltFetched)
{
    HRESULT hr;
    THREAD_PARAM_NEXT tpNext;

    tpNext.pIComputedColumn = pIComputedColumn;
    tpNext.celt = celt;
    tpNext.rgelt = rgelt;
    tpNext.pceltFetched = pceltFetched;
    m_pThreadParam = (void*)&tpNext;
//#if DBG_CERTSRV
    m_dwCallerThreadId = GetCurrentThreadId();
    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::Next(tid=%d) (this=0x%x)\n", m_dwCallerThreadId, this));
//#endif

    CSASSERT(NULL != m_pdb);
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->TestShutDownState();
    _JumpIfError(hr, error, "TestShutDownState");

    if (m_fThreading)
    {
        CSASSERT(NULL != m_hViewEvent);
        CSASSERT(NULL != m_hReturnEvent);
        CSASSERT(NULL != m_hWorkThread);

        if (NULL == m_hViewEvent ||
            NULL == m_hReturnEvent ||
            NULL == m_hWorkThread)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, error, "unexpected thread sync. state");
        }

        m_enumViewCall = ENUMTHREAD_NEXT;

        // set next event

        if (!SetEvent(m_hViewEvent))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetEvent");
        }
        else
        {
            hr = _HandleThreadError();
        }
    }
    else
    {
        // don't go through worker thread

        hr = _ThreadNext(0);
    }
    //hr = S_OK;

error:
    return(hr);
}


HRESULT
CEnumCERTDBRESULTROW::_ThreadNext(
    IN DWORD /* dwCallerThreadID */ )
{
    HRESULT hr;
    LONG cskip;
    LONG cskipped;
    THREAD_PARAM_NEXT  *ptpNext = (THREAD_PARAM_NEXT *)m_pThreadParam;

    DBGPRINT((s_ssDB, "CEnumCERTDBRESULTROW::ThreadNext(tid=%d) from (tid=%d)\n", GetCurrentThreadId(), m_dwCallerThreadId));
    CSASSERT(NULL != ptpNext);

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Trace: hr = penum->Next(%d, arow, &crow);\t_PrintIfError(hr, \"Next\");\n",
	ptpNext->celt));
    if (NULL == ptpNext->rgelt || NULL == ptpNext->pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ptpNext->pceltFetched = 0;
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    ZeroMemory(ptpNext->rgelt, ptpNext->celt * sizeof(ptpNext->rgelt[0]));

    CSASSERT(0 <= m_ielt);
    CSASSERT(0 <= m_ielt + m_cskip);
    DBGPRINT((
	DBG_SS_CERTDBI,
	"Next(celt=%d) ielt=%d, skip=%d\n",
	ptpNext->celt,
	m_ielt,
	m_cskip));

    hr = S_FALSE;
    if (m_fNoMoreData)
    {
	// We know no additional data can be returned until Reset is called or
	// until Skip is called with a negative skip count.  Don't bother...

	_JumpError2(hr, error, "NoMoreData", S_FALSE);
    }

    // If we have previously computed the end of the data set, ...

    cskip = m_cskip;
    if (0 != m_ieltMax)
    {
	if (m_ielt + cskip >= m_ieltMax)
	{
	    // The requested data lies past the computed end of the data set.

	    CSASSERT(S_FALSE == hr);
	    m_fNoMoreData = TRUE;
	    _JumpError2(hr, error, "past end", S_FALSE);
	}

	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "cskip = %d  m_ielt = %d  m_ieltMax = %d\n",
	    cskip,
	    m_ielt,
	    m_ieltMax));
	if (0 > cskip && m_ielt > m_ieltMax)
	{
	    // We're skiping backwards.  If we started out past the end of the
	    // data set, we must reduce the negative skip count passed to the
	    // DB layer to position the index cursor correctly.

	    cskip += m_ielt - m_ieltMax;
	    DBGPRINT((
		DBG_SS_CERTDBI,
		"MODIFIED: cskip = %d  m_ielt = %d  m_ieltMax = %d\n",
		cskip,
		m_ielt,
		m_ieltMax));
	}
    }

    hr = ((CCertDB *) m_pdb)->EnumCertDBResultRowNext(
						m_pcs,
						m_cRestriction,
						m_aRestriction,
						m_ccolOut,
						m_acolOut,
						cskip,
						ptpNext->pIComputedColumn,
						ptpNext->celt,
						ptpNext->rgelt,
						ptpNext->pceltFetched,
						&cskipped);
    if (S_FALSE == hr)
    {
	// Only set m_ieltMax the first time we run off the end, when we will
	// be guaranteed that we are moving forward through the DB index.
	// Otherwise the math is too complicated and would be redundant anyway.
	
	if (0 == m_ieltMax)
	{
	    CSASSERT(0 <= cskip);
	    CSASSERT(0 <= cskipped);
	    m_ieltMax = m_ielt + cskipped;
	}
	DBGPRINT((
	    DBG_SS_CERTDBI,
	    "Next: ieltMax=%d  ielt=%d, cskipped=%d\n",
	    m_ieltMax,
	    m_ielt,
	    cskipped));
	m_fNoMoreData = TRUE;
    }
    else
    {
	_JumpIfError(hr, error, "EnumCertDBResultRowNext");
    }

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Next: ielt=%d -> %d  cskip=%d, *pceltFetched=%d\n",
	m_ielt,
	m_ielt + m_cskip + *ptpNext->pceltFetched,
	m_cskip,
	*ptpNext->pceltFetched));

    m_ielt += m_cskip;
    m_ielt += *ptpNext->pceltFetched;
    m_cskip = 0;

error:
    if (S_FALSE == hr)
    {
	CSASSERT(NULL != ptpNext->rgelt);
	CSASSERT(NULL != ptpNext->pceltFetched);
	CSASSERT(*ptpNext->pceltFetched < ptpNext->celt);
	CERTDBRESULTROW *peltMaxIndex = &ptpNext->rgelt[*ptpNext->pceltFetched];

	peltMaxIndex->rowid = m_ieltMax;
	peltMaxIndex->ccol = ~m_ieltMax;
    }
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::ReleaseResultRow(
    /* [in] */      ULONG            celt,
    /* [in, out] */ CERTDBRESULTROW *rgelt)
{
    HRESULT hr;

    if (NULL == rgelt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->ReleaseResultRow(celt, rgelt);
    _JumpIfError(hr, error, "ReleaseResultRow");

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Skip(
    /* [in] */  LONG  celt,
    /* [out] */ LONG *pielt)
{
    HRESULT hr;
    LONG cskipnew;
    
    DBGPRINT((
	DBG_SS_CERTDBI,
	"Trace: hr = penum->Skip(%d, &irow);\t_PrintIfError(hr, \"Skip\");\n",
	celt));
    if (NULL == pielt)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cskipnew = m_cskip + celt;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Skip(%d) ielt=%d: %d --> %d, skip=%d --> %d\n",
	celt,
	m_ielt,
	m_ielt + m_cskip,
	m_ielt + cskipnew,
	m_cskip,
	cskipnew));

    CSASSERT(0 <= m_ielt);
    if (0 > celt)
    {
	if (0 > m_ielt + cskipnew)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Skip back to before start");
	}
	m_fNoMoreData = FALSE;
    }

    *pielt = m_ielt + cskipnew;
    m_cskip = cskipnew;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Reset(VOID)
{
    HRESULT hr;
    LONG iDummy;

    DBGPRINT((
	DBG_SS_CERTDBI,
	"Trace: hr = penum->Reset();\t_PrintIfError(hr, \"Reset\");\n// "));
    hr = Skip(-(m_ielt + m_cskip), &iDummy);
    _JumpIfError(hr, error, "Skip");

    CSASSERT(0 == iDummy);

error:
    return(hr);
}


STDMETHODIMP
CEnumCERTDBRESULTROW::Clone(
    /* [out] */ IEnumCERTDBRESULTROW **ppenum)
{
    HRESULT hr;
    LONG iDummy;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    hr = ((CCertDB *) m_pdb)->TestShutDownState();
    _JumpIfError(hr, error, "TestShutDownState");

    hr = ((CCertDB *) m_pdb)->OpenView(
				    m_cRestriction,
				    m_aRestriction,
				    m_ccolOut,
				    m_acolOut,
				    m_fThreading,
				    ppenum);
    _JumpIfError(hr, error, "OpenView");

    (*ppenum)->Skip(m_ielt + m_cskip, &iDummy);

error:
    return(hr);
}


// IUnknown implementation
STDMETHODIMP
CEnumCERTDBRESULTROW::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<IEnumCERTDBRESULTROW *>(this);
    }
    else if (iid == IID_IEnumCERTDBRESULTROW)
    {
	*ppv = static_cast<IEnumCERTDBRESULTROW *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBRESULTROW::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CEnumCERTDBRESULTROW::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CEnumCERTDBRESULTROW::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_IEnumCERTDBRESULTROW,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\adate.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        adate.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "adate.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::~CCertEncodeDateArray -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeDateArray::~CCertEncodeDateArray()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeDateArray::_Cleanup()
{
    if (NULL != m_aValue)
    {
	LocalFree(m_aValue);
	m_aValue = NULL;
    }
    m_cValue = 0;
    m_cValuesSet = 0;
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::Decode -- Decode DateArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    DWORD cbSequence;
    LONG i;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode to an array of ASN blobs:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &pSequence,
		    &cbSequence))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_cValue = pSequence->cValue;
    m_aValue = (DATE *) LocalAlloc(LMEM_FIXED, m_cValue * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    for (i = 0; i < m_cValue; i++)
    {
	DWORD cb;
	FILETIME ft;

	// Decode each ASN blob to a FILETIME:

	cb = sizeof(ft);
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_CHOICE_OF_TIME,
			pSequence->rgValue[i].pbData,
			pSequence->rgValue[i].cbData,
			0,                  // dwFlags
			&ft,
			&cb))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("CryptDecodeObject", hr);
	    goto error;
	}
	assert(sizeof(ft) == cb);

	// Convert each FILETIME into a DATE:

	hr = ceFileTimeToDate(&ft, &m_aValue[i]);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceFileTimeToDate", hr);
	    _Cleanup();
	    goto error;
	}
    }

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::GetCount -- Get Array count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::GetCount(
    /* [out, retval] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pCount = m_cValue;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::GetCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::GetValue -- Fetch the indexed date
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::GetValue(
    /* [in] */ LONG Index,
    /* [out, retval] */ DATE __RPC_FAR *pValue)
{
    HRESULT hr = S_OK;

    if (NULL == pValue)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue || Index >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (0 == m_aValue[Index])
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    *pValue = m_aValue[Index];

error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::GetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::Reset -- clear out data, and set up to encode new data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::Reset(
    /* [in] */ LONG Count)
{
    HRESULT hr = S_OK;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < Count || 0 > Count)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }
    m_aValue = (DATE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				Count * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = Count;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::SetValue -- Set an array date
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::SetValue(
    /* [in] */ LONG Index,
    /* [in] */ DATE Value)
{
    HRESULT hr = S_OK;

    if (!m_fConstructing ||
	NULL == m_aValue ||
	Index >= m_cValue ||
	m_cValuesSet >= m_cValue ||
	0 != m_aValue[Index] ||
	0 == Value)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    m_aValue[Index] = Value;
    m_cValuesSet++;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::SetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::Encode -- Encode DateArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeDateArray::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    LONG i;
    CRYPT_SEQUENCE_OF_ANY Sequence;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    Sequence.cValue = 0;
    Sequence.rgValue = NULL;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (m_cValuesSet != m_cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	ceERRORPRINTLINE("m_cValuesSet", hr);
	goto error;
    }

    Sequence.rgValue = (CRYPT_DER_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    m_cValue * sizeof(Sequence.rgValue[0]));
    if (NULL == Sequence.rgValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	FILETIME ft;

	// Convert each DATE into a FILETIME:

	assert(0 != m_aValue[i]);
	hr = ceDateToFileTime(&m_aValue[i], &ft);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceDateToFileTime", hr);
	    goto error;
	}

	// Encode each FILETIME into an ASN blob:

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_CHOICE_OF_TIME,
			&ft,
			0,
			FALSE,
			&Sequence.rgValue[i].pbData,
			&Sequence.rgValue[i].cbData))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceEncodeObject", hr);
	    goto error;
	}
	Sequence.cValue++;
    }
    assert((LONG) Sequence.cValue == m_cValue);

    // Encode the array of ASN blob:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstrBinary,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != Sequence.rgValue)
    {
	assert((LONG) Sequence.cValue <= m_cValue);
	for (i = 0; i < (LONG) Sequence.cValue; i++)
	{
	    assert(NULL != Sequence.rgValue[i].pbData);
	    LocalFree(Sequence.rgValue[i].pbData);
	}
	LocalFree(Sequence.rgValue);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeDateArray::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeDateArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeDateArray::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODEDATEARRAY,
			    &IID_ICertEncodeDateArray);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certdb\row.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        row.cpp
//
// Contents:    Cert Server Database interface implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"
#include "row.h"
#include "enum.h"
#include "db.h"
#include "dbw.h"

#define __dwFILE__	__dwFILE_CERTDB_ROW_CPP__


#if DBG
LONG g_cCertDBRow;
LONG g_cCertDBRowTotal;
#endif

CCertDBRow::CCertDBRow()
{
    DBGCODE(InterlockedIncrement(&g_cCertDBRow));
    DBGCODE(InterlockedIncrement(&g_cCertDBRowTotal));
    m_pdb = NULL;
    m_pcs = NULL;
    m_cRef = 1;
}


CCertDBRow::~CCertDBRow()
{
    DBGCODE(InterlockedDecrement(&g_cCertDBRow));
    _Cleanup();
}


VOID
CCertDBRow::_Cleanup()
{
    HRESULT hr;

    if (NULL != m_pdb)
    {
	if (NULL != m_pcs)
	{
	    hr = ((CCertDB *) m_pdb)->CloseTables(m_pcs);
	    _PrintIfError(hr, "CloseTables");

	    hr = ((CCertDB *) m_pdb)->ReleaseSession(m_pcs);
	    _PrintIfError(hr, "ReleaseSession");
	    m_pcs = NULL;
	}
	m_pdb->Release();
	m_pdb = NULL;
    }
}


HRESULT
CCertDBRow::Open(
    IN CERTSESSION *pcs,
    IN ICertDB *pdb,
    OPTIONAL IN CERTVIEWRESTRICTION const *pcvr)
{
    HRESULT hr;
    bool fBeginTransaction = false;

    _Cleanup();

    if (NULL == pcs || NULL == pdb)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    m_pdb = pdb;
    m_pdb->AddRef();

    CSASSERT(0 == pcs->cTransact);
    if (!(CSF_READONLY & pcs->SesFlags))
    {
	hr = ((CCertDB *) m_pdb)->BeginTransaction(pcs, FALSE);
	_JumpIfError(hr, error, "BeginTransaction");
    }
    fBeginTransaction = true;

    hr = ((CCertDB *) m_pdb)->OpenTables(pcs, pcvr);
    _JumpIfError2(hr, error, "OpenTables", CERTSRV_E_PROPERTY_EMPTY);

    m_pcs = pcs;

error:

    if (S_OK != hr)
    {
        if(fBeginTransaction && !(CSF_READONLY & pcs->SesFlags))
        {
	    HRESULT hr2;
	    
	    hr2 = ((CCertDB *) m_pdb)->CommitTransaction(pcs, FALSE, FALSE);
	    _PrintIfError(hr2, "CommitTransaction");
        }

	_Cleanup();
    }
    return(hr);
}


STDMETHODIMP
CCertDBRow::BeginTransaction(VOID)
{
    HRESULT hr;

    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (CSF_READONLY & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "read-only row");
    }
    hr = ((CCertDB *) m_pdb)->BeginTransaction(m_pcs, TRUE);
    _JumpIfError(hr, error, "BeginTransaction");

error:
    return(hr);
}

STDMETHODIMP
CCertDBRow::CommitTransaction(
    /* [in] */ DWORD dwCommitFlags)
{
    HRESULT hr;
    BOOL fLazyCommit = ((dwCommitFlags & CDBROW_COMMIT_SOFTCOMMIT)?TRUE:FALSE);
    BOOL fCommit = (((dwCommitFlags & CDBROW_COMMIT_COMMIT) || fLazyCommit)?TRUE:FALSE);
  
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (CSF_READONLY & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "read-only row");
    }
    hr = ((CCertDB *) m_pdb)->CommitTransaction(m_pcs, fCommit, fLazyCommit);
    _JumpIfError(hr, error, "CommitTransaction");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::GetRowId(
    /* [out] */ DWORD *pRowId)
{
    HRESULT hr;
    
    if (NULL == pRowId)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pcs)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_pcs");
    }
    *pRowId = m_pcs->RowId;
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::Delete()
{
    HRESULT hr;
    
    if (!(CSF_DELETE & m_pcs->SesFlags))
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "not open for delete");
    }
    hr = ((CCertDB *) m_pdb)->Delete(m_pcs);
    _JumpIfError(hr, error, "Delete");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::GetProperty(
    /* [in] */      WCHAR const *pwszPropName,
    /* [in] */      DWORD dwFlags,
    /* [in] */      ICertDBComputedColumn *pIComputedColumn,
    /* [in, out] */ DWORD *pcbProp,
    /* [out] */     BYTE *pbProp)		// OPTIONAL
{
    HRESULT hr;
    DWORD *pcbPropT = pcbProp;
    BYTE *pbPropT = pbProp;
    DWORD FlagsT = dwFlags;
    
    if (NULL == pwszPropName || NULL == pcbProp)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    if (NULL == pbProp)
    {
        *pcbProp = 0;
    }

    hr = _GetPropertyA(
		pwszPropName,
		FlagsT,
		pIComputedColumn,
		pcbPropT,
		pbPropT);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
        goto error;
    }

    _JumpIfErrorStr3(
        hr,
        error,
        "_GetPropertyA",
        pwszPropName,
        HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
	E_INVALIDARG);
    
    if (0 == *pcbPropT)
    {
        hr = CERTSRV_E_PROPERTY_EMPTY;
	DBGPRINT((
		DBG_SS_CERTDB,
		"DB: Empty \"%hs\" property: %ws\n",
		PROPTABLE_REQUEST == (PROPTABLE_MASK & dwFlags)?
		    "Request" :
		    PROPTABLE_CERTIFICATE == (PROPTABLE_MASK & dwFlags)?
		    "Certificate" : "CRL",
		pwszPropName));
        _JumpErrorStr(hr, error, "Empty property", pwszPropName);
    }
    CSASSERT(_VerifyPropertyLength(FlagsT, *pcbPropT, pbPropT));
    CSASSERT(_VerifyPropertyLength(dwFlags, *pcbProp, pbProp));

error:
    return(hr);
}


// get a field value

HRESULT
CCertDBRow::_GetPropertyA(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN ICertDBComputedColumn *pIComputedColumn,
    IN OUT DWORD *pcbProp,
    OPTIONAL OUT BYTE *pbProp)
{
    HRESULT hr;
    DBTABLE dt;

    if (PROPTABLE_ATTRIBUTE == (PROPTABLE_MASK & dwFlags))
    {
	hr = _VerifyPropertyValue(
			    dwFlags,
			    0,
			    JET_coltypLongText,
			    CB_DBMAXTEXT_ATTRVALUE);
	_JumpIfError(hr, error, "Property value type mismatch");

	hr = ((CCertDB *) m_pdb)->GetAttribute(
					    m_pcs,
					    pwszPropName,
					    pcbProp,
					    pbProp);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "GetAttribute",
		    pwszPropName,
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = ((CCertDB *) m_pdb)->MapPropId(pwszPropName, dwFlags, &dt);
	_JumpIfErrorStr(hr, error, "MapPropId", pwszPropName);

	hr = _VerifyPropertyValue(dwFlags, 0, dt.dbcoltyp, dt.dwcbMax);
	_JumpIfError2(hr, error, "Property value type mismatch", E_INVALIDARG);

	hr = ((CCertDB *) m_pdb)->GetProperty(
					m_pcs,
					&dt,
					pIComputedColumn,
					pcbProp,
					pbProp);
	if (hr == HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW))
	{
	    goto error;
	}
	_JumpIfError2(hr, error, "GetProperty", CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    return(hr);
}


BOOL
CCertDBRow::_VerifyPropertyLength(
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN BYTE const *pbProp)
{
    BOOL fOk = FALSE;

    switch (dwFlags & PROPTYPE_MASK)
    {
	case PROPTYPE_LONG:
	    fOk = sizeof(LONG) == cbProp;
	    break;

	case PROPTYPE_DATE:
	    fOk = sizeof(FILETIME) == cbProp;
	    break;

	case PROPTYPE_BINARY:
	    fOk = TRUE;		// nothing to check
	    break;

	case PROPTYPE_STRING:
	    if (MAXDWORD == cbProp)
	    {
		cbProp = wcslen((WCHAR const *) pbProp) * sizeof(WCHAR);
	    }
	    fOk =
		0 == cbProp ||
		NULL == pbProp ||
		wcslen((WCHAR const *) pbProp) * sizeof(WCHAR) == cbProp;
	    break;

	default:
	    CSASSERT(!"_VerifyPropertyLength: Unexpected type");
	    break;
    }
    return(fOk);
}


HRESULT
CCertDBRow::_VerifyPropertyValue(
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN JET_COLTYP coltyp,
    IN DWORD cbMax)
{
    JET_COLTYP wType;
    HRESULT hr = E_INVALIDARG;

    switch (dwFlags & PROPTYPE_MASK)
    {
	case PROPTYPE_LONG:
	    wType = JET_coltypLong;
	    break;

	case PROPTYPE_DATE:
	    wType = JET_coltypDateTime;
	    break;

	case PROPTYPE_BINARY:
	    wType = JET_coltypLongBinary;
	    break;

	case PROPTYPE_STRING:
	    // LONG or static-sized version?

	    if (JET_coltypLongText == coltyp)
	    {
		wType = JET_coltypLongText;
		if (coltyp == wType)
		{
		    CSASSERT(CB_DBMAXTEXT_MAXINTERNAL < cbMax);
		}
	    }
	    else
	    {
		wType = JET_coltypText;
		if (coltyp == wType)
		{
		    CSASSERT(JET_coltypText == coltyp);
		    CSASSERT(CB_DBMAXTEXT_MAXINTERNAL >= cbMax);
		}
	    }
	    break;

	default:
	    _JumpError(hr, error, "Property value type unknown");
    }
    if (coltyp != wType)
    {
	_JumpError2(hr, error, "Property value type mismatch", E_INVALIDARG);
    }

    // Note: cbProp and cbMax do not include the trailing '\0'.

    if (ISTEXTCOLTYP(wType) && cbMax < cbProp)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	DBGCODE(wprintf(
		    L"_VerifyPropertyValue: len = %u, max = %u\n",
		    cbProp,
		    cbMax));
	_JumpError(hr, error, "Property value string too long");
    }
    hr = S_OK;

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::SetProperty(
    /* [in] */ WCHAR const *pwszPropName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD cbProp,
    /* [in] */ BYTE const *pbProp)	// OPTIONAL
{
    HRESULT hr;
    char *pszProp = NULL;

    if (NULL == pwszPropName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == pbProp &&
	(0 != cbProp || PROPTYPE_STRING != (dwFlags & PROPTYPE_MASK)))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL pbProp");
    }
    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "SetProperty: delete/read-only row");
    }
    CSASSERT(_VerifyPropertyLength(dwFlags, cbProp, pbProp));

    if (NULL != pbProp && PROPTYPE_STRING == (dwFlags & PROPTYPE_MASK))
    {
	cbProp = wcslen((WCHAR const *) pbProp) * sizeof(WCHAR);
    }

    hr = _SetPropertyA(pwszPropName, dwFlags, cbProp, pbProp);
    _JumpIfErrorStr(hr, error, "_SetPropertyA", pwszPropName);

error:
    if (NULL != pszProp)
    {
	LocalFree(pszProp);
    }
    return(hr);
}


HRESULT
CCertDBRow::_SetPropertyA(
    IN WCHAR const *pwszPropName,
    IN DWORD dwFlags,
    IN DWORD cbProp,
    IN BYTE const *pbProp)		// OPTIONAL
{
    HRESULT hr;
    DBTABLE dt;

    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "_SetPropertyA: delete/read-only row");
    }
    CSASSERT(NULL != pwszPropName);
    if (!_VerifyPropertyLength(dwFlags, cbProp, pbProp))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Property value length invalid");
    }

    if (PROPTABLE_ATTRIBUTE == (PROPTABLE_MASK & dwFlags))
    {
	if (PROPCALLER_POLICY == (PROPCALLER_MASK & dwFlags))
	{
	    hr = E_ACCESSDENIED;
	    _JumpError(hr, error, "Property write disallowed");
	}
	hr = _VerifyPropertyValue(
			    PROPTYPE_STRING,		// lie
			    wcslen(pwszPropName) * sizeof(WCHAR),
			    JET_coltypText,
			    CB_DBMAXTEXT_ATTRNAME);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "_VerifyPropertyValue(attribute name)",
		    pwszPropName);

	hr = _VerifyPropertyValue(
			    dwFlags,
			    cbProp,
			    JET_coltypLongText,
			    CB_DBMAXTEXT_ATTRVALUE);
	_JumpIfErrorStr(
		    hr,
		    error,
		    "_VerifyPropertyValue(attribute value)",
		    pwszPropName);

	hr = ((CCertDB *) m_pdb)->SetAttribute(
					    m_pcs,
					    pwszPropName,
					    cbProp,
					    pbProp);
	_JumpIfError(hr, error, "SetProperty");
    }
    else
    {
	hr = ((CCertDB *) m_pdb)->MapPropId(pwszPropName, dwFlags, &dt);
	_JumpIfErrorStr(hr, error, "MapPropId", pwszPropName);

	if (PROPCALLER_POLICY == (PROPCALLER_MASK & dwFlags) &&
	    0 == (DBTF_POLICYWRITEABLE & dt.dwFlags))
	{
	    hr = E_ACCESSDENIED;
	    _JumpError(hr, error, "Property write disallowed");
	}
	hr = _VerifyPropertyValue(dwFlags, cbProp, dt.dbcoltyp, dt.dwcbMax);
	_JumpIfErrorStr(hr, error, "_VerifyPropertyValue", pwszPropName);

	hr = ((CCertDB *) m_pdb)->SetProperty(m_pcs, &dt, cbProp, pbProp);
	_JumpIfError(hr, error, "SetProperty");
    }

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::SetExtension(
    /* [in] */ WCHAR const *pwszExtensionName,
    /* [in] */ DWORD dwExtFlags,
    /* [in] */ DWORD cbValue,
    /* [in] */ BYTE const *pbValue)	// OPTIONAL
{
    HRESULT hr;

    if (NULL == pwszExtensionName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "SetExtension: delete/read-only row");
    }
    hr = ((CCertDB *) m_pdb)->SetExtension(
			m_pcs,
			pwszExtensionName,
			dwExtFlags,
			cbValue,
			pbValue);
    _JumpIfErrorStr(hr, error, "SetExtension", pwszExtensionName);

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::GetExtension(
    /* [in] */ WCHAR const *pwszExtensionName,
    /* [out] */ DWORD *pdwExtFlags,
    /* [in, out] */ DWORD *pcbValue,
    /* [out] */ BYTE *pbValue)		// OPTIONAL
{
    HRESULT hr;

    if (NULL == pwszExtensionName || NULL == pcbValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    hr = ((CCertDB *) m_pdb)->GetExtension(
			m_pcs,
			pwszExtensionName,
			pdwExtFlags,
			pcbValue,
			pbValue);
    _JumpIfErrorStr2(
		hr,
		error,
		"GetExtension",
		pwszExtensionName,
		CERTSRV_E_PROPERTY_EMPTY);

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::CopyRequestNames()
{
    HRESULT hr;

    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    if ((CSF_DELETE | CSF_READONLY) & m_pcs->SesFlags)
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "CopyRequestNames: delete/read-only row");
    }
    hr = ((CCertDB *) m_pdb)->CopyRequestNames(m_pcs);
    _JumpIfError(hr, error, "CopyRequestNames");

error:
    return(hr);
}


STDMETHODIMP
CCertDBRow::EnumCertDBName(
    /* [in] */  DWORD dwFlags,
    /* [out] */ IEnumCERTDBNAME **ppenum)
{
    HRESULT hr;
    IEnumCERTDBNAME *penum = NULL;
    JET_TABLEID tableid = 0;

    if (NULL == ppenum)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppenum = NULL;
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    hr = ((CCertDB *) m_pdb)->EnumerateSetup(m_pcs, &dwFlags, &tableid);
    _JumpIfError(hr, error, "EnumerateSetup");

    penum = new CEnumCERTDBNAME;
    if (NULL == penum)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "new CEnumCERTDBNAME");
    }
    hr = ((CEnumCERTDBNAME *) penum)->Open(this, tableid, dwFlags);
    _JumpIfError(hr, error, "Open");

    *ppenum = penum;

error:
    if (S_OK != hr)
    {
	HRESULT hr2;
	
	if (0 != tableid)
	{
	    hr2 = ((CCertDB *) m_pdb)->CloseTable(m_pcs, tableid);
	    _PrintIfError(hr2, "CloseTable");
	}
	delete penum;
    }
    return(hr);
}


HRESULT
CCertDBRow::EnumerateNext(
    IN OUT DWORD      *pFlags,
    IN     JET_TABLEID tableid,
    IN     LONG        cskip,
    IN     ULONG       celt,
    OUT    CERTDBNAME *rgelt,
    OUT    ULONG      *pceltFetched)
{
    HRESULT hr;
    
    if (NULL == rgelt || NULL == pceltFetched)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL == m_pdb)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "NULL m_pdb");
    }
    if (TABLE_REQCERTS != (CSF_TABLEMASK & m_pcs->SesFlags))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad Table");
    }
    hr = ((CCertDB *) m_pdb)->EnumerateNext(
					m_pcs,
					pFlags,
					tableid,
					cskip,
					celt,
					rgelt,
					pceltFetched);
    _JumpIfError2(hr, error, "EnumerateNext", S_FALSE);

error:
    return(hr);
}


HRESULT
CCertDBRow::EnumerateClose(
    IN JET_TABLEID tableid)
{
    return(((CCertDB *) m_pdb)->EnumerateClose(m_pcs, tableid));
}


// IUnknown implementation
STDMETHODIMP
CCertDBRow::QueryInterface(
    const IID& iid,
    void **ppv)
{
    HRESULT hr;
    
    if (NULL == ppv)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (iid == IID_IUnknown)
    {
	*ppv = static_cast<ICertDBRow *>(this);
    }
    else if (iid == IID_ICertDBRow)
    {
	*ppv = static_cast<ICertDBRow *>(this);
    }
    else
    {
	*ppv = NULL;
	hr = E_NOINTERFACE;
	_JumpError(hr, error, "IID");
    }
    reinterpret_cast<IUnknown *>(*ppv)->AddRef();
    hr = S_OK;

error:
    return(hr);
}


ULONG STDMETHODCALLTYPE
CCertDBRow::AddRef()
{
    return(InterlockedIncrement(&m_cRef));
}


ULONG STDMETHODCALLTYPE
CCertDBRow::Release()
{
    ULONG cRef = InterlockedDecrement(&m_cRef);

    if (0 == cRef)
    {
	delete this;
    }
    return(cRef);
}


#if 0
STDMETHODIMP
CCertDBRow::InterfaceSupportsErrorInfo(
    IN REFIID riid)
{
    static const IID *arr[] =
    {
	&IID_ICertDBRow,
    };

    for (int i = 0; i < sizeof(arr)/sizeof(arr[0]); i++)
    {
	if (InlineIsEqualGUID(*arr[i], riid))
	{
	    return(S_OK);
	}
    }
    return(S_FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\along.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        along.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "along.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::~CCertEncodeLongArray -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeLongArray::~CCertEncodeLongArray()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeLongArray::_Cleanup()
{
    if (NULL != m_aValue)
    {
	LocalFree(m_aValue);
	m_aValue = NULL;
    }
    m_cValue = 0;
    m_cValuesSet = 0;
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::Decode -- Decode LongArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    DWORD cbSequence;
    LONG i;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode to an array of ASN blobs:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &pSequence,
		    &cbSequence))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_cValue = pSequence->cValue;
    m_aValue = (LONG *) LocalAlloc(LMEM_FIXED, m_cValue * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    for (i = 0; i < m_cValue; i++)
    {
	DWORD cb;

	// Decode each ASN blob to an integer:

	cb = sizeof(m_aValue[i]);
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pSequence->rgValue[i].pbData,
			pSequence->rgValue[i].cbData,
			0,                  // dwFlags
			(VOID *) &m_aValue[i],
			&cb))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("CryptDecodeObject", hr);
	    goto error;
	}
	assert(sizeof(m_aValue[i]) == cb);
    }

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::GetCount -- Get Array count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::GetCount(
    /* [out, retval] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pCount = m_cValue;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::GetCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::GetValue -- Fetch the indexed long
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::GetValue(
    /* [in] */ LONG Index,
    /* [out, retval] */ LONG __RPC_FAR *pValue)
{
    HRESULT hr = S_OK;
    BYTE *pb;

    if (NULL == pValue)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue || Index >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    // Bitmap only exists when constrcuting!

    if (m_fConstructing)
    {
	pb = (BYTE *) &m_aValue[m_cValue];
	if (!GETBIT(pb, Index))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    ceERRORPRINTLINE("uninitialized", hr);
	    goto error;
	}
    }
    *pValue = m_aValue[Index];

error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::GetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::Reset -- clear out data, and set up to encode new data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::Reset(
    /* [in] */ LONG Count)
{
    HRESULT hr = S_OK;
    DWORD cbAlloc;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < Count || 0 > Count)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }
    cbAlloc = Count * sizeof(m_aValue[0]) + BITSTOBYTES(Count);
    m_aValue = (LONG *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cbAlloc);
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = Count;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::SetValue -- Set an array long
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::SetValue(
    /* [in] */ LONG Index,
    /* [in] */ LONG Value)
{
    HRESULT hr = S_OK;
    BYTE *pb;

    if (!m_fConstructing ||
	NULL == m_aValue ||
	Index >= m_cValue ||
	m_cValuesSet >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    pb = (BYTE *) &m_aValue[m_cValue];
    if (GETBIT(pb, Index))
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("already set", hr);
	goto error;
    }
    SETBIT(pb, Index);
    m_aValue[Index] = Value;
    m_cValuesSet++;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::SetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::Encode -- Encode LongArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeLongArray::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    LONG i;
    CRYPT_SEQUENCE_OF_ANY Sequence;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    Sequence.cValue = 0;
    Sequence.rgValue = NULL;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (m_cValuesSet != m_cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	ceERRORPRINTLINE("m_cValuesSet", hr);
	goto error;
    }

    Sequence.rgValue = (CRYPT_DER_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    m_cValue * sizeof(Sequence.rgValue[0]));
    if (NULL == Sequence.rgValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	// Encode each integer into an ASN blob:

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			&m_aValue[i],
			0,
			FALSE,
			&Sequence.rgValue[i].pbData,
			&Sequence.rgValue[i].cbData))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceEncodeObject", hr);
	    goto error;
	}
	Sequence.cValue++;
    }
    assert((LONG) Sequence.cValue == m_cValue);

    // Encode each integer into an ASN blob:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstrBinary,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != Sequence.rgValue)
    {
	assert((LONG) Sequence.cValue <= m_cValue);
	for (i = 0; i < (LONG) Sequence.cValue; i++)
	{
	    assert(NULL != Sequence.rgValue[i].pbData);
	    LocalFree(Sequence.rgValue[i].pbData);
	}
	LocalFree(Sequence.rgValue);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeLongArray::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeLongArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeLongArray::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODELONGARRAY,
			    &IID_ICertEncodeLongArray);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\along.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       along.h
//
//--------------------------------------------------------------------------

// along.h: Declaration of the CCertEncodeLongArray


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODELONGARRAY wszCLASS_CERTENCODE TEXT("LongArray")

class CCertEncodeLongArray: 
    public IDispatchImpl<ICertEncodeLongArray, &IID_ICertEncodeLongArray, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeLongArray>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeLongArray, &CLSID_CCertEncodeLongArray>
{
public:
    CCertEncodeLongArray()
    {
	m_aValue = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeLongArray();

BEGIN_COM_MAP(CCertEncodeLongArray)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeLongArray)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeLongArray) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeLongArray,
    wszCLASS_CERTENCODELONGARRAY TEXT(".1"),
    wszCLASS_CERTENCODELONGARRAY,
    IDS_CERTENCODELONGARRAY_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeLongArray
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetCount)(
		/* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(GetValue)(
		/* [in] */ LONG Index,
		/* [out, retval] */ LONG __RPC_FAR *pValue);

    STDMETHOD(Reset)(
		/* [in] */ LONG Count);

    STDMETHOD(SetValue)(
		/* [in] */ LONG Index,
		/* [in] */ LONG Value);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    LONG  *m_aValue;
    LONG   m_cValue;
    LONG   m_cValuesSet;
    BOOL   m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\adate.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       adate.h
//
//--------------------------------------------------------------------------

// adate.h: Declaration of the CCertEncodeDateArray


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODEDATEARRAY wszCLASS_CERTENCODE TEXT("DateArray")

class CCertEncodeDateArray: 
    public IDispatchImpl<ICertEncodeDateArray, &IID_ICertEncodeDateArray, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeDateArray>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeDateArray, &CLSID_CCertEncodeDateArray>
{
public:
    CCertEncodeDateArray()
    {
	m_aValue = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeDateArray();

BEGIN_COM_MAP(CCertEncodeDateArray)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeDateArray)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeDateArray) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeDateArray,
    wszCLASS_CERTENCODEDATEARRAY TEXT(".1"),
    wszCLASS_CERTENCODEDATEARRAY,
    IDS_CERTENCODEDATEARRAY_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeDateArray
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetCount)(
		/* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(GetValue)(
		/* [in] */ LONG Index,
		/* [out, retval] */ DATE __RPC_FAR *pValue);

    STDMETHOD(Reset)(
		/* [in] */ LONG Count);

    STDMETHOD(SetValue)(
		/* [in] */ LONG Index,
		/* [in] */ DATE Value);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    DATE  *m_aValue;
    LONG   m_cValue;
    LONG   m_cValuesSet;
    BOOL   m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\altname.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crldist.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "altname.h"
#include "celib.h"

#ifndef EAN_NAMEOBJECTID
#define EAN_NAMEOBJECTID        ( 0x80000000 )
#endif EAN_NAMEOBJECTID


//+--------------------------------------------------------------------------
// CCertEncodeAltName::CCertEncodeAltName -- constructor
//
// initialize class
//+--------------------------------------------------------------------------

CCertEncodeAltName::CCertEncodeAltName()
{
    m_aValue = NULL;
    m_DecodeInfo = NULL;
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::~CCertEncodeAltName -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeAltName::~CCertEncodeAltName()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_NameType -- determine name type tag
//
//+--------------------------------------------------------------------------

CCertEncodeAltName::enumNameType
CCertEncodeAltName::_NameType(
    IN DWORD NameChoice)
{
    enumNameType Type = enumUnknown;

    switch (NameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	case CERT_ALT_NAME_DNS_NAME:
	case CERT_ALT_NAME_URL:
	    Type = enumUnicode;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    Type = enumAnsi;
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	case CERT_ALT_NAME_IP_ADDRESS:
	    Type = enumBlob;
	    break;

	case CERT_ALT_NAME_OTHER_NAME:
	    Type = enumOther;
	    break;

	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
    }
    return(Type);
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeAltName::_Cleanup()
{
    if (NULL != m_aValue)
    {
	if (!m_fConstructing)
	{
	    if (NULL != m_DecodeInfo)
	    {
		LocalFree(m_DecodeInfo);
		m_DecodeInfo = NULL;
	    }
	}
	else
	{
	    CERT_ALT_NAME_ENTRY *pName;
	    CERT_ALT_NAME_ENTRY *pNameEnd;

	    for (pName = m_aValue, pNameEnd = &m_aValue[m_cValue];
		 pName < pNameEnd;
		 pName++)
	    {
		BYTE **ppb;

		ppb = NULL;

		switch (_NameType(pName->dwAltNameChoice))
		{
		    case enumUnicode:
		    case enumAnsi:
			ppb = (BYTE **) &pName->pwszURL;
			break;

		    case enumBlob:
			ppb = (BYTE **) &pName->DirectoryName.pbData;
			break;

		    case enumOther:
		    {
			CERT_OTHER_NAME *pOther = pName->pOtherName;
			if (NULL != pOther)
			{
			    if (NULL != pOther->pszObjId)
			    {
				LocalFree(pOther->pszObjId);
			    }
			    if (NULL != pOther->Value.pbData)
			    {
				LocalFree(pOther->Value.pbData);
			    }
			}
			ppb = (BYTE **) &pName->pOtherName;
			break;
		    }
		}
		if (NULL != ppb && NULL != *ppb)
		{
		    LocalFree(*ppb);
		}
	    }
	    LocalFree(m_aValue);
	}
	m_aValue = NULL;
    }
    assert(NULL == m_DecodeInfo);
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_MapName -- map a distribution point
//
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeAltName::_MapName(
    IN BOOL fEncode,
    IN LONG NameIndex,			// NameIndex | EAN_*
    OUT CERT_ALT_NAME_ENTRY **ppName)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_ENTRY *pName;

    if (fEncode)
    {
	pName = m_fConstructing? m_aValue : NULL;
    }
    else
    {
	pName = m_aValue;
    }

    if (NULL == pName)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    NameIndex &= ~EAN_NAMEOBJECTID;
    if (m_cValue <= NameIndex)
    {
	ceERRORPRINTLINE("bad NameIndex parameter", hr);
	hr = E_INVALIDARG;
	goto error;
    }
    *ppName = &pName[NameIndex];

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::Decode -- Decode AltName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode CERT_ALT_NAME_INFO:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &m_DecodeInfo,
		    &m_DecodeLength))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_aValue = m_DecodeInfo->rgAltEntry;
    m_cValue = m_DecodeInfo->cAltEntry;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::GetNameCount -- Get the Distribution Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::GetNameCount(
    /* [out, retval] */ LONG __RPC_FAR *pNameCount)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pNameCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pNameCount = m_cValue;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::GetNameCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::GetNameChoice -- Get a Name Choice
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::GetNameChoice(
    /* [in] */ LONG NameIndex,
    /* [out, retval] */ LONG __RPC_FAR *pNameChoice)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;

    if (NULL == pNameChoice)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    hr = _MapName(FALSE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }
    if (enumUnknown == _NameType(pName->dwAltNameChoice))
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    *pNameChoice = pName->dwAltNameChoice;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::GetNameChoice"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::GetName -- Get a Name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::GetName(
    /* [in] */ LONG NameIndex,			// NameIndex | EAN_*
    /* [out, retval] */ BSTR __RPC_FAR *pstrName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;

    if (NULL == pstrName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrName);
    hr = _MapName(FALSE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    hr = E_OUTOFMEMORY;
    switch (_NameType(pName->dwAltNameChoice))
    {
	case enumUnicode:
	    if (!ceConvertWszToBstr(pstrName, pName->pwszURL, -1))
	    {
		ceERRORPRINTLINE("no memory", hr);
		goto error;
	    }
	    break;

	case enumAnsi:
	    if (!ceConvertSzToBstr(pstrName, pName->pszRegisteredID, -1))
	    {
		ceERRORPRINTLINE("no memory", hr);
		goto error;
	    }
	    break;

	case enumBlob:
	    if (!ceConvertWszToBstr(
				pstrName,
				(WCHAR const *) pName->DirectoryName.pbData,
				pName->DirectoryName.cbData))
	    {
		ceERRORPRINTLINE("no memory", hr);
		goto error;
	    }
	    break;

	case enumOther:
	    if (EAN_NAMEOBJECTID & NameIndex)
	    {
		if (!ceConvertSzToBstr(
				pstrName,
				pName->pOtherName->pszObjId,
				-1))
		{
		    ceERRORPRINTLINE("no memory", hr);
		    goto error;
		}
	    }
	    else
	    {
		if (!ceConvertWszToBstr(
				pstrName,
				(WCHAR const *) pName->pOtherName->Value.pbData,
				pName->pOtherName->Value.cbData))
		{
		    ceERRORPRINTLINE("no memory", hr);
		    goto error;
		}
	    }
	    break;

	default:
	    assert(enumUnknown == _NameType(pName->dwAltNameChoice));
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    ceERRORPRINTLINE("uninitialized", hr);
	    goto error;
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::GetName"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::Reset -- clear out data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::Reset(
    /* [in] */ LONG NameCount)
{
    HRESULT hr = S_OK;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < NameCount || 0 > NameCount)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    m_aValue = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				NameCount * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = NameCount;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::SetNameEntry -- Set a Name Netry
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::SetNameEntry(
    /* [in] */ LONG NameIndex,			// NameIndex | EAN_*
    /* [in] */ LONG NameChoice,
    /* [in] */ BSTR const strName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;
    DATA_BLOB *pBlob = NULL;
    CCertEncodeAltName::enumNameType enumT;

    if (NULL == strName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (!m_fConstructing)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = _MapName(TRUE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    enumT = enumUnknown;
    if (CERT_ALT_NAME_OTHER_NAME == pName->dwAltNameChoice &&
	0 == (EAN_NAMEOBJECTID & NameIndex))
    {
	enumT = enumOther;
    }
    if (_NameType(pName->dwAltNameChoice) != enumT)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (CERT_ALT_NAME_OTHER_NAME != pName->dwAltNameChoice ||
	0 == (EAN_NAMEOBJECTID & NameIndex))
    {
	hr = ceVerifyAltNameString(NameChoice, strName);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceVerifyAltNameString", hr);
	    goto error;
	}
    }

    switch (_NameType(NameChoice))
    {
	case enumUnicode:
	    pName->pwszURL = ceDuplicateString(strName);
	    if (NULL == pName->pwszURL)
	    {
		hr = E_OUTOFMEMORY;
		ceERRORPRINTLINE("ceDuplicateString", hr);
		goto error;
	    }
	    break;

	case enumAnsi:
	    if (CERT_ALT_NAME_REGISTERED_ID == NameChoice)
	    {
		hr = ceVerifyObjId(strName);
		if (S_OK != hr)
		{
		    ceERRORPRINTLINE("ceVerifyObjId", hr);
		    goto error;
		}
	    }
	    if (!ceConvertWszToSz(&pName->pszRegisteredID, strName, -1))
	    {
		hr = E_OUTOFMEMORY;
		ceERRORPRINTLINE("ceConvertWszToSz", hr);
		goto error;
	    }
	    break;

	case enumBlob:
	    pBlob = &pName->DirectoryName;
	    break;

	case enumOther:
	    if (NULL == pName->pOtherName)
	    {
		pName->pOtherName = (CERT_OTHER_NAME *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(*pName->pOtherName));
		if (NULL == pName->pOtherName)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
	    }
	    else if (CERT_ALT_NAME_OTHER_NAME != pName->dwAltNameChoice)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "NameChoice conflict");
	    }
	    if (EAN_NAMEOBJECTID & NameIndex)
	    {
		if (NULL != pName->pOtherName->pszObjId)
		{
		    hr = E_INVALIDARG;
		    _JumpError(hr, error, "pszObjId already set");
		}
		hr = ceVerifyObjId(strName);
		if (S_OK != hr)
		{
		    ceERRORPRINTLINE("ceVerifyObjId", hr);
		    goto error;
		}
		if (!ceConvertWszToSz(&pName->pOtherName->pszObjId, strName, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ceConvertWszToSz");
		}
	    }
	    else
	    {
		pBlob = &pName->pOtherName->Value;
	    }
	    break;

	default:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("bad NameChoice parameter", hr);
	    goto error;
	    break;
    }

    if (NULL != pBlob)
    {
	if (NULL != pBlob->pbData)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "pbData already set");
	}
	pBlob->cbData = SysStringByteLen(strName);
	pBlob->pbData = (BYTE *) LocalAlloc(LMEM_FIXED, pBlob->cbData);
	if (NULL == pBlob->pbData)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pBlob->pbData, strName, pBlob->cbData);
    }
    pName->dwAltNameChoice = NameChoice;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::SetNameEntry"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_VerifyName -- Verify name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

BOOL
CCertEncodeAltName::_VerifyName(
    IN LONG NameIndex)
{
    HRESULT hr;
    BOOL fOk = FALSE;
    CERT_ALT_NAME_ENTRY *pName;

    assert(m_fConstructing);

    hr = _MapName(TRUE, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }
    assert(NULL != pName);
    switch (_NameType(pName->dwAltNameChoice))
    {
	case enumOther:
	    if (NULL != pName->pOtherName &&
		NULL != pName->pOtherName->pszObjId &&
		NULL != pName->pOtherName->Value.pbData)
	    {
		break;
	    }
	    // FALLTHROUGH

	case enumUnknown:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("uninitialized name", hr);
	    goto error;
    }
    fOk = TRUE;

error:
    return(fOk);
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::Encode -- Encode AltName
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeAltName::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_INFO AltName;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    LONG i;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    AltName.cAltEntry = m_cValue;
    AltName.rgAltEntry = m_aValue;

    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	// Verify all entries are initialized:

	if (!_VerifyName(i))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    ceERRORPRINTLINE("uninitialized name", hr);
	    goto error;
	}
    }

    // Encode CERT_ALT_NAME_INFO:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(pstrBinary, (WCHAR const *) pbEncoded, cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeAltName::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeAltName::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeAltName::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODEALTNAME,
			    &IID_ICertEncodeAltName);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\bitstr.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crldist.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "bitstr.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeBitString::~CCertEncodeBitString -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeBitString::~CCertEncodeBitString()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeBitString::_Cleanup()
{
    if (NULL != m_DecodeInfo)
    {
	LocalFree(m_DecodeInfo);
	m_DecodeInfo = NULL;
    }
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::Decode -- Decode BitString
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    DWORD cbBitString;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode CRYPT_BIT_BLOB:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_BITS,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &m_DecodeInfo,
		    &cbBitString))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::GetBitCount -- Get the Distribution Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::GetBitCount(
    /* [out, retval] */ LONG __RPC_FAR *pBitCount)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pBitCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_DecodeInfo)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pBitCount = m_DecodeInfo->cbData * 8 - m_DecodeInfo->cUnusedBits;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::GetBitCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::GetBitString -- Get the bits
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::GetBitString(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBitString)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pstrBitString)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBitString);

    if (NULL == m_DecodeInfo)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = E_OUTOFMEMORY;
    if (!ceConvertWszToBstr(
			pstrBitString,
			(WCHAR const *) m_DecodeInfo->pbData,
			m_DecodeInfo->cbData))
    {
	ceERRORPRINTLINE("no memory", hr);
	goto error;
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::GetBitString"));
}


//+--------------------------------------------------------------------------
// CCertEncodeBitString::Encode -- Encode BitString
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeBitString::Encode(
    /* [in] */ LONG BitCount,
    /* [in] */ BSTR strBitString,
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    CRYPT_BIT_BLOB BitString;
    LONG cbData;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    if (NULL != pstrBinary)
    {
	ceFreeBstr(pstrBinary);
    }
    if (NULL == strBitString || NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (CENCODEMAX < BitCount || 0 > BitCount)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    cbData = SysStringByteLen(strBitString);
    if (BitCount > cbData * 8 || BitCount <= (cbData - 1) * 8)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad BitCount parameter", hr);
	goto error;
    }
    BitString.cbData = cbData;
    BitString.pbData = (BYTE *) strBitString;
    BitString.cUnusedBits = cbData * 8 - BitCount;

    // Encode CRYPT_BIT_BLOB:
    // If cUnusedBits is 0, encode as X509_KEY_USAGE to ensure that trailing
    // zero bytes are stripped, and trailing zero bits in the last byte are
    // counted and that count is encoded into the CRYPT_BIT_BLOB.

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    0 == BitString.cUnusedBits? X509_KEY_USAGE : X509_BITS,
		    &BitString,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(pstrBinary, (WCHAR const *) pbEncoded, cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeBitString::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeBitString::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODEBITSTRING,
			    &IID_ICertEncodeBitString);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\bitstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bitstr.h
//
//--------------------------------------------------------------------------

// bitstr.h: Declaration of the CCertEncodeBitString


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODEBITSTRING wszCLASS_CERTENCODE TEXT("BitString")

class CCertEncodeBitString: 
    public IDispatchImpl<ICertEncodeBitString, &IID_ICertEncodeBitString, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeBitString>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeBitString, &CLSID_CCertEncodeBitString>
{
public:
    CCertEncodeBitString()
    {
	m_DecodeInfo = NULL;
    }
    ~CCertEncodeBitString();

BEGIN_COM_MAP(CCertEncodeBitString)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeBitString)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeBitString) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeBitString,
    wszCLASS_CERTENCODEBITSTRING TEXT(".1"),
    wszCLASS_CERTENCODEBITSTRING,
    IDS_CERTENCODEBITSTRING_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeBitString
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetBitCount)(
		/* [out, retval] */ LONG __RPC_FAR *pBitCount);

    STDMETHOD(GetBitString)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrBitString);

    STDMETHOD(Encode)(
		/* [in] */ LONG BitCount,
		/* [in] */ BSTR strBitString,
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    LONG		 m_cBits;
    CRYPT_BIT_BLOB	*m_DecodeInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\altname.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       altname.h
//
//--------------------------------------------------------------------------

// altname.h: Declaration of the CCertEncodeAltName


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODEALTNAME wszCLASS_CERTENCODE TEXT("AltName")

class CCertEncodeAltName: 
    public IDispatchImpl<ICertEncodeAltName, &IID_ICertEncodeAltName, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeAltName>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeAltName, &CLSID_CCertEncodeAltName>
{
public:
    CCertEncodeAltName();
    ~CCertEncodeAltName();

BEGIN_COM_MAP(CCertEncodeAltName)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeAltName)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeAltName) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeAltName,
    wszCLASS_CERTENCODEALTNAME TEXT(".1"),
    wszCLASS_CERTENCODEALTNAME,
    IDS_CERTENCODEALTNAME_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeAltName
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetNameCount)(
		/* [out, retval] */ LONG __RPC_FAR *pNameCount);

    STDMETHOD(GetNameChoice)(
		/* [in] */ LONG NameIndex,
		/* [out, retval] */ LONG __RPC_FAR *pNameChoice);

    STDMETHOD(GetName)(
		/* [in] */ LONG NameIndex,		// NameIndex | EAN_*
		/* [out, retval] */ BSTR __RPC_FAR *pstrName);

    STDMETHOD(Reset)(
		/* [in] */ LONG NameCount);

    STDMETHOD(SetNameEntry)(
		/* [in] */ LONG NameIndex,		// NameIndex | EAN_*
		/* [in] */ LONG NameChoice,
		/* [in] */ BSTR const strName);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    BOOL _VerifyName(
		IN LONG NameIndex);

    HRESULT _MapName(
		IN BOOL fEncode,
		IN LONG NameIndex,
		OUT CERT_ALT_NAME_ENTRY **ppName);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    typedef enum _enumNameType {
	enumUnknown = 0,
	enumUnicode,
	enumAnsi,
	enumBlob,
	enumOther,
    } enumNameType;

    enumNameType _NameType(
		IN DWORD NameChoice);

    CERT_ALT_NAME_ENTRY	*m_aValue;
    LONG		 m_cValue;
    CERT_ALT_NAME_INFO	*m_DecodeInfo;
    DWORD		 m_DecodeLength;
    BOOL		 m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\atl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        atl.cpp
//
// Contents:    ActiveX Template Library COM support
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\astring.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       astring.h
//
//--------------------------------------------------------------------------

// astring.h: Declaration of the CCertEncodeStringArray


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODESTRINGARRAY wszCLASS_CERTENCODE TEXT("StringArray")

class CCertEncodeStringArray: 
    public IDispatchImpl<ICertEncodeStringArray, &IID_ICertEncodeStringArray, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeStringArray>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeStringArray, &CLSID_CCertEncodeStringArray>
{
public:
    CCertEncodeStringArray()
    {
	m_aValue = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeStringArray();

BEGIN_COM_MAP(CCertEncodeStringArray)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeStringArray)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeStringArray) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeStringArray,
    wszCLASS_CERTENCODESTRINGARRAY TEXT(".1"),
    wszCLASS_CERTENCODESTRINGARRAY,
    IDS_CERTENCODESTRINGARRAY_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeStringArray
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetStringType)(
		/* [out, retval] */ LONG __RPC_FAR *pStringType);

    STDMETHOD(GetCount)(
		/* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(GetValue)(
		/* [in] */ LONG Index,
		/* [out, retval] */ BSTR __RPC_FAR *pstr);

    STDMETHOD(Reset)(
		/* [in] */ LONG Count,
		/* [in] */ LONG StringType);

    STDMETHOD(SetValue)(
		/* [in] */ LONG Index,
		/* [in] */ BSTR const str);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    CERT_NAME_VALUE **m_aValue;
    LONG	      m_cValue;
    LONG	      m_cValuesSet;
    BOOL	      m_fConstructing;
    LONG	      m_StringType;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\certenc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certenc.cpp
//
// Contents:    Cert Server encode/decode support
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "celib.h"
#include "resource.h"
#include "certenc.h"
#include "adate.h"
#include "along.h"
#include "astring.h"
#include "crldist.h"
#include "altname.h"
#include "bitstr.h"

CComModule _Module;
HMODULE g_hModule;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertEncodeDateArray, CCertEncodeDateArray)
    OBJECT_ENTRY(CLSID_CCertEncodeLongArray, CCertEncodeLongArray)
    OBJECT_ENTRY(CLSID_CCertEncodeStringArray, CCertEncodeStringArray)
    OBJECT_ENTRY(CLSID_CCertEncodeCRLDistInfo, CCertEncodeCRLDistInfo)
    OBJECT_ENTRY(CLSID_CCertEncodeAltName, CCertEncodeAltName)
    OBJECT_ENTRY(CLSID_CCertEncodeBitString, CCertEncodeBitString)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    VOID * /* lpReserved */ )
{
    g_hModule = hInstance;
    if (DLL_PROCESS_ATTACH == dwReason)
    {
	ceInitErrorMessageText(
			hInstance,
			IDS_E_UNEXPECTED,
			IDS_UNKNOWN_ERROR_CODE);
	_Module.Init(ObjectMap, hInstance);
	DisableThreadLibraryCalls(hInstance);
    }
    if (DLL_PROCESS_DETACH == dwReason)
    {
	_Module.Term();
    }
    return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(VOID)
{
    HRESULT hr;

    hr = 0 == _Module.GetLockCount()? S_OK : S_FALSE;
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    hr = _Module.GetClassObject(rclsid, riid, ppv);
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(VOID)
{
    HRESULT hr;

    // registers object, typelib and all interfaces in typelib

    hr = _Module.RegisterServer(TRUE);
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(VOID)
{
    _Module.UnregisterServer();
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\astring.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        astring.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "astring.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::~CCertEncodeStringArray -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeStringArray::~CCertEncodeStringArray()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeStringArray::_Cleanup()
{
    LONG i;

    if (NULL != m_aValue)
    {
	for (i = 0; i < m_cValue; i++)
	{
	    CERT_NAME_VALUE *pNameValue;

	    pNameValue = m_aValue[i];
	    assert(NULL != pNameValue);
	    if (m_fConstructing)
	    {
		if (NULL != pNameValue->Value.pbData)
		{
		    LocalFree(pNameValue->Value.pbData);
		}
	    }
	    else
	    {
		LocalFree(pNameValue);
	    }
	}
	if (m_fConstructing && NULL != m_aValue[0])
	{
	    LocalFree(m_aValue[0]);
	}
	LocalFree(m_aValue);
	m_aValue = NULL;
    }
    m_cValue = 0;
    m_cValuesSet = 0;
    m_fConstructing = FALSE;
    m_StringType = CERT_RDN_IA5_STRING;
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::Decode -- Decode StringArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    CRYPT_SEQUENCE_OF_ANY *pSequence = NULL;
    DWORD cbSequence;
    LONG i;

    _Cleanup();

    if (NULL == strBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode to an array of ASN blobs:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &pSequence,
		    &cbSequence))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_aValue = (CERT_NAME_VALUE **) LocalAlloc(
				LMEM_FIXED,
				pSequence->cValue * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    for (i = 0; i < (LONG) pSequence->cValue; i++)
    {
	DWORD cb;

	// Decode each ASN blob to a name value (string blob + encoding type):

	if (!ceDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pSequence->rgValue[i].pbData,
			pSequence->rgValue[i].cbData,
			FALSE,
			(VOID **) &m_aValue[i],
			&cb))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceDecodeObject", hr);
	    goto error;
	}
	if (0 == i)
	{
	    m_StringType = m_aValue[i]->dwValueType;
	}
	else
	{
	    if (m_StringType != (LONG) m_aValue[i]->dwValueType)
	    {
		ceERRORPRINTLINE("dwValueType mismatch", hr);
	    }
	}
	m_cValue++;
    }
    assert((LONG) pSequence->cValue == m_cValue);

error:
    if (NULL != pSequence)
    {
	LocalFree(pSequence);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::GetStringType -- Get string type
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::GetStringType(
    /* [out, retval] */ LONG __RPC_FAR *pStringType)
{
    HRESULT hr = S_OK;

    if (NULL == pStringType)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pStringType = m_StringType;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::GetStringType"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::GetCount -- Get Array count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::GetCount(
    /* [out, retval] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    *pCount = m_cValue;
error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::GetCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::GetValue -- Fetch the indexed string
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::GetValue(
    /* [in] */ LONG Index,
    /* [out, retval] */ BSTR __RPC_FAR *pstr)
{
    HRESULT hr = S_OK;

    if (NULL == pstr)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstr);
    if (NULL == m_aValue || Index >= m_cValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (NULL == m_aValue[Index]->Value.pbData)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstr,
			(WCHAR const *) m_aValue[Index]->Value.pbData,
			-1))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }
error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::GetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::Reset -- clear out data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::Reset(
    /* [in] */ LONG Count,
    /* [in] */ LONG StringType)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE *aNameValue = NULL;
    LONG i;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < Count || 0 > Count)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    switch (StringType)
    {
	case CERT_RDN_ANY_TYPE:
	//case CERT_RDN_ENCODED_BLOB:
	//case CERT_RDN_OCTET_STRING:
	case CERT_RDN_NUMERIC_STRING:
	case CERT_RDN_PRINTABLE_STRING:
	//case CERT_RDN_TELETEX_STRING: same as CERT_RDN_T61_STRING:
	case CERT_RDN_T61_STRING:
	case CERT_RDN_VIDEOTEX_STRING:
	case CERT_RDN_IA5_STRING:
	case CERT_RDN_GRAPHIC_STRING:
	//case CERT_RDN_VISIBLE_STRING: same as CERT_RDN_ISO646_STRING:
	case CERT_RDN_ISO646_STRING:
	case CERT_RDN_GENERAL_STRING:
	//case CERT_RDN_UNIVERSAL_STRING: same as CERT_RDN_INT4_STRING:
	case CERT_RDN_INT4_STRING:
	//case CERT_RDN_BMP_STRING: same as case CERT_RDN_UNICODE_STRING:
	case CERT_RDN_UNICODE_STRING:
	    break;

	default:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("bad parameter", hr);
	    goto error;
    }
    m_StringType = StringType;

    aNameValue = (CERT_NAME_VALUE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				Count * sizeof(*m_aValue[0]));
    if (NULL == aNameValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    m_aValue = (CERT_NAME_VALUE **) LocalAlloc(
				LMEM_FIXED,
				Count * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    m_cValue = Count;
    for (i = 0; i < Count; i++)
    {
	m_aValue[i] = &aNameValue[i];
    }
    aNameValue = NULL;

error:
    if (NULL != aNameValue)
    {
	LocalFree(aNameValue);
    }
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::SetValue -- Set an array string
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::SetValue(
    /* [in] */ LONG Index,
    /* [in] */ BSTR const str)
{
    HRESULT hr = S_OK;
    WCHAR *pwsz;

    if (NULL == str)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (!m_fConstructing ||
	NULL == m_aValue ||
	Index >= m_cValue ||
	m_cValuesSet >= m_cValue ||
	NULL != m_aValue[Index]->Value.pbData)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    pwsz = ceDuplicateString(str);
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceDuplicateString", hr);
	goto error;
    }
    m_aValue[Index]->dwValueType = m_StringType;
    m_aValue[Index]->Value.pbData = (BYTE *) pwsz;
    m_aValue[Index]->Value.cbData = 0;
    m_cValuesSet++;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::SetValue"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::Encode -- Encode StringArray
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeStringArray::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    LONG i;
    CRYPT_SEQUENCE_OF_ANY Sequence;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;

    Sequence.cValue = 0;
    Sequence.rgValue = NULL;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (m_cValuesSet != m_cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	ceERRORPRINTLINE("uninitialized values", hr);
	goto error;
    }

    Sequence.rgValue = (CRYPT_DER_BLOB *) LocalAlloc(
				    LMEM_FIXED,
				    m_cValue * sizeof(Sequence.rgValue[0]));
    if (NULL == Sequence.rgValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	// Encode each name blob into an ASN blob:

	if (!ceEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			m_aValue[i],
			0,
			FALSE,
			&Sequence.rgValue[i].pbData,
			&Sequence.rgValue[i].cbData))
	{
	    hr = ceHLastError();
	    ceERRORPRINTLINE("ceEncodeObject", hr);
	    goto error;
	}
	Sequence.cValue++;
    }
    assert((LONG) Sequence.cValue == m_cValue);

    // Encode the array of ASN blob:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    &Sequence,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(
			pstrBinary,
			(WCHAR const *) pbEncoded,
			cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    if (NULL != Sequence.rgValue)
    {
	assert((LONG) Sequence.cValue <= m_cValue);
	for (i = 0; i < (LONG) Sequence.cValue; i++)
	{
	    assert(NULL != Sequence.rgValue[i].pbData);
	    LocalFree(Sequence.rgValue[i].pbData);
	}
	LocalFree(Sequence.rgValue);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeStringArray::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeStringArray::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeStringArray::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODESTRINGARRAY,
			    &IID_ICertEncodeStringArray);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
//---------------------------------------------------------------------------

#include <windows.h>

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>
#include <certsrv.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:    ..\idl\com\$(O)\$(TARGETNAME).tlb

SOURCE_DIR=..\celib

$(NTTARGETFILE0):	$(SOURCE_DIR)\$(@F)
    copy $(SOURCE_DIR)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\crldist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crldist.h
//
//--------------------------------------------------------------------------

// crldist.h: Declaration of the CCertEncodeCRLDistInfo


#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certenc

#define wszCLASS_CERTENCODECRLDISTINFO wszCLASS_CERTENCODE TEXT("CRLDistInfo")

class CCertEncodeCRLDistInfo: 
    public IDispatchImpl<ICertEncodeCRLDistInfo, &IID_ICertEncodeCRLDistInfo, &LIBID_CERTENCODELib>, 
    public ISupportErrorInfoImpl<&IID_ICertEncodeCRLDistInfo>,
    public CComObjectRoot,
    public CComCoClass<CCertEncodeCRLDistInfo, &CLSID_CCertEncodeCRLDistInfo>
{
public:
    CCertEncodeCRLDistInfo()
    {
	m_aValue = NULL;
	m_DecodeInfo = NULL;
	m_fConstructing = FALSE;
    }
    ~CCertEncodeCRLDistInfo();

BEGIN_COM_MAP(CCertEncodeCRLDistInfo)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertEncodeCRLDistInfo)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertEncodeCRLDistInfo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertEncodeCRLDistInfo,
    wszCLASS_CERTENCODECRLDISTINFO TEXT(".1"),
    wszCLASS_CERTENCODECRLDISTINFO,
    IDS_CERTENCODECRLDIST_DESC,
    THREADFLAGS_BOTH)

// ICertEncodeCRLDistInfo
public:
    STDMETHOD(Decode)(
		/* [in] */ BSTR const strBinary);

    STDMETHOD(GetDistPointCount)(
		/* [out, retval] */ LONG __RPC_FAR *pDistPointCount);

    STDMETHOD(GetNameCount)(
		/* [in] */ LONG DistPointIndex,
		/* [out, retval] */ LONG __RPC_FAR *pNameCount);

    STDMETHOD(GetNameChoice)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameIndex,
		/* [out, retval] */ LONG __RPC_FAR *pNameChoice);

    STDMETHOD(GetName)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameIndex,
		/* [out, retval] */ BSTR __RPC_FAR *pstrName);

    STDMETHOD(Reset)(
		/* [in] */ LONG DistPointCount);

    STDMETHOD(SetNameCount)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameCount);

    STDMETHOD(SetNameEntry)(
		/* [in] */ LONG DistPointIndex,
		/* [in] */ LONG NameIndex,
		/* [in] */ LONG NameChoice,
		/* [in] */ BSTR const strName);

    STDMETHOD(Encode)(
		/* [out, retval] */ BSTR *pstrBinary);
private:
    VOID _Cleanup(VOID);

    BOOL _VerifyNames(
		IN LONG DistPointIndex);

    HRESULT _MapDistPoint(
		IN BOOL fEncode,
		IN LONG DistPointIndex,
		OUT LONG **ppNameCount,
		OUT CERT_ALT_NAME_ENTRY ***ppaName);

    HRESULT _MapName(
		IN BOOL fEncode,
		IN LONG DistPointIndex,
		IN LONG NameIndex,
		OUT CERT_ALT_NAME_ENTRY **ppName);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    CRL_DIST_POINT	 *m_aValue;
    LONG		  m_cValue;
    CRL_DIST_POINTS_INFO *m_DecodeInfo;
    BOOL		  m_fConstructing;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\certif.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       certif.cpp
//
//--------------------------------------------------------------------------

// CertIF.cpp : Implementation of DLL Exports.

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "ciinit.h"


SERVERCALLBACKS ServerCallBacks;

extern "C" HRESULT WINAPI
CertificateInterfaceInit(
    IN SERVERCALLBACKS const *psb,
    IN DWORD cbsb)
{
    if (sizeof(ServerCallBacks) != cbsb)
    {
	return(HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }
    ServerCallBacks = *psb;
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\crldist.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crldist.cpp
//
// Contents:    Cert Server Extension Encoding/Decoding implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include "resource.h"
#include "crldist.h"
#include "celib.h"


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::~CCertEncodeCRLDistInfo -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertEncodeCRLDistInfo::~CCertEncodeCRLDistInfo()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_Cleanup -- release all resources
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertEncodeCRLDistInfo::_Cleanup()
{
    if (NULL != m_aValue)
    {
	if (!m_fConstructing)
	{
	    if (NULL != m_DecodeInfo)
	    {
		LocalFree(m_DecodeInfo);
		m_DecodeInfo = NULL;
	    }
	}
	else
	{
	    CRL_DIST_POINT *pDistPoint;
	    CRL_DIST_POINT *pDistPointEnd;

	    for (pDistPoint = m_aValue, pDistPointEnd = &m_aValue[m_cValue];
		 pDistPoint < pDistPointEnd;
		 pDistPoint++)
	    {
		CERT_ALT_NAME_ENTRY *pName;
		CERT_ALT_NAME_ENTRY *pNameEnd;

		pName = pDistPoint->DistPointName.FullName.rgAltEntry;
		if (NULL != pName)
		{
		    for (pNameEnd = &pName[pDistPoint->DistPointName.FullName.cAltEntry];
			 pName < pNameEnd;
			 pName++)
		    {
			if (NULL != pName->pwszURL) // test arbitrary union arm
			{
			    LocalFree(pName->pwszURL);
			}
		    }
		    LocalFree(pDistPoint->DistPointName.FullName.rgAltEntry);
		}
	    }
	    LocalFree(m_aValue);
	}
	m_aValue = NULL;
    }
    assert(NULL == m_DecodeInfo);
    m_fConstructing = FALSE;
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_MapDistPoint -- map a distribution point
//
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeCRLDistInfo::_MapDistPoint(
    IN BOOL fEncode,
    IN LONG DistPointIndex,
    OUT LONG **ppNameCount,
    OUT CERT_ALT_NAME_ENTRY ***ppaName)
{
    HRESULT hr = S_OK;
    CRL_DIST_POINT *pDistPoint;

    if (fEncode)
    {
	pDistPoint = m_fConstructing? m_aValue : NULL;
    }
    else
    {
	pDistPoint = m_aValue;
    }

    if (NULL == pDistPoint)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    if (m_cValue <= DistPointIndex)
    {
	ceERRORPRINTLINE("bad DistPointIndex parameter", hr);
	hr = E_INVALIDARG;
	goto error;
    }
    *ppNameCount =
	(LONG *) &pDistPoint[DistPointIndex].DistPointName.FullName.cAltEntry;
    *ppaName = &pDistPoint[DistPointIndex].DistPointName.FullName.rgAltEntry;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_MapName -- map a name
//
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeCRLDistInfo::_MapName(
    IN BOOL fEncode,
    IN LONG DistPointIndex,
    IN LONG NameIndex,
    OUT CERT_ALT_NAME_ENTRY **ppName)
{
    HRESULT hr;
    LONG *pNameCount;
    CERT_ALT_NAME_ENTRY **paName;

    if (NULL == ppName)
    {
	hr = E_POINTER;
        ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    hr = _MapDistPoint(fEncode, DistPointIndex, &pNameCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    if (*pNameCount <= NameIndex)
    {
	ceERRORPRINTLINE("bad NameIndex parameter", hr);
	hr = E_INVALIDARG;
	goto error;
    }
    *ppName = &(*paName)[NameIndex];

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::Decode -- Decode CRLDistInfo
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::Decode(
    /* [in] */ BSTR const strBinary)
{
    HRESULT hr = S_OK;
    DWORD cbCRLDist;

    _Cleanup();

    if (NULL == strBinary)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    // Decode CRL_DIST_POINTS_INFO:

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    (BYTE *) strBinary,
		    SysStringByteLen(strBinary),
		    FALSE,
		    (VOID **) &m_DecodeInfo,
		    &cbCRLDist))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceDecodeObject", hr);
	goto error;
    }

    m_aValue = m_DecodeInfo->rgDistPoint;
    m_cValue = m_DecodeInfo->cDistPoint;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::Decode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetDistPointCount -- Get the Distribution Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetDistPointCount(
    /* [out, retval] */ LONG __RPC_FAR *pDistPointCount)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == m_aValue)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    if (NULL == pDistPointCount)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    *pDistPointCount = m_cValue;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetDistPointCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetNameCount -- Get a Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetNameCount(
    /* [in] */ LONG DistPointIndex,
    /* [out, retval] */ LONG __RPC_FAR *pNameCount)
{
    HRESULT hr;
    LONG *pCount;
    CERT_ALT_NAME_ENTRY **paName;

    if (NULL == pNameCount)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    hr = _MapDistPoint(FALSE, DistPointIndex, &pCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    if (NULL == *paName)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }
    *pNameCount = *pCount;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetNameCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetNameChoice -- Get a Name Choice
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetNameChoice(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameIndex,
    /* [out, retval] */ LONG __RPC_FAR *pNameChoice)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;

    if (NULL == pNameChoice)
    {
        hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }

    hr = _MapName(FALSE, DistPointIndex, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }
    *pNameChoice = pName->dwAltNameChoice;
    if (0 == pName->dwAltNameChoice)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	ceERRORPRINTLINE("uninitialized", hr);
	goto error;
    }

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetNameChoice"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::GetName -- Get a Name
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::GetName(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameIndex,
    /* [out, retval] */ BSTR __RPC_FAR *pstrName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;
    WCHAR const *pwsz = NULL;
    char const *psz = NULL;

    if (NULL == pstrName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrName);
    hr = _MapName(FALSE, DistPointIndex, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    switch (pName->dwAltNameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	    pwsz = pName->pwszRfc822Name;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    pwsz = pName->pwszDNSName;
	    break;

	case CERT_ALT_NAME_URL:
	    pwsz = pName->pwszURL;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    psz = pName->pszRegisteredID;
	    break;

	//case CERT_ALT_NAME_DIRECTORY_NAME:
	//case CERT_ALT_NAME_OTHER_NAME:
	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
	//case CERT_ALT_NAME_IP_ADDRESS:
	default:
	    assert(0 == pName->dwAltNameChoice);
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    ceERRORPRINTLINE("uninitialized", hr);
	    goto error;
    }

    // we'd better assure 1 and only 1 of these is non null

    if ((NULL != pwsz) ^ (NULL == psz))
    {
       hr = E_UNEXPECTED; 
       _JumpError(hr, error, "((NULL != pwsz) ^ (NULL == psz))");
    }

    hr = E_OUTOFMEMORY;
    if (NULL != pwsz)
    {
	if (!ceConvertWszToBstr(pstrName, pwsz, -1))
	{
	    ceERRORPRINTLINE("no memory", hr);
	    goto error;
	}
    }
    else
    {
	assert(NULL != psz);
	if (!ceConvertSzToBstr(pstrName, psz, -1))
	{
	    ceERRORPRINTLINE("no memory", hr);
	    goto error;
	}
    }
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::GetName"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::Reset -- clear out data
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::Reset(
    /* [in] */ LONG DistPointCount)
{
    HRESULT hr = S_OK;

    _Cleanup();
    m_fConstructing = TRUE;
    if (CENCODEMAX < DistPointCount || 0 > DistPointCount)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    m_aValue = (CRL_DIST_POINT *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				DistPointCount * sizeof(m_aValue[0]));
    if (NULL == m_aValue)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    m_cValue = DistPointCount;

error:
    if (S_OK != hr)
    {
	_Cleanup();
    }
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::Reset"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::SetNameCount -- Set the Name Count
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::SetNameCount(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameCount)
{
    HRESULT hr;
    LONG *pNameCount;
    CERT_ALT_NAME_ENTRY **paName;

    hr = E_INVALIDARG;
    if (!m_fConstructing)
    {
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }
    if (CENCODEMAX < NameCount || 0 > NameCount)
    {
	ceERRORPRINTLINE("bad count parameter", hr);
	goto error;
    }

    hr = _MapDistPoint(FALSE, DistPointIndex, &pNameCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    if (0 != *pNameCount || NULL != *paName)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    *paName = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				NameCount * sizeof(CERT_ALT_NAME_ENTRY));
    if (NULL == *paName)
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("LocalAlloc", hr);
	goto error;
    }
    *pNameCount = NameCount;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::SetNameCount"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::SetNameEntry -- Set a Name Netry
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::SetNameEntry(
    /* [in] */ LONG DistPointIndex,
    /* [in] */ LONG NameIndex,
    /* [in] */ LONG NameChoice,
    /* [in] */ BSTR const strName)
{
    HRESULT hr;
    CERT_ALT_NAME_ENTRY *pName;
    WCHAR **ppwsz = NULL;
    char **ppsz = NULL;

    if (NULL == strName)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    if (!m_fConstructing)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    hr = _MapName(TRUE, DistPointIndex, NameIndex, &pName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapName", hr);
	goto error;
    }

    if (NULL != pName->pwszURL)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    switch (NameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	    ppwsz = &pName->pwszRfc822Name;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    ppwsz = &pName->pwszDNSName;
	    break;

	case CERT_ALT_NAME_URL:
	    ppwsz = &pName->pwszURL;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    hr = ceVerifyObjId(strName);
	    if (S_OK != hr)
	    {
		ceERRORPRINTLINE("ceVerifyObjId", hr);
		goto error;
	    }
	    ppsz = &pName->pszRegisteredID;
	    break;

	//case CERT_ALT_NAME_DIRECTORY_NAME:
	//case CERT_ALT_NAME_OTHER_NAME:
	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
	//case CERT_ALT_NAME_IP_ADDRESS:
    }
    if (NULL != ppwsz)
    {
	if (NULL != *ppwsz)
	{
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("string already set", hr);
	    goto error;
	}
	hr = ceVerifyAltNameString(NameChoice, strName);
	if (S_OK != hr)
	{
	    ceERRORPRINTLINE("ceVerifyAltNameString", hr);
	    goto error;
	}
	*ppwsz = ceDuplicateString(strName);
	if (NULL == *ppwsz)
	{
	    hr = E_OUTOFMEMORY;
	    ceERRORPRINTLINE("ceDuplicateString", hr);
	    goto error;
	}
    }
    else if (NULL != ppsz)
    {
	if (NULL != *ppsz)
	{
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("string already set", hr);
	    goto error;
	}
	if (!ceConvertWszToSz(ppsz, strName, -1))
	{
	    hr = E_OUTOFMEMORY;
	    ceERRORPRINTLINE("ceConvertWszToSz", hr);
	    goto error;
	}
    }
    else
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad NameChoice parameter", hr);
	goto error;
    }
    pName->dwAltNameChoice = NameChoice;

error:
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::SetNameEntry"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_VerifyNames -- Verify names
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

BOOL
CCertEncodeCRLDistInfo::_VerifyNames(
    IN LONG DistPointIndex)
{
    HRESULT hr;
    BOOL fOk = FALSE;
    LONG Count;
    LONG *pNameCount;
    LONG i;
    CERT_ALT_NAME_ENTRY **paName;

    assert(m_fConstructing);

    hr = _MapDistPoint(TRUE, DistPointIndex, &pNameCount, &paName);
    if (S_OK != hr)
    {
	ceERRORPRINTLINE("_MapDistPoint", hr);
	goto error;
    }
    Count = *pNameCount;
    if (0 != Count)
    {
	CERT_ALT_NAME_ENTRY *pName;

	pName = *paName;
	assert(NULL != pName);
	for (i = 0; i < Count; pName++, i++)
	{
	    if (NULL == pName->pwszURL)		// test arbitrary union arm
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		ceERRORPRINTLINE("uninitialized name", hr);
		goto error;
	    }
	}
    }
    fOk = TRUE;

error:
    return(fOk);
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::Encode -- Encode CRLDistInfo
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertEncodeCRLDistInfo::Encode(
    /* [out, retval] */ BSTR __RPC_FAR *pstrBinary)
{
    HRESULT hr = S_OK;
    CRL_DIST_POINTS_INFO CRLDistInfo;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    LONG i;

    CRLDistInfo.cDistPoint = m_cValue;
    CRLDistInfo.rgDistPoint = m_aValue;

    if (NULL == pstrBinary)
    {
	hr = E_POINTER;
	ceERRORPRINTLINE("NULL parm", hr);
	goto error;
    }
    ceFreeBstr(pstrBinary);
    if (!m_fConstructing || NULL == m_aValue)
    {
	hr = E_INVALIDARG;
	ceERRORPRINTLINE("bad parameter", hr);
	goto error;
    }

    for (i = 0; i < m_cValue; i++)
    {
	m_aValue[i].DistPointName.dwDistPointNameChoice =
	    CRL_DIST_POINT_FULL_NAME;

	// Verify all entries are initialized:

	if (!_VerifyNames(i))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    ceERRORPRINTLINE("uninitialized name", hr);
	    goto error;
	}
    }

    // Encode CRL_DIST_POINTS_INFO:

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CRL_DIST_POINTS,
		    &CRLDistInfo,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }
    if (!ceConvertWszToBstr(pstrBinary, (WCHAR const *) pbEncoded, cbEncoded))
    {
	hr = E_OUTOFMEMORY;
	ceERRORPRINTLINE("ceConvertWszToBstr", hr);
	goto error;
    }

error:
    if (NULL != pbEncoded)
    {
	LocalFree(pbEncoded);
    }
    return(_SetErrorInfo(hr, L"CCertEncodeCRLDistInfo::Encode"));
}


//+--------------------------------------------------------------------------
// CCertEncodeCRLDistInfo::_SetErrorInfo -- set error object information
//
// Returns passed HRESULT
//+--------------------------------------------------------------------------

HRESULT
CCertEncodeCRLDistInfo::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    assert(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = ceDispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTENCODECRLDISTINFO,
			    &IID_ICertEncodeCRLDistInfo);
	assert(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certenc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certenc.rc
//
#define IDS_CERTENCODEDATEARRAY_DESC		1
#define IDS_CERTENCODELONGARRAY_DESC		2
#define IDS_CERTENCODEALTNAME_DESC		3
#define IDS_CERTENCODESTRINGARRAY_DESC		4
#define IDS_CERTENCODEBITSTRING_DESC		5
#define IDS_CERTENCODECRLDIST_DESC		6
#define IDS_E_UNEXPECTED			7
#define IDS_UNKNOWN_ERROR_CODE			8


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\csif.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        csif.h
//
// Contents:    CertIf includes
//
//---------------------------------------------------------------------------

#include "csprop.h"
#include "certif.h"
#include "cipolicy.h"
#include "ciexit.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\ciexit.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ciexit.cpp
//
//--------------------------------------------------------------------------

// ciexit.cpp: Implementation of CCertServerExit

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"
#include "ciinit.h"
#include <assert.h>

#include "ciexit.h"

#define __dwFILE__	__dwFILE_CERTIF_CIEXIT_CPP__


extern SERVERCALLBACKS ServerCallBacks;

/////////////////////////////////////////////////////////////////////////////
//

CCertServerExit::~CCertServerExit()
{
    EnumerateExtensionsClose();
    EnumerateAttributesClose();
}


STDMETHODIMP
CCertServerExit::SetContext(
    IN LONG Context)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);

    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "pfnGetProperty NULL");
    }
    if (0 != Context)
    {
	// PROPCALLER_SERVER indicates this call is only for Context validation
	// -- returns a zero RequestId.  This keeps CRL publication exit module
	// notification from failing.

	hr = (*ServerCallBacks.pfnGetProperty)(
				    Context,
				    PROPTYPE_LONG |
					PROPCALLER_SERVER |
					PROPTABLE_REQUEST,
				    wszPROPREQUESTREQUESTID,
				    &var);
	_JumpIfError(hr, error, "GetProperty");
    }
    m_Context = Context;
    hr = S_OK;

error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerExit::SetContext", NULL));
}


STDMETHODIMP
CCertServerExit::GetRequestProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_EXIT | PROPTABLE_REQUEST,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetRequestProperty", strPropertyName));
}


STDMETHODIMP
CCertServerExit::GetRequestAttribute(
    IN BSTR const strAttributeName,
    OUT BSTR __RPC_FAR *pstrAttributeValue)
{
    HRESULT hr;
    VARIANT var;

    var.vt = VT_BYREF | VT_BSTR;
    var.pbstrVal = pstrAttributeValue;

    if (NULL == pstrAttributeValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pstrAttributeValue NULL");
    }

    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				PROPTYPE_STRING |
				    PROPCALLER_EXIT |
				    PROPTABLE_ATTRIBUTE,
				strAttributeName,
				&var);
    if (VT_BSTR == var.vt)
    {
	*pstrAttributeValue = var.bstrVal;
	var.vt = VT_EMPTY;
    }
    else
    if ((VT_BYREF | VT_BSTR) == var.vt)
    {
	*pstrAttributeValue = *var.pbstrVal;
	var.vt = VT_EMPTY;
    }
error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerExit::GetRequestAttribute", strAttributeName));
}


STDMETHODIMP
CCertServerExit::GetCertificateProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_EXIT | PROPTABLE_CERTIFICATE,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetCertificateProperty", strPropertyName));
}


STDMETHODIMP
CCertServerExit::GetCertificateExtension(
    IN BSTR const strExtensionName,
    IN LONG Type,
    OUT VARIANT __RPC_FAR *pvarValue)
{
    HRESULT hr;
    
    m_fExtensionValid = FALSE;
    assert(NULL != ServerCallBacks.pfnGetExtension);
    if (NULL == ServerCallBacks.pfnGetExtension)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetExtension NULL");
    }
    hr = (*ServerCallBacks.pfnGetExtension)(
				m_Context,
				(Type & PROPTYPE_MASK) | PROPCALLER_EXIT,
				strExtensionName,
				(DWORD *) &m_ExtFlags,
				pvarValue);
    if (S_OK == hr)
    {
	m_fExtensionValid = TRUE;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetCertificateExtension", strExtensionName));
}


STDMETHODIMP
CCertServerExit::GetCertificateExtensionFlags(
    OUT LONG __RPC_FAR *pExtFlags)
{
    HRESULT hr = E_INVALIDARG;
    if (NULL == pExtFlags)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pExtFlags NULL");
    }

    *pExtFlags = 0;
    if (m_fExtensionValid)
    {
	*pExtFlags = m_ExtFlags;
	hr = S_OK;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::GetCertificateExtensionFlags", NULL));
}




STDMETHODIMP
CCertServerExit::EnumerateExtensionsSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_EXTENSIONS |
				    CIE_CALLER_EXIT,
				&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateExtensionsSetup", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateExtensions(
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumExtensions,
				pstrExtensionName);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateExtensions", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateExtensionsClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateExtensionsClose", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateAttributesSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_ATTRIBUTES |
				    CIE_CALLER_EXIT,
				&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateAttributesSetup", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateAttributes(
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumAttributes,
				pstrAttributeName);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateAttributes", NULL));
}


STDMETHODIMP
CCertServerExit::EnumerateAttributesClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerExit::EnumerateAttributesClose", NULL));
}


HRESULT
CCertServerExit::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszPropName)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);

    CSASSERT(NULL != pwszDescription);
    if (NULL == pwszDescription)
    {
        _JumpError(E_POINTER, error, "NULL parm");
    }

    if (FAILED(hrError))
    {
	    HRESULT hr;
	    WCHAR const *pwszLog = pwszDescription;
	    WCHAR *pwszAlloc = NULL;

	    if (NULL != pwszPropName)
	    {
	        pwszAlloc = (WCHAR *) LocalAlloc(
					    LMEM_FIXED, 
					    (wcslen(pwszDescription) +
					     wcslen(pwszPropName) +
					     2 +
					     1) * sizeof(WCHAR));
	        if (NULL != pwszAlloc)
	        {
		    wcscpy(pwszAlloc, pwszDescription);
		    wcscat(pwszAlloc, wszLPAREN);
		    wcscat(pwszAlloc, pwszPropName);
		    wcscat(pwszAlloc, wszRPAREN);
		    pwszLog = pwszAlloc;
	        }
	    }

	    hr = DispatchSetErrorInfo(
			        hrError,
			        pwszLog,
			        wszCLASS_CERTSERVEREXIT,
			        &IID_ICertServerExit);
	    CSASSERT(hr == hrError);
	    if (NULL != pwszAlloc)
	    {
	        LocalFree(pwszAlloc);
	    }
    }
error:
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\ciexit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ciexit.h
//
//--------------------------------------------------------------------------

// ciexit.h : Declaration of the CCertServerExit class


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CertIF

class CCertServerExit: 
    public IDispatchImpl<ICertServerExit, &IID_ICertServerExit, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertServerExit>,
    public CComObjectRoot,
    public CComCoClass<CCertServerExit, &CLSID_CCertServerExit>
{
public:
    CCertServerExit() { m_Context = 0; m_fExtensionValid = FALSE; }
    ~CCertServerExit();

BEGIN_COM_MAP(CCertServerExit)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertServerExit)
END_COM_MAP()

// Remove the comment from following the line if you don't want your object to 
// support aggregation.  The default is to support it.

DECLARE_NOT_AGGREGATABLE(CCertServerExit) 

DECLARE_REGISTRY(
    CCertServerExit,
    wszCLASS_CERTSERVEREXIT TEXT(".1"),
    wszCLASS_CERTSERVEREXIT,
    IDS_CERTSERVERPOLICY_DESC,
    THREADFLAGS_BOTH)

// ICertServerExit
public:
    STDMETHOD(SetContext)(
		    IN LONG Context);

    STDMETHOD(GetRequestProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetRequestAttribute)(
		    IN BSTR const strAttributeName,
		    OUT BSTR __RPC_FAR *pstrAttributeValue);

    STDMETHOD(GetCertificateProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetCertificateExtension)(
		    IN BSTR const strExtensionName,
		    IN LONG Type,
		    OUT VARIANT __RPC_FAR *pvarValue);

    STDMETHOD(GetCertificateExtensionFlags)(
		    OUT LONG __RPC_FAR *pFlags);

    STDMETHOD(EnumerateExtensionsSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateExtensions)(
		    OUT BSTR *pstrExtensionName);

    STDMETHOD(EnumerateExtensionsClose)(VOID);

    STDMETHOD(EnumerateAttributesSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateAttributes)(
		    OUT BSTR *pstrAttributeName);

    STDMETHOD(EnumerateAttributesClose)(VOID);

private:
    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription,
	OPTIONAL IN WCHAR const *pwszPropName);

    LONG   m_Context;
    LONG   m_ExtFlags;
    BOOL   m_fExtensionValid;
    CIENUM m_ciEnumExtensions;
    CIENUM m_ciEnumAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\cipolicy.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       cipolicy.cpp
//
//--------------------------------------------------------------------------

// cipolicy.cpp: Implementation of CCertServerPolicy

#include "pch.cpp"

#pragma hdrstop

#include "csprop.h"
#include "csdisp.h"
#include "ciinit.h"
#include <assert.h>

#include "cipolicy.h"

#define __dwFILE__	__dwFILE_CERTIF_CIPOLICY_CPP__


extern SERVERCALLBACKS ServerCallBacks;

/////////////////////////////////////////////////////////////////////////////
//

CCertServerPolicy::~CCertServerPolicy()
{
    EnumerateExtensionsClose();
    EnumerateAttributesClose();
}


STDMETHODIMP
CCertServerPolicy::SetContext(
    IN LONG Context)
{
    HRESULT hr;
    VARIANT var;

    VariantInit(&var);

    if (0 != Context)
    {
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

	hr = (*ServerCallBacks.pfnGetProperty)(
				    Context,
				    PROPTYPE_LONG |
					PROPCALLER_POLICY |
					PROPTABLE_CERTIFICATE,
				    wszPROPREQUESTREQUESTID,
				    &var);
	_JumpIfError(hr, error, "GetProperty");
    }
    m_Context = Context;
    hr = S_OK;

error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerPolicy::SetContext", NULL));
}


STDMETHODIMP
CCertServerPolicy::GetRequestProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }

    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_POLICY | PROPTABLE_REQUEST,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetRequestProperty", strPropertyName));
}


STDMETHODIMP
CCertServerPolicy::GetRequestAttribute(
    IN BSTR const strAttributeName,
    OUT BSTR __RPC_FAR *pstrAttributeValue)
{
    HRESULT hr;
    VARIANT var;

    var.vt = VT_BYREF | VT_BSTR;
    var.pbstrVal = pstrAttributeValue;

    if (NULL == pstrAttributeValue)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pstrAttributeValue NULL");
    }
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				PROPTYPE_STRING |
				    PROPCALLER_POLICY |
				    PROPTABLE_ATTRIBUTE,
				strAttributeName,
				&var);
    *pstrAttributeValue = NULL;
    if (VT_BSTR == var.vt)
    {
	*pstrAttributeValue = var.bstrVal;
	var.vt = VT_EMPTY;
    }
    else
    if ((VT_BYREF | VT_BSTR) == var.vt)
    {
	*pstrAttributeValue = *var.pbstrVal;
	var.vt = VT_EMPTY;
    }
error:
    VariantClear(&var);
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetRequestAttribute", strAttributeName));
}


STDMETHODIMP
CCertServerPolicy::GetCertificateProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    OUT VARIANT __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnGetProperty);
    if (NULL == ServerCallBacks.pfnGetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnGetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_POLICY | PROPTABLE_CERTIFICATE,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetCertificateProperty", strPropertyName));
}


STDMETHODIMP
CCertServerPolicy::SetCertificateProperty(
    IN BSTR const strPropertyName,
    IN LONG PropertyType,
    IN VARIANT const __RPC_FAR *pvarPropertyValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnSetProperty);
    if (NULL == ServerCallBacks.pfnSetProperty)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnSetProperty NULL");
    }
    hr = (*ServerCallBacks.pfnSetProperty)(
				m_Context,
				(PropertyType & PROPTYPE_MASK) |
				    PROPCALLER_POLICY | PROPTABLE_CERTIFICATE,
				strPropertyName,
				pvarPropertyValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::SetCertificateProperty", strPropertyName));
}


STDMETHODIMP
CCertServerPolicy::GetCertificateExtension(
    IN BSTR const strExtensionName,
    IN LONG Type,
    OUT VARIANT __RPC_FAR *pvarValue)
{
    HRESULT hr;
    
    m_fExtensionValid = FALSE;
    assert(NULL != ServerCallBacks.pfnGetExtension);
    if (NULL == ServerCallBacks.pfnGetExtension)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnGetExtension NULL");
    }
    hr = (*ServerCallBacks.pfnGetExtension)(
				m_Context,
				(Type & PROPTYPE_MASK) | PROPCALLER_POLICY,
				strExtensionName,
				(DWORD *) &m_ExtFlags,
				pvarValue);
    if (S_OK == hr)
    {
	m_fExtensionValid = TRUE;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetCertificateExtension", strExtensionName));
}


STDMETHODIMP
CCertServerPolicy::GetCertificateExtensionFlags(
    OUT LONG __RPC_FAR *pExtFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL == pExtFlags)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    *pExtFlags = 0;
    if (m_fExtensionValid)
    {
	*pExtFlags = m_ExtFlags;
	hr = S_OK;
    }
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::GetCertificateExtensionFlags", NULL));
}


STDMETHODIMP
CCertServerPolicy::SetCertificateExtension(
    IN BSTR const strExtensionName,
    IN LONG Type,
    IN LONG ExtFlags,
    IN VARIANT const __RPC_FAR *pvarValue)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnSetExtension);
    if (NULL == ServerCallBacks.pfnSetExtension)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnSetExtension NULL");
    }
    hr = (*ServerCallBacks.pfnSetExtension)(
				m_Context,
				(Type & PROPTYPE_MASK) | PROPCALLER_POLICY,
				strExtensionName,
				(ExtFlags & EXTENSION_POLICY_MASK) |
				    EXTENSION_ORIGIN_POLICY,
				pvarValue);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::SetCertificateExtension", strExtensionName));
}


STDMETHODIMP
CCertServerPolicy::EnumerateExtensionsSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_EXTENSIONS |
				    CIE_CALLER_POLICY,
				&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateExtensionsSetup", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateExtensions(
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumExtensions,
				pstrExtensionName);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateExtensions", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateExtensionsClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumExtensions);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateExtensionsClose", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateAttributesSetup(
    IN LONG Flags)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumSetup);
    if (NULL == ServerCallBacks.pfnEnumSetup)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumSetup NULL");
    }
    hr = (*ServerCallBacks.pfnEnumSetup)(
				m_Context,
				(Flags & CIE_OBJECTID) |
				    CIE_TABLE_ATTRIBUTES |
				    CIE_CALLER_POLICY,
				&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateAttributesSetup", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateAttributes(
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumNext);
    if (NULL == ServerCallBacks.pfnEnumNext)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumNext NULL");
    }
    hr = (*ServerCallBacks.pfnEnumNext)(
				&m_ciEnumAttributes,
				pstrAttributeName);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateAttributes", NULL));
}


STDMETHODIMP
CCertServerPolicy::EnumerateAttributesClose(VOID)
{
    HRESULT hr;
    
    assert(NULL != ServerCallBacks.pfnEnumClose);
    if (NULL == ServerCallBacks.pfnEnumClose)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "pfnEnumClose NULL");
    }
    hr = (*ServerCallBacks.pfnEnumClose)(&m_ciEnumAttributes);
error:
    return(_SetErrorInfo(hr, L"CCertServerPolicy::EnumerateAttributesClose", NULL));
}


HRESULT
CCertServerPolicy::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszPropName)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);

    CSASSERT(pwszDescription != NULL);
    if (NULL == pwszDescription)
    {
        _JumpError(E_POINTER, error, "NULL parm");
    }

    if (FAILED(hrError))
    {
        HRESULT hr;
	WCHAR const *pwszLog = pwszDescription;
	WCHAR *pwszAlloc = NULL;

	if (NULL != pwszPropName)
	{
	    pwszAlloc = (WCHAR *) LocalAlloc(
					LMEM_FIXED, 
					(wcslen(pwszDescription) +
					 wcslen(pwszPropName) +
					 2 +
					 1) * sizeof(WCHAR));
	    if (NULL != pwszAlloc)
	    {
		wcscpy(pwszAlloc, pwszDescription);
		wcscat(pwszAlloc, wszLPAREN);
		wcscat(pwszAlloc, pwszPropName);
		wcscat(pwszAlloc, wszRPAREN);
		pwszLog = pwszAlloc;
	    }
	}

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszLog,
			    wszCLASS_CERTSERVERPOLICY,
			    &IID_ICertServerPolicy);
	CSASSERT(hr == hrError);
	if (NULL != pwszAlloc)
	{
	    LocalFree(pwszAlloc);
	}
    }
error:
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\cipolicy.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       cipolicy.h
//
//--------------------------------------------------------------------------

// cipolicy.h : Declaration of the CCertServerPolicy class


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CertIF

class CCertServerPolicy: 
    public IDispatchImpl<ICertServerPolicy, &IID_ICertServerPolicy, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertServerPolicy>,
    public CComObjectRoot,
    public CComCoClass<CCertServerPolicy,&CLSID_CCertServerPolicy>
{
public:
    CCertServerPolicy() { m_Context = 0; m_fExtensionValid = FALSE; }
    ~CCertServerPolicy();

BEGIN_COM_MAP(CCertServerPolicy)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertServerPolicy)
END_COM_MAP()

// Remove the comment from following the line if you don't want your object to 
// support aggregation.  The default is to support it.

DECLARE_NOT_AGGREGATABLE(CCertServerPolicy) 

DECLARE_REGISTRY(
    CCertServerPolicy,
    wszCLASS_CERTSERVERPOLICY TEXT(".1"),
    wszCLASS_CERTSERVERPOLICY,
    IDS_CERTSERVERPOLICY_DESC,
    THREADFLAGS_BOTH)

// ICertServerPolicy
public:
    STDMETHOD(SetContext)(
		    IN LONG Context);

    STDMETHOD(GetRequestProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetRequestAttribute)(
		    IN BSTR const strAttributeName,
		    OUT BSTR __RPC_FAR *pstrAttributeValue);

    STDMETHOD(GetCertificateProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    OUT VARIANT __RPC_FAR *pvarPropertyValue);

    STDMETHOD(SetCertificateProperty)(
		    IN BSTR const strPropertyName,
		    IN LONG PropertyType,
		    IN VARIANT const __RPC_FAR *pvarPropertyValue);

    STDMETHOD(GetCertificateExtension)(
		    IN BSTR const strExtensionName,
		    IN LONG Type,
		    OUT VARIANT __RPC_FAR *pvarValue);

    STDMETHOD(GetCertificateExtensionFlags)(
		    OUT LONG __RPC_FAR *pFlags);

    STDMETHOD(SetCertificateExtension)(
		    IN BSTR const strExtensionName,
		    IN LONG Type,
		    IN LONG ExtFlags,
		    IN VARIANT const __RPC_FAR *pvarValue);

    STDMETHOD(EnumerateExtensionsSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateExtensions)(
		    OUT BSTR *pstrExtensionName);

    STDMETHOD(EnumerateExtensionsClose)(VOID);

    STDMETHOD(EnumerateAttributesSetup)(
		    IN LONG Flags);

    STDMETHOD(EnumerateAttributes)(
		    OUT BSTR *pstrAttributeName);

    STDMETHOD(EnumerateAttributesClose)(VOID);

private:
    HRESULT _SetErrorInfo(
	IN HRESULT hrError,
	IN WCHAR const *pwszDescription,
	OPTIONAL IN WCHAR const *pwszPropName);

    LONG   m_Context;
    LONG   m_ExtFlags;
    BOOL   m_fExtensionValid;
    CIENUM m_ciEnumExtensions;
    CIENUM m_ciEnumAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\pch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pch.cpp
//
//--------------------------------------------------------------------------

#define __DIR__		"certif"

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certif\csifm.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certifm.h
//
// Contents:    CertIf object map entries
//
//---------------------------------------------------------------------------

    OBJECT_ENTRY(CLSID_CCertServerPolicy, CCertServerPolicy)
    OBJECT_ENTRY(CLSID_CCertServerExit, CCertServerExit)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\admin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       admin.cpp
//
//  Contents:   ICertAdmin IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_ADMIN_CPP__


//+------------------------------------------------------------------------
// ICertAdmin dispatch support

//TCHAR szRegKeyAdminClsid[] = wszCLASS_CERTADMIN TEXT("\\Clsid");

//+------------------------------------
// IsValidCertificate method:

static OLECHAR *_apszIsValidCertificate[] = {
    TEXT("IsValidCertificate"),
    TEXT("strConfig"),
    TEXT("strSerialNumber"),
};


//+------------------------------------
// GetRevocationReason method:

static OLECHAR *_apszGetRevocationReason[] = {
    TEXT("GetRevocationReason"),
};

//+------------------------------------
// RevokeCertificate method:

static OLECHAR *_apszRevokeCertificate[] = {
    TEXT("RevokeCertificate"),
    TEXT("strConfig"),
    TEXT("strSerialNumber"),
    TEXT("Reason"),
    TEXT("Date"),
};

//+------------------------------------
// SetRequestAttributes method:

static OLECHAR *_apszSetRequestAttributes[] = {
    TEXT("SetRequestAttributes"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strAttributes"),
};

//+------------------------------------
// SetCertificateExtension method:

static OLECHAR *_apszSetCertificateExtension[] = {
    TEXT("SetCertificateExtension"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strExtensionName"),
    TEXT("Type"),
    TEXT("Flags"),
    TEXT("pvarValue"),
};

//+------------------------------------
// DenyRequest method:

static OLECHAR *_apszDenyRequest[] = {
    TEXT("DenyRequest"),
    TEXT("strConfig"),
    TEXT("RequestId"),
};

//+------------------------------------
// ResubmitRequest method:

static OLECHAR *_apszResubmitRequest[] = {
    TEXT("ResubmitRequest"),
    TEXT("strConfig"),
    TEXT("RequestId"),
};

//+------------------------------------
// PublishCRL method:

static OLECHAR *_apszPublishCRL[] = {
    TEXT("PublishCRL"),
    TEXT("strConfig"),
    TEXT("Date"),
};

//+------------------------------------
// GetCRL method:

static OLECHAR *_apszGetCRL[] = {
    TEXT("GetCRL"),
    TEXT("strConfig"),
    TEXT("Flags"),
};

//+------------------------------------
// ImportCertificate method:

static OLECHAR *_apszImportCertificate[] = {
    TEXT("ImportCertificate"),
    TEXT("strConfig"),
    TEXT("strCertificate"),
    TEXT("Flags"),
};

//+------------------------------------
// PublishCRLs method:

static OLECHAR *_apszPublishCRLs[] = {
    TEXT("PublishCRLs"),
    TEXT("strConfig"),
    TEXT("Date"),
    TEXT("CRLFlags"),
};

//+------------------------------------
// GetCAProperty method:

static OLECHAR *_apszGetCAProperty[] = {
    TEXT("GetCAProperty"),
    TEXT("strConfig"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("Flags"),
};

//+------------------------------------
// SetCAProperty method:

static OLECHAR *_apszSetCAProperty[] = {
    TEXT("SetCAProperty"),
    TEXT("strConfig"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("pvarPropertyValue"),
};

//+------------------------------------
// GetCAPropertyFlags method:

static OLECHAR *_apszGetCAPropertyFlags[] = {
    TEXT("GetCAPropertyFlags"),
    TEXT("strConfig"),
    TEXT("PropId"),
};

//+------------------------------------
// GetCAPropertyDisplayName method:

static OLECHAR *_apszGetCAPropertyDisplayName[] = {
    TEXT("GetCAPropertyDisplayName"),
    TEXT("strConfig"),
    TEXT("PropId"),
};

//+------------------------------------
// GetArchivedKey method:

static OLECHAR *_apszGetArchivedKey[] = {
    TEXT("GetArchivedKey"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("Flags"),
};

//+------------------------------------
// GetConfigEntry method:

static OLECHAR *_apszGetConfigEntry[] = {
    TEXT("GetConfigEntry"),
    TEXT("strConfig"),
    TEXT("strNodePath"),
    TEXT("strEntryName"),
};

//+------------------------------------
// SetConfigEntry method:

static OLECHAR *_apszSetConfigEntry[] = {
    TEXT("SetConfigEntry"),
    TEXT("strConfig"),
    TEXT("strNodePath"),
    TEXT("strEntryName"),
    TEXT("pvarEntry"),
};

//+------------------------------------
// ImportKey method:

static OLECHAR *_apszImportKey[] = {
    TEXT("ImportKey"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strCertHash"),
    TEXT("Flags"),
    TEXT("strKey"),
};

//+------------------------------------
// GetMyRoles method:

static OLECHAR *_apszGetMyRoles[] = {
    TEXT("GetMyRoles"),
    TEXT("strConfig"),
};

//+------------------------------------
// DeleteRow method:

static OLECHAR *_apszDeleteRow[] = {
    TEXT("DeleteRow"),
    TEXT("strConfig"),
    TEXT("Flags"),
    TEXT("Date"),
    TEXT("Table"),
    TEXT("RowId"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtAdmin[] =
{
#define ADMIN_ISVALIDCERTIFICATE	0
    DECLARE_DISPATCH_ENTRY(_apszIsValidCertificate)

#define ADMIN_GETREVOCATIONREASON	1
    DECLARE_DISPATCH_ENTRY(_apszGetRevocationReason)

#define ADMIN_REVOKECERTIFICATE		2
    DECLARE_DISPATCH_ENTRY(_apszRevokeCertificate)

#define ADMIN_SETREQUESTATTRIBUTES	3
    DECLARE_DISPATCH_ENTRY(_apszSetRequestAttributes)

#define ADMIN_SETCERTIFICATEEXTENSION	4
    DECLARE_DISPATCH_ENTRY(_apszSetCertificateExtension)

#define ADMIN_DENYREQUEST		5
    DECLARE_DISPATCH_ENTRY(_apszDenyRequest)

#define ADMIN_RESUBMITREQUEST		6
    DECLARE_DISPATCH_ENTRY(_apszResubmitRequest)

#define ADMIN_PUBLISHCRL		7
    DECLARE_DISPATCH_ENTRY(_apszPublishCRL)

#define ADMIN_GETCRL			8
    DECLARE_DISPATCH_ENTRY(_apszGetCRL)

#define ADMIN_IMPORTCERTIFICATE 	9
    DECLARE_DISPATCH_ENTRY(_apszImportCertificate)

#define ADMIN2_PUBLISHCRLS 		10
    DECLARE_DISPATCH_ENTRY(_apszPublishCRLs)

#define ADMIN2_GETCAPROPERTY 		11
    DECLARE_DISPATCH_ENTRY(_apszGetCAProperty)

#define ADMIN2_SETCAPROPERTY 		12
    DECLARE_DISPATCH_ENTRY(_apszSetCAProperty)

#define ADMIN2_GETCAPROPERTYFLAGS 	13
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyFlags)

#define ADMIN2_GETCAPROPERTYDISPLAYNAME	14
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyDisplayName)

#define ADMIN2_GETARCHIVEDKEY		15
    DECLARE_DISPATCH_ENTRY(_apszGetArchivedKey)

#define ADMIN2_GETCONFIGENTRY		16
    DECLARE_DISPATCH_ENTRY(_apszGetConfigEntry)

#define ADMIN2_SETCONFIGENTRY		17
    DECLARE_DISPATCH_ENTRY(_apszSetConfigEntry)

#define ADMIN2_IMPORTKEY		18
    DECLARE_DISPATCH_ENTRY(_apszImportKey)

#define ADMIN2_GETMYROLES		19
    DECLARE_DISPATCH_ENTRY(_apszGetMyRoles)

#define ADMIN2_DELETEROW		20
    DECLARE_DISPATCH_ENTRY(_apszDeleteRow)
};
#define CADMINDISPATCH	(ARRAYSIZE(s_adtAdmin))
#define CADMINDISPATCH_V1	ADMIN2_PUBLISHCRLS
#define CADMINDISPATCH_V2	CADMINDISPATCH


DWORD s_acAdminDispatch[] = {
    CADMINDISPATCH_V2,
    CADMINDISPATCH_V1,
};

IID const *s_apAdminiid[] = {
    &IID_ICertAdmin2,
    &IID_ICertAdmin,
};


HRESULT
Admin_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiAdmin)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTADMIN,
		&CLSID_CCertAdmin,
		ARRAYSIZE(s_acAdminDispatch),		// cver
		s_apAdminiid,
		s_acAdminDispatch,
		s_adtAdmin,
		pdiAdmin);
    _JumpIfError(hr, error, "DispatchSetup2(ICertAdmin)");

error:
    return(hr);
}


VOID
Admin_Release(
    IN OUT DISPATCHINTERFACE *pdiAdmin)
{
    DispatchRelease(pdiAdmin);
}


HRESULT
AdminVerifyVersion(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    switch (pdiAdmin->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiAdmin->pDispatch ||
		CADMINDISPATCH_V1 == pdiAdmin->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiAdmin->pDispatch ||
		CADMINDISPATCH_V2 == pdiAdmin->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiAdmin->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Admin_IsValidCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strSerialNumber, pwszSerialNumber, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strSerialNumber;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_ISVALIDCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(IsValidCertificate)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->IsValidCertificate(
							    strConfig,
							    strSerialNumber,
							    pDisposition);

	_JumpIfError(hr, error, "ICertAdmin::IsValidCertificate");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
Admin_GetRevocationReason(
    IN DISPATCHINTERFACE *pdiAdmin,
    OUT LONG *pReason)
{
    HRESULT hr;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (NULL != pdiAdmin->pDispatch)
    {
	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_GETREVOCATIONREASON,
			0,
			NULL,
			VT_I4,
			pReason);
	_JumpIfError(hr, error, "Invoke(GetRevocationReason)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->GetRevocationReason(pReason);
	_JumpIfError(hr, error, "ICertAdmin::GetRevocationReason");
    }

error:
    return(hr);
}


HRESULT
Admin_RevokeCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strSerialNumber, pwszSerialNumber, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strSerialNumber;
	avar[2].vt = VT_I4;
	avar[2].lVal = Reason;
	avar[3].vt = VT_DATE;
	avar[3].date = Date;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_REVOKECERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(RevokeCertificate)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->RevokeCertificate(
							    strConfig,
							    strSerialNumber,
							    Reason,
							    Date);
	_JumpIfError(hr, error, "ICertAdmin::RevokeCertificate");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
Admin_SetRequestAttributes(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszAttributes)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strAttributes = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strAttributes, pwszAttributes, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;
	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strAttributes;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_SETREQUESTATTRIBUTES,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetRequestAttributes)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->SetRequestAttributes(
								strConfig,
								RequestId,
								strAttributes);

	_JumpIfError(hr, error, "ICertAdmin::SetRequestAttributes");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strAttributes)
    {
	SysFreeString(strAttributes);
    }
    return(hr);
}


HRESULT
Admin_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG Flags,
    IN VARIANT const *pvarValue)

{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strExtensionName = NULL;

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strExtensionName, pwszExtensionName, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[6];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strExtensionName;

	avar[3].vt = VT_I4;
	avar[3].lVal = Type;

	avar[4].vt = VT_I4;
	avar[4].lVal = Flags;

	avar[5].vt = VT_VARIANT | VT_BYREF;
	avar[5].pvarVal = (VARIANT *) pvarValue;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_SETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetCertificateExtension)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->SetCertificateExtension(
							    strConfig,
							    RequestId,
							    strExtensionName,
							    Type,
							    Flags,
							    pvarValue);
	_JumpIfError(hr, error, "ICertAdmin::SetCertificateExtension");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strExtensionName)
    {
	SysFreeString(strExtensionName);
    }
    return(hr);
}


HRESULT
Admin_DenyRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_DENYREQUEST,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(DenyRequest)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->DenyRequest(
							strConfig,
							RequestId);
	_JumpIfError(hr, error, "ICertAdmin::DenyRequest");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_ResubmitRequest(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_RESUBMITREQUEST,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(ResubmitRequest)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->ResubmitRequest(
							strConfig,
							RequestId,
							pDisposition);
	_JumpIfError(hr, error, "ICertAdmin::ResubmitRequest");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_PublishCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_DATE;
	avar[1].date = Date;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_PUBLISHCRL,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(PublishCRL)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->PublishCRL(
                                                         strConfig,
                                                         Date);
	_JumpIfError(hr, error, "ICertAdmin::PublishCRL");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin2_PublishCRLs(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN DATE Date,
    IN LONG CRLFlags)		// CA_CRL_*
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_DATE;
	avar[1].date = Date;

	avar[2].vt = VT_I4;
	avar[2].date = CRLFlags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_PUBLISHCRLS,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(PublishCRLs)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->PublishCRLs(
                                                         strConfig,
                                                         Date,
							 CRLFlags);
	_JumpIfError(hr, error, "ICertAdmin2::PublishCRLs");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_GetCRL(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,
    OUT BSTR *pstrCRL)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_GETCRL,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrCRL);
	_JumpIfError(hr, error, "Invoke(GetCRL)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->GetCRL(
						    strConfig,
						    Flags,
						    pstrCRL);
	_JumpIfError(hr, error, "ICertAdmin::GetCRL");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin_ImportCertificate(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszCertificate,
    IN DWORD cbCertificate,
    IN LONG dwFlags,
    OUT LONG *pRequestId)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strCertificate = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    strCertificate = SysAllocStringByteLen(
				    (CHAR const *) pwszCertificate,
				    cbCertificate);
    if (NULL == strCertificate)
    {
	_JumpError(hr, error, "SysAllocStringByteLen");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strCertificate;
	avar[2].vt = VT_I4;
	avar[2].lVal = dwFlags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN_IMPORTCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pRequestId);
	_JumpIfError(hr, error, "Invoke(ImportCertificate)");
    }
    else
    {
	hr = ((ICertAdmin *) pdiAdmin->pUnknown)->ImportCertificate(
						    strConfig,
						    strCertificate,
						    dwFlags,
						    pRequestId);
	_JumpIfError3(
		    hr,
		    error,
		    "ICertAdmin::ImportCertificate",
		    NTE_BAD_SIGNATURE,
		    HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strCertificate)
    {
	SysFreeString(strCertificate);
    }
    return(hr);
}


HRESULT
AdminRevokeCertificate(
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszSerialNumber,
    IN LONG Reason,
    IN DATE Date)
{
    HRESULT hr;
    DISPATCHINTERFACE diAdmin;
    BSTR strConfig = NULL;
    
    if (NULL == pwszConfig)
    {
	hr = ConfigGetConfig(Flags, CC_LOCALACTIVECONFIG, &strConfig);
	_JumpIfError(hr, error, "ConfigGetConfig");

	pwszConfig = strConfig;
    }
    hr = Admin_Init(Flags, &diAdmin);
    _JumpIfError(hr, error, "Admin_Init");

    hr = Admin_RevokeCertificate(
			    &diAdmin,
			    pwszConfig,
			    pwszSerialNumber,
			    Reason,
			    Date);
    _JumpIfError(hr, error, "Admin_RevokeCertificate");

error:
    Admin_Release(&diAdmin);
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


#if 0
HRESULT
Admin2_SetCAProperty(
    IN WCHAR const *pwszConfig,
    IN LONG PropId,		// CR_PROP_*
    IN LONG PropIndex,
    IN LONG PropType,		// PROPTYPE_*
    IN VARIANT *pvarPropertyValue)
{
}
#endif


HRESULT
Admin2_GetArchivedKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN LONG Flags,		// CR_OUT_*
    OUT BSTR *pstrArchivedKey)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;
	avar[2].vt = VT_I4;
	avar[2].lVal = Flags;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_GETARCHIVEDKEY,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrArchivedKey);
	_JumpIfError(hr, error, "Invoke(GetArchivedKey)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->GetArchivedKey(
						    strConfig,
						    RequestId,
						    Flags,
						    pstrArchivedKey);
	_JumpIfError(hr, error, "ICertAdmin::GetArchivedKey");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


#if 0
HRESULT
Admin2_GetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    OUT VARIANT *pvarEntry)
{
}
#endif


#if 0
HRESULT
Admin2_SetConfigEntry(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszNodePath,
    IN WCHAR const *pwszEntryName,
    IN VARIANT const *pvarEntry)
{
}
#endif


HRESULT
Admin2_ImportKey(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszCertHash,
    IN LONG Flags,
    IN WCHAR const *pwszKey,
    IN DWORD cbKey)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strCertHash = NULL;
    BSTR strKey = NULL;

    if (NULL == pwszKey || NULL == pwszConfig)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "NULL parm");
    }
    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pwszCertHash)
    {
	if (!ConvertWszToBstr(&strCertHash, pwszCertHash, -1))
	{
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }
    strKey = SysAllocStringByteLen((CHAR const *) pwszKey, cbKey);
    if (NULL == strKey)
    {
	_JumpError(hr, error, "SysAllocStringByteLen");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[5];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strCertHash;

	avar[3].vt = VT_I4;
	avar[3].lVal = Flags;

	avar[4].vt = VT_BSTR;
	avar[4].bstrVal = strKey;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_IMPORTKEY,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(ImportKey)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->ImportKey(
							strConfig,
							RequestId,
							strCertHash,
							Flags,
							strKey);
	_JumpIfError2(
		hr,
		error,
		"ICertAdmin::ImportKey",
		HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strCertHash)
    {
	SysFreeString(strCertHash);
    }
    if (NULL != strKey)
    {
	SysFreeString(strKey);
    }
    return(hr);
}


HRESULT
Admin2_GetMyRoles(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    OUT LONG *pRoles)		// CA_ACCESS_*
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_GETMYROLES,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pRoles);
	_JumpIfError(hr, error, "Invoke(GetMyRoles)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->GetMyRoles(
							strConfig,
							pRoles);
	_JumpIfError(hr, error, "ICertAdmin::GetMyRoles");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Admin2_DeleteRow(
    IN DISPATCHINTERFACE *pdiAdmin,
    IN WCHAR const *pwszConfig,
    IN LONG Flags,		// CDR_*
    IN DATE Date,
    IN LONG Table,		// CVRC_TABLE_*
    IN LONG RowId,
    OUT LONG *pcDeleted)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiAdmin && NULL != pdiAdmin->pDispatchTable);

    hr = AdminVerifyVersion(pdiAdmin, 2);
    _JumpIfError(hr, error, "AdminVerifyVersion");

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiAdmin->pDispatch)
    {
	VARIANT avar[5];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;
	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;
	avar[2].vt = VT_DATE;
	avar[2].date = Date;
	avar[3].vt = VT_I4;
	avar[3].lVal = Table;
	avar[4].vt = VT_I4;
	avar[4].lVal = RowId;

	hr = DispatchInvoke(
			pdiAdmin,
			ADMIN2_DELETEROW,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pcDeleted);
	_JumpIfError(hr, error, "Invoke(DeleteRow)");
    }
    else
    {
	hr = ((ICertAdmin2 *) pdiAdmin->pUnknown)->DeleteRow(
						    strConfig,
						    Flags,
						    Date,
						    Table,
						    RowId,
						    pcDeleted);
	_JumpIfError(hr, error, "ICertAdmin::DeleteRow");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


#undef __dwFILE__
#define CCERTADMIN
#include "prop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\acl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        acl.cpp
//
// Contents:    Access Control helpers for certsrv
//
// History:     11-16-98 petesk created
//              10/99 xtan, major changes
//
//---------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop
#include <ntdsapi.h>
#define SECURITY_WIN32

#include <security.h>
#include <sddl.h>
#include <aclapi.h>

#include "certca.h"
#include "cscsp.h"
#include "certacl.h"
#include "certsd.h"

#define __dwFILE__	__dwFILE_CERTLIB_ACL_CPP__


// defines

const GUID GUID_APPRV_REQ = { /* 0e10c966-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c966,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

const GUID GUID_REVOKE= { /* 0e10c967-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c967,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

// Important, keep enroll GUID in sync with string define in certacl.h
const GUID GUID_ENROLL = { /* 0e10c968-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c968,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

const GUID GUID_AUTOENROLL = { /* a05b8cc2-17bc-4802-a710-e7c15ab866a2 */
    0xa05b8cc2,
    0x17bc,
    0x4802,
    {0xa7, 0x10, 0xe7, 0xc1, 0x5a, 0xb8, 0x66, 0xa2} };

const GUID GUID_READ_DB = { /* 0e10c969-78fb-11d2-90d4-00c04f79dc55 */
    0x0e10c969,
    0x78fb,
    0x11d2,
    {0x90, 0xd4, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };

HRESULT
myGetSDFromTemplate(
    IN WCHAR const           *pwszStringSD,
    IN OPTIONAL WCHAR const  *pwszReplace,
    OUT PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT  hr;
    WCHAR   *pwszReplaceSD = NULL;
    WCHAR const *pwszFinalSD = pwszStringSD;  

    CSASSERT(NULL != ppSD);

    if (NULL == ppSD)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "null SD pointer");
    }

    if (NULL != pwszReplace)
    {
        // replace the token

        CSASSERT(NULL != wcsstr(pwszStringSD, L"%ws"));

        pwszReplaceSD = (WCHAR*)LocalAlloc(LMEM_FIXED, 
                            (wcslen(pwszStringSD) +
                             wcslen(pwszReplace) + 1) * sizeof(WCHAR) );
        if (NULL == pwszReplaceSD)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wsprintf(pwszReplaceSD, pwszStringSD, pwszReplace);
        pwszFinalSD = pwszReplaceSD;
    }

    // build the security descriptor including the local machine.
    if (!myConvertStringSecurityDescriptorToSecurityDescriptor(
							pwszFinalSD,
							SDDL_REVISION,
							ppSD,
							NULL))
    {
        hr = myHLastError();
        _JumpErrorStr(
		hr,
		error,
		"myConvertStringSecurityDescriptorToSecurityDescriptor",pwszFinalSD);
    }

    DBGPRINT((DBG_SS_CERTLIBI, "security descriptor:%ws\n", pwszFinalSD));

    hr = S_OK;
error:
    if (NULL != pwszReplaceSD)
    {
        LocalFree(pwszReplaceSD);
    }
    return hr;
}

HRESULT
myGetSecurityDescriptorDacl(
    IN PSECURITY_DESCRIPTOR   pSD, 
    OUT PACL                 *ppDacl) // no free
{
    HRESULT  hr;
    PACL     pDacl = NULL; //no free
    BOOL     bDaclPresent = FALSE;
    BOOL     bDaclDefaulted = FALSE;

    CSASSERT(NULL != ppDacl);

    //init
    *ppDacl = NULL;

    // get dacl pointers
    if (!GetSecurityDescriptorDacl(pSD,
                                   &bDaclPresent,
                                   &pDacl,
                                   &bDaclDefaulted))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }
    if(!bDaclPresent || (pDacl == NULL))
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    *ppDacl = pDacl;

    hr = S_OK;
error:
    return hr;
}

HRESULT
myGetSecurityDescriptorSacl(
    IN PSECURITY_DESCRIPTOR   pSD, 
    OUT PACL                 *ppSacl) // no free
{
    HRESULT  hr;
    PACL     pSacl = NULL; //no free
    BOOL     bSaclPresent = FALSE;
    BOOL     bSaclDefaulted = FALSE;

    CSASSERT(NULL != ppSacl);

    //init
    *ppSacl = NULL;

    // get dacl pointers
    if (!GetSecurityDescriptorSacl(pSD,
                                   &bSaclPresent,
                                   &pSacl,
                                   &bSaclDefaulted))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }
    if(!bSaclPresent || (pSacl == NULL))
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    *ppSacl = pSacl;

    hr = S_OK;
error:
    return hr;
}

#define  CERTSRV_DACL_CONTROL_MASK SE_DACL_AUTO_INHERIT_REQ | \
                                   SE_DACL_AUTO_INHERITED | \
                                   SE_DACL_PROTECTED
#define  CERTSRV_SACL_CONTROL_MASK SE_SACL_AUTO_INHERIT_REQ | \
                                   SE_SACL_AUTO_INHERITED | \
                                   SE_SACL_PROTECTED


// Merge parts of a new SD with an old SD based on the SI flags:
// DACL_SECURITY_INFORMATION    - use new SD DACL
// SACL_SECURITY_INFORMATION    - use new SD SACL
// OWNER_SECURITY_INFORMATION   - use new SD owner
// GROUP_SECURITY_INFORMATION   - use new SD group

HRESULT 
myMergeSD(
    IN PSECURITY_DESCRIPTOR   pSDOld,
    IN PSECURITY_DESCRIPTOR   pSDMerge, 
    IN SECURITY_INFORMATION   si,
    OUT PSECURITY_DESCRIPTOR *ppSDNew)
{
    HRESULT              hr;
    PSECURITY_DESCRIPTOR pSDDaclSource = 
        si & DACL_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDSaclSource = 
        si & SACL_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDOwnerSource = 
        si & OWNER_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDGroupSource = 
        si & GROUP_SECURITY_INFORMATION ? pSDMerge : pSDOld;
    PSECURITY_DESCRIPTOR pSDNew = NULL;
    PSECURITY_DESCRIPTOR pSDNewRelative = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    PACL                 pDacl = NULL; //no free
    PSID                 pGroupSid = NULL; //no free
    BOOL                 fGroupDefaulted = FALSE;
    PSID                 pOwnerSid = NULL; //no free
    BOOL                 fOwnerDefaulted = FALSE;
    DWORD                dwSize;
    BOOL                 fSaclPresent = FALSE;
    BOOL                 fSaclDefaulted = FALSE;
    PACL                 pSacl = NULL; //no free
    DWORD                dwRevision;

    CSASSERT(NULL != pSDOld);
    CSASSERT(NULL != pSDMerge);
    CSASSERT(NULL != ppSDNew);

    *ppSDNew = NULL;

    pSDNew = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, 
                                      SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pSDNew == NULL) 
    {     
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!InitializeSecurityDescriptor(pSDNew, SECURITY_DESCRIPTOR_REVISION))
    { 
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    // set SD control
    if (!GetSecurityDescriptorControl(pSDOld, &sdc, &dwRevision))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorControl");
    }

    if (!SetSecurityDescriptorControl(
             pSDNew,
             CERTSRV_DACL_CONTROL_MASK|
             CERTSRV_SACL_CONTROL_MASK,
             sdc &
             (CERTSRV_DACL_CONTROL_MASK|
              CERTSRV_SACL_CONTROL_MASK)))    
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    // get CA security acl info
    hr = myGetSecurityDescriptorDacl(
             pSDDaclSource,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");
    
    // set new SD dacl
    if(!SetSecurityDescriptorDacl(pSDNew, 
                                  TRUE,
                                  pDacl,
                                  FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    // set new SD group
    if(!GetSecurityDescriptorGroup(pSDGroupSource, &pGroupSid, &fGroupDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
    }
    if(!SetSecurityDescriptorGroup(pSDNew, pGroupSid, fGroupDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorGroup");
    }

    // set new SD owner
    if(!GetSecurityDescriptorOwner(pSDOwnerSource, &pOwnerSid, &fOwnerDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorGroup");
    }
    if(!SetSecurityDescriptorOwner(pSDNew, pOwnerSid, fOwnerDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorGroup");
    }

    // set new SD sacl
    if(!GetSecurityDescriptorSacl(pSDSaclSource, &fSaclPresent, &pSacl, &fSaclDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorSacl");
    }
    if(!SetSecurityDescriptorSacl(pSDNew, fSaclPresent, pSacl, fSaclDefaulted))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorSacl");
    }

    if (!IsValidSecurityDescriptor(pSDNew))
    {
        hr = myHLastError();
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    dwSize = GetSecurityDescriptorLength(pSDNew);
    pSDNewRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
    if(pSDNewRelative == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!MakeSelfRelativeSD(pSDNew, pSDNewRelative, &dwSize))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LocalAlloc");
    }

    if (!IsValidSecurityDescriptor(pSDNewRelative))
    {
        hr = myHLastError();
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    *ppSDNew = pSDNewRelative;
    pSDNewRelative = NULL;
    hr = S_OK;
error:
    if(pSDNew)
    {
        LocalFree(pSDNew);
    }
    if(pSDNewRelative)
    {
        LocalFree(pSDNewRelative);
    }
    return hr;
}


HRESULT
UpdateServiceSacl(bool fTurnOnAuditing)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSaclSD = NULL;
    PACL pSacl = NULL; // no free
    bool fPrivilegeEnabled = false;

    hr = myGetSDFromTemplate(
        fTurnOnAuditing?
        CERTSRV_SERVICE_SACL_ON:
        CERTSRV_SERVICE_SACL_OFF,
        NULL, // no insertion string
        &pSaclSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = myGetSecurityDescriptorSacl(
        pSaclSD,
        &pSacl);
    _JumpIfError(hr, error, "myGet");


    hr = myEnablePrivilege(SE_SECURITY_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    fPrivilegeEnabled = true;

    hr = SetNamedSecurityInfo(
            wszSERVICE_NAME,
            SE_SERVICE,
            SACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            NULL,
            pSacl);
    if(ERROR_SUCCESS != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "SetNamedSecurityInfo");
    }

error:

    if(fPrivilegeEnabled)
    {
        myEnablePrivilege(SE_SECURITY_NAME, FALSE);
    }
    LOCAL_FREE(pSaclSD);
    return hr;
}

HRESULT 
SetFolderDacl(LPCWSTR pcwszFolderPath, LPCWSTR pcwszSDDL)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD = NULL;

    hr = myGetSDFromTemplate(pcwszSDDL, NULL, &pSD);
    _JumpIfErrorStr(hr, error, "myGetSDFromTemplate", pcwszSDDL);

    if (!SetFileSecurity(
        pcwszFolderPath,
        DACL_SECURITY_INFORMATION,
        pSD))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetFileSecurity");
    }

error:

    LOCAL_FREE(pSD);

    return hr;
}


HRESULT
mySetKeyContainerSecurity(
    IN HCRYPTPROV hProv)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;

    hr = myGetSDFromTemplate(WSZ_DEFAULT_KEYCONTAINER_SECURITY, NULL, &pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    // apply the security descriptor to the key container
    if (!CryptSetProvParam(
			hProv,
			PP_KEYSET_SEC_DESCR,
			(BYTE *) pSD,
			(DWORD) DACL_SECURITY_INFORMATION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSetProvParam");
    }
    hr = S_OK;

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\advapi32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       advapi32.cpp
//
//  Contents:   advapi32.dll wrapper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

typedef BOOL (WINAPI FNSTRINGSDTOSD)(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL);

BOOL
myConvertStringSecurityDescriptorToSecurityDescriptor(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL)
{
    HMODULE hModule;
    BOOL f = FALSE;
    static FNSTRINGSDTOSD *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	// load dll
	hModule = GetModuleHandle(TEXT("advapi32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSTRINGSDTOSD *) GetProcAddress(
		       hModule,
		       "ConvertStringSecurityDescriptorToSecurityDescriptorW");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    f = (*s_pfn)(
	    StringSecurityDescriptor,
	    StringSDRevision,
	    SecurityDescriptor,
	    SecurityDescriptorSize);
    if (!f)
        goto error;
    
    myRegisterMemAlloc(
        *SecurityDescriptor, 
        ((NULL == SecurityDescriptorSize) ? -1 : *SecurityDescriptorSize), 
        CSM_LOCALALLOC);
error:
    return(f);
}


typedef BOOL (WINAPI FNSIDTOSTRINGSID)(
    IN  PSID    Sid,
    OUT LPWSTR *StringSid);

BOOL
myConvertSidToStringSid(
    IN  PSID    Sid,
    OUT LPWSTR *StringSid)
{
    HMODULE hModule;
    BOOL f = FALSE;
    static FNSIDTOSTRINGSID *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	// load dll
	hModule = GetModuleHandle(TEXT("advapi32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSIDTOSTRINGSID *) GetProcAddress(
					       hModule,
					       "ConvertSidToStringSidW");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    f = (*s_pfn)(Sid, StringSid);
    if (!f)
        goto error;

    myRegisterMemAlloc(*StringSid, -1, CSM_LOCALALLOC);

error:
    return(f);
}


typedef BOOL (WINAPI FNSTRINGSIDTOSID)(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid);

BOOL
myConvertStringSidToSid(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid)
{
    HMODULE hModule;
    BOOL f = FALSE;
    static FNSTRINGSIDTOSID *s_pfn = NULL;

    if (NULL == s_pfn)
    {
	// load dll
	hModule = GetModuleHandle(TEXT("advapi32.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	// load system function
	s_pfn = (FNSTRINGSIDTOSID *) GetProcAddress(
					       hModule,
					       "ConvertStringSidToSidW");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    f = (*s_pfn)(StringSid, Sid);
    if (!f)
        goto error;

    myRegisterMemAlloc(*Sid, -1, CSM_LOCALALLOC);

error:
    return(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\certlibp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlibp.h
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#ifndef __CERTLIBP_H__
#define __CERTLIBP_H__


char PrintableChar(char ch);

HRESULT
myGetCertSubjectCommonName(
    IN CERT_CONTEXT const *pCert,
    OUT WCHAR **ppwszCommonName);

#endif // __CERTLIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\casd.cpp ===
//+--------------------------------------------------------------------------
// File:        casd.cpp
// Contents:    CCertificateAuthoritySD implementation
//---------------------------------------------------------------------------
#include <pch.cpp>
#include <sid.h>
#include <certsd.h>
#include <certacl.h>
#include <sid.h>

#define __dwFILE__	__dwFILE_CERTLIB_CASD_CPP__


LPCWSTR const *CCertificateAuthoritySD::m_pcwszResources; // no free

using namespace CertSrv;

HRESULT CCertificateAuthoritySD::Set(
    const PSECURITY_DESCRIPTOR pSD,
    bool fSetDSSecurity)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSDCrt; // no free
    PSECURITY_DESCRIPTOR pSDNew = NULL;

    CSASSERT(NULL != pSD);

    hr = LockGet(&pSDCrt);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myMergeSD(pSDCrt, pSD, DACL_SECURITY_INFORMATION, &pSDNew);
    _JumpIfError(hr, error, "myMergeSD");

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");
    
    hr = CProtectedSecurityDescriptor::Set(pSDNew);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

    hr = MapAndSetDaclOnObjects(fSetDSSecurity);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAndSetDaclOnObjects");

error:
    LOCAL_FREE(pSDNew);
    return hr;
}

HRESULT CCertificateAuthoritySD::MapAndSetDaclOnObjects(bool fSetDSSecurity)
{
    HRESULT hr = S_OK;
    PACL pCADacl; // no free
    PACL pDSAcl = NULL;
    PACL pServiceAcl = NULL;
    PSECURITY_DESCRIPTOR pCASD; // no free
    ACL_SIZE_INFORMATION CAAclInfo, DefaultDSAclInfo, DefaultServiceAclInfo;
    DWORD dwIndex, dwIndex2, dwIndex3;
    PVOID pAce;
    DWORD dwDSAclSize=0, dwServiceAclSize=0;
    DWORD dwTempSize;

    hr = LockGet(&pCASD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myGetSecurityDescriptorDacl(
            pCASD,
            &pCADacl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    if(!GetAclInformation(pCADacl,
                          &CAAclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    // calculate the DACL size
    for(dwIndex = 0; dwIndex < CAAclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(pCADacl, dwIndex, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(fSetDSSecurity)
        {
            hr = MapAclGetSize(pAce, ObjType_DS, dwTempSize);
            _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclGetSize");

            dwDSAclSize += dwTempSize;
        }


        hr = MapAclGetSize(pAce, ObjType_Service, dwTempSize);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclGetSize");

        dwServiceAclSize += dwTempSize;
    }

    DefaultDSAclInfo.AceCount = 0;
    if(fSetDSSecurity)
    {
        hr = SetDefaultAcl(ObjType_DS);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::SetDefaultAcl");

        if(!GetAclInformation(m_pDefaultDSAcl,
                              &DefaultDSAclInfo,
                              sizeof(ACL_SIZE_INFORMATION),
                              AclSizeInformation))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAclInformation");
        }

        CSASSERT(0==DefaultDSAclInfo.AclBytesFree);

        dwDSAclSize += DefaultDSAclInfo.AclBytesInUse;

        pDSAcl = (PACL)LocalAlloc(LMEM_FIXED, dwDSAclSize);
        if(!pDSAcl)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if(!InitializeAcl(pDSAcl, dwDSAclSize, ACL_REVISION_DS ))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeAcl");
        }
    }

    hr = SetDefaultAcl(ObjType_Service);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::SetDefaultAcl");

    if(!GetAclInformation(m_pDefaultServiceAcl,
                          &DefaultServiceAclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    CSASSERT(0==DefaultServiceAclInfo.AclBytesFree);

    dwServiceAclSize += DefaultServiceAclInfo.AclBytesInUse;
    
    pServiceAcl = (PACL)LocalAlloc(LMEM_FIXED, dwServiceAclSize);
    if(!pServiceAcl)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!InitializeAcl(pServiceAcl, dwServiceAclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // copy deny aces from default service acl
    for(dwIndex = 0; dwIndex < DefaultServiceAclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(m_pDefaultServiceAcl, dwIndex, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_ACE_TYPE)
            continue;

        if(!AddAce(
                pServiceAcl, 
                ACL_REVISION, 
                MAXDWORD,
                pAce,
                ((ACE_HEADER*)pAce)->AceSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "AddAce");
        }
    }

    if(fSetDSSecurity)
    {
        // copy deny aces from default ds acl
        for(dwIndex3 = 0; dwIndex3 < DefaultDSAclInfo.AceCount; dwIndex3++) 
        {
            if(!GetAce(m_pDefaultDSAcl, dwIndex3, &pAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_ACE_TYPE &&
               ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_OBJECT_ACE_TYPE)
                continue;

            if(!AddAce(
                    pDSAcl, 
                    ACL_REVISION_DS, 
                    MAXDWORD,
                    pAce,
                    ((ACE_HEADER*)pAce)->AceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "AddAce");
            }
        }
    }

    // add mapped deny aces to the DACL
    for(dwIndex2 = 0;  dwIndex2 < CAAclInfo.AceCount; dwIndex2++) 
    {
        if(!GetAce(pCADacl, dwIndex2, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_DENIED_ACE_TYPE)
            continue;

        if(fSetDSSecurity)
        {
            hr = MapAclAddAce(pDSAcl, ObjType_DS, pAce);
            _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
        }

        hr = MapAclAddAce(pServiceAcl, ObjType_Service, pAce);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
    }

    // continue with the allow aces from default service acl
    for(dwIndex=0; dwIndex < DefaultServiceAclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(m_pDefaultServiceAcl, dwIndex, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)
            continue;

        if(!AddAce(
                pServiceAcl, 
                ACL_REVISION, 
                MAXDWORD,
                pAce,
                ((ACE_HEADER*)pAce)->AceSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "AddAce");
        }
    }

    // continue with the allow aces from default ds acl
    if(fSetDSSecurity)
    {
        for(dwIndex3=0; dwIndex3 < DefaultDSAclInfo.AceCount; dwIndex3++) 
        {
            if(!GetAce(m_pDefaultDSAcl, dwIndex3, &pAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_ACE_TYPE &&
                ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_OBJECT_ACE_TYPE)
                continue;

            if(!AddAce(
                    pDSAcl, 
                    ACL_REVISION_DS, 
                    MAXDWORD,
                    pAce,
                    ((ACE_HEADER*)pAce)->AceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "AddAce");
            }
        }
    }

    // continue with the allow mapped aces to the DACL
    for(dwIndex2=0;dwIndex2 < CAAclInfo.AceCount; dwIndex2++) 
    {
        if(!GetAce(pCADacl, dwIndex2, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        if(((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType != ACCESS_ALLOWED_ACE_TYPE)
        {
            continue;
        }

        if(fSetDSSecurity)
        {
            hr = MapAclAddAce(pDSAcl, ObjType_DS, pAce);
            _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
        }

        hr = MapAclAddAce(pServiceAcl, ObjType_Service, pAce);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclAddAce");
    }

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");

    hr = MapAclSetOnService(pServiceAcl);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclSetOnService");
    
    // set DACL on objects
    if(fSetDSSecurity)
    {
        hr = MapAclSetOnDS(pDSAcl);
        _JumpIfError(hr, error, "CCertificateAuthoritySD::MapAclSetOnDS");
    }

error:
    LOCAL_FREE(pDSAcl);
    LOCAL_FREE(pServiceAcl);
    return hr;
}


HRESULT CCertificateAuthoritySD::MapAclGetSize(
    PVOID pAce, 
    ObjType type, 
    DWORD& dwSize)
{
    ACCESS_ALLOWED_ACE *pAllowAce = (ACCESS_ALLOWED_ACE*)pAce;

    // CA acl should contain only ACCESS_ALLOWED_ACE_TYPE
    // and ACCESS_DENIED_ACE_TYPE
    if(ACCESS_ALLOWED_ACE_TYPE != pAllowAce->Header.AceType &&
       ACCESS_DENIED_ACE_TYPE  != pAllowAce->Header.AceType)
    {
        return E_INVALIDARG;
    }

    dwSize = 0;

    switch(type)
    {
    case ObjType_DS:
        // enroll access maps to enroll object ace on DS
        if(pAllowAce->Mask & CA_ACCESS_ENROLL)
        {
            dwSize = sizeof(ACCESS_ALLOWED_OBJECT_ACE) - sizeof(DWORD)+
                GetLengthSid((PSID)&(pAllowAce->SidStart));
        }
        break;
    case ObjType_Service:
        // ca admin maps to full control on service
        if(pAllowAce->Mask & CA_ACCESS_ADMIN)
        {
            dwSize = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)+
                GetLengthSid((PSID)&(pAllowAce->SidStart));
        }
        break;
    default:
        CSASSERT(CSExpr("Invalid object type" && 0));
    }

    return S_OK;
}

HRESULT CCertificateAuthoritySD::MapAclAddAce(
    PACL pAcl, 
    ObjType type, 
    PVOID pAce)
{
    ACCESS_ALLOWED_ACE *pCrtAce = (ACCESS_ALLOWED_ACE *)pAce;
    bool fAllowAce = (pCrtAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE);

    CSASSERT(pCrtAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE ||
             pCrtAce->Header.AceType == ACCESS_DENIED_ACE_TYPE);

    switch(type)
    {
    case ObjType_DS:
        // enroll access maps to enroll object ace on DS
        if(pCrtAce->Mask & CA_ACCESS_ENROLL)
        {
            if(fAllowAce)
            {
                if(!AddAccessAllowedObjectAce(
                        pAcl,
                        ACL_REVISION_DS,
                        NO_INHERITANCE,
                        ACTRL_DS_CONTROL_ACCESS,
                        const_cast<GUID*>(&GUID_ENROLL),
                        NULL,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
            else
            {
                if(!AddAccessDeniedObjectAce(
                        pAcl,
                        ACL_REVISION_DS,
                        NO_INHERITANCE,
                        ACTRL_DS_CONTROL_ACCESS,
                        const_cast<GUID*>(&GUID_ENROLL),
                        NULL,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
        }
        break;
    case ObjType_Service:
        // ca admin maps to start/stop service
        if(pCrtAce->Mask & CA_ACCESS_ADMIN)
        {
            if(fAllowAce)
            {
                if(!AddAccessAllowedAce(
                        pAcl,
                        ACL_REVISION,
                        SERVICE_START | SERVICE_STOP,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
            else
            {
                if(!AddAccessDeniedAce(
                        pAcl,
                        ACL_REVISION,
                        SERVICE_START | SERVICE_STOP,
                        &pCrtAce->SidStart))
                {
                    return myHLastError();
                }
            }
        }
        break;
    default:
        CSASSERT(CSExpr("Invalid object type" && 0));
    }

    return S_OK;
}

HRESULT CCertificateAuthoritySD::SetDefaultAcl(ObjType type)
{
    HRESULT hr = S_OK;
    
    switch(type)
    {
    case ObjType_DS:
        if(!m_pDefaultDSAcl)
        {
            hr = SetComputerSID();
            _JumpIfError(hr, error, "SetComputerSID");

            CSASSERT(!m_pDefaultDSSD);
            hr = myGetSDFromTemplate(
                    WSZ_DEFAULT_DSENROLLMENT_SECURITY,
                    m_pwszComputerSID,
                    &m_pDefaultDSSD);
            _JumpIfError(hr, error, "myGetSDFromTemplate");
            
            hr = myGetSecurityDescriptorDacl(
                    m_pDefaultDSSD,
                    &m_pDefaultDSAcl);
            _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");
        }
        break;

    case ObjType_Service:
        if(!m_pDefaultServiceAcl)
        {
            CSASSERT(!m_pDefaultServiceSD);
            hr = myGetSDFromTemplate(
                    WSZ_DEFAULT_SERVICE_SECURITY,
                    NULL,
                    &m_pDefaultServiceSD);
            _JumpIfError(hr, error, "myGetSDFromTemplate");
            
            hr = myGetSecurityDescriptorDacl(
                    m_pDefaultServiceSD,
                    &m_pDefaultServiceAcl);
            _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

        }
        break;
    }
    
error:
    return hr;
}

HRESULT CCertificateAuthoritySD::SetComputerSID()
{
    HRESULT hr = S_OK;
    LPWSTR pwszDomainName = NULL;
    DWORD cDomainName = 0;
    LPWSTR pwszComputerName = NULL;
    DWORD cbSid;
    SID_NAME_USE SidUse;
    PBYTE pComputerSID = NULL;

    CSASSERT(!m_pwszComputerSID);

    hr = myGetComputerObjectName(NameSamCompatible, &pwszComputerName);
    _JumpIfError(hr, error, "myGetComputerObjectName");

    LookupAccountName(
                NULL,
                pwszComputerName,
                NULL,
                &cbSid,
                NULL,
                &cDomainName,
                &SidUse);
    if(GetLastError()!=ERROR_INSUFFICIENT_BUFFER)
    {
        hr = myHLastError();
        _JumpError(hr, error, "LookupAccountName");
    }
    
    pwszDomainName = (LPWSTR)LocalAlloc(
                                LMEM_FIXED, 
                                cDomainName*sizeof(WCHAR));
    if(!pwszDomainName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    pComputerSID = (LPBYTE)LocalAlloc(
                                LMEM_FIXED, 
                                cbSid);
    if(!pComputerSID)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    if(!LookupAccountName(
                NULL,
                pwszComputerName,
                pComputerSID,
                &cbSid,
                pwszDomainName,
                &cDomainName,
                &SidUse))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LookupAccountName");
    }

    if(!myConvertSidToStringSid(
            pComputerSID,
            &m_pwszComputerSID))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myConvertSidToStringSid");
    }

error:
    LOCAL_FREE(pwszComputerName);
    LOCAL_FREE(pwszDomainName);
    LOCAL_FREE(pComputerSID);
    return hr;
}


typedef LPCWSTR (WINAPI FNCAGETDN)(
    IN HCAINFO hCAInfo);

LPCWSTR
myCAGetDN(
    IN HCAINFO hCAInfo)
{
    HMODULE hModule;
    static FNCAGETDN *s_pfn = NULL;
    LPCWSTR pwszCADN = NULL;

    if (NULL == s_pfn)
    {
	hModule = GetModuleHandle(TEXT("certcli.dll"));
	if (NULL == hModule)
	{
            goto error;
	}

	s_pfn = (FNCAGETDN *) GetProcAddress(hModule, "CAGetDN");
	if (NULL == s_pfn)
	{
	    goto error;
	}
    }
    pwszCADN = (*s_pfn)(hCAInfo);

error:
    return(pwszCADN);
}


HRESULT CCertificateAuthoritySD::MapAclSetOnDS(const PACL pAcl)
{
    HRESULT hr = S_OK;
    LPWSTR pwszSanitizedDSName = NULL;
    HCAINFO hCAInfo = NULL;
    LPCWSTR pwszCADN;

	hr = mySanitizedNameToDSName(m_pcwszSanitizedName, &pwszSanitizedDSName);
	_JumpIfError(hr, error, "mySanitizedNameToDSName");

    hr = CAFindByName(
		  pwszSanitizedDSName,
		  NULL,
		  CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		  &hCAInfo);
	_JumpIfErrorStr(hr, error, "CAFindByName", pwszSanitizedDSName);

    pwszCADN = myCAGetDN(hCAInfo);
    if (NULL == pwszCADN)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCAGetDN");
    }

    hr = SetNamedSecurityInfo(
            const_cast<LPWSTR>(pwszCADN),
            SE_DS_OBJECT_ALL,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            pAcl,
            NULL);
    if(ERROR_SUCCESS != hr)
    {

        if ((HRESULT) ERROR_ACCESS_DENIED == hr)
        {
            // If we can't set the acl on ds enrollment object, notify
            // the caller with a special error code so it can take action.
            // See bug# 193388
            hr = ERROR_CAN_NOT_COMPLETE;
        }

        hr = myHError(hr);
        _JumpError(hr, error, "SetNamedSecurityInfo");
    }

error:
    LOCAL_FREE(pwszSanitizedDSName);
    if(hCAInfo)
        CACloseCA(hCAInfo);
    return hr;
}

HRESULT CCertificateAuthoritySD::MapAclSetOnService(const PACL pAcl)
{
    HRESULT hr = S_OK;

    hr = SetNamedSecurityInfo(
            wszSERVICE_NAME,
            SE_SERVICE,
            DACL_SECURITY_INFORMATION,
            NULL,
            NULL,
            pAcl,
            NULL);
    if(ERROR_SUCCESS != hr)
    {
        hr = myHError(hr);
        _JumpError(hr, error, "SetNamedSecurityInfo");
    }

error:

    return hr;
}

HRESULT CCertificateAuthoritySD::ResetSACL()
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSaclSD = NULL;
    PSECURITY_DESCRIPTOR pSDCrt; // no free
    PSECURITY_DESCRIPTOR pSDNew = NULL;

    hr = myGetSDFromTemplate(
            CERTSRV_SACL_ON,
            NULL,
            &pSaclSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = LockGet(&pSDCrt);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myMergeSD(pSDCrt, pSaclSD, SACL_SECURITY_INFORMATION, &pSDNew);
    _JumpIfError(hr, error, "myMergeSD");

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");
    
    hr = CProtectedSecurityDescriptor::Set(pSDNew);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    LOCAL_FREE(pSaclSD);
    LOCAL_FREE(pSDNew);
    return hr;
}

// Upgrade from CA security descriptor from win2k. 
//
// Allow aces are mapped as follows:
//      manage   -> CA admin + officer
//      enroll   -> enroll
//      read     -> read
//      revoke   -> officer
//      approve  -> officer
//      else     -> read
//
// Deny aces are ignored.

HRESULT CCertificateAuthoritySD::UpgradeWin2k(
    bool fUseEnterpriseAcl)
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSDOld; // no free
    PACL pAclOld; // no free
    PSECURITY_DESCRIPTOR pSDNewDaclOnly = NULL;
    PSECURITY_DESCRIPTOR pSDNewSaclOnly = NULL;
    PSECURITY_DESCRIPTOR pSDNew = NULL;
    PACL pAclNew = NULL;
    ACL_SIZE_INFORMATION OldAclSizeInfo;
    DWORD dwSizeAclNew = sizeof(ACL);
    DWORD cAce;
    PVOID pAce;
    ACCESS_MASK dwAccessMask;
    PSID pSid; // no free

    hr = LockGet(&pSDOld);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::LockGet");

    hr = myGetSecurityDescriptorDacl(
            pSDOld,
            &pAclOld);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    if(!GetAclInformation(pAclOld,
                          &OldAclSizeInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    for(cAce=0;cAce<OldAclSizeInfo.AceCount;cAce++)
    {
        if(!GetAce(pAclOld, cAce, &pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        dwSizeAclNew += GetUpgradeAceSizeAndType(pAce, NULL, NULL);
    }

    // if no valid ACE found, fall back to a default SD
    if(sizeof(ACL)==dwSizeAclNew)
    {
        hr= myGetSDFromTemplate(
                fUseEnterpriseAcl?
                WSZ_DEFAULT_CA_ENT_SECURITY:
                WSZ_DEFAULT_CA_STD_SECURITY,
                NULL,
                &pSDNew);
        _JumpIfError(hr, error, "myGetSDFromTemplate");
    }
    else
    {
        pAclNew = (PACL)LocalAlloc(LMEM_FIXED, dwSizeAclNew);
        if(!pAclNew)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");

        }

        FillMemory(pAclNew, dwSizeAclNew, L' ');
        if(!InitializeAcl(pAclNew, dwSizeAclNew, ACL_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeAcl");
        }

        for(cAce=0;cAce<OldAclSizeInfo.AceCount;cAce++)
        {
            if(!GetAce(pAclOld, cAce, &pAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(GetUpgradeAceSizeAndType(
                    pAce, 
                    &dwAccessMask,
                    &pSid))
            {
                BYTE acetype = ((ACCESS_ALLOWED_ACE*)pAce)->Header.AceType;
                switch(acetype)
                {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    if(!AddAccessAllowedAce(
                            pAclNew,
                            ACL_REVISION,
                            dwAccessMask,
                            pSid))
                    {
                        hr = myHLastError();
                        _JumpError(hr, error, "AddAccessAllowed");
                    }
                    break;
                case ACCESS_DENIED_ACE_TYPE:
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    if(!AddAccessDeniedAce(
                            pAclNew,
                            ACL_REVISION,
                            dwAccessMask,
                            pSid))
                    {
                        hr = myHLastError();
                        _JumpError(hr, error, "AddAccessAllowed");
                    }
                    break;
                }
            }
        }

        // Build a new SD based on this DACL

        pSDNewDaclOnly = (PSECURITY_DESCRIPTOR)LocalAlloc(
                            LMEM_FIXED,
                            SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (!pSDNewDaclOnly)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        if (!InitializeSecurityDescriptor(
                pSDNewDaclOnly, 
                SECURITY_DESCRIPTOR_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeSecurityDescriptor");
        }

        if(!SetSecurityDescriptorDacl(pSDNewDaclOnly,
                                      TRUE,
                                      pAclNew,
                                      FALSE))
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetSecurityDescriptorDacl");
        }

        hr= myGetSDFromTemplate(
                WSZ_DEFAULT_CA_STD_SECURITY,
                NULL,
                &pSDNewSaclOnly);
        _JumpIfError(hr, error, "myGetSDFromTemplate");

        // merge SACL & DACL in new SD
        hr = myMergeSD(
                pSDNewSaclOnly, 
                pSDNewDaclOnly, 
                DACL_SECURITY_INFORMATION, 
                &pSDNew);
        _JumpIfError(hr, error, "myMergeSD");

        CSASSERT(IsValidSecurityDescriptor(pSDNew));
    }

    hr = Unlock();
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Unlock");

    hr = CProtectedSecurityDescriptor::Set(pSDNew);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    LOCAL_FREE(pSDNew);
    LOCAL_FREE(pSDNewSaclOnly);
    LOCAL_FREE(pSDNewDaclOnly);
    LOCAL_FREE(pAclNew);
    return hr;
}


DWORD CCertificateAuthoritySD::GetUpgradeAceSizeAndType(
    PVOID pAce, DWORD *pdwType, PSID *ppSid)
{
    DWORD dwSize = 0;
    PSID pSid = NULL;
    DWORD dwType = 0;

    switch(((PACCESS_ALLOWED_ACE)pAce)->Header.AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
        pSid = (PSID)&(((PACCESS_ALLOWED_ACE)pAce)->SidStart);
        dwSize = sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+GetLengthSid(pSid);

        switch(((PACCESS_ALLOWED_ACE)pAce)->Mask)
        {
        case ACTRL_CERTSRV_MANAGE:
            dwType = CA_ACCESS_ADMIN | CA_ACCESS_OFFICER;
            break;
        default: // including ACTRL_CERTSRV_READ
            dwType = CA_ACCESS_READ;
        }
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:

        PACCESS_ALLOWED_OBJECT_ACE pObjAce = (PACCESS_ALLOWED_OBJECT_ACE)pAce;

        pSid = (PSID)(((BYTE*)(&pObjAce->ObjectType))+
                ((pObjAce->Flags&ACE_OBJECT_TYPE_PRESENT)? 
                sizeof(pObjAce->ObjectType):0)+
                ((pObjAce->Flags&ACE_INHERITED_OBJECT_TYPE_PRESENT)? 
                sizeof(pObjAce->InheritedObjectType):0));

        dwSize = sizeof(ACCESS_ALLOWED_ACE)-sizeof(DWORD)+GetLengthSid(pSid);

        REFGUID rGUID = (((PACCESS_ALLOWED_OBJECT_ACE)pAce)->ObjectType);
        if(IsEqualGUID(rGUID, GUID_ENROLL))
        {
            dwType = CA_ACCESS_ENROLL;
        } else
        if(IsEqualGUID(rGUID, GUID_APPRV_REQ) ||
           IsEqualGUID(rGUID, GUID_REVOKE))
        {
            dwType = CA_ACCESS_OFFICER;
        } else
        {
            dwType = CA_ACCESS_READ;
        }
        break;

    // denied aces are not upgraded so ignore them
    }

    if(ppSid)
        *ppSid = pSid;
    if(pdwType)
        *pdwType = dwType;

    return dwSize;
}

// Returns:
// - E_INVALIDARG: invalid ACEs found,
// - S_FALSE: no admin ACE found (to avoid admins locking themselves out)
HRESULT CCertificateAuthoritySD::Validate(PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr;
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwIndex;
    PACCESS_ALLOWED_ACE pAce; // no free
    PACL pDacl; // no free
    bool fAdminAceFound = false;
    DWORD dwKnownRights =   CA_ACCESS_ADMIN     |
                            CA_ACCESS_OFFICER   |
                            CA_ACCESS_READ      |
                            CA_ACCESS_ENROLL;

    if(!IsValidSecurityDescriptor(pSD))
    {
        hr = myHLastError();
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    // get acl
    hr = myGetSecurityDescriptorDacl(
             pSD,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        // only access allowed/denied aces and know rights are allowed
        if((ACCESS_ALLOWED_ACE_TYPE!=pAce->Header.AceType &&
            ACCESS_DENIED_ACE_TYPE !=pAce->Header.AceType) ||
           (~dwKnownRights & pAce->Mask))
        {
            return E_INVALIDARG;
        }

        if((CA_ACCESS_ADMIN & pAce->Mask) &&
           (ACCESS_ALLOWED_ACE_TYPE==pAce->Header.AceType))
        {
            fAdminAceFound = true;
        }
    }

    // no caadmin allow ace found
    hr = fAdminAceFound?S_OK:CERTSRV_E_NO_CAADMIN_DEFINED;

error:
    return hr;
}

HRESULT CCertificateAuthoritySD::ConvertToString(
    IN PSECURITY_DESCRIPTOR pSD,
    OUT LPWSTR& rpwszSD)
{
    HRESULT hr = S_OK;
    LPCWSTR pcwszHeader = L"\n"; // start with a new line
    DWORD dwBufSize = sizeof(WCHAR)*(wcslen(pcwszHeader)+1);
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwIndex;
    PACCESS_ALLOWED_ACE pAce; // no free
    PACL pDacl; // no free
    LPWSTR pwszAce; // no free
    
    rpwszSD = NULL;

    hr = Validate(pSD);
    _JumpIfError(hr, error, "CCertificateAuthoritySD::Validate");

    // get acl
    hr = myGetSecurityDescriptorDacl(
             pSD,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }
    
    
    // calculate text size

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            NULL);
        _JumpIfError(hr, error, "ConvertAceToString");

        dwBufSize += dwAceSize;
    }

    rpwszSD = (LPWSTR)LocalAlloc(LMEM_FIXED, dwBufSize);
    _JumpIfAllocFailed(rpwszSD, error);

    // build the output string
    wcscpy(rpwszSD, pcwszHeader);
    
    pwszAce = rpwszSD + wcslen(pcwszHeader);

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            pwszAce);
        _JumpIfError(hr, error, "ConvertAceToString");

        pwszAce += dwAceSize/sizeof(WCHAR);
    }

error:
    return hr;
}

// Returned string has the following format:
//
// [Allow|Deny]\t[Name|SID]\n
// \tRole1\n
// \tRole2\n
// ...
//
// Example:
//
// Allow    Administrators
//      CA Administrator
//      Certificate Manager
//
// If SID cannot be converted to friendly name it is displayed
// as a string SID
//
HRESULT CCertificateAuthoritySD::ConvertAceToString(
    IN PACCESS_ALLOWED_ACE pAce,
    OUT OPTIONAL PDWORD pdwSize,
    IN OUT OPTIONAL LPWSTR pwszSD)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 1; // trailing '\0'
    CSid sid((PSID)(&pAce->SidStart));
    
    LPCWSTR pcwszAllow      = m_pcwszResources[0];
    LPCWSTR pcwszDeny       = m_pcwszResources[1];

    LPCWSTR pcwszPermissionType = 
        (ACCESS_ALLOWED_ACE_TYPE==pAce->Header.AceType)?
        pcwszAllow:pcwszDeny;
    LPCWSTR pcwszSid; // no free

    DWORD dwRoles[] = 
    {
        CA_ACCESS_ADMIN,
        CA_ACCESS_OFFICER,
        CA_ACCESS_READ,
        CA_ACCESS_ENROLL,
    };

    // dwRoles and resources should match the roles
    const LPCWSTR *pcwszRoles = &m_pcwszResources[2];

    DWORD cRoles;

    // asked for size and/or ace string
    CSASSERT(pdwSize || pwszSD);

    pcwszSid = sid.GetName();
    if(!pcwszSid)
    {
        return E_OUTOFMEMORY;
    }
    
    dwSize = wcslen(pcwszSid);

    dwSize += wcslen(pcwszPermissionType);
    
    dwSize += 2; // '\t' between sid an permission and a '\n' after

    if(pwszSD)
    {
        wcscat(pwszSD, pcwszPermissionType);
        wcscat(pwszSD, L"\t");
        wcscat(pwszSD, pcwszSid);
        wcscat(pwszSD, L"\n");
    }


    for(cRoles=0;cRoles<ARRAYSIZE(dwRoles);cRoles++)
    {
        if(pAce->Mask & dwRoles[cRoles])
        {
            dwSize += wcslen(pcwszRoles[cRoles]) + 2; // "\tRole\n"
            if(pwszSD)
            {
                wcscat(pwszSD, L"\t");
                wcscat(pwszSD, pcwszRoles[cRoles]);
                wcscat(pwszSD, L"\n");
            }
        }
    }

    dwSize *= sizeof(WCHAR);

    if(pdwSize)
    {
        *pdwSize = dwSize;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <esent.h>

#include "certdb.h"
#include "cscsp.h"
#include "certlibp.h"

#define __dwFILE__	__dwFILE_CERTLIB_BACKUP_CPP__

#define _64k		(64 * 1024)


DWORD
_64kBlocks(
    IN DWORD nFileSizeHigh,
    IN DWORD nFileSizeLow)
{
    LARGE_INTEGER li;

    li.HighPart = nFileSizeHigh;
    li.LowPart = nFileSizeLow;
    return((DWORD) ((li.QuadPart + _64k - 1) / _64k));
}


HRESULT
myLargeAlloc(
    OUT DWORD *pcbLargeAlloc,
    OUT BYTE **ppbLargeAlloc)
{
    HRESULT hr;

    // at 512k the server begins doing efficient backups
    *pcbLargeAlloc = 512 * 1024;
    *ppbLargeAlloc = (BYTE *) VirtualAlloc(
				    NULL,
				    *pcbLargeAlloc,
				    MEM_COMMIT,
				    PAGE_READWRITE);
    if (NULL == *ppbLargeAlloc)
    {
        // couldn't alloc a large chunk?  Try 64k...

	*pcbLargeAlloc = _64k;
        *ppbLargeAlloc = (BYTE *) VirtualAlloc(
					NULL,
					*pcbLargeAlloc,
					MEM_COMMIT,
					PAGE_READWRITE);
        if (NULL == *ppbLargeAlloc)
        {
            hr = myHLastError();
	    _JumpError(hr, error, "VirtualAlloc");
        }
    }
    hr = S_OK;

error:
    return(hr);
}


// Files to look for when checking for an existing DB, AND
// Files to delete when clearing out a DB or DB Log directory:
// Do NOT delete certsrv.mdb from Cert server 1.0!

WCHAR const * const g_apwszDBFileMatchPatterns[] =
{
    L"res*.log",
    TEXT(szDBBASENAMEPARM) L"*.log",	// "edb*.log"
    TEXT(szDBBASENAMEPARM) L"*.chk",	// "edb*.chk"
    L"*" wszDBFILENAMEEXT,		// "*.edb"
    NULL
};


HRESULT
myDeleteDBFilesInDir(
    IN WCHAR const *pwszDir)
{
    HRESULT hr;
    WCHAR const * const *ppwsz;

    for (ppwsz = g_apwszDBFileMatchPatterns; NULL != *ppwsz; ppwsz++)
    {
	hr = myDeleteFilePattern(pwszDir, *ppwsz, FALSE);
        _JumpIfError(hr, error, "myDeleteFilePattern");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DoFilesExistInDir(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszPattern,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WCHAR *pwszFindPattern = NULL;
    WIN32_FIND_DATA wfd;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    hr = myBuildPathAndExt(pwszDir, pwszPattern, NULL, &pwszFindPattern);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hf = FindFirstFile(pwszFindPattern, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = S_OK;
	goto error;
    }
    do
    {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}

	//printf("File: %ws\n", wfd.cFileName);
	*pfFilesExist = TRUE;

	if (NULL != ppwszFileInUse)
	{
	    WCHAR *pwszFile;

	    hr = myBuildPathAndExt(pwszDir, wfd.cFileName, NULL, &pwszFile);
	    _JumpIfError(hr, error, "myBuildPathAndExt");

	    if (myIsFileInUse(pwszFile))
	    {
		DBGPRINT((
		    DBG_SS_CERTLIB,
		    "DoFilesExistInDir: File In Use: %ws\n",
		    pwszFile));

		*ppwszFileInUse = pwszFile;
		hr = S_OK;
		goto error;
	    }
	    LocalFree(pwszFile);
	}

    } while (FindNextFile(hf, &wfd));
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    if (NULL != pwszFindPattern)
    {
	LocalFree(pwszFindPattern);
    }
    return(hr);
}


HRESULT
myDoDBFilesExistInDir(
    IN WCHAR const *pwszDir,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    WCHAR const * const *ppwsz;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    hr = S_OK;
    for (ppwsz = g_apwszDBFileMatchPatterns; NULL != *ppwsz; ppwsz++)
    {
	BOOL fFilesExist;

	hr = DoFilesExistInDir(
			    pwszDir,
			    *ppwsz,
			    &fFilesExist,
			    ppwszFileInUse);
	_JumpIfError(hr, error, "DoFilesExistInDir");

	if (fFilesExist)
	{
	    *pfFilesExist = TRUE;
	}
	if (NULL != ppwszFileInUse && NULL != *ppwszFileInUse)
	{
	    break;
	}
    }
    CSASSERT(S_OK == hr);

error:
    return(hr);
}


HRESULT
DoDBFilesExistInRegDir(
    IN WCHAR const *pwszRegName,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    WCHAR *pwszDir = NULL;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    hr = myGetCertRegStrValue(NULL, NULL, NULL, pwszRegName, &pwszDir);
    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // reg entry doesn't exist, that's fine
            goto done;
        }
        _JumpError(hr, error, "myGetCertRegStrValue");
    }

    hr = myDoDBFilesExistInDir(pwszDir, pfFilesExist, ppwszFileInUse);
    _JumpIfError(hr, error, "myDoDBFilesExistInDir");

done:
    hr = S_OK;
error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    return(hr);
}


HRESULT
BuildDBFileName(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszDBFile)
{
    HRESULT hr;
    WCHAR *pwszDir = NULL;

    *ppwszDBFile = NULL;

    // get existing db path

    hr = myGetCertRegStrValue(NULL, NULL, NULL, wszREGDBDIRECTORY, &pwszDir);
    _JumpIfError(hr, error, "myGetCertRegStrValue");

    // form existing db file path
    hr = myBuildPathAndExt(
		    pwszDir,
		    pwszSanitizedName,
		    wszDBFILENAMEEXT,
		    ppwszDBFile);
    _JumpIfError(hr, error, "myBuildPathAndExt");

error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    return(hr);
}


WCHAR const * const g_apwszDBRegNames[] =
{
    wszREGDBDIRECTORY,
    wszREGDBLOGDIRECTORY,
    wszREGDBSYSDIRECTORY,
    wszREGDBTEMPDIRECTORY,
    NULL
};


// Verify that the DB and DB Log directories in the registry contain existing
// DB files, to decide whether the DB could be reused by cert server setup.
// Also see if any of the DB files are in use -- we don't want to point to the
// same directory as the DS DB and trash the DS, for example.

HRESULT
myDoDBFilesExist(
    IN WCHAR const *pwszSanitizedName,
    OUT BOOL *pfFilesExist,
    OPTIONAL OUT WCHAR **ppwszFileInUse)
{
    HRESULT hr;
    WCHAR const * const *ppwsz;
    WCHAR *pwszDBFile = NULL;

    *pfFilesExist = FALSE;
    if (NULL != ppwszFileInUse)
    {
	*ppwszFileInUse = NULL;
    }

    // this is very primitive, just check for existence

    // get existing db file path

    hr = BuildDBFileName(pwszSanitizedName, &pwszDBFile);
    if (S_OK == hr)
    {
	// If the main DB file doesn't exist, there's no point in continuing!

	if (!myDoesFileExist(pwszDBFile))
	{
	    CSASSERT(S_OK == hr);
	    goto error;
	}
	*pfFilesExist = TRUE;

	if (NULL != ppwszFileInUse && myIsFileInUse(pwszDBFile))
	{
	    *ppwszFileInUse = pwszDBFile;
	    pwszDBFile = NULL;
	    CSASSERT(S_OK == hr);
	    goto error;
	}
    }
    else
    {
        _PrintError(hr, "BuildDBFileName");
    }

    for (ppwsz = g_apwszDBRegNames; NULL != *ppwsz; ppwsz++)
    {
	BOOL fFilesExist;

	hr = DoDBFilesExistInRegDir(*ppwsz, &fFilesExist, ppwszFileInUse);
	_JumpIfError(hr, error, "DoDBFilesExistInRegDir");

	if (fFilesExist)
	{
	    *pfFilesExist = TRUE;
	}
	if (NULL != ppwszFileInUse && NULL != *ppwszFileInUse)
	{
	    CSASSERT(S_OK == hr);
	    goto error;
	}
    }
    CSASSERT(S_OK == hr);

error:
    if (NULL != pwszDBFile)
    {
        LocalFree(pwszDBFile);
    }
    return(hr);
}


HRESULT
BackupCopyDBFile(
    IN HCSBC hcsbc,
    IN WCHAR const *pwszDBFile,
    IN WCHAR const *pwszBackupFile,
    IN DWORD dwPercentCompleteBase,
    IN DWORD dwPercentCompleteDelta,
    OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    HRESULT hr2;
    HANDLE hFileBackup = INVALID_HANDLE_VALUE;
    BOOL fOpen = FALSE;
    LARGE_INTEGER licbFile;
    DWORD cbRead;
    DWORD cbWritten;
    DWORD dwPercentCompleteCurrent;
    DWORD ReadLoopMax;
    DWORD ReadLoopCurrent;
    DWORD cbLargeAlloc;
    BYTE *pbLargeAlloc = NULL;

    hr = myLargeAlloc(&cbLargeAlloc, &pbLargeAlloc);
    _JumpIfError(hr, error, "myLargeAlloc");

    //printf("Copy %ws to %ws\n", pwszDBFile, pwszBackupFile);

    hr = CertSrvBackupOpenFile(hcsbc, pwszDBFile, cbLargeAlloc, &licbFile);
    _JumpIfError(hr, error, "CertSrvBackupOpenFile");

    fOpen = TRUE;

    hFileBackup = CreateFile(
			pwszBackupFile,
			GENERIC_WRITE,
			0,
			NULL,
			CREATE_NEW,
			0,
			NULL);
    if (hFileBackup == INVALID_HANDLE_VALUE)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszBackupFile);
    }

    dwPercentCompleteCurrent = dwPercentCompleteBase;
    ReadLoopMax =
	(DWORD) ((licbFile.QuadPart + cbLargeAlloc - 1) / cbLargeAlloc);

    //printf("BackupDBFile: Percent per Read = %u, read count = %u\n", dwPercentCompleteDelta / ReadLoopMax, ReadLoopMax);

    ReadLoopCurrent = 0;

    while (0 != licbFile.QuadPart)
    {
	hr = CertSrvBackupRead(hcsbc, pbLargeAlloc, cbLargeAlloc, &cbRead);
	_JumpIfError(hr, error, "CertSrvBackupRead");

	//printf("CertSrvBackupRead(%x)\n", cbRead);

	if (!WriteFile(hFileBackup, pbLargeAlloc, cbRead, &cbWritten, NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "WriteFile", pwszBackupFile);
	}
	if (cbWritten != cbRead)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
	    _JumpErrorStr(hr, error, "WriteFile", pwszBackupFile);
	}
	licbFile.QuadPart -= cbRead;

	ReadLoopCurrent++;

	dwPercentCompleteCurrent =
		dwPercentCompleteBase +
		(ReadLoopCurrent * dwPercentCompleteDelta) / ReadLoopMax;
	CSASSERT(dwPercentCompleteCurrent <= dwPercentCompleteBase + dwPercentCompleteDelta);
	CSASSERT(*pdwPercentComplete <= dwPercentCompleteCurrent);
	*pdwPercentComplete = dwPercentCompleteCurrent;
	//printf("BackupDBFile: PercentComplete = %u\n", *pdwPercentComplete);
    }
    CSASSERT(*pdwPercentComplete <= dwPercentCompleteBase + dwPercentCompleteDelta);
    *pdwPercentComplete = dwPercentCompleteBase + dwPercentCompleteDelta;
    //printf("BackupDBFile: PercentComplete = %u (EOF)\n", *pdwPercentComplete);

error:
    if (INVALID_HANDLE_VALUE != hFileBackup)
    {
	CloseHandle(hFileBackup);
    }
    if (fOpen)
    {
	hr2 = CertSrvBackupClose(hcsbc);
	_PrintIfError(hr2, "CertSrvBackupClose");
    }
    if (NULL != pbLargeAlloc)
    {
	VirtualFree(pbLargeAlloc, 0, MEM_RELEASE);
    }
    return(hr);
}


HRESULT
BackupDBFileList(
    IN HCSBC hcsbc,
    IN BOOL fDBFiles,
    IN WCHAR const *pwszDir,
    OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    WCHAR *pwszzList = NULL;
    WCHAR const *pwsz;
    DWORD cfile;
    DWORD cb;
    WCHAR const *pwszFile;
    WCHAR wszPath[MAX_PATH];
    DWORD dwPercentCompleteCurrent;
    DWORD dwPercentComplete1File;

    if (fDBFiles)
    {
	hr = CertSrvBackupGetDatabaseNames(hcsbc, &pwszzList, &cb);
	_JumpIfError(hr, error, "CertSrvBackupGetDatabaseNames");
    }
    else
    {
	hr = CertSrvBackupGetBackupLogs(hcsbc, &pwszzList, &cb);
	_JumpIfError(hr, error, "CertSrvBackupGetBackupLogs");
    }

    // prefix complains this might happen, then deref'd below
    if (pwszzList == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "BackupDBFileList");
    }

    cfile = 0;
    for (pwsz = pwszzList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	cfile++;
    }
    if (0 != cfile)
    {
	dwPercentCompleteCurrent = 0;
	dwPercentComplete1File = 100 / cfile;
	//printf("BackupDBFileList: Percent per File = %u\n", dwPercentComplete1File);
	for (pwsz = pwszzList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    pwszFile = wcsrchr(pwsz, L'\\');
	    if (NULL == pwszFile)
	    {
		pwszFile = pwsz;
	    }
	    else
	    {
		pwszFile++;
	    }
	    if (wcslen(pwszDir) + 1 + wcslen(pwszFile) >= ARRAYSIZE(wszPath))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		_JumpErrorStr(hr, error, "wszPath", pwszDir);
	    }
	    wcscpy(wszPath, pwszDir);
	    wcscat(wszPath, L"\\");
	    wcscat(wszPath, pwszFile);

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"BackupDBFileList: %x %ws -> %ws\n",
		*pwsz,
		&pwsz[1],
		wszPath));

	    hr = BackupCopyDBFile(
			    hcsbc,
			    &pwsz[1],
			    wszPath,
			    dwPercentCompleteCurrent,
			    dwPercentComplete1File,
			    pdwPercentComplete);
	    _JumpIfError(hr, error, "BackupCopyDBFile");

	    dwPercentCompleteCurrent += dwPercentComplete1File;
	    CSASSERT(*pdwPercentComplete == dwPercentCompleteCurrent);
	    //printf("BackupDBFileList: PercentComplete = %u\n", *pdwPercentComplete);
	}
    }
    CSASSERT(*pdwPercentComplete <= 100);
    *pdwPercentComplete = 100;
    //printf("BackupDBFileList: PercentComplete = %u (END)\n", *pdwPercentComplete);
    hr = S_OK;

error:
    if (NULL != pwszzList)
    {
	CertSrvBackupFree(pwszzList);
    }
    return(hr);
}


#define wszBSSTARDOTSTAR	L"\\*.*"
#define wszBSSTAR		L"\\*"

BOOL
myIsDirEmpty(
    IN WCHAR const *pwszDir)
{
    HRESULT hr;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR wszpath[MAX_PATH];
    BOOL fEmpty = TRUE;

    if (wcslen(pwszDir) + WSZARRAYSIZE(wszBSSTARDOTSTAR) >= ARRAYSIZE(wszpath))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpath", pwszDir);
    }
    wcscpy(wszpath, pwszDir);
    wcscat(wszpath, wszBSSTARDOTSTAR);

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE != hf)
    {
	do {
	    if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	    {
		continue;
	    }
	    fEmpty = FALSE;
	    //printf("File: %ws\n", wfd.cFileName);
	    break;

	} while (FindNextFile(hf, &wfd));
	FindClose(hf);
    }
error:
    return(fEmpty);
}


HRESULT
myForceDirEmpty(
    IN WCHAR const *pwszDir)
{
    HRESULT hr;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR *pwszFile;
    WCHAR wszpath[MAX_PATH];
    DWORD cwcBase;

    cwcBase = wcslen(pwszDir);
    if (cwcBase + WSZARRAYSIZE(wszBSSTARDOTSTAR) >= ARRAYSIZE(wszpath))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpath", pwszDir);
    }
    wcscpy(wszpath, pwszDir);
    wcscat(wszpath, wszBSSTARDOTSTAR);
    cwcBase++;
    pwszFile = &wszpath[cwcBase];

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "FindFirstFile");
    }
    hr = S_OK;
    do {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}
	if (cwcBase + wcslen(wfd.cFileName) >= ARRAYSIZE(wszpath))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _PrintErrorStr(hr, "wszpath", pwszDir);
	    continue;
	}
	wcscpy(pwszFile, wfd.cFileName);
	//printf("File: %ws\n", wszpath);
	DeleteFile(wszpath);
    } while (FindNextFile(hf, &wfd));
    FindClose(hf);
    _JumpIfErrorStr(hr, error, "wszpath", pwszDir);

error:
    return(hr);
}


BOOL
myIsDirectory(IN WCHAR const *pwszDirectoryPath)
{
    WIN32_FILE_ATTRIBUTE_DATA data;

    return(
	GetFileAttributesEx(pwszDirectoryPath, GetFileExInfoStandard, &data) &&
	(FILE_ATTRIBUTE_DIRECTORY & data.dwFileAttributes));
}


BOOL
myIsFileInUse(
    IN WCHAR const *pwszFile)
{
    BOOL fInUse = FALSE;
    HANDLE hFile;
    
    hFile = CreateFile(
                pwszFile,
                GENERIC_WRITE, // dwDesiredAccess
                0,             // no share
                NULL,          // lpSecurityAttributes
                OPEN_EXISTING, // open only & fail if doesn't exist
                0,             // dwFlagAndAttributes
                NULL);         // hTemplateFile
    if (INVALID_HANDLE_VALUE == hFile)
    {
        if (ERROR_SHARING_VIOLATION == GetLastError())
        {
            fInUse = TRUE;
        }
    }
    else
    {
        CloseHandle(hFile);
    }
    return(fInUse);
}


HRESULT
myCreateBackupDir(
    IN WCHAR const *pwszDir,
    IN BOOL fForceOverWrite)
{
    HRESULT hr;

    if (!myIsDirectory(pwszDir))
    {
        if (!CreateDirectory(pwszDir, NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
            {
                _JumpErrorStr(hr, error, "CreateDirectory", pwszDir);
            }
        } // else dir created successfully
    } // else dir already exists

    if (!myIsDirEmpty(pwszDir))
    {
	if (!fForceOverWrite)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
	    _JumpErrorStr(hr, error, "myIsDirEmpty", pwszDir);
	}
	hr = myForceDirEmpty(pwszDir);
	_JumpIfErrorStr(hr, error, "myForceDirEmpty", pwszDir);

	if (!myIsDirEmpty(pwszDir))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
	    _JumpErrorStr(hr, error, "myIsDirEmpty", pwszDir);
	}
    } // else is empty

    hr = S_OK;

error:
    return(hr);
}


// if Flags & CDBBACKUP_VERIFYONLY, create and verify the target directory is empty

HRESULT
myBackupDB(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fServerOnline;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    WCHAR *pwszPathDBDir = NULL;
    WCHAR *pwszDATFile = NULL;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    DBBACKUPPROGRESS dbp;
    LONG grbitJet;
    LONG BackupFlags;
    BOOL fImpersonating = FALSE;
    
    hcsbc = NULL;
    if (NULL == pwszConfig)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "NULL pwszConfig");
    }
    
    if (NULL == pdbp)
    {
        pdbp = &dbp;
    }
    ZeroMemory(pdbp, sizeof(*pdbp));
    
    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;
    
    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");
    
    if (NULL == pwszBackupDir)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    if (~CDBBACKUP_BACKUPVALID & Flags)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Flags");
    }
    
    if (!myIsDirectory(pwszBackupDir))
    {
        if (!CreateDirectory(pwszBackupDir, NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
            {
                _JumpError(hr, error, "CreateDirectory");
            }
        }
    }
    
    hr = myBuildPathAndExt(
        pwszBackupDir,
        wszDBBACKUPSUBDIR,
        NULL,
        &pwszPathDBDir);
    _JumpIfError(hr, error, "myBuildPathAndExt");
    
    hr = myCreateBackupDir(
        pwszPathDBDir,
        (CDBBACKUP_OVERWRITE & Flags)? TRUE : FALSE);
    _JumpIfError(hr, error, "myCreateBackupDir");
    
    //if (NULL != pwszConfig)
    if (0 == (Flags & CDBBACKUP_VERIFYONLY))
    {
        hr = CertSrvIsServerOnline(pwszConfig, &fServerOnline);
        _JumpIfError(hr, error, "CertSrvIsServerOnline");
        
        //printf("Cert Server Online -> %d\n", fServerOnline);
        
        if (!fServerOnline)
        {
            hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
            _JumpError(hr, error, "CertSrvIsServerOnline");
        }
        
        BackupFlags = CSBACKUP_TYPE_FULL;
        grbitJet = 0;
        if (CDBBACKUP_INCREMENTAL & Flags)
        {
            grbitJet |= JET_bitBackupIncremental;
            BackupFlags = CSBACKUP_TYPE_LOGS_ONLY;
        }
        if (CDBBACKUP_KEEPOLDLOGS & Flags)
        {
            // JetBeginExternalBackup can't handle setting this bit
            // grbitJet |= JET_bitKeepOldLogs;
        }
        
        hr = CertSrvBackupPrepare(pwszConfig, grbitJet, BackupFlags, &hcsbc);
        _JumpIfError(hr, error, "CertSrvBackupPrepare");
        
        fBegin = TRUE;
        
        if (0 == (CDBBACKUP_INCREMENTAL & Flags))
        {
            hr = CertSrvRestoreGetDatabaseLocations(hcsbc, &pwszzFileList, &cbList);
            _JumpIfError(hr, error, "CertSrvRestoreGetDatabaseLocations");
            
            hr = myBuildPathAndExt(
                pwszPathDBDir,
                wszDBBACKUPCERTBACKDAT,
                NULL,
                &pwszDATFile);
            _JumpIfError(hr, error, "myBuildPathAndExt");
            
            hr = EncodeToFileW(
                pwszDATFile,
                (BYTE const *) pwszzFileList,
                cbList,
                CRYPT_STRING_BINARY);
            _JumpIfError(hr, error, "EncodeToFileW");
            
            hr = BackupDBFileList(
                hcsbc,
                TRUE,
                pwszPathDBDir,
                &pdbp->dwDBPercentComplete);
            _JumpIfError(hr, error, "BackupDBFileList(DB)");
        }
        else
        {
            pdbp->dwDBPercentComplete = 100;
        }
        //printf("DB Done: dwDBPercentComplete = %u\n", pdbp->dwDBPercentComplete);
        
        hr = BackupDBFileList(
            hcsbc,
            FALSE,
            pwszPathDBDir,
            &pdbp->dwLogPercentComplete);
        _JumpIfError(hr, error, "BackupDBFileList(Log)");
        //printf("Log Done: dwLogPercentComplete = %u\n", pdbp->dwLogPercentComplete);
        
        if (0 == (CDBBACKUP_KEEPOLDLOGS & Flags))
        {
            hr = CertSrvBackupTruncateLogs(hcsbc);
            _JumpIfError(hr, error, "CertSrvBackupTruncateLogs");
        }
        pdbp->dwTruncateLogPercentComplete = 100;
        //printf("Truncate Done: dwTruncateLogPercentComplete = %u\n", pdbp->dwTruncateLogPercentComplete);
    }
    
error:
    if (NULL != pwszzFileList)
    {
        CertSrvBackupFree(pwszzFileList);
    }
    if (fBegin)
    {
        hr2 = CertSrvBackupEnd(hcsbc);
        _PrintIfError(hr2, "CertSrvBackupEnd");
        if (S_OK == hr)
        {
            hr = hr2;
        }
    }
    if (NULL != pwszDATFile)
    {
        LocalFree(pwszDATFile);
    }
    if (NULL != pwszPathDBDir)
    {
        LocalFree(pwszPathDBDir);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


// Verify the backup file names only, and return the log file numeric range.

HRESULT
myVerifyBackupDirectory(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszPathDBDir,
    OUT DWORD *plogMin,
    OUT DWORD *plogMax,
    OUT DWORD *pc64kDBBlocks,	// 64k blocks in DB files to be restored
    OUT DWORD *pc64kLogBlocks)	// 64k blocks in Log files to be restored
{
    HRESULT hr;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA wfd;
    WCHAR wszpath[2 * MAX_PATH];
    WCHAR wszfile[MAX_PATH];
    BOOL fSawEDBFile = FALSE;
    BOOL fSawDatFile = FALSE;
    DWORD cLogFiles = 0;
    WCHAR *pwszCA;
    WCHAR *pwszRevertCA = NULL;
    WCHAR *pwszSanitizedCA = NULL;
    WCHAR *pwszExt;
    WCHAR *pwsz;
    DWORD log;

    *plogMin = MAXDWORD;
    *plogMax = 0;
    *pc64kDBBlocks = 0;
    *pc64kLogBlocks = 0;
    wszpath[0] = L'\0'; 

    pwszCA = wcschr(pwszConfig, L'\\');
    if (NULL != pwszCA)
    {
	pwszCA++;	// point to CA Name

	hr = myRevertSanitizeName(pwszCA, &pwszRevertCA);
	_JumpIfError(hr, error, "myRevertSanitizeName");

	hr = mySanitizeName(pwszRevertCA, &pwszSanitizedCA);
	_JumpIfError(hr, error, "mySanitizeName");
    }

    if (wcslen(pwszPathDBDir) + WSZARRAYSIZE(wszBSSTARDOTSTAR) >= ARRAYSIZE(wszpath))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpath", pwszPathDBDir);
    }
    wcscpy(wszpath, pwszPathDBDir);
    wcscat(wszpath, wszBSSTARDOTSTAR);

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "missing backup files");
    }

    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
    do {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}
	//printf("File: %ws\n", wfd.cFileName);

	if (wcslen(wfd.cFileName) >= ARRAYSIZE(wszfile))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpErrorStr(hr, error, "wszpath", pwszPathDBDir);
	}
	wcscpy(wszfile, wfd.cFileName);

	pwszExt = wcsrchr(wszfile, L'.');
	if (NULL == pwszExt)
	{
	    _JumpError(hr, error, "file missing extension");
	}
	*pwszExt++ = L'\0';

	if (0 == mylstrcmpiS(pwszExt, &wszLOGFILENAMEEXT[1]))
	{
	    if (0 != _wcsnicmp(wszfile, wszDBBASENAMEPARM, 3))
	    {
		_JumpErrorStr(hr, error, "bad log prefix", wfd.cFileName);
	    }
	    for (pwsz = &wszfile[3]; L'\0' != *pwsz; pwsz++)
	    {
		if (!iswxdigit(*pwsz))
		{
		    _JumpErrorStr(hr, error, "bad name digit", wfd.cFileName);
		}
	    }
	    log = wcstoul(&wszfile[3], NULL, 16);
	    if (log > *plogMax)
	    {
		//printf("Log %x: max = %x -> %x\n", log, *plogMax, log);
		*plogMax = log;
	    }
	    if (log < *plogMin)
	    {
		//printf("Log %x: min = %x -> %x\n", log, *plogMin, log);
		*plogMin = log;
	    }
	    *pc64kLogBlocks += _64kBlocks(wfd.nFileSizeHigh, wfd.nFileSizeLow);
	    cLogFiles++;
	}
	else
	if (0 == mylstrcmpiS(pwszExt, &wszDBFILENAMEEXT[1]))
	{
	    if (fSawEDBFile)
	    {
		_JumpError(hr, error, "multiple *.edb files");
	    }
	    if (NULL != pwszSanitizedCA &&
		0 != mylstrcmpiL(wszfile, pwszSanitizedCA))
	    {
		_PrintErrorStr(hr, "expected base name", pwszSanitizedCA);
		_JumpErrorStr(hr, error, "base name mismatch", wfd.cFileName);
	    }
	    *pc64kDBBlocks += _64kBlocks(wfd.nFileSizeHigh, wfd.nFileSizeLow);
	    fSawEDBFile = TRUE;
	}
	else
	if (0 == mylstrcmpiS(pwszExt, &wszDATFILENAMEEXT[1]))
	{
	    if (fSawDatFile)
	    {
		_JumpError(hr, error, "multiple *.dat files");
	    }
	    if (LSTRCMPIS(wfd.cFileName, wszDBBACKUPCERTBACKDAT))
	    {
		_JumpErrorStr(hr, error, "unexpected file", wfd.cFileName);
	    }
	    fSawDatFile = TRUE;
	}
	else
	{
	    _JumpErrorStr(hr, error, "unexpected extension", wfd.cFileName);
	}
    } while (FindNextFile(hf, &wfd));

    //printf("clog=%u: %u - %u  edb=%u\n", cLogFiles, *plogMin, *plogMax, fSawEDBFile);

    if (0 == cLogFiles)
    {
	_JumpError(hr, error, "missing log file(s)");
    }
    if (0 == (CDBBACKUP_INCREMENTAL & Flags))
    {
	if (!fSawEDBFile || !fSawDatFile)
	{
	    _JumpError(hr, error, "missing full backup file(s)");
	}
    }
    else
    {
	if (fSawEDBFile || fSawDatFile)
	{
	    _JumpError(hr, error, "unexpected incremental backup file(s)");
	}
    }

    if (*plogMax - *plogMin + 1 != cLogFiles)
    {
	_JumpError(hr, error, "missing log file(s)");
    }
    hr = S_OK;

error:
    if (NULL != pwszRevertCA)
    {
	LocalFree(pwszRevertCA);
    }
    if (NULL != pwszSanitizedCA)
    {
	LocalFree(pwszSanitizedCA);
    }
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    return(hr);
}


HRESULT
myGetRegUNCDBDir(
    IN HKEY hkey,
    IN WCHAR const *pwszReg,
    OPTIONAL IN WCHAR const *pwszServer,
    IN WCHAR const **ppwszUNCDir)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cb;
    WCHAR *pwszDir = NULL;
    WCHAR *pwszUNCDir;

    *ppwszUNCDir = NULL;
    hr = RegQueryValueEx(hkey, pwszReg, NULL, &dwType, NULL, &cb);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpErrorStr(hr, error, "RegQueryValueEx", pwszReg);
    }

    pwszDir = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == pwszDir)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = RegQueryValueEx(hkey, pwszReg, NULL, &dwType, (BYTE *) pwszDir, &cb);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpErrorStr(hr, error, "RegQueryValueEx", pwszReg);
    }

    hr = myConvertLocalPathToUNC(pwszServer, pwszDir, &pwszUNCDir);
    _JumpIfError(hr, error, "myConvertLocalPathToUNC");

    *ppwszUNCDir = pwszUNCDir;

error:
    if (NULL != pwszDir)
    {
	LocalFree(pwszDir);
    }
    return(hr);
}


HRESULT
myCopyUNCPath(
    IN WCHAR const *pwszIn,
    OPTIONAL IN WCHAR const *pwszDnsName,
    OUT WCHAR const **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwszOut;
    WCHAR const *pwsz;
    
    *ppwszOut = NULL;

    if (L'\\' != pwszIn[0] || L'\\' != pwszIn[1])
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad parm");
    }
    if (NULL == pwszDnsName)
    {
	hr = myConvertUNCPathToLocal(pwszIn, &pwszOut);
	_JumpIfError(hr, error, "myConvertUNCPathToLocal");
    }
    else
    {
	pwsz = wcschr(&pwszIn[2], L'\\');
	if (NULL == pwsz)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "bad parm");
	}
	pwszOut = (WCHAR *) LocalAlloc(
		LMEM_FIXED,
		(2 + wcslen(pwszDnsName) + wcslen(pwsz) + 1) * sizeof(WCHAR));
	if (NULL == pwszOut)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszOut, L"\\\\");
	wcscat(pwszOut, pwszDnsName);
	wcscat(pwszOut, pwsz);
    }
    *ppwszOut = pwszOut;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetDBPaths(
    IN WCHAR const *pwszConfig,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszzFileList,
    OUT WCHAR const **ppwszDBDir,
    OUT WCHAR const **ppwszLogDir,
    OUT WCHAR const **ppwszSystemDir)
{
    HRESULT hr;
    HKEY hkey = NULL;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszRegPath = NULL;
    WCHAR *pwszDBDir = NULL;
    WCHAR const *pwsz;
    WCHAR const *pwszT;
    BOOL fLocal;

    *ppwszDBDir = NULL;
    *ppwszLogDir = NULL;
    *ppwszSystemDir = NULL;

    hr = myIsConfigLocal(pwszConfig, NULL, &fLocal);
    _JumpIfError(hr, error, "myIsConfigLocal");

    if (fLocal)
    {
	pwszConfig = NULL;
    }
    else
    {
	hr = myGetMachineDnsName(&pwszDnsName);
	_JumpIfError(hr, error, "myGetMachineDnsName");
    }

    hr = myRegOpenRelativeKey(
			fLocal? NULL : pwszConfig,
			L"",
			0,
			&pwszRegPath,
			NULL,		// ppwszName
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    // Find old database path:

    pwszT = NULL;
    pwsz = NULL;
    if (NULL != pwszzFileList)
    {
	for (pwsz = pwszzFileList; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    if (CSBFT_CERTSERVER_DATABASE == *pwsz)
	    {
		pwsz++;
		pwszT = wcsrchr(pwsz, L'\\');
		break;
	    }
	}
    }

    if (NULL != pwszT)
    {
	DWORD cwc = SAFE_SUBTRACT_POINTERS(pwszT, pwsz);

	pwszDBDir = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszDBDir)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszDBDir, pwsz, cwc * sizeof(WCHAR));
	pwszDBDir[cwc] = L'\0';

	hr = myCopyUNCPath(pwszDBDir, pwszDnsName, ppwszDBDir);
	_JumpIfError(hr, error, "myCopyUNCPath");
    }
    else
    {
	hr = myGetRegUNCDBDir(hkey, wszREGDBDIRECTORY, pwszDnsName, ppwszDBDir);
	_JumpIfError(hr, error, "myGetRegUNCDBDir");
    }

    if (NULL != pwszLogPath)
    {
	hr = myCopyUNCPath(pwszLogPath, pwszDnsName, ppwszLogDir);
	_JumpIfError(hr, error, "myCopyUNCPath");
    }
    else
    {
	hr = myGetRegUNCDBDir(
			hkey,
			wszREGDBLOGDIRECTORY,
			pwszDnsName,
			ppwszLogDir);
	_JumpIfError(hr, error, "myGetRegUNCDBDir");
    }

    hr = myGetRegUNCDBDir(
			hkey,
			wszREGDBSYSDIRECTORY,
			pwszDnsName,
			ppwszSystemDir);
    _JumpIfError(hr, error, "myGetRegUNCDBDir");

error:
    if (S_OK != hr)
    {
	if (NULL != *ppwszDBDir)
	{
	    LocalFree(const_cast<WCHAR *>(*ppwszDBDir));
	    *ppwszDBDir = NULL;
	}
	if (NULL != *ppwszLogDir)
	{
	    LocalFree(const_cast<WCHAR *>(*ppwszLogDir));
	    *ppwszLogDir = NULL;
	}
	if (NULL != *ppwszSystemDir)
	{
	    LocalFree(const_cast<WCHAR *>(*ppwszSystemDir));
	    *ppwszSystemDir = NULL;
	}
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszDBDir)
    {
	LocalFree(pwszDBDir);
    }
    if (NULL != pwszRegPath)
    {
	LocalFree(pwszRegPath);
    }
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    return(hr);
}


HRESULT
RestoreCopyFile(
    IN BOOL fForceOverWrite,
    IN WCHAR const *pwszSourceDir,
    IN WCHAR const *pwszTargetDir,
    IN WCHAR const *pwszFile,
    IN DWORD nFileSizeHigh,
    IN DWORD nFileSizeLow,
    IN DWORD c64kBlocksTotal,		// total file size
    IN OUT DWORD *pc64kBlocksCurrent,	// current file size sum
    IN OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    WCHAR *pwszSource = NULL;
    WCHAR *pwszTarget = NULL;
    HANDLE hTarget = INVALID_HANDLE_VALUE;
    HANDLE hSource = INVALID_HANDLE_VALUE;
    LARGE_INTEGER licb;
    LARGE_INTEGER licbRead;
    DWORD cbRead;
    DWORD cbWritten;
    DWORD cbLargeAlloc;
    BYTE *pbLargeAlloc = NULL;
    DWORD c64kBlocksFile;
    DWORD dwPercentComplete;

    licb.HighPart = nFileSizeHigh;
    licb.LowPart = nFileSizeLow;

    hr = myBuildPathAndExt(pwszSourceDir, pwszFile, NULL, &pwszSource);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hr = myBuildPathAndExt(pwszTargetDir, pwszFile, NULL, &pwszTarget);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hr = myLargeAlloc(&cbLargeAlloc, &pbLargeAlloc);
    _JumpIfError(hr, error, "myLargeAlloc");

    hSource = CreateFile(
			pwszSource,
			GENERIC_READ,
			0,
			NULL,
			OPEN_EXISTING,
			0,
			NULL);
    if (hSource == INVALID_HANDLE_VALUE)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszSource);
    }
    hTarget = CreateFile(
			pwszTarget,
			GENERIC_WRITE,
			0,
			NULL,
			fForceOverWrite? CREATE_ALWAYS : CREATE_NEW,
			0,
			NULL);
    if (hTarget == INVALID_HANDLE_VALUE)
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszTarget);
    }

    licbRead.QuadPart = 0;
    c64kBlocksFile = 0;
    while (licbRead.QuadPart < licb.QuadPart)
    {
	if (!ReadFile(hSource, pbLargeAlloc, cbLargeAlloc, &cbRead, NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "ReadFile");
	}
	//printf("ReadFile(%x)\n", cbRead);

	if (!WriteFile(hTarget, pbLargeAlloc, cbRead, &cbWritten, NULL))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "WriteFile", pwszTarget);
	}
	if (cbWritten != cbRead)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
	    _JumpErrorStr(hr, error, "WriteFile", pwszTarget);
	}
	licbRead.QuadPart += cbRead;

	c64kBlocksFile = _64kBlocks(licbRead.HighPart, licbRead.LowPart);
	dwPercentComplete =
	    (100 * (c64kBlocksFile + *pc64kBlocksCurrent)) / c64kBlocksTotal;

	CSASSERT(*pdwPercentComplete <= dwPercentComplete);
	*pdwPercentComplete = dwPercentComplete;
	//printf("RestoreCopyFile0: PercentComplete = %u\n", *pdwPercentComplete);
    }
    *pc64kBlocksCurrent += c64kBlocksFile;
    dwPercentComplete = (100 * *pc64kBlocksCurrent) / c64kBlocksTotal;
    CSASSERT(*pdwPercentComplete <= dwPercentComplete);
    *pdwPercentComplete = dwPercentComplete;
    //printf("RestoreCopyFile1: PercentComplete = %u\n", *pdwPercentComplete);
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hTarget)
    {
	CloseHandle(hTarget);
    }
    if (INVALID_HANDLE_VALUE != hSource)
    {
	CloseHandle(hSource);
    }
    if (NULL != pwszSource)
    {
	LocalFree(pwszSource);
    }
    if (NULL != pwszTarget)
    {
	LocalFree(pwszTarget);
    }
    if (NULL != pbLargeAlloc)
    {
	VirtualFree(pbLargeAlloc, 0, MEM_RELEASE);
    }
    return(hr);
}


HRESULT
RestoreCopyFilePattern(
    IN BOOL fForceOverWrite,
    IN WCHAR const *pwszSourceDir,
    IN WCHAR const *pwszTargetDir,
    IN WCHAR const *pwszFilePattern,
    IN DWORD c64kBlocksTotal,		// total file size
    IN OUT DWORD *pc64kBlocksCurrent,	// current file size sum
    IN OUT DWORD *pdwPercentComplete)
{
    HRESULT hr;
    WCHAR *pwszPattern = NULL;
    HANDLE hf = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA wfd;
    
    hr = myBuildPathAndExt(pwszSourceDir, pwszFilePattern, NULL, &pwszPattern);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    hf = FindFirstFile(pwszPattern, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpErrorStr(hr, error, "missing source files", pwszPattern);
    }

    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
    do {
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    continue;
	}
	//printf("File: %ws\n", wfd.cFileName);
	hr = RestoreCopyFile(
			fForceOverWrite,
			pwszSourceDir,		// source dir
			pwszTargetDir,		// target dir
			wfd.cFileName,
			wfd.nFileSizeHigh,
			wfd.nFileSizeLow,
			c64kBlocksTotal,	// total file size
			pc64kBlocksCurrent,	// current file size sum
			pdwPercentComplete);
	_JumpIfError(hr, error, "RestoreCopyFile");

    } while (FindNextFile(hf, &wfd));
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hf)
    {
	FindClose(hf);
    }
    if (NULL != pwszPattern)
    {
	LocalFree(pwszPattern);
    }
    return(hr);
}


HRESULT
myRestoreDBFiles(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    IN WCHAR const *pwszBackupDir,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszzFileList,	// NULL if incremental restore
    IN DWORD c64kDBBlocks,
    IN DWORD c64kLogBlocks,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp)
{
    HRESULT hr;
    DWORD i;
#define IDIR_DB		0
#define IDIR_LOG	1
#define IDIR_SYSTEM	2
    WCHAR const *apwszDirs[3] = { NULL, NULL, NULL };
    DWORD c64kBlocksCurrent;
    BOOL fForceOverWrite = 0 != (CDBBACKUP_OVERWRITE & Flags);
    WCHAR *pwszFileInUse = NULL;

    // Get DB, Log & System paths from registry

    hr = myGetDBPaths(
		    pwszConfig,
		    pwszLogPath,
		    pwszzFileList,
		    &apwszDirs[IDIR_DB],
		    &apwszDirs[IDIR_LOG],
		    &apwszDirs[IDIR_SYSTEM]);
    _JumpIfError(hr, error, "myGetDBPaths");

    DBGPRINT((DBG_SS_CERTLIBI, "DBDir:  %ws\n", apwszDirs[IDIR_DB]));
    DBGPRINT((DBG_SS_CERTLIBI, "LogDir: %ws\n", apwszDirs[IDIR_LOG]));
    DBGPRINT((DBG_SS_CERTLIBI, "SysDir: %ws\n", apwszDirs[IDIR_SYSTEM]));

    CSASSERT((NULL == pwszzFileList) ^ (0 == (CDBBACKUP_INCREMENTAL & Flags)));
    for (i = 0; i < ARRAYSIZE(apwszDirs); i++)
    {
	BOOL fFilesExist;

	if (!myIsDirectory(apwszDirs[i]))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
	    _JumpErrorStr(hr, error, "not a directory", apwszDirs[i]);
	}
	hr = myDoDBFilesExistInDir(apwszDirs[i], &fFilesExist, &pwszFileInUse);
	_JumpIfError(hr, error, "myDoDBFilesExistInDir");

	if (NULL != pwszFileInUse)
	{
	    _PrintErrorStr(
		    HRESULT_FROM_WIN32(ERROR_BUSY),
		    "myDoDBFilesExistInDir",
		    pwszFileInUse);
	}
	if (!fFilesExist)
	{
	    if (CDBBACKUP_INCREMENTAL & Flags)
	    {
		// Incremental restore -- some DB files should already exist

		hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
		_JumpErrorStr(hr, error, "myDoDBFilesExistInDir", apwszDirs[i]);
	    }
	}
	else if (0 == (CDBBACKUP_INCREMENTAL & Flags))
	{
	    // Full restore -- no DB files should exist yet

	    if (!fForceOverWrite)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_DIR_NOT_EMPTY);
		_JumpErrorStr(
			hr,
			error,
			"myDoDBFilesExistInDir",
			NULL != pwszFileInUse? pwszFileInUse : apwszDirs[i]);
	    }
	    hr = myDeleteDBFilesInDir(apwszDirs[i]);
	    if (S_OK != hr)
	    {
		_PrintErrorStr(hr, "myDeleteDBFilesInDir", apwszDirs[i]);
	    }
	}
    }

    // copy files to appropriate target directories

    if (0 == (CDBBACKUP_INCREMENTAL & Flags))
    {
	c64kBlocksCurrent = 0;
	hr = RestoreCopyFilePattern(
			fForceOverWrite,
			pwszBackupDir,		// source dir
			apwszDirs[IDIR_DB],	// target dir
			L"*" wszDBFILENAMEEXT,	// match pattern
			c64kDBBlocks,
			&c64kBlocksCurrent,	// current total file size
			&pdbp->dwDBPercentComplete);
	_JumpIfError(hr, error, "RestoreCopyFile");

	CSASSERT(c64kDBBlocks == c64kBlocksCurrent);
    }
    CSASSERT(100 >= pdbp->dwDBPercentComplete);
    pdbp->dwDBPercentComplete = 100;

    c64kBlocksCurrent = 0;
    hr = RestoreCopyFilePattern(
		    fForceOverWrite,
		    pwszBackupDir,		// source dir
		    apwszDirs[IDIR_LOG],	// target dir
		    L"*" wszLOGFILENAMEEXT,	// match pattern
		    c64kLogBlocks,
		    &c64kBlocksCurrent,		// current total file size
		    &pdbp->dwLogPercentComplete);
    _JumpIfError(hr, error, "RestoreCopyFile");

    CSASSERT(c64kLogBlocks == c64kBlocksCurrent);

    CSASSERT(100 >= pdbp->dwLogPercentComplete);
    pdbp->dwLogPercentComplete = 100;

    CSASSERT(100 >= pdbp->dwTruncateLogPercentComplete);
    pdbp->dwTruncateLogPercentComplete = 100;

    hr = S_OK;

error:
    if (NULL != pwszFileInUse)
    {
	LocalFree(pwszFileInUse);
    }
    for (i = 0; i < ARRAYSIZE(apwszDirs); i++)
    {
	if (NULL != apwszDirs[i])
	{
	    LocalFree(const_cast<WCHAR *>(apwszDirs[i]));
	}
    }
    return(hr);
}


HRESULT
myDeleteRestoreInProgressKey(
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    HKEY hkey = NULL;
    WCHAR *pwszRegPath = NULL;

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszRegPath,
			NULL,		// ppwszName
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    hr = RegDeleteKey(hkey, wszREGKEYRESTOREINPROGRESS);
    _JumpIfError(hr, error, "RegDeleteKey");

error:
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
    if (NULL != pwszRegPath)
    {
	LocalFree(pwszRegPath);
    }
    return(hr);
}


// If CDBBACKUP_VERIFYONLY, only verify the passed directory contains valid
// files.  If pwszBackupDir is NULL, delete the RestoreInProgress registry key.

HRESULT
myRestoreDB(
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OPTIONAL IN WCHAR const *pwszBackupDir,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    OPTIONAL OUT DBBACKUPPROGRESS *pdbp)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR buf[MAX_PATH];
    WCHAR *pwszPathDBDir = NULL;
    WCHAR *pwszDATFile = NULL;
    WCHAR *pwszzFileList = NULL;
    DWORD cbList;
    CSEDB_RSTMAP RstMap[1];
    DWORD crstmap = 0;
    WCHAR *pwszFile;
    DWORD logMin;
    DWORD logMax;
    HCSBC hcsbc;
    BOOL fBegin = FALSE;
    BOOL fImpersonating = FALSE;
    DBBACKUPPROGRESS dbp;
    DWORD c64kDBBlocks;		// 64k blocks in DB files to be restored
    DWORD c64kLogBlocks;	// 64k blocks in Log files to be restored

    if (NULL == pdbp)
    {
	pdbp = &dbp;
    }
    ZeroMemory(pdbp, sizeof(*pdbp));
    hcsbc = NULL;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_RESTORE_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");
    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    if (NULL == pwszConfig ||
	((CDBBACKUP_VERIFYONLY & Flags) && NULL == pwszBackupDir))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL != pwszBackupDir)
    {
	if (!GetFullPathName(pwszBackupDir, ARRAYSIZE(buf), buf, &pwszFile))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetFullPathName");
	}
	hr = myBuildPathAndExt(buf, wszDBBACKUPSUBDIR, NULL, &pwszPathDBDir);
	_JumpIfError(hr, error, "myBuildPathAndExt");

	hr = myVerifyBackupDirectory(
				pwszConfig,
				Flags,
				pwszPathDBDir,
				&logMin,
				&logMax,
				&c64kDBBlocks,
				&c64kLogBlocks);
	_JumpIfError(hr, error, "myVerifyBackupDirectory");

	DBGPRINT((
		DBG_SS_CERTLIBI,
		"c64kBlocks=%u+%u\n",
		c64kDBBlocks,
		c64kLogBlocks));

	if (0 == (CDBBACKUP_INCREMENTAL & Flags))
	{
	    hr = myBuildPathAndExt(
			    pwszPathDBDir,
			    wszDBBACKUPCERTBACKDAT,
			    NULL,
			    &pwszDATFile);
	    _JumpIfError(hr, error, "myBuildPathAndExt");

	    hr = DecodeFileW(
			pwszDATFile,
			(BYTE **) &pwszzFileList,
			&cbList,
			CRYPT_STRING_BINARY);
	    _JumpIfError(hr, error, "DecodeFileW");

	    if (2 * sizeof(WCHAR) >= cbList ||
		L'\0' != pwszzFileList[cbList/sizeof(WCHAR) - 1] ||
		L'\0' != pwszzFileList[cbList/sizeof(WCHAR) - 2])
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "pwszzFileList malformed");
	    }
	    RstMap[0].pwszDatabaseName = pwszzFileList;
	    RstMap[0].pwszNewDatabaseName = pwszzFileList;
	    crstmap = 1;
	}
	if (0 == (CDBBACKUP_VERIFYONLY & Flags))
	{
	    hr = myRestoreDBFiles(
			    pwszConfig,
			    Flags,
			    pwszPathDBDir,
			    pwszLogPath,
			    pwszzFileList,
			    c64kDBBlocks,
			    c64kLogBlocks,
			    pdbp);
	    _JumpIfError(hr, error, "myRestoreDBFiles");

	    hr = CertSrvRestorePrepare(pwszConfig, CSRESTORE_TYPE_FULL, &hcsbc);
	    _JumpIfError(hr, error, "CertSrvRestorePrepare");

	    fBegin = TRUE;

	    hr = CertSrvRestoreRegister(
			    hcsbc,
			    pwszCheckPointFilePath,
			    pwszLogPath,
			    0 == crstmap? NULL : RstMap,
			    crstmap,
			    pwszBackupLogPath,
			    logMin,
			    logMax);

	    // When running only as backup operator, we don't have rights
	    // in the registry and CertSrvRestoreRegister fails with access
	    // denied. We try to mark for restore through a file.

	    if (E_ACCESSDENIED == hr)
	    {
		hr = CertSrvRestoreRegisterThroughFile(
				hcsbc,
				pwszCheckPointFilePath,
				pwszLogPath,
				0 == crstmap? NULL : RstMap,
				crstmap,
				pwszBackupLogPath,
				logMin,
				logMax);
		_JumpIfError(hr, error, "CertSrvRestoreRegisterThroughFile");
	    }
	    else
	    {
		_JumpIfError(hr, error, "CertSrvRestoreRegister");

		hr = CertSrvRestoreRegisterComplete(hcsbc, S_OK);
		_JumpIfError(hr, error, "CertSrvRestoreRegisterComplete");
	    }
	}
    }
    else if (0 == (CDBBACKUP_VERIFYONLY & Flags))
    {
	hr = myDeleteRestoreInProgressKey(pwszConfig);
	_JumpIfError(hr, error, "myDeleteRestoreInProgressKey");
    }
    hr = S_OK;

error:
    if (fBegin)
    {
	hr2 = CertSrvRestoreEnd(hcsbc);
	_PrintIfError(hr2, "CertSrvBackupEnd");
	if (S_OK == hr)
	{
	    hr = hr2;
	}
    }
    if (NULL != pwszzFileList)
    {
	LocalFree(pwszzFileList);
    }
    if (NULL != pwszDATFile)
    {
	LocalFree(pwszDATFile);
    }
    if (NULL != pwszPathDBDir)
    {
	LocalFree(pwszPathDBDir);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        myEnablePrivilege(SE_RESTORE_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


typedef BOOL (WINAPI FNPFXEXPORTCERTSTOREEX)(
    IN HCERTSTORE hStore,
    IN OUT CRYPT_DATA_BLOB* pPFX,
    IN LPCWSTR szPassword,
    IN VOID *pvReserved,
    IN DWORD dwFlags);

FNPFXEXPORTCERTSTOREEX PFXExportCertStoreOld;

BOOL WINAPI
PFXExportCertStoreOld(
    IN HCERTSTORE hStore,
    IN OUT CRYPT_DATA_BLOB *ppfx,
    IN WCHAR const *pwszPassword,
    IN VOID *, // pvReserved
    IN DWORD dwFlags)
{
    return(PFXExportCertStore(hStore, ppfx, pwszPassword, dwFlags));
}


HRESULT
myPFXExportCertStore(
    IN HCERTSTORE hStore,
    OUT CRYPT_DATA_BLOB *ppfx,
    IN WCHAR const *pwszPassword,
    IN BOOL fEnhancedStrength,
    IN DWORD dwFlags)
{
    HRESULT hr;
    FNPFXEXPORTCERTSTOREEX *pfn;
    char const *pszFunc;

    if (fEnhancedStrength)
    {
	pfn = PFXExportCertStoreEx;
	pszFunc = "PFXExportCertStoreEx";
    }
    else
    {
	pfn = PFXExportCertStoreOld;
	pszFunc = "PFXExportCertStoreOld";
    }

    ppfx->pbData = NULL;
    if (!(*pfn)(hStore, ppfx, pwszPassword, NULL, dwFlags))
    {
        hr = myHLastError();
        _JumpError(hr, error, pszFunc);
    }
    ppfx->pbData = (BYTE *) LocalAlloc(LMEM_FIXED, ppfx->cbData);
    if (NULL == ppfx->pbData)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "no memory for PFX blob");
    }
    if (!(*pfn)(hStore, ppfx, pwszPassword, NULL, dwFlags))
    {
        hr = myHLastError();
        _JumpError(hr, error, pszFunc);
    }
    hr = S_OK;

error:
    return(hr);
}


////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////

HRESULT
myAddChainToMemoryStore(
    IN HCERTSTORE hMemoryStore,
    IN CERT_CONTEXT const *pCertContext,
    IN DWORD dwmsTimeout)
{
    HRESULT hr;
    DWORD i;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_SIMPLE_CHAIN *pSimpleChain;

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);
    CertChainPara.dwUrlRetrievalTimeout = dwmsTimeout;

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pCertContext,
			    NULL,
			    NULL,
			    &CertChainPara,
			    0,
			    NULL,
			    &pCertChainContext))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChainContext->cChain)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        _JumpError(hr, error, "pCertChainContext->cChain");
    }

    pSimpleChain = pCertChainContext->rgpChain[0];
    for (i = 0; i < pSimpleChain->cElement; i++)
    {
	if (!CertAddCertificateContextToStore(
			    hMemoryStore,
			    pSimpleChain->rgpElement[i]->pCertContext,
			    CERT_STORE_ADD_REPLACE_EXISTING,
			    NULL))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertAddCertificateContextToStore");
	}
    }
    hr = S_OK;

error:
    if (pCertChainContext != NULL)
    {
	CertFreeCertificateChain(pCertChainContext);
    }
    return(hr);
}


HRESULT
SaveCACertChainToMemoryStore(
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN HCERTSTORE hMyStore,
    IN HCERTSTORE hTempMemoryStore,
    IN DWORD dwmsTimeout)
{
    HRESULT hr;
    CERT_CONTEXT const *pccCA = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD NameId;

    hr = myFindCACertByHashIndex(
			    hMyStore,
			    pwszSanitizedName,
			    CSRH_CASIGCERT,
			    iCert,
			    &NameId,
			    &pccCA);
    _JumpIfError(hr, error, "myFindCACertByHashIndex");

    hr = myRepairCertKeyProviderInfo(pccCA, TRUE, &pkpi);
    if (S_OK != hr)
    {
        if (CRYPT_E_NOT_FOUND != hr)
        {
            _JumpError(hr, error, "myRepairCertKeyProviderInfo");
        }
    }
    else if (NULL != pkpi)
    {
	BOOL fMatchingKey;

	hr = myVerifyPublicKey(
			pccCA,
			FALSE,
			NULL,		// pKeyProvInfo
			NULL,		// pPublicKeyInfo
			&fMatchingKey);
        if (S_OK != hr)
        {
            if (!IsHrSkipPrivateKey(hr))
            {
                _JumpError(hr, error, "myVerifyPublicKey");
            }
            _PrintError2(hr, "myVerifyPublicKey", hr);
        }
	else if (!fMatchingKey)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Key doesn't match cert");
	}
    }

    // Begin Chain Building

    hr = myAddChainToMemoryStore(hTempMemoryStore, pccCA, dwmsTimeout);
    _JumpIfError(hr, error, "myAddChainToMemoryStore");

    // End Chain Building

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pccCA)
    {
	CertFreeCertificateContext(pccCA);
    }
    return(hr);
}


HRESULT
myCertServerExportPFX(
    IN WCHAR const *pwszCA,
    IN WCHAR const *pwszBackupDir,
    IN WCHAR const *pwszPassword,
    IN BOOL fEnhancedStrength,
    IN BOOL fForceOverWrite,
    IN BOOL fMustExportPrivateKeys,
    IN DWORD dwmsTimeout,
    OPTIONAL OUT WCHAR **ppwszPFXFile)
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    HCERTSTORE hTempMemoryStore = NULL;
    CRYPT_DATA_BLOB pfx;
    WCHAR *pwszPFXFile = NULL;
    BOOL fImpersonating = FALSE;
    WCHAR *pwszSanitizedCA = NULL;
    WCHAR *pwszRevertCA = NULL;
    DWORD cCACert;
    DWORD cCACertSaved;
    DWORD i;

    pfx.pbData = NULL;

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    if (NULL != ppwszPFXFile)
    {
	*ppwszPFXFile = NULL;
    }

    for (;;)
    {
	hr = mySanitizeName(pwszCA, &pwszSanitizedCA);
	_JumpIfError(hr, error, "mySanitizeName");

	// get CA cert count
	hr = myGetCARegHashCount(pwszSanitizedCA, CSRH_CASIGCERT, &cCACert);
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
	    NULL == pwszRevertCA)
	{
	    LocalFree(pwszSanitizedCA);
	    pwszSanitizedCA = NULL;

	    hr = myRevertSanitizeName(pwszCA, &pwszRevertCA);
	    _JumpIfError(hr, error, "myRevertSanitizeName");

	    pwszCA = pwszRevertCA;
	    continue;
	}
	_JumpIfError(hr, error, "myGetCARegHashCount");

	if (NULL != pwszRevertCA)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"myCertServerExportPFX called with Sanitized Name: %ws\n",
		pwszSanitizedCA));
	}
	break;
    }

    if (!myIsDirectory(pwszBackupDir))
    {
        if (!CreateDirectory(pwszBackupDir, NULL))
        {
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
	    {
		_JumpError(hr, error, "CreateDirectory");
	    }
        }
    }

    pwszPFXFile = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszBackupDir) +
				     1 +
				     wcslen(pwszSanitizedCA) +
				     ARRAYSIZE(wszPFXFILENAMEEXT)) *
					 sizeof(WCHAR));
    if (NULL == pwszPFXFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszPFXFile, pwszBackupDir);
    wcscat(pwszPFXFile, L"\\");
    wcscat(pwszPFXFile, pwszSanitizedCA);
    wcscat(pwszPFXFile, wszPFXFILENAMEEXT);

    DBGPRINT((DBG_SS_CERTLIBI, "myCertServerExportPFX(%ws)\n", pwszPFXFile));

    hMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			CERT_STORE_OPEN_EXISTING_FLAG |
			    CERT_STORE_ENUM_ARCHIVED_FLAG |
			    CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_READONLY_FLAG,
			wszMY_CERTSTORE);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    hTempMemoryStore = CertOpenStore(
				CERT_STORE_PROV_MEMORY,
				X509_ASN_ENCODING,
				NULL,
				0,
				NULL);
    if (NULL == hTempMemoryStore)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertOpenStore");
    }

    cCACertSaved = 0;
    for (i = 0; i < cCACert; i++)
    {
	hr = SaveCACertChainToMemoryStore(
			    pwszSanitizedCA,
			    i,
			    hMyStore,
			    hTempMemoryStore,
			    dwmsTimeout);
	_PrintIfError(hr, "SaveCACertChainToMemoryStore");
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "SaveCACertChainToMemoryStore");

	    cCACertSaved++;
	}
    }
    if (0 == cCACertSaved)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "SaveCACertChainToMemoryStore");
    }

    // done, have built entire chain for all CA Certs

    // GemPlus returns NTE_BAD_TYPE instead of NTE_BAD_KEY, blowing up
    // REPORT_NOT_ABLE* filtering.  if they ever get this right, we can pass
    // "[...] : EXPORT_PRIVATE_KEYS"

    hr = myPFXExportCertStore(
		hTempMemoryStore,
		&pfx,
		pwszPassword,
		fEnhancedStrength,
		fMustExportPrivateKeys?
		    (EXPORT_PRIVATE_KEYS | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY) : 0);
    _JumpIfError(hr, error, "myPFXExportCertStore");

    hr = EncodeToFileW(
		pwszPFXFile,
		pfx.pbData,
		pfx.cbData,
		CRYPT_STRING_BINARY | (fForceOverWrite? DECF_FORCEOVERWRITE : 0));
    _JumpIfError(hr, error, "EncodeToFileW");

    if (NULL != ppwszPFXFile)
    {
	*ppwszPFXFile = pwszPFXFile;
	pwszPFXFile = NULL;
    }

error:
    if (NULL != pwszSanitizedCA)
    {
	LocalFree(pwszSanitizedCA);
    }
    if (NULL != pwszRevertCA)
    {
	LocalFree(pwszRevertCA);
    }
    if (NULL != pwszPFXFile)
    {
	LocalFree(pwszPFXFile);
    }
    if (NULL != hMyStore)
    {
	CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hTempMemoryStore)
    {
	CertCloseStore(hTempMemoryStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
	LocalFree(pfx.pbData);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_BACKUP_NAME, FALSE);
        RevertToSelf();
    }
    return(hr);
}


HRESULT
FindKeyUsage(
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension,
    OUT DWORD *pdwUsage)
{
    HRESULT hr;
    DWORD i;
    CRYPT_BIT_BLOB *pblob = NULL;

    *pdwUsage = 0;
    for (i = 0; i < cExtension; i++)
    {
	CERT_EXTENSION const *pce;

	pce = &rgExtension[i];
	if (0 == strcmp(pce->pszObjId, szOID_KEY_USAGE))
	{
	    DWORD cb;

	    // Decode CRYPT_BIT_BLOB:

	    if (!myDecodeObject(
			    X509_ASN_ENCODING,
			    X509_KEY_USAGE,
			    pce->Value.pbData,
			    pce->Value.cbData,
			    CERTLIB_USE_LOCALALLOC,
			    (VOID **) &pblob,
			    &cb))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "myDecodeObject");
	    }
	    if (1 > pblob->cbData || 8 < pblob->cUnusedBits)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Key Usage Extension too small");
	    }
	    *pdwUsage = *pblob->pbData;

	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    _JumpError(hr, error, "no Key Usage Extension");

error:
    if (NULL != pblob)
    {
	LocalFree(pblob);
    }
    return(hr);
}


HRESULT
mySetKeySpec(
    IN CERT_CONTEXT const *pCert,
    OUT DWORD *pdwKeySpec)
{
    HRESULT hr;
    DWORD dwKeyUsage;

    *pdwKeySpec = AT_SIGNATURE;
    hr = FindKeyUsage(
		pCert->pCertInfo->cExtension,
		pCert->pCertInfo->rgExtension,
		&dwKeyUsage);
    _JumpIfError(hr, error, "FindKeyUsage");

    if (CERT_KEY_ENCIPHERMENT_KEY_USAGE & dwKeyUsage)
    {
	*pdwKeySpec = AT_KEYEXCHANGE;
    }
    hr = S_OK;

error:

    // Ignore errors because the Key Usage extension may not exist:
    hr = S_OK;

    return(hr);
}


HRESULT
myRepairKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    IN BOOL fForceMachineKey,
    IN OUT CRYPT_KEY_PROV_INFO *pkpi)
{
    HRESULT hr;
    BOOL fModified = FALSE;

    if (0 == pkpi->dwProvType)
    {
	pkpi->dwProvType = PROV_RSA_FULL;
	fModified = TRUE;
    }
    if (0 == pkpi->dwKeySpec)
    {
	hr = mySetKeySpec(pCert, &pkpi->dwKeySpec);
	_JumpIfError(hr, error, "mySetKeySpec");

	fModified = TRUE;
    }
    if (fForceMachineKey && 0 == (CRYPT_MACHINE_KEYSET & pkpi->dwFlags))
    {
	pkpi->dwFlags |= CRYPT_MACHINE_KEYSET;
	fModified = TRUE;
    }
    if (fModified)
    {
	if (!CertSetCertificateContextProperty(
					    pCert,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    pkpi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myRepairCertKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    IN BOOL fForceMachineKey,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO **ppkpi)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;

    if (NULL != ppkpi)
    {
	*ppkpi = NULL;
    }

    hr = myCertGetKeyProviderInfo(pCert, &pkpi);
    _JumpIfError2(hr, error, "myCertGetKeyProviderInfo", CRYPT_E_NOT_FOUND);

    CSASSERT(NULL != pkpi);

    hr = myRepairKeyProviderInfo(pCert, fForceMachineKey, pkpi);
    _JumpIfError(hr, error, "myRepairKeyProviderInfo");

    if (NULL != ppkpi)
    {
	*ppkpi = pkpi;
	pkpi = NULL;
    }

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    return(hr);
}


HRESULT
myGetChainArrayFromStore(
    IN HCERTSTORE hStore,
    IN BOOL fCAChain,
    IN BOOL fUserStore,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    IN OUT DWORD *pcRestoreChain,
    OPTIONAL OUT RESTORECHAIN *paRestoreChain)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    WCHAR *pwszCommonName = NULL;
    CERT_CHAIN_PARA ChainParams;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    DWORD iRestoreChain = 0;

    if (NULL != ppwszCommonName)
    {
	*ppwszCommonName = NULL;
    }
    if (NULL != paRestoreChain)
    {
	ZeroMemory(paRestoreChain, *pcRestoreChain * sizeof(paRestoreChain[0]));
    }

    // Look for certificates with keys.  There should be at least one.

    for (;;)
    {
	BOOL fMatchingKey;
	WCHAR *pwszCommonNameT;
	CERT_CHAIN_CONTEXT const *pChain;
	DWORD NameId;

	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    break;
	}

	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}
	hr = myRepairCertKeyProviderInfo(pCert, !fUserStore, &pkpi);
	if (S_OK != hr)
	{
	    if (CRYPT_E_NOT_FOUND == hr)
	    {
		continue;
	    }
	    _JumpError(hr, error, "myRepairCertKeyProviderInfo");
	}
	if (NULL == pkpi || NULL == pkpi->pwszContainerName)
	{
	    continue;
	}

	hr = myVerifyPublicKey(
			pCert,
			CERT_V1 == pCert->pCertInfo->dwVersion,
			pkpi,		// pKeyProvInfo
			NULL,		// pPublicKeyInfo
			&fMatchingKey);
	_JumpIfError(hr, error, "myVerifyPublicKey");

	if (!fMatchingKey)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "Key doesn't match cert");
	}

	hr = myGetCertSubjectCommonName(pCert, &pwszCommonNameT);
	_JumpIfError(hr, error, "myGetCertSubjectCommonName");

	if (NULL == pwszCommonName)
	{
	    pwszCommonName = pwszCommonNameT;
	}
	else
	{
	    if (0 != lstrcmp(pwszCommonName, pwszCommonNameT))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_PrintErrorStr(hr, "first CommonName", pwszCommonName);
		_JumpErrorStr(hr, error, "multiple CommonNames", pwszCommonNameT);
	    }
	    LocalFree(pwszCommonNameT);
	}
	if (fCAChain)
	{
	    hr = myGetNameId(pCert, &NameId);
	    _PrintIfError(hr, "myGetNameId");
	}
	else
	{
	    NameId = 0;
	}

	if (NULL != paRestoreChain && iRestoreChain >= *pcRestoreChain)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	    _JumpError(hr, error, "Chain array full");
	}

	ZeroMemory(&ChainParams, sizeof(ChainParams));
	ChainParams.cbSize = sizeof(ChainParams);
	ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;

	// Get the chain and verify the cert:

	if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,		// hChainEngine
			    pCert,		// pCertContext
			    NULL,		// pTime
			    hStore,		// hAdditionalStore
			    &ChainParams,	// pChainPara
			    0,			// dwFlags
			    NULL,		// pvReserved
			    &pChain))		// ppChainContext
	{
	    hr = myHLastError();
	    _JumpIfError(hr, error, "CertGetCertificateChain");
	}
	if (NULL != paRestoreChain)
	{
	    paRestoreChain[iRestoreChain].pChain = pChain;
	    paRestoreChain[iRestoreChain].NameId = NameId;
	}
	else
	{
	    CertFreeCertificateChain(pChain);
	}
	iRestoreChain++;
    }
    if (NULL != ppwszCommonName)
    {
	*ppwszCommonName = pwszCommonName;
	pwszCommonName = NULL;
    }
    *pcRestoreChain = iRestoreChain;
    hr = S_OK;

error:
    if (S_OK != hr && NULL != paRestoreChain)
    {
	for (iRestoreChain = 0; iRestoreChain < *pcRestoreChain; iRestoreChain++)
	{
	    if (NULL != paRestoreChain[iRestoreChain].pChain)
	    {
		CertFreeCertificateChain(paRestoreChain[iRestoreChain].pChain);
		paRestoreChain[iRestoreChain].pChain = NULL;
	    }
	}
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
myCopyKeys(
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    IN WCHAR const *pwszOldContainer,
    IN WCHAR const *pwszNewContainer,
    IN WCHAR const *pwszNewCSP,
    IN BOOL fOldUserKey,
    IN BOOL fNewUserKey,
    IN BOOL fNewProtect,
    IN BOOL fForceOverWrite)
{
    HRESULT hr;
    HCRYPTPROV hProvOld = NULL;
    HCRYPTKEY hKeyOld = NULL;
    HCRYPTPROV hProvNew = NULL;
    HCRYPTKEY hKeyNew = NULL;
    CRYPT_BIT_BLOB PrivateKey;
    BOOL fKeyContainerNotFound = FALSE;

    ZeroMemory(&PrivateKey, sizeof(PrivateKey));

    if (!myCertSrvCryptAcquireContext(
			&hProvOld,
			pwszOldContainer,
			pkpi->pwszProvName,
			pkpi->dwProvType,
			pkpi->dwFlags,
			!fOldUserKey))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }
    if (!CryptGetUserKey(hProvOld, pkpi->dwKeySpec, &hKeyOld))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetUserKey");
    }
    hr = myCryptExportPrivateKey(
		    hKeyOld,
		    &PrivateKey.pbData,
		    &PrivateKey.cbData);
    _JumpIfError(hr, error, "myCryptExportPrivateKey");

    if (myCertSrvCryptAcquireContext(
			    &hProvNew,
			    pwszNewContainer,
			    pwszNewCSP,
			    pkpi->dwProvType,
			    pkpi->dwFlags,
			    !fNewUserKey))
    {
	if (!fForceOverWrite)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
	    _JumpErrorStr(hr, error, "Key Container Exists", pwszNewContainer);
	}

	// Delete the target key container

	CryptReleaseContext(hProvNew, 0);
        if (myCertSrvCryptAcquireContext(
			    &hProvNew,
			    pwszNewContainer,
			    pwszNewCSP,
			    pkpi->dwProvType,
			    pkpi->dwFlags | CRYPT_DELETEKEYSET,
			    !fNewUserKey))
        {
            fKeyContainerNotFound = TRUE;
        }
	hProvNew = NULL;
    }
    else
    {
        fKeyContainerNotFound = TRUE;
    }

    if (!myCertSrvCryptAcquireContext(
			    &hProvNew,
			    pwszNewContainer,
			    pwszNewCSP,
			    pkpi->dwProvType,
			    pkpi->dwFlags | 
			    (fKeyContainerNotFound? CRYPT_NEWKEYSET : 0),
			    !fNewUserKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCertSrvCryptAcquireContext");
    }

    if (!CryptImportKey(
		    hProvNew,
		    PrivateKey.pbData,
		    PrivateKey.cbData,
		    NULL,		// HCRYPTKEY hPubKey
		    CRYPT_EXPORTABLE | (fNewProtect? CRYPT_USER_PROTECTED : 0),
		    &hKeyNew))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }

error:
    if (NULL != PrivateKey.pbData)
    {
	SecureZeroMemory(PrivateKey.pbData, PrivateKey.cbData); // Key material
	LocalFree(PrivateKey.pbData);
    }
    if (NULL != hKeyNew)
    {
	CryptDestroyKey(hKeyNew);
    }
    if (NULL != hProvNew)
    {
	CryptReleaseContext(hProvNew, 0);
    }
    if (NULL != hKeyOld)
    {
	CryptDestroyKey(hKeyOld);
    }
    if (NULL != hProvOld)
    {
	CryptReleaseContext(hProvOld, 0);
    }
    return(hr);
}


HRESULT
myImportChainAndKeys(
    IN WCHAR const *pwszSanitizedCA,
    IN DWORD iCert,
    IN DWORD iKey,
    IN BOOL fForceOverWrite,
    IN CERT_CHAIN_CONTEXT const *pChain,
    OPTIONAL OUT CERT_CONTEXT const **ppccNewestCA)
{
    HRESULT hr;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;
    CERT_CHAIN_ELEMENT **ppChainElement;
    WCHAR *pwszKeyContainerName = NULL;

    hr = myAllocIndexedName(
			pwszSanitizedCA,
			iKey,
			MAXDWORD,
			&pwszKeyContainerName);
    _JumpIfError(hr, error, "myAllocIndexedName");

    ppChainElement = pChain->rgpChain[0]->rgpElement;

    hr = myCertGetKeyProviderInfo(ppChainElement[0]->pCertContext, &pkpi);
    _JumpIfError(hr, error, "myCertGetKeyProviderInfo");

    if (iCert == iKey)
    {
	hr = myCopyKeys(
		    pkpi,
		    pkpi->pwszContainerName,	// pwszOldContainer
		    pwszKeyContainerName,	// pwszNewContainer
		    pkpi->pwszProvName,		// pwszNewCSP
		    FALSE,			// fOldUserKey
		    FALSE,			// fNewUserKey
		    FALSE,			// fNewProtect
		    fForceOverWrite);
	_JumpIfError(hr, error, "myCopyKeys");
    }

    pkpi->pwszContainerName = pwszKeyContainerName;

    hr = mySaveChainAndKeys(
			pChain->rgpChain[0],
			wszMY_CERTSTORE,
			CERT_SYSTEM_STORE_LOCAL_MACHINE |
			    CERT_STORE_BACKUP_RESTORE_FLAG,
			pkpi,
			ppccNewestCA);
    _JumpIfError(hr, error, "mySaveChainAndKeys");

    hr = S_OK;

error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pwszKeyContainerName)
    {
        LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


HRESULT
FindPFXInBackupDir(
    IN WCHAR const *pwszBackupDir,
    OUT WCHAR **ppwszPFXFile)
{
    HRESULT hr;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR wszpath[MAX_PATH];
    WCHAR wszfile[MAX_PATH];
    DWORD cFile = 0;

    *ppwszPFXFile = NULL;

    if (wcslen(pwszBackupDir) +
	WSZARRAYSIZE(wszBSSTAR) +
	WSZARRAYSIZE(wszPFXFILENAMEEXT) >= ARRAYSIZE(wszpath))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "wszpath", pwszBackupDir);
    }
    wcscpy(wszpath, pwszBackupDir);
    wcscat(wszpath, wszBSSTAR);
    wcscat(wszpath, wszPFXFILENAMEEXT);

    hf = FindFirstFile(wszpath, &wfd);
    if (INVALID_HANDLE_VALUE != hf)
    {
	do {
	    if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	    {
		continue;
	    }
	    cFile++;
	    if (wcslen(wfd.cFileName) >= ARRAYSIZE(wszfile))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		_JumpErrorStr(hr, error, "wszpath", pwszBackupDir);
	    }
	    wcscpy(wszfile, wfd.cFileName);
	    //printf("File: %ws\n", wszfile);
	    break;

	} while (FindNextFile(hf, &wfd));
	FindClose(hf);
    }
    if (0 == cFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no *.p12 files");
    }
    if (1 < cFile)
    {
	hr = HRESULT_FROM_WIN32(ERROR_DIRECTORY);
	_JumpError(hr, error, "Too many *.p12 files");
    }

    *ppwszPFXFile = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszBackupDir) +
				     1 +
				     wcslen(wszfile) +
				     1) * sizeof(WCHAR));
    if (NULL == *ppwszPFXFile)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszPFXFile, pwszBackupDir);
    wcscat(*ppwszPFXFile, L"\\");
    wcscat(*ppwszPFXFile, wszfile);
    hr = S_OK;

error:
    return(hr);
}


// Return TRUE if pcc is newer than pcc2

BOOL
IsCACertNewer(
    IN CERT_CONTEXT const *pcc,
    IN DWORD NameId,
    IN CERT_CONTEXT const *pcc2,
    IN DWORD NameId2)
{
    BOOL fNewer = FALSE;
    CERT_INFO const *pci = pcc->pCertInfo;
    CERT_INFO const *pci2 = pcc2->pCertInfo;

    if (MAXDWORD != NameId && MAXDWORD != NameId2)
    {
	if (CANAMEIDTOICERT(NameId) > CANAMEIDTOICERT(NameId2))
	{
	    fNewer = TRUE;
	}
    }
    else
    if (CompareFileTime(&pci->NotAfter, &pci2->NotAfter) > 0)
    {
	fNewer = TRUE;
    }

#if 0
    HRESULT hr;
    WCHAR *pwszDate = NULL;
    WCHAR *pwszDate2 = NULL;

    hr = myGMTFileTimeToWszLocalTime(&pci->NotAfter, &pwszDate);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

    hr = myGMTFileTimeToWszLocalTime(&pci2->NotAfter, &pwszDate2);
    _PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

    printf(
	"%u.%u %ws is %wsnewer than %u.%u %ws\n",
	CANAMEIDTOICERT(NameId),
	CANAMEIDTOIKEY(NameId),
	pwszDate,
	fNewer? L"" : L"NOT ",
	CANAMEIDTOICERT(NameId2),
	CANAMEIDTOIKEY(NameId2),
	pwszDate2);

    if (NULL != pwszDate) LocalFree(pwszDate);
    if (NULL != pwszDate2) LocalFree(pwszDate2);
#endif

    return(fNewer);
}


#if 0
VOID
DumpChainArray(
    IN char const *psz,
    IN DWORD cCACert,
    IN OUT RESTORECHAIN *paRestoreChain)
{
    HRESULT hr;
    DWORD i;
    
    printf("\n%hs:\n", psz);
    for (i = 0; i < cCACert; i++)
    {
	WCHAR *pwszDate;
	
	hr = myGMTFileTimeToWszLocalTime(
	    &paRestoreChain[i].pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->NotBefore,
	    &pwszDate);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

	printf(
	    " %u: %u.%u %ws",
	    i,
	    CANAMEIDTOICERT(paRestoreChain[i].NameId),
	    CANAMEIDTOIKEY(paRestoreChain[i].NameId),
	    pwszDate);


	if (NULL != pwszDate) LocalFree(pwszDate);

	hr = myGMTFileTimeToWszLocalTime(
	    &paRestoreChain[i].pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->NotAfter,
	    &pwszDate);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");

	printf(" -- %ws\n", pwszDate);

	if (NULL != pwszDate) LocalFree(pwszDate);
    }
    printf("\n");
}
#endif


HRESULT
SortCACerts(
    IN DWORD cCACert,
    IN OUT RESTORECHAIN *paRestoreChain)
{
    HRESULT hr;
    DWORD i;
    DWORD j;

#if 0
    DumpChainArray("Start", cCACert, paRestoreChain);
#endif

    for (i = 0; i < cCACert; i++)
    {
	for (j = i + 1; j < cCACert; j++)
	{
	    CERT_CHAIN_CONTEXT const *pChain;
	    DWORD NameId;
	    DWORD NameId2;
	    CERT_CONTEXT const *pcc;
	    CERT_CONTEXT const *pcc2;

	    pChain = paRestoreChain[i].pChain;
	    NameId = paRestoreChain[i].NameId;
	    NameId2 = paRestoreChain[j].NameId;

	    pcc = pChain->rgpChain[0]->rgpElement[0]->pCertContext;
	    pcc2 = paRestoreChain[j].pChain->rgpChain[0]->rgpElement[0]->pCertContext;

#if 0
	    printf(
		"%u(%u.%u) %u(%u.%u): ",
		i,
		CANAMEIDTOIKEY(NameId),
		CANAMEIDTOICERT(NameId),
		j,
		CANAMEIDTOIKEY(NameId2),
		CANAMEIDTOICERT(NameId2));
#endif

	    if (IsCACertNewer(pcc, NameId, pcc2, NameId2))
	    {
		paRestoreChain[i] = paRestoreChain[j];
		paRestoreChain[j].pChain = pChain;
		paRestoreChain[j].NameId = NameId;
	    }
	}
    }
#if 0
    DumpChainArray("End", cCACert, paRestoreChain);
#endif

    hr = S_OK;

//error:
    return(hr);
}


#define cwcGUIDKEYS	38

HRESULT
myDeleteGuidKeys(
    IN HCERTSTORE hStorePFX,
    IN BOOL fMachineKeySet)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    CRYPT_KEY_PROV_INFO *pkpi = NULL;

    // Look for certificates with keys, and delete all key containers with
    // names that look like GUIDs.

    for (;;)
    {
	HCRYPTPROV hProv;

	pCert = CertEnumCertificatesInStore(hStorePFX, pCert);
	if (NULL == pCert)
	{
	    break;
	}

	if (NULL != pkpi)
	{
	    LocalFree(pkpi);
	    pkpi = NULL;
	}
	hr = myRepairCertKeyProviderInfo(pCert, FALSE, &pkpi);
	if (S_OK == hr &&
	    NULL != pkpi->pwszContainerName &&
	    wcLBRACE == pkpi->pwszContainerName[0] &&
	    cwcGUIDKEYS == wcslen(pkpi->pwszContainerName) &&
	    wcRBRACE == pkpi->pwszContainerName[cwcGUIDKEYS - 1])
	{
	    if (myCertSrvCryptAcquireContext(
			    &hProv,
			    pkpi->pwszContainerName,
			    pkpi->pwszProvName,
			    pkpi->dwProvType,
			    pkpi->dwFlags | CRYPT_DELETEKEYSET,
			    fMachineKeySet))
	    {
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "myDeleteGuidKeys(%ws, %ws)\n",
		    fMachineKeySet? L"Machine" : L"User",
		    pkpi->pwszContainerName));
	    }
	}
    }
    hr = S_OK;

//error:
    if (NULL != pkpi)
    {
	LocalFree(pkpi);
    }
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    return(hr);
}


HRESULT
myCertServerImportPFX(
    IN WCHAR const *pwszBackupDirOrPFXFile,
    IN WCHAR const *pwszPassword,
    IN BOOL fForceOverWrite,
    OPTIONAL OUT WCHAR **ppwszCommonName,
    OPTIONAL OUT WCHAR **ppwszPFXFile,
    OPTIONAL OUT CERT_CONTEXT const **ppccNewestCA)
{
    HRESULT hr;
    CRYPT_DATA_BLOB pfx;
    HCERTSTORE hStorePFX = NULL;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszSanitizedName = NULL;
    RESTORECHAIN *paRestoreChain = NULL;
    WCHAR *pwszPFXFile = NULL;
    DWORD FileAttr;
    BOOL fImpersonating = FALSE;
    DWORD cCACert;
    DWORD iCert;

    pfx.pbData = NULL;
    cCACert = 0;

    if (NULL != ppwszCommonName)
    {
        *ppwszCommonName = NULL;
    }
    if (NULL != ppwszPFXFile)
    {
        *ppwszPFXFile = NULL;
    }
    if (NULL != ppccNewestCA)
    {
        *ppccNewestCA = NULL;
    }

    if (!ImpersonateSelf(SecurityImpersonation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ImpersonateSelf");
    }
    fImpersonating = TRUE;

    hr = myEnablePrivilege(SE_RESTORE_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    hr = myEnablePrivilege(SE_BACKUP_NAME, TRUE);
    _JumpIfError(hr, error, "myEnablePrivilege");

    FileAttr = GetFileAttributes(pwszBackupDirOrPFXFile);
    if (MAXDWORD == FileAttr)
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetFileAttributes");
    }

    if (FILE_ATTRIBUTE_DIRECTORY & FileAttr)
    {
        hr = FindPFXInBackupDir(pwszBackupDirOrPFXFile, &pwszPFXFile);
        _JumpIfError(hr, error, "FindPFXInBackupDir");
    }
    else
    {
	hr = myDupString(pwszBackupDirOrPFXFile, &pwszPFXFile);
	_JumpIfError(hr, error, "myDupString");
    }

    hr = DecodeFileW(pwszPFXFile, &pfx.pbData, &pfx.cbData, CRYPT_STRING_ANY);
    _JumpIfError(hr, error, "DecodeFileW");

    CSASSERT(NULL != pfx.pbData);

    if (!PFXIsPFXBlob(&pfx))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "PFXIsPFXBlob");
    }

    hStorePFX = myPFXImportCertStore(
				&pfx,
				pwszPassword,
				CRYPT_EXPORTABLE | CRYPT_MACHINE_KEYSET);
    if (NULL == hStorePFX)
    {
        hr = myHLastError();
        _JumpError(hr, error, "myPFXImportCertStore");
    }

    hr = myGetChainArrayFromStore(
			    hStorePFX,
			    TRUE,		// fCAChain
			    FALSE,		// fUserStore
			    &pwszCommonName,
			    &cCACert,
			    NULL);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    if (0 == cCACert)
    {
        hr = HRESULT_FROM_WIN32(CRYPT_E_SELF_SIGNED);
        _JumpError(hr, error, "myGetChainArrayFromStore <no chain>");
    }

    paRestoreChain = (RESTORECHAIN *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cCACert * sizeof(paRestoreChain[0]));
    if (NULL == paRestoreChain)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = myGetChainArrayFromStore(
			    hStorePFX,
			    TRUE,		// fCAChain
			    FALSE,		// fUserStore
			    NULL,
			    &cCACert,
			    paRestoreChain);
    _JumpIfError(hr, error, "myGetChainArrayFromStore");

    hr = SortCACerts(cCACert, paRestoreChain);
    _JumpIfError(hr, error, "SortCACerts");

    hr = mySanitizeName(pwszCommonName, &pwszSanitizedName);
    _JumpIfError(hr, error, "mySanitizeName");

    for (iCert = 0; iCert < cCACert; iCert++)
    {
	CERT_CHAIN_CONTEXT const *pChain = paRestoreChain[iCert].pChain;
	DWORD iKey;
	CERT_PUBLIC_KEY_INFO *pPublicKeyInfo;
	WCHAR *pwszDN;

	if (1 > pChain->cChain)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "No Chain Context");
	}

	// Compute iKey by comparing this public key to the public keys
	// of all certs in the array already processed.

	pPublicKeyInfo = &pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->SubjectPublicKeyInfo;

	for (iKey = 0; iKey < iCert; iKey++)
	{
	    if (CertComparePublicKeyInfo(
				    X509_ASN_ENCODING,
				    pPublicKeyInfo,
				    &paRestoreChain[iKey].pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->SubjectPublicKeyInfo))
	    {
		// by design, CertComparePublicKeyInfo doesn't set last error!

		break;
	    }
	}
	pwszDN = NULL;
	hr = myCertNameToStr(
		    X509_ASN_ENCODING,
		    &pChain->rgpChain[0]->rgpElement[0]->pCertContext->pCertInfo->Subject,
		    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		    &pwszDN);
	_PrintIfError(hr, "myCertNameToStr");
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "Import: %u.%u -- %u.%u: %ws\n",
	    iCert,
	    iKey,
	    CANAMEIDTOICERT(paRestoreChain[iCert].NameId),
	    CANAMEIDTOIKEY(paRestoreChain[iCert].NameId),
	    pwszDN));
	if (NULL != pwszDN)
	{
	    LocalFree(pwszDN);
	}

	// Retrieve the cert context for the newest CA cert chain in the PFX
	// we are importing.  We must return a cert context with the new
	// key prov info, not the PFX cert context with a GUID key container.

	hr = myImportChainAndKeys(
			    pwszSanitizedName,
			    iCert,
			    iKey,
			    fForceOverWrite,
			    pChain,
			    iCert + 1 == cCACert? ppccNewestCA : NULL);
	_JumpIfError(hr, error, "myImportChainAndKeys");
    }

    if (NULL != ppwszCommonName)
    {
        *ppwszCommonName = pwszCommonName;
        pwszCommonName = NULL;
    }
    if (NULL != ppwszPFXFile)
    {
        *ppwszPFXFile = pwszPFXFile;
        pwszPFXFile = NULL;
    }
    hr = S_OK;

error:
    if (NULL != paRestoreChain)
    {
        for (iCert = 0; iCert < cCACert; iCert++)
	{
	    if (NULL != paRestoreChain[iCert].pChain)
	    {
		CertFreeCertificateChain(paRestoreChain[iCert].pChain);
	    }
	}
	LocalFree(paRestoreChain);
    }
    if (NULL != pwszPFXFile)
    {
        LocalFree(pwszPFXFile);
    }
    if (NULL != pwszCommonName)
    {
        LocalFree(pwszCommonName);
    }
    if (NULL != pwszSanitizedName)
    {
        LocalFree(pwszSanitizedName);
    }
    if (NULL != hStorePFX)
    {
        myDeleteGuidKeys(hStorePFX, TRUE);
	CertCloseStore(hStorePFX, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != pfx.pbData)
    {
        LocalFree(pfx.pbData);
    }
    if (fImpersonating)
    {
        myEnablePrivilege(SE_RESTORE_NAME, FALSE);
        myEnablePrivilege(SE_BACKUP_NAME,  FALSE);
        RevertToSelf();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\certlib.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certlib.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include <time.h>
#include <locale.h>
extern "C" {
#include <luidate.h>
}
#include <wininet.h>

#include "csdisp.h"
#include "csprop.h"
#include <winnlsp.h>
#include <winldap.h>
#include <ntsecapi.h>
#include "csldap.h"
#include <tfc.h>
#include "cainfop.h"
#include <dsgetdc.h>
#include <lm.h>

#define __dwFILE__	__dwFILE_CERTLIB_CERTLIB_CPP__


#define  wszSANITIZEESCAPECHAR  L"!"
#define  wszURLESCAPECHAR       L"%"
#define  wcSANITIZEESCAPECHAR   L'!'

char
PrintableChar(char ch)
{
    if (ch < ' ' || ch > '~')
    {
        ch = '.';
    }
    return(ch);
}


VOID
mydbgDumpHex(
    IN DWORD dwSubSysId,
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb)
{
    if (DbgIsSSActive(dwSubSysId))
    {
	DumpHex(Flags, pb, cb);
    }
}


VOID
DumpHex(
    IN DWORD Flags,
    IN BYTE const *pb,
    IN ULONG cb)
{
    char const *pszsep;
    ULONG r;
    ULONG i;
    ULONG cbremain;
    BOOL fZero = FALSE;
    DWORD cchIndent;
    DWORD cchAsciiSep;
    char szAddress[8 + 1];
    char szHexDump[1 + 1 + 3 * 16 + 1];
    char szAsciiDump[16 + 1];
    char *psz;

    cchIndent = DH_INDENTMASK & Flags;
    if ((DH_MULTIADDRESS & Flags) && 16 >= cb)
    {
	Flags |= DH_NOADDRESS;
    }
    cbremain = 0;
    for (r = 0; r < cb; r += 16)
    {
	szAddress[0] = '\0';
        if (0 == (DH_NOADDRESS & Flags))
	{
	    sprintf(szAddress, 64 * 1024 < cb? "%06x": "%04x", r);
	    CSASSERT(strlen(szAddress) < ARRAYSIZE(szAddress));
	}

	cbremain = cb - r;
        if (r != 0 && pb[r] == 0 && cbremain >= 16)
        {
            ULONG j;

            for (j = r + 1; j < cb; j++)
            {
                if (pb[j] != 0)
                {
                    break;
                }
            }
            if (j == cb)
            {
                fZero = TRUE;
                break;
            }
        }

	psz = szHexDump;
        for (i = 0; i < min(cbremain, 16); i++)
        {
            pszsep = " ";
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = "  ";
                if (i == 0)             // 0
                {
		    if (0 == (DH_NOTABPREFIX & Flags))
		    {
			pszsep = "\t";
		    }
		    else if (DH_NOADDRESS & Flags)
		    {
			pszsep = "";
		    }
                }
            }
	    CSASSERT(strlen(pszsep) <= 2);
            psz += sprintf(psz, "%hs%02x", pszsep, pb[r + i]);
        }
	*psz = '\0';
	CSASSERT(strlen(szHexDump) < ARRAYSIZE(szHexDump));

	cchAsciiSep = 0;
	szAsciiDump[0] = '\0';
	if (0 == (DH_NOASCIIHEX & Flags) && 0 != i)
        {
            cchAsciiSep = 3 + (16 - i)*3 + ((i <= 8)? 1 : 0);
            for (i = 0; i < min(cbremain, 16); i++)
            {
		szAsciiDump[i] = PrintableChar(pb[r + i]);
            }
	    szAsciiDump[i] = '\0';
	    CSASSERT(strlen(szAsciiDump) < ARRAYSIZE(szAsciiDump));
        }
	char szBuf[
		sizeof(szAddress) +
		sizeof(szHexDump) +
		3 +
		sizeof(szAsciiDump)];
	_snprintf(
		szBuf,
		ARRAYSIZE(szBuf),
		"%hs%hs%*hs%hs",
		szAddress,
		szHexDump,
		cchAsciiSep,
		"",
		szAsciiDump);
	szBuf[ARRAYSIZE(szBuf) - 1] = '\0';
	CSASSERT(strlen(szBuf) + 1 < ARRAYSIZE(szBuf));

#define szFMTHEXDUMP	"%*hs%hs\n"
	if (DH_PRIVATEDATA & Flags)
	{
	    wprintf(TEXT(szFMTHEXDUMP), cchIndent, "", szBuf);
	}
	else
	{
	    CONSOLEPRINT7((MAXDWORD, szFMTHEXDUMP, cchIndent, "", szBuf));
	}
    }
    if (fZero)
    {
        CONSOLEPRINT1((MAXDWORD, "\tRemaining %lx bytes are zero\n", cbremain));
    }
}


HRESULT
myDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (*pDate == 0.0)
    {
        GetSystemTime(&st);
    }
    else
    {
	if (!VariantTimeToSystemTime(*pDate, &st))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "VariantTimeToSystemTime");
	}
    }

    if (!SystemTimeToFileTime(&st, pft))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

error:
    return(hr);
}

HRESULT
myMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    HRESULT hr;
    FILETIME ft;

    hr = myDateToFileTime(pDate, &ft);
    _JumpIfError(hr, error, "myDateToFileTime");

    myMakeExprDateTime(&ft, lDelta, enumPeriod);

    hr = myFileTimeToDate(&ft, pDate);
    _JumpIfError(hr, error, "myFileTimeToDate");

error:
    return(hr);
}


typedef struct _UNITSTABLE
{
    WCHAR const     *pwszString;
    enum ENUM_PERIOD enumPeriod;
} UNITSTABLE;

UNITSTABLE g_aut[] =
{
    { wszPERIODSECONDS, ENUM_PERIOD_SECONDS },
    { wszPERIODMINUTES, ENUM_PERIOD_MINUTES },
    { wszPERIODHOURS,   ENUM_PERIOD_HOURS },
    { wszPERIODDAYS,    ENUM_PERIOD_DAYS },
    { wszPERIODWEEKS,   ENUM_PERIOD_WEEKS },
    { wszPERIODMONTHS,  ENUM_PERIOD_MONTHS },
    { wszPERIODYEARS,   ENUM_PERIOD_YEARS },
};
#define CUNITSTABLEMAX	(sizeof(g_aut)/sizeof(g_aut[0]))


HRESULT
myTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount)
{
    HRESULT hr;
    UNITSTABLE const *put;

    for (put = g_aut; put < &g_aut[CUNITSTABLEMAX]; put++)
    {
	if (0 == mylstrcmpiS(pwszPeriod, put->pwszString))
	{
	    *penumPeriod = put->enumPeriod;
	    if (0 > lCount)
	    {
		lCount = MAXLONG;
	    }
	    *plCount = lCount;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    CSASSERT(hr == S_OK);
    return(hr);
}


HRESULT
myTranslateUnlocalizedPeriodString(
    IN enum ENUM_PERIOD enumPeriod,
    OUT WCHAR const **ppwszPeriodString)
{
    HRESULT hr;
    UNITSTABLE const *put;

    *ppwszPeriodString = NULL;
    for (put = g_aut; put < &g_aut[CUNITSTABLEMAX]; put++)
    {
	if (enumPeriod == put->enumPeriod)
	{
	    *ppwszPeriodString = put->pwszString;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    CSASSERT(hr == S_OK);
    return(hr);
}


HRESULT
myFileTimePeriodToWszTimePeriod(
    IN FILETIME const *pftGMT,
    IN BOOL fExact,
    OUT WCHAR **ppwszTimePeriod)
{
    HRESULT hr;
    DWORD cPeriodUnits;
    PERIODUNITS *rgPeriodUnits = NULL;
    WCHAR const *pwszUnitSep;
    DWORD i;
    WCHAR awc[MAX_PATH];
    WCHAR *pwsz;

    *ppwszTimePeriod = NULL; 
    hr = caTranslateFileTimePeriodToPeriodUnits(
					pftGMT,
					fExact,
					&cPeriodUnits,
					&rgPeriodUnits);
    _JumpIfError(hr, error, "caTranslateFileTimePeriodToPeriodUnits");

    CSASSERT(0 < cPeriodUnits);
    pwszUnitSep = L"";
    pwsz = awc;
    for (i = 0; i < cPeriodUnits; i++)
    {
	WCHAR const *pwszPeriodString;

	hr = myTranslateUnlocalizedPeriodString(
				rgPeriodUnits[i].enumPeriod,
				&pwszPeriodString);
	_JumpIfError(hr, error, "myTranslateUnlocalizedPeriodString");

	pwsz += wsprintf(
		    pwsz,
		    L"%ws%u %ws",
		    pwszUnitSep,
		    rgPeriodUnits[i].lCount,
		    pwszPeriodString);
	pwszUnitSep = L", ";
    }
    hr = myDupString(awc, ppwszTimePeriod);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != rgPeriodUnits)
    {
	LocalFree(rgPeriodUnits);
    }
    return(hr);
}


HRESULT
myFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (!FileTimeToSystemTime(pft, &st))
    {
        hr = myHLastError();
        _JumpError(hr, error, "FileTimeToSystemTime");
    }
    if (!SystemTimeToVariantTime(&st, pDate))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "SystemTimeToVariantTime");
    }

error:
    return(hr);
}


HRESULT
mySystemTimeToGMTSystemTime(
    IN OUT SYSTEMTIME *pSys)
{
    // Conversion path: SystemTimeLocal -> ftLocal -> ftGMT -> SystemTimeGMT

    FILETIME ftLocal, ftGMT;
    HRESULT hr = S_OK;

    if (!SystemTimeToFileTime(pSys, &ftLocal))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

    if (!LocalFileTimeToFileTime(&ftLocal, &ftGMT))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LocalFileTimeToFileTime");
    }

    if (!FileTimeToSystemTime(&ftGMT, pSys))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FileTimeToSystemTime");
    }

error:
    return hr;
}


HRESULT
myGMTFileTimeToWszLocalTime(
    IN FILETIME const *pftGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime)
{
    HRESULT hr;
    FILETIME ftLocal;

    *ppwszLocalTime = NULL;

    if (!FileTimeToLocalFileTime(pftGMT, &ftLocal))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FileTimeToLocalFileTime");
    }
    hr = myFileTimeToWszTime(&ftLocal, fSeconds, ppwszLocalTime);
    _JumpIfError(hr, error, "myFileTimeToWszTime");

error:
    return(hr);
}


HRESULT
myFileTimeToWszTime(
    IN FILETIME const *pft,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszTime)
{
    HRESULT hr;
    SYSTEMTIME st;
    WCHAR awcDate[128];
    WCHAR awcTime[128];
    WCHAR *pwsz;

    *ppwszTime = NULL;

    if (!FileTimeToSystemTime(pft, &st))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FileTimeToSystemTime");
    }

    if (0 == GetDateFormat(
		    LOCALE_USER_DEFAULT,
		    DATE_SHORTDATE,
		    &st,
		    NULL,
		    awcDate,
		    sizeof(awcDate)/sizeof(awcDate[0])))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetDateFormat");
    }

    if (0 == GetTimeFormat(
		    LOCALE_USER_DEFAULT,
		    TIME_NOSECONDS,
		    &st,
		    NULL,
		    awcTime,
		    sizeof(awcTime)/sizeof(awcTime[0])))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetTimeFormat");
    }

    if (fSeconds)
    {
	wsprintf(
	    &awcTime[wcslen(awcTime)],
	    L" %02u.%03us",
	    st.wSecond,
	    st.wMilliseconds);
    }

    pwsz = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    (wcslen(awcDate) + 1 + wcslen(awcTime) + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwsz, awcDate);
    wcscat(pwsz, L" ");
    wcscat(pwsz, awcTime);

    *ppwszTime = pwsz;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGMTDateToWszLocalTime(
    IN DATE const *pDateGMT,
    IN BOOL fSeconds,
    OUT WCHAR **ppwszLocalTime)
{
    HRESULT hr;
    FILETIME ftGMT;

    *ppwszLocalTime = NULL;

    hr = myDateToFileTime(pDateGMT, &ftGMT);
    _JumpIfError(hr, error, "myDateToFileTime");

    hr = myGMTFileTimeToWszLocalTime(&ftGMT, fSeconds, ppwszLocalTime);
    _JumpIfError(hr, error, "FileTimeToLocalFileTime");

    hr = S_OK;

error:
    return(hr);
}


HRESULT
myWszLocalTimeToGMTDate(
    IN WCHAR const *pwszLocalTime,
    OUT DATE *pDateGMT)
{
    HRESULT hr;
    FILETIME ftGMT;

    hr = myWszLocalTimeToGMTFileTime(pwszLocalTime, &ftGMT);
    _JumpIfError2(hr, error, "myWszLocalTimeToGMTFileTime", E_INVALIDARG);

    hr = myFileTimeToDate(&ftGMT, pDateGMT);
    _JumpIfError(hr, error, "myFileTimeToDate");

error:
    return(hr);
}


HRESULT
myWszLocalTimeToGMTFileTime(
    IN WCHAR const *pwszLocalTime,
    OUT FILETIME *pftGMT)
{
    HRESULT hr;
    time_t time;
    USHORT parselen;
    struct tm *ptm;
    SYSTEMTIME stLocal;
    FILETIME ftLocal;
    char *pszLocalTime = NULL;

    if (!ConvertWszToSz(&pszLocalTime, pwszLocalTime, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }

    hr = LUI_ParseDateTime(pszLocalTime, (time_t *) &time, &parselen, 0);
    if (S_OK != hr)
    {
	_PrintError2(hr, "LUI_ParseDateTime", hr);
        hr = E_INVALIDARG;
	_JumpError2(hr, error, "LUI_ParseDateTime", hr);
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myWszLocalTimeToGMTDate = %ws: %x -- %ws\n",
	pwszLocalTime,
	time,
	_wctime(&time)));

    ptm = gmtime(&time);
    if (ptm == NULL)
    {
        hr = E_UNEXPECTED;
        _JumpError(hr, error, "gmTime");
    }

    stLocal.wYear = (WORD) ptm->tm_year + 1900;
    stLocal.wMonth = (WORD) ptm->tm_mon + 1;
    stLocal.wDayOfWeek = (WORD) ptm->tm_wday;
    stLocal.wDay = (WORD) ptm->tm_mday;
    stLocal.wHour = (WORD) ptm->tm_hour;
    stLocal.wMinute = (WORD) ptm->tm_min;
    stLocal.wSecond = (WORD) ptm->tm_sec;
    stLocal.wMilliseconds = 0;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%u/%u/%u %u:%02u:%02u.%03u DayOfWeek=%u\n",
	stLocal.wMonth,
	stLocal.wDay,
	stLocal.wYear,
	stLocal.wHour,
	stLocal.wMinute,
	stLocal.wSecond,
	stLocal.wMilliseconds,
	stLocal.wDayOfWeek));

    if (!SystemTimeToFileTime(&stLocal, &ftLocal))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

    if (!LocalFileTimeToFileTime(&ftLocal, pftGMT))
    {
        hr = myHLastError();
        _JumpError(hr, error, "LocalFileTimeToFileTime");
    }

error:
    if (NULL != pszLocalTime)
    {
	LocalFree(pszLocalTime);
    }
    return(hr);
}

// counts # of string in a multisz string
DWORD CountMultiSz(LPCWSTR pcwszString)
{
    DWORD dwCount = 0;

    if(!pcwszString)
        return 0;
    while(*pcwszString)
    {
        dwCount++;
        pcwszString += wcslen(pcwszString)+1;
    }
    return dwCount;
}

//
// myRegValueToVariant and myVariantToRegValue map registry values 
// to/from variant:
//
// REG_SZ       <->     VT_BSTR
// REG_BINARY   <->     VT_ARRAY|VT_UI1
// REG_DWORD    <->     VT_I4 (VT_I2)
// REG_MULTI_SZ <->     VT_ARRAY|VT_BSTR
//

HRESULT myRegValueToVariant(
    IN DWORD dwType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pVar)
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sab;
    LPWSTR pwszCrtString = (LPWSTR)pbValue;
    BSTR bstr = NULL;
    SAFEARRAY* psa;

    VariantInit(pVar);

    switch(dwType)
    {
    case REG_SZ:
        if(sizeof(WCHAR)<=cbValue)
            cbValue -= sizeof(WCHAR);
	    V_BSTR(pVar) = NULL;
	    if (!ConvertWszToBstr(
			    &(V_BSTR(pVar)),
			    (WCHAR const *) pbValue,
			    cbValue))
	    {
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToBstr");
	    }
        V_VT(pVar) = VT_BSTR;
        break;

    case REG_BINARY:
        sab.cElements = cbValue;
        sab.lLbound = 0;
        psa = SafeArrayCreate(
                            VT_UI1,
                            1,
                            &sab);
        if(!psa)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "SafeArrayCreate");
        }
        for(DWORD c=0; c<sab.cElements; c++)
        {
            hr = SafeArrayPutElement(psa, (LONG*)&c, (LPVOID)&pbValue[c]);
            _JumpIfError(hr, error, "SafeArrayPutElement");
        }
                
        V_VT(pVar) = VT_ARRAY|VT_UI1;
        V_ARRAY(pVar) = psa;
        break;

    case REG_DWORD:
	    V_VT(pVar) = VT_I4;
	    V_I4(pVar) = *(LONG const *) pbValue;
        break;

    case REG_MULTI_SZ:
        sab.cElements = CountMultiSz((LPCWSTR)pbValue);
        sab.lLbound = 0;
        psa = SafeArrayCreate(
                            VT_BSTR,
                            1,
                            &sab);
        if(!psa)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "SafeArrayCreate");
        }
        for(DWORD cStr=0; cStr<sab.cElements; cStr++)
        {
            if(!ConvertWszToBstr(
                    &bstr,
                    pwszCrtString,
                    -1))
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "ConvertWszToBstr");
            }

            hr = SafeArrayPutElement(psa, (LONG*)&cStr, bstr);
            _JumpIfError(hr, error, "SafeArrayPutElement");

            pwszCrtString += wcslen(pwszCrtString)+1;

            SysFreeString(bstr);
            bstr = NULL;
        }
        
        V_VT(pVar) = VT_ARRAY|VT_BSTR;
        V_ARRAY(pVar) = psa;
        break;

    default:
        hr = E_INVALIDARG;
        _JumpError(hr, error, "invalid type");
    }

error:
    if(bstr)
        SysFreeString(bstr);
    return hr;
}


HRESULT
myVariantToRegValue(
    IN VARIANT const *pvarPropertyValue,
    OUT DWORD *pdwType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop)
{
    HRESULT hr = S_OK;
    DWORD cbprop = 0;
    BYTE *pbprop = NULL; // no free
    LONG lLbound, lUbound;
    void * pData = NULL;
    LPSAFEARRAY psa = NULL; // no free
    BSTR bstr = NULL; // no free

    *ppbprop = NULL;
    *pcbprop = 0;

    switch (pvarPropertyValue->vt)
    {
        case VT_BYREF|VT_BSTR:
        case VT_BSTR:
            bstr = (pvarPropertyValue->vt & VT_BYREF)?
                *V_BSTRREF(pvarPropertyValue):
                V_BSTR(pvarPropertyValue);

            *pdwType = REG_SZ;

            if (NULL == bstr)
            {
                bstr = L"";
            }

            pbprop = (BYTE *) bstr;
            cbprop = (wcslen(bstr) + 1) * sizeof(WCHAR);
            break;

        case VT_BYREF|VT_ARRAY|VT_UI1:
        case VT_ARRAY|VT_UI1:
            psa = (pvarPropertyValue->vt & VT_BYREF)?
                *V_ARRAYREF(pvarPropertyValue):
                V_ARRAY(pvarPropertyValue);
            *pdwType = REG_BINARY;
            if(1!=SafeArrayGetDim(psa))
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "only 1 dim array of bytes allowed");
            }
                
            hr = SafeArrayGetLBound(
                psa,
                1,
                &lLbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayGetUBound(
                psa,
                1,
                &lUbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayAccessData(psa, &pData);
            _JumpIfError(hr, error, "SafeArrayGetLBound");
            
            cbprop = lUbound-lLbound+1;
            pbprop = (LPBYTE)pData;
            break;

        case VT_BYREF|VT_I2:
        case VT_I2:
            *pdwType = REG_DWORD;
            pbprop = (BYTE *)((pvarPropertyValue->vt & VT_BYREF)?
                V_I2REF(pvarPropertyValue):
                &V_I2(pvarPropertyValue));
            cbprop = sizeof(V_I2(pvarPropertyValue));
            break;

        case VT_BYREF|VT_I4:
        case VT_I4:
            *pdwType = REG_DWORD;
            pbprop = (BYTE *) ((pvarPropertyValue->vt & VT_BYREF)?
                V_I4REF(pvarPropertyValue):
                &V_I4(pvarPropertyValue));
		    cbprop = sizeof(pvarPropertyValue->lVal);
    		break;

        case VT_BYREF|VT_ARRAY|VT_BSTR:
        case VT_ARRAY|VT_BSTR:
            psa = (pvarPropertyValue->vt & VT_BYREF)?
                *V_ARRAYREF(pvarPropertyValue):
                V_ARRAY(pvarPropertyValue);

            *pdwType = REG_MULTI_SZ;
            if(1!=SafeArrayGetDim(psa))
            {
                hr = E_INVALIDARG;
                _JumpError(hr, error, "only 1 dim array of bstr allowed");
            }
            
            hr = SafeArrayGetLBound(
                psa,
                1,
                &lLbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayGetUBound(
                psa,
                1,
                &lUbound);
            _JumpIfError(hr, error, "SafeArrayGetLBound");

            hr = SafeArrayAccessData(psa, &pData);
            _JumpIfError(hr, error, "SafeArrayGetLBound");
            
            for(LONG c=0;c<=lUbound-lLbound;c++)
            {
                BSTR str = ((BSTR *) pData)[c];

                if (NULL == str)
		{
		    hr = E_POINTER;
		    _JumpError(hr, error, "BSTR NULL");
		}
		cbprop += wcslen(str)+1;
            }
            cbprop += 1;
            cbprop *= sizeof(WCHAR);

            {
		BYTE* pbprop2 = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
		if (NULL == pbprop2)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		*ppbprop = pbprop2;

		for(LONG c=0;c<=lUbound-lLbound;c++)
		{
		    wcscpy((LPWSTR)pbprop2, ((BSTR*)pData)[c]);
		    pbprop2 += (wcslen((LPWSTR)pbprop2)+1)*sizeof(WCHAR);
		}
        
		*(LPWSTR)pbprop2 = L'\0';
            }
            break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "invalid variant type");
    }

    if (NULL != pbprop)
    {
        *ppbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
        if (NULL == *ppbprop)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        CopyMemory(*ppbprop, pbprop, cbprop);
    }

    *pcbprop = cbprop;

error:

    if(pData)
    {
        CSASSERT(psa);
        SafeArrayUnaccessData(psa);
    }
    return(hr);
}


HRESULT
myUnmarshalVariant(
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue)
{
    HRESULT hr = S_OK;

    CSASSERT(NULL != pvarValue);
    VariantInit(pvarValue);

    // pb = NULL, cb = 0 always returns VT_EMPTY

    if (NULL == pbValue)
    {
	CSASSERT(0 == cbValue);
        CSASSERT(VT_EMPTY == pvarValue->vt);
        goto error;
    }

    switch (PROPTYPE_MASK & PropType)
    {
	case PROPTYPE_STRING:
	    if (0 == (PROPMARSHAL_LOCALSTRING & PropType) &&
		sizeof(WCHAR) <= cbValue)
	    {
		cbValue -= sizeof(WCHAR);
	    }
	    if (*(WCHAR const*)(pbValue+cbValue) != L'\0' &&
            wcslen((WCHAR const *) pbValue) * sizeof(WCHAR) != cbValue)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad string len");
	    }
	    // FALLTHROUGH:

	case PROPTYPE_BINARY:
//	    CSASSERT(0 != cbValue);
	    pvarValue->bstrVal = NULL;
	    if (!ConvertWszToBstr(
			    &pvarValue->bstrVal,
			    (WCHAR const *) pbValue,
			    cbValue))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "ConvertWszToBstr");
	    }
	    pvarValue->vt = VT_BSTR;
	    break;

	case PROPTYPE_LONG:
	    if (sizeof(LONG) != cbValue)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad PROPTYPE_LONG len");
	    }
	    pvarValue->vt = VT_I4;
	    pvarValue->lVal = *(LONG const *) pbValue;
	    break;

	case PROPTYPE_DATE:
	    if (sizeof(FILETIME) != cbValue)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "bad PROPTYPE_DATE len");
	    }
	    hr = myFileTimeToDate(
				(FILETIME const *) pbValue,
				&pvarValue->date);
	    _JumpIfError(hr, error, "myFileTimeToDate");

	    pvarValue->vt = VT_DATE;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropType parameter");
    }

error:
    return(hr);
}


HRESULT
myUnmarshalFormattedVariant(
    IN DWORD Flags,
    IN DWORD PropId,
    IN DWORD PropType,
    IN DWORD cbValue,
    IN BYTE const *pbValue,
    OUT VARIANT *pvarValue)
{
    HRESULT hr;
    BSTR strCert;
    
    hr = myUnmarshalVariant(
		    PropType,
		    cbValue,
		    pbValue,
		    pvarValue);
    _JumpIfError(hr, error, "myUnmarshalVariant");

    if (PROPTYPE_BINARY == (PROPTYPE_MASK & PropType))
    {
	CSASSERT(VT_BSTR == pvarValue->vt);

	CSASSERT(CSExpr(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER));
	CSASSERT(CSExpr(CV_OUT_BASE64 == CRYPT_STRING_BASE64));
	CSASSERT(CSExpr(CV_OUT_BINARY == CRYPT_STRING_BINARY));
	CSASSERT(CSExpr(CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER));
	CSASSERT(CSExpr(CV_OUT_HEX == CRYPT_STRING_HEX));
	CSASSERT(CSExpr(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII));
	CSASSERT(CSExpr(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR));
	CSASSERT(CSExpr(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR));

	switch (Flags)
	{
	    case CV_OUT_BASE64HEADER:
		if (CR_PROP_BASECRL == PropId || CR_PROP_DELTACRL == PropId)
		{
		    Flags = CV_OUT_BASE64X509CRLHEADER;
		}
		else
		if (MAXDWORD == PropId)
		{
		    Flags = CV_OUT_BASE64REQUESTHEADER;
		}
		break;

	    case CV_OUT_BASE64:
	    case CV_OUT_BINARY:
	    case CV_OUT_BASE64REQUESTHEADER:
	    case CV_OUT_BASE64X509CRLHEADER:
	    case CV_OUT_HEX:
	    case CV_OUT_HEXASCII:
	    case CV_OUT_HEXADDR:
	    case CV_OUT_HEXASCIIADDR:
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Flags");
	}

	if (CV_OUT_BINARY != Flags)
	{
	    strCert = NULL;
	    hr = EncodeCertString(pbValue, cbValue, Flags, &strCert);
	    _JumpIfError(hr, error, "EncodeCertString");

	    SysFreeString(pvarValue->bstrVal);
	    pvarValue->bstrVal = strCert;
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myMarshalVariant(
    IN VARIANT const *pvarPropertyValue,
    IN DWORD PropType,
    OUT DWORD *pcbprop,
    OUT BYTE **ppbprop)
{
    HRESULT hr = S_OK;
    DWORD cbprop = 0;
    BYTE *pbprop = NULL;
    BSTR str = NULL;
    FILETIME ft;
    LONG lval;

    *ppbprop = NULL;

    // VT_EMPTY always produces same result: *ppbprop = NULL, *pcbprop = 0
    if (VT_EMPTY != pvarPropertyValue->vt)
    {
	switch (PROPTYPE_MASK & PropType)
	{
	    case PROPTYPE_BINARY:
	    case PROPTYPE_STRING:
		switch (pvarPropertyValue->vt)
		{
		    case VT_BYREF | VT_BSTR:
			if (NULL != pvarPropertyValue->pbstrVal)
			{
			    str = *pvarPropertyValue->pbstrVal;
			}
			break;

		    case VT_BSTR:
			str = pvarPropertyValue->bstrVal;
			break;
		}
		if (NULL == str)
		{
		    if (PROPTYPE_STRING == (PROPTYPE_MASK & PropType) &&
			(PROPMARSHAL_NULLBSTROK & PropType) &&
			VT_NULL == pvarPropertyValue->vt)
		    {
			cbprop = 0;
		    }
		    else
		    {
			hr = E_INVALIDARG;
			_JumpError(
				pvarPropertyValue->vt,
				error,
				"variant BSTR type/value");
		    }
		}
		else
		{
		    pbprop = (BYTE *) str;
		    if (PROPTYPE_BINARY == (PROPTYPE_MASK & PropType))
		    {
			cbprop = SysStringByteLen(str) + sizeof(WCHAR);
		    }
		    else
		    {
			cbprop = (wcslen(str) + 1) * sizeof(WCHAR);
		    }
		}
		break;

	    case PROPTYPE_LONG:
		// VB likes to send small constant integers as VT_I2

		if (VT_I2 == pvarPropertyValue->vt)
		{
		    lval = pvarPropertyValue->iVal;
		}
		else if (VT_I4 == pvarPropertyValue->vt)
		{
		    lval = pvarPropertyValue->lVal;
		}
		else if (VT_EMPTY == pvarPropertyValue->vt)
		{
		    pbprop = NULL;
		    cbprop = 0;
		    break;
		}
		else
		{
		    hr = E_INVALIDARG;
		    _JumpError(pvarPropertyValue->vt, error, "variant LONG type");
		}
		pbprop = (BYTE *) &lval;
		cbprop = sizeof(lval);
		break;

	    case PROPTYPE_DATE:
		if (VT_DATE == pvarPropertyValue->vt)
		{
		    hr = myDateToFileTime(&pvarPropertyValue->date, &ft);
		    _JumpIfError(hr, error, "myDateToFileTime");
		}
		else if (VT_EMPTY == pvarPropertyValue->vt)
		{
		    pbprop = NULL;
		    cbprop = 0;
		    break;
		}
		else
		{
		    hr = E_INVALIDARG;
		    _JumpError(pvarPropertyValue->vt, error, "variant DATE type");
		}

		pbprop = (BYTE *) &ft;
		cbprop = sizeof(ft);
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(pvarPropertyValue->vt, error, "variant type/value");
	}
	if (NULL != pbprop)
	{
	    *ppbprop = (BYTE *) LocalAlloc(LMEM_FIXED, cbprop);
	    if (NULL == *ppbprop)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    CopyMemory(*ppbprop, pbprop, cbprop);
	    if (NULL != str &&
		sizeof(WCHAR) <= cbprop &&
		((PROPMARSHAL_LOCALSTRING & PropType) ||
		 PROPTYPE_BINARY == (PROPTYPE_MASK & PropType)))
	    {
		cbprop -= sizeof(WCHAR);
	    }
	}
    }
    *pcbprop = cbprop;

error:
    return(hr);
}


BOOL
myIsMinusSignString(
    IN WCHAR const *pwsz)
{
    return(
	NULL != pwsz &&
	L'\0' != pwsz[0] &&
	L'\0' == pwsz[1] &&
	myIsMinusSign(pwsz[0]));
}


// IsCharRegKeyChar -- Determines if a character is valid for use in a file
// name AND in a registry key name.
#define wszInvalidFileAndKeyChars  L"<>\"/\\:|?*"
#define wszUnsafeURLChars          L"#\"&<>[]^`{}|"
#define wszUnsafeDSChars           L"()='\"`,;+"

BOOL
myIsCharSanitized(
    IN WCHAR wc)
{
    BOOL fCharOk = TRUE;
    if (L' ' > wc ||
        L'~' < wc ||
        NULL != wcschr(
		    wszInvalidFileAndKeyChars
			wszUnsafeURLChars
			wszSANITIZEESCAPECHAR
			wszURLESCAPECHAR
			wszUnsafeDSChars,
		    wc))
    {
	fCharOk = FALSE;
    }
    return(fCharOk);
}


HRESULT
mySanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszPassedName;
    WCHAR *pwszDst;
    WCHAR *pwszOut = NULL;
    WCHAR wcChar;
    DWORD dwSize;

    *ppwszNameOut = NULL;
    pwszPassedName = pwszName;

    dwSize = 0;

    if (NULL == pwszName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pwszName NULL");
    }

    while (L'\0' != (wcChar = *pwszPassedName++))
    {
	if (myIsCharSanitized(wcChar))
	{
	    dwSize++;
	}
        else
        {
            dwSize += 5; // format !XXXX
        }
    }
    if (0 == dwSize)
    {
        goto error; // done
    }

    pwszOut = (WCHAR *) LocalAlloc(LMEM_ZEROINIT, (dwSize + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszDst = pwszOut;
    while (L'\0' != (wcChar = *pwszName++))
    {
	if (myIsCharSanitized(wcChar))
	{
            *pwszDst++ = wcChar;
	}
        else
        {
	    pwszDst += wsprintf(
			    pwszDst,
			    L"%ws%04x",
			    wszSANITIZEESCAPECHAR,
			    wcChar);
        }
    }
    *pwszDst = wcChar; // L'\0' terminator

    *ppwszNameOut = pwszOut;
    pwszOut = NULL;

    hr = S_OK;
error:
    if (NULL != pwszOut)
    {
        LocalFree(pwszOut);
    }
    return(hr);
}


BOOL
ScanHexEscapeDigits(
    IN WCHAR const *pwszHex,
    OUT WCHAR *pwcRevert)
{
    BOOL ret = FALSE;
    DWORD i;
    WCHAR wc;
    WCHAR wszValue[5];

    for (i = 0; i < 4; i++)
    {
	wc = pwszHex[i];
	wszValue[i] = wc;
	if (!isascii(wc) || !isxdigit((char) wc))
	{
	    goto error;
	}
    }
    wszValue[4] = L'\0';
    if (1 != swscanf(wszValue, L"%04x", &i))
    {
        goto error;
    }
    *pwcRevert = (WCHAR) i;
    ret = TRUE;

error:
    return(ret);
}


// This function will truncate the output if pwszName contains "!0000".
// The output string is L'\0' terminated, so the length is not returned.

HRESULT
myRevertSanitizeName(
    IN WCHAR const *pwszName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR wc;
    WCHAR wcRevert;
    WCHAR *pwszRevert;

    *ppwszNameOut = NULL;

    if (NULL == pwszName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL sanitized name");
    }
    cwc = wcslen(pwszName);
    *ppwszNameOut = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == *ppwszNameOut)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "Out of memory");
    }

    pwszRevert = *ppwszNameOut;
    while (L'\0' != *pwszName)
    {
	wc = *pwszName++;

        if (wcSANITIZEESCAPECHAR == wc &&
            ScanHexEscapeDigits(pwszName, &wcRevert))
        {
	    wc = wcRevert;
	    pwszName += 4;
        }
        *pwszRevert++ = wc;
    }
    *pwszRevert = L'\0';
    CSASSERT(wcslen(*ppwszNameOut) <= cwc);
    hr = S_OK;

error:
    return hr;
}


#define cwcCNMAX 	64		// 64 chars max for DS CN
#define cwcCHOPHASHMAX	(1 + 5)		// "-%05hu" decimal USHORT hash digits
#define cwcCHOPBASE 	(cwcCNMAX - (cwcCHOPHASHMAX + cwcSUFFIXMAX))

HRESULT
mySanitizedNameToDSName(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcCopy;
    WCHAR wszDSName[cwcCHOPBASE + cwcCHOPHASHMAX + 1];

    *ppwszNameOut = NULL;

    if (NULL == pwszSanitizedName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL sanitized name");
    }
    cwc = wcslen(pwszSanitizedName);
    cwcCopy = cwc;
    if (cwcCHOPBASE < cwcCopy)
    {
	cwcCopy = cwcCHOPBASE;
    }
    CopyMemory(wszDSName, pwszSanitizedName, cwcCopy * sizeof(WCHAR));
    wszDSName[cwcCopy] = L'\0';

    if (cwcCHOPBASE < cwc)
    {
        // Hash the rest of the name into a USHORT
        USHORT usHash = 0;
	DWORD i;
	WCHAR *pwsz;

	// Truncate an incomplete sanitized Unicode character
	
	pwsz = wcsrchr(wszDSName, L'!');
	if (NULL != pwsz && wcslen(pwsz) < 5)
	{
	    cwcCopy -= wcslen(pwsz);
	    *pwsz = L'\0';
	}

        for (i = cwcCopy; i < cwc; i++)
        {
            USHORT usLowBit = (USHORT) ((0x8000 & usHash)? 1 : 0);

	    usHash = ((usHash << 1) | usLowBit) + pwszSanitizedName[i];
        }
	wsprintf(&wszDSName[cwcCopy], L"-%05hu", usHash);
	CSASSERT(wcslen(wszDSName) < ARRAYSIZE(wszDSName));
    }

    hr = myDupString(wszDSName, ppwszNameOut);
    _JumpIfError(hr, error, "myDupString");

    DBGPRINT((DBG_SS_CERTLIBI, "mySanitizedNameToDSName(%ws)\n", *ppwszNameOut));

error:
    return(hr);
}


HRESULT
CertNameToHashString(
    IN CERT_NAME_BLOB const *pCertName,
    OUT WCHAR **ppwszHash)
{
    HRESULT hr = S_OK;
    WCHAR wszHash[CBMAX_CRYPT_HASH_LEN * 3];	// 20 bytes @ 3 WCHARs/byte
    DWORD cbString;
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE rgbHashVal[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHashVal;

    if (0 == pCertName->cbData)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "empty cert name");
    }

    CSASSERT(NULL != ppwszHash);

    // get a cryptographic provider

    if (!CryptAcquireContext(
            &hProv,
            NULL,	// container
            MS_DEF_PROV,	// provider name
            PROV_RSA_FULL, // provider type
            CRYPT_VERIFYCONTEXT)) // dwflags
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptAcquireContext");
    }

    // get a hash

    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptCreateHash");
    }

    // hash the name

    if (!CryptHashData(hHash, pCertName->pbData, pCertName->cbData, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptHashData");
    }

    cbHashVal = CBMAX_CRYPT_HASH_LEN;
    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHashVal, &cbHashVal, 0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGetHashParam");
    }

    cbString = sizeof(wszHash);
    hr = MultiByteIntegerToWszBuf(
			TRUE,	// byte multiple
			cbHashVal,
			rgbHashVal,
			&cbString,
			wszHash);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    // Generated string looks like this: 
    //
    //     04 e7 23 92 98 9f d8 45 80 c9 ef 87 81 29 41 5d bc 4f 63 20
    // 
    // We need to trim the spaces. We'll do it inplace.

    {
        WCHAR *pwcSrc;
	WCHAR *pwcDest;

        for (pwcSrc = pwcDest = wszHash; L'\0' != *pwcSrc; pwcSrc++)
        {
            if (L' ' != *pwcSrc)
	    {
                *pwcDest++ = *pwcSrc;
	    }
        }
        *pwcDest = L'\0';
    }

    *ppwszHash = (WCHAR *) LocalAlloc(LMEM_FIXED, cbString);
    _JumpIfAllocFailed(*ppwszHash, error);

    wcscpy(*ppwszHash, wszHash);

error:
    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
myCombineStrings(
    IN WCHAR const *pwszNew,
    IN BOOL fAppendNew,
    OPTIONAL IN WCHAR const *pwszSeparator,
    IN OUT WCHAR **ppwszInOut)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwsz;

    if (NULL == pwszSeparator)
    {
	pwszSeparator = L"";
    }
    cwc = wcslen(pwszNew);
    if (NULL != *ppwszInOut)
    {
	cwc += wcslen(*ppwszInOut) + wcslen(pwszSeparator);
    }
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "Policy:LocalAlloc");
    }
    *pwsz = L'\0';
    if (fAppendNew)
    {
	if (NULL != *ppwszInOut)
	{
	    wcscat(pwsz, *ppwszInOut);
	    wcscat(pwsz, pwszSeparator);
	}
	wcscat(pwsz, pwszNew);
    }
    else
    {
	wcscat(pwsz, pwszNew);
	if (NULL != *ppwszInOut)
	{
	    wcscat(pwsz, pwszSeparator);
	    wcscat(pwsz, *ppwszInOut);
	}
    }
    if (NULL != *ppwszInOut)
    {
	LocalFree(*ppwszInOut);
    }
    *ppwszInOut = pwsz;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myAppendString(
    IN WCHAR const *pwszNew,
    OPTIONAL IN WCHAR const *pwszSeparator,
    IN OUT WCHAR **ppwszInOut)
{
    return(myCombineStrings(pwszNew, TRUE, pwszSeparator, ppwszInOut));
}


HRESULT
myPrependString(
    IN WCHAR const *pwszNew,
    OPTIONAL IN WCHAR const *pwszSeparator,
    IN OUT WCHAR **ppwszInOut)
{
    return(myCombineStrings(pwszNew, FALSE, pwszSeparator, ppwszInOut));
}


HRESULT
myGetRDNAttributeFromNameBlob(
    IN CERT_NAME_BLOB const *pNameBlob,
    IN LPCSTR pcszAttributeOID,    
    OUT WCHAR **ppwszCN)
{
    HRESULT hr;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    CERT_RDN *prdn;
    CERT_RDN *prdnEnd;
    WCHAR const *pwszCN = NULL;

    *ppwszCN = NULL;

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	NULL == pwszCN && prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    CSASSERT(
		prdna->dwValueType == CERT_RDN_PRINTABLE_STRING ||
		prdna->dwValueType == CERT_RDN_UNICODE_STRING ||
		prdna->dwValueType == CERT_RDN_TELETEX_STRING ||
		prdna->dwValueType == CERT_RDN_IA5_STRING ||
		prdna->dwValueType == CERT_RDN_UTF8_STRING);

	    if (0 != strcmp(pcszAttributeOID, prdna->pszObjId) ||
		NULL == prdna->Value.pbData ||
		sizeof(WCHAR) > prdna->Value.cbData ||
		L'\0' == *(WCHAR *) prdna->Value.pbData)
	    {
		continue;
	    }
	    pwszCN = (WCHAR const *) prdna->Value.pbData;
	    //break; don't break, we're interested in the last CN found, not the first
        }
    }
    if (NULL != pwszCN)
    {
	hr = myDupString(pwszCN, ppwszCN);
	_JumpIfError(hr, error, "myDupString");
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HRESULT
myGetCommonName(
    IN CERT_NAME_BLOB const *pNameBlob,
    IN BOOL fAllowDefault,
    OUT WCHAR **ppwszCN)
{
    HRESULT hr;

    hr = myGetRDNAttributeFromNameBlob(pNameBlob, szOID_COMMON_NAME, ppwszCN);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetRDNAttributeFromNameBlob");
	*ppwszCN = NULL;
        if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
	    _JumpError(hr, error, "myGetRDNAttributeFromNameBlob");
	}
    }
    if (NULL == *ppwszCN)
    {
        if (!fAllowDefault)
        {
            hr = CERTSRV_E_BAD_REQUESTSUBJECT;
            _JumpError(hr, error, "No CN");
        }

        hr = CertNameToHashString(pNameBlob, ppwszCN);
        _JumpIfError(hr, error, "CertNameToHashString");
    }
    hr = S_OK;

error:
    return(hr);
}


// Decode OCTET string, and convert UTF8 string to Unicode.
// Can return S_OK and NULL pointer.

HRESULT
myDecodeCMCRegInfo(
    IN BYTE const *pbOctet,
    IN DWORD cbOctet,
    OUT WCHAR **ppwszRA)
{
    HRESULT hr;
    CRYPT_DATA_BLOB *pBlob = NULL;
    DWORD cb;

    *ppwszRA = NULL;
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_OCTET_STRING,
		    pbOctet,
		    cbOctet,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pBlob,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (0 != pBlob->cbData && NULL != pBlob->pbData)
    {
	if (!myConvertUTF8ToWsz(
			ppwszRA,
			(CHAR const *) pBlob->pbData,
			pBlob->cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myConvertUTF8ToWsz");
	}
    }
    hr = S_OK;

error:
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}


DWORD
myGetCertNameProperty(
    IN BOOL fFirstRDN,	// else last matching RDN
    IN CERT_NAME_INFO const *pNameInfo,
    IN char const *pszObjId,
    OUT WCHAR const **ppwszName)
{
    HRESULT hr;
    CERT_RDN_ATTR const *prdnaT;
    CERT_RDN const *prdn;
    CERT_RDN const *prdnEnd;

    prdnaT = NULL;
    for (
	prdn = pNameInfo->rgRDN, prdnEnd = &prdn[pNameInfo->cRDN];
	prdn < prdnEnd;
	prdn++)
    {
	CERT_RDN_ATTR *prdna;
	CERT_RDN_ATTR *prdnaEnd;

	for (
	    prdna = prdn->rgRDNAttr, prdnaEnd = &prdna[prdn->cRDNAttr];
	    prdna < prdnaEnd;
	    prdna++)
	{
	    if (0 == strcmp(prdna->pszObjId, pszObjId))
	    {
		prdnaT = prdna;
		if (fFirstRDN)
		{
		    goto done;
		}
	    }
	}
    }
    if (NULL == prdnaT)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	goto error;
    }

done:
    *ppwszName = (WCHAR const *) prdnaT->Value.pbData;
    hr = S_OK;

error:
    return(hr);

}


VOID
myUuidCreate(
    OUT UUID *pUuid)
{
    HRESULT hr;
    BYTE *pb;

    ZeroMemory(pUuid, sizeof(*pUuid));
    hr = UuidCreate(pUuid);
    if (S_OK != hr)
    {
	BYTE *pbEnd;
	
	CSASSERT((HRESULT) RPC_S_UUID_LOCAL_ONLY == hr);

	// No net card?  Fake up a GUID:

	pb = (BYTE *) pUuid;
	pbEnd = (BYTE *) pb + sizeof(*pUuid);

	GetSystemTimeAsFileTime((FILETIME *) pb);
	pb += sizeof(FILETIME);

	while (pb < pbEnd)
	{
	    *(DWORD *) pb = GetTickCount();
	    pb += sizeof(DWORD);
	}
	CSASSERT(pb == pbEnd);
    }
}


VOID
myGenerateGuidSerialNumber(
    OUT GUID *pguidSerialNumber)
{
    BYTE *pb;

    myUuidCreate(pguidSerialNumber);

    pb = &((BYTE *) pguidSerialNumber)[sizeof(*pguidSerialNumber) - 1];

    // make sure the last byte is never zero
    if (0 == *pb)
    {
	*pb = 'z';
    }

    // Some clients can't handle negative serial numbers:
    *pb &= 0x7f;
}


BOOL
myAreBlobsSame(
    IN BYTE const *pbData1,
    IN DWORD cbData1,
    IN BYTE const *pbData2,
    IN DWORD cbData2)
{
    BOOL ret = FALSE;

    if (cbData1 != cbData2)
    {
        goto error;
    }
    if (NULL != pbData1 && NULL != pbData2)
    {
	if (0 != memcmp(pbData1, pbData2, cbData1))
	{
	    goto error;
	}
    }

    // else at least one is NULL -- they'd better both be NULL, & the count 0.

    else if (pbData1 != pbData2 || 0 != cbData1)
    {
	goto error;
    }
    ret = TRUE;

error:
    return(ret);
}


BOOL
myAreSerialNumberBlobsSame(
    IN CRYPT_INTEGER_BLOB const *pBlob1,
    IN CRYPT_INTEGER_BLOB const *pBlob2)
{
    DWORD cbData1 = pBlob1->cbData;
    DWORD cbData2 = pBlob2->cbData;

    if (NULL != pBlob1->pbData)
    {
	while (0 != cbData1 && 0 == pBlob1->pbData[cbData1 - 1])
	{
	    cbData1--;
	}
    }
    if (NULL != pBlob2->pbData)
    {
	while (0 != cbData2 && 0 == pBlob2->pbData[cbData2 - 1])
	{
	    cbData2--;
	}
    }
    return(myAreBlobsSame(pBlob1->pbData, cbData1, pBlob2->pbData, cbData2));
}


// myAreCertContextBlobsSame -- return TRUE if the certs are identical.

BOOL
myAreCertContextBlobsSame(
    IN CERT_CONTEXT const *pcc1,
    IN CERT_CONTEXT const *pcc2)
{
    return(myAreBlobsSame(
		pcc1->pbCertEncoded,
		pcc1->cbCertEncoded,
		pcc2->pbCertEncoded,
		pcc2->cbCertEncoded));
}


WCHAR const g_wszCert[] = L"cert";

HRESULT
myIsDirWriteable(
    IN WCHAR const *pwszPath,
    IN BOOL fFilePath)
{
    HRESULT hr;
    WCHAR *pwszBase;
    WCHAR *pwsz;
    WCHAR wszDir[MAX_PATH];
    WCHAR wszTempFile[MAX_PATH];

    if (fFilePath &&
	iswalpha(pwszPath[0]) &&
	L':' == pwszPath[1] &&
	L'\0' == pwszPath[2])
    {
	hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	_JumpErrorStr(hr, error, "not a file path", pwszPath);
    }
    if (!GetFullPathName(
		pwszPath,
		ARRAYSIZE(wszDir),
		wszDir,
		&pwsz))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "GetFullPathName", pwszPath);
    }
    if (fFilePath)
    {
	if (NULL == pwsz)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
	    _JumpErrorStr(hr, error, "not a file path", pwszPath);
	}
	pwszBase = wszDir;
	if (iswalpha(wszDir[0]) &&
	    L':' == wszDir[1] &&
	    L'\\' == wszDir[2])
	{
	    pwszBase += 3;
	}
	else if (L'\\' == wszDir[0] && L'\\' == wszDir[1])
	{
	    pwszBase += 2;
	}

	if (pwsz > pwszBase && L'\\' == pwsz[-1])
	{
	    pwsz--;
	}
	*pwsz = L'\0';
    }

    if (!GetTempFileName(wszDir, g_wszCert, 0, wszTempFile))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "GetTempFileName", wszDir);

    }
    if (!DeleteFile(wszTempFile))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "DeleteFile", wszTempFile);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetComputerObjectName(
    IN EXTENDED_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszComputerObjectName)
{
    HRESULT hr;
    WCHAR *pwszComputerObjectName = NULL;
    DWORD cwc;

    *ppwszComputerObjectName = NULL;

    cwc = 0;
    if (!GetComputerObjectName(NameFormat, NULL, &cwc))
    {
	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    _JumpError(hr, error, "GetComputerObjectName");
	}
    }

    pwszComputerObjectName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszComputerObjectName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!GetComputerObjectName(NameFormat, pwszComputerObjectName, &cwc))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetComputerObjectName");
    }

    *ppwszComputerObjectName = pwszComputerObjectName;
    pwszComputerObjectName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszComputerObjectName)
    {
	LocalFree(pwszComputerObjectName);
    }
    return(hr);
}


HRESULT
myGetComputerNames(
    OUT WCHAR **ppwszDnsName,
    OUT WCHAR **ppwszOldName)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszOldName = NULL;

    *ppwszOldName = NULL;
    *ppwszDnsName = NULL;

    cwc = MAX_COMPUTERNAME_LENGTH + 1;
    pwszOldName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszOldName)
    {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }
    if (!GetComputerName(pwszOldName, &cwc))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetComputerName");
    }

    hr = myGetMachineDnsName(ppwszDnsName);
    _JumpIfError(hr, error, "myGetMachineDnsName");

    *ppwszOldName = pwszOldName;
    pwszOldName = NULL;

error:
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}

HRESULT
myGetComputerNameEx(
    IN COMPUTER_NAME_FORMAT NameFormat,
    OUT WCHAR **ppwszName)
{
    HRESULT hr;
    WCHAR *pwszName = NULL;
    DWORD cwc;

    *ppwszName = NULL;

    cwc = 0;
    if (!GetComputerNameEx(NameFormat, NULL, &cwc))
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
        {
            _JumpError(hr, error, "GetComputerNameEx");
        }
    }
    pwszName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!GetComputerNameEx(NameFormat, pwszName, &cwc))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetComputerNameEx");
    }

    *ppwszName = pwszName;
    pwszName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszName)
    {
        LocalFree(pwszName);
    }
    return(hr);
}

typedef LANGID (WINAPI FNSETTHREADUILANGUAGE)(
    IN WORD wReserved);

LANGID
mySetThreadUILanguage(
    IN WORD wReserved)
{
    HMODULE hModule;
    LANGID lang = 0;
    HANDLE hStdOut;
    static FNSETTHREADUILANGUAGE *s_pfn = NULL;

    // Make the SetThreadUILanguage call only if a console exists:
    // FILE_TYPE_CHAR (what about FILE_TYPE_PIPE, FILE_TYPE_DISK)

    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (INVALID_HANDLE_VALUE != hStdOut &&
	FILE_TYPE_CHAR == (~FILE_TYPE_REMOTE & GetFileType(hStdOut)))
    {
	if (NULL == s_pfn)
	{
	    hModule = GetModuleHandle(TEXT("kernel32.dll"));
	    if (NULL == hModule)
	    {
		goto error;
	    }

	    // load system function
	    s_pfn = (FNSETTHREADUILANGUAGE *) GetProcAddress(
						       hModule,
						       "SetThreadUILanguage");
	    if (NULL == s_pfn)
	    {
		goto error;
	    }
	}
	lang = (*s_pfn)(wReserved);
    }

error:
    return(lang);
}


HRESULT
myFormConfigString(
    IN WCHAR const  *pwszServer,
    IN WCHAR const  *pwszCAName,
    OUT WCHAR      **ppwszConfig)
{
    HRESULT  hr;
    WCHAR   *pwszConfig = NULL;

    *ppwszConfig = NULL;

    pwszConfig = (WCHAR *) LocalAlloc(LPTR,
                (wcslen(pwszServer) + wcslen(pwszCAName) + 2) * sizeof(WCHAR));
    if (NULL == pwszConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszConfig, pwszServer);
    wcscat(pwszConfig, L"\\");
    wcscat(pwszConfig, pwszCAName);

    *ppwszConfig = pwszConfig;

    hr = S_OK;
error:
    return hr;
}


HRESULT
myCLSIDToWsz(
    IN CLSID const *pclsid,
    OUT WCHAR **ppwsz)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    WCHAR *pwsz1;
    WCHAR *pwsz2;

    *ppwsz = NULL;
    hr = StringFromCLSID(*pclsid, &pwsz);
    _JumpIfError(hr, error, "StringFromCLSID");

    for (pwsz1 = pwsz; L'\0' != *pwsz1; pwsz1++)
    {
	if (L'A' <= *pwsz1 && L'F' >= *pwsz1)
	{
	    *pwsz1 += L'a' - L'A';
	}
    }

    pwsz1 = pwsz;
    pwsz2 = &pwsz[wcslen(pwsz) - 1];
    if (wcLBRACE == *pwsz1 && wcRBRACE == *pwsz2)
    {
	pwsz1++;
	*pwsz2 = L'\0';
    }
    hr = myDupString(pwsz1, ppwsz);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwsz)
    {
	CoTaskMemFree(pwsz);
    }
    return(hr);
}


HRESULT
myLoadRCString(
    IN HINSTANCE   hInstance,
    IN int         iRCId,
    OUT WCHAR    **ppwsz)
{
#define CS_RCALLOCATEBLOCK 256
    HRESULT   hr;
    WCHAR    *pwszTemp = NULL;
    int       sizeTemp;
    int       size;
    int       cBlocks = 1;

    *ppwsz = NULL;

    size = 0;
    while (NULL == pwszTemp)
    {
        sizeTemp = cBlocks * CS_RCALLOCATEBLOCK;

        pwszTemp = (WCHAR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                        sizeTemp * sizeof(WCHAR));
	if (NULL == pwszTemp)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

        size = LoadString(
                   hInstance,
                   iRCId,
                   pwszTemp,
                   sizeTemp);
        if (0 == size)
        {
            hr = myHLastError();
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"myLoadRCString(hInstance=%x, iRCId=%u) --> %x\n",
		hInstance,
		iRCId,
		hr));
            if (S_OK != hr &&
                HRESULT_FROM_WIN32(ERROR_RESOURCE_NAME_NOT_FOUND) != hr)
            {
                _JumpError(hr, error, "LoadString");
            }
        }

        if (size < sizeTemp - 1)
        {
            // ok, size is big enough
            break;
        }
        ++cBlocks;
        LocalFree(pwszTemp);
        pwszTemp = NULL;
    }

    *ppwsz = (WCHAR*) LocalAlloc(LPTR, (size+1) * sizeof(WCHAR));
    if (NULL == *ppwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (0 == size)
    {
        // two possible cases, 1) real empty string or
        // 2) id not found in resource. either case make it empty string
        **ppwsz = L'\0';
    }
    else
    {
        // copy it
        wcscpy(*ppwsz, pwszTemp);
    }

    hr = S_OK;
error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return hr;
}


HRESULT
_IsConfigLocal(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwsz;
    DWORD cwc;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL != pwsz)
    {
	cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
    }
    else
    {
	cwc = wcslen(pwszConfig);
    }
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszMachine, pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';

    if (0 == mylstrcmpiL(pwszMachine, pwszDnsName) ||
	0 == mylstrcmpiL(pwszMachine, pwszOldName))
    {
	*pfLocal = TRUE;
    }
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = pwszMachine;
	pwszMachine = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    return(hr);
}


HRESULT
myIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszOldName = NULL;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    hr = myGetComputerNames(&pwszDnsName, &pwszOldName);
    _JumpIfError(hr, error, "myGetComputerNames");

    hr = _IsConfigLocal(
		    pwszConfig,
		    pwszDnsName,
		    pwszOldName,
		    ppwszMachine,
		    pfLocal);
    _JumpIfError(hr, error, "_IsConfigLocal");

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}


HRESULT
myIsConfigLocal2(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    
    hr = _IsConfigLocal(
		    pwszConfig,
		    pwszDnsName,
		    pwszOldName,
		    NULL,
		    pfLocal);
    _JumpIfError(hr, error, "_IsConfigLocal");

error:
    return(hr);
}


HRESULT
myGetConfig(
    IN DWORD dwUIFlag,
    OUT WCHAR **ppwszConfig)
{
    HRESULT hr;
    HRESULT hr2;
    BSTR strConfig = NULL;
    WCHAR *pwszConfig = NULL;
    WCHAR *pwszActiveCA = NULL;
    WCHAR *pwszCommonName = NULL;
    WCHAR *pwszDnsName = NULL;

    CSASSERT(NULL != ppwszConfig);
    *ppwszConfig = NULL;

    hr = ConfigGetConfig(DISPSETUP_COM, dwUIFlag, &strConfig);
    if (S_OK != hr)
    {
	if (CC_LOCALCONFIG != dwUIFlag)
	{
	    _JumpError(hr, error, "ConfigGetConfig");
	}
	hr2 = hr;

	hr = myGetCertRegStrValue(
			    NULL,
			    NULL,
			    NULL,
			    wszREGACTIVE,
			    &pwszActiveCA);
	_PrintIfError(hr, "myGetCertRegStrValue");

	if (S_OK == hr)
	{
	    hr = myGetCertRegStrValue(
				pwszActiveCA,
				NULL,
				NULL,
				wszREGCOMMONNAME,
				&pwszCommonName);
	    _PrintIfError(hr, "myGetCertRegStrValue");
	}
	if (S_OK != hr)
	{
	    hr = hr2;
	    _JumpError(hr, error, "ConfigGetConfig");
	}
	hr = myGetMachineDnsName(&pwszDnsName);
	_JumpIfError(hr, error, "myGetMachineDnsName");

	hr = myFormConfigString(pwszDnsName, pwszCommonName, &pwszConfig);
	_JumpIfError(hr, error, "myFormConfigString");

	if (!ConvertWszToBstr(&strConfig, pwszConfig, MAXDWORD))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }
    *ppwszConfig = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				SysStringByteLen(strConfig) + sizeof(WCHAR));
    if (NULL == *ppwszConfig)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszConfig, strConfig);
    CSASSERT(
	wcslen(*ppwszConfig) * sizeof(WCHAR) ==
	SysStringByteLen(strConfig));
    hr = S_OK;

error:
    if (NULL != pwszActiveCA)
    {
	LocalFree(pwszActiveCA);
    }
    if (NULL != pwszCommonName)
    {
	LocalFree(pwszCommonName);
    }
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    if (NULL != pwszConfig)
    {
	LocalFree(pwszConfig);
    }
    if (NULL != strConfig)
    {
        SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
myBuildPathAndExt(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile,
    OPTIONAL IN WCHAR const *pwszExt,
    OUT WCHAR **ppwszPath)
{
    HRESULT hr;
    WCHAR *pwsz;
    DWORD cwc;

    *ppwszPath = NULL;
    cwc = wcslen(pwszDir) + 1 + wcslen(pwszFile) + 1;
    if (NULL != pwszExt)
    {
	cwc += wcslen(pwszExt);
    }

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwsz, pwszDir);
    if (L'\\' != pwsz[wcslen(pwsz) - 1])
    {
	wcscat(pwsz, L"\\");
    }
    wcscat(pwsz, pwszFile);
    if (NULL != pwszExt)
    {
	wcscat(pwsz, pwszExt);
    }
    *ppwszPath = pwsz;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myDeleteFilePattern(
    IN WCHAR const *pwszDir,
    OPTIONAL IN WCHAR const *pwszPattern,	// defaults to L"*.*"
    IN BOOL fRecurse)
{
    HRESULT hr;
    HRESULT hr2;
    HANDLE hf;
    WIN32_FIND_DATA wfd;
    WCHAR *pwszFindPath = NULL;
    WCHAR *pwszDeleteFile;
    WCHAR *pwszDeletePath = NULL;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myDeleteFilePattern(%ws, %ws, %ws)\n",
	pwszDir,
	pwszPattern,
	fRecurse? L"Recurse" : L"NO Recurse"));

    if (NULL == pwszPattern)
    {
	pwszPattern = L"*.*";
    }

    hr = myBuildPathAndExt(pwszDir, pwszPattern, NULL, &pwszFindPath);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    pwszDeletePath = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszDir) +  1 + MAX_PATH) * sizeof(WCHAR));
    if (NULL == pwszDeletePath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszDeletePath, pwszFindPath);
    pwszDeleteFile = wcsrchr(pwszDeletePath, L'\\');
    CSASSERT(NULL != pwszDeleteFile);
    pwszDeleteFile++;

    hf = FindFirstFile(pwszFindPath, &wfd);
    if (INVALID_HANDLE_VALUE == hf)
    {
	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
	    HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
	{
	    hr = S_OK;
	    goto error;
	}
	_JumpErrorStr(hr, error, "FindFirstFile", pwszFindPath);
    }
    do
    {
	wcscpy(pwszDeleteFile, wfd.cFileName);
	if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
	{
	    if (fRecurse &&
		0 != lstrcmp(L".", wfd.cFileName) &&
		0 != lstrcmp(L"..", wfd.cFileName))
	    {
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "myDeleteFilePattern(DIR): %ws\n",
		    pwszDeletePath));
		hr2 = myRemoveFilesAndDirectory(pwszDeletePath, TRUE);
		if (S_OK != hr2)
		{
		    if (S_OK == hr)
		    {
			hr = hr2;		// only return first error
		    }
		    _PrintErrorStr(hr2, "myRemoveFilesAndDirectory", pwszDeletePath);
		}
	    }
	}
	else
	{
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"myDeleteFilePattern: %ws\n",
		pwszDeletePath));
	    if (!DeleteFile(pwszDeletePath))
	    {
		hr2 = myHLastError();
		if (S_OK == hr)
		{
		    hr = hr2;		// only return first error
		}
		_PrintErrorStr(hr2, "DeleteFile", pwszDeletePath);
	    }
	}
    } while (FindNextFile(hf, &wfd));
    FindClose(hf);

error:
    if (NULL != pwszFindPath)
    {
	LocalFree(pwszFindPath);
    }
    if (NULL != pwszDeletePath)
    {
	LocalFree(pwszDeletePath);
    }
    return(hr);
}


HRESULT
myRemoveFilesAndDirectory(
    IN WCHAR const *pwszPath,
    IN BOOL fRecurse)
{
    HRESULT hr;
    HRESULT hr2;

    hr = myDeleteFilePattern(pwszPath, NULL, fRecurse);
    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "myDeleteFilePattern", pwszPath);
    }
    if (!RemoveDirectory(pwszPath))
    {
	hr2 = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr2 &&
	    HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr2)
	{
	    if (S_OK == hr)
	    {
		hr = hr2;		// only return first error
	    }
	    _JumpErrorStr(hr2, error, "RemoveDirectory", pwszPath);
	}
    }

error:
    return(hr);
}


BOOL
myIsFullPath(
    IN WCHAR const *pwszPath,
    OUT DWORD      *pdwFlag)
{
    BOOL fFullPath = FALSE;

    *pdwFlag = 0;
    if (NULL != pwszPath)
    {
	if (L'\\' == pwszPath[0] && L'\\' == pwszPath[1])
	{
	    fFullPath = TRUE;
	    *pdwFlag = UNC_PATH;
	}
	else
	if (iswalpha(pwszPath[0]) &&
	    L':' == pwszPath[1] &&
	    L'\\' == pwszPath[2])
	{
	    fFullPath = TRUE;
	    *pdwFlag = LOCAL_PATH;
	}
    }
    return(fFullPath);
}



// Convert local full path to UNC, as in c:\foo... --> \\server\c$\foo...
// If pwszServer is NULL or empty, preserve the local full path

HRESULT
myConvertLocalPathToUNC(
    OPTIONAL IN WCHAR const *pwszServer,
    IN WCHAR const *pwszFile,
    OUT WCHAR **ppwszFileUNC)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR const *pwsz;
    WCHAR *pwszDst;
    WCHAR *pwszFileUNC = NULL;

    if (!iswalpha(pwszFile[0]) || L':' != pwszFile[1] || L'\\' != pwszFile[2])
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "non-local path");
    }
    if (NULL != pwszServer && L'\0' == *pwszServer)
    {
	pwszServer = NULL;
    }
    cwc = wcslen(pwszFile) + 1;
    if (NULL != pwszServer)
    {
	cwc += 2 + wcslen(pwszServer) + 1;
    }

    pwszFileUNC = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszFileUNC)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc pwszFiles");
    }

    pwsz = pwszFile;
    pwszDst = pwszFileUNC;
    if (NULL != pwszServer)
    {
	wcscpy(pwszDst, L"\\\\");	// --> "\\"
	wcscat(pwszDst, pwszServer);	// --> "\\server"
	pwszDst += wcslen(pwszDst);
	*pwszDst++ = L'\\';		// --> "\\server\"
	*pwszDst++ = *pwsz++;		// --> "\\server\c"
	*pwszDst++ = L'$';		// --> "\\server\c$"
	pwsz++;				// skip colon
    }
    wcscpy(pwszDst, pwsz);		// --> "\\server\c$\foo..."

    *ppwszFileUNC = pwszFileUNC;
    hr = S_OK;

error:
    return(hr);
}


WCHAR const *
LocalStart(
    IN WCHAR const *pwsz,
    OUT BOOL *pfUNC)
{
    WCHAR const *pwc;

    *pfUNC = FALSE;
    pwc = pwsz;
    if (L'\\' != *pwc)
    {
	pwc++;
    }
    if (L'\\' == pwc[0] || L'\\' == pwc[1])
    {
	pwc = wcschr(&pwc[2], L'\\');
	if (NULL != pwc &&
	    iswalpha(pwc[1]) &&
	    L'$' == pwc[2] &&
	    L'\\' == pwc[3])
	{
	    pwsz = &pwc[1];
	    *pfUNC = TRUE;
	}
    }
    return(pwsz);
}


ULONG
myLocalPathwcslen(
    IN WCHAR const *pwsz)
{
    BOOL fUNC;

    return(wcslen(LocalStart(pwsz, &fUNC)));
}


VOID
myLocalPathwcscpy(
    OUT WCHAR *pwszOut,
    IN WCHAR const *pwszIn)
{
    BOOL fUNC;

    wcscpy(pwszOut, LocalStart(pwszIn, &fUNC));
    if (fUNC)
    {
	CSASSERT(L'$' == pwszOut[1]);
	pwszOut[1] = L':';
    }
}


HRESULT
myConvertUNCPathToLocal(
    IN WCHAR const *pwszUNCPath,
    OUT WCHAR **ppwszLocalPath)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszLocalPath;
    
    CSASSERT(NULL != pwszUNCPath);
    CSASSERT(NULL != ppwszLocalPath);
    *ppwszLocalPath = NULL;

    if (L'\\' != pwszUNCPath[0] || L'\\' != pwszUNCPath[1])
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad parm");
    }
    cwc = myLocalPathwcslen(pwszUNCPath) + 1;
    pwszLocalPath = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszLocalPath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    myLocalPathwcscpy(pwszLocalPath, pwszUNCPath);
    *ppwszLocalPath = pwszLocalPath;
    hr = S_OK;

error:
    return(hr);
}

//+-------------------------------------------------------------------------
//  Description: create any number of directories in one call
//--------------------------------------------------------------------------
HRESULT
myCreateNestedDirectories(
    WCHAR const *pwszDirectory)
{
    HRESULT hr;

    WCHAR   rgszDir[MAX_PATH];          // static buffer
    WCHAR   *pszNext = const_cast<WCHAR*>(pwszDirectory);   // point to end of current directory
    
    // skip "X:\"
    if ((pszNext[1] == L':') && 
        (pszNext[2] == L'\\'))
        pszNext += 3;

    while (pszNext)   // incr past
    {
        DWORD ch;

        // find the next occurence of '\'
        pszNext = wcschr(pszNext, L'\\');
        if (pszNext == NULL)
        {
            // last directory: copy everything
            wcscpy(rgszDir, pwszDirectory);
        }
        else
        {
            // else copy up to Next ptr 
            ch = SAFE_SUBTRACT_POINTERS(pszNext, pwszDirectory);
            if (0 != ch)
            {
                CopyMemory(rgszDir, pwszDirectory, ch*sizeof(WCHAR));
        
                // zero-term
                rgszDir[ch] = L'\0';
            
                // incr past '\\'
                pszNext++;  
            }
            else
            {
                //if ch = 0, means the first char is \, skip CreateDirectory
                pszNext++; //must shift to next char to get out of loop
                continue;
            }
        }
        
        // UNDONE: PeteSk - add in directory security
        if (!CreateDirectory(rgszDir, NULL))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) != hr)
            {
                // something must be wrong with the path
                _JumpError(hr, error, "CreateDirectory");
            }
        }
    }

    hr = S_OK;
    
error:
    return hr;
}


HRESULT
myUncanonicalizeURLParm(
    IN WCHAR const *pwszParmIn,
    OUT WCHAR **ppwszParmOut)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszCanon = NULL;
    WCHAR *pwszUncanon = NULL;
    static const WCHAR s_wszLdap[] = L"ldap:///";

    *ppwszParmOut = NULL;

    cwc = WSZARRAYSIZE(s_wszLdap) + wcslen(pwszParmIn);
    pwszCanon = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszCanon)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszCanon, s_wszLdap);
    wcscat(&pwszCanon[WSZARRAYSIZE(s_wszLdap)], pwszParmIn);

    hr = myInternetUncanonicalizeURL(pwszCanon, &pwszUncanon);
    _JumpIfError(hr, error, "myInternetUncanonicalizeURL");

    hr = myDupString(&pwszUncanon[WSZARRAYSIZE(s_wszLdap)], ppwszParmOut);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwszCanon)
    {
	LocalFree(pwszCanon);
    }
    if (NULL != pwszUncanon)
    {
	LocalFree(pwszUncanon);
    }
    return(hr);
}


// myFormatCertsrvStringArray FormatMessage arguments:
//
// %1 -- Machine full DNS name: pwszServerName_p1_2;
//
// %2 -- Machine short name: first DNS component of pwszServerName_p1_2
//
// %3 -- Sanitized CA name: pwszSanitizedName_p3_7 
//
// %4 -- Cert Filename Suffix:
//       if 0 == iCert_p4 && MAXDWORD == iCertTarget_p4: L""
//       else if MAXDWORD != iCertTarget_p4 L"(%u-%u)"
//       else L"(%u)"
//
// %5 -- DS DN path to Domain root: pwszDomainDN_p5
//
// %6 -- DS DN path to Configuration container: pwszConfigDN_p6
//
// %7 -- Sanitized CA name, truncated and hash suffix added if too long:
//	 pwszSanitizedName_p3_7
//
// %8 -- CRL Filename/Key Name Suffix: L"" if 0 == iCRL_p8; else L"(%u)"
//
// %9 -- CRL Filename Suffix: L"" if !fDeltaCRL_p9; else L"+"
//
// %10 -- DS CRL attribute: L"" if !fDSAttrib_p10_11; depends on fDeltaCRL_p9
//
// %11 -- DS CA Cert attribute: L"" if !fDSAttrib_p10_11
//
// %12 -- DS user cert attribute
//
// %13 -- DS KRA cert attribute
//
// %14 -- DS cross cert pair attribute

HRESULT 
myFormatCertsrvStringArray(
    IN BOOL    fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7, 
    IN DWORD   iCert_p4,
    IN DWORD   iCertTarget_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6, 
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut)
{
    HRESULT hr = S_OK;
    LPCWSTR apwszInsertionArray[100];  // 100 'cause this is the max number of insertion numbers allowed by FormatMessage
    LPWSTR    pwszCurrent = NULL;
    BSTR      strShortMachineName = NULL;
    DWORD     i;
    WCHAR *pwszSanitizedDSName = NULL;
    WCHAR wszCertSuffix[2 * cwcFILENAMESUFFIXMAX];
    WCHAR wszCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR wszDeltaCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR const *pwszT;


    ZeroMemory(apwszStringsOut, cStrings * sizeof(apwszStringsOut[0]));
    ZeroMemory(apwszInsertionArray, sizeof(apwszInsertionArray));

    // Format the template into a real name
    // Initialize the insertion string array.

    //+================================================
    // Machine DNS name (%1)    

    CSASSERT(L'1' == wszFCSAPARM_SERVERDNSNAME[1]);
    apwszInsertionArray[1 - 1] = pwszServerName_p1_2;

    //+================================================
    // Short Machine Name (%2)

    CSASSERT(L'2' == wszFCSAPARM_SERVERSHORTNAME[1]);
    strShortMachineName = SysAllocString(pwszServerName_p1_2);
    if (strShortMachineName == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }

    pwszCurrent = wcschr(strShortMachineName, L'.');
    if (NULL != pwszCurrent)
    {
        *pwszCurrent = 0;
    }
    apwszInsertionArray[2 - 1] = strShortMachineName;

    //+================================================
    // sanitized name (%3)

    CSASSERT(L'3' == wszFCSAPARM_SANITIZEDCANAME[1]);
    apwszInsertionArray[3 - 1] = pwszSanitizedName_p3_7;  

    //+================================================
    // Cert filename suffix (%4) | (%4-%4)

    CSASSERT(L'4' == wszFCSAPARM_CERTFILENAMESUFFIX[1]);
    wszCertSuffix[0] = L'\0';
    if (0 != iCert_p4 || MAXDWORD != iCertTarget_p4)
    {
        wsprintf(
	    wszCertSuffix,
	    MAXDWORD != iCertTarget_p4? L"(%u-%u)" : L"(%u)",
	    iCert_p4,
	    iCertTarget_p4);
    }
    apwszInsertionArray[4 - 1] = wszCertSuffix;  

    //+================================================
    // Domain DN (%5)

    if (NULL == pwszDomainDN_p5 || L'\0' == *pwszDomainDN_p5)
    {
	pwszDomainDN_p5 = L"DC=UnavailableDomainDN";
    }
    CSASSERT(L'5' == wszFCSAPARM_DOMAINDN[1]);
    apwszInsertionArray[5 - 1] = pwszDomainDN_p5;

    //+================================================
    // Config DN (%6)

    if (NULL == pwszConfigDN_p6 || L'\0' == *pwszConfigDN_p6)
    {
	pwszConfigDN_p6 = L"DC=UnavailableConfigDN";
    }
    CSASSERT(L'6' == wszFCSAPARM_CONFIGDN[1]);
    apwszInsertionArray[6 - 1] = pwszConfigDN_p6;

    // Don't pass pwszSanitizedName_p3_7 to SysAllocStringLen with the extended
    // length to avoid faulting past end of pwszSanitizedName_p3_7.

    //+================================================
    // Sanitized Short Name (%7)

    CSASSERT(L'7' == wszFCSAPARM_SANITIZEDCANAMEHASH[1]);
    hr = mySanitizedNameToDSName(pwszSanitizedName_p3_7, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    apwszInsertionArray[7 - 1] = pwszSanitizedDSName;

    //+================================================
    // CRL filename suffix (%8)

    CSASSERT(L'8' == wszFCSAPARM_CRLFILENAMESUFFIX[1]);
    wszCRLSuffix[0] = L'\0';
    if (0 != iCRL_p8)
    {
        wsprintf(wszCRLSuffix, L"(%u)", iCRL_p8);
    }
    apwszInsertionArray[8 - 1] = wszCRLSuffix;  

    //+================================================
    // Delta CRL filename suffix (%9)

    CSASSERT(L'9' == wszFCSAPARM_CRLDELTAFILENAMESUFFIX[1]);
    wszDeltaCRLSuffix[0] = L'\0';
    if (fDeltaCRL_p9)
    {
        wcscpy(wszDeltaCRLSuffix, L"+");
    }
    apwszInsertionArray[9 - 1] = wszDeltaCRLSuffix;  

    //+================================================
    // CRL attribute (%10)

    CSASSERT(L'1' == wszFCSAPARM_DSCRLATTRIBUTE[1]);
    CSASSERT(L'0' == wszFCSAPARM_DSCRLATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = fDeltaCRL_p9?
		    wszDSSEARCHDELTACRLATTRIBUTE :
		    wszDSSEARCHBASECRLATTRIBUTE;
    }
    apwszInsertionArray[10 - 1] = pwszT;  

    //+================================================
    // CA cert attribute (%11)

    CSASSERT(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[1]);
    CSASSERT(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCACERTATTRIBUTE;
    }
    apwszInsertionArray[11 - 1] = pwszT;  

    //+================================================
    // User cert attribute (%12)

    CSASSERT(L'1' == wszFCSAPARM_DSUSERCERTATTRIBUTE[1]);
    CSASSERT(L'2' == wszFCSAPARM_DSUSERCERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHUSERCERTATTRIBUTE;
    }
    apwszInsertionArray[12 - 1] = pwszT;  

    //+================================================
    // KRA cert attribute (%13)

    CSASSERT(L'1' == wszFCSAPARM_DSKRACERTATTRIBUTE[1]);
    CSASSERT(L'3' == wszFCSAPARM_DSKRACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHKRACERTATTRIBUTE;
    }
    apwszInsertionArray[13 - 1] = pwszT;  

    //+================================================
    // Cross cert pair attribute (%14)

    CSASSERT(L'1' == wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE[1]);
    CSASSERT(L'4' == wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCROSSCERTPAIRATTRIBUTE;
    }
    apwszInsertionArray[14 - 1] = pwszT;  

    //+================================================
    // Now format the strings...

    for (i = 0; i < cStrings; i++)
    {
        if (0 == FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			    FORMAT_MESSAGE_FROM_STRING |
			    FORMAT_MESSAGE_ARGUMENT_ARRAY,
			(VOID *) apwszStringsIn[i],
			0,              // dwMessageID
			0,              // dwLanguageID
			(LPWSTR) &apwszStringsOut[i], 
			wcslen(apwszStringsIn[i]),
			(va_list *) apwszInsertionArray))
        {
            hr = myHLastError();
	    _JumpError(hr, error, "FormatMessage");
        }
	if (fURL)
	{
	    WCHAR *pwsz;
	    
	    hr = myInternetCanonicalizeUrl(apwszStringsOut[i], &pwsz);
	    _JumpIfError(hr, error, "myInternetCanonicalizeUrl");

	    LocalFree(apwszStringsOut[i]);
	    apwszStringsOut[i] = pwsz;
	}
    }

error:
    if (S_OK != hr)
    {
	for (i = 0; i < cStrings; i++)
	{
	    if (NULL != apwszStringsOut[i])
	    {
		LocalFree(apwszStringsOut[i]);
		apwszStringsOut[i] = NULL;
	    }
	}
    }
    if (NULL != strShortMachineName)
    {
        SysFreeString(strShortMachineName);
    }
    if (NULL != pwszSanitizedDSName)
    {
        LocalFree(pwszSanitizedDSName);
    }
    return (hr);
}


HRESULT
myAllocIndexedName(
    IN WCHAR const *pwszName,
    IN DWORD Index,
    IN DWORD IndexTarget,
    OUT WCHAR **ppwszIndexedName)
{
    HRESULT hr;
    WCHAR wszIndex[1 + 2 * cwcDWORDSPRINTF + 3];	// L"(%u-%u)"
    WCHAR *pwszIndexedName;

    *ppwszIndexedName = NULL;
    wszIndex[0] = L'\0';
    if (0 != Index || MAXDWORD != IndexTarget)
    {
	wsprintf(
	    wszIndex,
	    MAXDWORD != IndexTarget? L"(%u-%u)" : L"(%u)",
	    Index,
	    IndexTarget);
    }
    pwszIndexedName = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (wcslen(pwszName) + wcslen(wszIndex) + 1) * sizeof(WCHAR));
    if (NULL == pwszIndexedName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszIndexedName, pwszName);
    wcscat(pwszIndexedName, wszIndex);
    *ppwszIndexedName = pwszIndexedName;
    hr = S_OK;

error:
    return(hr);
}


int 
myWtoI(
    IN WCHAR const *string,
    OUT BOOL *pfValid)
{
    HRESULT hr;
    WCHAR wszBuf[16];
    WCHAR *pwszT = wszBuf;
    int cTmp = ARRAYSIZE(wszBuf);
    int i = 0;
    WCHAR const *pwsz;
    BOOL fSawDigit = FALSE;
 
    CSASSERT(NULL != pfValid);
    *pfValid = FALSE;

    cTmp = FoldString(MAP_FOLDDIGITS, string, -1, pwszT, cTmp);
    if (cTmp == 0)
    {
        hr = myHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            hr = S_OK;
            cTmp = FoldString(MAP_FOLDDIGITS, string, -1, NULL, 0);

            pwszT = (WCHAR *) LocalAlloc(LMEM_FIXED, cTmp * sizeof(WCHAR));
	    if (NULL == pwszT)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

            cTmp = FoldString(MAP_FOLDDIGITS, string, -1, pwszT, cTmp);
            if (cTmp == 0)
	    {
                hr = myHLastError();
	    }
        }
        _JumpIfError(hr, error, "FoldString");
    }    
    pwsz = pwszT;
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    if (L'0' == *pwsz && (L'x' == pwsz[1] || L'X' == pwsz[1]))
    {
	pwsz += 2;
	while (iswxdigit(*pwsz))
	{
	    i <<= 4;
	    if (iswdigit(*pwsz))
	    {
		i |= *pwsz - L'0';
	    }
	    else if (L'A' <= *pwsz && L'F' >= *pwsz)
	    {
		i |= *pwsz - L'A' + 10;
	    }
	    else
	    {
		i |= *pwsz - L'a' + 10;
	    }
	    fSawDigit = TRUE;
	    pwsz++;
	}
    }
    else
    {
	while (iswdigit(*pwsz))
	{
	    fSawDigit = TRUE;
	    pwsz++;
	}
	i = _wtoi(pwszT);
    }
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    if (L'\0' == *pwsz)
    {
	*pfValid = fSawDigit;
    }

error:
    if (NULL != pwszT && pwszT != wszBuf)
    {
       LocalFree(pwszT);
    }
    return(i);
}


HRESULT
myGetEnvString(
    OUT WCHAR **ppwszOut,
    IN  WCHAR const *pwszVariable)
{
    HRESULT hr;
    WCHAR awcBuf[MAX_PATH];
    DWORD len;

    len = GetEnvironmentVariable(pwszVariable, awcBuf, ARRAYSIZE(awcBuf));
    if (0 == len)
    {
        hr = myHLastError();
        _JumpErrorStr2(
		hr,
		error,
		"GetEnvironmentVariable",
		pwszVariable,
		HRESULT_FROM_WIN32(ERROR_ENVVAR_NOT_FOUND));
    }
    if (ARRAYSIZE(awcBuf) <= len)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        _JumpError(hr, error, "GetEnvironmentVariable");
    }
    *ppwszOut = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(awcBuf) + 1) * sizeof(WCHAR));
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszOut, awcBuf);
    hr = S_OK;

error:
    return(hr);
}


BOOL
IsValidAttributeChar(
    IN WCHAR wc)
{
    BOOL fOk = TRUE;

    if (myIsMinusSign(wc) || iswspace(wc))
    {
	fOk = FALSE;
    }
    return(fOk);
}


// myParseNextAttribute -- destructively parse a name, value attribute pair.
// Allow CR and/or LF delimiters -- MAC web pages seem to convert LFs into CRs.

HRESULT
myParseNextAttribute(
    IN OUT WCHAR **ppwszBuf,
    IN BOOL fURL,		// Use = and & instead of : and \r\n
    OUT WCHAR const **ppwszName,
    OUT WCHAR const **ppwszValue)
{
    HRESULT hr;
    WCHAR *pwszBuf = *ppwszBuf;
    WCHAR wcSep = fURL? L'=' : L':';
    WCHAR *wszTerm = fURL? L"&" : L"\r\n";

    for (;;)
    {
	WCHAR *pwcToken;
	WCHAR *pwcDst;
	WCHAR *pwc;
	WCHAR const *pwszTerm;
	WCHAR wszQuote[2];

	// Find the beginning of the next token

	while (iswspace(*pwszBuf))
	{
	    pwszBuf++;
	}
	pwcToken = pwszBuf;
	pwszBuf = wcschr(pwszBuf, wcSep);
	if (NULL == pwszBuf)
	{
	    hr = S_FALSE;
	    goto error;
	}

	// If there's a wszTerm char before the next wcSep char, start over.

	pwc = &pwcToken[wcscspn(pwcToken, wszTerm)];
	if (pwc < pwszBuf)
	{
	    pwszBuf = pwc + 1;
	    continue;
	}
	for (pwc = pwcDst = pwcToken; pwc < pwszBuf; pwc++)
	{
	    if (IsValidAttributeChar(*pwc))
	    {
		*pwcDst++ = *pwc;
	    }
	}
	pwszBuf++;		// skip past the wcSep before it gets stomped
	*pwcDst = L'\0';	// may stomp the wcSep separator
	*ppwszName = pwcToken;

	// Find beginning of Value string

	while (NULL == wcschr(wszTerm, *pwszBuf) && iswspace(*pwszBuf))
	{
	    pwszBuf++;
	}
	wszQuote[0] = L'\0';
	pwszTerm = wszTerm;
	if (fURL && (L'"' == *pwszBuf || L'\'' == *pwszBuf))
	{
	    wszQuote[0] = *pwszBuf;
	    wszQuote[1] = L'\0';
	    pwszTerm = wszQuote;
	    pwszBuf++;
	}
	pwcToken = pwszBuf;

	// find end of Value string

	pwc = &pwcToken[wcscspn(pwcToken, pwszTerm)];
	pwszBuf = pwc;
	if (L'\0' != *pwszBuf)
	{
	    // for case when last Value *is* terminated by a wszTerm char:

	    *pwszBuf++ = L'\0';
	}

	// trim trailing whitespace from Value string

	while (--pwc >= pwcToken && iswspace(*pwc))
	{
	    *pwc = L'\0';
	}
	if (L'\0' != wszQuote[0] && pwc >= pwcToken && wszQuote[0] == *pwc)
	{
	    *pwc = L'\0';
	}
	if (L'\0' == **ppwszName || L'\0' == *pwcToken)
	{
	    continue;
	}
	*ppwszValue = pwcToken;
	break;
    }
    hr = S_OK;

error:
    *ppwszBuf = pwszBuf;
    return(hr);
}


// Destructively parse an old-style 4 byte IP Address.

HRESULT
infParseIPV4Address(
    IN WCHAR *pwszValue,
    OUT BYTE *pb,
    IN OUT DWORD *pcb)
{
    HRESULT hr;
    DWORD cb;

    DBGPRINT((DBG_SS_CERTLIBI, "infParseIPV4Address(%ws)\n", pwszValue));
    if (CB_IPV4ADDRESS > *pcb)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "buffer too small");
    }
    for (cb = 0; cb < CB_IPV4ADDRESS; cb++)
    {
	WCHAR *pwszNext;
	BOOL fValid;
	DWORD dw;
	
	pwszNext = &pwszValue[wcscspn(pwszValue, L".")];
	if (L'.' == *pwszNext)
	{
	    *pwszNext++ = L'\0';
	}
	dw = myWtoI(pwszValue, &fValid);
	if (!fValid || 255 < dw)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "bad IP Address digit string", pwszValue);
	}
	pb[cb] = (BYTE) dw;
	pwszValue = pwszNext;
    }
    if (L'\0' != *pwszValue)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "extra data");
    }
    *pcb = cb;
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infParseIPV4Address: %u.%u.%u.%u\n",
	pb[0],
	pb[1],
	pb[2],
	pb[3]));
    hr = S_OK;

error:
    return(hr);
}


// Destructively parse a new-style 16 byte IP Address.

#define MAKE16(b0, b1)	(((b0) << 8) | (b1))

HRESULT
infParseIPV6AddressSub(
    IN WCHAR *pwszValue,
    OUT BYTE *pb,
    IN OUT DWORD *pcb)
{
    HRESULT hr;
    DWORD cbMax = *pcb;
    DWORD cb;

    DBGPRINT((DBG_SS_CERTLIBI, "infParseIPV6AddressSub(%ws)\n", pwszValue));
    ZeroMemory(pb, cbMax);

    for (cb = 0; cb < cbMax; cb += 2)
    {
	WCHAR *pwszNext;
	BOOL fValid;
	DWORD dw;
	WCHAR awc[7];
	
	pwszNext = &pwszValue[wcscspn(pwszValue, L":")];
	if (L':' == *pwszNext)
	{
	    *pwszNext++ = L'\0';
	}
	if (L'\0' == *pwszValue)
	{
	    break;
	}
	if (4 < wcslen(pwszValue))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "too many IP Address digits", pwszValue);
	}
	wcscpy(awc, L"0x");
	wcscat(awc, pwszValue);
	CSASSERT(wcslen(awc) < ARRAYSIZE(awc));

	dw = myWtoI(awc, &fValid);
	if (!fValid || 64 * 1024 <= dw)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "bad IP Address digit string", pwszValue);
	}
	pb[cb] = (BYTE) (dw >> 8);
	pb[cb + 1] = (BYTE) dw;
	pwszValue = pwszNext;
    }
    if (L'\0' != *pwszValue)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "extra data", pwszValue);
    }
    *pcb = cb;
    hr = S_OK;

error:
    return(hr);
}


// Destructively parse a new-style 16 byte IP Address.

HRESULT
infParseIPV6Address(
    IN WCHAR *pwszValue,
    OUT BYTE *pb,
    IN OUT DWORD *pcb)
{
    HRESULT hr;
    DWORD cbMax;
    WCHAR *pwsz;
    WCHAR *pwszLeft;
    WCHAR *pwszRight;
    BYTE abRight[CB_IPV6ADDRESS];
    DWORD cbLeft;
    DWORD cbRight;
    DWORD i;
    BOOL fV4Compat;

    DBGPRINT((DBG_SS_CERTLIBI, "infParseIPV6Address(%ws)\n", pwszValue));
    if (CB_IPV6ADDRESS > *pcb)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "buffer too small");
    }
    ZeroMemory(pb, CB_IPV6ADDRESS);
    cbMax = CB_IPV6ADDRESS;

    // If there's a period after the last colon, an IP V4 Address is attached.
    // Parse it as an IP V4 Address, and reduce the expected size of the IP V6
    // Address to be parsed from eight to six 16-bit address chunks.

    pwsz = wcsrchr(pwszValue, L':');
    if (NULL != pwsz)
    {
	if (NULL != wcschr(pwsz, L'.'))
	{
	    DWORD cb = CB_IPV4ADDRESS;

	    hr = infParseIPV4Address(
			    &pwsz[1],
			    &pb[CB_IPV6ADDRESS - CB_IPV4ADDRESS],
			    &cb);
	    _JumpIfError(hr, error, "infParseIPV4Address");

	    CSASSERT(CB_IPV4ADDRESS == cb);

	    pwsz[1] = L'\0';	// get rid of the trailing IP V4 Address

	    // drop the trailing colon -- if it's not part of a double colon.

	    if (pwsz > pwszValue && L':' != *--pwsz)
	    {
		pwsz[1] = L'\0';
	    }
	    cbMax -= CB_IPV4ADDRESS;
	}
    }
    cbLeft = 0;
    cbRight = 0;
    pwszLeft = pwszValue;
    pwszRight = wcsstr(pwszValue, L"::");
    if (NULL != pwszRight)
    {
	*pwszRight = L'\0';
	pwszRight += 2;
	if (L'\0' != *pwszRight)
	{
	    cbRight = cbMax;
	    hr = infParseIPV6AddressSub(pwszRight, abRight, &cbRight);
	    _JumpIfError(hr, error, "infParseIPV6AddressSub");
	}
    }

    if (L'\0' != *pwszLeft)
    {
	cbLeft = cbMax;
	hr = infParseIPV6AddressSub(pwszLeft, pb, &cbLeft);
	_JumpIfError(hr, error, "infParseIPV6AddressSub");
    }
    if (NULL == pwszRight && cbLeft != cbMax)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "too few IP Address chunks");
    }
    if (cbLeft + cbRight + (NULL != pwszRight? 1 : 0) > cbMax)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "too many IP Address chunks");
    }
    if (0 != cbRight)
    {
	CopyMemory(&pb[cbMax - cbRight], abRight, cbRight);
    }
    *pcb = CB_IPV6ADDRESS;

    fV4Compat = TRUE;
    for (i = 0; i < CB_IPV6ADDRESS - CB_IPV4ADDRESS - 2; i++)
    {
	if (0 != pb[i])
	{
	    fV4Compat = FALSE;
	    break;
	}
    }
    if (fV4Compat)
    {
	CSASSERT(i == CB_IPV6ADDRESS - CB_IPV4ADDRESS - 2);
	fV4Compat = (0 == pb[i] && 0 == pb[i + 1]) ||
		    (0xff == pb[i] && 0xff == pb[i + 1]);
    }
    if (fV4Compat)
    {
	CSASSERT(i == CB_IPV6ADDRESS - CB_IPV4ADDRESS - 2);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infParseIPV6Address: ::%hs%u.%u.%u.%u\n",
	    0 == pb[i]? "" : "ffff:",
	    pb[12],
	    pb[13],
	    pb[14],
	    pb[15]));
    }
    else
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infParseIPV6Address: %x:%x:%x:%x:%x:%x:%x:%x\n",
	    MAKE16(pb[0], pb[1]),
	    MAKE16(pb[2], pb[3]),
	    MAKE16(pb[4], pb[5]),
	    MAKE16(pb[6], pb[7]),
	    MAKE16(pb[8], pb[9]),
	    MAKE16(pb[10], pb[11]),
	    MAKE16(pb[12], pb[13]),
	    MAKE16(pb[14], pb[15])));
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myParseIPAddress(
    IN WCHAR const *pwszValue,
    OUT BYTE *pbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    DWORD cb = *pcbData;
    WCHAR *pwszDup = NULL;

    // if pwszValue is an empty string, return zero length.

    *pcbData = 0;
    if (L'\0' != *pwszValue)
    {
	hr = myDupString(pwszValue, &pwszDup);
	_JumpIfError(hr, error, "myDupString");

	if (NULL == wcschr(pwszDup, L':'))
	{
	    hr = infParseIPV4Address(pwszDup, pbData, &cb);
	    _JumpIfError(hr, error, "infParseIPV4Address");
	}
	else
	{
	    hr = infParseIPV6Address(pwszDup, pbData, &cb);
	    _JumpIfError(hr, error, "infParseIPV6Address");
	}
	*pcbData = cb;
	DBGDUMPHEX((
		DBG_SS_CERTLIBI,
		DH_NOADDRESS | DH_NOTABPREFIX | 8,
		pbData,
		*pcbData));
    }
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
myBuildOSVersionAttribute(
    OUT BYTE **ppbVersion,
    OUT DWORD *pcbVersion)
{
    HRESULT hr;
    DWORD i;
    OSVERSIONINFO osvInfo;
    CERT_NAME_VALUE cnvOSVer;
#define cwcVERSIONMAX	128
    WCHAR wszVersion[12 * 4 + cwcVERSIONMAX];

    *ppbVersion = NULL;
    ZeroMemory(&osvInfo, sizeof(osvInfo));

    // get the OSVersion

    osvInfo.dwOSVersionInfoSize = sizeof(osvInfo);
    if (!GetVersionEx(&osvInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "GetVersionEx");
    }
        
    for (i = 0; ; i++)
    {
	swprintf(
	    wszVersion,
	    0 == i? L"%d.%d.%d.%d.%.*ws" : L"%d.%d.%d.%d", 
	    osvInfo.dwMajorVersion,
	    osvInfo.dwMinorVersion,
	    osvInfo.dwBuildNumber,
	    osvInfo.dwPlatformId,
	    cwcVERSIONMAX,
	    osvInfo.szCSDVersion);
	CSASSERT(ARRAYSIZE(wszVersion) > wcslen(wszVersion));

	cnvOSVer.dwValueType = CERT_RDN_IA5_STRING;
	cnvOSVer.Value.pbData = (BYTE *) wszVersion;
	cnvOSVer.Value.cbData = 0;

	if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_ANY_STRING,
		    &cnvOSVer,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbVersion,
		    pcbVersion))
	{
	    hr = myHLastError();
	    _PrintError(hr, "myEncodeObject");
	    if (0 == i)
	    {
		continue;
	    }
	    goto error;
	}
	break;
    }
    hr = S_OK;

error:
    return(hr);
}


WCHAR const *
myFixTemplateCase(
    IN WCHAR const *pwszCertType)
{
    DWORD i;
    static WCHAR const *apwszCertType[] = {
	wszCERTTYPE_CA,
	wszCERTTYPE_SUBORDINATE_CA,
	wszCERTTYPE_CROSS_CA,
    };

    for (i = 0; i < ARRAYSIZE(apwszCertType); i++)
    {
	if (0 == mylstrcmpiS(pwszCertType, apwszCertType[i]))
	{
	    pwszCertType = apwszCertType[i];
	    break;
	}
    }
    return(pwszCertType);
}


HRESULT
myBuildCertTypeExtension(
    IN WCHAR const *pwszCertType,
    OUT CERT_EXTENSION *pExt)
{
    HRESULT hr;
    CERT_TEMPLATE_EXT Template;
    CERT_NAME_VALUE NameValue;
    LPCSTR pszStructType;
    char *pszObjId = NULL;
    VOID *pv;
    char *pszObjIdExt;

    if (!ConvertWszToSz(&pszObjId, pwszCertType, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    hr = myVerifyObjIdA(pszObjId);
    if (S_OK == hr)
    {
	ZeroMemory(&Template, sizeof(Template));

	Template.pszObjId = pszObjId;
	//Template.dwMajorVersion = 0;
	//Template.fMinorVersion = FALSE;      // TRUE for a minor version
	//Template.dwMinorVersion = 0;

	pszStructType = X509_CERTIFICATE_TEMPLATE;
	pv = &Template;
	pszObjIdExt = szOID_CERTIFICATE_TEMPLATE;
    }
    else
    {
	NameValue.dwValueType = CERT_RDN_UNICODE_STRING;
	NameValue.Value.pbData = (BYTE *) myFixTemplateCase(pwszCertType);
	NameValue.Value.cbData = 0;

	pszStructType = X509_UNICODE_ANY_STRING;
	pv = &NameValue;
	pszObjIdExt = szOID_ENROLL_CERTTYPE_EXTENSION;
    }
    if (!myEncodeObject(
		X509_ASN_ENCODING,
		pszStructType,
		pv,
		0,
		CERTLIB_USE_LOCALALLOC,
		&pExt->Value.pbData,
		&pExt->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    pExt->pszObjId = pszObjIdExt;
    pExt->fCritical = FALSE;
    hr = S_OK;

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(hr);
}


VOID
myPackExtensionArray(
    IN BOOL fFreeData,
    IN OUT DWORD *pcExt,
    IN OUT CERT_EXTENSION **prgExt)
{
    CERT_EXTENSION *rgExt = *prgExt;
    DWORD cExt = *pcExt;
    DWORD i;
    DWORD j;
    CERT_EXTENSION *pExti;
    CERT_EXTENSION *pExtj;

    for (i = 0; i < cExt; i++)
    {
	pExti = &rgExt[i];

	if (NULL != pExti->pszObjId)
	{
	    for (j = i + 1; j < cExt; j++)
	    {
		pExtj = &rgExt[j];

		if (NULL != pExtj->pszObjId &&
		    0 == strcmp(pExti->pszObjId, pExtj->pszObjId))
		{
		    if (fFreeData)
		    {
			LocalFree(pExtj->pszObjId);
			if (NULL != pExtj->Value.pbData)
			{
			    LocalFree(pExtj->Value.pbData);
			}
		    }
		    pExtj->pszObjId = NULL;
		    pExtj->Value.pbData = NULL;
		}
	    }
	    if (NULL == pExti->Value.pbData)
	    {
		if (fFreeData)
		{
		    LocalFree(pExti->pszObjId);
		}
		pExti->pszObjId = NULL;
	    }
	}
    }
    for (i = j = 0; i < cExt; i++)
    {
	pExti = &rgExt[i];
	pExtj = &rgExt[j];

	CSASSERT((NULL != pExti->pszObjId) ^ (NULL == pExti->Value.pbData));
	if (NULL != pExti->pszObjId && NULL != pExti->Value.pbData)
	{
	    *pExtj = *pExti;
	    j++;
	}
    }
    if (j < cExt)
    {
	ZeroMemory(&rgExt[j], (cExt - j) * sizeof(rgExt[0]));
	*pcExt = j;
    }
}


HRESULT
myMergeExtensions(
    IN DWORD cExtOrg,
    IN CERT_EXTENSION *rgExtOrg,
    IN DWORD cExtInf,
    IN CERT_EXTENSION *rgExtInf,
    OUT DWORD *pcExtMerged,
    OUT CERT_EXTENSION **prgExtMerged)
{
    HRESULT hr;
    CERT_EXTENSION *rgExtMerged;

    *prgExtMerged = NULL;

    rgExtMerged = (CERT_EXTENSION *) LocalAlloc(
			    LMEM_FIXED,
			    (cExtInf + cExtOrg) * sizeof(rgExtMerged[0]));
    if (NULL == rgExtMerged)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (0 != cExtInf)
    {
	CopyMemory(
		&rgExtMerged[0],
		&rgExtInf[0],
		cExtInf * sizeof(rgExtMerged[0]));
    }
    if (0 != cExtOrg)
    {
	CopyMemory(
		&rgExtMerged[cExtInf],
		&rgExtOrg[0],
		cExtOrg * sizeof(rgExtMerged[0]));
    }
    *pcExtMerged = cExtInf + cExtOrg;
    *prgExtMerged = rgExtMerged;
    myPackExtensionArray(FALSE, pcExtMerged, prgExtMerged);
    hr = S_OK;

error:
    return(hr);
}


BOOL
IsWhistler(VOID)
{
    HRESULT hr;
    OSVERSIONINFO ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fWhistler = FALSE;

    if (!s_fDone)
    {
	s_fDone = TRUE;

	// get and confirm platform info

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx(&ovi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetVersionEx");
	}
	if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
	{
	    hr = ERROR_CANCELLED;
	    _JumpError(hr, error, "Not a supported OS");
	}
	if (5 < ovi.dwMajorVersion ||
	    (5 <= ovi.dwMajorVersion && 0 < ovi.dwMinorVersion))
	{
	    s_fWhistler = TRUE;
	}
    }

error:
    return(s_fWhistler);
}


static BOOL
GetFlags(
    OUT DWORD *pdw)
{
    HRESULT hr = S_FALSE;
    
    *pdw = 0;

#if defined(_ALLOW_GET_FLAGS_)
    hr = myGetCertRegDWValue(NULL, NULL, NULL, L"SFlags", pdw);
    if (S_OK == hr)
    {
        DBGPRINT((
	    DBG_SS_CERTLIB,
	    "CertSrv\\Configuration\\SFlags override: %u\n",
	    *pdw));
    }
#endif
    return(S_OK == hr);
}
    

BOOL
FIsAdvancedServer(VOID)
{
    HRESULT hr;
    OSVERSIONINFOEX ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fIsAdvSvr = FALSE;

    if (!s_fDone)
    {
	s_fDone = TRUE;

	// get and confirm platform info

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx((OSVERSIONINFO *) &ovi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetVersionEx");
	}
	if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
	{
	    hr = ERROR_CANCELLED;
	    _JumpError(hr, error, "Not a supported OS");
	}
 
        // if server or DC, if DTC or ADS bits are set, return TRUE

        s_fIsAdvSvr =
	    (ovi.wProductType == VER_NT_SERVER ||
	     ovi.wProductType == VER_NT_DOMAIN_CONTROLLER) && 
	    (ovi.wSuiteMask & VER_SUITE_DATACENTER ||
	     ovi.wSuiteMask & VER_SUITE_ENTERPRISE);

	{
	    DWORD dw;

	    if (GetFlags(&dw))
	    {
		s_fIsAdvSvr = dw;
	    }
	}
    }

error:
    return(s_fIsAdvSvr);
}


BOOL
FIsServer(VOID)
{
    HRESULT hr;
    OSVERSIONINFOEX ovi;
    static BOOL s_fDone = FALSE;
    static BOOL s_fIsSvr = FALSE;

    if (!s_fDone)
    {
	s_fDone = TRUE;

	// get and confirm platform info

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx((OSVERSIONINFO *) &ovi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetVersionEx");
	}
	if (VER_PLATFORM_WIN32_NT != ovi.dwPlatformId)
	{
	    hr = ERROR_CANCELLED;
	    _JumpError(hr, error, "Not a supported OS");
	}
 
        // if server or DC, if DTC or ADS bits are set, return TRUE
        s_fIsSvr =
	    (ovi.wProductType == VER_NT_SERVER ||
	     ovi.wProductType == VER_NT_DOMAIN_CONTROLLER) &&
	    0 == ((VER_SUITE_PERSONAL | VER_SUITE_BLADE) & ovi.wSuiteMask);

        if (!s_fIsSvr && VER_NT_WORKSTATION == ovi.wProductType)
	{
	    DWORD dw;

	    if (GetFlags(&dw))
	    {
		s_fIsSvr = TRUE;
	    }
	}
    }

error:
    return(s_fIsSvr);
}


HRESULT
myAddLogSourceToRegistry(
    IN LPWSTR   pwszMsgDLL,
    IN LPWSTR   pwszApp)
{
    HRESULT     hr=S_OK;
    DWORD       dwData=0;
    WCHAR       const *pwszRegPath = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
    WCHAR       NameBuf[MAX_PATH];

    HKEY        hkey = NULL;

    if (wcslen(pwszRegPath) + wcslen(pwszApp) >= ARRAYSIZE(NameBuf))
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpErrorStr(hr, error, "NameBuf", pwszApp);
    }
    wcscpy(NameBuf, pwszRegPath);
    wcscat(NameBuf, pwszApp);

    // Create a new key for our application
    hr = RegOpenKey(HKEY_LOCAL_MACHINE, NameBuf, &hkey);
    if (S_OK != hr)
    {
        hr = RegCreateKey(HKEY_LOCAL_MACHINE, NameBuf, &hkey);
        _JumpIfError(hr, error, "RegCreateKey");
    }

    // Add the Event-ID message-file name to the subkey

    hr = RegSetValueEx(
                    hkey,
                    L"EventMessageFile",
                    0,
                    REG_EXPAND_SZ,
                    (const BYTE *) pwszMsgDLL,
                    (wcslen(pwszMsgDLL) + 1) * sizeof(WCHAR));
    _JumpIfError(hr, error, "RegSetValueEx");

    // Set the supported types flags and add it to the subkey

    dwData = EVENTLOG_ERROR_TYPE |
                EVENTLOG_WARNING_TYPE |
                EVENTLOG_INFORMATION_TYPE;

    hr = RegSetValueEx(
                    hkey,
                    L"TypesSupported",
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwData,
                    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(myHError(hr));
}


HRESULT
myDupStringA(
    IN CHAR const *pszIn,
    IN CHAR **ppszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (strlen(pszIn) + 1) * sizeof(CHAR);
    *ppszOut = (CHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppszOut, pszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myIsCurrentUserBuiltinAdmin(
    OUT bool *pfIsMember)
{
    HANDLE                      hAccessToken = NULL, hDupToken = NULL;
    PSID                        psidAdministrators = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;
    HRESULT hr = S_OK;
    BOOL fIsMember = FALSE;

    CSASSERT(pfIsMember);

    if (!AllocateAndInitializeSid(
                            &siaNtAuthority,
                            2,
                            SECURITY_BUILTIN_DOMAIN_RID,
                            DOMAIN_ALIAS_RID_ADMINS,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            &psidAdministrators))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AllocateAndInitializeSid");
    }

    {
    HANDLE hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }

    // Get the access token for current thread
    if (!OpenThreadToken(
            hThread, 
            TOKEN_QUERY | TOKEN_DUPLICATE, 
            FALSE,
            &hAccessToken))
    {
        hr = myHLastError();

        if(hr==HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            HANDLE hProcess = GetCurrentProcess();
            if (NULL == hProcess)
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetCurrentProcess");
            }

            if (!OpenProcessToken(hProcess,
                    TOKEN_DUPLICATE,
                    &hAccessToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "OpenProcessToken");
            }
        }
        else
        {
            _JumpError(hr, error, "OpenThreadToken");
        }
    }
    }

    // CheckTokenMembership must operate on impersonation token, so make one
    if (!DuplicateToken(hAccessToken, SecurityIdentification, &hDupToken))
    {
        hr = myHLastError();
        _JumpError(hr, error, "DuplicateToken");
    }

    if (!CheckTokenMembership(
        hDupToken,
        psidAdministrators,
        &fIsMember))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CheckTokenMembership");
    }

    *pfIsMember = fIsMember?true:false;

    hr = S_OK;

error:
    if (hAccessToken)
        CloseHandle(hAccessToken);

    if (hDupToken)
        CloseHandle(hDupToken);

    // Free the SID we allocated
    if (psidAdministrators)
        FreeSid(psidAdministrators);

    return(hr);
}


HRESULT
mySetRegistryLocalPathString(
    IN HKEY hkey,
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszUNCPath)
{
    HRESULT hr;
    WCHAR *pwszLocalPath = NULL;

    hr = myConvertUNCPathToLocal(pwszUNCPath, &pwszLocalPath);
    _JumpIfError(hr, error, "myConvertUNCPathToLocal");

    hr = RegSetValueEx(
                    hkey,
                    pwszRegValueName,
                    0,
                    REG_SZ,
                    (BYTE *) pwszLocalPath,
                    (wcslen(pwszLocalPath) + 1) * sizeof(WCHAR));
    _JumpIfError(hr, error, "RegSetValueEx");

error:
    if (NULL != pwszLocalPath)
    {
        LocalFree(pwszLocalPath);
    }
    return(hr);
}


HRESULT
myLocalMachineIsDomainMember(
    OUT bool *pfIsDomainMember)
{
    HRESULT hr = S_OK;
    NTSTATUS status;
    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO pPDI = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;

    CSASSERT(pfIsDomainMember);

    *pfIsDomainMember = FALSE;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    status = LsaOpenPolicy( 
        NULL,
        &ObjectAttributes,
        GENERIC_READ | POLICY_VIEW_LOCAL_INFORMATION,
        &PolicyHandle);

    if(ERROR_SUCCESS != status)
    {
        hr = myHError(LsaNtStatusToWinError(status));
        _JumpError(hr, error, "LsaOpenPolicy");
    }

    status = LsaQueryInformationPolicy( PolicyHandle,
        PolicyPrimaryDomainInformation,
        (PVOID*)&pPDI);
    if(status)
    {
        hr = myHError(LsaNtStatusToWinError(status));
        _JumpError(hr, error, "LsaQueryInformationPolicy");
    }

    if( pPDI->Sid )
    {
        // domain member if has domain SID
        *pfIsDomainMember = TRUE;
                
    }

error:
    if(pPDI)
    {
        LsaFreeMemory((LPVOID)pPDI);
    }

    if(PolicyHandle)
    {
        LsaClose(PolicyHandle);
    }

    return hr;
}


HRESULT
myComputeMAC(
    IN WCHAR const *pcwsFileName,
    OUT WCHAR **ppwszMAC)
{
    HRESULT hr;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFileMapping = NULL;
    BYTE *pbFile = NULL;

    DWORD cbImage, cbImageHigh = 0;
    __int64 icbImage, icbHashed;
       
    WCHAR rgwszMAC[CBMAX_CRYPT_HASH_LEN * 3];	// 20 bytes @ 3 WCHARs/byte
    DWORD cbString;

    DWORD dwFileMappingSize; 
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE rgbHashVal[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHashVal = sizeof(rgbHashVal);

    *ppwszMAC = NULL;

    // find allocation granularity we can use
    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);
    dwFileMappingSize = systemInfo.dwAllocationGranularity;

    // get the file size
    hFile = CreateFile(
		    pcwsFileName,
		    GENERIC_READ,
		    FILE_SHARE_READ,
		    NULL,
		    OPEN_EXISTING,
		    FILE_ATTRIBUTE_NORMAL,
		    0);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = myHLastError();
	if (S_OK == hr)
	{
	    _PrintError(hr, "CreateFile");
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpErrorStr(hr, error, "CreateFile", pcwsFileName);
    }

    if (0xffffffff == (cbImage = GetFileSize(hFile, &cbImageHigh)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "GetFileSize");
    }
    icbImage = ((__int64) cbImageHigh << 32) | cbImage;

    // create mapping, indicating we will map the entire file sooner or later
    hFileMapping = CreateFileMapping(hFile,
                                  NULL,
                                  PAGE_READONLY,
                                  0,
                                  0,
                                  NULL);
    if(hFileMapping == NULL)
    {
        hr = myHLastError();
	_JumpError(hr, error, "CreateFileMapping");
    }

    // get a cryptographic provider

    if (!CryptAcquireContext(
		&hProv,
		NULL,	// container
		MS_DEF_PROV,	// provider name
		PROV_RSA_FULL, // provider type
		CRYPT_VERIFYCONTEXT)) // dwflags
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    // get a hash
    if (!CryptCreateHash(hProv, CALG_SHA1, 0, 0, &hHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptCreateHash");
    }

    // begin looping over data
    for (icbHashed = 0; icbHashed < icbImage; icbHashed += dwFileMappingSize)
    {
	DWORD cbBytesLeft = (DWORD) min(
					(__int64) dwFileMappingSize,
					icbImage - icbHashed);

	// map the next blob into memory
	pbFile = (BYTE *) MapViewOfFile(
				hFileMapping,
				FILE_MAP_READ,
				(DWORD) (icbHashed>>32),	//hi32
				(DWORD) (icbHashed),		//lo32
				cbBytesLeft);	// max num bytes to map
	if (NULL == pbFile)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "MapViewOfFile");
	}

	// hash file
	if (!CryptHashData(hHash, pbFile, cbBytesLeft, 0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashData");
	}

	// unmap this portion
	if (!UnmapViewOfFile(pbFile))
	{
	    pbFile = NULL;
	    hr = myHLastError();
	    _JumpError(hr, error, "UnmapViewOfFile");
	}
	pbFile = NULL;
    }
    // end looping over data

    // retry the hash

    if (!CryptGetHashParam(hHash, HP_HASHVAL, rgbHashVal, &cbHashVal, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetHashParam");
    }

    cbString = sizeof(rgwszMAC);
    hr = MultiByteIntegerToWszBuf(
           TRUE, // byte multiple
           cbHashVal,
           rgbHashVal,
           &cbString,
           rgwszMAC);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    hr = myDupString(rgwszMAC, ppwszMAC);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pbFile)
    {
	UnmapViewOfFile(pbFile);
    }
    if (NULL != hFileMapping)
    {
	CloseHandle(hFileMapping);
    }
    if (INVALID_HANDLE_VALUE != hFile)
    {
	CloseHandle(hFile);
    }
    if (NULL != hHash)
    {
	if (!CryptDestroyHash(hHash))
	{
	    if (hr == S_OK)
	    {
		hr = myHLastError();
	    }
	}
    }
    if (NULL != hProv)
    {
	if (!CryptReleaseContext(hProv, 0))
	{
	    if (hr == S_OK)
	    {
		hr = myHLastError();
	    }
	}
    }
    return(hr);
}


HRESULT
myHExceptionCodePrintLineFile(
    IN EXCEPTION_POINTERS const *pep,
    IN DWORD dwLineFile)
{
    return(myHExceptionCodePrint(
			pep,
			NULL, 
			__LINEFILETOFILE__(dwLineFile),
			__LINEFILETOLINE__(dwLineFile)));
}


BOOL
myShouldPrintError(
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    BOOL fPrint = TRUE;

    if (myIsDelayLoadHResult(hr))
    {
#if DBG_CERTSRV
        if (!DbgIsSSActive(DBG_SS_MODLOAD))
#endif
        {
            fPrint = FALSE;
        }
    }
    if (S_OK != hrquiet && hrquiet == hr)
    {
#if DBG_CERTSRV
        if (!DbgIsSSActive(DBG_SS_NOQUIET))
#endif
        {
            fPrint = FALSE;
        }
    }
    return(fPrint);
}


VOID
CSPrintErrorLineFileData2(
    OPTIONAL IN WCHAR const *pwszData,
    IN DWORD dwLineFile,
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    WCHAR awchr[cwcHRESULTSTRING];

    if (DbgIsSSActive(DBG_SS_ERROR) &&
	myShouldPrintError(hr, hrquiet))
    {
        DbgPrintf(
	    MAXDWORD,
	    "%u.%u.%u: %ws%ws%ws\n",
	    __LINEFILETOFILE__(dwLineFile),
	    __LINEFILETOLINE__(dwLineFile),
	    0,
	    myHResultToString(awchr, hr),
	    NULL != pwszData? L": " : L"",
	    NULL != pwszData? pwszData : L"");

        DBGPRINT((
                DBG_SS_ERROR,
                "%u.%u.%u: %ws%ws%ws\n",
		__LINEFILETOFILE__(dwLineFile),
		__LINEFILETOLINE__(dwLineFile),
		0,
                myHResultToString(awchr, hr),
                NULL != pwszData? L": " : L"",
                NULL != pwszData? pwszData : L""));
    }
}


VOID
CSPrintErrorLineFile(
    IN DWORD dwLineFile,
    IN HRESULT hr)
{
    CSPrintErrorLineFileData2(NULL, dwLineFile, hr, S_OK);
}


VOID
CSPrintErrorLineFile2(
    IN DWORD dwLineFile,
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    CSPrintErrorLineFileData2(NULL, dwLineFile, hr, hrquiet);
}


VOID
CSPrintErrorLineFileData(
    OPTIONAL IN WCHAR const *pwszData,
    IN DWORD dwLineFile,
    IN HRESULT hr)
{
    CSPrintErrorLineFileData2(pwszData, dwLineFile, hr, S_OK);
}


// Finds a template in list based on name or OID.
// Caller is responsible for CACloseCertType(hCertType) in case of success

HRESULT
myFindCertTypeByNameOrOID(
    IN const HCERTTYPE &hCertTypeList,
    IN OPTIONAL LPCWSTR pcwszCertName,
    IN OPTIONAL LPCWSTR pcwszCertOID,
    OUT HCERTTYPE& hCertType)
{
    HRESULT hr;
    HCERTTYPE hCrtCertType;
    HCERTTYPE hPrevCertType;

    CSASSERT(pcwszCertName || pcwszCertOID);

    hCertType = NULL;
    hCrtCertType = hCertTypeList;

    while (NULL != hCrtCertType)
    {
	LPWSTR *apwszCrtCertType;
	BOOL fFound;

        hr = CAGetCertTypeProperty(
                            hCrtCertType,
                            CERTTYPE_PROP_CN,
                            &apwszCrtCertType);
        _JumpIfError(hr, error, "CAGetCertTypeProperty CERTTYPE_PROP_CN");

	if (NULL != apwszCrtCertType)
	{
	    fFound = NULL != apwszCrtCertType[0] &&
		NULL != pcwszCertName &&
		0 == mylstrcmpiS(apwszCrtCertType[0], pcwszCertName);

	    CAFreeCertTypeProperty(hCrtCertType, apwszCrtCertType);
	    if (fFound)
	    {
		break;
	    }
	}

        hr = CAGetCertTypeProperty(
                            hCrtCertType,
                            CERTTYPE_PROP_OID,
                            &apwszCrtCertType);

        // ignore errors, V1 templates don't have OIDs
        if (S_OK == hr && NULL != apwszCrtCertType)
	{
	    fFound = NULL != apwszCrtCertType[0] &&
		NULL != pcwszCertOID &&
		0 == mylstrcmpiS(apwszCrtCertType[0], pcwszCertOID);

	    CAFreeCertTypeProperty(hCrtCertType, apwszCrtCertType);
	    if (fFound)
	    {
		break;
	    }
        }
        hPrevCertType = hCrtCertType;
        hr = CAEnumNextCertType(hPrevCertType, &hCrtCertType);
        _JumpIfError(hr, error, "CAEnumNextCertType");

        // hold on to the initial list

        if (hCertTypeList != hPrevCertType)
        {
            CACloseCertType(hPrevCertType);
        }
    }
    if (NULL == hCrtCertType)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        _JumpError2(hr, error, "NULL hCrtCertType", hr);
    }
    hCertType = hCrtCertType;
    hCrtCertType = NULL;
    hr = S_OK;
    
error:
    if (NULL != hCrtCertType && hCertTypeList != hCrtCertType)
    {
	CACloseCertType(hCrtCertType);
    }
    return(hr);
}


///////////////////////////////////////////////////////////////////////////////
// ConvertToString*

///////////////////////////////////////////////////////////////////////////////
HRESULT ConvertToStringI2I4(
    LONG lVal,
    LPWSTR *ppwszOut)
{
    WCHAR wszVal[cwcDWORDSPRINTF]; // big enough to hold a LONG as string
    _itow(lVal, wszVal, 10);
    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(wszVal)+1));
    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, wszVal);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT ConvertToStringUI2UI4(
    ULONG ulVal,
    LPWSTR *ppwszOut)
{
    WCHAR wszVal[cwcDWORDSPRINTF]; // big enough to hold a LONG as string
    _itow(ulVal, wszVal, 10);
    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(wszVal)+1));
    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, wszVal);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT ConvertToStringUI8(
    ULARGE_INTEGER *puliVal,
        LPWSTR *ppwszOut)
{
    WCHAR wszVal[cwcULONG_INTEGERSPRINTF]; // big enough to hold a LONG as string

    _ui64tow(puliVal->QuadPart, wszVal, 10);
    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(wcslen(wszVal)+1));
    if(!*ppwszOut)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(*ppwszOut, wszVal);
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT ConvertToStringWSZ(
    LPCWSTR pcwszVal,
    LPWSTR *ppwszOut,
    bool fDoublePercentsInString)

{
    if(fDoublePercentsInString)
    {
        // replace each occurence of % with %%
        return DoublePercentsInString(
            pcwszVal,
            ppwszOut);
    }
    else
    {
        *ppwszOut = (LPWSTR) LocalAlloc(
            LMEM_FIXED,
            sizeof(WCHAR)*(wcslen(pcwszVal)+1));
        
        if(!*ppwszOut)
        {
            return E_OUTOFMEMORY;
        }
        wcscpy(*ppwszOut, pcwszVal);
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT ConvertToStringArrayUI1(
    LPSAFEARRAY psa,
    LPWSTR *ppwszOut)
{
    SafeArrayEnum<BYTE> saenum(psa);
    if(!saenum.IsValid())
    {
        return E_INVALIDARG;
    }
    BYTE b;
    // byte array is formated as "0x00 0x00..." ie 5 
    // chars per byte
    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(saenum.GetCount()*5 + 1));

    if(!*ppwszOut)
        return E_OUTOFMEMORY;

    LPWSTR pwszCrt = *ppwszOut;
    while(S_OK==saenum.Next(b))
    {
        wsprintf(pwszCrt, L"0x%02X ", b); // eg "0x0f" or "0xa4"
        pwszCrt+=5;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT ConvertToStringArrayBSTR(
    LPSAFEARRAY psa,
    LPWSTR *ppwszOut,
    bool fDoublePercentsInString)
{
    SafeArrayEnum<BSTR> saenum(psa);
    if(!saenum.IsValid())
    {
        return E_INVALIDARG;
    }
    DWORD dwLen = 1;
    BSTR bstr;

    while(S_OK==saenum.Next(bstr))
    {
        dwLen+=2*wcslen(bstr)+10;
    }

    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(dwLen));

    if(!*ppwszOut)
        return E_OUTOFMEMORY;
    **ppwszOut = L'\0';
        
    saenum.Reset();

    WCHAR* pwszTemp = NULL;

    while(S_OK==saenum.Next(bstr))
    {
        if(fDoublePercentsInString)
        {
            if (NULL != pwszTemp)
	    {
		LocalFree(pwszTemp);
		pwszTemp = NULL;
	    }
	    if (S_OK != DoublePercentsInString(bstr, &pwszTemp))
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
                return E_OUTOFMEMORY;
            }
            wcscat(*ppwszOut, pwszTemp);
        }
        else
        {
            wcscat(*ppwszOut, bstr);
        }
        wcscat(*ppwszOut, L"\n");
    }

    LOCAL_FREE(pwszTemp);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
HRESULT DoublePercentsInString(
    LPCWSTR pcwszIn,
    LPWSTR *ppwszOut)
{
    const WCHAR *pchSrc;
    WCHAR *pchDest;

    *ppwszOut = (LPWSTR) LocalAlloc(
        LMEM_FIXED,
        sizeof(WCHAR)*(2*wcslen(pcwszIn)+1));

    if(!*ppwszOut)
        return E_OUTOFMEMORY;

    for(pchSrc = pcwszIn, pchDest = *ppwszOut; 
        L'\0'!=*pchSrc; 
        pchSrc++, pchDest++)
    {
        *pchDest = *pchSrc;
        if(L'%'==*pchSrc)
            *(++pchDest) = L'%';
    }
    *pchDest = L'\0';

    return S_OK;
}


HRESULT
ConvertToStringDATE(
    IN DATE const *pDate,
    IN BOOL fGMT,
    OUT LPWSTR *ppwszOut)
{
    HRESULT hr;
    FILETIME ft;

    hr = myDateToFileTime(pDate, &ft);
    if (S_OK == hr)
    {
        if (fGMT)
	{
	    hr = myFileTimeToWszTime(&ft, FALSE, ppwszOut);
	}
	else
	{
	    hr = myGMTFileTimeToWszLocalTime(&ft, FALSE, ppwszOut);
	}
    }
    return(hr);
}


typedef DWORD (WINAPI fnDsEnumerateDomainTrusts) (
    IN LPWSTR ServerName OPTIONAL,
    IN ULONG Flags,
    OUT PDS_DOMAIN_TRUSTSW *Domains,
    OUT PULONG DomainCount
    );

typedef NET_API_STATUS (NET_API_FUNCTION fnNetApiBufferFree) (
    IN LPVOID Buffer
    );

///////////////////////////////////////////////////////////////////////////////
HRESULT myGetComputerDomainSid(PSID& rpsidDomain)
{
    HRESULT hr = S_OK;
    PDS_DOMAIN_TRUSTS pDomainInfo = NULL;
    ULONG cDomainInfo = 0;
    HMODULE hModule = NULL;
    fnDsEnumerateDomainTrusts *pfnDsEnumerateDomainTrusts = NULL;
    fnNetApiBufferFree *pfnNetApiBufferFree = NULL;

    hModule = LoadLibrary(L"netapi32.dll");
    if (NULL == hModule)
    {
        hr = myHLastError();
        _JumpError(hr, error, "LoadLibrary(netapi32.dll)");
    }

    pfnDsEnumerateDomainTrusts = (fnDsEnumerateDomainTrusts *) GetProcAddress(
        hModule,
        "DsEnumerateDomainTrustsW");
    if (NULL == pfnDsEnumerateDomainTrusts)
    {
        hr = myHLastError();
        _JumpError(hr, error, "DsEnumerateDomainTrustsW");
    }

    pfnNetApiBufferFree = (fnNetApiBufferFree *) GetProcAddress(
        hModule,
        "NetApiBufferFree");
    if(NULL == pfnNetApiBufferFree)
    {
        hr = myHLastError();
        _JumpError(hr, error, "NetApiBufferFree");
    }

    hr = (*pfnDsEnumerateDomainTrusts)(
        NULL,
        DS_DOMAIN_PRIMARY,
        &pDomainInfo,
        &cDomainInfo);
    _JumpIfError(hr, error, "DsEnumerateDomainTrusts");

    CSASSERT(1==cDomainInfo);

    rpsidDomain = (PSID)LocalAlloc(
        LMEM_FIXED,
        GetLengthSid(pDomainInfo->DomainSid));
    _JumpIfAllocFailed(rpsidDomain, error);

    CopySid(
        GetLengthSid(pDomainInfo->DomainSid),
        rpsidDomain,
        pDomainInfo->DomainSid);
error:
    if(pDomainInfo)
    {
        (*pfnNetApiBufferFree)(pDomainInfo);
    }
    if(hModule)
    {
        FreeLibrary(hModule);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
HRESULT myGetSidFromRid(
    DWORD dwGroupRid, 
    OPTIONAL PSID *ppSid, 
    OPTIONAL LPWSTR* ppwszSid)
{
    HRESULT hr;
    LPWSTR pwszDomain = NULL;
    LPWSTR pwszDomainSid = NULL;
    PSID psidDomain = NULL;
    LPWSTR pwszSid = NULL;
    PSID psid = NULL;
    static const cchRid = 10;

    hr = myGetComputerDomainSid(psidDomain);
    _JumpIfError(hr, error, "myGetComputerDomainSid");

    if(!ConvertSidToStringSid(
        psidDomain,
        &pwszDomainSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ConvertSidToStringSid");
    }
    myRegisterMemAlloc(pwszDomainSid, -1, CSM_LOCALALLOC);

    pwszSid = (LPWSTR) LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(pwszDomainSid)+cchRid+2)); // add 2 for dash and '\0'
    _JumpIfAllocFailed(pwszSid, error);

    wsprintf(pwszSid, L"%s-%d", pwszDomainSid, dwGroupRid);

    if(ppSid)
    {
        if(!ConvertStringSidToSid(
            pwszSid,
            &psid))
        {
            hr = myHLastError();
            _JumpErrorStr(hr, error, "ConvertSidToStringSid", pwszSid);
        }
	myRegisterMemAlloc(psid, -1, CSM_LOCALALLOC);
       
        *ppSid = psid;
        psid = NULL;
    }

    if(ppwszSid)
    {
        *ppwszSid = pwszSid;
        pwszSid = NULL;
    }

    hr = S_OK;

error:
    LOCAL_FREE(pwszDomain);
    LOCAL_FREE(pwszDomainSid);
    LOCAL_FREE(psidDomain);
    LOCAL_FREE(psid);
    LOCAL_FREE(pwszSid);
    return hr;
}


HRESULT
myEncodeUTF8(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CERT_NAME_VALUE name;
    
    *ppbOut = NULL;
    name.dwValueType = CERT_RDN_UTF8_STRING;
    name.Value.pbData = (BYTE *) pwszIn;
    name.Value.cbData = 0;

    if (!myEncodeObject(
		X509_ASN_ENCODING,
		X509_UNICODE_ANY_STRING,
		&name,
		0,
		CERTLIB_USE_LOCALALLOC,
		ppbOut,
		pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myEncodeOtherNameBinary(
    IN WCHAR const *pwszIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    CRYPT_DATA_BLOB blob;

    *ppbOut = NULL;
    blob.pbData = NULL;

    if (0 == _wcsnicmp(wszPROPUTF8TAG, pwszIn, WSZARRAYSIZE(wszPROPUTF8TAG)))
    {
	hr = myEncodeUTF8(
		    &pwszIn[WSZARRAYSIZE(wszPROPUTF8TAG)],
		    ppbOut,
		    pcbOut);
	_JumpIfError(hr, error, "Policy:myEncodeUTF8");
    }
    else
    {
	WCHAR const *pwsz;
	BOOL fOctet = FALSE;

	if (0 == _wcsnicmp(
			wszPROPOCTETTAG,
			pwszIn,
			WSZARRAYSIZE(wszPROPOCTETTAG)))
	{
	    pwsz = &pwszIn[WSZARRAYSIZE(wszPROPOCTETTAG)];
	    fOctet = TRUE;
	}
	else
	if (0 == _wcsnicmp(wszPROPASNTAG, pwszIn, WSZARRAYSIZE(wszPROPASNTAG)))
	{
	    pwsz = &pwszIn[WSZARRAYSIZE(wszPROPASNTAG)];
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_DS_BAD_ATT_SCHEMA_SYNTAX);
	    _JumpError(hr, error, "Policy:polReencodeBinary");
	}

	// CryptStringToBinaryW(CRYPT_STRING_BASE64) fails on empty strings,
	// because zero length means use wcslen + 1, which passes the L'\0'
	// terminator to the base 64 conversion code.

	if (L'\0' == *pwsz)
	{
	    *ppbOut = (BYTE *) LocalAlloc(LMEM_FIXED, 0);
	    if (NULL == *ppbOut)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    *pcbOut = 0;
	}
	else
	{
	    hr = myCryptStringToBinary(
				pwsz,
				wcslen(pwsz),
				CRYPT_STRING_BASE64,
				ppbOut,
				pcbOut,
				NULL,
				NULL);
	    _JumpIfError(hr, error, "myCryptStringToBinary");
	}

	if (fOctet)
	{
	    blob.pbData = *ppbOut;
	    blob.cbData = *pcbOut;
	    *ppbOut = NULL;

	    if (!myEncodeObject(
			    X509_ASN_ENCODING,
			    X509_OCTET_STRING,
			    &blob,
			    0,
			    CERTLIB_USE_LOCALALLOC,
			    ppbOut,
			    pcbOut))
	    {
		hr = myHLastError();
		_JumpError(hr, error, "Policy:myEncodeObject");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != blob.pbData)
    {
	LocalFree(blob.pbData);
    }
    return(hr);
}


// Wrappers to make sure zeroing memory survives compiler optimizations.
// Use to wipe private key and password data.

VOID 
myZeroDataString(
    IN WCHAR *pwsz)
{
    HRESULT hr;

    hr = S_OK;
    __try
    {
	SecureZeroMemory(pwsz, wcslen(pwsz) * sizeof(*pwsz));
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
}


VOID 
myZeroDataStringA(
    IN char *psz)
{
    HRESULT hr;

    hr = S_OK;
    __try
    {
	SecureZeroMemory(psz, strlen(psz) * sizeof(*psz));
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Exception");
    }
}


// Locale-independent case-ignore string compare

int
mylstrcmpiL(
    IN WCHAR const *pwsz1,
    IN WCHAR const *pwsz2)
{
    // CSTR_LESS_THAN(1) - CSTR_EQUAL(2)    == -1 string 1 less than string 2
    // CSTR_EQUAL(2) - CSTR_EQUAL(2)        == 0 string 1 equal to string 2
    // CSTR_GREATER_THAN(3) - CSTR_EQUAL(2) == 1 string 1 greater than string 2

    return(CompareString(
		IsWhistler()?
		    LOCALE_INVARIANT :
		    MAKELCID(
			MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
			SORT_DEFAULT),
		NORM_IGNORECASE,
		pwsz1,
		-1,
		pwsz2,
		-1) -
	    CSTR_EQUAL);
}

// Locale-independent case-ignore string compare
// asserts the static string contains a strict subset of 7-bit ASCII characters.

int
mylstrcmpiS(
    IN WCHAR const *pwszDynamic,
    IN WCHAR const *pwszStatic)
{
#if DBG_CERTSRV
    WCHAR const *pwszS;

    for (pwszS = pwszStatic; L'\0' != *pwszS; pwszS++)
    {
	CSASSERT(L' ' <= *pwszS && L'~' >= *pwszS);
    }
#endif //DBG_CERTSRV

    return(mylstrcmpiL(pwszDynamic, pwszStatic));
}


HRESULT
myGetLong(
    WCHAR const *pwszIn,
    LONG *pLong)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR const *pwsz;
    LONG l;

    pwsz = pwszIn;
    if (NULL == pwsz)
    {
	_JumpError(hr, error, "NULL parm");
    }
    if (L'\0' == *pwsz)
    {
	_JumpError(hr, error, "empty string");
    }
    if (L'0' == *pwsz && (L'x' == pwsz[1] || L'X' == pwsz[1]))
    {
	pwsz += 2;
	l = 0;
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswxdigit(*pwsz))
	    {
		_JumpErrorStr(hr, error, "Non-hex digit", pwszIn);
	    }
	    l <<= 4;
	    if (iswdigit(*pwsz))
	    {
		l |= *pwsz - L'0';
	    }
	    else if (L'A' <= *pwsz && L'F' >= *pwsz)
	    {
		l |= *pwsz - L'A' + 10;
	    }
	    else
	    {
		l |= *pwsz - L'a' + 10;
	    }
	}
	*pLong = l;
    }
    else
    {
	for ( ; L'\0' != *pwsz; pwsz++)
	{
	    if (!iswdigit(*pwsz))
	    {
		_JumpErrorStr2(hr, error, "Non-decimal digit", pwszIn, hr);
	    }
	}
	*pLong = _wtol(pwszIn);
    }
    hr = S_OK;
    //wprintf(L"myGetLong(%ws) --> %x (%d)\n", pwszIn, *pLong, *pLong);

error:
    return(hr);
}


HRESULT
myGetSignedLong(
    WCHAR const *pwszIn,
    LONG *pLong)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR const *pwsz;
    LONG sign = 1;

    pwsz = pwszIn;
    if (NULL == pwsz)
    {
	_JumpError(hr, error, "NULL parm");
    }
    if (myIsMinusSign(*pwsz))
    {
	pwsz++;
	sign = -1;
    }
    else if (L'+' == *pwsz)
    {
	pwsz++;
    }
    hr = myGetLong(pwsz, pLong);
    _JumpIfError2(hr, error, "myGetLong", hr);

    *pLong *= sign;
    //wprintf(L"myGetSignedLong(%ws) --> %x (%d)\n", pwszIn, *pLong, *pLong);

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\certpick.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certpick.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "cainfop.h"
#include "csdisp.h"
#include "csldap.h"
#include "tfc.h"
#include "clibres.h"

#define __dwFILE__	__dwFILE_CERTLIB_CERTPICK_CPP__


#define CUCS_SOURCEMASK (CUCS_MACHINESTORE | CUCS_USERSTORE | CUCS_DSSTORE)

#define CUCS_TYPEMASK (CUCS_MYSTORE | \
			CUCS_CASTORE | \
			CUCS_KRASTORE | \
			CUCS_ROOTSTORE)

#define CUCS_VALIDMASK (CUCS_SOURCEMASK | \
			CUCS_TYPEMASK | \
			CUCS_V1ONLY | \
			CUCS_V3ONLY | \
			CUCS_ARCHIVED | \
			CUCS_USAGEREQUIRED | \
			CUCS_SILENT | \
			CUCS_PRIVATEKEYREQUIRED | \
                        CUCS_USAGEKEYENCIPHER)


// My, CA, KRA and Root stores -- in HKLM, HKCU and the DS
#define CDISPLAYSTOREMAX	(4 * 3)

typedef struct _STOREMAP {
    DWORD dwFlags;
    WCHAR const *pwszStoreName;
    WCHAR const *pwszDSTemplate;
} STOREMAP;

STOREMAP s_aStoreMap[] = {
    { CUCS_MYSTORE,   wszMY_CERTSTORE,   NULL },
    { CUCS_CASTORE,   wszCA_CERTSTORE,   wszDSAIAQUERYTEMPLATE },
    { CUCS_KRASTORE,  wszKRA_CERTSTORE,  wszDSKRAQUERYTEMPLATE },
    { CUCS_ROOTSTORE, wszROOT_CERTSTORE, NULL },
    { 0x0,            NULL,              NULL },
};

HRESULT
FormatDSStoreName(
    IN OUT BSTR *pstrDomainDN,
    IN OUT BSTR *pstrConfigDN,
    IN WCHAR const *pwszTemplate,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    LDAP *pld = NULL;

    if (NULL == *pstrConfigDN)		// first call
    {
	// Renewal domain and config containers (%5, %6)

	hr = myLdapOpen(
		    NULL,			// pwszDomainName
		    RLBF_REQUIRE_SECURE_LDAP,	// dwFlags
		    &pld,
		    pstrDomainDN,
		    pstrConfigDN);
	_JumpIfError(hr, error, "myLdapOpen");
    }
    hr = myFormatCertsrvStringArray(
		    FALSE,			// fURL
		    L"",			// pwszServerName_p1_2
		    L"",            // pwszSanitizedName_p3_7
		    0,				// iCert_p4
		    MAXDWORD,			// iCertTarget_p4
		    *pstrDomainDN,		// pwszDomainDN_p5
		    *pstrConfigDN,		// pwszConfigDN_p6
		    0,				// iCRL_p8
		    FALSE,			// fDeltaCRL_p9
		    FALSE,			// fDSAttrib_p10_11
		    1,				// cStrings
		    (LPCWSTR *) &pwszTemplate,	// apwszStringsIn
		    ppwszOut);			// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

error:
    myLdapClose(pld, NULL, NULL);
    return(hr);
}


HRESULT
myOpenCertStores(
    IN DWORD dwFlags,		// CUCS_*
    OUT DWORD *pcStore,
    OUT HCERTSTORE **prghStore)
{
    HRESULT hr;
    HRESULT hr2;
    HCERTSTORE *rghStore = NULL;
    DWORD cStore = 0;
    STOREMAP *psm;
    DWORD OpenFlags;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;
    WCHAR *pwszDSStore = NULL;

    *pcStore = 0;
    *prghStore = NULL;
    rghStore = (HCERTSTORE *) LocalAlloc(
				    LMEM_FIXED,
				    CDISPLAYSTOREMAX * sizeof(HCERTSTORE));
    if (NULL == rghStore)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc(rghStore)");
    }
    OpenFlags = CERT_STORE_READONLY_FLAG | CERT_STORE_SET_LOCALIZED_NAME_FLAG;
    if (CUCS_ARCHIVED & dwFlags)
    {
	OpenFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;
    }

    hr2 = S_OK;
    if ((CUCS_SOURCEMASK | CUCS_TYPEMASK) & dwFlags)
    {
	if (~CUCS_VALIDMASK & dwFlags)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwFlags");
	}
	if (0 == (CUCS_SOURCEMASK & dwFlags))
	{
	    dwFlags |= CUCS_SOURCEMASK;	// source default: all cert store sources
	}
	if (0 == (CUCS_TYPEMASK & dwFlags))
	{
	    dwFlags |= CUCS_MYSTORE;	// type default: use my store
	}

	for (psm = s_aStoreMap; NULL != psm->pwszStoreName; psm++)
	{
	    if (dwFlags & psm->dwFlags)
	    {
		HCERTSTORE hStore;

		if (CUCS_MACHINESTORE & dwFlags)
		{
		    hStore = CertOpenStore(
				    CERT_STORE_PROV_SYSTEM_W,
				    X509_ASN_ENCODING,
				    NULL,
				    CERT_SYSTEM_STORE_LOCAL_MACHINE | OpenFlags,
				    psm->pwszStoreName);
		    if (NULL == hStore)
		    {
			hr = myHLastError();
			_PrintErrorStr(hr, "CertOpenStore LocalMachine", psm->pwszStoreName);
			if (S_OK == hr2)
			{
			    hr2 = hr;
			}
		    }
		    else
		    {
			DBGPRINT((
			    DBG_SS_CERTLIBI,
			    "CertOpenStore LocalMachine(%ws, HKLM)[%u]\n",
			    psm->pwszStoreName,
			    cStore));
			rghStore[cStore++] = hStore;
		    }
		}
		if (CUCS_USERSTORE & dwFlags)
		{
		    hStore = CertOpenStore(
				    CERT_STORE_PROV_SYSTEM_W,
				    X509_ASN_ENCODING,
				    NULL,
				    CERT_SYSTEM_STORE_CURRENT_USER | OpenFlags,
				    psm->pwszStoreName);
		    if (NULL == hStore)
		    {
			hr = myHLastError();
			_PrintErrorStr(hr, "CertOpenStore User", psm->pwszStoreName);
			if (S_OK == hr2)
			{
			    hr2 = hr;
			}
		    }
		    else
		    {
			DBGPRINT((
			    DBG_SS_CERTLIBI,
			    "CertOpenStore User(%ws, HKCU)[%u]\n",
			    psm->pwszStoreName,
			    cStore));
			rghStore[cStore++] = hStore;
		    }
		}
		if ((CUCS_DSSTORE & dwFlags) && NULL != psm->pwszDSTemplate)
		{
		    CString strStoreFriendlyName;
		    int idResource;

		    switch(psm->dwFlags)
		    {
			case CUCS_CASTORE:
			    idResource = IDS_STORENAME_DS_AIA;
			    break;

			case CUCS_KRASTORE:
			    idResource = IDS_STORENAME_DS_KRA;
			    break;

			default:
			    CSASSERT(CSExpr(!"Invalid cert store name"));
			    idResource = 0;
		    }
		    strStoreFriendlyName.LoadString(idResource);

		    if (NULL != pwszDSStore)
		    {
			LocalFree(pwszDSStore);
			pwszDSStore = NULL;
		    }

		    hr = FormatDSStoreName(
				    &strDomainDN,
				    &strConfigDN,
				    psm->pwszDSTemplate,
				    &pwszDSStore);
                    if (S_OK != hr)
                    {
                        _PrintError(hr, "FormatDSStoreName");
                    }
                    else
                    {
                        hStore = myUrlCertOpenStore(
					CRYPT_WIRE_ONLY_RETRIEVAL |
					    CRYPT_RETRIEVE_MULTIPLE_OBJECTS,
					pwszDSStore);
                        if (NULL == hStore)
                        {
                            hr = myHLastError();
                            _PrintErrorStr(hr, "myUrlCertOpenStore", pwszDSStore);
                            if (S_OK == hr2)
                            {
                                hr2 = hr;
                            }
                        }
                        else
                        {
                            CRYPT_DATA_BLOB cdb;

                            cdb.pbData = (BYTE *) strStoreFriendlyName.GetBuffer();
                            cdb.cbData = sizeof(WCHAR) *
                                (wcslen(strStoreFriendlyName.GetBuffer()) + 1);
                            if (!CertSetStoreProperty(
					hStore,
					CERT_STORE_LOCALIZED_NAME_PROP_ID,
					0,
					(const void *) &cdb))
                            {
                                hr = myHLastError();
                                _PrintErrorStr(hr, "CertSetStoreProp LDAP", pwszDSStore);
                                hr = S_OK;
                            }

                            DBGPRINT((
                                DBG_SS_CERTLIBI,
                                "myUrlCertOpenStore(%ws)[%u]\n",
                                pwszDSStore,
                                cStore));
                            rghStore[cStore++] = hStore;
                        }

		    }
		}
	    }
	}
    }
    hr = hr2;

    if (0 == cStore)
    {
        if (hr == S_OK)
	{
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpError(hr, error, "no Cert Store");
    }
    CSASSERT(CDISPLAYSTOREMAX >= cStore);
    *pcStore = cStore;
    *prghStore = rghStore;
    rghStore = NULL;

    // successfully opened some stores
    hr = S_OK;

error:
    if (NULL != strDomainDN)
    {
	SysFreeString(strDomainDN);
    }
    if (NULL != strConfigDN)
    {
	SysFreeString(strConfigDN);
    }
    if (NULL != pwszDSStore)
    {
        LocalFree(pwszDSStore);
    }
    if (NULL != rghStore)
    {
	myCloseCertStores(cStore, rghStore);
    }
    return(hr);
}


VOID
myCloseCertStores(
    IN DWORD cStore,
    IN HCERTSTORE *rghStore)
{
    DWORD i;

    if (NULL != rghStore)
    {
	for (i = cStore; i < cStore; i++)
	{
	    if (NULL != rghStore[i])
	    {
		CertCloseStore(rghStore[i], CERT_CLOSE_STORE_CHECK_FLAG);
	    }
        }
	LocalFree(rghStore);
    }
}


// Search for and load the cryptographic provider and private key. 

HRESULT
myLoadPrivateKey(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD dwFlags,		// CUCS_*
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv)
{
    HRESULT hr;
    HCERTSTORE *rghStore = NULL;
    DWORD cStore;

    hr = myOpenCertStores(dwFlags, &cStore, &rghStore);
    _JumpIfError(hr, error, "myOpenCertStores");

    hr = myLoadPrivateKeyFromCertStores(
				pPubKeyInfo,
				cStore,
				rghStore,
				phProv,
				pdwKeySpec,
				pfCallerFreeProv);
    _JumpIfError(hr, error, "myLoadPrivateKeyFromCertStores");

error:
    if (NULL != rghStore)
    {
	myCloseCertStores(cStore, rghStore);
    }
    return(hr);
}


HRESULT
myLoadPrivateKeyFromCertStores(
    IN CERT_PUBLIC_KEY_INFO const *pPubKeyInfo,
    IN DWORD cStore,
    IN HCERTSTORE *rghStore,
    OUT HCRYPTPROV *phProv,
    OUT DWORD *pdwKeySpec,
    OUT BOOL *pfCallerFreeProv)
{
    HRESULT hr;
    DWORD i;
    CERT_CONTEXT const *pcc = NULL;

    // for each cert store
    //   for each cert in store with matching public key (lookup by public key)
    //     call CryptAcquireCertificatePrivateKey
    //       if succeeds, exit w/S_OK

    hr = S_OK;
    for (i = 0; i < cStore; i++)
    {
	HCERTSTORE hStore = rghStore[i];

	for (;;)
	{
	    pcc = CertFindCertificateInStore(
				    hStore,
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    0,
				    CERT_FIND_PUBLIC_KEY,
				    pPubKeyInfo,
				    pcc);
	    if (NULL == pcc)
	    {
		hr = myHLastError();
		_PrintError(hr, "CertFindCertificateInStore");
		break;
	    }
	    if (!CryptAcquireCertificatePrivateKey(
				    pcc,
				    CRYPT_ACQUIRE_COMPARE_KEY_FLAG,
				    NULL,	// pvReserved
				    phProv,
				    pdwKeySpec,
				    pfCallerFreeProv))
	    {
		hr = myHLastError();
		_PrintError(hr, "CryptAcquireCertificatePrivateKey");
		continue;
	    }
	    hr = S_OK;
	    goto error;
	}
    }
    if (S_OK == hr)
    {
	hr = CRYPT_E_NOT_FOUND;
    }
    _JumpError(hr, error, "CertFindCertificateInStore");

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
	pcc = NULL;
    }
    return(hr);
}


HRESULT
myMakeSerialBstr(
    IN WCHAR const *pwszSerialNumber,
    OUT BSTR *pstrSerialNumber)
{
    HRESULT hr = E_OUTOFMEMORY;
    WCHAR *pwszDup = NULL;
    WCHAR const *pwszSrc;
    WCHAR *pwszDst;

    pwszDup = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszSerialNumber) + 2) * sizeof(*pwszDup));
    if (NULL == pwszDup)
    {
	_JumpError(hr, error, "LocalAlloc");
    }

    pwszSrc = pwszSerialNumber;
    *pwszDup = L'0';		// allow possible leading zero
    pwszDst = &pwszDup[1];

    while (L'\0' != *pwszSrc)
    {
	WCHAR wc = *pwszSrc++;

	if (iswspace(wc))
	{
	    continue;
	}
	if (L'A' <= wc && L'F' >= wc)
	{
	    wc += L'a' - L'A';
	}
	if ((L'a' > wc || L'f' < wc) &&
	    (L'0' > wc || L'9' < wc))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr2(hr, error, "myMakeSerialBstr", pwszSerialNumber, hr);
	}
	*pwszDst++ = wc;
    }
    *pwszDst = L'\0';
    pwszSrc = pwszDup;		// point at possible extra leading zero
    if (1 & (pwszDst - pwszSrc))
    {
	pwszSrc++;		// keep the length even
    }
    while (L'0' == pwszSrc[0] && L'0' == pwszSrc[1] && L'\0' != pwszSrc[2])
    {
	pwszSrc += 2;		// skip pairs of leading zeros
    }

    if (!myConvertWszToBstr(pstrSerialNumber, pwszSrc, MAXDWORD))
    {
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    hr = S_OK;

error:
    if (NULL != pwszDup)
    {
	LocalFree(pwszDup);
    }
    return(hr);
}


HRESULT
myNameBlobMatch(
    IN CERT_NAME_BLOB const *pSubject,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fFoundCN = FALSE;
    BOOL fMatchCN = FALSE;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    DWORD i;

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pSubject->pbData,
		pSubject->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    for (i = 0; i < pNameInfo->cRDN; i++)
    {
	CERT_RDN const *prdn;
	DWORD j;

	prdn = &pNameInfo->rgRDN[i];

	for (j = 0; j < prdn->cRDNAttr; j++)
	{
	    CERT_RDN_ATTR const *prdna;

	    prdna = &prdn->rgRDNAttr[j];

	    if (0 == strcmp(szOID_COMMON_NAME, prdna->pszObjId) &&
		NULL != prdna->Value.pbData)
	    {
		fFoundCN = TRUE;
		
		if (0 == mylstrcmpiL(
			    pwszCertName,
			    (WCHAR const *) prdna->Value.pbData))
		{
		    fMatchCN = TRUE;
		    break;
		}
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    *pfMatch = fMatchCN || (fAllowMissingCN && !fFoundCN);
    return(hr);
}


HRESULT
mySerialNumberMatch(
    IN CRYPT_INTEGER_BLOB const *pSerialNumber,
    IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BSTR strSerialNumber = NULL;
    BOOL fMatch = FALSE;

    hr = MultiByteIntegerToBstr(
			FALSE,
			pSerialNumber->cbData,
			pSerialNumber->pbData,
			&strSerialNumber);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    if (0 == mylstrcmpiL(pwszSerialNumber, strSerialNumber))
    {
	fMatch = TRUE;
    }
    CSASSERT(S_OK == hr);

error:
    if (NULL != strSerialNumber)
    {
        SysFreeString(strSerialNumber);
    }
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCertHashMatch(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    //wprintf(L"IN: ");
    //DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 1, pb, cb);

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pCert,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    //wprintf(L"CH: ");
    //DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 1, abHash, cbHash);
    if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
    {
	fMatch = TRUE;
	hr = S_OK;
	goto error;
    }

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
				pCert,
				CERT_KEY_IDENTIFIER_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_PrintError(hr, "CertGetCertificateContextProperty(KeyId)");
    }
    else
    {
	//wprintf(L"KH: ");
	//DumpHex(DH_NOADDRESS | DH_NOTABPREFIX | DH_NOASCIIHEX | 1, abHash, cbHash);
	if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
	{
	    fMatch = TRUE;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCertMatch(
    IN CERT_CONTEXT const *pCert,
    IN WCHAR const *pwszCertName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    
    if (NULL != pbHash)
    {
	hr = myCertHashMatch(pCert, cbHash, pbHash, &fMatch);
	_JumpIfError(hr, error, "myCertHashMatch");
    }
    if (!fMatch && NULL != pwszSerialNumber)
    {
	hr = mySerialNumberMatch(
			&pCert->pCertInfo->SerialNumber,
			pwszSerialNumber,
			&fMatch);
	_JumpIfError(hr, error, "mySerialNumberMatch");
    }
    if (!fMatch)
    {
	hr = myNameBlobMatch(
			&pCert->pCertInfo->Subject,
			pwszCertName,
			fAllowMissingCN,
			&fMatch);
	_JumpIfError(hr, error, "myNameBlobMatch");
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCertMatchEKUOrApplicationPolicies(
    IN CERT_CONTEXT const *pCert,
    IN DWORD cpszObjId,
    IN CHAR const * const *apszObjId,
    IN BOOL fUsageRequired,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    CERT_ENHKEY_USAGE *pKeyUsage = NULL;
    DWORD cbKeyUsage = 0;
    BOOL fMatch = FALSE;
    DWORD i;
    DWORD j;
    
    for (;;)
    {
	// get enhanced key usage OIDs

	if (!CertGetEnhancedKeyUsage(
			pCert,
			CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
			pKeyUsage,
			&cbKeyUsage))
	{
	    // accept match if EKU extension not found

	    hr = myHLastError();
	    if (!fUsageRequired && CRYPT_E_NOT_FOUND == hr)
	    {
		fMatch = TRUE;
	    }
	    _PrintError2(hr, "CertGetEnhancedKeyUsage", CRYPT_E_NOT_FOUND);
	    hr = S_OK;
	    goto error;
	}
	if (NULL != pKeyUsage)
	{
	    break;	// EKU extension fetched; break out of while loop
	}
	pKeyUsage = (CERT_ENHKEY_USAGE *) LocalAlloc(LMEM_FIXED, cbKeyUsage);
	if (NULL == pKeyUsage)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "out of memory");
	}
    }

    if (NULL != pKeyUsage)
    {
	if (0 == pKeyUsage->cUsageIdentifier)
	{
	    hr = myHLastError();	// set by CertGetEnhancedKeyUsage
	    if (S_OK != hr)
	    {
		fMatch = TRUE;
	    }
	}
	else
	{
	    for (i = 0; i < pKeyUsage->cUsageIdentifier; i++)
	    {
		if (fMatch)
		{
		    break;
		}
		for (j = 0; j < cpszObjId; j++)
		{
		    if (0 == strcmp(
				pKeyUsage->rgpszUsageIdentifier[i],
				apszObjId[j]))
		    {
			fMatch = TRUE;	// found matching EKU OID
			break;
		    }
		}
	    }
	}
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    if (NULL != pKeyUsage)
    {
        LocalFree(pKeyUsage);
    }
    return(hr);
}


HRESULT
myCRLHashMatch(
    IN CRL_CONTEXT const *pCRL,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    cbHash = sizeof(abHash);
    if (!CertGetCRLContextProperty(
				pCRL,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCRLContextProperty");
    }
    if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
    {
	fMatch = TRUE;
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCRLMatch(
    IN CRL_CONTEXT const *pCRL,
    IN WCHAR const *pwszCRLName,
    IN BOOL fAllowMissingCN,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    
    if (NULL != pbHash)
    {
	hr = myCRLHashMatch(pCRL, cbHash, pbHash, &fMatch);
	_JumpIfError(hr, error, "myCRLHashMatch");
    }
    if (!fMatch)
    {
	hr = myNameBlobMatch(
			&pCRL->pCrlInfo->Issuer,
			pwszCRLName,
			fAllowMissingCN,
			&fMatch);
	_JumpIfError(hr, error, "myNameBlobMatch");
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCTLHashMatch(
    IN CTL_CONTEXT const *pCTL,
    IN DWORD cb,
    IN BYTE const *pb,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    cbHash = sizeof(abHash);
    if (!CertGetCTLContextProperty(
				pCTL,
				CERT_SHA1_HASH_PROP_ID,
				abHash,
				&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCTLContextProperty");
    }
    if (cbHash == cb && 0 == memcmp(abHash, pb, cb))
    {
	fMatch = TRUE;
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


HRESULT
myCTLMatch(
    IN CTL_CONTEXT const *pCTL,
    OPTIONAL IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT BOOL *pfMatch)
{
    HRESULT hr;
    BOOL fMatch = FALSE;
    
    if (NULL != pbHash)
    {
	hr = myCTLHashMatch(pCTL, cbHash, pbHash, &fMatch);
	_JumpIfError(hr, error, "myCTLHashMatch");
    }
    hr = S_OK;

error:
    *pfMatch = fMatch;
    return(hr);
}


typedef struct _CERTFILTERCALLBACKDATA
{
    DWORD		dwFlags;	// CUCS_*
    DWORD		cpszObjId;
    CHAR const * const *apszObjId;
    WCHAR const	       *pwszCommonName;
    BYTE	       *pbHash;
    DWORD		cbHash;
    BSTR		strSerialNumber;
    HRESULT		hr;
    HCERTSTORE		hMemStore;
} CERTFILTERCALLBACKDATA;


BOOL WINAPI
CertificateFilterProc(
    PCCERT_CONTEXT pCertContext,
    BOOL          *pfInitialSelectedCert,
    void          *pvCallbackData)
{
    HRESULT hr;
    BOOL fMatch;
    CERTFILTERCALLBACKDATA *pCallbackData =
                           (CERTFILTERCALLBACKDATA *) pvCallbackData;
    CERT_NAME_INFO *pNameInfo = NULL;
    WCHAR *pwszSubject = NULL;

    CSASSERT(NULL != pCertContext);

    *pfInitialSelectedCert = FALSE;
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		&pCertContext->pCertInfo->Subject,
		CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_QUOTING_FLAG,
		&pwszSubject);
    _PrintIfError(hr, "myCertNameToStr");
    if (NULL != pCallbackData->apszObjId)
    {
	hr = myCertMatchEKUOrApplicationPolicies(
				pCertContext,
				pCallbackData->cpszObjId,
				pCallbackData->apszObjId,
				CUCS_USAGEREQUIRED & pCallbackData->dwFlags,
				&fMatch);
	_JumpIfError(hr, error, "myCertMatchEKUOrApplicationPolicies");

	if (!fMatch)
	{
	    _PrintErrorStr2(
			CRYPT_E_NOT_FOUND,
			"no matching EKU",
			pwszSubject,
			CRYPT_E_NOT_FOUND);
	    hr = S_OK;
	    goto error;
	}
    }

    // The CommonName filter serves three purposes: 1: a common name, 2: the
    // sha-1 hash of the cert, 3: the sha-1 hash of the public key (or the
    // Subject Key Id extension), 4: the serial number of the cert.  If any one
    // of these match, the cert is accepted.

    if (NULL != pCallbackData->pwszCommonName)
    {
	hr = myCertMatch(
		    pCertContext,
		    pCallbackData->pwszCommonName,
		    FALSE,		// fAllowMissingCN
		    pCallbackData->pbHash,
		    pCallbackData->cbHash,
		    pCallbackData->strSerialNumber,
		    &fMatch);
	_JumpIfError(hr, error, "myCertMatch");

	if (!fMatch)
	{
	    _PrintErrorStr2(
		    CRYPT_E_NOT_FOUND,
		    "no matching CN/Hash/Serial",
		    pwszSubject,
		    CRYPT_E_NOT_FOUND);
	    hr = S_OK;
	    goto error;
	}
    }

    fMatch = FALSE;
    if ((CUCS_V1ONLY & pCallbackData->dwFlags) && 
	CERT_V1 != pCertContext->pCertInfo->dwVersion)
    {
	_PrintErrorStr2(
		CRYPT_E_NOT_FOUND,
		"not V1",
		pwszSubject,
		CRYPT_E_NOT_FOUND);
	hr = S_OK;
	goto error;
    }

    if ((CUCS_V3ONLY & pCallbackData->dwFlags) && 
	CERT_V3 != pCertContext->pCertInfo->dwVersion)
    {
	_PrintErrorStr2(
		CRYPT_E_NOT_FOUND,
		"not V3",
		pwszSubject,
		CRYPT_E_NOT_FOUND);
	hr = S_OK;
	goto error;
    }

    if (CUCS_PRIVATEKEYREQUIRED & pCallbackData->dwFlags)
    {
	DWORD cb;
	
	if (!CertGetCertificateContextProperty(
					pCertContext,
					CERT_KEY_PROV_INFO_PROP_ID,
					NULL,
					&cb))
	{
	    _PrintErrorStr(CRYPT_E_NOT_FOUND, "no KeyProvInfo", pwszSubject);
	    hr = S_OK;
	    goto error;
	}
    }

    if (CUCS_USAGEKEYENCIPHER & pCallbackData->dwFlags)
    {
	DWORD dwKeyUsage;
	DWORD cb = sizeof(dwKeyUsage);
	
	if (!CertGetIntendedKeyUsage(
		X509_ASN_ENCODING,
		pCertContext->pCertInfo,
		(BYTE*)&dwKeyUsage,
		cb))
	{
	    _PrintErrorStr(CRYPT_E_NOT_FOUND, "CertGetIntendedKeyUsage", pwszSubject);
	    hr = S_OK;
	    goto error;
	}
	if (!(dwKeyUsage & CERT_KEY_ENCIPHERMENT_KEY_USAGE))
	{
	    _PrintErrorStr2(
		    CRYPT_E_NOT_FOUND,
		    "key encipherment key usage not found",
		    pwszSubject,
		    CRYPT_E_NOT_FOUND);
	    hr = S_OK;
	    goto error;
	}
    }

    // Attempt to add to the temporary store; if it fails then it already
    // exists so we don't want it displayed.

    if (!CertAddCertificateLinkToStore(
			    pCallbackData->hMemStore,
			    pCertContext,
			    CERT_STORE_ADD_NEW,
			    NULL))
    {
	hr = myHLastError();
	_PrintErrorStr2(hr, "CertAddCertificateLinkToStore Dup", pwszSubject, hr);
	hr = S_OK;
	goto error;
    }
    fMatch = TRUE;
    hr = S_OK;

error:
    if (S_OK == pCallbackData->hr || (fMatch && S_FALSE == pCallbackData->hr))
    {
        pCallbackData->hr = hr;		// keep the first HRESULT
    }
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    if (NULL != pNameInfo)
    {
        LocalFree(pNameInfo);
    }
    return(fMatch);
}


HRESULT
myGetKRACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fUseDS,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    CHAR const *pszObjId = szOID_KP_KEY_RECOVERY_AGENT;

    hr = myGetCertificateFromPicker(
			    hInstance,
			    hwndParent,
			    idTitle,
			    idSubTitle,
			    CUCS_MYSTORE | CUCS_KRASTORE | CUCS_CASTORE |
				CUCS_MACHINESTORE | CUCS_USERSTORE |
				CUCS_USAGEREQUIRED | CUCS_USAGEKEYENCIPHER |
				(fUseDS? CUCS_DSSTORE : 0) |
				(fSilent? CUCS_SILENT : 0),
			    pwszCommonName,
			    0,		// cStore
			    NULL,	// rghStore
			    1,		// cpszObjId
			    &pszObjId,
			    ppCert);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

error:
    return(hr);
}


HRESULT
myGetERACertificateFromPicker(
    OPTIONAL IN HINSTANCE    hInstance,
    OPTIONAL IN HWND         hwndParent,
    OPTIONAL IN int          idTitle,
    OPTIONAL IN int          idSubTitle,
    OPTIONAL IN WCHAR const *pwszCommonName,
    IN BOOL		     fSilent,
    OUT CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    CHAR const * const apszObjId[2] = {
	szOID_ENROLLMENT_AGENT,
	szOID_KP_QUALIFIED_SUBORDINATION,
    };

    hr = myGetCertificateFromPicker(
			    hInstance,
			    hwndParent,
			    idTitle,
			    idSubTitle,
			    CUCS_MYSTORE |
				CUCS_PRIVATEKEYREQUIRED |
				//CUCS_USAGEREQUIRED |
				(fSilent? CUCS_SILENT : 0),
			    pwszCommonName,
			    0,				// cStore
			    NULL,			// rghStore
			    ARRAYSIZE(apszObjId),	// cpszObjId
			    apszObjId,
			    ppCert);
    _JumpIfError(hr, error, "myGetCertificateFromPicker");

error:
    return(hr);
}


HRESULT
mySelectCertificateFromStore(
    IN OUT CRYPTUI_SELECTCERTIFICATE_STRUCT *pCertSelect,
    IN HCERTSTORE hStore,
    IN OUT CERT_CONTEXT const **ppCertRet)
{
    HRESULT hr;
    CERT_CONTEXT const *pCertRet = *ppCertRet;
    CERT_CONTEXT const *pCert = NULL;
    BOOL fInitialSelectedCert = FALSE;

    for (;;)
    {
	pCert = CertEnumCertificatesInStore(hStore, pCert);
	if (NULL == pCert)
	{
	    hr = myHLastError();
	    _PrintError(hr, "CertEnumCertificatesInStore");
	    break;
	}
	if ((*pCertSelect->pFilterCallback)(
				pCert,
				&fInitialSelectedCert,
				pCertSelect->pvCallbackData))
	{
	    if (NULL != pCertRet)
	    {
		hr = CRYPT_E_EXISTS;
		_JumpError(hr, error, "more than one cert matches");
	    }
	    pCertRet = CertDuplicateCertificateContext(pCert);
	    if (NULL == pCertRet)
	    {
		hr = CRYPT_E_NOT_FOUND;
		_JumpError(hr, error, "CertDuplicateCertificateContext");
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pCert)
    {
	CertFreeCertificateContext(pCert);
    }
    *ppCertRet = pCertRet;
    return(hr);
}


CERT_CONTEXT const *
mySelectCertificate(
    IN OUT CRYPTUI_SELECTCERTIFICATE_STRUCT *pCertSelect)
{
    HRESULT hr;
    CERT_CONTEXT const *pCert = NULL;
    DWORD i;

    if (NULL == pCertSelect->rghDisplayStores ||
	0 == pCertSelect->cDisplayStores)
    {
	hr = CRYPT_E_NOT_FOUND;
	_JumpError(hr, error, "no Cert Stores");
    }
    for (i = 0; i < pCertSelect->cDisplayStores; i++)
    {
	hr = mySelectCertificateFromStore(
				    pCertSelect,
				    pCertSelect->rghDisplayStores[i],
				    &pCert);
	_JumpIfError(hr, error, "mySelectCertificateFromStore");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	if (NULL != pCert)
	{
	    CertFreeCertificateContext(pCert);
	    pCert = NULL;
	}
	SetLastError(hr);
    }
    return(pCert);
}


HRESULT
myGetCertificateFromPicker(
    OPTIONAL IN HINSTANCE           hInstance,
    OPTIONAL IN HWND                hwndParent,
    OPTIONAL IN int                 idTitle,
    OPTIONAL IN int                 idSubTitle,
    IN DWORD                        dwFlags,	// CUCS_*
    OPTIONAL IN WCHAR const        *pwszCommonName,
    OPTIONAL IN DWORD               cStore,
    OPTIONAL IN HCERTSTORE         *rghStore,
    IN DWORD		            cpszObjId,
    OPTIONAL IN CHAR const * const *apszObjId,
    OUT CERT_CONTEXT const        **ppCert)
{
    HRESULT hr;
    HCERTSTORE *rghStoreOpened = NULL;
    DWORD cStoreOpened;
    CERTFILTERCALLBACKDATA callbackData;
    CRYPTUI_SELECTCERTIFICATE_STRUCT CertSelect;

    ZeroMemory(&callbackData, sizeof(callbackData));
    ZeroMemory(&CertSelect, sizeof(CertSelect));

    // custom titles

    if (NULL != hInstance)
    {
        // try to load title from resource
        hr = myLoadRCString(
		    hInstance,
		    idTitle,
		    const_cast<WCHAR **>(&CertSelect.szTitle));
        if (S_OK != hr)
        {
            CSASSERT(NULL == CertSelect.szTitle);
            _PrintError(hr, "myLoadRCString(Title)");
        }
        hr = myLoadRCString(
		    hInstance,
		    idSubTitle,
		    const_cast<WCHAR **>(&CertSelect.szDisplayString));
        if (S_OK != hr)
        {
            CSASSERT(NULL == CertSelect.szDisplayString);
            _PrintError(hr, "myLoadRCString(Title)");
        }
    }

    if (NULL == rghStore)
    {
	cStore = 0;
    }
    cStoreOpened = 0;
    if ((CUCS_SOURCEMASK | CUCS_TYPEMASK) & dwFlags)
    {
        CWaitCursor cwait;

	hr = myOpenCertStores(dwFlags, &cStoreOpened, &rghStoreOpened);
	_PrintIfError(hr, "myOpenCertStores");
    }
    CertSelect.cDisplayStores = cStore + cStoreOpened;
    if (0 == CertSelect.cDisplayStores)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no Cert Store");
    }
    CertSelect.rghDisplayStores = (HCERTSTORE *) LocalAlloc(
				    LMEM_FIXED,
				    CertSelect.cDisplayStores * sizeof(HCERTSTORE));
    if (NULL == CertSelect.rghDisplayStores)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc(CertSelect.rghDisplayStores)");
    }

    if (0 != cStore)
    {
	CopyMemory(
		&CertSelect.rghDisplayStores[0],
		rghStore,
		cStore * sizeof(rghStore[0]));
    }
    if (0 != cStoreOpened)
    {
	CopyMemory(
		&CertSelect.rghDisplayStores[cStore],
		rghStoreOpened,
		cStoreOpened * sizeof(rghStore[0]));
    }

    // temporary store where the callback will store links to found certs
    // so it can check for duplicates

    callbackData.hMemStore = CertOpenStore(
			CERT_STORE_PROV_MEMORY,
			X509_ASN_ENCODING,
			NULL,
			CERT_STORE_CREATE_NEW_FLAG,
			NULL);
    if (NULL == callbackData.hMemStore)
    {
	hr = myHLastError();
	_JumpError(hr, error, "can't create memory store");
    }

    CertSelect.dwSize = sizeof(CertSelect);
    CertSelect.hwndParent = hwndParent;
    //CertSelect.dwFlags = 0;			// single selection
    //CertSelect.dwDontUseColumn = 0;		// display all column
    CertSelect.pFilterCallback = CertificateFilterProc; // assign callback
    //CertSelect.pDisplayCallback = NULL;	// use default cert view dlg
    callbackData.dwFlags = dwFlags;
    callbackData.cpszObjId = cpszObjId;
    callbackData.apszObjId = apszObjId;
    callbackData.pwszCommonName = pwszCommonName;
    if (NULL != pwszCommonName)
    {
	hr = WszToMultiByteInteger(
			    TRUE,
			    pwszCommonName,
			    &callbackData.cbHash,
			    &callbackData.pbHash);
	_PrintIfError2(hr, "WszToMultiByteInteger", hr);

	hr = myMakeSerialBstr(pwszCommonName, &callbackData.strSerialNumber);
	_PrintIfError2(hr, "myMakeSerialBstr", hr);
    }
    callbackData.hr = S_FALSE;
    CertSelect.pvCallbackData = &callbackData;	// pass filter info as data
    //CertSelect.cStores = 0;		// no additional stores for chain verify
    //CertSelect.rghStores = NULL;	// no additional stores for chain verify
    //CertSelect.cPropSheetPages = 0;		// no custom cert view pages
    //CertSelect.rgPropSheetPages = NULL;	// no custom cert view pages
    //CertSelect.hSelectedCertStore = NULL;	// single selection

    if (CUCS_SILENT & dwFlags)
    {
	*ppCert = mySelectCertificate(&CertSelect);
	if (NULL == *ppCert)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "mySelectCertificate");
	}
    }
    else
    {
	*ppCert = CryptUIDlgSelectCertificate(&CertSelect);
    }

    // check for error in selection dialog

    hr = callbackData.hr;
    if (S_FALSE == hr)
    {
	hr = S_OK;
	//hr = CRYPT_E_NOT_FOUND;
    }
    _JumpIfError(hr, error, "CryptUIDlgSelectCertificate");

error:
    if (NULL != rghStoreOpened)
    {
	myCloseCertStores(cStoreOpened, rghStoreOpened);
    }
    if (NULL != callbackData.hMemStore)
    {
        CertCloseStore(callbackData.hMemStore, 0);
    }
    if (NULL != callbackData.strSerialNumber)
    {
	SysFreeString(callbackData.strSerialNumber);
    }
    if (NULL != callbackData.pbHash)
    {
	LocalFree(callbackData.pbHash);
    }
    if (NULL != CertSelect.szTitle)
    {
        LocalFree(const_cast<WCHAR *>(CertSelect.szTitle));
    }
    if (NULL != CertSelect.szDisplayString)
    {
        LocalFree(const_cast<WCHAR *>(CertSelect.szDisplayString));
    }
    if (NULL != CertSelect.rghDisplayStores)
    {
	LocalFree(CertSelect.rghDisplayStores);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\ciexit.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ciexit.cpp
//
// Contents:    Cert Server Exit dispatch support
//
// History:     20-Jan-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_CIEXIT_CPP__


//+------------------------------------------------------------------------
// ICertServerExit dispatch support

// TCHAR const g_wszRegKeyCIExitClsid[] = wszCLASS_CERTSERVEREXIT TEXT("\\Clsid");

//+------------------------------------
// SetContext method:

static OLECHAR *exit_apszSetContext[] = {
    TEXT("SetContext"),
    TEXT("Context"),
};

//+------------------------------------
// GetRequestProperty method:

static OLECHAR *exit_apszGetRequestProp[] = {
    TEXT("GetRequestProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// GetRequestAttribute method:

static OLECHAR *exit_apszGetRequestAttr[] = {
    TEXT("GetRequestAttribute"),
    TEXT("strAttributeName"),
};

//+------------------------------------
// GetCertificateProperty method:

static OLECHAR *exit_apszGetCertificateProp[] = {
    TEXT("GetCertificateProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// GetCertificateExtension method:

static OLECHAR *exit_apszGetCertificateExt[] = {
    TEXT("GetCertificateExtension"),
    TEXT("strExtensionName"),
    TEXT("Type"),
};

//+------------------------------------
// GetCertificateExtensionFlags method:

static OLECHAR *exit_apszGetCertificateExtFlags[] = {
    TEXT("GetCertificateExtensionFlags"),
};

//+------------------------------------
// EnumerateExtensionsSetup method:

static OLECHAR *exit_apszEnumerateExtensionsSetup[] = {
    TEXT("EnumerateExtensionsSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateExtensions method:

static OLECHAR *exit_apszEnumerateExtensions[] = {
    TEXT("EnumerateExtensions"),
};

//+------------------------------------
// EnumerateExtensionsClose method:

static OLECHAR *exit_apszEnumerateExtensionsClose[] = {
    TEXT("EnumerateExtensionsClose"),
};

//+------------------------------------
// EnumerateAttributesSetup method:

static OLECHAR *exit_apszEnumerateAttributesSetup[] = {
    TEXT("EnumerateAttributesSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateAttributes method:

static OLECHAR *exit_apszEnumerateAttributes[] = {
    TEXT("EnumerateAttributes"),
};

//+------------------------------------
// EnumerateAttributesClose method:

static OLECHAR *exit_apszEnumerateAttributesClose[] = {
    TEXT("EnumerateAttributesClose"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtCIExit[] =
{
#define EXIT_SETCONTEXT			0
    DECLARE_DISPATCH_ENTRY(exit_apszSetContext)

#define EXIT_GETREQUESTPROPERTY		1
    DECLARE_DISPATCH_ENTRY(exit_apszGetRequestProp)

#define EXIT_GETREQUESTATTRIBUTE	2
    DECLARE_DISPATCH_ENTRY(exit_apszGetRequestAttr)

#define EXIT_GETCERTIFICATEPROPERTY	3
    DECLARE_DISPATCH_ENTRY(exit_apszGetCertificateProp)

#define EXIT_GETCERTIFICATEEXTENSION	4
    DECLARE_DISPATCH_ENTRY(exit_apszGetCertificateExt)

#define EXIT_GETCERTIFICATEEXTENSIONFLAGS	5
    DECLARE_DISPATCH_ENTRY(exit_apszGetCertificateExtFlags)

#define EXIT_ENUMERATEEXTENSIONSSETUP	6
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateExtensionsSetup)

#define EXIT_ENUMERATEEXTENSIONS	7
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateExtensions)

#define EXIT_ENUMERATEEXTENSIONSCLOSE	8
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateExtensionsClose)

#define EXIT_ENUMERATEATTRIBUTESSETUP	9
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateAttributesSetup)

#define EXIT_ENUMERATEATTRIBUTES	10
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateAttributes)

#define EXIT_ENUMERATEATTRIBUTESCLOSE	11
    DECLARE_DISPATCH_ENTRY(exit_apszEnumerateAttributesClose)
};
#define CEXITDISPATCH	(ARRAYSIZE(g_adtCIExit))


HRESULT
CIExit_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiCIExit)
{
    HRESULT hr;

    hr = DispatchSetup(
		Flags,
                CLSCTX_INPROC_SERVER,
                wszCLASS_CERTSERVEREXIT, //g_wszRegKeyCIExitClsid,
		&CLSID_CCertServerExit,
		&IID_ICertServerExit,
		CEXITDISPATCH,
                g_adtCIExit,
                pdiCIExit);
    _JumpIfError(hr, error, "DispatchSetup");

    pdiCIExit->pDispatchTable = g_adtCIExit;

error:
    return(hr);
}


VOID
CIExit_Release(
    IN OUT DISPATCHINTERFACE *pdiCIExit)
{
    DispatchRelease(pdiCIExit);
}


HRESULT
CIExit_SetContext(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Context)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Context;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_SETCONTEXT,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetContext)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->SetContext(Context);
	_JumpIfError(hr, error, "ICertServerExit::SetContext");
    }

error:
    return(hr);
}


HRESULT
ciexitGetProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN DWORD IExitTable,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    HRESULT hr;
    BSTR bstrPropName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);
    CSASSERT(
	    EXIT_GETCERTIFICATEPROPERTY == IExitTable ||
	    EXIT_GETREQUESTATTRIBUTE == IExitTable ||
	    EXIT_GETREQUESTPROPERTY == IExitTable);

    VariantInit(&varResult);
    *pbstrPropValue = NULL;

    if (!ConvertWszToBstr(&bstrPropName, pwszPropName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (PropertyType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrPropName;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropertyType;

	hr = DispatchInvoke(
			pdiCIExit,
			IExitTable,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrPropValue);
	_JumpIfError(
		hr,
		error,
		EXIT_GETCERTIFICATEPROPERTY == IExitTable?
		    "Invoke(Exit::GetCertificateProperty)" :
		    EXIT_GETREQUESTPROPERTY == IExitTable?
			"Invoke(Exit::GetRequestProperty)" :
			"Invoke(Exit::GetRequestAttribute)");
    }
    else
    {
	if (EXIT_GETCERTIFICATEPROPERTY == IExitTable)
	{
	    hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetCertificateProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else if (EXIT_GETREQUESTPROPERTY == IExitTable)
	{
	    hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetRequestProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else
	{
	    CSASSERT(EXIT_GETREQUESTATTRIBUTE == IExitTable);
	    CSASSERT(PROPTYPE_STRING == PropertyType);
	    hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetRequestAttribute(
							    bstrPropName,
							    &varResult.bstrVal);
	    if (S_OK == hr)
	    {
		varResult.vt = VT_BSTR;
	    }
	}
	_JumpIfError(
		hr,
		error,
		EXIT_GETCERTIFICATEPROPERTY == IExitTable?
		    "ICertServerExit::GetCertificateProperty" :
		    EXIT_GETREQUESTPROPERTY == IExitTable?
			"ICertServerExit::GetRequestProperty" :
			"ICertServerExit::GetRequestAttribute");

	hr = DispatchGetReturnValue(&varResult, RetType, pbstrPropValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrPropName)
    {
	SysFreeString(bstrPropName);
    }
    return(hr);
}


HRESULT
CIExit_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(ciexitGetProperty(
			pdiCIExit,
			EXIT_GETREQUESTPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIExit_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue)
{
    return(ciexitGetProperty(
			pdiCIExit,
			EXIT_GETREQUESTATTRIBUTE,
			pwszPropName,
			PROPTYPE_STRING,
			pbstrPropValue));
}


HRESULT
CIExit_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(ciexitGetProperty(
			pdiCIExit,
			EXIT_GETCERTIFICATEPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIExit_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue)
{
    HRESULT hr;
    BSTR bstrExtensionName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    VariantInit(&varResult);
    *pbstrValue = NULL;

    if (!ConvertWszToBstr(&bstrExtensionName, pwszExtensionName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrExtensionName;

	avar[1].vt = VT_I4;
	avar[1].lVal = Type;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_GETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrValue);
	_JumpIfError(hr, error, "Invoke(Exit::GetCertificateExtension)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetCertificateExtension(
								bstrExtensionName,
								Type,
								&varResult);
	_JumpIfError(hr, error, "ICertServerExit::GetCertificateExtension");

	hr = DispatchGetReturnValue(&varResult, RetType, pbstrValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrExtensionName)
    {
	SysFreeString(bstrExtensionName);
    }
    return(hr);
}


HRESULT
CIExit_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT LONG *pExtFlags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_GETCERTIFICATEEXTENSIONFLAGS,
			0,
			NULL,
			VT_I4,
			pExtFlags);
	_JumpIfError(hr, error, "Invoke(Exit::GetCertificateExtensionFlags)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->GetCertificateExtensionFlags(
								pExtFlags);
	_JumpIfError(hr, error, "ICertServerExit::GetCertificateExtensionFlags");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEEXTENSIONSSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsSetup)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateExtensionsSetup(
							    Flags);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateExtensionsSetup");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEEXTENSIONS,
			0,
			NULL,
			VT_BSTR,
			pstrExtensionName);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensions)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateExtensions(
							    pstrExtensionName);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateExtensions");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIExit)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEEXTENSIONSCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsClose)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateExtensionsClose();
	_JumpIfError(hr, error, "ICertServerExit::EnumerateExtensionsClose");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIExit,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEATTRIBUTESSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesSetup)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateAttributesSetup(
							    Flags);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateAttributesSetup");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIExit,
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEATTRIBUTES,
			0,
			NULL,
			VT_BSTR,
			pstrAttributeName);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributes)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateAttributes(
							    pstrAttributeName);
	_JumpIfError(hr, error, "ICertServerExit::EnumerateAttributes");
    }

error:
    return(hr);
}


HRESULT
CIExit_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIExit)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIExit && NULL != pdiCIExit->pDispatchTable);

    if (NULL != pdiCIExit->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIExit,
			EXIT_ENUMERATEATTRIBUTESCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesClose)");
    }
    else
    {
	hr = ((ICertServerExit *) pdiCIExit->pUnknown)->EnumerateAttributesClose();
	_JumpIfError(hr, error, "ICertServerExit::EnumerateAttributesClose");
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\certsd.cpp ===
//+--------------------------------------------------------------------------
// File:        certsd.cpp
// Contents:    CA's security descriptor class implementation
//---------------------------------------------------------------------------
#include <pch.cpp>
#pragma hdrstop
#include "certsd.h"
#include "certacl.h"

#define __dwFILE__	__dwFILE_CERTLIB_CERTSD_CPP__

using namespace CertSrv;

HRESULT
CProtectedSecurityDescriptor::Init(LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;
    CSASSERT(!m_fInitialized);
    
    __try
    {
	InitializeCriticalSection(&m_csWrite);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "InitializeCriticalSection");

    m_hevtNoReaders = CreateEvent(
        NULL,
        TRUE,
        TRUE,
        NULL);
    if(NULL==m_hevtNoReaders)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }

    m_pcwszSanitizedName = pwszSanitizedName;    

error:
    return hr;
}

HRESULT
CProtectedSecurityDescriptor::SetSD(const PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    SECURITY_DESCRIPTOR_CONTROL SDCtrl;
    DWORD dwRev;

    CSASSERT(NULL==m_pSD);

    if(pSD)
    {
        if(!IsValidSecurityDescriptor(pSD))
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "IsValidSecurityDescriptor");
        }

        if(!GetSecurityDescriptorControl(pSD, &SDCtrl, &dwRev))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetSecurityDescriptorControl");
        }

        // always keep the SD in self relative form
        if(!(SDCtrl&SE_SELF_RELATIVE))
        {
            if(!MakeSelfRelativeSD(pSD, NULL, &dwSize))
            {
                m_pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
                if(NULL == m_pSD)
                {
                    hr = E_OUTOFMEMORY;
                    _JumpError(hr, error, "LocalAlloc");
                }

                if(!MakeSelfRelativeSD(pSD, m_pSD, &dwSize))
                {
                    hr = myHLastError();
                    _JumpError(hr, error, "LocalAlloc");
                }
            }
        }
        else
        {
            dwSize = GetSecurityDescriptorLength(pSD);

            m_pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED, dwSize);
            if(NULL == m_pSD)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc");
            }
            CopyMemory(m_pSD, pSD, dwSize);
        }
    }

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Initialize(LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;

    CSASSERT(!m_fInitialized);

    hr = Init(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");

    m_fInitialized = true;

    hr = Load();
    if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
        hr = S_OK;
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Load");

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Initialize(
    PSECURITY_DESCRIPTOR pSD, 
    LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;

    CSASSERT(!m_fInitialized);
    
    hr = Init(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");
    
    hr = SetSD(pSD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::SetSD");

    m_fInitialized = true;

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::InitializeFromTemplate(
    LPCWSTR pcwszTemplate, 
    LPCWSTR pwszSanitizedName)
{
    HRESULT hr = S_OK;

    CSASSERT(!m_fInitialized);
    
    hr = Init(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");

    hr = myGetSDFromTemplate(
            pcwszTemplate,
            NULL,
            &m_pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");
    
    m_fInitialized = true;

error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Load()
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSD = NULL;

    CSASSERT(m_fInitialized);

    hr = myGetCertRegBinaryValue(m_pcwszSanitizedName,
                                 NULL,
                                 NULL,
                                 GetPersistRegistryVal(),
                                 (BYTE**)&pSD);
    if(S_OK!=hr)
    {
        return hr;
    }

    if(!IsValidSecurityDescriptor(pSD))
    {
       LocalFree(pSD);
       return E_UNEXPECTED;
    }

    if(m_pSD)
    {
        LocalFree(m_pSD);
    }

    m_pSD = pSD;

    return S_OK;
}

HRESULT 
CProtectedSecurityDescriptor::Save()
{
    HRESULT hr = S_OK;
    DWORD cbLength = GetSecurityDescriptorLength(m_pSD);

    CSASSERT(m_fInitialized);

	hr = mySetCertRegValue(
			NULL,
			m_pcwszSanitizedName,
			NULL,
			NULL,
			GetPersistRegistryVal(),
			REG_BINARY,
			(BYTE const *) m_pSD,
			cbLength,
			FALSE);
	_JumpIfError(hr, error, "mySetCertRegValue");
    
error:
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Delete()
{
    HRESULT hr = S_OK;

    CSASSERT(m_fInitialized);

	hr = myDeleteCertRegValue(
			m_pcwszSanitizedName,
			NULL,
			NULL,
			GetPersistRegistryVal());
	_JumpIfError(hr, error, "myDeleteCertRegValue");
    
error:
    return hr;
}

HRESULT
CProtectedSecurityDescriptor::Set(const PSECURITY_DESCRIPTOR pSD)
{
    HRESULT hr = S_OK;
    DWORD dwResult;
    CSASSERT(m_fInitialized);
    if(!IsValidSecurityDescriptor(pSD))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "IsValidSecurityDescriptor");
    }

    __try
    {
        EnterCriticalSection(&m_csWrite);
        dwResult = WaitForSingleObject(m_hevtNoReaders, INFINITE);
        if(WAIT_OBJECT_0 != dwResult)
        {
            hr = myHLastError();
        }
        else
        {
            if(m_pSD)
            {
                LocalFree(m_pSD);
                m_pSD = NULL;
            }
            hr = SetSD(pSD);
        }
        LeaveCriticalSection(&m_csWrite);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
error:
    return hr;
}

HRESULT
CProtectedSecurityDescriptor::LockGet(PSECURITY_DESCRIPTOR *ppSD)
{
    HRESULT hr = S_OK;
    CSASSERT(m_fInitialized);
    __try
    {
        EnterCriticalSection(&m_csWrite);
        InterlockedIncrement(&m_cReaders);
        if(!ResetEvent(m_hevtNoReaders))
        {
            hr = myHLastError();
        }
        LeaveCriticalSection(&m_csWrite);
        *ppSD = m_pSD;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return hr;
}

HRESULT 
CProtectedSecurityDescriptor::Unlock()
{
    HRESULT hr = S_OK;
    CSASSERT(m_fInitialized);
    if(!InterlockedDecrement(&m_cReaders))
    {
        if(!SetEvent(m_hevtNoReaders))
        {
            hr = myHLastError();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\check7f.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        check7f.cpp
//
// Contents:    Cert Server test for ASN-encoded 7f length
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include <assert.h>

#include "csdisp.h"

typedef struct _ASNTABLE {
    WORD State;
    WORD Flags;
    WCHAR const *pwszElement;
} ASNTABLE;


#define BOOLEAN_TAG             0x01
#define INTEGER_TAG             0x02
#define BIT_STRING_TAG          0x03
#define OCTET_STRING_TAG        0x04
#define NULL_TAG                0x05
#define OBJECT_ID_TAG           0x06
#define SET_OF_TAG              0x11
#define PRINTABLE_STRING_TAG    0x13
#define TELETEX_STRING_TAG      0x14
#define CHAR_STRING_TAG         0x16
#define UTCTIME_TAG             0x17
#define SEQUENCE_TAG            0x30
#define RDN_TAG           	0x31
#define PRIMITIVE_TAG           0x80
#define ATTRIBUTE_TAG           0xa0

#define BEG_REPEAT1		0x00000100	// begin repeat section
#define BEG_REPEAT2		0x00000200	// begin nested repeat section
#define END_REPEAT1		0x00000400	// 'or' in back step count
#define END_REPEAT2		0x00000800	// 'or' in back step count
#define OPTIONAL_FIELD		0x00001000	// begin optional field
#define ANY_TAG			0x00002000	// match any tag

const ASNTABLE asnCert[] = {
 { CHECK7F_OTHER, SEQUENCE_TAG,			L"Certificate" },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L".ToBeSigned" },

 { CHECK7F_OTHER, ATTRIBUTE_TAG | OPTIONAL_FIELD, L"..Version" },
 { CHECK7F_OTHER, INTEGER_TAG ,			L"...Version.Integer" },

 { CHECK7F_OTHER, INTEGER_TAG,			L"..SerialNumber" },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L"..SignatureAlgorithm" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L"...SignatureAlgorithm.ObjectId" },
 { CHECK7F_OTHER, ANY_TAG | OPTIONAL_FIELD,	L"...SignatureAlgorithm.Parameters" },

 { CHECK7F_ISSUER, SEQUENCE_TAG,		L"..Issuer Name" },

 { CHECK7F_ISSUER_RDN,
     BEG_REPEAT1 | RDN_TAG | OPTIONAL_FIELD,	L"...Issuer.RDN" },

 { CHECK7F_ISSUER_RDN_ATTRIBUTE,
		BEG_REPEAT2 | SEQUENCE_TAG,	L"....Issuer.RDN.Attribute" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L".....Issuer.RDN.Attribute.ObjectId" },
 { CHECK7F_ISSUER_RDN_STRING, ANY_TAG,		L".....Issuer.RDN.Attribute.Value" },
 { 0, END_REPEAT2 | 3,				L"...." },
 { 0, END_REPEAT1 | 5,				L"..." },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L"..Dates" },
 { CHECK7F_OTHER, UTCTIME_TAG,			L"...Dates.NotBefore" },
 { CHECK7F_OTHER, UTCTIME_TAG,			L"...Dates.NotAfter" },

 { CHECK7F_SUBJECT, SEQUENCE_TAG,		L"..Subject Name" },
 { CHECK7F_SUBJECT_RDN,
     BEG_REPEAT1 | RDN_TAG | OPTIONAL_FIELD,	L"...Subject.RDN" },
 { CHECK7F_SUBJECT_RDN_ATTRIBUTE,
		BEG_REPEAT2 | SEQUENCE_TAG,	L"....Subject.RDN.Attribute" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L".....Subject.RDN.Attribute.ObjectId" },
 { CHECK7F_SUBJECT_RDN_STRING, ANY_TAG,		L".....Subject.RDN.Attribute.Value" },
 { 0, END_REPEAT2 | 3,				L"...." },
 { 0, END_REPEAT1 | 5,				L"..." },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L"..PublicKey" },
 { CHECK7F_OTHER, SEQUENCE_TAG,			L"...PublicKey.Algorithm" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L"....PublicKey.Algorithm.ObjectId" },
 { CHECK7F_OTHER, ANY_TAG | OPTIONAL_FIELD,	L"....PublicKey.Algorithm.Parameters" },
 { CHECK7F_OTHER, BIT_STRING_TAG,		L"...PublicKey.Key" },

 { CHECK7F_OTHER,
	PRIMITIVE_TAG | 1 | OPTIONAL_FIELD,	L"..IssuerUniqueId" },
 { CHECK7F_OTHER,
	PRIMITIVE_TAG | 2 | OPTIONAL_FIELD,	L"..SubjectUniqueId" },

 { CHECK7F_EXTENSIONS,
	ATTRIBUTE_TAG | 3 | OPTIONAL_FIELD,	L"..Extensions" },
 { CHECK7F_EXTENSION_ARRAY, SEQUENCE_TAG,	L"...Extensions.Array" },
 { CHECK7F_EXTENSION,
		 BEG_REPEAT1 | SEQUENCE_TAG,	L"....Extensions.Array.Extension" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L".....Extensions.Array.Extension.ObjectId" },
 { CHECK7F_OTHER, BOOLEAN_TAG | OPTIONAL_FIELD,	L".....Extensions.Array.Extension.Critical" },
 { CHECK7F_EXTENSION_VALUE, OCTET_STRING_TAG,	L".....Extensions.Array.Extension.Value" },
 //{ CHECK7F_EXTENSION_VALUE_RAW, ANY_TAG,	L"......Extensions.Array.Extension.Value.Bits" },
 { 0, END_REPEAT1 | 4,				L"...." },

 { CHECK7F_OTHER, SEQUENCE_TAG,			L".SignatureAlogorithm" },
 { CHECK7F_OTHER, OBJECT_ID_TAG,		L"..SignatureAlgorithm.ObjectId" },
 { CHECK7F_OTHER, ANY_TAG | OPTIONAL_FIELD,	L"..SignatureAlgorithm.Parameters" },

 { CHECK7F_OTHER, BIT_STRING_TAG,		L".Signature" },

 { 0, 0,					NULL }
};

#define cbOLDCERTENROLLCHOKESLENGTH	0x7f


// DecodeLength decodes an ASN1 encoded length field.  The pbEncoded parameter
// is the encoded length.  pdwLen is used to return the length.  The function
// returns a -1 if it fails and otherwise returns the number of total bytes in
// the encoded length.

long
DecodeLength(
    BOOL DBGCODE(fVerbose),
    DWORD *pdwLen,
    DWORD DBGCODE(iLevel),
    BYTE const *DBGCODE(pbBase),
    BYTE const *pbEncoded,
    DWORD cbEncoded,
    WCHAR const *DBGCODE(pwsz))
{
    long    index = 0;
    BYTE    count;

    assert(NULL != pdwLen);
    assert(NULL != pbEncoded);

    if (1 > cbEncoded)
    {
        DBGPRINT((DBG_SS_CERTLIB, "cbEncoded overflow %d\n", cbEncoded));
        return(-1);
    }

    // determine the length of the length field

    count = pbEncoded[0];
    if (0x80 < count)
    {
        // If there is more than one byte in the length field, then the lower
	// seven bits tells us the number of bytes.

        count &= 0x7f;

        // This function only allows the length field to be 2 bytes.  If the
	// field is longer, then the function fails.

        if (2 < count)
        {
            DBGPRINT((DBG_SS_CERTLIB, "Length field reported to be over 2 bytes\n"));
            return(-1);
        }

        if (count > cbEncoded)
	{
	    DBGPRINT((DBG_SS_CERTLIB, "cbEncoded overflow %d\n", cbEncoded));
	    return(-1);
	}

        *pdwLen = 0;

        // go through the bytes of the length field

        for (index = 1; index <= count; index++)
        {
            *pdwLen = (*pdwLen << 8) + pbEncoded[index];
        }
    }
    else	// the length field is just one byte long
    {
        *pdwLen = pbEncoded[0];
        index = 1;
    }

    // return how many bytes there were in the length field.

#if DBG_CERTSRV
    if (fVerbose)
    {
	CONSOLEPRINT7((
		    DBG_SS_CERTLIB,
		    "asn %u:@%x: %02x, len %x, cbEncoded %x, end @%x, %ws\n",
		    iLevel,
		    &pbEncoded[-1] - pbBase,
		    pbEncoded[-1],
		    *pdwLen,
		    cbEncoded + 1,
		    &pbEncoded[-1] - pbBase + cbEncoded + 1,
		    pwsz));
    }
#endif // DBG_CERTSRV
    return(index);
}


WCHAR const *
GetLevel(
    OPTIONAL IN WCHAR const *pwszField,
    OUT DWORD *piLevel)
{
    DWORD iLevel = 0;

    iLevel = 0;
    if (NULL != pwszField)
    {
	while ('.' == *pwszField)
	{
	    iLevel++;
	    pwszField++;
	}
    }
    *piLevel = iLevel;
    return(pwszField);
}


BOOL
RestoreLevel(
    IN DWORD *acbLevel,
    IN DWORD iLevelNext,
    IN DWORD *piLevel,
    IN BOOL fVerbose)
{
    BOOL fOk = FALSE;
    DWORD iLevel;
    DWORD i = *piLevel;

#if DBG_CERTSRV
    if (1 < fVerbose)
    {
	CONSOLEPRINT2((
		    DBG_SS_CERTLIBI,
		    "RestoreLevel(%x, %x)\n",
		    iLevelNext,
		    *piLevel));
    }
#endif

    iLevel = *piLevel;

    while (0 < iLevel && 0 == acbLevel[iLevel] && iLevelNext < iLevel)
    {
	iLevel--;
	if (1 < fVerbose)
	{
	    CONSOLEPRINT2((
		    DBG_SS_CERTLIBI, 
		    "Restoring length(%u) ==> %x\n",
		    iLevel,
		    acbLevel[iLevel]));
	}
    }
    if (iLevelNext < iLevel)
    {
	CONSOLEPRINT2((
		    MAXDWORD, 
		    "BAD RESTORED LENGTH[%u]: 0 < %x\n",
		    iLevel,
		    acbLevel[iLevel]));
	goto error;
    }
    *piLevel = iLevel;
    fOk = TRUE;

error:
    if (1 < fVerbose)
    {
	CONSOLEPRINT4((
		    DBG_SS_CERTLIBI, 
		    "RestoreLevel(%x, %x --> %x) --> %x\n",
		    iLevelNext,
		    i,
		    *piLevel,
		    fOk));
    }
    return(fOk);
}


VOID
ReturnString(
    IN WCHAR const *pwszReturn,
    OPTIONAL IN OUT DWORD *pcwcBuf,
    OPTIONAL OUT WCHAR *pwcBuf)
{
    DWORD cwcNeeded = wcslen(pwszReturn) + 1;
    DWORD cwcBuf;

    if (NULL != pcwcBuf)
    {
	cwcBuf = *pcwcBuf;
	if (NULL != pwcBuf && 0 < cwcBuf)
	{
	    CopyMemory(pwcBuf, pwszReturn, sizeof(WCHAR) * min(cwcBuf, cwcNeeded));
	    pwcBuf[cwcBuf - 1] = L'\0';
	}
	*pcwcBuf = cwcNeeded;
    }
}


#define MATCHTAG(b, flags)  ((ANY_TAG & (flags)) || (b) == (BYTE) (flags))


HRESULT
myCheck7f(
    IN const BYTE *pbCert,
    IN DWORD cbCert,
    IN BOOL fVerbose,
    OUT DWORD *pState,
    OPTIONAL OUT DWORD *pIndex1,
    OPTIONAL OUT DWORD *pIndex2,
    OPTIONAL IN OUT DWORD *pcwcField,
    OPTIONAL OUT WCHAR *pwszField,
    OPTIONAL IN OUT DWORD *pcwcObjectId,
    OPTIONAL OUT WCHAR *pwszObjectId,
    OPTIONAL OUT WCHAR const **ppwszObjectIdDescription)
{
    ASNTABLE const *pasn;
    HRESULT hr = S_OK;
    BOOL fSaveCert = TRUE;
    BYTE const *pb = pbCert;
    long index;
    DWORD length;
    DWORD acbLevel[20];
    DWORD iLevel;
    DWORD iLevelNext;
    WCHAR const *pwszfieldname;
    DWORD cbdiff;
    DWORD aiElement[20];
    DWORD aiElement7f[2];
    DWORD iElementLevel;
    DWORD State;
    BOOL fSetField = FALSE;
    BOOL fSetObjectId = FALSE;
    CERT_INFO *pCertInfo = NULL;
    DWORD cbCertInfo;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    WCHAR *pwszObjId = NULL;

    State = CHECK7F_NONE;
    if (NULL != ppwszObjectIdDescription)
    {
	*ppwszObjectIdDescription = NULL;
    }

#if DBG_CERTSRV
    if (!fVerbose && DbgIsSSActive(DBG_SS_CERTLIBI))
    {
	fVerbose = TRUE;
    }
#endif // DBG_CERTSRV
    if (fVerbose)
    {
	CONSOLEPRINT1((MAXDWORD, "myCheck7f: %x bytes\n", cbCert));
    }
    pasn = asnCert;
    iLevel = 0;
    ZeroMemory(aiElement7f, sizeof(aiElement7f));
    acbLevel[iLevel] = cbCert;
    iElementLevel = 0;
    while (0 != iLevel || (0 != acbLevel[iLevel] && NULL != pasn->pwszElement))
    {
	DWORD i;

	if (1 < fVerbose)
	{
	    if (2 < fVerbose)
	    {
		CONSOLEPRINT3((
			    DBG_SS_CERTLIBI, 
			    "ASN:0: *pb=%x %u: %ws\n",
			    *pb,
			    pasn - asnCert,
			    pasn->pwszElement));
	    }
	    CONSOLEPRINT0((MAXDWORD, "LENGTHS:0:"));
	    for (i = 0; i <= iLevel; i++)
	    {
		CONSOLEPRINT1((MAXDWORD, " %3x", acbLevel[i]));
	    }
	    CONSOLEPRINT0((MAXDWORD, "\n"));
	}
	while (OPTIONAL_FIELD & pasn->Flags)
	{
	    DWORD f;

	    if (0 < acbLevel[iLevel] && MATCHTAG(*pb, pasn->Flags))
	    {
#if DBG_CERTSRV
		if (fVerbose)
		{
		    CONSOLEPRINT2((
			    DBG_SS_CERTLIB,
			    "Optional field MATCH cb=%x %ws\n",
			    acbLevel[iLevel],
			    pasn->pwszElement));
		}
#endif // DBG_CERTSRV
		break;
	    }

#if DBG_CERTSRV
	    if (fVerbose)
	    {
		CONSOLEPRINT2((
			DBG_SS_CERTLIB,
			"Optional field NO match cb=%x %ws\n",
			acbLevel[iLevel],
			pasn->pwszElement));
	    }
#endif // DBG_CERTSRV

	    f = 0;
	    switch ((BEG_REPEAT1 | BEG_REPEAT2) & pasn->Flags)
	    {
		case BEG_REPEAT1:
		    f = END_REPEAT1;
		    break;

		case BEG_REPEAT2:
		    f = END_REPEAT2;
		    break;
	    }
	    if (f)
	    {
		while (!(f & pasn->Flags))
		{
#if DBG_CERTSRV
		    if (fVerbose)
		    {
			CONSOLEPRINT2((
				DBG_SS_CERTLIB,
				"Skipping[%x] %ws\n",
				f,
				pasn->pwszElement));
		    }
#endif // DBG_CERTSRV
		    pasn++;
		}
	    }
	    else
	    {
		DWORD iLevelCurrent;
		
		GetLevel(pasn->pwszElement, &iLevelCurrent);
		for (;;)
		{
		    GetLevel(pasn[1].pwszElement, &iLevelNext);
		    if (iLevelNext <= iLevelCurrent)
		    {
			break;
		    }
#if DBG_CERTSRV
		    if (fVerbose)
		    {
			CONSOLEPRINT1((
				DBG_SS_CERTLIB,
				"Skipping nested optional field %ws\n",
				pasn->pwszElement));
		    }
#endif // DBG_CERTSRV
		    pasn++;
		}
	    }
#if DBG_CERTSRV
	    if (fVerbose)
	    {
		CONSOLEPRINT1((
			DBG_SS_CERTLIB,
			"Skipping optional field %ws\n",
			pasn->pwszElement));
	    }
#endif // DBG_CERTSRV
	    pasn++;

	    if (0 == acbLevel[iLevel])
	    {
		GetLevel(pasn->pwszElement, &iLevelNext);
		if (iLevelNext < iLevel)
		{
		    iLevel = iLevelNext;
		}
	    }
	}
	while ((END_REPEAT1 | END_REPEAT2) & pasn->Flags)
	{
	    // Make sure only one END_REPEAT bit is on.
	    assert(
		(END_REPEAT1 | END_REPEAT2) !=
		((END_REPEAT1 | END_REPEAT2) & pasn->Flags));

	    pwszfieldname = GetLevel(pasn->pwszElement, &iLevelNext);
	    if (!RestoreLevel(acbLevel, iLevelNext, &iLevel, fVerbose))
	    {
		goto error;
	    }
	    i = (BYTE) pasn->Flags;
	    assert((DWORD) (pasn - asnCert) > i);
	    if (0 != acbLevel[iLevel])
	    {
		if (!MATCHTAG(*pb, (pasn - i)->Flags))
		{
		    CONSOLEPRINT5((
			MAXDWORD, 
			"Check7f: Unexpected tag at %x: at level %u: (%x/%x) %ws\n",
			cbCert - acbLevel[0],
			iLevel,
			*pb,
			pasn->Flags,
			pasn->pwszElement));
		    goto error;
		}

		// Some data remain at this level, and the type tag matches
		// the expected repeat tag, loop back to the start of the
		// section to be repeated.

		pasn -= i;

		// Make sure only one BEG_REPEAT bit is on.
		assert(
		    (BEG_REPEAT1 | BEG_REPEAT2) !=
		    ((BEG_REPEAT1 | BEG_REPEAT2) & pasn->Flags));

		// Make sure the BEG_REPEAT bit in the begin record matches
		// the END_REPEAT bit in the end record.
		assert(
		    ((BEG_REPEAT1 & pasn->Flags) &&
		     (END_REPEAT1 & pasn[i].Flags)) ||
		    ((BEG_REPEAT2 & pasn->Flags) &&
		     (END_REPEAT2 & pasn[i].Flags)));
	    }
	    else
	    {
		pasn++;
		iElementLevel--;
	    }
	}
	if (2 < fVerbose)
	{
	    CONSOLEPRINT3((
			DBG_SS_CERTLIBI, 
			"ASN:1: *pb=%x %u: %ws\n",
			*pb,
			pasn - asnCert,
			pasn->pwszElement));
	}
	if ((BEG_REPEAT1 | BEG_REPEAT2) & pasn->Flags)
	{
	    if ((BEG_REPEAT1 & pasn->Flags) && 0 == iElementLevel ||
		(BEG_REPEAT2 & pasn->Flags) && 1 == iElementLevel)
	    {
		iElementLevel++;
		aiElement[iElementLevel] = 0;
	    }
	    aiElement[iElementLevel]++;
	}

	pwszfieldname = GetLevel(pasn->pwszElement, &iLevelNext);
	if (!RestoreLevel(acbLevel, iLevelNext, &iLevel, fVerbose))
	{
	    goto error;
	}

	if (1 < fVerbose)
	{
	    CONSOLEPRINT0((MAXDWORD, "LENGTHS:1:"));
	    for (i = 0; i <= iLevel; i++)
	    {
		CONSOLEPRINT1((MAXDWORD, " %3x", acbLevel[i]));
	    }
	    CONSOLEPRINT0((MAXDWORD, "\n"));
	}
	if (0 == iLevel && 0 == acbLevel[0])
	{
	    break;		// all done!
	}
	if (!MATCHTAG(*pb, pasn->Flags))
	{
	    CONSOLEPRINT5((
		MAXDWORD, 
		"Check7f: Unexpected tag at %x: at level %u: (%x/%x) %ws\n",
		cbCert - acbLevel[0],
		iLevel,
		*pb,
		pasn->Flags,
		pasn->pwszElement));
	    goto error;
	}

	GetLevel(pasn[1].pwszElement, &iLevelNext);
	index = DecodeLength(
			fVerbose,
			&length,
			iLevel,
			pbCert,
			&pb[1],
			acbLevel[iLevel] - 1,
			pasn->pwszElement);

	if (fVerbose)
	{
	    DWORD ccol;
	    char achdbg[128];
	    char *pchdbg;
	    //char achbuf[10];

	    pchdbg = achdbg;
	    pchdbg += sprintf(pchdbg, "%04x:", pb - pbCert);

	    for (i = 0; i <= iLevel; i++)
	    {
		pchdbg += sprintf(pchdbg, " %3x", acbLevel[i]);
	    }
	    pchdbg += sprintf(pchdbg, " (%x)", length);
        
	    ccol = SAFE_SUBTRACT_POINTERS(pchdbg, achdbg);
	    if (ccol > 34)
	    {
		ccol = 34;
	    }
	    pchdbg += sprintf(pchdbg, " %*hs -- ", 34 - ccol, "");

	    assert(2 >= iElementLevel);
	    if (1 == iElementLevel)
	    {
		pchdbg += sprintf(pchdbg, "[%u]:", aiElement[1] - 1);
	    }
	    else if (2 == iElementLevel)
	    {
		pchdbg += sprintf(
				pchdbg, 
				"[%u,%u]:",
				aiElement[1] - 1,
				aiElement[2] - 1);
	    }
	    CONSOLEPRINT2((DBG_SS_CERTLIBI, "%hs%ws\n", achdbg, pwszfieldname));
	}
	if (length == cbOLDCERTENROLLCHOKESLENGTH)
	{
	    CONSOLEPRINT2((
			MAXDWORD, 
			"Check7f: Length of %ws is %u bytes\n",
			pwszfieldname,
			length));
	    if (CHECK7F_NONE == State)
	    {
		ReturnString(pwszfieldname, pcwcField, pwszField);
		if (1 <= iElementLevel)
		{
		    aiElement7f[0] = aiElement[1];
		}
		if (2 <= iElementLevel)
		{
		    aiElement7f[1] = aiElement[2];
		}
		State = pasn->State;
		fSetField = TRUE;
	    }
	}

	if (1 < fVerbose)
	{
	    CONSOLEPRINT6((
			DBG_SS_CERTLIBI, 
			"index=%x len=%x level=%x->%x acb[%x]=%x\n",
			index,
			length,
			iLevel,
			iLevelNext,
			iLevel,
			acbLevel[iLevel]));
	}
	if (0 > index || index + length > acbLevel[iLevel])
	{
	    CONSOLEPRINT2((
			MAXDWORD,
			"Check7f: BAD LENGTH: i=%x l=%x\n",
			index,
			length));
	    goto error;
	}

	cbdiff = index + 1;
	if (iLevelNext > iLevel)
	{
	    assert(iLevel + 1 == iLevelNext);
	}
	else
	{
	    cbdiff += length;
	}
	for (i = 0; i <= iLevel; i++)
	{
	    if (acbLevel[i] < cbdiff)
	    {
		CONSOLEPRINT3((
			    MAXDWORD, 
			    "Check7f: BAD NESTED LENGTH[%u]: %x < %x\n",
			    i,
			    acbLevel[i],
			    cbdiff));
		goto error;
	    }
	    acbLevel[i] -= cbdiff;
	}

	if (iLevelNext > iLevel)
	{
	    iLevel++;
	    if (1 < fVerbose)
	    {
		CONSOLEPRINT2((
			    DBG_SS_CERTLIBI,
			    "Saving length(%u) <== %x\n",
			    iLevel,
			    length));
	    }
	    acbLevel[iLevel] = length;
	}
	pb += cbdiff;
	pasn++;
    }
    *pIndex1 = 0;
    if (0 != iLevel || 0 != acbLevel[iLevel] || NULL != pasn->pwszElement)
    {
	CONSOLEPRINT3((
		    MAXDWORD, 
		    "Check7f: Mismatch: %x bytes left at: %x: %ws\n",
		    acbLevel[iLevel],
		    cbCert - acbLevel[0],
		    pasn->pwszElement));
    }
    else if (!fSetField)
    {
	fSaveCert = FALSE;
    }
    if (fSetField && NULL != pcwcObjectId)
    {
	char const *pszObjId;
	CERT_NAME_BLOB const *pNameBlob;

	// Decode certificate

	cbCertInfo = 0;
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_CERT_TO_BE_SIGNED,
			pbCert,
			cbCert,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pCertInfo,
			&cbCertInfo))
	{
	    hr = GetLastError();
	    goto error;
	}
	pszObjId = NULL;
	pNameBlob = NULL;
	switch (State)
	{
	    case CHECK7F_ISSUER_RDN:
	    case CHECK7F_ISSUER_RDN_ATTRIBUTE:
	    case CHECK7F_ISSUER_RDN_STRING:
		pNameBlob = &pCertInfo->Issuer;
		break;

	    case CHECK7F_SUBJECT_RDN:
	    case CHECK7F_SUBJECT_RDN_ATTRIBUTE:
	    case CHECK7F_SUBJECT_RDN_STRING:
		pNameBlob = &pCertInfo->Subject;
		break;

	    case CHECK7F_EXTENSION:
	    case CHECK7F_EXTENSION_VALUE:
	    case CHECK7F_EXTENSION_VALUE_RAW:
		if (0 != aiElement7f[0] &&
		    aiElement7f[0] <= pCertInfo->cExtension)
		{
		    pszObjId =
			pCertInfo->rgExtension[aiElement7f[0] - 1].pszObjId;
		}
		break;

	    default:
		break;
	}
	if (NULL != pNameBlob)
	{
	    if (!myDecodeName(
			X509_ASN_ENCODING,
			X509_UNICODE_NAME,
			pNameBlob->pbData,
			pNameBlob->cbData,
			CERTLIB_USE_LOCALALLOC,
			&pNameInfo,
			&cbNameInfo))
	    {
		hr = GetLastError();
		goto error;
	    }
	    if (0 != aiElement7f[0] && aiElement7f[0] <= pNameInfo->cRDN)
	    {
		CERT_RDN *pRDN;

		pRDN = &pNameInfo->rgRDN[aiElement7f[0] - 1];

		if (0 != aiElement7f[1] && aiElement7f[1] <= pRDN->cRDNAttr)
		{
		    pszObjId = pRDN->rgRDNAttr[aiElement7f[1] - 1].pszObjId;
		}
	    }
	}
	if (NULL != pszObjId)
	{
	    if (!ConvertSzToWsz(&pwszObjId, pszObjId, -1))
	    {
		hr = E_OUTOFMEMORY;
		goto error;
	    }
	    ReturnString(pwszObjId, pcwcObjectId, pwszObjectId);
	    fSetObjectId = TRUE;
	    if (NULL != ppwszObjectIdDescription)
	    {
		WCHAR const *pwszDesc;

		pwszDesc = myGetOIDNameA(pszObjId);
		if (NULL != pwszDesc && L'\0' != *pwszDesc)
		{
		    *ppwszObjectIdDescription = pwszDesc;
		}
	    }
	}
    }

error:
    if (fSaveCert)
    {
	EncodeToFileW(
		fSetField? L"c:\\7flen.crt" : L"c:\\7fasn.crt",
		pbCert,
		cbCert,
		DECF_FORCEOVERWRITE | CRYPT_STRING_BINARY);
    }
    if (NULL != pCertInfo)
    {
	LocalFree(pCertInfo);
    }
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    if (NULL != pwszObjId)
    {
	LocalFree(pwszObjId);
    }

    *pState = State;
    if (NULL != pIndex1)
    {
	*pIndex1 = aiElement7f[0];
    }
    if (NULL != pIndex2)
    {
	*pIndex2 = aiElement7f[1];
    }
    if (!fSetField && NULL != pcwcField)
    {
	if (NULL != pwszField && 0 < *pcwcField)
	{
	    pwszField[0] = L'\0';
	}
	*pcwcField = 0;
    }
    if (!fSetObjectId && NULL != pcwcObjectId)
    {
	if (NULL != pwszObjectId && 0 < *pcwcObjectId)
	{
	    pwszObjectId[0] = L'\0';
	}
	*pcwcObjectId = 0;
    }
    if (fVerbose)
    {
	CONSOLEPRINT1((MAXDWORD, "myCheck7f: --> %x\n", hr));
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\cnfgstg.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    CConfigStorage implements read/write to CA configuration data 
//              currently stored under HKLM\System\CCS\Services\Certsvc\
//              Configuration
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <config.h>

#define __dwFILE__	__dwFILE_CERTLIB_CNFGSTG_CPP__


using namespace CertSrv;

HRESULT CConfigStorage::InitMachine(LPCWSTR pcwszMachine)
{
    m_pwszMachine = new WCHAR[wcslen(pcwszMachine)+3];
    if(!m_pwszMachine)
    {
        return E_OUTOFMEMORY;
    }

    m_pwszMachine[0] = L'\0';

    if(pcwszMachine[0]!=L'\\' &&
       pcwszMachine[1]!=L'\\')
    {
        wcscpy(m_pwszMachine, L"\\\\");
    }
    wcscat(m_pwszMachine, pcwszMachine);
    return S_OK;
}

CConfigStorage::~CConfigStorage()
{
    if(m_hRemoteHKLM)
        RegCloseKey(m_hRemoteHKLM);
    if(m_hRootConfigKey)
        RegCloseKey(m_hRootConfigKey);
    if(m_hCAKey)
        RegCloseKey(m_hCAKey);
    if(m_pwszMachine)
        delete[] m_pwszMachine;
}


// Retrieve a CA configuration value. If no authority name is specified, the
// node path must be NULL and value is queried from the Configuration root.
// If an authority name is passed in, the value is retrieved from the authority
// node; if a node path is passed in, it is used relative to the authority node
// to read the value.

// For example, to read Configuration\DBDirectory, call:
// 
//      GetEntry(NULL, NULL, L"DBDirectory", &var)
//
// To read Configuration\MyCA\CAServerName, call:
//
//      GetEntry(L"MyCA", NULL, L"CAServerName", &var)
//
// To read Configuration\MyCA\CSP\HashAlgorithm, call:
//
//      GetEntry(L"MyCA", L"CSP", L"HashAlgorithm"
//
//
// If pcwszValue is null, getentry returns a VT_ARRAY|VT_BSTR with a list
// of subkey names.

HRESULT CConfigStorage::GetEntry(
    LPCWSTR pcwszAuthorityName,
    LPCWSTR pcwszRelativeNodePath,
    LPCWSTR pcwszValue,
    VARIANT *pVariant)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    LPBYTE pData = NULL, pTmp;
    DWORD cData = 0;
    HKEY hKeyTmp = NULL;
    DWORD dwType;
    DWORD nIndex;
    DWORD cName;
    DWORD cKeys;

    if(EmptyString(pcwszAuthorityName))
    {
        if(!EmptyString(pcwszRelativeNodePath))
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "CConfigStorage::GetEntry");
        }

        hr = InitRootKey();
        _JumpIfError(hr, error, "CConfigStorage::InitRootKey");

        hKey = m_hRootConfigKey;
    }
    else
    {
        hr = InitCAKey(pcwszAuthorityName);
        _JumpIfError(hr, error, "CConfigStorage::InitCAKey");

        hKey = m_hCAKey;
    }
    
    CSASSERT(hKey);

    if(!EmptyString(pcwszRelativeNodePath))
    {
        hr = RegOpenKeyEx(
               hKey,
               pcwszRelativeNodePath,
               0,
               KEY_ALL_ACCESS,
               &hKeyTmp);
        if ((HRESULT) ERROR_ACCESS_DENIED == hr)
        {
            hr = RegOpenKeyEx(
                   hKey,
                   pcwszRelativeNodePath,
                   0,
                   KEY_READ,
                   &hKeyTmp);
        }
        _JumpIfErrorStr(hr, error, "RegOpenKeyEx", pcwszRelativeNodePath);
        hKey = hKeyTmp;
    }

    if(EmptyString(pcwszValue))
    {
        dwType = REG_MULTI_SZ;
        cData = 2;

        hr = RegQueryInfoKey(
                hKey,
                NULL,NULL,NULL,
                &cKeys,
                &cName,
                NULL,NULL,NULL,NULL,NULL,NULL);
        _JumpIfError(hr, error, "RegQueryInfoKey");

        cData = (cName+1)*cKeys*sizeof(WCHAR);
        pData = (LPBYTE)LocalAlloc(LMEM_FIXED, cData);
        if(!pData)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        pTmp = pData;

        for(nIndex=0;nIndex<cKeys; nIndex++)
        {
            cName = cData;
            hr = RegEnumKeyEx(
                    hKey,
                    nIndex,
                    (LPWSTR)pTmp,
                    &cName,
                    0, NULL, NULL, NULL);
            _JumpIfError(hr, error, "RegEnumKeyEx");
            pTmp = pTmp+(wcslen((LPWSTR)pTmp)+1)*sizeof(WCHAR);
        }

        *(LPWSTR)pTmp= L'\0';

        hr = myRegValueToVariant(
                dwType,
                cData,
                pData,
                pVariant);
        _JumpIfError(hr, error, "myRegValueToVariant");
    }
    else
    {
        hr = RegQueryValueEx(
                hKey,
                pcwszValue,
                NULL,
                &dwType,
                NULL,
                &cData);
        _JumpIfError2(hr, error, "RegQueryValueEx", ERROR_FILE_NOT_FOUND);

        pData = (LPBYTE)LocalAlloc(LMEM_FIXED, cData);
        if(!pData)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        hr = RegQueryValueEx(
                hKey,
                pcwszValue,
                NULL,
                &dwType,
                pData,
                &cData);
        _JumpIfError(hr, error, "RegQueryValueEx");

        hr = myRegValueToVariant(
                dwType,
                cData,
                pData,
                pVariant);
        _JumpIfError(hr, error, "myRegValueToVariant");
    }

error:
    if(hKeyTmp)
        RegCloseKey(hKeyTmp);
    if(pData)
        LocalFree(pData);
    return myHError(hr);
}


// If variant type is VT_EMPTY, SetEntry deletes the value. Otherwise it
// set the value, see myRegValueToVariant for supported types
HRESULT CConfigStorage::SetEntry(
    LPCWSTR pcwszAuthorityName,
    LPCWSTR pcwszRelativeNodePath,
    LPCWSTR pcwszValue,
    VARIANT *pVariant)
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    LPBYTE pData = NULL;
    DWORD cData;
    HKEY hKeyTmp = NULL;
    DWORD dwType;

    if(EmptyString(pcwszAuthorityName))
    {
        if(!EmptyString(pcwszRelativeNodePath))
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "CConfigStorage::GetEntry");
        }

        hr = InitRootKey();
        _JumpIfError(hr, error, "CConfigStorage::InitRootKey");

        hKey = m_hRootConfigKey;
    }
    else
    {
        hr = InitCAKey(pcwszAuthorityName);
        _JumpIfError(hr, error, "CConfigStorage::InitCAKey");

        hKey = m_hCAKey;
    }
    
    CSASSERT(hKey);

    if(!EmptyString(pcwszRelativeNodePath))
    {
        hr = RegOpenKeyEx(
               hKey,
               pcwszRelativeNodePath,
               0,
               KEY_ALL_ACCESS,
               &hKeyTmp);
        _JumpIfErrorStr(hr, error, "RegOpenKeyEx", pcwszRelativeNodePath);
        hKey = hKeyTmp;
    }

    if(VT_EMPTY == V_VT(pVariant))
    {
        // delete value
        hr = RegDeleteValue(
            hKey,
            pcwszValue);
        _JumpIfErrorStr(hr, error, "RegDeleteValue", pcwszValue);
    }
    else
    {
        // set value
        hr = myVariantToRegValue(
                pVariant,
                &dwType,
                &cData,
                &pData);
        _JumpIfError(hr, error, "myVariantToRegValue");

        hr = RegSetValueEx(
                hKey,
                pcwszValue,
                NULL,
                dwType,
                pData,
                cData);
        _JumpIfErrorStr(hr, error, "RegSetValueEx", pcwszValue);
    }

error:
    if(hKeyTmp)
        RegCloseKey(hKeyTmp);
    if(pData)
        LocalFree(pData);

    return myHError(hr);
}

HRESULT CConfigStorage::InitRootKey()
{
    HRESULT hr = S_OK;

    if(!m_hRootConfigKey)
    {
        if(m_pwszMachine)
        {
            hr = RegConnectRegistry(
                    m_pwszMachine,
                    HKEY_LOCAL_MACHINE,
                    &m_hRemoteHKLM);
            _JumpIfError(hr, error, "RegConnectRegistry");


        }

        hr = RegOpenKeyEx(
                m_hRemoteHKLM?m_hRemoteHKLM:HKEY_LOCAL_MACHINE,
                wszREGKEYCONFIGPATH,
                0,
                KEY_ALL_ACCESS,
                &m_hRootConfigKey);
        if ((HRESULT) ERROR_ACCESS_DENIED == hr)
        {
            hr = RegOpenKeyEx(
                    m_hRemoteHKLM?m_hRemoteHKLM:HKEY_LOCAL_MACHINE,
                    wszREGKEYCONFIGPATH,
                    0,
                    KEY_READ,
                    &m_hRootConfigKey);
        }
        _JumpIfErrorStr(hr, error, "RegOpenKeyEx", wszREGKEYCONFIGPATH);
    }

error:
    return hr;
}

HRESULT CConfigStorage::InitCAKey(LPCWSTR pcwszAuthority)
{
    HRESULT hr = S_OK;

    if(!m_hCAKey)
    {
        hr = InitRootKey();
        _JumpIfError(hr, error, "CConfigStorage::InitRootKey");

        hr = RegOpenKeyEx(
                m_hRootConfigKey,
                pcwszAuthority,
                0,
                KEY_ALL_ACCESS,
                &m_hCAKey);
        if ((HRESULT) ERROR_ACCESS_DENIED == hr)
        {
            hr = RegOpenKeyEx(
                    m_hRootConfigKey,
                    pcwszAuthority,
                    0,
                    KEY_READ,
                    &m_hCAKey);
        }
        _JumpIfErrorStr(hr, error, "RegOpenKeyEx", pcwszAuthority);
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\cipolicy.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        cipolicy.cpp
//
// Contents:    Cert Server Policy dispatch support
//
// History:     20-Jan-97       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_CIPOLICY_CPP__


//+------------------------------------------------------------------------
// ICertServerPolicy dispatch support

//TCHAR const g_wszRegKeyCIPolicyClsid[] = wszCLASS_CERTSERVERPOLICY TEXT("\\Clsid");

//+------------------------------------
// SetContext method:

static OLECHAR *policy_apszSetContext[] = {
    TEXT("SetContext"),
    TEXT("Context"),
};

//+------------------------------------
// GetRequestProperty method:

static OLECHAR *policy_apszGetRequestProp[] = {
    TEXT("GetRequestProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// GetRequestAttribute method:

static OLECHAR *policy_apszGetRequestAttr[] = {
    TEXT("GetRequestAttribute"),
    TEXT("strAttributeName"),
};

//+------------------------------------
// GetCertificateProperty method:

static OLECHAR *policy_apszGetCertificateProp[] = {
    TEXT("GetCertificateProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
};

//+------------------------------------
// SetCertificateProperty method:

static OLECHAR *policy_apszSetCertificateProp[] = {
    TEXT("SetCertificateProperty"),
    TEXT("strPropertyName"),
    TEXT("PropertyType"),
    TEXT("pvarPropertyValue"),
};

//+------------------------------------
// GetCertificateExtension method:

static OLECHAR *policy_apszGetCertificateExt[] = {
    TEXT("GetCertificateExtension"),
    TEXT("strExtensionName"),
    TEXT("Type"),
};

//+------------------------------------
// GetCertificateExtensionFlags method:

static OLECHAR *policy_apszGetCertificateExtFlags[] = {
    TEXT("GetCertificateExtensionFlags"),
};

//+------------------------------------
// SetCertificateExtension method:

static OLECHAR *policy_apszSetCertificateExt[] = {
    TEXT("SetCertificateExtension"),
    TEXT("strExtensionName"),
    TEXT("Type"),
    TEXT("ExtFlags"),
    TEXT("pvarValue"),
};

//+------------------------------------
// EnumerateExtensionsSetup method:

static OLECHAR *policy_apszEnumerateExtensionsSetup[] = {
    TEXT("EnumerateExtensionsSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateExtensions method:

static OLECHAR *policy_apszEnumerateExtensions[] = {
    TEXT("EnumerateExtensions"),
};

//+------------------------------------
// EnumerateExtensionsClose method:

static OLECHAR *policy_apszEnumerateExtensionsClose[] = {
    TEXT("EnumerateExtensionsClose"),
};

//+------------------------------------
// EnumerateAttributesSetup method:

static OLECHAR *policy_apszEnumerateAttributesSetup[] = {
    TEXT("EnumerateAttributesSetup"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumerateAttributes method:

static OLECHAR *policy_apszEnumerateAttributes[] = {
    TEXT("EnumerateAttributes"),
};

//+------------------------------------
// EnumerateAttributesClose method:

static OLECHAR *policy_apszEnumerateAttributesClose[] = {
    TEXT("EnumerateAttributesClose"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtCIPolicy[] =
{
#define POLICY_SETCONTEXT		0
    DECLARE_DISPATCH_ENTRY(policy_apszSetContext)

#define POLICY_GETREQUESTPROPERTY	1
    DECLARE_DISPATCH_ENTRY(policy_apszGetRequestProp)

#define POLICY_GETREQUESTATTRIBUTE	1
    DECLARE_DISPATCH_ENTRY(policy_apszGetRequestAttr)

#define POLICY_GETCERTIFICATEPROPERTY	2
    DECLARE_DISPATCH_ENTRY(policy_apszGetCertificateProp)

#define POLICY_SETCERTIFICATEPROPERTY	3
    DECLARE_DISPATCH_ENTRY(policy_apszSetCertificateProp)

#define POLICY_GETCERTIFICATEEXTENSION	4
    DECLARE_DISPATCH_ENTRY(policy_apszGetCertificateExt)

#define POLICY_GETCERTIFICATEEXTENSIONFLAGS	5
    DECLARE_DISPATCH_ENTRY(policy_apszGetCertificateExtFlags)

#define POLICY_SETCERTIFICATEEXTENSION	6
    DECLARE_DISPATCH_ENTRY(policy_apszSetCertificateExt)

#define POLICY_ENUMERATEEXTENSIONSSETUP	7
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateExtensionsSetup)

#define POLICY_ENUMERATEEXTENSIONS	8
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateExtensions)

#define POLICY_ENUMERATEEXTENSIONSCLOSE	9
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateExtensionsClose)

#define POLICY_ENUMERATEATTRIBUTESSETUP	10
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateAttributesSetup)

#define POLICY_ENUMERATEATTRIBUTES	11
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateAttributes)

#define POLICY_ENUMERATEATTRIBUTESCLOSE	12
    DECLARE_DISPATCH_ENTRY(policy_apszEnumerateAttributesClose)
};
#define CPOLICYDISPATCH	(ARRAYSIZE(g_adtCIPolicy))




HRESULT
CIPolicy_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiCIPolicy)
{
    HRESULT hr;

    hr = DispatchSetup(
		Flags,
                CLSCTX_INPROC_SERVER,
                wszCLASS_CERTSERVERPOLICY, // g_wszRegKeyCIPolicyClsid,
		&CLSID_CCertServerPolicy,
		&IID_ICertServerPolicy,
		CPOLICYDISPATCH,
                g_adtCIPolicy,
                pdiCIPolicy);
    _JumpIfError(hr, error, "DispatchSetup");

    pdiCIPolicy->pDispatchTable = g_adtCIPolicy;

error:
    return(hr);
}


VOID
CIPolicy_Release(
    IN OUT DISPATCHINTERFACE *pdiCIPolicy)
{
    DispatchRelease(pdiCIPolicy);
}


HRESULT
CIPolicy_SetContext(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Context)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Context;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_SETCONTEXT,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetContext)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->SetContext(Context);
	_JumpIfError(hr, error, "ICertServerPolicy::SetContext");
    }

error:
    return(hr);
}


HRESULT
cipolicyGetProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN DWORD IPolicyTable,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    HRESULT hr;
    BSTR bstrPropName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);
    CSASSERT(
	    POLICY_GETCERTIFICATEPROPERTY == IPolicyTable ||
	    POLICY_GETREQUESTPROPERTY == IPolicyTable);

    VariantInit(&varResult);
    *pbstrPropValue = NULL;

    if (!ConvertWszToBstr(&bstrPropName, pwszPropName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (PropertyType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrPropName;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropertyType;

	hr = DispatchInvoke(
			pdiCIPolicy,
			IPolicyTable,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrPropValue);
	_JumpIfError(
		hr,
		error,
		POLICY_GETCERTIFICATEPROPERTY == IPolicyTable?
		    "Invoke(Policy::GetCertificateProperty)" :
		    POLICY_GETREQUESTPROPERTY == IPolicyTable?
			"Invoke(Policy::GetRequestProperty)" :
			"Invoke(Policy::GetRequestAttribute)");
    }
    else
    {
	if (POLICY_GETCERTIFICATEPROPERTY == IPolicyTable)
	{
	    hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetCertificateProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else if (POLICY_GETREQUESTPROPERTY == IPolicyTable)
	{
	    hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetRequestProperty(
								bstrPropName,
								PropertyType,
								&varResult);
	}
	else
	{
	    CSASSERT(POLICY_GETREQUESTATTRIBUTE == IPolicyTable);
	    CSASSERT(PROPTYPE_STRING == PropertyType);
	    hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetRequestAttribute(
							    bstrPropName,
							    &varResult.bstrVal);
	    if (S_OK == hr)
	    {
		varResult.vt = VT_BSTR;
	    }
	}
	_JumpIfError(
		hr,
		error,
		POLICY_GETCERTIFICATEPROPERTY == IPolicyTable?
		    "ICertServerPolicy::GetCertificateProperty" :
		    POLICY_GETREQUESTPROPERTY == IPolicyTable?
			"ICertServerPolicy::GetRequestProperty" :
			"ICertServerPolicy::GetRequestAttribute");
	
	hr = DispatchGetReturnValue(&varResult, RetType, pbstrPropValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrPropName)
    {
	SysFreeString(bstrPropName);
    }
    return(hr);
}


HRESULT
CIPolicy_GetRequestProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(cipolicyGetProperty(
			pdiCIPolicy,
			POLICY_GETREQUESTPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIPolicy_GetRequestAttribute(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    OUT BSTR *pbstrPropValue)
{
    return(cipolicyGetProperty(
			pdiCIPolicy,
			POLICY_GETREQUESTATTRIBUTE,
			pwszPropName,
			PROPTYPE_STRING,
			pbstrPropValue));
}


HRESULT
CIPolicy_GetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    OUT BSTR *pbstrPropValue)
{
    return(cipolicyGetProperty(
			pdiCIPolicy,
			POLICY_GETCERTIFICATEPROPERTY,
			pwszPropName,
			PropertyType,
			pbstrPropValue));
}


HRESULT
CIPolicy_SetCertificateProperty(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszPropName,
    IN LONG PropertyType,
    IN WCHAR const *pwszPropValue)
{
    HRESULT hr;
    VARIANT avar[3];
    BSTR bstrPropName = NULL;
    BSTR bstrPropValue = NULL;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (!ConvertWszToBstr(&bstrPropName, pwszPropName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (PropertyType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    if (!ConvertWszToBstr(&bstrPropValue, pwszPropValue, -1))
	    {
		hr = E_OUTOFMEMORY;
		goto error;
	    }
	    avar[2].vt = VT_BSTR;
	    avar[2].bstrVal = bstrPropValue;
	    break;

	case PROPTYPE_DATE:
	    avar[2].vt = VT_DATE;
	    avar[2].date = *(DATE *) pwszPropValue;
	    break;

	case PROPTYPE_LONG:
	    avar[2].vt = VT_I4;
	    avar[2].lVal = *(LONG *) pwszPropValue;
	    break;
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrPropName;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropertyType;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_SETCERTIFICATEPROPERTY,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetCertificateProperty)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->SetCertificateProperty(
								bstrPropName,
								PropertyType,
								&avar[2]);
	_JumpIfError(hr, error, "ICertServerPolicy::SetCertificateProperty");
    }

error:
    if (NULL != bstrPropName)
    {
	SysFreeString(bstrPropName);
    }
    if (NULL != bstrPropValue)
    {
	SysFreeString(bstrPropValue);
    }
    return(hr);
}


HRESULT
CIPolicy_GetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    OUT BSTR *pbstrValue)
{
    HRESULT hr;
    BSTR bstrExtensionName = NULL;
    LONG RetType;
    VARIANT varResult;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    VariantInit(&varResult);
    *pbstrValue = NULL;

    if (!ConvertWszToBstr(&bstrExtensionName, pwszExtensionName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrExtensionName;

	avar[1].vt = VT_I4;
	avar[1].lVal = Type;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_GETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pbstrValue);
	_JumpIfError(hr, error, "Invoke(Policy::GetCertificateExtension)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetCertificateExtension(
								bstrExtensionName,
								Type,
								&varResult);
	_JumpIfError(hr, error, "ICertServerPolicy::GetCertificateExtension");

	hr = DispatchGetReturnValue(&varResult, RetType, pbstrValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    if (NULL != bstrExtensionName)
    {
	SysFreeString(bstrExtensionName);
    }
    return(hr);
}


HRESULT
CIPolicy_GetCertificateExtensionFlags(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT LONG *pExtFlags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_GETCERTIFICATEEXTENSIONFLAGS,
			0,
			NULL,
			VT_I4,
			pExtFlags);
	_JumpIfError(hr, error, "Invoke(Policy::GetCertificateExtensionFlags)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->GetCertificateExtensionFlags(
								pExtFlags);
	_JumpIfError(hr, error, "ICertServerPolicy::GetCertificateExtensionFlags");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_SetCertificateExtension(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN WCHAR const *pwszExtensionName,
    IN LONG Type,
    IN LONG ExtFlags,
    IN void const *pvValue)
{
    HRESULT hr;
    VARIANT avar[4];
    BSTR bstrExtensionName = NULL;


    if (!ConvertWszToBstr(&bstrExtensionName, pwszExtensionName, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }

    switch (Type)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    avar[3].vt = VT_BSTR;
	    avar[3].bstrVal = (BSTR)pvValue;
	    break;

	case PROPTYPE_DATE:
	    avar[3].vt = VT_DATE;
	    avar[3].date = *(DATE *) pvValue;
	    break;

	case PROPTYPE_LONG:
	    avar[3].vt = VT_I4;
	    avar[3].lVal = *(LONG *) pvValue;
	    break;
    }

    if (NULL != pdiCIPolicy->pDispatch)
    {
	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = bstrExtensionName;

	avar[1].vt = VT_I4;
	avar[1].lVal = Type;

	avar[2].vt = VT_I4;
	avar[2].lVal = ExtFlags;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_SETCERTIFICATEEXTENSION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetCertificateExtension)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->SetCertificateExtension(
							    bstrExtensionName,
							    Type,
							    ExtFlags,
							    &avar[2]);
	_JumpIfError(hr, error, "ICertServerPolicy::SetCertificateExtension");
    }

error:
    if (NULL != bstrExtensionName)
    {
	SysFreeString(bstrExtensionName);
    }

    return(hr);
}


HRESULT
CIPolicy_EnumerateExtensionsSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEEXTENSIONSSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsSetup)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateExtensionsSetup(
								    Flags);
	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateExtensionsSetup");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateExtensions(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrExtensionName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEEXTENSIONS,
			0,
			NULL,
			VT_BSTR,
			pstrExtensionName);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensions)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateExtensions(
							    pstrExtensionName);
	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateExtensions");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateExtensionsClose(
    IN DISPATCHINTERFACE *pdiCIPolicy)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEEXTENSIONSCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateExtensionsClose)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateExtensionsClose();

	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateExtensionsClose");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateAttributesSetup(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    IN LONG Flags)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEATTRIBUTESSETUP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesSetup)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateAttributesSetup(
								    Flags);

	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateAttributesSetup");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateAttributes(
    IN DISPATCHINTERFACE *pdiCIPolicy,
    OUT BSTR *pstrAttributeName)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEATTRIBUTES,
			0,
			NULL,
			0,
			pstrAttributeName);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributes)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateAttributes(
							    pstrAttributeName);

	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateAttributes");
    }

error:
    return(hr);
}


HRESULT
CIPolicy_EnumerateAttributesClose(
    IN DISPATCHINTERFACE *pdiCIPolicy)
{
    HRESULT hr;

    CSASSERT(NULL != pdiCIPolicy && NULL != pdiCIPolicy->pDispatchTable);

    if (NULL != pdiCIPolicy->pDispatch)
    {
	hr = DispatchInvoke(
			pdiCIPolicy,
			POLICY_ENUMERATEATTRIBUTESCLOSE,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(EnumerateAttributesClose)");
    }
    else
    {
	hr = ((ICertServerPolicy *) pdiCIPolicy->pUnknown)->EnumerateAttributesClose();
	_JumpIfError(hr, error, "ICertServerPolicy::EnumerateAttributesClose");
    }

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\config.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       config.cpp
//
//  Contents:   ICertConfig IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_CONFIG_CPP__


//+------------------------------------------------------------------------
// ICertConfig dispatch support

// TCHAR szRegKeyConfigClsid[] = wszCLASS_CERTCONFIG TEXT("\\Clsid");

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
    TEXT("Index"),
};

//+------------------------------------
// Next method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetField method:

static OLECHAR *_apszGetField[] = {
    TEXT("GetField"),
    TEXT("strFieldName"),
};

//+------------------------------------
// GetConfig method:

static OLECHAR *_apszGetConfig[] = {
    TEXT("GetConfig"),
    TEXT("Flags"),
};

//+------------------------------------
// SetSharedFolder method:

static OLECHAR *_apszSetSharedFolder[] = {
    TEXT("SetSharedFolder"),
    TEXT("strSharedFolder"),
};

//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtConfig[] =
{
#define CONFIG_RESET		0
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define CONFIG_NEXT		1
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define CONFIG_GETFIELD		2
    DECLARE_DISPATCH_ENTRY(_apszGetField)

#define CONFIG_GETCONFIG	3
    DECLARE_DISPATCH_ENTRY(_apszGetConfig)

#define CONFIG2_SETSHAREDFOLDER	4
    DECLARE_DISPATCH_ENTRY(_apszSetSharedFolder)
};
#define CCONFIGDISPATCH	(ARRAYSIZE(s_adtConfig))
#define CCONFIGDISPATCH_V1	CONFIG2_SETSHAREDFOLDER
#define CCONFIGDISPATCH_V2	CCONFIGDISPATCH


DWORD s_acConfigDispatch[] = {
    CCONFIGDISPATCH_V2,
    CCONFIGDISPATCH_V1,
};

IID const *s_apConfigiid[] = {
    &IID_ICertConfig2,
    &IID_ICertConfig,
};


HRESULT
Config_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiConfig)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTCONFIG,
		&CLSID_CCertConfig,
		ARRAYSIZE(s_acConfigDispatch),		// cver
		s_apConfigiid,
		s_acConfigDispatch,
		s_adtConfig,
		pdiConfig);
    _JumpIfError(hr, error, "DispatchSetup2(ICertConfig)");

error:
    return(hr);
}


VOID
Config_Release(
    IN OUT DISPATCHINTERFACE *pdiConfig)
{
    DispatchRelease(pdiConfig);
}


HRESULT
ConfigVerifyVersion(
    IN DISPATCHINTERFACE *pdiConfig,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    switch (pdiConfig->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiConfig->pDispatch ||
		CCONFIGDISPATCH_V1 == pdiConfig->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiConfig->pDispatch ||
		CCONFIGDISPATCH_V2 == pdiConfig->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiConfig->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Config_Reset(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Index,
    OUT LONG *pCount)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Index;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_RESET,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pCount);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->Reset(Index, pCount);

	_JumpIfError(hr, error, "ICertConfig::Reset");
    }

error:
    return(hr);
}


HRESULT
Config_Next(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (NULL != pdiConfig->pDispatch)
    {
	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError(hr, error, "Invoke(Next)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->Next(pIndex);
	if (S_FALSE != hr)
	{
	    _JumpIfError(hr, error, "ICertConfig::Next");
	}
    }

error:
    return(hr);
}


HRESULT
Config_GetField(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszField,
    OUT BSTR *pstr)
{
    HRESULT hr;
    BSTR strField = NULL;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (!ConvertWszToBstr(&strField, pwszField, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    //wprintf(L"str=%ws, len=%u\n", strField, ((ULONG *) strField)[-1]);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strField;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_GETFIELD,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstr);
	_JumpIfError(hr, error, "Invoke(GetField)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->GetField(strField, pstr);
	_JumpIfErrorNotSpecific(
			    hr,
			    error,
			    "ICertConfig::GetField",
			    CERTSRV_E_PROPERTY_EMPTY);
    }
    hr = S_OK;

error:
    if (NULL != strField)
    {
	SysFreeString(strField);
    }
    return(hr);
}


HRESULT
Config_GetConfig(
    IN DISPATCHINTERFACE *pdiConfig,
    IN LONG Flags,
    OUT BSTR *pstrConfig)
{
    HRESULT hr;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG_GETCONFIG,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrConfig);
	_JumpIfError(hr, error, "Invoke(GetConfig)");
    }
    else
    {
	hr = ((ICertConfig *) pdiConfig->pUnknown)->GetConfig(Flags, pstrConfig);
	_JumpIfError(hr, error, "ICertConfig::GetConfig");
    }

error:
    return(hr);
}


HRESULT
Config2_SetSharedFolder(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszSharedFolder)
{
    HRESULT hr;
    BSTR strSharedFolder = NULL;

    CSASSERT(NULL != pdiConfig && NULL != pdiConfig->pDispatchTable);

    hr = ConfigVerifyVersion(pdiConfig, 2);
    _JumpIfError(hr, error, "ConfigVerifyVersion");

    if (!ConvertWszToBstr(&strSharedFolder, pwszSharedFolder, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    //wprintf(L"str=%ws, len=%u\n", strSharedFolder, ((ULONG *) strSharedFolder)[-1]);

    if (NULL != pdiConfig->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strSharedFolder;

	hr = DispatchInvoke(
			pdiConfig,
			CONFIG2_SETSHAREDFOLDER,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetSharedFolder)");
    }
    else
    {
	hr = ((ICertConfig2 *) pdiConfig->pUnknown)->SetSharedFolder(strSharedFolder);
	_JumpIfError(hr, error, "ICertConfig::GetConfig");
    }

error:
    if (NULL != strSharedFolder)
    {
	SysFreeString(strSharedFolder);
    }
    return(hr);
}


WCHAR const * const s_apwszFieldNames[] = {
    wszCONFIG_COMMONNAME,
    wszCONFIG_ORGUNIT,
    wszCONFIG_ORGANIZATION,
    wszCONFIG_LOCALITY,
    wszCONFIG_STATE,
    wszCONFIG_COUNTRY,
    wszCONFIG_CONFIG,
    wszCONFIG_EXCHANGECERTIFICATE,
    wszCONFIG_SIGNATURECERTIFICATE,
    wszCONFIG_DESCRIPTION,
    wszCONFIG_SERVER,
    wszCONFIG_AUTHORITY,
    wszCONFIG_SANITIZEDNAME,
    wszCONFIG_SHORTNAME,
    wszCONFIG_SANITIZEDSHORTNAME,
    wszCONFIG_FLAGS,
};
#define CSTRING (sizeof(s_apwszFieldNames)/sizeof(s_apwszFieldNames[0]))

WCHAR const *s_apwszDisplayNames[CSTRING] = {
    wszCONFIG_COMMONNAME L":",
    wszCONFIG_ORGUNIT L":",
    wszCONFIG_ORGANIZATION L":",
    wszCONFIG_LOCALITY L":",
    wszCONFIG_STATE L":",
    wszCONFIG_COUNTRY L":",
    wszCONFIG_CONFIG L":",
    wszCONFIG_EXCHANGECERTIFICATE L":",
    wszCONFIG_SIGNATURECERTIFICATE L":",
    wszCONFIG_DESCRIPTION L":",
    wszCONFIG_SERVER L":",
    wszCONFIG_AUTHORITY L":",
    wszCONFIG_SANITIZEDNAME L":",
    wszCONFIG_SHORTNAME L":",
    wszCONFIG_SANITIZEDSHORTNAME L":",
    wszCONFIG_FLAGS L":",
};


HRESULT
ConfigDumpSetDisplayNames(
    IN WCHAR const * const *apwszFieldNames,
    IN WCHAR const * const *apwszDisplayNames,
    IN DWORD cNames)
{
    DWORD i;
    DWORD j;
    HRESULT hr;

    for (i = 0; i < cNames; i++)
    {
	for (j = 0; j < CSTRING; j++)
	{
	    if (0 == mylstrcmpiS(s_apwszFieldNames[j], apwszFieldNames[i]) ||
		(0 == LSTRCMPIS(s_apwszFieldNames[j], wszCONFIG_DESCRIPTION) &&
		 0 == LSTRCMPIS(apwszFieldNames[i], wszCONFIG_COMMENT)))
	    {
		s_apwszDisplayNames[j] = apwszDisplayNames[i];
		break;
	    }
	}
	if (CSTRING <= j)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "column name", apwszFieldNames[i]);
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ConfigDumpEntry(
    IN DISPATCHINTERFACE *pdiConfig,
    IN WCHAR const *pwszEntry,		// localized L"Entry"
    IN LONG Index,  // less than 0 skip index, entry, & suffix print
    OPTIONAL IN WCHAR const *pwszSuffix)
{
    HRESULT hr;
    DWORD i;
    BSTR strings[CSTRING];

    for (i = 0; i < CSTRING; i++)
    {
	strings[i] = NULL;
    }
    for (i = 0; i < CSTRING; i++)
    {
	hr = Config_GetField(pdiConfig, s_apwszFieldNames[i], &strings[i]);
	_JumpIfError(hr, error, "Config_GetField");
    }
    if (-1 < Index)
    {
        myConsolePrintf(
	    L"%ws%ws %u:%ws%ws\n",
	    0 == Index? L"" : L"\n",
	    pwszEntry,
	    Index,
	    NULL != pwszSuffix? L" " : L"",
	    NULL != pwszSuffix? pwszSuffix : L"");
    }
    for (i = 0; i < CSTRING; i++)
    {
	myConsolePrintf(L"  ");
	myConsolePrintString(24, s_apwszDisplayNames[i]);
	myConsolePrintf(L"\t`");
	if (0 != wcscmp(s_apwszFieldNames[i], L"ExchangeCertificate"))
	{
	    if (NULL != strings[i])
	    {
		myConsolePrintf(L"%ws", strings[i]);
	    }
	}
	myConsolePrintf(L"'\n");
    }
    hr = S_OK;

error:
    for (i = 0; i < CSTRING; i++)
    {
	if (NULL != strings[i])
	{
	    SysFreeString(strings[i]);
	}
    }
    return(hr);
}


HRESULT
ConfigDump(
    IN DWORD Flags,				// See DispatchSetup() Flags
    IN WCHAR const *pwszEntry,			// localized L"Entry"
    OPTIONAL IN WCHAR const *pwszLocalSuffix,	// localized L"(Local)"
    OPTIONAL IN WCHAR const *pwszMach1,
    OPTIONAL IN WCHAR const *pwszMach2)
{
    HRESULT hr;
    LONG i;
    LONG count;
    LONG Index;
    BSTR strServer = NULL;
    WCHAR const *pwszSuffix;
    DISPATCHINTERFACE diConfig;

    hr = Config_Init(Flags, &diConfig);
    _JumpIfError(hr, error, "Config_Init");

    hr = Config_Reset(&diConfig, 0, &count);
    _JumpIfError(hr, error, "Config_Reset");

    Index = 0;
    for (i = 0; i < count; i++)
    {
	hr = Config_Next(&diConfig, &Index);
	if (S_OK != hr && S_FALSE != hr)
	{
	    _JumpError(hr, error, "Config_Next");
	}
	hr = S_OK;
	if (-1 == Index)
	{
	    break;
	}

	pwszSuffix = NULL;
	if (NULL != pwszLocalSuffix)
	{
	    hr = Config_GetField(&diConfig, wszCONFIG_SERVER, &strServer);
	    _JumpIfError(hr, error, "Config_GetField");

	    if ((NULL != pwszMach1 && 0 == mylstrcmpiL(strServer, pwszMach1)) ||
		(NULL != pwszMach2 && 0 == mylstrcmpiL(strServer, pwszMach2)))
	    {
		pwszSuffix = pwszLocalSuffix;
	    }
	}
	hr = ConfigDumpEntry(&diConfig, pwszEntry, Index, pwszSuffix);
	_JumpIfError(hr, error, "ConfigDumpEntry");
    }

error:
    if (NULL != strServer)
    {
	SysFreeString(strServer);
    }
    Config_Release(&diConfig);
    return(hr);
}


HRESULT
ConfigGetConfig(
    IN DWORD Flags,
    IN DWORD dwUIFlag,
    OUT BSTR *pstrConfig)
{
    HRESULT hr;
    DISPATCHINTERFACE diConfig;

    hr = Config_Init(Flags, &diConfig);
    _JumpIfError(hr, error, "Config_Init");

    hr = Config_GetConfig(&diConfig, dwUIFlag, pstrConfig);
    _JumpIfError(hr, error, "Config_GetConfig");

error:
    Config_Release(&diConfig);
    return(hr);
}


DWORD
myGetDisplayLength(
    IN WCHAR const *pwsz)
{
    HRESULT hr;
    LONG ccol;

    CSASSERT(NULL != pwsz);

    ccol = WideCharToMultiByte(
		    GetACP(),	// CodePage
		    0,		// dwFlags
		    pwsz,	// lpWideCharStr
		    -1,		// cchWideChar, -1 => L'\0' terminated
		    NULL,	// lpMultiByteStr
		    0,		// cbMultiByte
		    NULL,	// lpDefaultChar
		    NULL);	// lpUsedDefaultChar
    if (0 >= ccol)
    {
	if (0 > ccol || L'\0' != *pwsz)
	{
	    hr = myHLastError();
	    _PrintError(hr, "WideCharToMultiByte");
	}
	ccol = wcslen(pwsz);
    }
    else
    {
	ccol--;			// don't include trailing L'\0'
    }
//error:
    return(ccol);
}


LONG
myConsolePrintString(
    IN DWORD ccolMin,
    IN WCHAR const *pwszString)
{
    DWORD ccolDisplay;
    DWORD ccolRet;

    ccolRet = myGetDisplayLength(pwszString);
    ccolDisplay = ccolRet;
    if (ccolMin < ccolDisplay)
    {
	ccolDisplay = ccolMin;
    }
    myConsolePrintf(L"%ws%*ws", pwszString, ccolMin - ccolDisplay, L"");
    return(ccolRet);
}


static BOOL s_fConsolePrintfDisable = FALSE;

BOOL
myConsolePrintfDisable(
    IN BOOL fDisable)
{
    BOOL fDisableOld = s_fConsolePrintfDisable;

    s_fConsolePrintfDisable = fDisable;
    return(fDisableOld);
}


// Fall back to stdio if s_fConsolePrintfDisable is set OR
// if _vsnwprintf doesn't exist in ntdll.dll and msvcrt.dll OR
// if we run out of memory allocating a working buffer.
//
// Otherwise:
// if redirected, use WriteFile
// if not redirected, use WriteConsole

#define cwcBUFMIN	512
#define cwcBUFMAX	(64 * 1024)

int __cdecl
myConsolePrintf(
    OPTIONAL IN WCHAR const *pwszFmt,
    ...)
{
    HRESULT hr;
    va_list pva;
    int cwc;
    DWORD cwcOut;
    HANDLE hStdOut;
    WCHAR wszBuf[cwcBUFMIN];
    WCHAR *pwszBuf = wszBuf;
    DWORD cwcBuf = ARRAYSIZE(wszBuf);
    CHAR szAnsi[2 * cwcBUFMIN];
    CHAR *pszAnsi = NULL;
    DWORD cchAnsi;

    BOOL fRedirected = FALSE;


    typedef int (__cdecl FN_VSNWPRINTF)(
        OUT wchar_t *,
        IN size_t,
        IN const wchar_t *,
        IN va_list);

    HMODULE hModule;
    static FN_VSNWPRINTF *s_pfn = NULL;

    if (NULL == pwszFmt)
    {
        pwszFmt = L"(null)";
    }
    if (L'\0' == *pwszFmt)
    {
	cwcOut = 0;
	goto error;
    }
    if (NULL == s_pfn)
    {
        hModule = GetModuleHandle(TEXT("ntdll.dll"));
        if (NULL != hModule)
        {
            s_pfn = (FN_VSNWPRINTF *) GetProcAddress(hModule, "_vsnwprintf");
        }
	if (NULL == s_pfn)
	{
	    hModule = GetModuleHandle(TEXT("msvcrt.dll"));
            s_pfn = (FN_VSNWPRINTF *) GetProcAddress(hModule, "_vsnwprintf");
	}
    }
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (NULL == s_pfn || s_fConsolePrintfDisable)
    {
	hStdOut = INVALID_HANDLE_VALUE;		// use stdio fallback
    }

    cwc = 0;
    if (INVALID_HANDLE_VALUE != hStdOut)
    {
	for (;;)
	{
	    va_start(pva, pwszFmt);
	    cwc = (*s_pfn)(pwszBuf, cwcBuf, pwszFmt, pva);
	    va_end(pva);

	    if (-1 != cwc)
	    {
		break;
	    }
	    if (cwcBUFMAX <= cwcBuf)
	    {
		_PrintError(
		    HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW),
		    "_vsnwprintf");
		hStdOut = INVALID_HANDLE_VALUE;
		break;
	    }
	    if (pwszBuf != wszBuf)
	    {
		LocalFree(pwszBuf);
	    }
	    cwcBuf *= 2;
	    if (cwcBUFMAX < cwcBuf)
	    {
		cwcBuf = cwcBUFMAX;
	    }
	    pwszBuf = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcBuf * sizeof(WCHAR));
	    if (NULL == pwszBuf)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
		hStdOut = INVALID_HANDLE_VALUE;
		break;
	    }
	}
    }

    if (INVALID_HANDLE_VALUE != hStdOut)
    {
	// time for output -- where are we going, to a file or the console?
	
	switch (~FILE_TYPE_REMOTE & GetFileType(hStdOut))
	{
	    //case FILE_TYPE_PIPE:
	    //case FILE_TYPE_DISK:
	    default:
		// if redirected to a pipe or a file, don't use WriteConsole;
		// it drops redirected output on the floor
		fRedirected = TRUE;
		break;

	    case FILE_TYPE_UNKNOWN:
                _PrintError2(
			E_UNEXPECTED,
			"GetFileType(FILE_TYPE_UNKNOWN)",
			E_UNEXPECTED);
                hStdOut = INVALID_HANDLE_VALUE;
		s_fConsolePrintfDisable = TRUE;
                break;
		
	    case FILE_TYPE_CHAR:
		break;
	}
    }

    cwcOut = 0;
    if (INVALID_HANDLE_VALUE != hStdOut)
    {
	if (!fRedirected)
	{
	    if (!WriteConsole(hStdOut, pwszBuf, cwc, &cwcOut, NULL))
	    {
		hr = myHLastError();
		_PrintError(hr, "WriteConsole");
		hStdOut = INVALID_HANDLE_VALUE;
	    }
	}
	else  // WriteConsole is out of the question
	{
	    DWORD cch;

	    // Expand all \n chars to \r\n so the WriteFile ends up clean.
	    // Alloc new buffer big enough to hold two bytes per WCHAR for
	    // worst case MultiByte translation + inserted \r chars.

	    cchAnsi = 2 * (cwc + 1);
	    if (ARRAYSIZE(szAnsi) >= cchAnsi)
	    {
		pszAnsi = szAnsi;
	    }
	    else
	    {
		pszAnsi = (LPSTR) LocalAlloc(LMEM_FIXED, cchAnsi);
		if (NULL == pszAnsi)
		{
		    _PrintError(E_OUTOFMEMORY, "LocalAlloc");
		    hStdOut = INVALID_HANDLE_VALUE;
		}
	    }
	    cch = 0;
	    if (INVALID_HANDLE_VALUE != hStdOut)
            {
                // if going to a file, we should not use console codepage, we
		// should use ANSI codepage OR write unicode & a unicode
		// filemarker at beginning of file.
                // Since we don't know if this is the first thing in the file,
		// let's go the ANSI route.

		cch = WideCharToMultiByte(
				    GetACP(), // GetConsoleOutputCP(),
				    0,
				    pwszBuf,
				    cwc,
				    pszAnsi,
				    cchAnsi,
				    NULL,
				    NULL);
		if (0 == cch)
		{
		    hr = myHLastError();
		    _PrintError(hr, "WideCharToMultiByte");
		    _PrintErrorStr(GetACP(), "WideCharToMultiByte", pwszBuf);
		    hStdOut = INVALID_HANDLE_VALUE;
		}
	    }
	    if (INVALID_HANDLE_VALUE != hStdOut)
	    {
		CHAR *pchWork = pszAnsi;
		DWORD cchOut;
		
		// expand all \n chars to \r\n

		cwcOut = cwc;
		for (unsigned int j = 0; j < cch; j++, pchWork++)
		{
		    if (*pchWork == '\n')
		    {
			// create a 1-char space before \n

			MoveMemory(&pchWork[1], pchWork, cch - j);

			// Fill with \r and skip past \r (this statement) and
			// \n (automatic via loop incr).

			*pchWork++ = '\r';
			j++;
			cch++;		// write one more char for each \n
		    }
		}
		CSASSERT(pchWork <= &pszAnsi[2 * cwc]);
		
		if (!WriteFile(hStdOut, pszAnsi, cch, &cchOut, NULL))
		{
		    hr = myHLastError();
		    _PrintError(hr, "WriteFile");
		    if (E_HANDLE == hr)
		    {
			hStdOut = INVALID_HANDLE_VALUE;
			s_fConsolePrintfDisable = TRUE;
		    }
		    else
		    {
			// This is the only case we drop output on the floor.
			// Most likely cause is disk full, so stdio won't help.
		    }
		}
	    }
	} // else WriteConsole
    }

    if (INVALID_HANDLE_VALUE == hStdOut)
    {
	BOOL fRetried = FALSE;
	
	for (;;)
	{
	    ALIGNIOB(stdout);
	    va_start(pva, pwszFmt);
	    hr = S_OK;
	    __try
	    {
		cwcOut = vfwprintf(stdout, pwszFmt, pva);
	    }
	    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	    {
		cwcOut = MAXDWORD;
		DBGPRINT((
		    DBG_SS_ERROR,
		    "Exception %x: myConsolePrintf(%ws)",
		    hr,
		    pwszFmt));
	    }
	    va_end(pva);
#pragma warning(push)
#pragma warning(disable: 4127)	// conditional expression is constant
	    if (S_OK == hr || fRetried || !IOBUNALIGNED(stdout))
#pragma warning(pop)
	    {
		break;
	    }
	    fRetried = TRUE;
	}
    }

error:
    if (NULL != pwszBuf && wszBuf != pwszBuf)
    {
	LocalFree(pwszBuf);
    }
    if (NULL != pszAnsi && szAnsi != pszAnsi)
    {
	LocalFree(pszAnsi);
    }
    return((int) cwcOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\crfile.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crfile.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define __dwFILE__	__dwFILE_CERTLIB_CRFILE_CPP__


HRESULT
myFixupRCFilterString(WCHAR *szFilter)
{
    LPWSTR szTmpPtr;

    if (NULL == szFilter)
        return S_OK;

    // translate to end of string
    for (szTmpPtr = szFilter; ; )
    {
	szTmpPtr = wcschr(szTmpPtr, L'|');
	if (NULL == szTmpPtr)
	{
	    break;
	}
        // replace every "|" with NULL termination
        szTmpPtr[0] = L'\0';
        szTmpPtr++;
    }

    return S_OK;
}

HRESULT
myGetFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    IN BOOL                  fOpen,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    HRESULT       hr;
    WCHAR        *pwszTitle = NULL;
    WCHAR        *pwszExpandedTitle = NULL;
    WCHAR        *pwszFilter = NULL;
    WCHAR        *pwszDefExt = NULL;
    WCHAR         wszFileName[MAX_PATH] = L"\0";
    WCHAR         wszEmptyFilter[] = L"\0";
    WCHAR         wszPath[MAX_PATH];
    WCHAR        *pwszFilePortion;
    DWORD         dwFileAttr;
    BOOL          fGetFile;
    OPENFILENAME  ofn;

    CSASSERT(NULL != ppwszFile);

    // init
    *ppwszFile = NULL;
    ZeroMemory(&ofn, sizeof(OPENFILENAME));

    if (0 != iRCTitle)
    {
        // load title
        hr = myLoadRCString(hInstance, iRCTitle, &pwszTitle);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszTitle);
            _PrintError(hr, "myLoadECString(iRCTitle)");
        }
        else if (NULL != pwszTitleInsert)
        {
            // replace %1
            if (FormatMessage(
                         FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_STRING |
                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         pwszTitle,
                         0,
                         0,
                         reinterpret_cast<WCHAR *>(&pwszExpandedTitle),
                         0,
                         reinterpret_cast<va_list *>
                             (const_cast<WCHAR **>(&pwszTitleInsert))) )
            {
                CSASSERT(NULL != pwszExpandedTitle);
                // free title with %1
                LocalFree(pwszTitle);
                pwszTitle = pwszExpandedTitle;
                pwszExpandedTitle = NULL;
            }
        }
    }

    if (0 != iRCFilter)
    {
        // load filter
        hr = myLoadRCString(hInstance, iRCFilter, &pwszFilter);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszFilter);
            _PrintError(hr, "myLoadECString(iRCFilter)");
        }
        if (NULL == pwszFilter)
        {
            //point to empty one
            pwszFilter = wszEmptyFilter;
        }
        else
        {
            hr = myFixupRCFilterString(pwszFilter);
            _JumpIfError(hr, error , "myFixupRCFilterString");
        }
    }

    if (0 != iRCDefExt)
    {
        // load default extension
        hr = myLoadRCString(hInstance, iRCDefExt, &pwszDefExt);
        if (S_OK != hr)
        {
            CSASSERT(NULL == pwszDefExt);
            _PrintError(hr, "myLoadECString(iRCDefExt)");
        }
    }

    ofn.lStructSize = CCSIZEOF_STRUCT(OPENFILENAME, lpTemplateName);
    ofn.hwndOwner = hwndOwner;
    ofn.hInstance = hInstance;
    ofn.lpstrTitle = pwszTitle;
    ofn.lpstrFilter = pwszFilter;
    ofn.lpstrDefExt = pwszDefExt;
    ofn.Flags = Flags;
    ofn.lpstrFile = wszFileName;  // for out
    ofn.nMaxFile = ARRAYSIZE(wszFileName);

    if (NULL != pwszDefaultFile)
    {
        // analysis of default directory and file
        dwFileAttr = GetFileAttributes(pwszDefaultFile);
        if (0xFFFFFFFF == dwFileAttr &&
            HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != (hr = myHLastError()) )
        {
            // error, ignore, pop up file dialog without defaults
            _PrintError(hr, "GetFileAttributes");
        }
        else
        {
            if (0xFFFFFFFF != dwFileAttr &&
                FILE_ATTRIBUTE_DIRECTORY & dwFileAttr)
            {
                // only pass a dircetory path
                ofn.lpstrInitialDir = pwszDefaultFile;
            }
            else
            {
                // full path
                pwszFilePortion = NULL; // init
                if (0 == GetFullPathName(
                             pwszDefaultFile,
                             ARRAYSIZE(wszPath),
                             wszPath,
                             &pwszFilePortion) )
                {
                    // error, ignore
                    hr = myHLastError();
                    _PrintError(hr, "GetFullPathName");
                }
                else
                {
                    if (NULL != pwszFilePortion)
                    {
                        wcscpy(wszFileName, pwszFilePortion);
                    }
                    *pwszFilePortion = L'\0'; // make init dir
                    ofn.lpstrInitialDir = wszPath;
                }
            }
                
        }
    }

    if (fOpen)
    {
        fGetFile = GetOpenFileName(&ofn);
    }
    else
    {
        fGetFile = GetSaveFileName(&ofn);
    }

    if (!fGetFile)
    {
        hr = CommDlgExtendedError();
        if (S_OK == hr)
        {
            // cancel would make Get?FileName return FALSE but no error
            goto done;
        }
        _JumpError(hr, error, "GetOpenFileName");
    }

    // ok get file name

    hr = myDupString(wszFileName, ppwszFile);
    _JumpIfError(hr, error, "myDupString");

done:
    hr = S_OK;
error:
    if (NULL != pwszTitle)
    {
        LocalFree(pwszTitle);
    }
    if (NULL != pwszExpandedTitle)
    {
        LocalFree(pwszExpandedTitle);
    }
    if (NULL != pwszFilter && pwszFilter != wszEmptyFilter)
    {
        LocalFree(pwszFilter);
    }
    if (NULL != pwszDefExt)
    {
        LocalFree(pwszDefExt);
    }
    return hr;
}

HRESULT
myGetOpenFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    TRUE,    // open file
                    iRCTitle,
                    NULL,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}

HRESULT
myGetSaveFileName(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    FALSE,    // save file
                    iRCTitle,
                    NULL,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}

HRESULT
myGetOpenFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    TRUE,    // open file
                    iRCTitle,
                    pwszTitleInsert,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}

HRESULT
myGetSaveFileNameEx(
    IN HWND                  hwndOwner,
    IN HINSTANCE             hInstance,
    OPTIONAL IN int          iRCTitle,
    OPTIONAL IN WCHAR const *pwszTitleInsert,
    OPTIONAL IN int          iRCFilter,
    OPTIONAL IN int          iRCDefExt,
    OPTIONAL IN DWORD        Flags,
    OPTIONAL IN WCHAR const *pwszDefaultFile,
    OUT WCHAR              **ppwszFile)
{
    return myGetFileName(
                    hwndOwner,
                    hInstance,
                    FALSE,    // save file
                    iRCTitle,
                    pwszTitleInsert,
                    iRCFilter,
                    iRCDefExt,
                    Flags,
                    pwszDefaultFile,
                    ppwszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\crypt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crypt.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include <winldap.h>

#include "csdisp.h"
#include "cscsp.h"
#include "csprop.h"
#include "csber.h"
#include "csldap.h"

#define __dwFILE__	__dwFILE_CERTLIB_CRYPT_CPP__


HRESULT
myGenerateKeys(
    IN WCHAR const *pwszContainer,
    OPTIONAL IN WCHAR const *pwszProvName,
    IN DWORD dwFlags,
    IN BOOL fMachineKeySet,
    IN DWORD dwKeySpec,
    IN DWORD dwProvType,
    IN DWORD dwKeySize,
    OUT HCRYPTPROV *phProv)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;

    *phProv = NULL;

    if (fMachineKeySet)
    {
	dwFlags |= CRYPT_MACHINE_KEYSET;
    }

    // see if the container already exists

    if (CryptAcquireContext(
			phProv,
			pwszContainer,
			pwszProvName,
			dwProvType,
			dwFlags))
    {
	if (NULL != *phProv)
	{
	    CryptReleaseContext(*phProv, 0);
	    *phProv = NULL;
	}

        // container exists -- remove old keys and generate new ones.

        if (!CryptAcquireContext(
			    phProv,
			    pwszContainer,
			    pwszProvName,
			    dwProvType,
			    CRYPT_DELETEKEYSET | dwFlags))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptAcquireContextEx");
        }
    }

    // create new container

    if (!CryptAcquireContext(
                        phProv,
                        pwszContainer,
			pwszProvName,
                        dwProvType,
                        CRYPT_NEWKEYSET | dwFlags)) // force new container
    {
        hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContextEx");
    }

    // create keys

    if (!CryptGenKey(*phProv, dwKeySpec, dwKeySize << 16, &hKey))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenKey");
    }
    hr = S_OK;

error:
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    return(hr);
}


HRESULT
myCryptExportPrivateKey(
    IN HCRYPTKEY hKey,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey)
{
    HRESULT hr;
    BYTE *pbKey = NULL;

    *ppbKey = NULL;

    // export the key set to a CAPI blob

    if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, NULL, pcbKey))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "CryptExportKey", NTE_BAD_KEY_STATE);
    }

    pbKey = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbKey);
    if (NULL == pbKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportKey(hKey, NULL, PRIVATEKEYBLOB, 0, pbKey, pcbKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptExportKey");
    }

    *ppbKey = pbKey;
    pbKey = NULL;
    hr = S_OK;

error:
    if (NULL != pbKey)
    {
	LocalFree(pbKey);
    }
    return(hr);
}


HRESULT
myVerifyPublicKeyFromHProv(
    IN HCRYPTPROV hProv,
    IN DWORD dwKeySpec,
    IN OPTIONAL CERT_CONTEXT const *pCert,
    IN BOOL fV1Cert,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OPTIONAL OUT BOOL *pfMatchingKey)
{
    HRESULT hr;
    DWORD cb;
    CERT_PUBLIC_KEY_INFO *pPublicKeyInfoExported = NULL;

    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = FALSE;
    }
    if (!myCryptExportPublicKeyInfo(
				hProv,
				dwKeySpec,
				CERTLIB_USE_LOCALALLOC,
				&pPublicKeyInfoExported,
				&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptExportPublicKeyInfo");
    }

    if (NULL == pPublicKeyInfo)
    {
	if (NULL == pCert)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "No cert & no SubjectPublicKeyInfo");
	}
	pPublicKeyInfo = &pCert->pCertInfo->SubjectPublicKeyInfo;
    }
    if (!myCertComparePublicKeyInfo(
			    X509_ASN_ENCODING,
			    fV1Cert,
			    pPublicKeyInfoExported,
			    pPublicKeyInfo))
    {
	// by design, (my)CertComparePublicKeyInfo doesn't set last error!

	hr = NTE_BAD_KEY;
	_JumpError(hr, error, "myCertComparePublicKeyInfo");
    }
    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = TRUE;
    }
    hr = S_OK;

error:
    if (NULL != pPublicKeyInfoExported)
    {
	LocalFree(pPublicKeyInfoExported);
    }
    return(hr);
}


HRESULT
myVerifyPublicKey(
    IN OPTIONAL CERT_CONTEXT const *pCert,
    IN BOOL fV1Cert,
    IN OPTIONAL CRYPT_KEY_PROV_INFO const *pKeyProvInfo,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    OPTIONAL OUT BOOL *pfMatchingKey)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    DWORD dwKeySpec;

    if (NULL != pfMatchingKey)
    {
	*pfMatchingKey = FALSE;
    }
    if (NULL == pCert ||
	!CryptAcquireCertificatePrivateKey(
				    pCert,
				    0,		// dwFlags
				    NULL,	// pvReserved
				    &hProv,
				    &dwKeySpec,
				    NULL))	// pfCallerFreeProv
    {
        if (NULL != pKeyProvInfo)
        {
            // ok, try passed kpi

            if (!myCertSrvCryptAcquireContext(
		&hProv,
		pKeyProvInfo->pwszContainerName,
		pKeyProvInfo->pwszProvName,
		pKeyProvInfo->dwProvType,
		~CRYPT_MACHINE_KEYSET & pKeyProvInfo->dwFlags,
		(CRYPT_MACHINE_KEYSET & pKeyProvInfo->dwFlags)? TRUE : FALSE))
	    {
                hr = myHLastError();
                _JumpErrorStr(
			hr,
			error,
			"myCertSrvCryptAcquireContextEx",
			pKeyProvInfo->pwszContainerName);
            }
            dwKeySpec = pKeyProvInfo->dwKeySpec;
        }
        else if (NULL != pCert)
	{
            hr = myHLastError();
            _JumpError(hr, error, "CryptAcquireCertificatePrivateKey");
	}
	else
        {
	    hr = E_POINTER;
	    _JumpError(hr, error, "No cert & no KeyProvInfo");
        }
    }
    hr = myVerifyPublicKeyFromHProv(
			    hProv,
			    dwKeySpec,
			    pCert,
			    fV1Cert,
			    pPublicKeyInfo,
			    pfMatchingKey);
    _JumpIfError(hr, error, "myVerifyPublicKeyFromHProv");

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


DWORD
myASNGetDataIndex(
    IN BYTE bBERTag,
    IN DWORD iStart,
    IN BYTE const *pb,
    IN DWORD cb,
    OUT DWORD *pdwLen)
{
    DWORD iData = MAXDWORD;

    pb += iStart;
    if (iStart + 2 <= cb && bBERTag == pb[0])
    {
	DWORD cbLen = 0;

	if (0x7f >= pb[1])
	{
	    *pdwLen = pb[1];
	    cbLen = 1;
	}
	else if (iStart + 3 <= cb && 0x81 == pb[1])
	{
	    *pdwLen = pb[2];
	    cbLen = 2;
	}
	else if (iStart + 4 <= cb && 0x82 == pb[1])
	{
	    *pdwLen = (pb[2] << 8) | pb[3];
	    cbLen = 3;
	}
	if (0 != cbLen &&
	    iStart + cbLen + *pdwLen <= cb)
	{
	    iData = iStart + 1 + cbLen;
	}
    }
    return(iData);
}


DWORD
myASNStoreLength(
    IN DWORD dwLen,
    IN OUT BYTE *pb,
    IN DWORD cb)
{
    DWORD cbLen = MAXDWORD;

    if (1 <= cb && 0x7f >= dwLen)
    {
	pb[0] = (BYTE) dwLen;
	cbLen = 1;
    }
    else if (2 <= cb && 0xff >= dwLen)
    {
	pb[0] = 0x81;
	pb[1] = (BYTE) dwLen;
	cbLen = 2;
    }
    else if (3 <= cb && 0xffff >= dwLen)
    {
	pb[0] = 0x82;
	pb[1] = (BYTE) (dwLen >> 8);
	pb[2] = (BYTE) dwLen;
	cbLen = 3;
    }
    return(cbLen);
}


// If this is a valid public key with a missing leading zero byte before the
// sign bit set in the first public key byte, add a zero byte and increment
// the lengths.  This canonicalizes the old incorrect V1 public key encoding
// used in EPF files.

HRESULT
myCanonicalizePublicKey(
    IN BYTE const *pbKeyIn,
    IN DWORD cbKeyIn,
    OUT BYTE **ppbKeyOut,
    OUT DWORD *pcbKeyOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    DWORD iDataSequence;
    DWORD dwLenSequence;
    DWORD iDataModulus;
    DWORD dwLenModulus;
    BYTE *pbKeyOut = NULL;
    DWORD cbKeyOut;
    BYTE *pb;
    DWORD cb;
    DWORD cbLen;

    *ppbKeyOut = NULL;

    iDataSequence = myASNGetDataIndex(
			    BER_SEQUENCE,
			    0,
			    pbKeyIn,
			    cbKeyIn,
			    &dwLenSequence);
    if (MAXDWORD == iDataSequence)
    {
	_JumpError(hr, error, "iDataSequence");
    }
    iDataModulus = myASNGetDataIndex(
			    BER_INTEGER,
			    iDataSequence,
			    pbKeyIn,
			    cbKeyIn,
			    &dwLenModulus);
    if (MAXDWORD == iDataModulus)
    {
	_JumpError(hr, error, "iDataModulus");
    }
    if (iDataSequence + dwLenSequence == cbKeyIn - 1 &&
	1 == pbKeyIn[cbKeyIn - 1])
    {
	cbKeyIn--;
    }
    if (0 == (0x80 & pbKeyIn[iDataModulus]))
    {
	_JumpError2(hr, error, "key sign", hr);
    }
    cbKeyOut = cbKeyIn + 1;
    pbKeyOut = (BYTE *) LocalAlloc(LMEM_FIXED, cbKeyOut);
    if (NULL == pbKeyOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pb = pbKeyOut;
    cb = cbKeyOut;

    // Set the sequence tag and new length:

    *pb++ = BER_SEQUENCE;
    cb--;
    cbLen = myASNStoreLength(dwLenSequence + 1, pb, cb);
    if (MAXDWORD == cbLen)
    {
	_JumpError(hr, error, "new dwLenSequence");
    }
    pb += cbLen;
    cb -= cbLen;

    // Set the modulus tag and new length:

    *pb++ = BER_INTEGER;
    cb--;
    cbLen = myASNStoreLength(dwLenModulus + 1, pb, cb);
    if (MAXDWORD == cbLen)
    {
	_JumpError(hr, error, "new dwLenModulus");
    }
    pb += cbLen;
    cb -= cbLen;

    *pb++ = 0;
    cb--;

    if (cb != cbKeyIn - (iDataModulus))
    {
	// crossed an encoding length boundary -- shouldn't happen!
	// new and old sequence and modulus lengths expected:
	//   0x10a <== 0x109, 0x101 <== 0x100
	//   0x89  <== 0x88,  0x81  <== 0x80
	//   0x48  <== 0x47,  0x41  <== 0x40

	_JumpError(hr, error, "new key length");
    }
    CopyMemory(pb, &pbKeyIn[iDataModulus], cb);

    *pcbKeyOut = cbKeyOut;
    *ppbKeyOut = pbKeyOut;
    pbKeyOut = NULL;
    hr = S_OK;

error:
    if (NULL != pbKeyOut)
    {
	LocalFree(pbKeyOut);
    }
    return(hr);
}


// If this is a valid public key with a proper leading zero byte before the
// sign bit set in the next public key byte, remove the zero byte and decrement
// the lengths.  This conforms to the old incorrect V1 public key encoding
// used in EPF files.

HRESULT
mySqueezePublicKey(
    IN BYTE const *pbKeyIn,
    IN DWORD cbKeyIn,
    OUT BYTE **ppbKeyOut,
    OUT DWORD *pcbKeyOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    DWORD iDataSequence;
    DWORD dwLenSequence;
    DWORD iDataModulus;
    DWORD dwLenModulus;
    BYTE *pbKeyOut = NULL;
    DWORD cbKeyOut;
    BYTE *pb;
    DWORD cb;
    DWORD cbLen;

    *ppbKeyOut = NULL;

    iDataSequence = myASNGetDataIndex(
			    BER_SEQUENCE,
			    0,
			    pbKeyIn,
			    cbKeyIn,
			    &dwLenSequence);
    if (MAXDWORD == iDataSequence)
    {
	_JumpError(hr, error, "iDataSequence");
    }
    iDataModulus = myASNGetDataIndex(
			    BER_INTEGER,
			    iDataSequence,
			    pbKeyIn,
			    cbKeyIn,
			    &dwLenModulus);
    if (MAXDWORD == iDataModulus)
    {
	_JumpError(hr, error, "iDataModulus");
    }
    if (0 != pbKeyIn[iDataModulus] ||
	0 == (0x80 & pbKeyIn[iDataModulus + 1]))
    {
	_JumpError(hr, error, "key sign");
    }
    cbKeyOut = cbKeyIn - 1;
    pbKeyOut = (BYTE *) LocalAlloc(LMEM_FIXED, cbKeyOut);
    if (NULL == pbKeyOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pb = pbKeyOut;
    cb = cbKeyOut;

    // Set the sequence tag and new length:

    *pb++ = BER_SEQUENCE;
    cb--;
    cbLen = myASNStoreLength(dwLenSequence - 1, pb, cb);
    if (MAXDWORD == cbLen)
    {
	_JumpError(hr, error, "new dwLenSequence");
    }
    pb += cbLen;
    cb -= cbLen;

    // Set the modulus tag and new length:

    *pb++ = BER_INTEGER;
    cb--;
    cbLen = myASNStoreLength(dwLenModulus - 1, pb, cb);
    if (MAXDWORD == cbLen)
    {
	_JumpError(hr, error, "new dwLenModulus");
    }
    pb += cbLen;
    cb -= cbLen;

    if (cb != cbKeyIn - (iDataModulus + 1))
    {
	// crossed an encoding length boundary -- shouldn't happen!
	// new and old sequence and modulus lengths expected:
	//   0x10a ==> 0x109, 0x101 ==> 0x100
	//   0x89  ==> 0x88,  0x81  ==> 0x80
	//   0x48  ==> 0x47,  0x41  ==> 0x40

	_JumpError(hr, error, "new key length");
    }
    CopyMemory(pb, &pbKeyIn[iDataModulus + 1], cb);

    *pcbKeyOut = cbKeyOut;
    *ppbKeyOut = pbKeyOut;
    pbKeyOut = NULL;
    hr = S_OK;

error:
    if (NULL != pbKeyOut)
    {
	LocalFree(pbKeyOut);
    }
    return(hr);
}


// by design, (my)CertComparePublicKeyInfo doesn't set last error!

BOOL
myCertComparePublicKeyInfo(
    IN DWORD dwCertEncodingType,
    IN BOOL fV1Cert,
    IN CERT_PUBLIC_KEY_INFO const *pPubKey1,
    IN CERT_PUBLIC_KEY_INFO const *pPubKey2)
{
    BOOL fMatch = FALSE;
    BYTE *pbKeyNew = NULL;

    if (CertComparePublicKeyInfo(
			dwCertEncodingType,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPubKey1),
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPubKey2)))
    {
	fMatch = TRUE;
	goto error;
    }

#if 0
    wprintf(L"pPubKey1:\n");
    DumpHex(
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pPubKey1->PublicKey.pbData,
	pPubKey1->PublicKey.cbData);

    wprintf(L"pPubKey2:\n");
    DumpHex(
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pPubKey2->PublicKey.pbData,
	pPubKey2->PublicKey.cbData);
#endif

    // If this is a V1 X509 cert with the sign bit set in the first public key
    // byte -- without a leading zero pad byte, and there's a wasted byte at
    // the end of the public key, squeeze out the leading zero byte from the
    // correctly encoded key, and compare the result.

    if (fV1Cert &&
	(pPubKey1->PublicKey.cbData == pPubKey2->PublicKey.cbData ||
	 pPubKey1->PublicKey.cbData == pPubKey2->PublicKey.cbData + 1))
    {
	HRESULT hr;
	CERT_PUBLIC_KEY_INFO PubKey1;
	CERT_PUBLIC_KEY_INFO PubKey2;

	PubKey1 = *pPubKey1;
	PubKey2 = *pPubKey2;

	hr = mySqueezePublicKey(
			PubKey1.PublicKey.pbData,
			PubKey1.PublicKey.cbData,
			&pbKeyNew,
			&PubKey1.PublicKey.cbData);
	_JumpIfError(hr, error, "mySqueezePublicKey");

	//PubKey1.PublicKey.cbData--;
	PubKey1.PublicKey.pbData = pbKeyNew;
	if (2 < PubKey2.PublicKey.cbData &&
	    PubKey2.PublicKey.cbData == 1 + PubKey1.PublicKey.cbData &&
	    1 == PubKey2.PublicKey.pbData[PubKey2.PublicKey.cbData - 1] &&
	    1 == PubKey2.PublicKey.pbData[PubKey2.PublicKey.cbData - 2])
	{
	    PubKey2.PublicKey.cbData--;
	}
#if 0
	wprintf(L"PubKey1:\n");
	DumpHex(
	    DH_NOADDRESS | DH_NOTABPREFIX | 8,
	    PubKey1.PublicKey.pbData,
	    PubKey1.PublicKey.cbData);

	wprintf(L"PubKey2:\n");
	DumpHex(
	    DH_NOADDRESS | DH_NOTABPREFIX | 8,
	    PubKey2.PublicKey.pbData,
	    PubKey2.PublicKey.cbData);
#endif
	if (CertComparePublicKeyInfo(
			    dwCertEncodingType,
			    &PubKey1,
			    &PubKey2))
	{
	    fMatch = TRUE;
	}
    }

error:
    if (NULL != pbKeyNew)
    {
	LocalFree(pbKeyNew);
    }
    return(fMatch);
}


BOOL
myCryptSignMessage(
    IN CRYPT_SIGN_MESSAGE_PARA const *pcsmp,
    IN BYTE const *pbToBeSigned,
    IN DWORD cbToBeSigned,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbSignedBlob,
    OUT DWORD *pcbSignedBlob)
{
    BOOL b;

    *ppbSignedBlob = NULL;
    *pcbSignedBlob = 0;
    for (;;)
    {
	b = CryptSignMessage(
			const_cast<CRYPT_SIGN_MESSAGE_PARA *>(pcsmp),
			TRUE,			// fDetachedSignature
			1,			// cToBeSigned
			&pbToBeSigned,		// rgpbToBeSigned
			&cbToBeSigned,		// rgcbToBeSigned
			*ppbSignedBlob,
			pcbSignedBlob);
	if (b && 0 == *pcbSignedBlob)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppbSignedBlob)
	    {
		myFree(*ppbSignedBlob, allocType);
		*ppbSignedBlob = NULL;
	    }
	    break;
	}
	if (NULL != *ppbSignedBlob)
	{
	    break;
	}
	*ppbSignedBlob = (BYTE *) myAlloc(*pcbSignedBlob, allocType);
	if (NULL == *ppbSignedBlob)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}


BOOL
myEncodeCert(
    IN DWORD dwEncodingType,
    IN CERT_SIGNED_CONTENT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_CERT,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeName(
    IN DWORD dwEncodingType,
    IN CERT_NAME_INFO const *pInfo,
    IN DWORD dwFlags,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_UNICODE_NAME,
		    pInfo,
		    dwFlags,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeKeyAttributes(
    IN DWORD dwEncodingType,
    IN CERT_KEY_ATTRIBUTES_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_KEY_ATTRIBUTES,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeKeyUsage(
    IN DWORD dwEncodingType,
    IN CRYPT_BIT_BLOB const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_KEY_USAGE,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN CERT_AUTHORITY_KEY_ID2_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_AUTHORITY_KEY_ID2,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}


BOOL
myEncodeToBeSigned(
    DWORD dwEncodingType,
    CERT_INFO const *pInfo,
    IN CERTLIB_ALLOCATOR allocType,
    BYTE **ppbEncoded,
    DWORD *pcbEncoded)
{
    return(myEncodeObject(
		    dwEncodingType,
		    X509_CERT_TO_BE_SIGNED,
		    pInfo,
		    0,
		    allocType,
		    ppbEncoded,
		    pcbEncoded));
}

BOOL
myDecodeName(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_NAME_INFO **ppNameInfo,
    OUT DWORD *pcbNameInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppNameInfo,
		    pcbNameInfo));
}


BOOL
myDecodeKeyAuthority(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID_INFO const **ppInfo,
    OUT DWORD *pcbInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    X509_AUTHORITY_KEY_ID,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


BOOL
myDecodeKeyAuthority2(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_AUTHORITY_KEY_ID2_INFO const **ppInfo,
    OUT DWORD *pcbInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    X509_AUTHORITY_KEY_ID2,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


BOOL
myDecodeExtensions(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_EXTENSIONS **ppInfo,
    OUT DWORD *pcbInfo)
{
    return(myDecodeObject(
		    dwEncodingType,
		    X509_NAME,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


BOOL
myDecodeKeyGenRequest(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CERT_KEYGEN_REQUEST_INFO **ppKeyGenRequest,
    OUT DWORD *pcbKeyGenRequest)
{
    return(myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_KEYGEN_REQUEST_TO_BE_SIGNED,
		    pbRequest,
		    cbRequest,
		    allocType,
		    (VOID **) ppKeyGenRequest,
		    pcbKeyGenRequest));
}


HRESULT
myDecodeCSPProviderAttribute(
    IN BYTE const *pbCSPEncoded,
    IN DWORD cbCSPEncoded,
    OUT CRYPT_CSP_PROVIDER **ppccp)
{
    HRESULT hr;
    CRYPT_SEQUENCE_OF_ANY *pCSPProviderSeq = NULL;
    DWORD cb;
    CRYPT_CSP_PROVIDER *pccp;
    DWORD dwKeySpec;
    CERT_NAME_VALUE *pName = NULL;
    CRYPT_BIT_BLOB *pBlob = NULL;
    BYTE *pb;

    *ppccp = NULL;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_SEQUENCE_OF_ANY,
		    pbCSPEncoded,
		    cbCSPEncoded,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pCSPProviderSeq,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (3 > pCSPProviderSeq->cValue)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Sequence count < 3");
    }

    dwKeySpec = 0;
    if (NULL != pCSPProviderSeq->rgValue[0].pbData &&
	0 != pCSPProviderSeq->rgValue[0].cbData)
    {
	cb = sizeof(dwKeySpec);
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pCSPProviderSeq->rgValue[0].pbData,
			pCSPProviderSeq->rgValue[0].cbData,
			0,
			&dwKeySpec,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptDecodeObject");
	}
    }
    if (NULL != pCSPProviderSeq->rgValue[1].pbData &&
	0 != pCSPProviderSeq->rgValue[1].cbData)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pCSPProviderSeq->rgValue[1].pbData,
			pCSPProviderSeq->rgValue[1].cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pName,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
    }
    if (NULL != pCSPProviderSeq->rgValue[2].pbData &&
	0 != pCSPProviderSeq->rgValue[2].cbData)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_BITS,
			pCSPProviderSeq->rgValue[2].pbData,
			pCSPProviderSeq->rgValue[2].cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pBlob,
			&cb))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myDecodeObject");
	}
    }
    cb = sizeof(*pccp);
    if (NULL != pName && NULL != pName->Value.pbData)
    {
	cb += POINTERROUND((wcslen((WCHAR const *) pName->Value.pbData) + 1) *
							    sizeof(WCHAR));
    }
    if (NULL != pBlob && NULL != pBlob->pbData)
    {
	cb += POINTERROUND(pBlob->cbData);
    }
    pccp = (CRYPT_CSP_PROVIDER *) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);
    if (NULL == pccp)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppccp = pccp;
    pb = (BYTE *) (pccp + 1);
    pccp->dwKeySpec = dwKeySpec;
    if (NULL != pName->Value.pbData)
    {
	pccp->pwszProviderName = (WCHAR *) pb;
	wcscpy(pccp->pwszProviderName, (WCHAR const *) pName->Value.pbData);
	pb += POINTERROUND((wcslen((WCHAR const *) pName->Value.pbData) + 1) *
							    sizeof(WCHAR));
    }
    if (NULL != pBlob && NULL != pBlob->pbData)
    {
	pccp->Signature.pbData = pb;
	pccp->Signature.cbData = pBlob->cbData;
	pccp->Signature.cUnusedBits = pBlob->cUnusedBits;
	CopyMemory(pccp->Signature.pbData, pBlob->pbData, pBlob->cbData);
    }
    hr = S_OK;

error:
    if (NULL != pCSPProviderSeq)
    {
	LocalFree(pCSPProviderSeq);
    }
    if (NULL != pName)
    {
	LocalFree(pName);
    }
    if (NULL != pBlob)
    {
	LocalFree(pBlob);
    }
    return(hr);
}


BOOL
myCertGetCertificateContextProperty(
    IN CERT_CONTEXT const *pCertContext,
    IN DWORD dwPropId,
    IN CERTLIB_ALLOCATOR allocType,
    OUT VOID **ppvData,
    OUT DWORD *pcbData)
{
    BOOL b;

    *ppvData = NULL;
    *pcbData = 0;
    for (;;)
    {
	b = CertGetCertificateContextProperty(
					 pCertContext,
					 dwPropId,
					 *ppvData,
					 pcbData);
	if (b && 0 == *pcbData)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppvData)
	    {
		myFree(*ppvData, allocType);
		*ppvData = NULL;
	    }
	    break;
	}
	if (NULL != *ppvData)
	{
	    break;
	}
	*ppvData = (VOID *) myAlloc(*pcbData, allocType);
	if (NULL == *ppvData)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}


HRESULT
myCertGetKeyProviderInfo(
    IN CERT_CONTEXT const *pCert,
    OUT CRYPT_KEY_PROV_INFO **ppkpi)
{
    HRESULT hr;
    DWORD cb;

    *ppkpi = NULL;

    if (!CertGetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					NULL,
					&cb))
    {
	hr = myHLastError();
	_JumpError2(
		hr,
		error,
		"CertGetCertificateContextProperty",
		CRYPT_E_NOT_FOUND);
    }

    *ppkpi = (CRYPT_KEY_PROV_INFO *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppkpi)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CertGetCertificateContextProperty(
					pCert,
					CERT_KEY_PROV_INFO_PROP_ID,
					*ppkpi,
					&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCryptExportKey(
    IN HCRYPTKEY hKey,
    IN HCRYPTKEY hKeyExp,
    IN DWORD dwBlobType,
    IN DWORD dwFlags,
    OUT BYTE **ppbKey,
    OUT DWORD *pcbKey)
{
    HRESULT hr;

    if (!CryptExportKey(hKey, hKeyExp, dwBlobType, dwFlags, NULL, pcbKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptExportKey");
    }

    *ppbKey = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbKey);
    if (NULL == *ppbKey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!CryptExportKey(hKey, hKeyExp, dwBlobType, dwFlags, *ppbKey, pcbKey))
    {
	hr = myHLastError();
	LocalFree(*ppbKey);
	*ppbKey = NULL;
	_JumpError(hr, error, "CryptExportKey");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCryptEncrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted)
{
    HRESULT hr;
    BYTE *pbEncrypted = NULL;
    DWORD cbEncrypted;
    DWORD cbAlloc;
    BOOL fRetried = FALSE;

    cbAlloc = cbIn + 64;	// may be enough to prevent overflow
    for (;;)
    {
	cbEncrypted = cbIn;
	pbEncrypted = (BYTE *) LocalAlloc(LMEM_FIXED, cbAlloc);
	if (NULL == pbEncrypted)
	{
	   hr = E_OUTOFMEMORY;
	   _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pbEncrypted, pbIn, cbIn);

	if (!CryptEncrypt(
		    hKey,
		    NULL,		// hHash
		    TRUE,		// Final
		    0,			// dwFlags
		    pbEncrypted,	// pbData
		    &cbEncrypted,	// pdwDataLen
		    cbAlloc))		// dwBufLen
	{
	    hr = myHLastError();
	    if (!fRetried && HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr)
	    {
                SecureZeroMemory(pbEncrypted, cbAlloc); // only zero size we alloced last time around
		LocalFree(pbEncrypted);
		pbEncrypted = NULL;
		DBGPRINT((
		    DBG_SS_CERTLIB,
		    "CryptEncrypt(MORE DATA): %u -> %u\n",
		    cbAlloc,
		    cbEncrypted));
		cbAlloc = cbEncrypted;
		fRetried = TRUE;
		continue;
	    }
	    _JumpError(hr, error, "CryptEncrypt");
	}
	break;
    }
    *ppbEncrypted = pbEncrypted;
    *pcbEncrypted = cbEncrypted;
    pbEncrypted = NULL;
    hr = S_OK;

error:
    if (NULL != pbEncrypted)
    {
	LocalFree(pbEncrypted);
    }
    return(hr);
}


HRESULT
myCryptDecrypt(
    IN HCRYPTKEY hKey,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    BYTE *pbDecrypted = NULL;
    DWORD cbDecrypted;

    // init
    *ppbDecrypted = NULL;
    *pcbDecrypted = 0;

    cbDecrypted = cbIn;
    pbDecrypted = (BYTE *) LocalAlloc(LMEM_FIXED, cbIn);
    if (NULL == pbDecrypted)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pbDecrypted, pbIn, cbIn);

    if (!CryptDecrypt(
		hKey,
		NULL,			// hHash
		TRUE,			// Final
		0,			// dwFlags
		pbDecrypted,		// pbData
		&cbDecrypted))		// pdwDataLen
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecrypt");
    }
    *ppbDecrypted = pbDecrypted;
    *pcbDecrypted = cbDecrypted;
    pbDecrypted = NULL;
    hr = S_OK;

error:
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    return(hr);
}


HRESULT
myCryptEncryptMessage(
    IN ALG_ID algId,
    IN DWORD cCertRecipient,
    IN CERT_CONTEXT const **rgCertRecipient,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN OPTIONAL HCRYPTPROV hCryptProv,
    OUT BYTE **ppbEncrypted,
    OUT DWORD *pcbEncrypted)
{
    HRESULT hr;
    CRYPT_ENCRYPT_MESSAGE_PARA cemp;
    CRYPT_OID_INFO const *pOidInfo;

    // Convert to an Object Id

    pOidInfo = CryptFindOIDInfo(
			CRYPT_OID_INFO_ALGID_KEY,
			&algId,
			CRYPT_ENCRYPT_ALG_OID_GROUP_ID);
    if (NULL == pOidInfo)
    {
        // function is not doc'd to set GetLastError()

        hr = CRYPT_E_NOT_FOUND;
	DBGPRINT((DBG_SS_ERROR, "algId = %x\n", algId));
        _JumpError(hr, error, "CryptFindOIDInfo");
    }

    // Encrypt the data with the public key

    ZeroMemory(&cemp, sizeof(cemp));
    cemp.cbSize = sizeof(cemp);
    cemp.dwMsgEncodingType = PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING;
    cemp.ContentEncryptionAlgorithm.pszObjId = const_cast<char *>(pOidInfo->pszOID);
    cemp.hCryptProv = hCryptProv;

    *pcbEncrypted = 0;
    for (;;)
    {
	if (!CryptEncryptMessage(
			    &cemp,
			    cCertRecipient,	// cRecipientCert
			    rgCertRecipient,	// rgpRecipientCert IN
			    pbIn,		// pbToBeEncrypted
			    cbIn,		// cbToBeEncrypted
			    *ppbEncrypted,	// pbEncryptedBlob
			    pcbEncrypted))	// pcbEncryptedBlob
	{
	    hr = myHLastError();
	    if (NULL != *ppbEncrypted)
	    {
		LocalFree(*ppbEncrypted);
		*ppbEncrypted = NULL;
	    }
	    _JumpError(hr, error, "CryptEncryptMessage");
	}
	if (NULL != *ppbEncrypted)
	{
	    break;
	}
	*ppbEncrypted = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncrypted);
	if (NULL == *ppbEncrypted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myCryptDecryptMessage(
    IN HCERTSTORE hStore,
    IN BYTE const *pbEncrypted,
    IN DWORD cbEncrypted,
    IN CERTLIB_ALLOCATOR allocType,
    OUT BYTE **ppbDecrypted,
    OUT DWORD *pcbDecrypted)
{
    HRESULT hr;
    CRYPT_DECRYPT_MESSAGE_PARA cdmp;

    ZeroMemory(&cdmp, sizeof(cdmp));
    cdmp.cbSize = sizeof(cdmp);
    cdmp.dwMsgAndCertEncodingType = PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    cdmp.cCertStore = 1;
    cdmp.rghCertStore = &hStore;

    *ppbDecrypted = NULL;
    *pcbDecrypted = 0;
    for (;;)
    {
	if (!CryptDecryptMessage(
			    &cdmp,
			    pbEncrypted,
			    cbEncrypted,
			    *ppbDecrypted,
			    pcbDecrypted,
			    NULL))	// ppXchgCert
	{
	    hr = myHLastError();
	    if (NULL != *ppbDecrypted)
	    {
		myFree(*ppbDecrypted, allocType);
		*ppbDecrypted = NULL;
	    }
	    _JumpError(hr, error, "CryptDecryptMessage");
	}
	if (NULL != *ppbDecrypted)
	{
	    break;
	}
	*ppbDecrypted = (BYTE *) myAlloc(*pcbDecrypted, allocType);
	if (NULL == *ppbDecrypted)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetInnerPKCS10(
    IN HCRYPTMSG hMsg,
    IN char const *pszInnerContentObjId,
    OUT CERT_REQUEST_INFO **ppRequest)
{
    HRESULT hr;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    CMC_DATA_INFO *pcmcData = NULL;
    DWORD cbcmcData;
    CMC_TAGGED_CERT_REQUEST const *pTaggedCertRequest;
    DWORD cbRequest;

    *ppRequest = NULL;

    if (0 != strcmp(pszInnerContentObjId, szOID_CT_PKI_DATA))
    {
	hr = CRYPT_E_INVALID_MSG_TYPE;
	_JumpError(hr, error, "Not a CMC request");
    }

    // Get the request content, then search for the PKCS10's public key.

    hr = myCryptMsgGetParam(
		    hMsg,
		    CMSG_CONTENT_PARAM,
		    0,
                    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pbContent,
		    &cbContent);
    _JumpIfError(hr, error, "myCryptMsgGetParam");

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    CMC_DATA,
		    pbContent,
		    cbContent,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcmcData,
		    &cbcmcData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (1 != pcmcData->cTaggedRequest ||
	CMC_TAGGED_CERT_REQUEST_CHOICE !=
	    pcmcData->rgTaggedRequest[0].dwTaggedRequestChoice)
    {
	hr = CRYPT_E_INVALID_MSG_TYPE;
	_JumpError(hr, error, "Must be 1 PKCS10");
    }
    pTaggedCertRequest = pcmcData->rgTaggedRequest[0].pTaggedCertRequest;

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_REQUEST_TO_BE_SIGNED,
		    pTaggedCertRequest->SignedCertRequest.pbData,
		    pTaggedCertRequest->SignedCertRequest.cbData,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppRequest,
		    &cbRequest))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pbContent)
    {
	LocalFree(pbContent);
    }
    if (NULL != pcmcData)
    {
	LocalFree(pcmcData);
    }
    return(hr);
}


HRESULT
myPKCSEncodeString(
    IN WCHAR const *pwsz,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE cnv;

    // encode the string as an IA5 string

    cnv.dwValueType = CERT_RDN_IA5_STRING;
    cnv.Value.pbData = (BYTE *) pwsz;
    cnv.Value.cbData = 0;	// Use L'\0' termination for the length

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_NAME_VALUE,
		    &cnv,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
error:
    return(hr);
}


HRESULT
myPKCSDecodeString(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr = S_OK;
    CERT_NAME_VALUE *pcnv = NULL;
    DWORD cbOut;

    *ppwszOut = NULL;

    // decode the string from an IA5 string

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_UNICODE_NAME_VALUE,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pcnv,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    if (CERT_RDN_IA5_STRING != pcnv->dwValueType)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Not an IA5 string");
    }
    cbOut = (wcslen((WCHAR const *) pcnv->Value.pbData) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cbOut);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pcnv->Value.pbData, cbOut);

error:
    if (NULL != pcnv)
    {
	LocalFree(pcnv);
    }
    return(hr);
}


HRESULT
myPKCSEncodeLong(
    IN LONG Value,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;

    // encode the long value

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    &Value,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
error:
    return(hr);
}


HRESULT
myPKCSDecodeLong(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT LONG **ppValue)
{
    HRESULT hr = S_OK;
    DWORD cbOut;

    // encode the long value

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_INTEGER,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppValue,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    CSASSERT(sizeof(**ppValue) == cbOut);
error:
    return(hr);
}


HRESULT
myPKCSEncodeDate(
    IN FILETIME const *pft,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;

    // encode the time value

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CHOICE_OF_TIME,
		    pft,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    ppbOut,
		    pcbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
error:
    return(hr);
}


HRESULT
myPKCSDecodeDate(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT FILETIME **ppftOut)
{
    HRESULT hr = S_OK;
    DWORD cbOut;

    // encode the time value

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_CHOICE_OF_TIME,
		    pbIn,
		    cbIn,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) ppftOut,
		    &cbOut))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    CSASSERT(sizeof(**ppftOut) == cbOut);
error:
    return(hr);
}


HRESULT
myEncodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr = E_INVALIDARG;

    // everyone assumes pbIn != NULL

    if (NULL == pbIn || 0 == cbIn)
    {
	_JumpError(hr, error, "NULL param");
    }

    switch (PROPTYPE_MASK & Flags)
    {
	case PROPTYPE_STRING:
	    if (0 == (PROPMARSHAL_LOCALSTRING & Flags) &&
		sizeof(WCHAR) <= cbIn)
	    {
		cbIn -= sizeof(WCHAR);
	    }
	    if (wcslen((WCHAR const *) pbIn) * sizeof(WCHAR) != cbIn)
	    {
		_JumpError(hr, error, "bad string len");
	    }
	    hr = myPKCSEncodeString((WCHAR const *) pbIn, ppbOut, pcbOut);
	    _JumpIfError(hr, error, "myPKCSEncodeString");

	    break;

	case PROPTYPE_LONG:
	    CSASSERT(sizeof(DWORD) == cbIn);
	    hr = myPKCSEncodeLong(*(DWORD const *) pbIn, ppbOut, pcbOut);
	    _JumpIfError(hr, error, "myPKCSEncodeLong");

	    break;

	case PROPTYPE_DATE:
	    CSASSERT(sizeof(FILETIME) == cbIn);
	    hr = myPKCSEncodeDate((FILETIME const *) pbIn, ppbOut, pcbOut);
	    _JumpIfError(hr, error, "myPKCSEncodeDate");

	    break;

	default:
	    _JumpError(hr, error, "variant type/value");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myDecodeExtension(
    IN DWORD Flags,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;

    switch (PROPTYPE_MASK & Flags)
    {
	case PROPTYPE_STRING:
	    hr = myPKCSDecodeString(pbIn, cbIn, (WCHAR **) ppbOut);
	    _JumpIfError(hr, error, "myPKCSDecodeString");

	    *pcbOut = wcslen((WCHAR const *) *ppbOut) * sizeof(WCHAR);
	    break;

	case PROPTYPE_LONG:
	    hr = myPKCSDecodeLong(pbIn, cbIn, (LONG **) ppbOut);
	    _JumpIfError(hr, error, "myPKCSDecodeLong");

	    *pcbOut = sizeof(LONG);
	    break;

	case PROPTYPE_DATE:
	    hr = myPKCSDecodeDate(pbIn, cbIn, (FILETIME **) ppbOut);
	    _JumpIfError(hr, error, "myPKCSDecodeDate");

	    *pcbOut = sizeof(FILETIME);
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Flags: Invalid type");
    }

error:
    return(hr);
}


// szOID_ENROLLMENT_NAME_VALUE_PAIR

BOOL
myDecodeNameValuePair(
    IN DWORD dwEncodingType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN CERTLIB_ALLOCATOR allocType,
    OUT CRYPT_ENROLLMENT_NAME_VALUE_PAIR **ppInfo,
    OUT DWORD *pcbInfo)
{

    return(myDecodeObject(
		    dwEncodingType,
		    szOID_ENROLLMENT_NAME_VALUE_PAIR,
		    pbEncoded,
		    cbEncoded,
		    allocType,
		    (VOID **) ppInfo,
		    pcbInfo));
}


//+-------------------------------------------------------------------------
// myVerifyObjIdA - verify the passed pszObjId is valid as per X.208
//
// Encode and Decode the Object Id and make sure it survives the round trip.
// The first number must be 0, 1 or 2.
// Enforce all characters are digits and dots.
// Enforce that no dot starts or ends the Object Id, and disallow double dots.
// Enforce there is at least one dot separator.
// If the first number is 0 or 1, the second number must be between 0 & 39.
// If the first number is 2, the second number can be any value.
//--------------------------------------------------------------------------

HRESULT
myVerifyObjIdA(
    IN CHAR const *pszObjId)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_ATTRIBUTE ainfo;
    CRYPT_ATTRIBUTE *painfo = NULL;
    DWORD cbainfo;
    char const *psz;
    int i;
    BOOL fNoisy = FALSE;

    hr = E_INVALIDARG;
    for (psz = pszObjId; '\0' != *psz; psz++)
    {
	// must be a digit or a dot separator

	if (!isdigit(*psz))
	{
	    if ('.' != *psz)
	    {
		_JumpError2(hr, error, "bad ObjId: bad char", hr);
	    }

	    // can't have dot at start, double dots or dot at end

	    if (psz == pszObjId || '.' == psz[1] || '\0' == psz[1])
	    {
		_JumpError2(hr, error, "bad ObjId: dot location", hr);
	    }
	}
    }
    psz = strchr(pszObjId, '.');
    if (NULL == psz)
    {
	_JumpError2(hr, error, "bad ObjId: must have at least one dot", hr);
    }
    i = atoi(pszObjId);
    switch (i)
    {
	case 0:
	case 1:
	    i = atoi(++psz);
	    if (0 > i || 39 < i)
	    {
		_JumpError(hr, error, "bad ObjId: 0. or 1. must be followed by 0..39");
	    }
	    break;

	case 2:
	    break;

	default:
	    fNoisy = TRUE;
	    _JumpError(hr, error, "bad ObjId: must start with 0, 1 or 2");
    }

    fNoisy = TRUE;
    ainfo.pszObjId = const_cast<char *>(pszObjId);
    ainfo.cValue = 0;
    ainfo.rgValue = NULL;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    &ainfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    pbEncoded,
		    cbEncoded,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &painfo,
		    &cbainfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }

    if (0 != strcmp(pszObjId, painfo->pszObjId))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad ObjId: decode mismatch");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	DBGPRINT((
	    fNoisy? DBG_SS_CERTLIB : DBG_SS_CERTLIBI,
	    "myVerifyObjIdA(%hs): %x\n",
	    pszObjId,
	    hr));
    }
    if (NULL != pbEncoded)
    {
    	LocalFree(pbEncoded);
    }
    if (NULL != painfo)
    {
    	LocalFree(painfo);
    }
    return(hr);
}


HRESULT
myVerifyObjId(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
    CHAR *pszObjId = NULL;

    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToSz");
    }
    hr = myVerifyObjIdA(pszObjId);
    _JumpIfErrorStr2(hr, error, "myVerifyObjIdA", pwszObjId, E_INVALIDARG);

error:
    if (NULL != pszObjId)
    {
    	LocalFree(pszObjId);
    }
    return(hr);
}


// The returned pszObjId is a constant that must not be freed.  CryptFindOIDInfo
// has a static internal database that is valid until crypt32.dll is unloaded.

#define GON_GROUP	0x00000001
#define GON_GENERIC	0x00000002

typedef struct _OIDNAME
{
    char const *pszObjId;
    WCHAR const *pwszDisplayName;
} OIDNAME;

#if DBG
#define wszCERTLIB	L"(certlib)"
#else
#define wszCERTLIB	L""
#endif

OIDNAME s_aOIDName[] = {
    { szOID_CT_PKI_DATA,		L"CMC Data" wszCERTLIB, },
    { szOID_CT_PKI_RESPONSE,		L"CMC Response" wszCERTLIB, },
    { szOID_CMC,			L"Unsigned CMC Request" wszCERTLIB, },
    { szOID_CMC_TRANSACTION_ID,		L"Transaction Id" wszCERTLIB, },
    { szOID_CMC_SENDER_NONCE,		L"Sender Nonce" wszCERTLIB, },
    { szOID_CMC_RECIPIENT_NONCE,	L"Recipient Nonce" wszCERTLIB, },
    { szOID_CMC_REG_INFO,		L"Reg Info" wszCERTLIB, },
    { szOID_CMC_GET_CERT,		L"Get Certificate" wszCERTLIB, },
    { szOID_CMC_GET_CRL,		L"Get CRL" wszCERTLIB, },
    { szOID_CMC_REVOKE_REQUEST,		L"Revoke Request" wszCERTLIB, },
    { szOID_CMC_QUERY_PENDING,		L"Query Pending" wszCERTLIB, },
    { szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE, L"Confirm Certificate Acceptance" wszCERTLIB, },
    { szOID_CMC_STATUS_INFO,		L"Unsigned CMC Response" wszCERTLIB, },
    { szOID_CMC_ADD_EXTENSIONS,		L"CMC Extensions" wszCERTLIB, },
    { szOID_CMC_ADD_ATTRIBUTES,		L"CMC Attributes" wszCERTLIB, },
    { szOID_VERISIGN_ONSITE_JURISDICTION_HASH, L"Jurisdiction Hash" wszCERTLIB, },
    { szOID_PKCS_7_DATA,		L"PKCS 7 Data" wszCERTLIB, },
    { szOID_ARCHIVED_KEY_ATTR,		L"Archived Key" wszCERTLIB, },
    { szOID_CTL,			L"Certifcate Trust List" wszCERTLIB, },
    { szOID_ARCHIVED_KEY_CERT_HASH,	L"Archived Key Certificate Hash" wszCERTLIB, },
    { szOID_ROOT_LIST_SIGNER,		L"Root List Signer" wszCERTLIB, },
    { szOID_PRIVATEKEY_USAGE_PERIOD,	L"Private Key Usage Period" wszCERTLIB, },
    { szOID_REQUEST_CLIENT_INFO,	L"Client Information" wszCERTLIB, },
    { szOID_NTDS_REPLICATION,	        L"DS object Guid" wszCERTLIB, },
    { szOID_CERTSRV_CROSSCA_VERSION,	L"Cross CA Version" wszCERTLIB, },
};


WCHAR const *
myGetOIDNameA(
    IN char const *pszObjId)
{
    CRYPT_OID_INFO const *pInfo = NULL;
    WCHAR const *pwszName = L"";
    DWORD Flags = GON_GROUP | GON_GENERIC;

    if ('+' == *pszObjId)
    {
	Flags = GON_GROUP;	// Group lookup only
	pszObjId++;
    }
    else
    if ('-' == *pszObjId)
    {
	Flags = GON_GENERIC;	// Generic lookup only
	pszObjId++;
    }

    // First try looking up the ObjectId as an Extension or Attribute, because
    // we get a better Display Name, especially for Subject RDNs: CN, L, etc.
    // If that fails, look it up without restricting the group.

    if (GON_GROUP & Flags)
    {
	pInfo = CryptFindOIDInfo(
			    CRYPT_OID_INFO_OID_KEY,
			    (VOID *) pszObjId,
			    CRYPT_EXT_OR_ATTR_OID_GROUP_ID);
    }
    if ((GON_GENERIC & Flags) &&
	(NULL == pInfo ||
	 NULL == pInfo->pwszName ||
	 L'\0' == pInfo->pwszName[0]))
    {
	pInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, (VOID *) pszObjId, 0);
    }
    if (NULL != pInfo && NULL != pInfo->pwszName && L'\0' != pInfo->pwszName[0])
    {
	pwszName = pInfo->pwszName;
    }
    else
    {
	OIDNAME const *pOIDName;

	for (pOIDName = s_aOIDName;
	     pOIDName < &s_aOIDName[ARRAYSIZE(s_aOIDName)];
	     pOIDName++)
	{
	    if (0 == strcmp(pOIDName->pszObjId, pszObjId))
	    {
		pwszName = pOIDName->pwszDisplayName;
		break;
	    }
	}
    }
    return(pwszName);
}


WCHAR const *
myGetOIDName(
    IN WCHAR const *pwszObjId)
{
    char *pszObjId = NULL;
    WCHAR const *pwszName = L"";

    if (!ConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	_JumpError(E_OUTOFMEMORY, error, "ConvertWszToSz");
    }
    pwszName = myGetOIDNameA(pszObjId);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(pwszName);
}


typedef struct _DUMPFLAGS
{
    DWORD Mask;
    DWORD Value;
    WCHAR const *pwszDescription;
} DUMPFLAGS;


#define _DFBIT(def)		{ (def), (def), L#def }
#define _DFBIT2(mask, def)	{ (mask), (def), L#def }


DUMPFLAGS g_adfErrorStatus[] =
{
    _DFBIT(CERT_TRUST_IS_NOT_TIME_VALID),
    _DFBIT(CERT_TRUST_IS_NOT_TIME_NESTED),
    _DFBIT(CERT_TRUST_IS_REVOKED),
    _DFBIT(CERT_TRUST_IS_NOT_SIGNATURE_VALID),
    _DFBIT(CERT_TRUST_IS_NOT_VALID_FOR_USAGE),
    _DFBIT(CERT_TRUST_IS_UNTRUSTED_ROOT),
    _DFBIT(CERT_TRUST_REVOCATION_STATUS_UNKNOWN),
    _DFBIT(CERT_TRUST_IS_CYCLIC),

    _DFBIT(CERT_TRUST_INVALID_EXTENSION),
    _DFBIT(CERT_TRUST_INVALID_POLICY_CONSTRAINTS),
    _DFBIT(CERT_TRUST_INVALID_BASIC_CONSTRAINTS),
    _DFBIT(CERT_TRUST_INVALID_NAME_CONSTRAINTS),
    _DFBIT(CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT),
    _DFBIT(CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT),
    _DFBIT(CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT),
    _DFBIT(CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT),

    _DFBIT(CERT_TRUST_IS_OFFLINE_REVOCATION),
    _DFBIT(CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY),

    _DFBIT(CERT_TRUST_IS_PARTIAL_CHAIN),
    _DFBIT(CERT_TRUST_CTL_IS_NOT_TIME_VALID),
    _DFBIT(CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID),
    _DFBIT(CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE),

    { 0, 0, NULL }
};

DUMPFLAGS g_adfInfoStatus[] =
{
    _DFBIT(CERT_TRUST_HAS_EXACT_MATCH_ISSUER),
    _DFBIT(CERT_TRUST_HAS_KEY_MATCH_ISSUER),
    _DFBIT(CERT_TRUST_HAS_NAME_MATCH_ISSUER),
    _DFBIT(CERT_TRUST_IS_SELF_SIGNED),

    _DFBIT(CERT_TRUST_HAS_PREFERRED_ISSUER),
    _DFBIT(CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY),
    _DFBIT(CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS),

    _DFBIT(CERT_TRUST_IS_COMPLEX_CHAIN),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfChainFlags[] =
{
    _DFBIT(CERT_CHAIN_CACHE_END_CERT),
    _DFBIT(CERT_CHAIN_THREAD_STORE_SYNC),
    _DFBIT(CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL),
    _DFBIT(CERT_CHAIN_USE_LOCAL_MACHINE_STORE),
    _DFBIT(CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE),
    _DFBIT(CERT_CHAIN_ENABLE_SHARE_STORE),
    _DFBIT(CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING),
    _DFBIT(CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS),
    _DFBIT(CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE),
    _DFBIT(CERT_CHAIN_TIMESTAMP_TIME),
    _DFBIT(CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT),
    _DFBIT(CERT_CHAIN_REVOCATION_CHECK_END_CERT),
    _DFBIT(CERT_CHAIN_REVOCATION_CHECK_CHAIN),
    _DFBIT(CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT),
    _DFBIT(CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY),
    { 0, 0, NULL }
};

DUMPFLAGS g_adfVerifyFlags[] =
{
    _DFBIT(CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT),
    _DFBIT(CA_VERIFY_FLAGS_IGNORE_OFFLINE),
    _DFBIT(CA_VERIFY_FLAGS_NO_REVOCATION),
    _DFBIT(CA_VERIFY_FLAGS_FULL_CHAIN_REVOCATION),
    _DFBIT(CA_VERIFY_FLAGS_NT_AUTH),
    _DFBIT(CA_VERIFY_FLAGS_IGNORE_INVALID_POLICIES),
    _DFBIT(CA_VERIFY_FLAGS_IGNORE_NOREVCHECK),
    _DFBIT(CA_VERIFY_FLAGS_DUMP_CHAIN),
    _DFBIT(CA_VERIFY_FLAGS_SAVE_CHAIN),
    { 0, 0, NULL }
};


VOID
DumpFlags(
    IN DWORD Flags,
    IN WCHAR const *pwsz,
    IN DUMPFLAGS const *pdf)
{
    for ( ; NULL != pdf->pwszDescription; pdf++)
    {
	if ((Flags & pdf->Mask) == pdf->Value)
	{
	    CONSOLEPRINT3((
		    MAXDWORD,
		    "%ws = %ws (0x%x)\n",
		    pwsz,
		    pdf->pwszDescription,
		    pdf->Value));
	}
    }
}


VOID
DumpUsage(
    IN WCHAR const *pwsz,
    OPTIONAL IN CERT_ENHKEY_USAGE const *pUsage)
{
    DWORD i;

    if (NULL != pUsage)
    {
	for (i = 0; i < pUsage->cUsageIdentifier; i++)
	{
	    CONSOLEPRINT4((
		    MAXDWORD,
		    "%ws[%u] = %hs %ws\n",
		    pwsz,
		    i,
		    pUsage->rgpszUsageIdentifier[i],
		    myGetOIDNameA(pUsage->rgpszUsageIdentifier[i])));
	}
    }
}


HRESULT
WriteBlob(
    IN FILE *pf,
    IN BYTE const *pb,
    IN DWORD cb,
    IN DWORD Flags)
{
    HRESULT hr;
    char *pszBase64 = NULL;

    hr = myCryptBinaryToStringA(
		    pb,
		    cb,
		    Flags | CRYPT_STRING_NOCR,
		    &pszBase64);
    _JumpIfError(hr, error, "myCryptBinaryToStringA");

    fputs(pszBase64, pf);
    fflush(pf);
    if (ferror(pf))
    {
	hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
	_JumpError(hr, error, "fputs");
    }
    hr = S_OK;

error:
    if (NULL != pszBase64)
    {
	LocalFree(pszBase64);
    }
    return(hr);
}


DWORD
myCRLNumber(
    IN CRL_CONTEXT const *pCRL)
{
    HRESULT hr;
    CERT_EXTENSION const *pExt;
    DWORD CRLNumber = 0;
    DWORD dw;
    DWORD cb;

    pExt = CertFindExtension(
			szOID_CRL_NUMBER,
			pCRL->pCrlInfo->cExtension,
			pCRL->pCrlInfo->rgExtension);
    if (NULL == pExt)
    {
	// This API doesn't set LastError
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "CertFindExtension(CRLNumber)");
    }
    cb = sizeof(dw);
    dw = 0;
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pExt->Value.pbData,
			pExt->Value.cbData,
			0,
			&dw,
			&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    CRLNumber = dw;

error:
    return(CRLNumber);
}


VOID
WriteChain(
    IN CERT_SIMPLE_CHAIN const *pChain,
    IN DWORD SaveIndex,
    IN DWORD ChainIndex)
{
    HRESULT hr;
#define szCHAINFORMAT	"Chain%d_%d.txt"
    char szPath[MAX_PATH + ARRAYSIZE(szCHAINFORMAT) + 2 * cwcDWORDSPRINTF];
    DWORD i;
    FILE *pf = NULL;
    DWORD cch;

    cch = GetEnvironmentVariableA("temp", szPath, MAX_PATH);
    if (0 == cch || MAX_PATH <= cch)
    {
	strcpy(szPath, "\\");
    }
    i = strlen(szPath);
    if (0 == i || '\\' != szPath[i - 1])
    {
	szPath[i++] = '\\';
    }
    sprintf(&szPath[i], szCHAINFORMAT, SaveIndex, ChainIndex);
    pf = fopen(szPath, "w");
    if (NULL == pf)
    {
	hr = errno;
	_JumpError(hr, error, "fopen");
    }
    for (i = 0; i < pChain->cElement; i++)
    {
	CERT_CHAIN_ELEMENT const *pElement = pChain->rgpElement[i];
	CERT_REVOCATION_INFO *pRevocationInfo;

	if (0 < i)
	{
	    fputs("\n", pf);
	}
	fprintf(pf, "Certificate %d:\n", i);

	hr = WriteBlob(
		    pf,
		    pElement->pCertContext->pbCertEncoded,
		    pElement->pCertContext->cbCertEncoded,
		    CRYPT_STRING_BASE64HEADER);
	_JumpIfError(hr, error, "WriteBlob");

	pRevocationInfo = pElement->pRevocationInfo;

	if (NULL != pRevocationInfo &&
	    CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		pRevocationInfo->cbSize &&
	    NULL != pRevocationInfo->pCrlInfo)
	{
	    CERT_REVOCATION_CRL_INFO *pCrlInfo;

	    pCrlInfo = pRevocationInfo->pCrlInfo;
	    if (NULL != pCrlInfo)
	    {
		if (NULL != pCrlInfo->pBaseCrlContext)
		{
		    fprintf(
			pf,
			"\nCRL %u:\n",
			myCRLNumber(pCrlInfo->pBaseCrlContext));
		    hr = WriteBlob(
				pf,
				pCrlInfo->pBaseCrlContext->pbCrlEncoded,
				pCrlInfo->pBaseCrlContext->cbCrlEncoded,
				CRYPT_STRING_BASE64X509CRLHEADER);
		    _JumpIfError(hr, error, "WriteBlob");
		}
		if (NULL != pCrlInfo->pDeltaCrlContext)
		{
		    fprintf(
			pf,
			"\nDelta CRL %u:\n",
			myCRLNumber(pCrlInfo->pDeltaCrlContext));
		    hr = WriteBlob(
				pf,
				pCrlInfo->pDeltaCrlContext->pbCrlEncoded,
				pCrlInfo->pDeltaCrlContext->cbCrlEncoded,
				CRYPT_STRING_BASE64X509CRLHEADER);
		    _JumpIfError(hr, error, "WriteBlob");
		}
	    }
	}
    }

error:
    if (NULL != pf)
    {
	fclose(pf);
    }
}


HRESULT
DumpChainOpenHash(
    OUT HCRYPTPROV *phProv,
    OUT HCRYPTHASH *phHash)
{
    HRESULT hr;

    *phProv = NULL;
    *phHash = NULL;
    if (!CryptAcquireContext(
		    phProv,
		    NULL,		// container
		    MS_DEF_PROV,
		    PROV_RSA_FULL,
		    CRYPT_VERIFYCONTEXT))
    {
	*phProv = NULL;
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (!CryptCreateHash(*phProv, CALG_SHA1, 0, 0, phHash))
    {
	*phHash = NULL;
	hr = myHLastError();
	_JumpError(hr, error, "CryptCreateHash");
    }
    hr = S_OK;

error:
    if (S_OK != hr && NULL != *phProv)
    {
	if (!CryptReleaseContext(*phProv, 0))
	{
	    HRESULT hr2 = myHLastError();

	    _PrintError(hr, "CryptReleaseContext");
	    if (hr == S_OK)
	    {
		hr = hr2;
	    }
	}
	*phProv = NULL;
    }
    return(hr);
}


VOID
DumpChainName(
    IN char const *pszType,
    IN CERT_NAME_BLOB const *pName)
{
    HRESULT hr;
    WCHAR *pwsz;

    pwsz = NULL;
    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		pName,
		CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
		&pwsz);
    _PrintIfError(hr, "myCertNameToStr");
    if (NULL != pwsz)
    {
	CONSOLEPRINT2((MAXDWORD, "%hs: %ws\n", pszType, pwsz));
	LocalFree(pwsz);
    }
}


HRESULT
DumpChainSerial(
    IN char const *pszType,
    IN CRYPT_INTEGER_BLOB const *pSerial)
{
    HRESULT hr;
    BSTR strSerial = NULL;

    hr = MultiByteIntegerToBstr(
			    FALSE,
			    pSerial->cbData,
			    pSerial->pbData,
			    &strSerial);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    CONSOLEPRINT2((MAXDWORD, "%hs: %ws\n", pszType, strSerial));

error:
    if (NULL != strSerial)
    {
	SysFreeString(strSerial);
    }
    return(hr);
}


HRESULT
DumpChainHash(
    IN BYTE const *pbHash,
    IN DWORD cbHash)
{
    HRESULT hr;
    WCHAR wszHash[CBMAX_CRYPT_HASH_LEN * 3];
    DWORD cbwszHash;

    cbwszHash = sizeof(wszHash);
    hr = MultiByteIntegerToWszBuf(
		       TRUE,	// byte multiple
		       cbHash,
		       pbHash,
		       &cbwszHash,
		       wszHash);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    CONSOLEPRINT1((MAXDWORD, "  %ws\n", wszHash));

    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpChainAddHash(
    IN OPTIONAL HCRYPTHASH hHash,
    IN BYTE const *pb,
    IN DWORD cb)
{
    HRESULT hr;

    if (NULL != hHash)
    {
	if (!CryptHashData(hHash, pb, cb, 0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptHashData");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
DumpChainHashResult(
    IN OPTIONAL HCRYPTHASH hHash,
    IN char const *pszType)
{
    HRESULT hr;
    HCRYPTHASH hHashT = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    if (NULL != hHash)
    {
	if (!CryptDuplicateHash(
			hHash,
			NULL,		// pdwReserved
			0,		// dwFlags
			&hHashT))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptDuplicateHash");
	}
	if (!CryptGetHashParam(hHashT, HP_HASHVAL, abHash, &cbHash, 0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetHashParam");
	}
	CONSOLEPRINT2((MAXDWORD, "%hs:\n", pszType));
	hr = DumpChainHash(abHash, cbHash);
	_JumpIfError(hr, error, "DumpChainHash");
    }
    hr = S_OK;

error:
    if (NULL != hHashT)
    {
	CryptDestroyHash(hHashT);
    }
    return(hr);
}


VOID
DumpChainTemplate(
    IN CERT_INFO const *pCertInfo)
{
    HRESULT hr;
    CERT_NAME_VALUE *pbName = NULL;
    CERT_TEMPLATE_EXT *pTemplate = NULL;
    CERT_EXTENSION *pExt;
    DWORD cb;

    // display v1 template extension first

    pExt = CertFindExtension(
		    szOID_ENROLL_CERTTYPE_EXTENSION,
		    pCertInfo->cExtension,
		    pCertInfo->rgExtension);
    if (NULL != pExt)
    {
	if (!myDecodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_ANY_STRING,
			pExt->Value.pbData,
			pExt->Value.cbData,
			CERTLIB_USE_LOCALALLOC,
			(VOID **) &pbName,
			&cb))
	{
	    hr = myHLastError();
	    _PrintError(hr, "myDecodeObject");
	}
	else
	{
	    CONSOLEPRINT1((MAXDWORD, "  Template: %ws\n", pbName->Value.pbData));
	}
    }
    pExt = CertFindExtension(
		    szOID_CERTIFICATE_TEMPLATE,
		    pCertInfo->cExtension,
		    pCertInfo->rgExtension);

    if (NULL != pExt)
    {
        if (!myDecodeObject(
                        X509_ASN_ENCODING,
                        X509_CERTIFICATE_TEMPLATE,
                        pExt->Value.pbData,
                        pExt->Value.cbData,
                        CERTLIB_USE_LOCALALLOC,
                        (VOID **) &pTemplate,
                        &cb))
        {
            hr = myHLastError();
            _PrintError(hr, "myDecodeObject");
        }
	else
	{
	    WCHAR const *pwsz;

	    pwsz = myGetOIDNameA(pTemplate->pszObjId); // Static: do not free!
	    if (NULL != pwsz && L'\0' != *pwsz)
	    {
		CONSOLEPRINT1((MAXDWORD, "  Template: %ws\n", pwsz));
	    }
	    else
	    {
		CONSOLEPRINT1((MAXDWORD, "  Template: %hs\n", pTemplate->pszObjId));
	    }
	}
    }

//error:
    LOCAL_FREE(pTemplate);
    LOCAL_FREE(pbName);
}


HRESULT
DumpChainCert(
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    DumpChainName("  Issuer", &pcc->pCertInfo->Issuer);
    DumpChainName("  Subject", &pcc->pCertInfo->Subject);
    DumpChainSerial("  Serial", &pcc->pCertInfo->SerialNumber);
    DumpChainTemplate(pcc->pCertInfo);
    if (!CertGetCertificateContextProperty(
				    pcc,
				    CERT_SHA1_HASH_PROP_ID,
				    abHash,
				    &cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }
    hr = DumpChainHash(abHash, cbHash);
    _JumpIfError(hr, error, "DumpChainHash");

error:
    return(hr);
}


HRESULT
DumpChainCRL(
    IN BOOL fDelta,
    OPTIONAL IN CRL_CONTEXT const *pCRL,
    IN OPTIONAL HCRYPTHASH hHash)
{
    HRESULT hr;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;

    if (NULL != pCRL)
    {
	CONSOLEPRINT2((
		MAXDWORD,
		"    %hsCRL %u:\n",
		fDelta? "Delta " : "",
		myCRLNumber(pCRL)));

	DumpChainName("    Issuer", &pCRL->pCrlInfo->Issuer);
	if (!CertGetCRLContextProperty(
				    pCRL,
				    CERT_SHA1_HASH_PROP_ID,
				    abHash,
				    &cbHash))
	{
	    hr = myHLastError();
	    _PrintError(hr, "CertGetCRLContextProperty");
	}
	else
	{
	    CONSOLEPRINT0((MAXDWORD, "  "));
	    hr = DumpChainHash(abHash, cbHash);
	    _PrintIfError(hr, "DumpChainHash");
	}
	hr = DumpChainAddHash(hHash, pCRL->pbCrlEncoded, pCRL->cbCrlEncoded);
	_JumpIfError(hr, error, "DumpChainAddHash");
    }
    hr = S_OK;

error:
    return(hr);
}


VOID
DumpChainSeconds(
    IN WCHAR const *pwszField,
    IN DWORD dwSeconds)
{
    HRESULT hr;
    LLFILETIME llftPeriod;
    WCHAR *pwszTimePeriod;

    llftPeriod.ft.dwHighDateTime = 0;
    llftPeriod.ft.dwLowDateTime = dwSeconds;
    llftPeriod.ll *= CVT_BASE;
    llftPeriod.ll = -llftPeriod.ll;

    hr = myFileTimePeriodToWszTimePeriod(&llftPeriod.ft, TRUE, &pwszTimePeriod);
    if (S_OK != hr)
    {
	_PrintError(hr, "myFileTimePeriodToWszTimePeriod");
	CONSOLEPRINT2((MAXDWORD, "%ws: %us\n", pwszField, dwSeconds));
    }
    else
    {
	CONSOLEPRINT2((MAXDWORD, "%ws: %ws\n", pwszField, pwszTimePeriod));
	LocalFree(pwszTimePeriod);
    }
}


VOID
myDumpChain(
    IN HRESULT hrVerify,
    IN DWORD dwFlags,
    IN CERT_CONTEXT const *pCert,
    OPTIONAL IN FNSIMPLECHAINELEMENTCALLBACK *pfnCallback,
    OPTIONAL IN WCHAR const *pwszMissingIssuer,
    IN CERT_CHAIN_CONTEXT const *pChainContext)
{
    HRESULT hr;
    DWORD i;
    DWORD j;
    static BOOL s_fEnvChecked = FALSE;
    static BOOL s_fDumpEnabled = FALSE;
    static DWORD s_SaveCount = 0;
    static DWORD s_SaveIndex;
    BOOL fDump;
    BOOL fSave;
    HCRYPTPROV hProv = NULL;
    HCRYPTHASH hHash = NULL;

    if (!s_fEnvChecked)
    {
	WCHAR wszBuf[20];
	DWORD cwc;

	cwc = GetEnvironmentVariable(
				L"CertSrv_Chain",
				wszBuf,
				ARRAYSIZE(wszBuf));
	if (0 < cwc && ARRAYSIZE(wszBuf) > cwc)
	{
	    s_fDumpEnabled = TRUE;
	    s_SaveCount = _wtoi(wszBuf);
	    s_SaveIndex = s_SaveCount;
	}
	s_fEnvChecked = TRUE;
    }
    fSave = 0 != s_SaveCount || (CA_VERIFY_FLAGS_SAVE_CHAIN & dwFlags);
    fDump = s_fDumpEnabled ||
		S_OK != hrVerify ||
		(CA_VERIFY_FLAGS_DUMP_CHAIN & dwFlags);
#if DBG_CERTSRV
    if (DbgIsSSActive(DBG_SS_CERTLIBI))
    {
	fDump = TRUE;
    }
#endif
    if (!fSave && !fDump)
    {
	return;
    }
    if (0 != s_SaveCount)
    {
	if (++s_SaveIndex >= s_SaveCount)
	{
	    s_SaveIndex = 0;
	}
    }
    if (fDump)
    {
	CONSOLEPRINT0((MAXDWORD, "-------- CERT_CHAIN_CONTEXT --------\n"));
	DumpFlags(
		pChainContext->TrustStatus.dwInfoStatus,
		L"ChainContext.dwInfoStatus",
		g_adfInfoStatus);
	DumpFlags(
		pChainContext->TrustStatus.dwErrorStatus,
		L"ChainContext.dwErrorStatus",
		g_adfErrorStatus);
	if (CCSIZEOF_STRUCT(CERT_CHAIN_CONTEXT, dwRevocationFreshnessTime) <=
			pChainContext->cbSize &&
	    pChainContext->fHasRevocationFreshnessTime)
	{
	    DumpChainSeconds(
		L"ChainContext.dwRevocationFreshnessTime",
		pChainContext->dwRevocationFreshnessTime);
	}
    }
    for (i = 0; i < pChainContext->cChain; i++)
    {
	if (fSave)
	{
	    WriteChain(pChainContext->rgpChain[i], s_SaveIndex, i);
	}
	if (fDump)
	{
	    DumpFlags(
		    pChainContext->rgpChain[i]->TrustStatus.dwInfoStatus,
		    L"\nSimpleChain.dwInfoStatus",
		    g_adfInfoStatus);
	    DumpFlags(
		    pChainContext->rgpChain[i]->TrustStatus.dwErrorStatus,
		    L"SimpleChain.dwErrorStatus",
		    g_adfErrorStatus);
	    if (CCSIZEOF_STRUCT(CERT_SIMPLE_CHAIN, dwRevocationFreshnessTime) <=
			    pChainContext->rgpChain[i]->cbSize &&
		pChainContext->rgpChain[i]->fHasRevocationFreshnessTime)
	    {
		DumpChainSeconds(
		    L"SimpleChain.dwRevocationFreshnessTime",
		    pChainContext->rgpChain[i]->dwRevocationFreshnessTime);
	    }
	}
	if (NULL != hHash)
	{
	    CryptDestroyHash(hHash);
	    hHash = NULL;
	}
	if (NULL != hProv)
	{
	    CryptReleaseContext(hProv, 0);
	    hProv = NULL;
	}
	hr = DumpChainOpenHash(&hProv, &hHash);
	_PrintIfError(hr, "DumpChainOpenHash");

	for (j = 0; j < pChainContext->rgpChain[i]->cElement; j++)
	{
	    CERT_CHAIN_ELEMENT const *pElement;

	    pElement = pChainContext->rgpChain[i]->rgpElement[j];

	    if (fDump ||
		S_OK != hrVerify ||
		0 != pElement->TrustStatus.dwErrorStatus)
	    {
		CERT_REVOCATION_INFO *pRevocationInfo;

		CONSOLEPRINT4((
		    MAXDWORD,
		    "\nCertContext[%u][%u]: dwInfoStatus=%x dwErrorStatus=%x\n",
		    i,
		    j,
		    pElement->TrustStatus.dwInfoStatus,
		    pElement->TrustStatus.dwErrorStatus));

		hr = DumpChainCert(pElement->pCertContext);
		_PrintIfError(hr, "DumpChainCert");

		DumpFlags(
			pElement->TrustStatus.dwInfoStatus,
			L"  Element.dwInfoStatus",
			g_adfInfoStatus);
		DumpFlags(
			pElement->TrustStatus.dwErrorStatus,
			L"  Element.dwErrorStatus",
			g_adfErrorStatus);

		if (NULL != pfnCallback)
		{
		    (*pfnCallback)(dwFlags, j, pChainContext->rgpChain[i]);
		}
		pRevocationInfo = pElement->pRevocationInfo;

		if (NULL != pRevocationInfo &&
		    CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
			pRevocationInfo->cbSize &&
		    NULL != pRevocationInfo->pCrlInfo)
		{
		    hr = DumpChainCRL(
			    FALSE,
			    pRevocationInfo->pCrlInfo->pBaseCrlContext,
			    hHash);
		    _PrintIfError(hr, "DumpChainCRL");

		    hr = DumpChainCRL(
			    TRUE,
			    pRevocationInfo->pCrlInfo->pDeltaCrlContext,
			    hHash);
		    _PrintIfError(hr, "DumpChainCRL");
		}

		if (CCSIZEOF_STRUCT(CERT_CHAIN_ELEMENT, pIssuanceUsage) <=
		    pElement->cbSize)
		{
		    DumpUsage(L"  Issuance", pElement->pIssuanceUsage);
		}
		if (CCSIZEOF_STRUCT(CERT_CHAIN_ELEMENT, pApplicationUsage) <=
		    pElement->cbSize)
		{
		    DumpUsage(L"  Application", pElement->pApplicationUsage);
		}
		if (CCSIZEOF_STRUCT(CERT_CHAIN_ELEMENT, pwszExtendedErrorInfo) <=
		    pElement->cbSize &&
		    NULL != pElement->pwszExtendedErrorInfo)
		{
		    CONSOLEPRINT1((
			    MAXDWORD,
			    "  %ws",
			    pElement->pwszExtendedErrorInfo));
		}
		if (1 + j == pChainContext->rgpChain[i]->cElement)
		{
		    DumpChainHashResult(hHash, "\nExclude leaf cert");
		}

		hr = DumpChainAddHash(
			    hHash,
			    pElement->pCertContext->pbCertEncoded,
			    pElement->pCertContext->cbCertEncoded);
		_PrintIfError(hr, "DumpChainAddHash");

		if (1 + j == pChainContext->rgpChain[i]->cElement)
		{
		    hr = DumpChainHashResult(hHash, "Full chain");
		    _PrintIfError(hr, "DumpChainAddHash");
		}
	    }
	}
    }
    if (fDump)
    {
	if (S_OK != hrVerify)
	{
	    WCHAR const *pwszErr = myGetErrorMessageText(hrVerify, TRUE);

	    if (NULL != pwszMissingIssuer)
	    {
		CONSOLEPRINT1((
			MAXDWORD,
			"Missing Issuer: %ws\n",
			pwszMissingIssuer));
	    }
	    DumpChainCert(pCert);
	    if (NULL != pwszErr)
	    {
		CONSOLEPRINT1((MAXDWORD, "%ws\n", pwszErr));
		LocalFree(const_cast<WCHAR *>(pwszErr));
	    }
	}
	CONSOLEPRINT0((MAXDWORD, "------------------------------------\n"));
    }
    if (NULL != hHash)
    {
	CryptDestroyHash(hHash);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
}


#pragma warning(push)
#pragma warning(disable: 4706)	// assignment within conditional expression: while (*pwsz++ = *psz++)
HRESULT
SavePolicies(
    OPTIONAL IN CERT_ENHKEY_USAGE const *pUsage,
    OUT WCHAR **ppwszzPolicies)
{
    HRESULT hr;
    DWORD i;
    DWORD cwc;
    char const *psz;
    WCHAR *pwsz;

    // pUsage == NULL means the cert is good for *all* policies.
    // Do nothing here, which returns *ppwszzPolicies == NULL.
    //
    // pUsage->cUsageIdentifier == 0 means the cert is good for *no* policies.
    // Return a double L'\0' terminated string containing no policy OIDs.

    if (NULL != pUsage)
    {
	BOOL fEmpty = 0 == pUsage->cUsageIdentifier ||
			NULL == pUsage->rgpszUsageIdentifier;

	cwc = 1;
	if (fEmpty)
	{
	    cwc++;
	}
	else
	{
	    for (i = 0; i < pUsage->cUsageIdentifier; i++)
	    {
		cwc += strlen(pUsage->rgpszUsageIdentifier[i]) + 1;
	    }
	}
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	*ppwszzPolicies = pwsz;
	if (fEmpty)
	{
	    *pwsz++ = L'\0';
	}
	else
	{
	    for (i = 0; i < pUsage->cUsageIdentifier; i++)
	    {
		psz = pUsage->rgpszUsageIdentifier[i];
		while (*pwsz++ = *psz++)
		    ;
	    }
	}
	*pwsz++ = L'\0';
	CSASSERT(pwsz == &(*ppwszzPolicies)[cwc]);
    }
    hr = S_OK;

error:
    return(hr);
}
#pragma warning(pop)


HRESULT
myVerifyCertContextEx(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD dwmsTimeout,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    IN DWORD cIssuanceOids,
    OPTIONAL IN CHAR const * const *apszIssuanceOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN FILETIME const *pft,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL IN FNSIMPLECHAINELEMENTCALLBACK *pfnCallback,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer,
    OPTIONAL OUT WCHAR **ppwszzIssuancePolicies,
    OPTIONAL OUT WCHAR **ppwszzApplicationPolicies,
    OPTIONAL OUT WCHAR **ppwszExtendedErrorInfo,
    OPTIONAL OUT CERT_TRUST_STATUS *pTrustStatus)
{
    HRESULT hr;
    DWORD ChainFlags;
    CERT_CHAIN_PARA ChainParams;
    CERT_CHAIN_POLICY_PARA ChainPolicy;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_CONTEXT const *pChainContext = NULL;
    LPCSTR pszChainPolicyFlags;
    WCHAR *pwszMissingIssuer = NULL;
    CERT_CHAIN_ELEMENT const *pElement;
    WCHAR const *pwsz;

    if (NULL != ppwszMissingIssuer)
    {
	*ppwszMissingIssuer = NULL;
    }
    if (NULL != ppwszzIssuancePolicies)
    {
	*ppwszzIssuancePolicies = NULL;
    }
    if (NULL != ppwszzApplicationPolicies)
    {
	*ppwszzApplicationPolicies = NULL;
    }
    if (NULL != ppwszExtendedErrorInfo)
    {
	*ppwszExtendedErrorInfo = NULL;
    }
    if (NULL != pTrustStatus)
    {
	ZeroMemory(pTrustStatus, sizeof(*pTrustStatus));
    }
    ZeroMemory(&ChainParams, sizeof(ChainParams));
    ChainParams.cbSize = sizeof(ChainParams);
    ChainParams.dwUrlRetrievalTimeout = dwmsTimeout;

    if (0 != cUsageOids && NULL != apszUsageOids)
    {
	ChainParams.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
	ChainParams.RequestedUsage.Usage.cUsageIdentifier = cUsageOids;
	ChainParams.RequestedUsage.Usage.rgpszUsageIdentifier = const_cast<char **>(apszUsageOids);
    }

    if (0 != cIssuanceOids && NULL != apszIssuanceOids)
    {
	ChainParams.RequestedIssuancePolicy.dwType = USAGE_MATCH_TYPE_AND;
	ChainParams.RequestedIssuancePolicy.Usage.cUsageIdentifier = cIssuanceOids;
	ChainParams.RequestedIssuancePolicy.Usage.rgpszUsageIdentifier = const_cast<char **>(apszIssuanceOids);
    }

    ChainFlags = 0;
    if (0 == (CA_VERIFY_FLAGS_NO_REVOCATION & dwFlags))
    {
	if (CA_VERIFY_FLAGS_FULL_CHAIN_REVOCATION & dwFlags)
	{
	    ChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN;
	}
	else
	{
	    ChainFlags = CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
	}
    }
    if (CA_VERIFY_FLAGS_DUMP_CHAIN & dwFlags)
    {
	DumpFlags(dwFlags, L"dwFlags", g_adfVerifyFlags);
	if (0 != cIssuanceOids && NULL != apszIssuanceOids)
	{
	    DumpUsage(L"Issuance", &ChainParams.RequestedIssuancePolicy.Usage);
	}
	if (0 != cUsageOids && NULL != apszUsageOids)
	{
	    DumpUsage(L"Application", &ChainParams.RequestedUsage.Usage);
	}
	DumpFlags(ChainFlags, L"ChainFlags", g_adfChainFlags);
	pwsz = NULL;
	if (HCCE_LOCAL_MACHINE == hChainEngine)
	{
	    pwsz = L"HCCE_LOCAL_MACHINE";
	}
	else if (HCCE_CURRENT_USER == hChainEngine)
	{
	    pwsz = L"HCCE_CURRENT_USER";
	}
	if (NULL != pwsz)
	{
	    CONSOLEPRINT1((MAXDWORD, "%ws\n", pwsz));
	}
    }

    // use NTAuth policy if (usage oids being added) & (caller asks us to check(EntCA))

    pwsz = NULL;
    if (0 != cUsageOids &&
	NULL != apszUsageOids &&
	(CA_VERIFY_FLAGS_NT_AUTH & dwFlags))
    {
	pszChainPolicyFlags = CERT_CHAIN_POLICY_NT_AUTH;
	pwsz = L"CERT_CHAIN_POLICY_NT_AUTH";
    }
    else
    {
	pszChainPolicyFlags = CERT_CHAIN_POLICY_BASE;
	pwsz = L"CERT_CHAIN_POLICY_BASE";
    }
    if (NULL != pwsz && (CA_VERIFY_FLAGS_DUMP_CHAIN & dwFlags))
    {
	CONSOLEPRINT1((MAXDWORD, "%ws\n", pwsz));
    }

    // Get the chain and verify the cert:

    DBGPRINT((DBG_SS_CERTLIBI, "Calling CertGetCertificateChain...\n"));
    if (!CertGetCertificateChain(
			    hChainEngine,	// hChainEngine
			    pCert,		// pCertContext
			    const_cast<FILETIME *>(pft), // pTime
			    hAdditionalStore,	// hAdditionalStore
			    &ChainParams,	// pChainPara
			    ChainFlags,		// dwFlags
			    NULL,		// pvReserved
			    &pChainContext))	// ppChainContext
    {
        hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }
    DBGPRINT((DBG_SS_CERTLIBI, "CertGetCertificateChain done\n"));

    ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));
    ChainPolicy.cbSize = sizeof(ChainPolicy);
    ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG;
    //ChainPolicy.pvExtraPolicyPara = NULL;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);
    //PolicyStatus.dwError = 0;
    PolicyStatus.lChainIndex = -1;
    PolicyStatus.lElementIndex = -1;
    //PolicyStatus.pvExtraPolicyStatus = NULL;

    if (!CertVerifyCertificateChainPolicy(
                                    pszChainPolicyFlags,
				    pChainContext,
				    &ChainPolicy,
				    &PolicyStatus))
    {
        hr = myHLastError();
	_JumpError(hr, error, "CertVerifyCertificateChainPolicy");
    }

    hr = myHError(PolicyStatus.dwError);
    if ((CA_VERIFY_FLAGS_IGNORE_OFFLINE |
	 CA_VERIFY_FLAGS_IGNORE_NOREVCHECK |
	 CA_VERIFY_FLAGS_NO_REVOCATION) & dwFlags)
    {
	if (CRYPT_E_NO_REVOCATION_CHECK == hr ||
	    (CRYPT_E_REVOCATION_OFFLINE == hr &&
	     ((CA_VERIFY_FLAGS_IGNORE_OFFLINE |
	       CA_VERIFY_FLAGS_IGNORE_NOREVCHECK) & dwFlags)))
        {
            hr = S_OK;
        }
    }
    if (CA_VERIFY_FLAGS_ALLOW_UNTRUSTED_ROOT & dwFlags)
    {
        if (CERT_E_UNTRUSTEDROOT == hr)
        {
            hr = S_OK;
        }
    }
    if (CA_VERIFY_FLAGS_IGNORE_INVALID_POLICIES & dwFlags)
    {
	if (CERT_E_INVALID_POLICY == hr)
        {
            hr = S_OK;
        }
    }
    if (S_OK != hr &&
	0 < pChainContext->cChain &&
	0 < pChainContext->rgpChain[0]->cElement)
    {
	pElement = pChainContext->rgpChain[0]->rgpElement[
		    pChainContext->rgpChain[0]->cElement - 1];

	if (0 == (CERT_TRUST_IS_SELF_SIGNED & pElement->TrustStatus.dwInfoStatus))
	{
	    HRESULT hr2;

	    hr2 = myCertNameToStr(
			    X509_ASN_ENCODING,
			    &pElement->pCertContext->pCertInfo->Issuer,
			    CERT_X500_NAME_STR | CERT_NAME_STR_REVERSE_FLAG,
			    &pwszMissingIssuer);
	    _PrintIfError(hr2, "myCertNameToStr");
	}
    }
    if (NULL != pTrustStatus)
    {
	*pTrustStatus = pChainContext->TrustStatus;
    }
    myDumpChain(
	    hr,
	    dwFlags,
	    pCert,
	    pfnCallback,
	    pwszMissingIssuer,
	    pChainContext);

    if (NULL != ppwszMissingIssuer)
    {
	*ppwszMissingIssuer = pwszMissingIssuer;
	pwszMissingIssuer = NULL;
    }
    if (NULL != ppwszExtendedErrorInfo)
    {
	CERT_CHAIN_ELEMENT **ppElement;
	CERT_CHAIN_ELEMENT **ppElementEnd;

	ppElement = &pChainContext->rgpChain[0]->rgpElement[0];
	ppElementEnd = &ppElement[pChainContext->rgpChain[0]->cElement];
	while (ppElement < ppElementEnd)
	{
	    if (CCSIZEOF_STRUCT(CERT_CHAIN_ELEMENT, pwszExtendedErrorInfo) <=
		(*ppElement)->cbSize &&
		NULL != (*ppElement)->pwszExtendedErrorInfo)
	    {
		HRESULT hr2;

		hr2 = myDupString(
			    (*ppElement)->pwszExtendedErrorInfo,
			    ppwszExtendedErrorInfo);
		_PrintIfError(hr2, "myDupString");

		break;
	    }
	    ppElement++;
	}
    }
    _JumpIfError(hr, error, "PolicyStatus.dwError");

    pElement = pChainContext->rgpChain[0]->rgpElement[0];

    if (NULL != ppwszzIssuancePolicies &&
	CCSIZEOF_STRUCT(CERT_CHAIN_ELEMENT, pIssuanceUsage) <= pElement->cbSize)
    {
	hr = SavePolicies(
		    pElement->pIssuanceUsage,
		    ppwszzIssuancePolicies);
	_JumpIfError(hr, error, "SavePolicies");
    }
    if (NULL != ppwszzApplicationPolicies &&
	CCSIZEOF_STRUCT(CERT_CHAIN_ELEMENT, pApplicationUsage) <= pElement->cbSize)
    {
	hr = SavePolicies(
		    pElement->pApplicationUsage,
		    ppwszzApplicationPolicies);
	_JumpIfError(hr, error, "SavePolicies");
    }

error:
    if (S_OK != hr)
    {
	if (NULL != ppwszzIssuancePolicies && NULL != *ppwszzIssuancePolicies)
	{
	    LocalFree(*ppwszzIssuancePolicies);
	    *ppwszzIssuancePolicies = NULL;
	}
	if (NULL != ppwszzApplicationPolicies && NULL != *ppwszzApplicationPolicies)
	{
	    LocalFree(*ppwszzApplicationPolicies);
	    *ppwszzApplicationPolicies = NULL;
	}
    }
    if (NULL != pwszMissingIssuer)
    {
        LocalFree(pwszMissingIssuer);
    }
    if (NULL != pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }
    return(hr);
}


HRESULT
myVerifyCertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags,
    IN DWORD cUsageOids,
    OPTIONAL IN CHAR const * const *apszUsageOids,
    OPTIONAL IN HCERTCHAINENGINE hChainEngine,
    OPTIONAL IN HCERTSTORE hAdditionalStore,
    OPTIONAL OUT WCHAR **ppwszMissingIssuer)
{
    HRESULT hr;

    hr = myVerifyCertContextEx(
			pCert,
			dwFlags,
			0,		// dwmsTimeout
			cUsageOids,
			apszUsageOids,
			0,		// cIssuanceOids
			NULL,		// apszIssuanceOids
			hChainEngine,
			NULL,		// pft
			hAdditionalStore,
			NULL,		// pfnCallback
			ppwszMissingIssuer,
			NULL,		// ppwszzIssuancePolicies
			NULL,		// ppwszzApplicationPolicies
			NULL,		// ppwszExtendedErrorInfo
			NULL);		// pTrustStatus
    _JumpIfError2(hr, error, "myVerifyCertContextEx", hr);

error:
    return(hr);
}


HRESULT
myIsFirstSigner(
    IN CERT_NAME_BLOB const *pNameBlob,
    OUT BOOL *pfFirst)
{
    HRESULT hr;
    CERT_NAME_INFO *pNameInfo = NULL;
    DWORD cbNameInfo;
    DWORD i;

    *pfFirst = FALSE;

    if (!myDecodeName(
		X509_ASN_ENCODING,
		X509_UNICODE_NAME,
		pNameBlob->pbData,
		pNameBlob->cbData,
		CERTLIB_USE_LOCALALLOC,
		&pNameInfo,
		&cbNameInfo))
    {

	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    for (i = 0; i < pNameInfo->cRDN; i++)
    {
	CERT_RDN const *prdn;
	DWORD j;

	prdn = &pNameInfo->rgRDN[i];

	for (j = 0; j < prdn->cRDNAttr; j++)
	{
	    if (0 == strcmp(
			prdn->rgRDNAttr[j].pszObjId,
			szOID_RDN_DUMMY_SIGNER))
	    {
		*pfFirst = TRUE;
		i = pNameInfo->cRDN;	// terminate outer loop
		break;
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pNameInfo)
    {
	LocalFree(pNameInfo);
    }
    return(hr);
}


HCERTSTORE
myPFXImportCertStore(
    IN CRYPT_DATA_BLOB *ppfx,
    OPTIONAL IN WCHAR const *pwszPassword,
    IN DWORD dwFlags)
{
    HCERTSTORE hStore;
    HRESULT hr;

    if (NULL == pwszPassword)
    {
	pwszPassword = L"";	// Try empty password first, then NULL
    }

    for (;;)
    {
	hStore = PFXImportCertStore(ppfx, pwszPassword, dwFlags);
	if (NULL == hStore)
	{
	    hr = myHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD) != hr ||
		NULL == pwszPassword ||
		L'\0' != *pwszPassword)
	    {
		_JumpError2(
			hr,
			error,
			"PFXImportCertStore",
			HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	    }
	    pwszPassword = NULL;	// empty password failed; try NULL
	    continue;
	}
	break;
    }


error:
    return(hStore);
}


// No longer support versions before IE3.02 - Auth2 update, advisory only

HRESULT
CertCheck7f(
    IN CERT_CONTEXT const *pcc)
{
    HRESULT hr;
    DWORD State;
    DWORD Index1;
    DWORD Index2;
    DWORD cwcField;
    WCHAR wszField[128];
    DWORD cwcObjectId;
    WCHAR wszObjectId[128];
    WCHAR const *pwszObjectIdDescription = NULL;

    cwcField = sizeof(wszField)/sizeof(wszField[0]);
    cwcObjectId = sizeof(wszObjectId)/sizeof(wszObjectId[0]);
    hr = myCheck7f(
		pcc->pbCertEncoded,
		pcc->cbCertEncoded,
		FALSE,
		&State,
		&Index1,
		&Index2,
		&cwcField,
		wszField,
		&cwcObjectId,
		wszObjectId,
		&pwszObjectIdDescription);	// Static: do not free!
    _JumpIfError(hr, error, "myCheck7f");

    if (CHECK7F_NONE != State)
    {
	hr = CERTSRV_E_ENCODING_LENGTH;

#if DBG_CERTSRV
	WCHAR wszIndex[5 + 2 * cwcDWORDSPRINTF];

	wszIndex[0] = L'\0';
	if (0 != Index1)
	{
	    wsprintf(
		wszIndex,
		0 != Index2? L"[%u,%u]" : L"[%u]",
		Index1 - 1,
		Index2 - 1);
	}
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "CertCheck7f: %ws%ws%ws%ws%ws%ws%ws, hr=%x\n",
	    wszField,
	    wszIndex,
	    0 != cwcObjectId? L" ObjectId=" : L"",
	    0 != cwcObjectId? wszObjectId : L"",
	    NULL != pwszObjectIdDescription? L" " wszLPAREN : L"",
	    NULL != pwszObjectIdDescription? pwszObjectIdDescription : L"",
	    NULL != pwszObjectIdDescription? wszRPAREN : L"",
	    hr));
#endif // DBG_CERTSRV
    }
error:
    return(hr);
}


HRESULT
myAddCertToStore(
    IN HCERTSTORE                          hStore,
    IN CERT_CONTEXT const                 *pCertContext,
    OPTIONAL IN CRYPT_KEY_PROV_INFO const *pkpi,
    OPTIONAL OUT CERT_CONTEXT const      **ppCert)
{
    HRESULT hr;
    CERT_CONTEXT const *pcc = NULL;

    if (NULL != ppCert)
    {
	*ppCert = NULL;
    }

    // for root cert, if it shows related private key, it will
    // pfx import failure for other applications

    // Add as encoded blob to avoid all properties, key prov info, etc.

    if (!CertAddEncodedCertificateToStore(
		    hStore,
		    X509_ASN_ENCODING,
		    pCertContext->pbCertEncoded,
		    pCertContext->cbCertEncoded,
		    NULL != pkpi?
			CERT_STORE_ADD_REPLACE_EXISTING :
			CERT_STORE_ADD_USE_EXISTING,
		    &pcc))			// ppCertContext
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertAddEncodedCertificateToStore");
    }
    if (NULL != pkpi)
    {
	if (!CertSetCertificateContextProperty(
					    pcc,
					    CERT_KEY_PROV_INFO_PROP_ID,
					    0,
					    pkpi))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertSetCertificateContextProperty");
	}
    }
    if (NULL != ppCert)
    {
	*ppCert = pcc;
	pcc = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pcc)
    {
	CertFreeCertificateContext(pcc);
    }
    return(hr);
}


HRESULT
mySaveChainAndKeys(
    IN CERT_SIMPLE_CHAIN const *pSimpleChain,
    IN WCHAR const *pwszStore,
    IN DWORD dwStoreFlags,
    IN CRYPT_KEY_PROV_INFO const *pkpi,
    OPTIONAL IN CERT_CONTEXT const **ppCert)
{
    HRESULT hr;
    HCERTSTORE hRootStore = NULL;
    HCERTSTORE hCAStore = NULL;
    HCERTSTORE hMyStore = NULL;
    DWORD i;

    if (NULL != ppCert)
    {
	*ppCert = NULL;
    }
    hRootStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			dwStoreFlags,
			wszROOT_CERTSTORE);
    if (NULL == hRootStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", wszROOT_CERTSTORE);
    }

    hCAStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			dwStoreFlags,
			wszCA_CERTSTORE);
    if (NULL == hCAStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", wszCA_CERTSTORE);
    }

    hMyStore = CertOpenStore(
			CERT_STORE_PROV_SYSTEM_REGISTRY_W,
			X509_ASN_ENCODING,
			NULL,		// hProv
			dwStoreFlags,
			pwszStore);
    if (NULL == hMyStore)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CertOpenStore", pwszStore);
    }

    for (i = 0; i < pSimpleChain->cElement; i++)
    {
	CERT_CONTEXT const *pcc = pSimpleChain->rgpElement[i]->pCertContext;
	HCERTSTORE hStore;

//	CertCheck7f(pcc);

        // if leaf CA cert, add to MY store

        if (0 == i)
        {
            CERT_CONTEXT const *pccFound = CertFindCertificateInStore(
						    hMyStore,
						    X509_ASN_ENCODING,
						    0,
						    CERT_FIND_EXISTING,
						    pcc,
						    NULL);

            if (NULL == pccFound)
            {
		hr = myAddCertToStore(hMyStore, pcc, pkpi, ppCert);
		_JumpIfError(hr, error, "myAddCertToStore");
            }
            else
            {
                if (NULL != ppCert)
                {
                    *ppCert = pccFound;
                }
                else
                {
                    CertFreeCertificateContext(pccFound);
                }
            }
        }

        // if root cert, add to ROOT store (without key); else add to CA store

	hStore = hCAStore;

	if (CERT_TRUST_IS_SELF_SIGNED &
	    pSimpleChain->rgpElement[i]->TrustStatus.dwInfoStatus)
	{
	    hStore = hRootStore;
	}
	hr = myAddCertToStore(hStore, pcc, NULL, NULL);
	_JumpIfError(hr, error, "myAddCertToStore");
    }
    hr = S_OK;

error:
    if (NULL != hRootStore)
    {
        CertCloseStore(hRootStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hCAStore)
    {
        CertCloseStore(hCAStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


HRESULT
myGetNameIdExtension(
    IN DWORD cExtension,
    IN CERT_EXTENSION const *rgExtension,
    OUT DWORD *pdwNameId)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    CERT_EXTENSION const *pExt;
    DWORD NameId;
    DWORD cb;

    *pdwNameId = MAXDWORD;
    pExt = CertFindExtension(
			szOID_CERTSRV_CA_VERSION,
			cExtension,
			const_cast<CERT_EXTENSION *>(rgExtension));
    if (NULL == pExt)
    {
	// This API doesn't set LastError
	_JumpError(hr, error, "CertFindExtension(CA Version)");
    }
    cb = sizeof(NameId);
    NameId = 0;
    if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_INTEGER,
			pExt->Value.pbData,
			pExt->Value.cbData,
			0,
			&NameId,
			&cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptDecodeObject");
    }
    *pdwNameId = NameId;
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetNameId(
    IN CERT_CONTEXT const *pCACert,
    OUT DWORD *pdwNameId)
{
    HRESULT hr;

    hr = myGetNameIdExtension(
		    pCACert->pCertInfo->cExtension,
		    pCACert->pCertInfo->rgExtension,
		    pdwNameId);
    _JumpIfError2(hr, error, "myGetNameIdExtension", hr);

error:
    return(hr);
}


HRESULT
myGetCRLNameId(
    IN CRL_CONTEXT const *pCRL,
    OUT DWORD *pdwNameId)
{
    HRESULT hr;

    hr = myGetNameIdExtension(
		    pCRL->pCrlInfo->cExtension,
		    pCRL->pCrlInfo->rgExtension,
		    pdwNameId);
    _JumpIfError2(hr, error, "myGetNameIdExtension", hr);

error:
    return(hr);
}


HRESULT
myGetCertSubjectField(
    IN CERT_CONTEXT const *pCert,
    IN LPCSTR pcszFieldOID,
    OUT WCHAR **ppwszField)
{
    HRESULT hr;
    CERT_NAME_INFO *pCertNameInfo = NULL;
    DWORD cbCertNameInfo;
    WCHAR const *pwszName;

    if (!myDecodeName(
		    X509_ASN_ENCODING,
                    X509_UNICODE_NAME,
                    pCert->pCertInfo->Subject.pbData,
                    pCert->pCertInfo->Subject.cbData,
                    CERTLIB_USE_LOCALALLOC,
                    &pCertNameInfo,
                    &cbCertNameInfo))
    {
        hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }
    hr = myGetCertNameProperty(
			CERT_V1 == pCert->pCertInfo->dwVersion,
			pCertNameInfo,
			pcszFieldOID,
			&pwszName);
    _JumpIfError(hr, error, "myGetCertNameProperty");

    *ppwszField = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszName) + 1) * sizeof(WCHAR));
    if (NULL == *ppwszField)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(*ppwszField, pwszName);
    hr = S_OK;

error:
    if (NULL != pCertNameInfo)
    {
	LocalFree(pCertNameInfo);
    }
    return(hr);
}

HRESULT
myGetCertSubjectCommonName(
    IN CERT_CONTEXT const *pCert,
    OUT WCHAR **ppwszCommonName)
{
    return myGetCertSubjectField(
        pCert,
        szOID_COMMON_NAME,
        ppwszCommonName);
}

HRESULT
myCertGetNameString(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwType,
    OUT WCHAR **ppwszSimpleName)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    *ppwszSimpleName = NULL;
    if (CERT_NAME_SIMPLE_DISPLAY_TYPE == dwType &&
	CERT_V1 == pcc->pCertInfo->dwVersion)
    {
	hr = myGetCertSubjectCommonName(pcc, &pwsz);
	_PrintIfError(hr, "myGetCertSubjectCommonName");
    }
    if (NULL == pwsz)
    {
	DWORD cwc = 0;

	for (;;)
	{
	    cwc = CertGetNameString(
			    pcc,
			    CERT_NAME_SIMPLE_DISPLAY_TYPE,
			    0,			// dwFlags
			    NULL,		// pvTypePara
			    pwsz,
			    cwc);
	    if (1 >= cwc)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND);
		_JumpError(hr, error, "CertGetNameString");
	    }
	    if (NULL != pwsz)
	    {
		break;
	    }
	    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	    if (NULL == pwsz)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	}
    }
    *ppwszSimpleName = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    return(hr);
}


HRESULT
myCertStrToName(
    IN DWORD dwCertEncodingType,
    IN LPCWSTR pszX500,
    IN DWORD dwStrType,
    IN OPTIONAL void *pvReserved,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded,
    OUT OPTIONAL LPCWSTR *ppszError)
{
    HRESULT hr;

    *ppbEncoded = NULL;
    *pcbEncoded = 0;

    for (;;)
    {
	if (!CertStrToName(
		    dwCertEncodingType,
		    pszX500,
		    dwStrType,
		    pvReserved,
		    *ppbEncoded,
		    pcbEncoded,
		    ppszError))
	{
	    hr = myHLastError();
	    if (NULL != *ppbEncoded)
	    {
		LocalFree(*ppbEncoded);
		*ppbEncoded = NULL;
	    }
	    _JumpError(hr, error, "CertStrToName");
	}
	if (NULL != *ppbEncoded)
	{
	    break;
	}
	*ppbEncoded = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncoded);
	if (NULL == *ppbEncoded)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myCertNameToStr(
    IN DWORD dwCertEncodingType,
    IN CERT_NAME_BLOB const *pName,
    IN DWORD dwStrType,
    OUT WCHAR **ppwszName)
{
    HRESULT hr;
    DWORD cwc = 0;
    WCHAR *pwszName = NULL;

    for (;;)
    {
	cwc = CertNameToStr(
			dwCertEncodingType,
			const_cast<CERT_NAME_BLOB *>(pName),
			dwStrType,
			pwszName,
			cwc);
	if (1 > cwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "CertNameToStr");
	}
	if (NULL != pwszName)
	{
	    break;
	}
	pwszName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppwszName = pwszName;
    pwszName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    return(hr);
}


HRESULT
myVerifyKRACertContext(
    IN CERT_CONTEXT const *pCert,
    IN DWORD dwFlags)
{
    HRESULT hr;
    WCHAR *pwszzAppPolicies = NULL;
    WCHAR *pwszCrt;
    DWORD dwKeyUsage;
    DWORD cb = sizeof(dwKeyUsage);

    hr = myVerifyCertContextEx(
			pCert,
			dwFlags,
			0,			// dwmsTimeout
			0,                      // cUsageOids
			NULL,                   // apszUsageOids
			0,			// cIssuanceOids
			NULL,			// apszIssuanceOids
			HCCE_LOCAL_MACHINE,     // hChainEngine
			NULL,			// pft
			NULL,                   // hAdditionalStore
			NULL,			// pfnCallback
			NULL,                   // ppwszMissingIssuer
			NULL,			// ppwszzIssuancePolicies
			&pwszzAppPolicies,
			NULL,			// ppwszExtendedErrorInfo
			NULL);			// pTrustStatus
    _JumpIfError(hr, error, "myVerifyCertContextEx");


    if (!CertGetIntendedKeyUsage(
            X509_ASN_ENCODING,
            pCert->pCertInfo,
            (BYTE*)&dwKeyUsage,
            cb))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CertGetIntendedKeyUsage");
    }

    if(!(dwKeyUsage & CERT_KEY_ENCIPHERMENT_KEY_USAGE))
    {
        hr = CERT_E_WRONG_USAGE;
        _JumpError(hr, error, "Key usage not containing key encipherment");
    }

    hr = CERT_E_WRONG_USAGE;
    for (pwszCrt = pwszzAppPolicies;
         pwszCrt && L'\0' != *pwszCrt;
         pwszCrt += wcslen(pwszCrt) + 1)
    {
        if(0==wcscmp(TEXT(szOID_KP_KEY_RECOVERY_AGENT), pwszCrt))
        {
            hr = S_OK;
            break;
        }
    }
    _JumpIfError(hr, error, "myVerifyKRACertContext");

error:
    if(pwszzAppPolicies)
    {
        LocalFree(pwszzAppPolicies);
    }
    return(hr);
}


HRESULT
myIsDeltaCRL(
    IN CRL_CONTEXT const *pCRL,
    OUT BOOL *pfIsDeltaCRL)
{
    HRESULT hr;
    CERT_EXTENSION *pExt;

    *pfIsDeltaCRL = FALSE;
    pExt = CertFindExtension(
		    szOID_DELTA_CRL_INDICATOR,
		    pCRL->pCrlInfo->cExtension,
		    pCRL->pCrlInfo->rgExtension);
    if (NULL != pExt)
    {
	*pfIsDeltaCRL = TRUE;
    }
    hr = S_OK;

//error:
    return(hr);
}


typedef BOOL (WINAPI fnCryptRetrieveObjectByUrlW) (
    IN LPCWSTR pszUrl,
    IN LPCSTR pszObjectOid,
    IN DWORD dwRetrievalFlags,
    IN DWORD dwTimeout,
    OUT LPVOID* ppvObject,
    IN HCRYPTASYNC hAsyncRetrieve,
    IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
    IN OPTIONAL LPVOID pvVerify,
    IN OPTIONAL PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );

HCERTSTORE
myUrlCertOpenStore(
    IN DWORD dwFlags,
    IN WCHAR const *pwszURL)
{
    HRESULT hr;
    HMODULE hModule = NULL;
    fnCryptRetrieveObjectByUrlW *pfn = NULL;
    HCERTSTORE hStore = NULL;

    hModule = LoadLibrary(TEXT("cryptnet.dll"));
    if (NULL == hModule)
    {
        hr = myHLastError();
        _JumpError(hr, error, "LoadLibrary(cryptnet.dll)");
    }

    pfn = (fnCryptRetrieveObjectByUrlW *) GetProcAddress(
            hModule,
            "CryptRetrieveObjectByUrlW");
    if (NULL == pfn)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptRetrieveObjectByUrl");
    }

    if (!(*pfn)(
            pwszURL,
            CONTEXT_OID_CAPI2_ANY,
            dwFlags,
            csecLDAPTIMEOUT * 1000,	// ms
            (VOID **) &hStore,
            NULL,
            NULL,
            NULL,
            NULL))
    {
	hr = myHLastError();
	_JumpErrorStr(hr, error, "CryptRetrieveObjectByUrl", pwszURL);
    }
    hr = S_OK;

error:
    if (NULL != hModule)
    {
        FreeLibrary(hModule);
    }
    if (NULL == hStore)
    {
	SetLastError(hr);
    }
    return(hStore);
}


HRESULT
mySetEnablePrivateKeyUsageCount(
    IN HCRYPTPROV hProv,
    IN BOOL fEnabled)
{
    HRESULT hr;
    DWORD dwEnableKeyUsageCount = fEnabled? 1 : 0;

    if (!CryptSetProvParam(
		    hProv,
		    PP_CRYPT_COUNT_KEY_USE,
		    (BYTE *) &dwEnableKeyUsageCount,
		    0))
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CryptSetProvParam", L"PP_CRYPT_COUNT_KEY_USE");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myGetSigningKeyUsageCount(
    IN HCRYPTPROV hProv,
    OUT BOOL *pfSupported,
    OUT BOOL *pfEnabled,
    OPTIONAL OUT ULARGE_INTEGER *puliCount)
{
    HRESULT hr;
    HCRYPTKEY hKey = NULL;
    DWORD cb;
    DWORD dwEnableKeyUsageCount;
    ULARGE_INTEGER uliCount;
    BOOL fPropSupported;

    *pfSupported = FALSE;
    *pfEnabled = FALSE;
    if (NULL != puliCount)
    {
	puliCount->QuadPart = 0;
    }
#define CSP_DBGPRINT
#ifdef CSP_DBGPRINT
    uliCount.QuadPart = 0;	// zero only for the debug print
#endif

    // An old CSP supports setting PP_CRYPT_COUNT_KEY_USE, but not fetching!
    // The new CSP supports setting and fetching PP_CRYPT_COUNT_KEY_USE,
    // but always returns with dwEnableKeyUsageCount set to zero on a freshly
    // acquired hProv (the flag is not persistent, and is only used to control
    // key use counting for newly created keys).
    // Always fetch the actual count, if the CSP supports the feature.
    // To distinguish between supported but not enabled & enabled but not yet
    // used (count is zero), fetching the actual count should fail when not
    // enabled, leaving *pfEnabled set to FALSE.

    cb = sizeof(dwEnableKeyUsageCount);
    fPropSupported = CryptGetProvParam(
				hProv,
				PP_CRYPT_COUNT_KEY_USE,
				(BYTE *) &dwEnableKeyUsageCount,
				&cb,
				0);
    if (!fPropSupported)
    {
        hr = myHLastError();
        _PrintErrorStr2(
		    hr,
		    "CryptGetProvParam",
		    L"PP_CRYPT_COUNT_KEY_USE",
		    NTE_BAD_TYPE);
    }
    else
    {
	*pfSupported = TRUE;
	if (!CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetUserKey");
	}
	cb = sizeof(uliCount);
	if (!CryptGetKeyParam(
			hKey,
			KP_GET_USE_COUNT,
			(BYTE *) &uliCount,
			&cb,
			0))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(
			hr,
			"CryptGetKeyParam",
			L"KP_GET_USE_COUNT",
			NTE_BAD_TYPE);
	}
	else
	{
	    *pfEnabled = TRUE;
	    if (NULL != puliCount)
	    {
		*puliCount = uliCount;
	    }
	}
    }
    hr = S_OK;

error:
#ifdef CSP_DBGPRINT
    DBGPRINT((
	DBG_SS_CERTLIB,
	"myGetSigningKeyUsageCount:%hs hr=%x Supported=%u Enabled=%u Count=%I64u\n",
	fPropSupported? "NEW" : "OLD",
	hr,
	*pfSupported,
	*pfEnabled,
	NULL != puliCount? puliCount->QuadPart : uliCount.QuadPart));
#endif
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    return(hr);
}

HRESULT
myCertGetEnhancedKeyUsage(
    IN CERT_CONTEXT const *pcc,
    IN DWORD dwFlags,
    OUT CERT_ENHKEY_USAGE **ppUsage)
{
    HRESULT hr;
    CERT_ENHKEY_USAGE *pUsage = NULL;
    DWORD cb;

    *ppUsage = NULL;

    for (;;)
    {
	if (!CertGetEnhancedKeyUsage(pcc, dwFlags, pUsage, &cb))
	{
	    hr = myHLastError();
	    _JumpError2(hr, error, "CertGetEnhancedKeyUsage", CRYPT_E_NOT_FOUND);
	}
	if (NULL != pUsage)
	{
	    *ppUsage = pUsage;
	    pUsage = NULL;
	    break;
	}
	pUsage = (CERT_ENHKEY_USAGE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pUsage)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = S_OK;

error:
    if (NULL != pUsage)
    {
	LocalFree(pUsage);
    }
    return(hr);
}

// if app policies extension was empty, myConvertAppPoliciesToEKU returns S_OK and NULL pbEKU
HRESULT
myConvertAppPoliciesToEKU(
    IN BYTE * pbAppPolicies,
    IN DWORD cbAppPolicies,
    OUT BYTE **ppbEKU,
    OUT DWORD *pcbEKU)
{
    HRESULT hr = S_OK;
    CERT_POLICIES_INFO *pcpsi = NULL;
    DWORD cb, i;
    CERT_ENHKEY_USAGE ceu;

    ZeroMemory(&ceu, sizeof(ceu));
    *ppbEKU = NULL;
    *pcbEKU = 0;

    if (!myDecodeObject(
            X509_ASN_ENCODING,
            X509_CERT_POLICIES,
            pbAppPolicies,
            cbAppPolicies,
            CERTLIB_USE_LOCALALLOC,
            (VOID **) &pcpsi,
            &cb))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myDecodeObject");
    }

    if(0 < pcpsi->cPolicyInfo)
    {
        ceu.rgpszUsageIdentifier = (char **) LocalAlloc(
            LMEM_FIXED,
            pcpsi->cPolicyInfo * sizeof(ceu.rgpszUsageIdentifier[0]));
        if (NULL == ceu.rgpszUsageIdentifier)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "Policy:myLocalAlloc");
        }

        for (i = 0; i < pcpsi->cPolicyInfo; i++)
        {
            ceu.rgpszUsageIdentifier[i] = pcpsi->rgPolicyInfo[i].pszPolicyIdentifier;
        }

        ceu.cUsageIdentifier = pcpsi->cPolicyInfo;

        if (!myEncodeObject(
                X509_ASN_ENCODING,
                X509_ENHANCED_KEY_USAGE,
                &ceu,
                0,
                CERTLIB_USE_LOCALALLOC,
                ppbEKU,
                pcbEKU))
        {
            hr = myHLastError();
            _JumpError(hr, error, "Policy:myEncodeObject");
        }
    }

    hr = S_OK;

error:
    if (NULL != ceu.rgpszUsageIdentifier)
    {
        LocalFree(ceu.rgpszUsageIdentifier);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\cslistvw.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       cslistvw.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <commctrl.h>
#include <assert.h>

#include "cslistvw.h"

BOOL OnDialogHelp(LPHELPINFO pHelpInfo, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;

    if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        WinHelp((HWND)pHelpInfo->hItemHandle, szHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    }
    return TRUE;
}

BOOL OnDialogContextHelp(HWND hWnd, LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    if (rgzHelpIDs == NULL || szHelpFile == NULL)
        return TRUE;
    assert(IsWindow(hWnd));
    WinHelp(hWnd, szHelpFile, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID)rgzHelpIDs);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\cscsp.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cscsp.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <tchar.h>
#include "initcert.h"
#include "cscsp.h"
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_CSCSP_CPP__



TCHAR const g_wszRegKeyCSP[] = wszREGKEYCSP;
TCHAR const g_wszRegKeyEncryptionCSP[] = wszREGKEYENCRYPTIONCSP;
TCHAR const g_wszRegProviderType[] = wszREGPROVIDERTYPE;
TCHAR const g_wszRegProvider[] = wszREGPROVIDER;
TCHAR const g_wszRegHashAlgorithm[] = wszHASHALGORITHM;
TCHAR const g_wszRegEncryptionAlgorithm[] = wszENCRYPTIONALGORITHM;
TCHAR const g_wszRegMachineKeyset[] = wszMACHINEKEYSET;
TCHAR const g_wszRegKeySize[] = wszREGKEYSIZE;


BOOL
myCertSrvCryptAcquireContext(
    OUT HCRYPTPROV *phProv,
    IN WCHAR const *pwszContainer,
    IN WCHAR const *pwszProvider,
    IN DWORD        dwProvType,
    IN DWORD        dwFlags,
    IN BOOL         fMachineKeyset)
{
    HRESULT hr;

    if (fMachineKeyset)
    {
        dwFlags |= CRYPT_MACHINE_KEYSET;
    }
    if (!CryptAcquireContext(
			phProv,
			pwszContainer,
			pwszProvider,
			dwProvType,
			dwFlags))
    {
	hr = myHLastError();
	_PrintErrorStr2(
	    hr,
	    (CRYPT_MACHINE_KEYSET & dwFlags)?
		"CryptAcquireContext(Machine)" : "CryptAcquireContext(User)",
	    pwszProvider,
	    (CRYPT_DELETEKEYSET & dwFlags)? hr : S_OK);
	_JumpErrorStr2(
	    hr,
	    error,
	    (CRYPT_MACHINE_KEYSET & dwFlags)?
		"CryptAcquireContext(Machine)" : "CryptAcquireContext(User)",
	    pwszContainer,
	    (CRYPT_DELETEKEYSET & dwFlags)? hr : S_OK);
    }
    hr = S_OK;
          
error:
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


HRESULT
myGetCertSrvCSP(
    IN BOOL fEncryptionCSP,
    IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *pdwProvType,
    OUT WCHAR **ppwszProvName,
    OUT ALG_ID *pidAlg,
    OUT BOOL *pfMachineKeyset,
    OPTIONAL OUT DWORD *pdwKeySize)
{
    HRESULT hr;
    HKEY    hCertSrvCSPKey = NULL;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    WCHAR  *pwszPath = NULL;
    WCHAR  *pwszProvName = NULL;
    WCHAR const *pwszRegKeyCSP;
    DWORD cwc;
    
    if (NULL != ppwszProvName)
    {
	*ppwszProvName = NULL;
    }
    if (NULL != pdwKeySize)
    {
	*pdwKeySize = 0;
    }
    if (NULL == pwszSanitizedCAName ||
	NULL == pdwProvType ||
	NULL == ppwszProvName ||
	NULL == pidAlg ||
	NULL == pfMachineKeyset)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    pwszRegKeyCSP = fEncryptionCSP? g_wszRegKeyEncryptionCSP : g_wszRegKeyCSP;
    cwc = WSZARRAYSIZE(wszREGKEYCONFIGPATH_BS) +
	    wcslen(pwszSanitizedCAName) +
	    1 +
	    wcslen(pwszRegKeyCSP);
    pwszPath = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszPath)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszPath, wszREGKEYCONFIGPATH_BS);
    wcscat(pwszPath, pwszSanitizedCAName);
    wcscat(pwszPath, L"\\");
    wcscat(pwszPath, pwszRegKeyCSP);
    CSASSERT(cwc == wcslen(pwszPath));

    hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		pwszPath,
		0,
		KEY_ALL_ACCESS,
		&hCertSrvCSPKey);
    _JumpIfErrorStr2(hr, error, "RegOpenKeyEx", pwszPath, ERROR_FILE_NOT_FOUND);

    dwValueSize = 0;
    hr = RegQueryValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProvider,
		    0,
		    &dwValueType,
		    NULL,
		    &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_SZ != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    pwszProvName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    dwValueSize + sizeof(WCHAR));
    if (NULL == pwszProvName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    hr = RegQueryValueEx(
		    hCertSrvCSPKey,
		    g_wszRegProvider,
		    0,
		    &dwValueType,
		    (BYTE *) pwszProvName,
		    &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    pwszProvName[dwValueSize / sizeof(WCHAR)] = L'\0';


    dwValueSize = sizeof(*pdwProvType);
    hr = RegQueryValueEx(hCertSrvCSPKey,
                          g_wszRegProviderType,
                          0,
                          &dwValueType,
                          (BYTE *) pdwProvType,
                          &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_DWORD != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    dwValueSize = sizeof(*pidAlg);
    hr = RegQueryValueEx(
		    hCertSrvCSPKey,
		    fEncryptionCSP? 
			g_wszRegEncryptionAlgorithm :
			g_wszRegHashAlgorithm,
		    0,
		    &dwValueType,
		    (BYTE *) pidAlg,
		    &dwValueSize);
    if (S_OK != hr && fEncryptionCSP)
    {
	_PrintErrorStr2(
		    hr,
		    "RegQueryValueEx",
		    g_wszRegEncryptionAlgorithm,
		    ERROR_FILE_NOT_FOUND);
	dwValueSize = sizeof(*pidAlg);
	hr = RegQueryValueEx(
			hCertSrvCSPKey,
			g_wszRegHashAlgorithm,
			0,
			&dwValueType,
			(BYTE *) pidAlg,
			&dwValueSize);
    }
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_DWORD != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    dwValueSize = sizeof(*pfMachineKeyset);
    hr = RegQueryValueEx(hCertSrvCSPKey,
                          g_wszRegMachineKeyset,
                          0,
                          &dwValueType,
                          (BYTE *) pfMachineKeyset,
                          &dwValueSize);
    _JumpIfError(hr, error, "RegQueryValueEx");

    if (REG_DWORD != dwValueType)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Invalid reg type");
    }

    if (NULL != pdwKeySize)
    {
	dwValueSize = sizeof(*pdwKeySize);
	hr = RegQueryValueEx(hCertSrvCSPKey,
			      g_wszRegKeySize,
			      0,
			      &dwValueType,
			      (BYTE *) pdwKeySize,
			      &dwValueSize);
	_JumpIfError(hr, error, "RegQueryValueEx");

	if (REG_DWORD != dwValueType)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Invalid reg type");
	}
    }

    *ppwszProvName = pwszProvName;
    pwszProvName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszProvName)
    {
        LocalFree(pwszProvName);
    }
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    if (NULL != hCertSrvCSPKey)
    {
        RegCloseKey(hCertSrvCSPKey);
    }
    return(myHError(hr));
}


//+------------------------------------------------------------------------
//
//  Function:   myGetSigningOID( . . . . )
//
//  Synopsis:   Determine algorithm identifer for cert creation
//  Arguments:  csp_provider_type, hash_algorithm_id.
//  Returns:    object identifier
//
//-------------------------------------------------------------------------

HRESULT
myGetSigningOID(
    OPTIONAL IN HCRYPTPROV hProv,	// hProv OR pwszProvName & dwProvType
    OPTIONAL IN WCHAR const *pwszProvName,
    OPTIONAL IN DWORD dwProvType,
    IN ALG_ID idHashAlg,
    OUT CHAR **ppszAlgId)
{
    HRESULT  hr;

    PCCRYPT_OID_INFO pcOIDInfo; //don't free it
    ALG_ID      aidAlgKey[] = {idHashAlg, 0};
    HCRYPTPROV  hProvT = NULL;
    int         i;
    DWORD       dwFlags;
    DWORD       cbData;
    PROV_ENUMALGS enumalgs;
    BOOL        fFoundSignID = FALSE;

    *ppszAlgId = NULL;
    if (NULL == hProv)
    {
	CSASSERT(NULL != pwszProvName);

	if (!myCertSrvCryptAcquireContext(
				&hProvT,
				NULL,
				pwszProvName,
				dwProvType,
				CRYPT_VERIFYCONTEXT,
				FALSE))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "myCertSrvCryptAcquireContext", pwszProvName);
	}
	hProv = hProvT;
    }

    // find public key id

    dwFlags = CRYPT_FIRST;
    for (i = 0; ; i++)
    {
        cbData = sizeof(enumalgs);
        if (!CryptGetProvParam(
			    hProv,
			    PP_ENUMALGS,
			    (BYTE *) &enumalgs,
			    &cbData,
			    dwFlags))
        {
            hr = myHLastError();
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                // out of for loop
                break;
            }
	    _JumpError(hr, error, "CryptGetProvParam");
        }
        if (ALG_CLASS_SIGNATURE == GET_ALG_CLASS(enumalgs.aiAlgid))
        {
            fFoundSignID = TRUE;
            aidAlgKey[1] = enumalgs.aiAlgid;
            break;
        }
	dwFlags = 0;
    }

    if (fFoundSignID)
    {
        pcOIDInfo = CryptFindOIDInfo(
                        CRYPT_OID_INFO_SIGN_KEY,
                        aidAlgKey,
                        CRYPT_SIGN_ALG_OID_GROUP_ID); // only signing
        if (NULL == pcOIDInfo)
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "unsupported signing algorithm");
        }
	hr = myDupStringA(pcOIDInfo->pszOID, ppszAlgId);
	_JumpIfError(hr, error, "myDupStringA");
    }
    hr = S_OK;

error:
    if (NULL != hProvT)
    {
        CryptReleaseContext(hProvT, 0);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myValidateKeyForSigning(
    IN HCRYPTPROV hProv,
    OPTIONAL IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId)
{
    HRESULT hr;
    BYTE abRandom[64];
    HCRYPTKEY hKey = NULL;
    HCRYPTHASH hHash = NULL;
    BYTE *pbSignature = NULL;
    DWORD cbSignature;

    // create a supported hash
    if (!CryptCreateHash(hProv, algId, 0, 0, &hHash))
    {
        hr = myHLastError();
	DBGPRINT((DBG_SS_ERROR, "algId = %x\n", algId));
        _JumpError(hr, error, "CryptCreateHash");
    }
    // create some random data
    if (!CryptGenRandom(hProv, ARRAYSIZE(abRandom), abRandom))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }
    if (!CryptHashData(hHash, abRandom, ARRAYSIZE(abRandom), 0))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptHashData");
    }
    // sign the hash, get size first
    if (!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, NULL, &cbSignature))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignHash");
    }
    pbSignature = (BYTE *) LocalAlloc(LMEM_FIXED, cbSignature);
    if (NULL == pbSignature)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    if (!CryptSignHash(hHash, AT_SIGNATURE, NULL, 0, pbSignature, &cbSignature))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptSignHash");
    }

    if (NULL != pPublicKeyInfo)
    {
	// import public key into provider

	if (!CryptImportPublicKeyInfo(
			hProv,
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			&hKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptImportPublicKeyInfo");
	}
    }
    else
    {
        // get public key from container

        if (!CryptGetUserKey(hProv, AT_SIGNATURE, &hKey))
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptGetUserKey");
        }
    }

    if (!CryptVerifySignature(hHash, pbSignature, cbSignature, hKey, NULL, 0))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptVerifySignature");
    }
    hr = S_OK;

error:
    if (NULL != hHash)
    {
        CryptDestroyHash(hHash);
    }
    if (NULL != hKey)
    {
        CryptDestroyKey(hKey);
    }
    if (NULL != pbSignature)
    {
        LocalFree(pbSignature);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myValidateKeyForEncrypting(
    IN HCRYPTPROV hProv,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID algId)
{
    HRESULT hr;
    HCRYPTKEY hKeyPub = NULL;
    HCRYPTKEY hKeySym = NULL;
    HCRYPTKEY hKeyPri = NULL;
    BYTE *pbKeySym = NULL;
    DWORD cbKeySym;
    BYTE abRandom[64];
    BYTE *pbEncrypted = NULL;
    BYTE *pbDecrypted = NULL;
    DWORD cbEncrypted;
    DWORD cbDecrypted;

    // import public key into provider

    if (!CryptImportPublicKeyInfo(
			hProv,
			X509_ASN_ENCODING,
			const_cast<CERT_PUBLIC_KEY_INFO *>(pPublicKeyInfo),
			&hKeyPub))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportPublicKeyInfo");
    }

    // Generate a default sized symmetric session key

    if (!CryptGenKey(hProv, algId, CRYPT_EXPORTABLE, &hKeySym))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGenKey");
    }

    // create some random data

    if (!CryptGenRandom(hProv, ARRAYSIZE(abRandom), abRandom))
    {
        hr = myHLastError();
        _JumpError(hr, error, "CryptGenRandom");
    }
#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "Plain text size = %d\n", ARRAYSIZE(abRandom)));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	abRandom,
	ARRAYSIZE(abRandom)));
#endif
    hr = myCryptEncrypt(
		    hKeySym,
		    abRandom,
		    ARRAYSIZE(abRandom),
		    &pbEncrypted,
		    &cbEncrypted);
    _JumpIfError(hr, error, "myCryptEncrypt");

#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "Encrypted size = %d\n", cbEncrypted));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pbEncrypted,
	cbEncrypted));
#endif

    hr = myCryptExportKey(hKeySym, hKeyPub, SIMPLEBLOB, 0, &pbKeySym, &cbKeySym);
    _JumpIfError(hr, error, "myCryptExportKey");

    CryptDestroyKey(hKeySym);
    hKeySym = NULL;

#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "SIMPLEBLOB:\n"));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | DH_PRIVATEDATA | 8,
	pbKeySym,
	cbKeySym));
#endif

    // get private key from container and import session key blob

    if (!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hKeyPri))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptGetUserKey");
    }
    if (!CryptImportKey(
		    hProv,
		    pbKeySym,
		    cbKeySym,
		    hKeyPri,
		    CRYPT_EXPORTABLE,
		    &hKeySym))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }
    hr = myCryptDecrypt(
		    hKeySym,
		    pbEncrypted,
		    cbEncrypted,
		    &pbDecrypted,
		    &cbDecrypted);
    _JumpIfError(hr, error, "myCryptDecrypt");

#if 1
    DBGPRINT((DBG_SS_CERTLIBI, "Decrypted size = %d\n", cbDecrypted));
    DBGDUMPHEX((
	DBG_SS_CERTLIBI,
	DH_NOADDRESS | DH_NOTABPREFIX | 8,
	pbDecrypted,
	cbDecrypted));
#endif

    if (ARRAYSIZE(abRandom) != cbDecrypted ||
	0 != memcmp(abRandom, pbDecrypted, ARRAYSIZE(abRandom)))
    {
	hr = NTE_BAD_KEY;
	_JumpIfError(hr, error, "Decrypted data mismatch");
    }
    hr = S_OK;

error:
    if (NULL != hKeyPub)
    {
        CryptDestroyKey(hKeyPub);
    }
    if (NULL != hKeySym)
    {
        CryptDestroyKey(hKeySym);
    }
    if (NULL != hKeyPri)
    {
        CryptDestroyKey(hKeyPri);
    }
    if (NULL != pbEncrypted)
    {
	LocalFree(pbEncrypted);
    }
    if (NULL != pbDecrypted)
    {
	LocalFree(pbDecrypted);
    }
    if (NULL != pbKeySym)
    {
	LocalFree(pbKeySym);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myValidateSigningKey(
    IN WCHAR const *pwszKeyContainerName,
    IN WCHAR const *pwszProvName,
    IN DWORD dwProvType,
    IN BOOL fCryptSilent,
    IN BOOL fMachineKeyset,
    IN BOOL fForceSignatureTest,
    IN OPTIONAL CERT_CONTEXT const *pcc,
    IN OPTIONAL CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN ALG_ID idAlg,
    OPTIONAL OUT BOOL *pfSigningTestAttempted,
    OPTIONAL OUT HCRYPTPROV *phProv)
{
    HRESULT hr;
    HCRYPTPROV hProv = NULL;
    BOOL fCountSupported;
    BOOL fCountEnabled;
    BOOL fMatchingKey;

    if (NULL != pfSigningTestAttempted)
    {
	*pfSigningTestAttempted = FALSE;
    }
    if (NULL != phProv)
    {
	*phProv = NULL;
    }
    if (!myCertSrvCryptAcquireContext(
			       &hProv,
			       pwszKeyContainerName,
			       pwszProvName,
			       dwProvType,
			       fCryptSilent? CRYPT_SILENT : 0,
			       fMachineKeyset))
    {
	hr = myHLastError();
	_JumpErrorStr(
		    hr,
		    error,
		    "myCertSrvCryptAcquireContext",
		    pwszKeyContainerName);
    }

    if (NULL == pPublicKeyInfo && NULL != pcc)
    {
	pPublicKeyInfo = &pcc->pCertInfo->SubjectPublicKeyInfo;
    }
    if (NULL != pPublicKeyInfo)
    {
	hr = myVerifyPublicKeyFromHProv(
			hProv,
			AT_SIGNATURE,
			pcc,
			NULL != pcc && CERT_V1 == pcc->pCertInfo->dwVersion,
			pPublicKeyInfo,
			&fMatchingKey);
	_JumpIfError(hr, error, "myVerifyPublicKeyFromHProv");

	if (!fMatchingKey)
	{
	    hr = NTE_BAD_KEY;
	    _JumpError(hr, error, "fMatchingKey");
	}
    }

    hr = myGetSigningKeyUsageCount(
			    hProv,
			    &fCountSupported,
			    &fCountEnabled,
			    NULL);		// puliCount
    _JumpIfError(hr, error, "myGetSigningKeyUsageCount");

    if (fForceSignatureTest || !fCountSupported || !fCountEnabled)
    {
	// test signing

	if (NULL != pfSigningTestAttempted)
	{
	    *pfSigningTestAttempted = TRUE;
	}
	hr = myValidateKeyForSigning(hProv, pPublicKeyInfo, idAlg);
	_JumpIfError(hr, error, "myValidateKeyForSigning");
    }
    if (NULL != phProv)
    {
	*phProv = hProv;
	hProv = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    return(hr);
}


HRESULT
GenerateTemporaryContainerName(
    OUT WCHAR **ppwszKeyContainerName)
{
    HRESULT hr;
    GUID guid;
    WCHAR awcbuf[MAX_PATH];
    DWORD cb;
    DWORD cwc;

    myGenerateGuidSerialNumber(&guid);

    wcscpy(awcbuf, L"KeyVerification--");
    cwc = wcslen(awcbuf);
    cb = sizeof(awcbuf) - cwc * sizeof(WCHAR);
    hr = MultiByteIntegerToWszBuf(
			FALSE,
			sizeof(guid),
			(BYTE const *) &guid,
			&cb,
			&awcbuf[cwc]);
    _JumpIfError(hr, error, "MultiByteIntegerToWszBuf");

    hr = myDupString(awcbuf, ppwszKeyContainerName);
    _JumpIfError(hr, error, "myDupString");

error:
    return(hr);
}


VOID
DeleteRSAKeyContainer(
    IN WCHAR const *pwszKeyContainerName,
    IN BOOL fMachineKeyset)
{
    HCRYPTPROV hProv;
    DWORD dwFlags = CRYPT_DELETEKEYSET;

    if (fMachineKeyset)
    {
        dwFlags |= CRYPT_MACHINE_KEYSET;
    }
    CryptAcquireContext(
		    &hProv,
		    pwszKeyContainerName,
		    NULL,		// pwszProvName
		    PROV_RSA_FULL,
		    dwFlags);
}


HRESULT
myValidateKeyBlob(
    IN BYTE const *pbKey,
    IN DWORD cbKey,
    IN CERT_PUBLIC_KEY_INFO const *pPublicKeyInfo,
    IN BOOL fV1Cert,
    OUT BOOL *pfSigningKey,
    OPTIONAL OUT CRYPT_KEY_PROV_INFO *pkpi)
{
    HRESULT hr;
    WCHAR *pwszKeyContainerName = NULL;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hKey = NULL;
    CRYPT_KEY_PROV_INFO kpi;
    BOOL fMatchingKey;

    // Use a NULL container name in a CRYPT_VERIFYCONTEXT to avoid persisting
    // the private key -- unless the caller asked for the KeyProvInfo to be
    // filled in and returned.

    *pfSigningKey = FALSE;

    if (NULL != pkpi)
    {
	hr = GenerateTemporaryContainerName(&pwszKeyContainerName);
	_JumpIfError(hr, error, "GenerateTemporaryContainerName");

	DeleteRSAKeyContainer(pwszKeyContainerName, FALSE);

	DBGPRINT((DBG_SS_CERTLIBI, "Key Container: %ws\n", pwszKeyContainerName));
    }

    if (!CryptAcquireContext(
			&hProv,
			pwszKeyContainerName,
			NULL,
			PROV_RSA_FULL,
			NULL == pkpi? CRYPT_VERIFYCONTEXT : CRYPT_NEWKEYSET))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptAcquireContext");
    }

    if (!CryptImportKey(
		    hProv,
		    pbKey,
		    cbKey,
		    NULL,		// hPubKey
		    CRYPT_EXPORTABLE,
		    &hKey))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CryptImportKey");
    }
    CryptDestroyKey(hKey);
    hKey = NULL;

    ZeroMemory(&kpi, sizeof(kpi));
    kpi.pwszContainerName = pwszKeyContainerName;
    kpi.dwProvType = PROV_RSA_FULL;
    kpi.dwKeySpec = AT_KEYEXCHANGE;
    if (!CryptGetUserKey(hProv, kpi.dwKeySpec, &hKey))
    {
	hr = myHLastError();
	_PrintError2(hr, "CryptGetUserKey", hr);

	kpi.dwKeySpec = AT_SIGNATURE;
	if (!CryptGetUserKey(hProv, kpi.dwKeySpec, &hKey))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptGetUserKey");
	}
	*pfSigningKey = TRUE;
    }
    CryptDestroyKey(hKey);
    hKey = NULL;

    if (NULL != pkpi)
    {
	CryptReleaseContext(hProv, 0);
	hProv = NULL;

	if (!CryptAcquireContext(
			    &hProv,
			    pwszKeyContainerName,
			    NULL,
			    PROV_RSA_FULL,
			    0))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptAcquireContext");
	}
    }
    if (AT_SIGNATURE == kpi.dwKeySpec)
    {
	hr = myValidateKeyForSigning(hProv, pPublicKeyInfo, CALG_SHA1);
	_PrintIfError(hr, "myValidateKeyForSigning");
    }
    else
    {
	hr = myValidateKeyForEncrypting(hProv, pPublicKeyInfo, CALG_RC4);
	_PrintIfError(hr, "myValidateKeyForEncrypting");
    }
    if (S_OK != hr)
    {
	_JumpError(hr, error, "Key Validation");
    }

    hr = myVerifyPublicKeyFromHProv(
			    hProv,
			    kpi.dwKeySpec,
			    NULL,		// pCert
			    fV1Cert,
			    pPublicKeyInfo,
			    &fMatchingKey);
    _JumpIfError(hr, error, "myVerifyPublicKeyFromHProv");

    if (!fMatchingKey)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "Key doesn't match cert");
    }
    if (NULL != pkpi)
    {
	*pkpi = kpi;
	pwszKeyContainerName = NULL;
    }

error:
    if (NULL != hKey)
    {
	CryptDestroyKey(hKey);
    }
    if (NULL != hProv)
    {
	CryptReleaseContext(hProv, 0);
    }
    if (NULL != pwszKeyContainerName)
    {
	DeleteRSAKeyContainer(pwszKeyContainerName, FALSE);
	LocalFree(pwszKeyContainerName);
    }
    return(hr);
}


/*
 *      myEnumProviders
 *
 *      Purpose:
 *                Enumerate the providers.
 *
 *      Parameters:
 *                IN  dwIndex        - Index to the providers to enumerate
 *                IN  pdwReserved    - Reserved for future use
 *                IN  dwFlags        - Flags parameter
 *                OUT pdwProvType    - The type of the provider
 *                OUT ppwszProvName  - Name of the enumerated provider
 */

HRESULT
myEnumProviders(
    IN DWORD dwIndex,
    IN DWORD *pdwReserved,
    IN DWORD dwFlags,
    OUT DWORD *pdwProvType,
    OUT WCHAR **ppwszProvName)
{
    HRESULT hr;
    char *pszProvName = NULL;
    DWORD cbProvName;

    *ppwszProvName = NULL;
    
    for (;;)
    {
	if (!CryptEnumProvidersA(
			dwIndex,
			pdwReserved,
			dwFlags,
			pdwProvType,
			pszProvName,
			&cbProvName))
	{
	    hr = myHLastError();
	    _JumpError2(hr, error, "CryptEnumProvidersA", hr);
	}
	if (NULL != pszProvName)
	{
	    break;
	}

        // allocate ansi string buffer

        pszProvName = (char *) LocalAlloc(LMEM_FIXED, cbProvName);
        if (NULL == pszProvName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }

    if (!myConvertSzToWsz(ppwszProvName, pszProvName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }
    hr = S_OK;

error:
    if (NULL != pszProvName)
    {
        LocalFree(pszProvName);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\cspelog.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       cspelog.cpp
//
//  Contents:   implements policy and exit module logging routines.
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_CSPELOG_CPP__


HRESULT
SetModuleErrorInfo(
    IN ICreateErrorInfo *pCreateErrorInfo)
{
    HRESULT hr;
    IErrorInfo *pErrorInfo = NULL;

    hr = pCreateErrorInfo->QueryInterface(
				IID_IErrorInfo,
				(VOID **) &pErrorInfo);
    _JumpIfError(hr, error, "QueryInterface");

    hr = SetErrorInfo(0, pErrorInfo);
    _JumpIfError(hr, error, "SetErrorInfo");

error:
    if (NULL != pErrorInfo)
    {
        pErrorInfo->Release();
    }
    return(hr);
}


HRESULT
LogModuleStatus(
    IN HMODULE hModule,
    IN HRESULT hrMsg,
    IN DWORD dwLogID,				// Resource ID of log string
    IN BOOL fPolicy, 
    IN WCHAR const *pwszSource, 
    IN WCHAR const * const *ppwszInsert,	// array of insert strings
    OPTIONAL OUT ICreateErrorInfo **ppCreateErrorInfo)
{
    HRESULT hr;
    WCHAR *pwszResult = NULL;
    ICreateErrorInfo *pCreateErrorInfo = NULL;

    if (NULL != ppCreateErrorInfo)
    {
	*ppCreateErrorInfo = NULL;
    }
    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_ARGUMENT_ARRAY |
			FORMAT_MESSAGE_FROM_HMODULE,
		    hModule,
		    dwLogID,
		    0,
		    (WCHAR *) &pwszResult,
		    0,
		    (va_list *) ppwszInsert))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FormatMessage");
    }

    hr = CreateErrorInfo(&pCreateErrorInfo);
    _JumpIfError(hr, error, "CreateErrorInfo");

    hr = pCreateErrorInfo->SetGUID(fPolicy? IID_ICertPolicy : IID_ICertExit);
    _PrintIfError(hr, "SetGUID");

    if (S_OK != hrMsg)
    {
	WCHAR wszhr[cwcDWORDSPRINTF];

	wsprintf(wszhr, L"0x%x", hrMsg);
	hr = myPrependString(wszhr, L", ", &pwszResult);
	_PrintIfError(hr, "myPrependString");
    }
    DBGPRINT((
	fPolicy? DBG_SS_CERTPOL : DBG_SS_CERTEXIT,
	"LogModuleStatus(%ws): %ws\n",
	pwszSource,
	pwszResult));

    hr = pCreateErrorInfo->SetDescription(pwszResult);
    _PrintIfError(hr, "SetDescription");

    // Set ProgId:

    hr = pCreateErrorInfo->SetSource(const_cast<WCHAR *>(pwszSource));
    _PrintIfError(hr, "SetSource");

    if (NULL != ppCreateErrorInfo)
    {
	*ppCreateErrorInfo = pCreateErrorInfo;
	pCreateErrorInfo = NULL;
    }
    else
    {
	hr = SetModuleErrorInfo(pCreateErrorInfo);
	_JumpIfError(hr, error, "SetModuleErrorInfo");
    }
    hr = S_OK;

error:
    if (NULL != pwszResult)
    {
        LocalFree(pwszResult);
    }
    if (NULL != pCreateErrorInfo)
    {
        pCreateErrorInfo->Release();
    }
    return(hr);
}


HRESULT
LogPolicyEvent(
    IN HMODULE hModule,
    IN HRESULT hrMsg,
    IN DWORD dwLogID,				// Resource ID of log string
    IN ICertServerPolicy *pServer,
    IN WCHAR const *pwszPropEvent,
    IN WCHAR const * const *ppwszInsert)	// array of insert strings
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    BSTR strName = NULL;
    VARIANT varValue;

    if (0 == FormatMessage(
		    FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_ARGUMENT_ARRAY |
			FORMAT_MESSAGE_FROM_HMODULE,
		    hModule,
		    dwLogID,
		    0,
		    (WCHAR *) &pwszValue,
		    0,
		    (va_list *) ppwszInsert))
    {
	hr = myHLastError();
	_JumpError(hr, error, "FormatMessage");
    }
    DBGPRINT((DBG_SS_CERTPOL, "LogPolicyEvent: %ws\n", pwszValue));

    varValue.vt = VT_EMPTY;

    if (!myConvertWszToBstr(&strName, pwszPropEvent, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }

    if (S_OK != hrMsg)
    {
	WCHAR wszhr[cwcDWORDSPRINTF];

	wsprintf(wszhr, L"0x%x", hrMsg);
	hr = myPrependString(wszhr, L",", &pwszValue);
	_PrintIfError(hr, "myPrependString");
    }
    varValue.bstrVal = NULL;
    if (!myConvertWszToBstr(&varValue.bstrVal, pwszValue, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertWszToBstr");
    }
    varValue.vt = VT_BSTR;
    
    hr = pServer->SetCertificateProperty(strName, PROPTYPE_STRING, &varValue);
    _JumpIfError(hr, error, "SetCertificateProperty");

error:
    VariantClear(&varValue);
    if (NULL != strName)
    {
	SysFreeString(strName);
    }
    if (NULL != pwszValue)
    {
        LocalFree(pwszValue);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\csw97ppg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97ppg.cpp
//
//--------------------------------------------------------------------------

// csw97ppg.cpp : implementation file

#include <pch.cpp>

#pragma hdrstop

#include "prsht.h"
#include "csw97ppg.h"
//#include "resource.h"


#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage property page
//IMPLEMENT_DYNCREATE(CWizard97PropertyPage, CPropertyPage)

CWizard97PropertyPage::CWizard97PropertyPage() :
    PropertyPage(),
    m_pWiz(NULL)
{
    ASSERT(0); // default constructor - should never be called
}


CWizard97PropertyPage::CWizard97PropertyPage(
    HINSTANCE hInstance,
    UINT nIDTemplate,
    UINT rgnIDFont[CSW97PG_COUNT]) :
    PropertyPage(nIDTemplate),
    m_pWiz(NULL)
{
    //{{AFX_DATA_INIT(CWizard97PropertyPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hInstance = hInstance;
    CopyMemory(m_rgnIDFont, rgnIDFont, sizeof(m_rgnIDFont));
}


CWizard97PropertyPage::~CWizard97PropertyPage()
{
}


/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage message handlers

void
CWizard97PropertyPage::InitWizard97(
    bool bHideHeader)
{
    ZeroMemory(&m_psp97, sizeof(PROPSHEETPAGE));
    CopyMemory(&m_psp97, &m_psp, m_psp.dwSize);
    m_psp97.dwSize = sizeof(PROPSHEETPAGE);

    if (bHideHeader)
    {
	// for first and last page of the wizard
	m_psp97.dwFlags |= PSP_HIDEHEADER;
    }
    else
    {
	// for intermediate pages
	m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
	m_psp97.pszHeaderTitle = (LPCTSTR) m_szHeaderTitle;
	m_psp97.pszHeaderSubTitle = (LPCTSTR) m_szHeaderSubTitle;
    }
}


BOOL
CWizard97PropertyPage::SetupFonts()
{
    BOOL bReturn = FALSE;
    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
    LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
    // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;

    WCHAR	largeFontSizeString[24];
    INT		largeFontSize;
    WCHAR	smallFontSizeString[24];
    INT		smallFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if (!::LoadString(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDLARGEFONTNAME],
		BigBoldLogFont.lfFaceName,
		LF_FACESIZE)) 
    {
	ASSERT(0);
        lstrcpy(BigBoldLogFont.lfFaceName, L"MS Shell Dlg");
    }

    if (::LoadStringW(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDLARGEFONTSIZE],
		largeFontSizeString,
		ARRAYSIZE(largeFontSizeString))) 
    {
        largeFontSize = wcstoul(largeFontSizeString, NULL, 10);
    } 
    else 
    {
	ASSERT(0);
        largeFontSize = 12;
    }

    if (!::LoadString(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDSMALLFONTNAME],
		BoldLogFont.lfFaceName,
		LF_FACESIZE)) 
    {
		ASSERT(0);
        lstrcpy(BoldLogFont.lfFaceName, L"MS Shell Dlg");
    }

    if (::LoadStringW(
		m_hInstance,
		m_rgnIDFont[CSW97PG_IDSMALLFONTSIZE],
		smallFontSizeString,
		ARRAYSIZE(smallFontSizeString))) 
    {
        smallFontSize = wcstoul(smallFontSizeString, NULL, 10);
    } 
    else 
    {
	ASSERT(0);
        smallFontSize = 8;
    }

    HDC hdc = GetDC(m_hWnd);

    if (hdc)
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * largeFontSize / 72);
        BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc, LOGPIXELSY) * smallFontSize / 72);


        BOOL bBigBold = m_bigBoldFont.CreateFontIndirect(&BigBoldLogFont);
	BOOL bBold = m_boldFont.CreateFontIndirect(&BoldLogFont);

        ReleaseDC(m_hWnd, hdc);

        if (bBigBold && bBold)
	{
	    bReturn = TRUE;
	}
    }
    return bReturn;
}


HFONT
CWizard97PropertyPage::GetBoldFont()
{
    return m_boldFont;
}


HFONT
CWizard97PropertyPage::GetBigBoldFont()
{
    return m_bigBoldFont;
}



BOOL CWizard97PropertyPage::OnInitDialog() 
{
    PropertyPage::OnInitDialog();
	
    SetupFonts();
	
    return TRUE;  // return TRUE unless you set the focus to a control
		  // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\cstring.cpp ===
#include <pch.cpp>
#pragma hdrstop

#include "tfc.h"

#define __dwFILE__	__dwFILE_CERTLIB_CSTRING_CPP__

extern HINSTANCE g_hInstance;

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CString
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

CString::CString()
{ 
    Init();
}

CString::CString(const CString& stringSrc)
{
	Init();
	*this = stringSrc;
}

CString::CString(LPCSTR lpsz)
{
    Init();
    *this = lpsz;
}

CString::CString(LPCWSTR lpsz)
{
    Init();
    *this = lpsz;
}

CString::~CString() 
{ 
    if (szData)
    {    
        LocalFree(szData); 
        szData = NULL;
    }
    dwDataLen = 0;
}

// called to initialize cstring
void CString::Init()
{
    szData = NULL;
    dwDataLen = 0;
}

// called to make cstring empty
void CString::Empty() 
{ 
    if (szData)
    {
        // Allow us to use ReAlloc
        szData[0]=L'\0';
        dwDataLen = sizeof(WCHAR);
    }
    else
        dwDataLen = 0;

}

BOOL CString::IsEmpty() const
{ 
    return ((NULL == szData) || (szData[0] == L'\0')); 
}

LPWSTR CString::GetBuffer(DWORD cch) 
{ 
    // get buffer of at least cch CHARS

    cch ++; // incl null term
    cch *= sizeof(WCHAR); // cb

    if (cch > dwDataLen) 
    {
        LPWSTR szTmp;
        if (szData)
            szTmp = (LPWSTR)LocalReAlloc(szData, cch, LMEM_MOVEABLE); 
        else
            szTmp = (LPWSTR)LocalAlloc(LMEM_FIXED, cch);

        if (!szTmp)
        {
            LocalFree(szData);
            dwDataLen = 0;
        }
        else
        {
            dwDataLen = cch;
        }

        szData = szTmp;
    }
    return szData; 
}

BSTR CString::AllocSysString() const
{
    return SysAllocStringLen(szData, (dwDataLen-1)/sizeof(WCHAR));
}


DWORD CString::GetLength() const
{ 
    // return # chars in string (not incl NULL term)
    return ((dwDataLen > 0) ? wcslen(szData) : 0);
}

// warning: insertion strings cannot exceed MAX_PATH chars
void CString::Format(LPCWSTR lpszFormat, ...)
{
    Empty();
    
    DWORD cch = wcslen(lpszFormat) + MAX_PATH;
    GetBuffer(cch);     // chars (don't count NULL term)

    if (szData != NULL)
    {
        DWORD dwformatted;
        int cPrint;
        va_list argList;
        va_start(argList, lpszFormat);
        cPrint = _vsnwprintf(szData, cch, lpszFormat, argList);
        if(-1 == cPrint)
        {
            szData[cch-1] = L'\0';
            dwformatted = cch-1;
        }
        else
        {
            dwformatted = cPrint;
        }
        va_end(argList);
        
        dwformatted = (dwformatted+1)*sizeof(WCHAR);    // cvt to bytes
        VERIFY (dwformatted <= dwDataLen);
        dwDataLen = dwformatted;
    }
    else
    {
        ASSERT(dwDataLen == 0);
        dwDataLen = 0;
    }
}



BOOL CString::LoadString(UINT iRsc) 
{
    WCHAR *pwszResource = myLoadResourceStringNoCache(g_hInstance, iRsc);
    if (NULL == pwszResource)
        return FALSE;
    
    Attach(pwszResource);

    return TRUE;
}

BOOL CString::FromWindow(HWND hWnd)
{
    Empty();
    
    INT iCh = (INT)SendMessage(hWnd, WM_GETTEXTLENGTH, 0, 0);

    GetBuffer(iCh);

    if (NULL == szData)
        return FALSE;

    if (dwDataLen != (DWORD)SendMessage(hWnd, WM_GETTEXT, (WPARAM)(dwDataLen/sizeof(WCHAR)), (LPARAM)szData))
    {
        // truncation!
    }
    return TRUE;
}


BOOL CString::ToWindow(HWND hWnd)
{
    return (BOOL)SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)szData);
}

void CString::SetAt(int nIndex, WCHAR ch) 
{ 
    ASSERT(nIndex <= (int)(dwDataLen / sizeof(WCHAR)) ); 
    if (nIndex <= (int)(dwDataLen / sizeof(WCHAR)) )
        szData[nIndex] = ch;
}

// test
BOOL CString::IsEqual(LPCWSTR sz)
{
    if ((szData == NULL) || (szData[0] == L'\0'))
        return ((sz == NULL) || (sz[0] == L'\0'));

    if (sz == NULL)
        return FALSE;

    return (0 == lstrcmp(sz, szData));
}


// assignmt
const CString& CString::operator=(const CString& stringSrc) 
{ 
    if (stringSrc.IsEmpty())
        Empty();
    else
    {
        GetBuffer( stringSrc.GetLength() );
        if (szData != NULL)
        {
            CopyMemory(szData, stringSrc.szData, sizeof(WCHAR)*(stringSrc.GetLength()+1));
        }
    }
    
    return *this;
}

// W Const
const CString& CString::operator=(LPCWSTR lpsz)
{
    if (lpsz == NULL)
        Empty();
    else
    {
        GetBuffer(wcslen(lpsz));
        if (szData != NULL)
        {
            CopyMemory(szData, lpsz, sizeof(WCHAR)*(wcslen(lpsz)+1));
        }
    }
    return *this;
}
// W 
const CString& CString::operator=(LPWSTR lpsz)
{
    *this = (LPCWSTR)lpsz;
    return *this;
}


// A Const
const CString& CString::operator=(LPCSTR lpsz)
{
    if (lpsz == NULL)
        Empty();
    else
    {
        DWORD cch;
        cch = ::MultiByteToWideChar(CP_ACP, 0, lpsz, -1, NULL, 0);
        GetBuffer(cch-1);
        if (szData != NULL)
        {
            ::MultiByteToWideChar(CP_ACP, 0, lpsz, -1, szData, cch);
        }
    }    
    return *this;
}

// A 
const CString& CString::operator=(LPSTR lpsz)
{
    *this = (LPCSTR)lpsz;
    return *this;
}

// concat
const CString& CString::operator+=(LPCWSTR lpsz)
{
    if (IsEmpty())
    {
        *this = lpsz;
        return *this;
    }

    if (lpsz != NULL)
    {
        GetBuffer(wcslen(lpsz) + GetLength() );
        if (szData != NULL)
        {
            wcscat(szData, lpsz);
        }
    }
    return *this;
}

const CString& CString::operator+=(const CString& string)
{
    if (IsEmpty()) 
    {
        *this = string;
        return *this;
    }

    if (!string.IsEmpty())
    {
        GetBuffer( string.GetLength() + GetLength() );    // don't count NULL terms
        if (szData != NULL)
        {
            wcscat(szData, string.szData);
        }
    }
    return *this;
}

void CString::Attach(LPWSTR pcwszSrc)
{
    if(szData)
    {
        LocalFree(szData);
    }

    dwDataLen = sizeof(WCHAR)*(wcslen(pcwszSrc)+1);
    szData = pcwszSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\exitdisp.cpp ===
#include <pch.cpp>
#pragma hdrstop
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__      __dwFILE_CERTLIB_EXITDISP_CPP__


//+------------------------------------------------------------------------
// ICertExit dispatch support

//+------------------------------------
// Initialize method:

OLECHAR *exit_apszInitialize[] = {
    TEXT("Initialize"),
    TEXT("strConfig"),
};

//+------------------------------------
// Notify method:

OLECHAR *exit_apszNotify[] = {
    TEXT("Notify"),
    TEXT("ExitEvent"),
    TEXT("Context"),
};

//+------------------------------------
// GetDescription method:

OLECHAR *exit_apszGetDescription[] = {
    TEXT("GetDescription"),
};

//+------------------------------------
// GetManageModule method:

OLECHAR *exit_apszGetManageModule[] = {
    TEXT("GetManageModule"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtExit[] =
{
    DECLARE_DISPATCH_ENTRY(exit_apszInitialize)
    DECLARE_DISPATCH_ENTRY(exit_apszNotify)
    DECLARE_DISPATCH_ENTRY(exit_apszGetDescription)
    DECLARE_DISPATCH_ENTRY(exit_apszGetManageModule)
};
DWORD CEXITDISPATCH		(ARRAYSIZE(g_adtExit));


DWORD s_acExitDispatch[] = {
    CEXITDISPATCH_V2,
    CEXITDISPATCH_V1,
};

IID const *s_apExitiid[] = {
    &IID_ICertExit2,
    &IID_ICertExit,
};


HRESULT
Exit_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdi)
{
    HRESULT hr;

    hr = DispatchSetup2(
                Flags,
                CLSCTX_INPROC_SERVER,
                pcwszProgID, // g_wszRegKeyCIPolicyClsid,
                pclsid,
                ARRAYSIZE(s_acExitDispatch),
                s_apExitiid,
                s_acExitDispatch,
                g_adtExit,
                pdi);
    _JumpIfError(hr, error, "DispatchSetup");

    pdi->pDispatchTable = g_adtExit;

error:
    return(hr);
}


VOID
Exit_Release(
    IN OUT DISPATCHINTERFACE *pdiManage)
{
    DispatchRelease(pdiManage);
}


HRESULT
ExitVerifyVersion(
    IN DISPATCHINTERFACE *pdiExit,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiExit && NULL != pdiExit->pDispatchTable);

    switch (pdiExit->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiExit->pDispatch ||
		CEXITDISPATCH_V1 == pdiExit->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiExit->pDispatch ||
		CEXITDISPATCH_V2 == pdiExit->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiExit->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Exit_Initialize(
    IN DISPATCHINTERFACE *pdiExit,
    IN WCHAR const *pwszConfig,
    OUT LONG *pEventMask)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    hr = S_OK;
    __try
    {
	if (NULL != pdiExit->pDispatch)
	{
	    VARIANT avar[1];

	    CSASSERT(NULL != pdiExit->pDispatchTable);
	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;

	    hr = DispatchInvoke(
			    pdiExit,
			    EXIT_INITIALIZE,
			    ARRAYSIZE(avar),
			    avar,
			    VT_I4,
			    pEventMask);
	    _LeaveIfError(hr, "Invoke(Initialize)");
	}
	else
	{
	    hr = ((ICertExit *) pdiExit->pUnknown)->Initialize(
							    strConfig,
							    pEventMask);
	    _LeaveIfError(hr, "ICertExit::Initialize");
	}
    }
    __finally
    {
	if (NULL != strConfig)
	{
	    SysFreeString(strConfig);
	}
    }

error:
    return(hr);
}


HRESULT
Exit_Notify(
    IN DISPATCHINTERFACE *pdiExit,
    IN LONG ExitEvent,
    IN LONG Context)
{
    HRESULT hr;

    if (NULL != pdiExit->pDispatch)
    {
	VARIANT avar[2];

	CSASSERT(NULL != pdiExit->pDispatchTable);
	avar[0].vt = VT_I4;
	avar[0].lVal = ExitEvent;
	avar[1].vt = VT_I4;
	avar[1].lVal = Context;

	hr = DispatchInvoke(
			pdiExit,
			EXIT_NOTIFY,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Notify)");
    }
    else
    {
	hr = ((ICertExit *) pdiExit->pUnknown)->Notify(ExitEvent, Context);
	_JumpIfError(hr, error, "ICertExit::Notify");
    }

error:
    return(hr);
}


HRESULT
Exit_GetDescription(
    IN DISPATCHINTERFACE *pdiExit,
    OUT BSTR *pstrDescription)
{
    HRESULT hr;

    if (NULL != pdiExit->pDispatch)
    {
	CSASSERT(NULL != pdiExit->pDispatchTable);

	hr = DispatchInvoke(
			pdiExit,
			EXIT_GETDESCRIPTION,
			0,
			NULL,
			VT_BSTR,
			pstrDescription);
	_JumpIfError(hr, error, "Invoke(GetDescription)");
    }
    else
    {
	hr = ((ICertExit *) pdiExit->pUnknown)->GetDescription(pstrDescription);
	_JumpIfError(hr, error, "ICertExit::GetDescription");
    }

error:
    return(hr);
}


HRESULT
Exit2_GetManageModule(
    IN DISPATCHINTERFACE *pdiExit,
    OUT DISPATCHINTERFACE *pdiManageModule)
{
    HRESULT hr;
    ICertManageModule *pManageModule = NULL;

    hr = ExitVerifyVersion(pdiExit, 2);
    _JumpIfError(hr, error, "ExitVerifyVersion");

    if (NULL != pdiExit->pDispatch)
    {
	CSASSERT(NULL != pdiExit->pDispatchTable);

	hr = DispatchInvoke(
			pdiExit,
			EXIT2_GETMANAGEMODULE,
			0,
			NULL,
			VT_DISPATCH,
			&pManageModule);
	_JumpIfError(hr, error, "Invoke(GetManageModule)");
    }
    else
    {
	hr = ((ICertExit2 *) pdiExit->pUnknown)->GetManageModule(
							&pManageModule);
	_JumpIfError(hr, error, "ICertExit::GetManageModule");
    }

    hr = ManageModule_Init2(
		NULL != pdiExit->pDispatch,
		pManageModule,
		pdiManageModule);
    _JumpIfError(hr, error, "ManageModule_Init2");

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\dcom.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dcom.cpp
//
//  Contents:   IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certsrvd.h"

#define __dwFILE__      __dwFILE_CERTLIB_DCOM_CPP__


HRESULT
mySplitConfigString(
    IN WCHAR const *pwszConfig,
    OUT WCHAR **ppwszServer,
    OUT WCHAR **ppwszAuthority)
{
    HRESULT hr;
    WCHAR const *pwsz;
    DWORD cwcServer;
    WCHAR *pwszAuthority = NULL;
    
    *ppwszServer = NULL;
    *ppwszAuthority = NULL;
    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwcServer = wcslen(pwszConfig);
    }
    else
    {
        cwcServer = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
	pwsz++;

	pwszAuthority = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(wcslen(pwsz) + 1) * sizeof(WCHAR));
	if (NULL == pwszAuthority)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszAuthority, pwsz);
    }
    *ppwszServer = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwcServer + 1) * sizeof(WCHAR));
    if (NULL == *ppwszServer)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszServer, pwszConfig, cwcServer * sizeof(WCHAR));
    (*ppwszServer)[cwcServer] = L'\0';

    *ppwszAuthority = pwszAuthority;
    pwszAuthority = NULL;
    hr = S_OK;

error:
    if (NULL != pwszAuthority)
    {
	LocalFree(pwszAuthority);
    }
    return(hr);
}


HRESULT
_OpenDComConnection(
    IN WCHAR const *pwszConfig,
    IN CLSID const *pclsid,
    IN IID const *piid,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OUT BOOL *pfNewConnection,
    IN OUT IUnknown **ppUnknown)
{
    HRESULT hr;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwsz;
    DWORD cwc;
    COSERVERINFO ComponentInfo;
    MULTI_QI mq;
    WCHAR *pwcDot = NULL;

    if (NULL == pwszConfig ||
	NULL == pclsid ||
	NULL == piid ||
	NULL == pfNewConnection ||
	NULL == ppUnknown)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    CSASSERT(NULL != pwszConfig);
    *pfNewConnection = FALSE;

    // Allow UNC-style config strings: \\server\CaName

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwc = wcslen(pwszConfig);
        if (NULL != ppwszAuthority)
        {
	    *ppwszAuthority = &pwszConfig[cwc];
        }
    }
    else
    {
        cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
        if (NULL != ppwszAuthority)
        {
	    *ppwszAuthority = &pwsz[1];
        }
    }
    pwszServerName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszServerName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszServerName, pwszConfig, cwc * sizeof(WCHAR));
    pwszServerName[cwc] = L'\0';

    // NOTE: CoSetProxyBlanket returns RPC_S_UNKNOWN_AUTHN_SERVICE when
    // the Dns name ends with a '.'.  Until that's fixed, truncate the dot.

    if (0 < cwc && L'.' == pwszServerName[cwc - 1])
    {
        pwszServerName[cwc - 1] = L'\0';
        cwc--;
    }

    if (NULL == *ppUnknown ||
	NULL == ppwszServerName ||
	NULL == *ppwszServerName ||
	0 != mylstrcmpiL(pwszServerName, *ppwszServerName))
    {
        ZeroMemory(&ComponentInfo, sizeof(COSERVERINFO));
        ComponentInfo.pwszName = pwszServerName;
        //ComponentInfo.pAuthInfo = NULL;

        mq.pIID = piid;
        mq.pItf = NULL;
        mq.hr = S_OK;

        myCloseDComConnection(ppUnknown, ppwszServerName);

        for (;;)
	{
	    hr = CoCreateInstanceEx(
			    *pclsid,
			    NULL,
			    CLSCTX_SERVER, //CLSCTX_LOCAL_SERVER,
			    &ComponentInfo,
			    1,
			    &mq);
	    _PrintIfErrorStr2(
			hr,
			"CoCreateInstanceEx",
			pwszServerName,
			E_NOINTERFACE);

	    if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr &&
		0 < cwc &&
		L'.' == pwszServerName[cwc - 1])
	    {
		pwcDot = &pwszServerName[cwc - 1];
		*pwcDot = L'\0';
		continue;
	    }
	    break;
	}
	if (NULL != pwcDot)
	{
	    *pwcDot = L'.';
	}
	_JumpIfErrorStr2(hr, error, "CoCreateInstanceEx", pwszServerName, hr);

	*ppUnknown = mq.pItf;
	if (NULL != ppwszServerName)
	{
	    CSASSERT(NULL == *ppwszServerName);
	    *ppwszServerName = pwszServerName;
	    pwszServerName = NULL;
	}

	*pfNewConnection = TRUE;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	myCloseDComConnection(ppUnknown, ppwszServerName);
    }
    if (NULL != pwszServerName)
    {
	LocalFree(pwszServerName);
    }
    return(hr);
}


HRESULT
_OpenDComConnection2(
    IN WCHAR const *pwszConfig,
    IN CLSID const *pclsid,
    IN IID const *piid, // v1 interface
    IN IID const *piid2,// v2 interface
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OPTIONAL OUT BOOL *pfNewConnection,
    IN OUT DWORD *pdwServerVersion,
    IN OUT IUnknown **ppUnknown)
{
    HRESULT hr = E_INVALIDARG;
    BOOL fNewConnection;
    DWORD dwAuthnSvc = RPC_C_AUTHN_DEFAULT;
    IUnknown *pUnknown;
    IUnknown *pRealUnknown = NULL;
    IRpcOptions *pRpcOpt = NULL;
    ULONG_PTR dwProperty = 0;

    if (NULL != pfNewConnection)
    {
	*pfNewConnection = FALSE;
    }
    CSASSERT(
	0 == *pdwServerVersion ||
	1 == *pdwServerVersion ||
	2 == *pdwServerVersion);

    hr = _OpenDComConnection(
		    pwszConfig,
		    pclsid,
		    piid,
		    ppwszAuthority,
		    ppwszServerName,
		    &fNewConnection,
		    ppUnknown);
    _JumpIfError(hr, error, "_OpenDComConnection");

    if (fNewConnection)
    {
	if (NULL != pfNewConnection)
	{
	    *pfNewConnection = TRUE;
	}


	// determine if server is on local box, we'll pass in AuthN param based on this

	hr = (*ppUnknown)->QueryInterface (IID_IRpcOptions, (void**)&pRpcOpt);
	if (SUCCEEDED(hr))
	{
	    hr = pRpcOpt->Query((*ppUnknown), COMBND_SERVER_LOCALITY, &dwProperty);
	    if (SUCCEEDED(hr))
	    {
	        // if not local, set snego (locally snego doesn't work)
	        if(SERVER_LOCALITY_MACHINE_LOCAL != dwProperty)
	            dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
	    }
	    pRpcOpt->Release();
	    pRpcOpt = NULL;
	}

	hr = (*ppUnknown)->QueryInterface(IID_IUnknown, (VOID **) &pRealUnknown);
	_JumpIfError(hr, error, "QI IUnknown");

	hr = CoSetProxyBlanket(
		    pRealUnknown,
		    dwAuthnSvc,
		    RPC_C_AUTHZ_DEFAULT,    // use NT default authentication
		    COLE_DEFAULT_PRINCIPAL,
		    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, // call
		    RPC_C_IMP_LEVEL_IMPERSONATE,
		    NULL,
		    EOAC_STATIC_CLOAKING);
	_JumpIfError(hr, error, "CoSetProxyBlanket");

	hr = CoSetProxyBlanket(
		    *ppUnknown,
		    dwAuthnSvc,
		    RPC_C_AUTHZ_DEFAULT,    // use NT default authentication
		    COLE_DEFAULT_PRINCIPAL,
		    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, // call
		    RPC_C_IMP_LEVEL_IMPERSONATE,
		    NULL,
		    EOAC_STATIC_CLOAKING);
	_JumpIfError(hr, error, "CoSetProxyBlanket");

	hr = (*ppUnknown)->QueryInterface(*piid2, (VOID **) &pUnknown);
	if (S_OK != hr)
	{
	    *pdwServerVersion = 1;	// v2 not supported
	}
	else
	{
	    *pdwServerVersion = 2;	// v2 supported
	    (*ppUnknown)->Release();
	    *ppUnknown = pUnknown;

	    hr = CoSetProxyBlanket(
		    *ppUnknown,
		    dwAuthnSvc,
		    RPC_C_AUTHZ_DEFAULT,    // use NT default authentication
		    COLE_DEFAULT_PRINCIPAL,
		    RPC_C_AUTHN_LEVEL_PKT_PRIVACY, // call
		    RPC_C_IMP_LEVEL_IMPERSONATE,
		    NULL,
		    EOAC_STATIC_CLOAKING);
	    _JumpIfError(hr, error, "CoSetProxyBlanket");

	}

    }
    hr = S_OK;

error:
    if(pRealUnknown)
    {
        pRealUnknown->Release();
    }
    return(hr);
}


HRESULT
myOpenAdminDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertAdminD2 **ppICertAdminD)
{
    HRESULT hr;

    hr = _OpenDComConnection2(
			pwszConfig,
			&CLSID_CCertAdminD,
			&IID_ICertAdminD,
			&IID_ICertAdminD2,
			ppwszAuthority,
			ppwszServerName,
			NULL,			// pfNewConnection
			pdwServerVersion,
			(IUnknown **) ppICertAdminD);
    _JumpIfError(hr, error, "_OpenDComConnection2");

error:
    return(hr);
}


HRESULT
myOpenRequestDComConnection(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR const **ppwszAuthority,
    OPTIONAL IN OUT WCHAR **ppwszServerName,
    OPTIONAL OUT BOOL *pfNewConnection,
    IN OUT DWORD *pdwServerVersion,
    IN OUT ICertRequestD2 **ppICertRequestD)
{
    HRESULT hr;

    hr = _OpenDComConnection2(
			pwszConfig,
			&CLSID_CCertRequestD,
			&IID_ICertRequestD,
			&IID_ICertRequestD2,
			ppwszAuthority,
			ppwszServerName,
			pfNewConnection,
			pdwServerVersion,
			(IUnknown **) ppICertRequestD);
    _JumpIfError(hr, error, "_OpenDComConnection2");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// myCloseDComConnection -- release DCOM connection
//
//+--------------------------------------------------------------------------

VOID
myCloseDComConnection(
    OPTIONAL IN OUT IUnknown **ppUnknown,
    OPTIONAL IN OUT WCHAR **ppwszServerName)
{
    if (NULL != ppUnknown && NULL != *ppUnknown)
    {
        (*ppUnknown)->Release();
        *ppUnknown = NULL;
    }
    if (NULL != ppwszServerName && NULL != *ppwszServerName)
    {
	LocalFree(*ppwszServerName);
	*ppwszServerName = NULL;
    }
}


HRESULT
myPingCertSrv(
    IN WCHAR const *pwszConfigOrCAName,
    OPTIONAL IN WCHAR const *pwszMachineName,
    OPTIONAL OUT WCHAR **ppwszzCANames,
    OPTIONAL OUT WCHAR **ppwszSharedFolder,
    OPTIONAL OUT CAINFO **ppCAInfo,
    OPTIONAL OUT DWORD *pdwServerVersion,
    OPTIONAL OUT WCHAR **ppwszCADnsName)
{
    HRESULT hr;
    WCHAR wszConfig[MAX_PATH];
    WCHAR const *pwszConfig;
    ICertRequestD2 *pICertRequestD = NULL;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCANames;
    CERTTRANSBLOB ctbSharedFolder;
    CERTTRANSBLOB ctbCAInfo;
    CERTTRANSBLOB ctbCADnsName;
    CAINFO CAInfo;
    CAINFO const *pCAInfo;
    DWORD dwServerVersion = 0;

    ctbCANames.pb = NULL;
    ctbCANames.cb = 0;
    ctbSharedFolder.pb = NULL;
    ctbSharedFolder.cb = 0;
    ctbCAInfo.pb = NULL;
    ctbCAInfo.cb = 0;
    ctbCADnsName.pb = NULL;
    ctbCADnsName.cb = 0;

    if (NULL != ppwszzCANames)
    {
        *ppwszzCANames = NULL;
    }
    if (NULL != ppwszSharedFolder)
    {
        *ppwszSharedFolder = NULL;
    }
    if (NULL != ppCAInfo)
    {
        *ppCAInfo = NULL;
    }
    if (NULL != ppwszCADnsName)
    {
        *ppwszCADnsName = NULL;
    }

    if (NULL == pwszConfigOrCAName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Invalid parameters");
    }
    pwszConfig = pwszConfigOrCAName;
    if (NULL != pwszMachineName)
    {
        wcscpy(wszConfig, pwszMachineName);
        wcscat(wszConfig, L"\\");
        wcscat(wszConfig, pwszConfigOrCAName);
        pwszConfig = wszConfig;
    }

    hr = myOpenRequestDComConnection(
                        pwszConfig,
                        &pwszAuthority,
                        NULL,
                        NULL,
                        &dwServerVersion,
                        &pICertRequestD);
    _JumpIfError(hr, error, "myOpenRequestDComConnection");

    CSASSERT(0 != dwServerVersion);

    if (2 <= dwServerVersion)
    {
        __try
        {
            hr = pICertRequestD->Ping2(pwszAuthority);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "Ping2");
    }
    else
    {
        __try
        {
            hr = pICertRequestD->Ping(pwszAuthority);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "Ping");
    }

    if (NULL != ppwszzCANames)
    {
        __try
        {
            hr = pICertRequestD->GetCACert(
                                        GETCERT_CANAME,
                                        pwszAuthority,
                                        &ctbCANames);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "GetCACert(CANames)");

        // must register this memory
        myRegisterMemAlloc(ctbCANames.pb, ctbCANames.cb, CSM_COTASKALLOC);

        // Only one CA Name expected for now...

        CSASSERT(
            (wcslen((WCHAR *) ctbCANames.pb) + 1) * sizeof(WCHAR) ==
            ctbCANames.cb);

        *ppwszzCANames = (WCHAR *) LocalAlloc(
                                        LMEM_FIXED,
                                        ctbCANames.cb + sizeof(WCHAR));
        if (NULL == *ppwszzCANames)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppwszzCANames, ctbCANames.pb, ctbCANames.cb);
        (*ppwszzCANames)[ctbCANames.cb/sizeof(WCHAR)] = L'\0';
    }

    if (NULL != ppwszSharedFolder)
    {
        __try
        {
            hr = pICertRequestD->GetCACert(
                GETCERT_SHAREDFOLDER,
                pwszAuthority,
                &ctbSharedFolder);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "GetCACert(SharedFolder)");
        
        // must register this memory
        myRegisterMemAlloc(ctbSharedFolder.pb, ctbSharedFolder.cb, CSM_COTASKALLOC);
        
        *ppwszSharedFolder = (WCHAR *)LocalAlloc(LMEM_FIXED,
            ctbSharedFolder.cb + sizeof(WCHAR));
        if (NULL == *ppwszSharedFolder)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppwszSharedFolder, ctbSharedFolder.pb, ctbSharedFolder.cb);
        (*ppwszSharedFolder)[ctbSharedFolder.cb/sizeof(WCHAR)] = L'\0';
        
        CSASSERT(wcslen(*ppwszSharedFolder)*sizeof(WCHAR) == ctbSharedFolder.cb);
    }

    if (NULL != ppCAInfo)
    {
        __try
        {
            hr = pICertRequestD->GetCACert(
                                    GETCERT_CAINFO,
                                    pwszAuthority,
                                    &ctbCAInfo);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        if (E_INVALIDARG == hr)         // if old server
        {
            __try
            {
                hr = pICertRequestD->GetCACert(
                                        GETCERT_CATYPE,
                                        pwszAuthority,
                                        &ctbCAInfo);
            }
            __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
            {
            }
            _JumpIfError(hr, error, "GetCACert(CAType)");

            myRegisterMemAlloc(ctbCAInfo.pb, ctbCAInfo.cb, CSM_COTASKALLOC);

            ZeroMemory(&CAInfo, sizeof(CAInfo));
            CAInfo.cbSize = CCSIZEOF_STRUCT(CAINFO, cCASignatureCerts);
            CAInfo.CAType = *(ENUM_CATYPES *) ctbCAInfo.pb;
            CAInfo.cCASignatureCerts = 1;
            pCAInfo = &CAInfo;
        }
        else
        {
            _JumpIfError(hr, error, "GetCACert(CAInfo)");

            // must register this memory

            myRegisterMemAlloc(ctbCAInfo.pb, ctbCAInfo.cb, CSM_COTASKALLOC);

            pCAInfo = (CAINFO *) ctbCAInfo.pb;
        }
        *ppCAInfo = (CAINFO *) LocalAlloc(LMEM_FIXED, pCAInfo->cbSize);
        if (NULL == *ppCAInfo)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppCAInfo, pCAInfo, pCAInfo->cbSize);
    }
    if (NULL != pdwServerVersion)
    {
        *pdwServerVersion = dwServerVersion;
    }
    if (NULL != ppwszCADnsName && 2 <= dwServerVersion)
    {
        __try
        {
            hr = pICertRequestD->GetCAProperty(
                pwszAuthority,
                CR_PROP_DNSNAME,
                0,
                PROPTYPE_STRING,
                &ctbCADnsName);
        }
        __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
        _JumpIfError(hr, error, "GetCACert(SharedFolder)");

        // must register this memory
        myRegisterMemAlloc(ctbCADnsName.pb, ctbCADnsName.cb, CSM_COTASKALLOC);
        
        *ppwszCADnsName = (WCHAR *)LocalAlloc(LMEM_FIXED, ctbCADnsName.cb + sizeof(WCHAR));
        if (NULL == *ppwszCADnsName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        CopyMemory(*ppwszCADnsName, ctbCADnsName.pb, ctbCADnsName.cb);
        (*ppwszCADnsName)[ctbCADnsName.cb/sizeof(WCHAR)] = L'\0';
        
        CSASSERT((wcslen(*ppwszCADnsName)+1)*sizeof(WCHAR) == ctbCADnsName.cb);
    }

    hr = S_OK;

error:
    myCloseDComConnection((IUnknown **) &pICertRequestD, NULL);
    if (NULL != ctbCANames.pb)
    {
        CoTaskMemFree(ctbCANames.pb);
    }
    if (NULL != ctbSharedFolder.pb)
    {
        CoTaskMemFree(ctbSharedFolder.pb);
    }
    if (NULL != ctbCAInfo.pb)
    {
        CoTaskMemFree(ctbCAInfo.pb);
    }
    if (NULL != ctbCADnsName.pb)
    {
        CoTaskMemFree(ctbCADnsName.pb);
    }

    return(hr);
}


HRESULT
myEnablePrivilege(
    IN LPCTSTR szPrivilege,
    IN BOOL fEnable)
{

    HRESULT hr = S_OK;
    TOKEN_PRIVILEGES NewState;
    CAutoHANDLE hThread;
    CAutoHANDLE hToken;

    NewState.PrivilegeCount = 1;


    hThread = GetCurrentThread();
    if (!hThread)
    {
        hr = myHLastError();
	    _JumpIfError(hr, error, "GetCurrentThread");
    }

    // Get the access token for current thread
    if (!OpenThreadToken(
            hThread, 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, 
            FALSE,
            &hToken))
    {
        hr = myHLastError();

        if(hr==HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            HANDLE hProcess = GetCurrentProcess();
            if (!hProcess)
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetCurrentProcess");
            }

            if (!OpenProcessToken(hProcess,
                    TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                    &hToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "OpenProcessToken");
            }

            hr = S_OK;
        }
        else
        {
            _JumpError(hr, error, "OpenThreadToken");
        }
    }

    if (!LookupPrivilegeValue(NULL, szPrivilege, &NewState.Privileges[0].Luid))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "LookupPrivelageValue");
    }

    NewState.Privileges[0].Attributes = (fEnable?SE_PRIVILEGE_ENABLED:0);

    if(!AdjustTokenPrivileges(hToken,
                              FALSE,
                              &NewState,
                              sizeof(NewState),
                              NULL,
                              NULL))
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "AdjustTokenPrivileges");
    }
    else
    {
        hr = myHLastError();
        if(HRESULT_FROM_WIN32(ERROR_NOT_ALL_ASSIGNED)==hr)
        {
            // privilege not held, return a generic access denied error
            hr = E_ACCESSDENIED;
        }
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\dispatch.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       csdisp.cpp
//
//  Contents:   IDispatch helper functions
//
//  History:    09-Dec-96   vich    created
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_DISPATCH_CPP__


#ifndef DBG_DISPATCH
#  define DBG_DISPATCH	0
#endif

TCHAR szRegKeyClsidValue[] = TEXT("");


HRESULT
DispatchGetReturnValue(
    VARIANT *pvar,
    IN LONG Type,
    OUT VOID *pretval)
{
    HRESULT hr = S_OK;

    if (VT_EMPTY == pvar->vt)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "VT_EMPTY", hr);
    }
    if (Type != pvar->vt)
    {
	DBGPRINT((
	    DBG_SS_CERTLIB,
	    "pvar->vt=%x, expected %x\n",
	    pvar->vt,
	    Type));
	hr = TYPE_E_WRONGTYPEKIND;
	_JumpError(hr, error, "pvar->vt != Type");
    }
    switch (Type)
    {
	case VT_I4:
	    *(LONG *) pretval = pvar->lVal;
	    break;

	case VT_DATE:
	    *(DATE *) pretval = pvar->date;
	    break;

	case VT_BSTR:
	    *(BSTR *) pretval = pvar->bstrVal;
            
	    pvar->vt = VT_EMPTY;
	    break;

	case VT_DISPATCH:
	    *(IDispatch **) pretval = pvar->pdispVal;
	    pvar->vt = VT_EMPTY;
	    break;

	default:
	    hr = E_INVALIDARG;
	    goto error;
    }

error:
    return(hr);
}


HRESULT
DispatchSetErrorInfoSub(
    IN HRESULT hrError,
    OPTIONAL IN WCHAR const *pwszIDispatchMethod,
    OPTIONAL IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszSource,
    OPTIONAL IN IID const *piid,
    OPTIONAL IN WCHAR const *pwszHelpFile,
    IN DWORD dwHelpFileContext)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    ICreateErrorInfo *pCreateErrorInfo = NULL;
    IErrorInfo *pErrorInfo = NULL;

#ifdef DBG_CERTSRV_DEBUG_PRINT
    if (NULL != pwszIDispatchMethod || DbgIsSSActive(DBG_SS_CERTLIBI))
#else
    if (NULL != pwszIDispatchMethod)
#endif
    {
	pwszError = myGetErrorMessageText(hrError, TRUE);
		
	if (NULL != pwszIDispatchMethod)
	{
	    CONSOLEPRINT1((
		    MAXDWORD,
		    "IDispatch->Invoke(%ws) Exception:\n",
		    pwszIDispatchMethod));
	}
	else
	{
	    CONSOLEPRINT0((MAXDWORD, "COM Error:\n"));
	}

	CONSOLEPRINT5((
		MAXDWORD,
		"    Source=%ws\n    Description=%ws\n    HelpFile=%ws[%x]\n    %ws\n",
		pwszSource,
		pwszDescription,
		pwszHelpFile,
		dwHelpFileContext,
		pwszError));
    }

    hr = CreateErrorInfo(&pCreateErrorInfo);
    _JumpIfError(hr, error, "CreateErrorInfo");

    if (NULL != piid)
    {
	hr = pCreateErrorInfo->SetGUID(*piid);
	_PrintIfError(hr, "SetGUID");
    }
    if (NULL != pwszSource)
    {
	hr = pCreateErrorInfo->SetSource(const_cast<WCHAR *>(pwszSource));
	_PrintIfError(hr, "SetSource");
    }
    if (NULL != pwszDescription)
    {
	hr = pCreateErrorInfo->SetDescription(
					const_cast<WCHAR *>(pwszDescription));
	_PrintIfError(hr, "SetDescription");
    }
    if (NULL != pwszHelpFile)
    {
	hr = pCreateErrorInfo->SetHelpFile(const_cast<WCHAR *>(pwszHelpFile));
	_PrintIfError(hr, "SetHelpFile");

	hr = pCreateErrorInfo->SetHelpContext(dwHelpFileContext);
	_PrintIfError(hr, "SetHelpContext");
    }

    hr = pCreateErrorInfo->QueryInterface(
				    IID_IErrorInfo,
				    (VOID **) &pErrorInfo);
    _JumpIfError(hr, error, "QueryInterface");

    SetErrorInfo(0, pErrorInfo);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    if (NULL != pErrorInfo)
    {
	pErrorInfo->Release();
    }
    if (NULL != pCreateErrorInfo)
    {
	pCreateErrorInfo->Release();
    }
    return(hr);
}


HRESULT
DispatchInvoke(
    IN DISPATCHINTERFACE *pDispatchInterface,
    IN LONG MethodIndex,
    IN DWORD cvar,
    IN VARIANT avar[],
    IN LONG Type,
    OUT VOID *pretval)
{
    HRESULT hr;
    DISPATCHTABLE const *pdt;
    EXCEPINFO excepinfo;
    VARIANT varResult;
    DISPPARAMS parms;
    unsigned iArgErr;
    DISPID *adispid;

    VariantInit(&varResult);
    CSASSERT(NULL != pDispatchInterface->pDispatchTable);
    CSASSERT((DWORD) MethodIndex < pDispatchInterface->m_cDispatchTable);
    pdt = &pDispatchInterface->pDispatchTable[MethodIndex];

    adispid = &pDispatchInterface->m_adispid[pdt->idispid];
    CSASSERT(NULL != pDispatchInterface->m_adispid);
    CSASSERT(pdt->idispid + pdt->cdispid <= pDispatchInterface->m_cdispid);

    parms.rgvarg = avar;
    parms.rgdispidNamedArgs = &adispid[1];
    parms.cArgs = pdt->cdispid - 1;
    parms.cNamedArgs = parms.cArgs;

    if (parms.cArgs != cvar)
    {
	CSASSERT(parms.cArgs == cvar);
	hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	_JumpError(hr, error, "cvar");
    }

    CSASSERT(NULL != pDispatchInterface->pDispatch);

    hr = pDispatchInterface->pDispatch->Invoke(
		    adispid[0],
		    IID_NULL,
		    LOCALE_SYSTEM_DEFAULT,
		    DISPATCH_METHOD,
		    &parms,
		    &varResult,
		    &excepinfo,
		    &iArgErr);

    if (S_OK != hr)
    {
	_PrintErrorStr(hr, "Invoke", pdt->apszNames[0]);

	if (DISP_E_EXCEPTION == hr)
	{
	    HRESULT hr2;

	    if (FAILED(excepinfo.scode))
	    {
		hr = excepinfo.scode;
	    }
	    hr2 = DispatchSetErrorInfoSub(
				hr,
				pdt->apszNames[0],
				excepinfo.bstrDescription,
				excepinfo.bstrSource,
				pDispatchInterface->GetIID(),
				excepinfo.bstrHelpFile,
				excepinfo.dwHelpContext);
	    _PrintIfError(hr2, "DispatchSetErrorInfoSub");
	}
	goto error;
    }

    if (CLSCTX_INPROC_SERVER != pDispatchInterface->m_ClassContext)
    {
	myRegisterMemAlloc(&varResult, 0, CSM_VARIANT);
    }
    if (NULL != pretval)
    {
	hr = DispatchGetReturnValue(&varResult, Type, pretval);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "DispatchGetReturnValue",
		    pdt->apszNames[0],
		    CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    VariantClear(&varResult);
    return(hr);
}


HRESULT
DispatchGetIds(
    IN IDispatch *pDispatch,
    IN DWORD cDispatchTable,
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr = S_OK;
    DISPATCHTABLE *pdt;
    DISPATCHTABLE *pdtEnd;
    DISPID *adispid = NULL;
    DWORD idispid;

    pdtEnd = &pDispatchTable[cDispatchTable];
    pDispatchInterface->m_cdispid = 0;
    for (pdt = pDispatchTable; pdt < pdtEnd; pdt++)
    {
	if (0 == pdt->idispid)
	{
	    pdt->idispid = pDispatchInterface->m_cdispid;
	}
	CSASSERT(pdt->idispid == pDispatchInterface->m_cdispid);
	pDispatchInterface->m_cdispid += pdt->cdispid;
    }

    adispid = (DISPID *) LocalAlloc(
			LMEM_FIXED,
			pDispatchInterface->m_cdispid * sizeof(adispid[0]));
    if (NULL == adispid)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    idispid = 0;
    for (pdt = pDispatchTable; pdt < pdtEnd; pdt++)
    {
	CSASSERT(idispid + pdt->cdispid <= pDispatchInterface->m_cdispid);
	hr = pDispatch->GetIDsOfNames(
				IID_NULL,
				pdt->apszNames,
				pdt->cdispid,
				LOCALE_SYSTEM_DEFAULT,
				&adispid[idispid]);
#if DBG_CERTSRV
	if (S_OK != hr || CSExpr(DBG_DISPATCH))
	{
	    DWORD i;

	    DBGPRINT((
		MAXDWORD,
		"GetIDsOfNames(%ws) --> %x, dispid=%x" szLPAREN,
		pdt->apszNames[0],
		hr,
		adispid[idispid]));
	    for (i = 1; i < pdt->cdispid; i++)
	    {
		DBGPRINT((
		    MAXDWORD,
		    "%ws%x",
		    i == 1? L"" : L", ",
		    adispid[idispid + i]));
	    }
	    DBGPRINT((MAXDWORD, szRPAREN "\n"));
	}
#endif
	_JumpIfError(hr, error, "GetIDsOfNames");

	idispid += pdt->cdispid;
    }
    pDispatchInterface->m_cDispatchTable = cDispatchTable;
    pDispatchInterface->pDispatchTable = pDispatchTable;
    pDispatchInterface->m_adispid = adispid;
    adispid = NULL;

error:
    if (NULL != adispid)
    {
	LocalFree(adispid);
    }
    return(hr);
}




HRESULT
DispatchSetup(
    IN DWORD Flags,
    IN DWORD ClassContext,
    OPTIONAL IN TCHAR const *pszProgID,	        // for IDispatch
    OPTIONAL IN CLSID const *pclsid,		// for COM
    OPTIONAL IN IID const *piid,		// for COM
    IN DWORD cDispatchTable,			// for IDispatch
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr;
    CLSID clsid;
    
    pDispatchInterface->SetIID(piid);
    for (;;)
    {
	pDispatchInterface->pDispatch = NULL;
	pDispatchInterface->pUnknown = NULL;
	pDispatchInterface->m_adispid = NULL;

	CSASSERT(NULL != pszProgID || DISPSETUP_COM == Flags);
	CSASSERT(NULL != pclsid || DISPSETUP_IDISPATCH == Flags);
	CSASSERT(NULL != piid || DISPSETUP_IDISPATCH == Flags);

	if (DISPSETUP_IDISPATCH == Flags)
	{
            // use win32 version, not our own hack
            hr = CLSIDFromProgID(pszProgID, &clsid);

	    _JumpIfError2(
			hr,
			error,
			"ClassNameToCLSID",
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	    pclsid = &clsid;
	    piid = &IID_IDispatch;
	}

	hr = CoCreateInstance(
			*pclsid,
			NULL,		// pUnkOuter
			ClassContext,
			*piid,
			DISPSETUP_IDISPATCH == Flags? 
			    (VOID **) &pDispatchInterface->pDispatch :
			    (VOID **) &pDispatchInterface->pUnknown);
#if DBG_DISPATCH
	printf("CoCreateInstance(%x) --> %x\n", Flags, hr);
#endif
	if (S_OK != hr)
	{
	    _PrintError2(hr, "CoCreateInstance", E_NOINTERFACE);
	    if (DISPSETUP_COMFIRST != Flags)
	    {
		_JumpError2(hr, error, "CoCreateInstance", E_NOINTERFACE);
	    }
	    Flags = DISPSETUP_IDISPATCH;
	    continue;
	}
	pDispatchInterface->m_ClassContext = ClassContext;
	break;
    }
    if (DISPSETUP_IDISPATCH == Flags)
    {
	hr = DispatchGetIds(
			pDispatchInterface->pDispatch,
			cDispatchTable,
			pDispatchTable,
			pDispatchInterface);
	if (S_OK != hr)
	{
	    DispatchRelease(pDispatchInterface);
	    _JumpError(hr, error, "DispatchGetIds");
	}
    }

error:
    return(hr);
}



HRESULT
DispatchSetup2(
    IN DWORD Flags,
    IN DWORD ClassContext,
    IN WCHAR const *pwszClass,		// wszRegKeyAdminClsid
    IN CLSID const *pclsid,
    IN DWORD cver,
    IN IID const * const *ppiid,	// cver elements
    IN DWORD const *pcDispatch,		// cver elements
    IN OUT DISPATCHTABLE *pDispatchTable,
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    HRESULT hr = E_INVALIDARG;

    CSASSERT(0 < cver);
    for ( ; 0 < cver; cver--, ppiid++, pcDispatch++)
    {
	hr = DispatchSetup(
		    Flags,
		    ClassContext,
		    pwszClass,
		    pclsid,
		    *ppiid,
		    *pcDispatch,
		    pDispatchTable,
		    pDispatchInterface);
	if (S_OK == hr)
	{
	    pDispatchInterface->m_dwVersion = cver;
	    pDispatchInterface->pDispatchTable = pDispatchTable;
	    break;
	}
	if (1 == cver)
	{
	    _JumpErrorStr(hr, error, "DispatchSetup", pwszClass);
	}
	_PrintErrorStr2(hr, "DispatchSetup", pwszClass, hr);
    }

error:
    return(hr);
}


VOID
DispatchRelease(
    IN OUT DISPATCHINTERFACE *pDispatchInterface)
{
    if (NULL != pDispatchInterface->pDispatch)
    {
	pDispatchInterface->pDispatch->Release();
	pDispatchInterface->pDispatch = NULL;
    }
    if (NULL != pDispatchInterface->pUnknown)
    {
	pDispatchInterface->pUnknown->Release();
	pDispatchInterface->pUnknown = NULL;
    }
    if (NULL != pDispatchInterface->m_adispid)
    {
	LocalFree(pDispatchInterface->m_adispid);
	pDispatchInterface->m_adispid = NULL;
    }
}


BOOL
myConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb)
{
    HRESULT hr;
    BSTR bstr;

    bstr = NULL;
    if (NULL != pwc)
    {
	if (-1 == cb)
	{
	    cb = wcslen(pwc) * sizeof(WCHAR);
	}
	bstr = SysAllocStringByteLen((char const *) pwc, cb);
	if (NULL == bstr)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocStringByteLen");
	}
    }
    if (NULL != *pbstr)
    {
	SysFreeString(*pbstr);
    }
    *pbstr = bstr;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


BOOL
myConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch)
{
    HRESULT hr;
    BSTR bstr = NULL;
    LONG cwc = 0;

    if (-1 == cch)
    {
	cch = strlen(pch);
    }
    CSASSERT(0 != cch);
    for (;;)
    {
	cwc = MultiByteToWideChar(GetACP(), 0, pch, cch, bstr, cwc);
	if (0 >= cwc)
	{
	    hr = myHLastError();
	    _PrintError(hr, "MultiByteToWideChar");
	    if (NULL != bstr)
	    {
		SysFreeString(bstr);
	    }
	    break;
	}
	if (NULL != bstr)
	{
	    bstr[cwc] = L'\0';
	    if (NULL != *pbstr)
	    {
		SysFreeString(*pbstr);
	    }
	    *pbstr = bstr;
	    hr = S_OK;
	    break;
	}
	bstr = SysAllocStringLen(NULL, cwc);
	if (NULL == bstr)
	{
	    hr = E_OUTOFMEMORY;
	    break;
	}
    }
    if (S_OK != hr)
    {
	SetLastError(hr);
    }
    return(S_OK == hr);
}


HRESULT
DecodeCertString(
    IN BSTR const bstrIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    DWORD dwSize;

    *ppbOut = NULL;

    CSASSERT(CSExpr(CR_IN_BASE64HEADER == CRYPT_STRING_BASE64HEADER));
    CSASSERT(CSExpr(CR_IN_BASE64 == CRYPT_STRING_BASE64));
    CSASSERT(CSExpr(CR_IN_BINARY == CRYPT_STRING_BINARY));

    switch (Flags)
    {
	case CRYPT_STRING_BASE64HEADER:
	case CRYPT_STRING_BASE64:
	case CRYPT_STRING_BASE64REQUESTHEADER:
	case CRYPT_STRING_HEX:
	case CRYPT_STRING_HEXASCII:
	case CRYPT_STRING_BASE64_ANY:
	case CRYPT_STRING_HEX_ANY:
	case CRYPT_STRING_BASE64X509CRLHEADER:
	case CRYPT_STRING_HEXADDR:
	case CRYPT_STRING_HEXASCIIADDR:
	    CSASSERT(sizeof(WCHAR) * wcslen(bstrIn) == SysStringByteLen(bstrIn));
	    // FALLTHROUGH

	case CRYPT_STRING_ANY:
            dwSize = (SysStringByteLen(bstrIn) + sizeof(WCHAR) - 1) / sizeof(WCHAR);
            break;

	case CRYPT_STRING_BINARY:
            dwSize = SysStringByteLen(bstrIn);
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Flags");
    }
    hr = myCryptStringToBinary(
			bstrIn,
			dwSize,
			Flags,
			ppbOut,
			pcbOut,
			NULL,
			NULL);
    _JumpIfError(hr, error, "myCryptStringToBinary");

    if (CRYPT_STRING_ANY == Flags &&
	(SysStringByteLen(bstrIn) & (sizeof(WCHAR) - 1)))
    {
	(*pcbOut)--;
	CSASSERT(SysStringByteLen(bstrIn) == *pcbOut);
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
EncodeCertString(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT BSTR *pbstrOut)
{
    HRESULT hr = E_INVALIDARG;
    WCHAR *pwcCert = NULL;
    DWORD cbCert;

    CSASSERT(CSExpr(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER));
    CSASSERT(CSExpr(CR_OUT_BASE64 == CRYPT_STRING_BASE64));
    CSASSERT(CSExpr(CR_OUT_BINARY == CRYPT_STRING_BINARY));
    //CSASSERT(CSExpr(CR_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER));
    //CSASSERT(CSExpr(CR_OUT_HEX == CRYPT_STRING_HEX));

    CSASSERT(CSExpr(CV_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER));
    CSASSERT(CSExpr(CV_OUT_BASE64 == CRYPT_STRING_BASE64));
    CSASSERT(CSExpr(CV_OUT_BINARY == CRYPT_STRING_BINARY));
    CSASSERT(CSExpr(CV_OUT_BASE64REQUESTHEADER == CRYPT_STRING_BASE64REQUESTHEADER));
    CSASSERT(CSExpr(CV_OUT_HEX == CRYPT_STRING_HEX));
    CSASSERT(CSExpr(CV_OUT_HEXASCII == CRYPT_STRING_HEXASCII));
    CSASSERT(CSExpr(CV_OUT_BASE64X509CRLHEADER == CRYPT_STRING_BASE64X509CRLHEADER));
    CSASSERT(CSExpr(CV_OUT_HEXADDR == CRYPT_STRING_HEXADDR));
    CSASSERT(CSExpr(CV_OUT_HEXASCIIADDR == CRYPT_STRING_HEXASCIIADDR));

    if (NULL == pbIn || (~CR_OUT_ENCODEMASK & Flags))
    {
	goto error;
    }

    switch (CR_OUT_ENCODEMASK & Flags)
    {
	case CRYPT_STRING_BASE64HEADER:
	case CRYPT_STRING_BASE64:
	case CRYPT_STRING_BASE64REQUESTHEADER:
	case CRYPT_STRING_HEX:
	case CRYPT_STRING_HEXASCII:
	case CRYPT_STRING_BASE64X509CRLHEADER:
	case CRYPT_STRING_HEXADDR:
	case CRYPT_STRING_HEXASCIIADDR:
	    hr = myCryptBinaryToString(
                        pbIn,
                        cbIn,
                        CR_OUT_ENCODEMASK & Flags,
                        &pwcCert);
	    _JumpIfError(hr, error, "myCryptBinaryToString");

	    cbCert = sizeof(WCHAR) * wcslen(pwcCert);
	    break;

	case CRYPT_STRING_BINARY:
	    pwcCert = (WCHAR *) pbIn;
	    cbCert = cbIn;
	    hr = S_OK;
	    break;

	default:
	    goto error;
    }
    if (!ConvertWszToBstr(pbstrOut, pwcCert, cbCert))
    {
	hr = E_OUTOFMEMORY;
    }

    hr = S_OK;
error:
    if (NULL != pwcCert && pwcCert != (WCHAR *) pbIn)
    {
	LocalFree(pwcCert);
    }
    return(hr);
}


HRESULT
DispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    WCHAR *pwszText = NULL;

    if (NULL == pwszDescription)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL pointer");
    }
    CSASSERT(FAILED(hrError));
    pwszError = myGetErrorMessageText(hrError, TRUE);
    if (NULL == pwszError)
    {
	_PrintError(E_OUTOFMEMORY, "myGetErrorMessageText");
    }
    else
    {
	pwszText = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    (wcslen(pwszDescription) + 1 + wcslen(pwszError) + 1) *
	     sizeof(WCHAR));
	if (NULL == pwszText)
	{
	    _PrintError(E_OUTOFMEMORY, "LocalAlloc");
	}
	else
	{
	    wcscpy(pwszText, pwszDescription);
	    wcscat(pwszText, L" ");
	    wcscat(pwszText, pwszError);
	}
    }
    hr = DispatchSetErrorInfoSub(
			hrError,
			NULL,		// pwszIDispatchMethod
			NULL != pwszText?
			    pwszText : const_cast<WCHAR *>(pwszDescription),
			pwszProgId,
			piid,
			NULL,		// pwszHelpFile
			0);		// dwHelpFileContext
    _PrintIfError(hr, "DispatchSetErrorInfoSub");

error:
    if (NULL != pwszText)
    {
	LocalFree(pwszText);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hrError);	// return input error!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\csw97sht.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       csw97sht.cpp
//
//--------------------------------------------------------------------------

// csw97sht.cpp: implementation of the CWizard97PropertySheet class.
//
//////////////////////////////////////////////////////////////////////

#include <pch.cpp>

#pragma hdrstop

#include "prsht.h"
#include "csw97sht.h"
#include "csw97ppg.h"
//#include "resource.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWizard97PropertySheet::CWizard97PropertySheet(
    HINSTANCE hInstance,
    UINT nIDCaption,
    UINT nIDWaterMark,
    UINT nIDBanner,
    BOOL fWizard)
{
    ZeroMemory(&m_pPagePtr, sizeof(CWizard97PropertyPage*) * NUM_PAGES);
    ZeroMemory(&m_pPageArr, sizeof(HPROPSHEETPAGE) * NUM_PAGES);

    // NOTICE: do this because of header mismatch
    ZeroMemory(&m_psh, sizeof(PROPSHEETHEADER));
    m_psh.dwFlags = fWizard ? (PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER) : PSH_DEFAULT;
    m_psh.pszbmWatermark = MAKEINTRESOURCE(nIDWaterMark);
    m_psh.pszbmHeader = MAKEINTRESOURCE(nIDBanner);
    m_psh.hplWatermark = NULL;         
	

    m_psh.dwSize              = sizeof(m_psh);
    m_psh.hInstance           = hInstance; //AfxGetApp()->m_hInstance;
    m_psh.hwndParent          = NULL;

    VERIFY(m_title.LoadString(nIDCaption));
    m_psh.pszCaption          = (LPCTSTR) m_title;
    m_psh.phpage              = NULL;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = 0;

    m_nPageCount = 0;
}

CWizard97PropertySheet::~CWizard97PropertySheet()
{
}


BOOL
CWizard97PropertySheet::DoWizard(
    HWND hParent)
{
    m_psh.hwndParent = hParent;
//   if (m_nPageCount > 0 && m_pPagePtr[m_nPageCount - 1])
//		m_pPagePtr[m_nPageCount - 1]->m_bLast = TRUE;

    m_psh.phpage              = m_pPageArr;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = m_nPageCount;

    return (BOOL)PropertySheet(&m_psh);
}

void
CWizard97PropertySheet::AddPage(
    CWizard97PropertyPage *pPage)
{
    ASSERT(pPage);
    if (pPage)
    {
	ASSERT(m_nPageCount < NUM_PAGES);
	m_pPagePtr[m_nPageCount] = pPage;
	m_pPageArr[m_nPageCount] = ::CreatePropertySheetPage(&(pPage->m_psp97));
	ASSERT(m_pPageArr[m_nPageCount]);
	m_nPageCount++;
	pPage->m_pWiz = this;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\keygen.c ===
/***************************************************/
/* Copyright (C) Microsoft Corporation, 1996 - 1999*/
/***************************************************/
/* Abstract syntax: keygen */
/* Created: Mon Jan 27 13:51:10 1997 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -listingfile keygen.lst -noshortennames -1990 -noconstraints
 */

#include   <stddef.h>
#include   "etype.h"
#include   "keygen.h"

static char copyright[] = 
   "Copyright (C) Microsoft Corporation, 1996 - 1999";


void DLL_ENTRY_FDEF _ossinit_keygen(struct ossGlobal *world) {
    ossLinkBer(world);
}

static unsigned short _pduarray[] = {
    7, 8, 10, 13
};

static struct etype _etypearray[] = {
    {16, 0, 0, NULL, 4, 4, 4, 4, 56, 0, 26, 0},
    {-1, 2, 0, NULL, 8, 0, 4, 4, 8, 0, 62, 0},
    {-1, 4, 0, NULL, 8, 0, 4, 4, 8, 0, 3, 0},
    {-1, 6, 22, NULL, 8, 0, 4, 4, 8, 0, 25, 0},
    {-1, 8, 0, NULL, 16, 0, 0, 0, 8, 0, 51, 0},
    {-1, 9, 11, NULL, 88, 2, 1, 0, 8, 0, 12, 0},
    {-1, 17, 0, NULL, 4, 0, 4, 0, 8, 0, 0, 0},
    {-1, 19, 21, NULL, 12, 2, 0, 0, 8, 2, 12, 0},
    {-1, 29, 31, NULL, 96, 2, 0, 0, 8, 4, 12, 0},
    {-1, 39, 0, NULL, 16, 0, 0, 0, 8, 0, 51, 0},
    {-1, 40, 42, NULL, 112, 3, 0, 0, 8, 6, 12, 0},
    {-1, 52, 54, NULL, 104, 2, 0, 0, 8, 9, 12, 0},
    {-1, 62, 0, NULL, 8, 0, 4, 4, 40, 0, 3, 0},
    {-1, 64, 66, NULL, 200, 3, 0, 0, 8, 11, 12, 0}
};

static struct efield _efieldarray[] = {
    {4, 0, -1, 0, 0},
    {72, 4, 0, 0, 1},
    {0, 1, -1, 0, 0},
    {8, 6, -1, 0, 0},
    {0, 5, -1, 0, 0},
    {88, 2, -1, 0, 0},
    {0, 9, -1, 0, 0},
    {16, 5, -1, 0, 0},
    {104, 2, -1, 0, 0},
    {0, 8, -1, 0, 0},
    {96, 3, -1, 0, 0},
    {0, 11, -1, 0, 0},
    {104, 5, -1, 0, 0},
    {192, 12, -1, 0, 0}
};

static Etag _tagarray[] = {
    1, 0x0006, 1, 0x0002, 1, 0x0003, 1, 0x0016, 0, 1,
    0x0010, 13, 16, 1, 0x0006, 1, 0, 1, 0x0002, 1,
    0x0010, 23, 26, 1, 0x0002, 1, 1, 0x0002, 2, 1,
    0x0010, 33, 36, 1, 0x0010, 1, 1, 0x0003, 2, 0,
    1, 0x0010, 45, 46, 49, 0, 1, 0x0010, 2, 1,
    0x0003, 3, 1, 0x0010, 56, 59, 1, 0x0010, 1, 1,
    0x0016, 2, 1, 0x0003, 1, 0x0010, 69, 72, 75, 1,
    0x0010, 1, 1, 0x0010, 2, 1, 0x0003, 3
};

static struct eheader _head = {_ossinit_keygen, -1, 15, 772, 4, 14,
    _pduarray, _etypearray, _efieldarray, NULL, _tagarray,
    NULL, NULL, NULL, 0};

#ifdef _OSSGETHEADER
void *DLL_ENTRY_FDEF ossGetHeader()
{
    return &_head;
}
#endif /* _OSSGETHEADER */

void *keygen = &_head;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\inf.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        inf.cpp
//
// Contents:    Cert Server INF file processing routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certca.h>

#include "csdisp.h"
#include "initcert.h"
#include "clibres.h"
#include "csber.h"

#define __dwFILE__	__dwFILE_CERTLIB_INF_CPP__

#define wszBSCAPOLICYFILE	L"\\" wszCAPOLICYFILE
#define wszINFKEY_CONTINUE	L"_continue_"
#define wszINFKEY_VERSION	L"Version"
#define wszINFSECTION_EXTENSIONS	L"Extensions"
#define cwcINFLINEMAX		1024

#define wcBOM		(WCHAR) 0xfffe
#define wcBOMBIGENDIAN	(WCHAR) 0xfeff

static WCHAR *s_pwszSection = NULL;
static WCHAR *s_pwszKey = NULL;
static WCHAR *s_pwszValue = NULL;
static HRESULT s_hr = S_OK;

static WCHAR g_wcBOM = L'\0';
static BOOL g_fIgnoreReferencedSections = FALSE;

VOID
infClearString(
    IN OUT WCHAR **ppwsz)
{
    if (NULL != ppwsz && NULL != *ppwsz)
    {
	LocalFree(*ppwsz);
	*ppwsz = NULL;
    }
}


BOOL
infCopyString(
    OPTIONAL IN WCHAR const *pwszIn,
    OPTIONAL OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    
    if (NULL != pwszIn && NULL == *ppwszOut)
    {
	hr = myDupString(pwszIn, ppwszOut);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = S_OK;

error:
    return(S_OK == hr);
}


#define INFSTRINGSELECT(pwsz)	(NULL != (pwsz)? (pwsz) : L"")

#if DBG_CERTSRV
# define INFSETERROR(hr, pwszSection, pwszKey, pwszValue) \
    { \
	_PrintError3(hr, "infSetError", ERROR_LINE_NOT_FOUND, S_FALSE); \
	infSetError(hr, pwszSection, pwszKey, pwszValue, __LINE__); \
    }
#else
# define INFSETERROR infSetError
#endif


VOID
infSetError(
    IN HRESULT hr,
    OPTIONAL IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszKey,
    OPTIONAL IN WCHAR const *pwszValue
    DBGPARM(IN DWORD dwLine))
{
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"inf.cpp(%u): infSetError Begin: [%ws] %ws = %ws\n",
	dwLine,
	INFSTRINGSELECT(pwszSection),
	INFSTRINGSELECT(pwszKey),
	INFSTRINGSELECT(pwszValue)));
    s_hr = hr;
    infCopyString(pwszSection, &s_pwszSection);
    infCopyString(pwszKey, &s_pwszKey);
    infCopyString(pwszValue, &s_pwszValue);
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"inf.cpp(%u): infSetError End:   [%ws] %ws = %ws\n",
	dwLine,
	INFSTRINGSELECT(s_pwszSection),
	INFSTRINGSELECT(s_pwszKey),
	INFSTRINGSELECT(s_pwszValue)));
}


WCHAR *
myInfGetError()
{
    DWORD cwc = 1;
    WCHAR *pwsz = NULL;
    
    if (NULL != s_pwszSection)
    {
	cwc += wcslen(s_pwszSection) + 2;
    }
    if (NULL != s_pwszKey)
    {
	cwc += wcslen(s_pwszKey) + 1 + 2;
    }
    if (NULL != s_pwszValue)
    {
	cwc += wcslen(s_pwszValue) + 1;
    }
    if (1 == cwc)
    {
	goto error;
    }
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	goto error;
    }
    *pwsz = L'\0';
    if (NULL != s_pwszSection)
    {
	wcscat(pwsz, wszLBRACKET);
	wcscat(pwsz, s_pwszSection);
	wcscat(pwsz, wszRBRACKET);
    }
    if (NULL != s_pwszKey && L'\0' != s_pwszKey[0])
    {
	wcscat(pwsz, L" ");
	wcscat(pwsz, s_pwszKey);
	wcscat(pwsz, L" =");
    }
    if (NULL != s_pwszValue && L'\0' != s_pwszValue[0])
    {
	wcscat(pwsz, L" ");
	wcscat(pwsz, s_pwszValue);
    }
error:
    return(pwsz);
}


VOID
myInfClearError()
{
    s_hr = S_OK;
    infClearString(&s_pwszSection);
    infClearString(&s_pwszKey);
    infClearString(&s_pwszValue);
}


typedef struct _SECTIONINFO {
    DWORD  dwRefCount;
    WCHAR *pwszSection;
    struct _SECTIONINFO *pNext;
} SECTIONINFO;

SECTIONINFO *g_pSectionInfo = NULL;


HRESULT
infSaveSectionName(
    IN WCHAR const *pwszSection)
{
    HRESULT hr;
    SECTIONINFO *psi = NULL;
    
    if (0 != LSTRCMPIS(pwszSection, wszINFKEY_VERSION))
    {
	psi = (SECTIONINFO *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    sizeof(*psi));
	if (NULL == psi)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	hr = myDupString(pwszSection, &psi->pwszSection);
	_JumpIfError(hr, error, "myDupString");

	psi->pNext = g_pSectionInfo;
	g_pSectionInfo = psi;
	psi = NULL;
    }
    hr = S_OK;

error:
    if (NULL != psi)
    {
	LocalFree(psi);
    }
    return(hr);
}


VOID
infFreeSectionNames()
{
    SECTIONINFO *psi;

    psi = g_pSectionInfo;
    g_pSectionInfo = NULL;
    while (NULL != psi)
    {
	SECTIONINFO *psiNext;

	if (NULL != psi->pwszSection)
	{
	    LocalFree(psi->pwszSection);
	}
	psiNext = psi->pNext;
	LocalFree(psi);
	psi = psiNext;
    }
}


HRESULT
myInfGetUnreferencedSectionNames(
    OUT WCHAR **ppwszzSectionNames)
{
    HRESULT hr;
    DWORD cwc;
    SECTIONINFO *psi;

    *ppwszzSectionNames = NULL;

    cwc = 0;
    for (psi = g_pSectionInfo; NULL != psi; psi = psi->pNext)
    {
	if (0 == psi->dwRefCount)
	{
	    cwc += wcslen(psi->pwszSection) + 3;
	}
    }
    if (0 != cwc)
    {
	WCHAR *pwszz;
	WCHAR *pwsz;
	
	pwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pwsz = pwszz;
	for (psi = g_pSectionInfo; NULL != psi; psi = psi->pNext)
	{
	    if (0 == psi->dwRefCount)
	    {
		*pwsz++ = wcLBRACKET;
		wcscpy(pwsz, psi->pwszSection);
		pwsz += wcslen(pwsz);
		*pwsz++ = wcRBRACKET;
		*pwsz++ = L'\0';
	    }
	}
	*pwsz = L'\0';
	CSASSERT(cwc == SAFE_SUBTRACT_POINTERS(pwsz, pwszz));
	*ppwszzSectionNames = pwszz;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
infReferenceSectionName(
    IN WCHAR const *pwszSection)
{
    HRESULT hr;
    SECTIONINFO *psi;

    if (!g_fIgnoreReferencedSections)
    {
	for (psi = g_pSectionInfo; NULL != psi; psi = psi->pNext)
	{
	    if (0 == mylstrcmpiL(pwszSection, psi->pwszSection))
	    {
		psi->dwRefCount++;
		break;
	    }
	}
	if (NULL == psi)
	{
	    hr = SPAPI_E_LINE_NOT_FOUND;	// don't ignore this error
	    _JumpError(hr, error, "unexpected section");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
inffopen(
    IN WCHAR const *pwszfn,
    OUT FILE **ppf)
{
    HRESULT hr;
    FILE *pf = NULL;
    
    *ppf = NULL;
    g_fIgnoreReferencedSections = FALSE;
    g_wcBOM = L'\0';

    pf = _wfopen(pwszfn, L"r");	// Assume Ansi INF file
    if (NULL == pf)
    {
	hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "_wfopen");
    }
    g_wcBOM = (WCHAR) fgetc(pf) << 8;
    g_wcBOM |= fgetc(pf);
    if (!feof(pf))
    {
	if (wcBOM == g_wcBOM)		// Oops, Unicode INF file
	{
	    fclose(pf);
	    pf = _wfopen(pwszfn, L"rb");
	    if (NULL == pf)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "fopen");
	    }
	}
	else if (wcBOMBIGENDIAN == g_wcBOM)
	{
	    g_fIgnoreReferencedSections = TRUE;
	    fclose(pf);
	    pf = NULL;
	}
	else
	{
	    if (fseek(pf, 0L, SEEK_SET))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
		_JumpError(hr, error, "fseek");
	    }
	}
    }
    *ppf = pf;
    hr = S_OK;

error:
    return(hr);
}


WCHAR *
inffgetws(
    OUT WCHAR *pwcLine,
    IN DWORD cwcLine,
    IN FILE *pfInf)
{
    HRESULT hr;
    WCHAR *pwc = NULL;
    WCHAR *pwsz = NULL;
    char achLine[cwcINFLINEMAX];
    char *pch;

    if (wcBOM == g_wcBOM)
    {
	pwc = fgetws(pwcLine, cwcLine, pfInf);
    }
    else
    {
	pch = fgets(achLine, ARRAYSIZE(achLine), pfInf);
	if (NULL == pch)
	{
	    goto error;
	}
	if (!myConvertSzToWsz(&pwsz, achLine, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "myConvertSzToWsz");
	}
	wcsncpy(pwcLine, pwsz, cwcLine);
	pwcLine[cwcLine - 1] = L'\0';
	pwc = pwcLine;
    }

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    return(pwc);
}


#define ISBLANK(ch)	(L' ' == (ch) || L'\t' == (ch))

HRESULT
infCollectSectionNames(
    IN WCHAR const *pwszfnInf)
{
    HRESULT hr;
    FILE *pfInf = NULL;
    WCHAR awcLine[cwcINFLINEMAX];
    WCHAR *pwszEnd;

    hr = inffopen(pwszfnInf, &pfInf);
    _JumpIfError(hr, error, "inffopen");

    if (!g_fIgnoreReferencedSections)
    {
	while (NULL != inffgetws(awcLine, ARRAYSIZE(awcLine), pfInf))
	{
	    WCHAR *pwsz;

	    awcLine[wcscspn(awcLine, L";=\r\n")] = L'\0';
	    pwsz = wcschr(awcLine, wcLBRACKET);
	    if (NULL == pwsz)
	    {
		continue;
	    }
	    pwsz++;
	    pwszEnd = wcschr(awcLine, wcRBRACKET);
	    if (NULL == pwszEnd)
	    {
		continue;
	    }
	    *pwszEnd = L'\0';
	    while (ISBLANK(*pwsz))
	    {
		pwsz++;
	    }
	    while (--pwszEnd >= pwsz && ISBLANK(*pwszEnd))
	    {
		*pwszEnd = L'\0';
	    }
	    hr = infSaveSectionName(pwsz);
	    _JumpIfError(hr, error, "infSaveSectionName");
	}
    }
    hr = S_OK;

error:
    if (NULL != pfInf)
    {
	fclose(pfInf);
    }
    return(hr);
}


HRESULT
infGetCurrentKeyValueAndAlloc(
    IN OUT INFCONTEXT *pInfContext,
    IN DWORD Index,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    DWORD cwc;

    if (!SetupGetStringField(pInfContext, Index, NULL, 0, &cwc))
    {
	hr = myHLastError();
	_JumpError2(hr, error, "SetupGetStringField", E_INVALIDARG);
    }
    pwszValue = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszValue)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!SetupGetStringField(pInfContext, Index, pwszValue, cwc, NULL))
    {
	hr = myHLastError();
	_JumpError(hr, error, "SetupGetStringField");
    }
    *ppwszValue = pwszValue;
    pwszValue = NULL;
    hr = S_OK;

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
infGetCurrentKeyValue(
    IN OUT INFCONTEXT *pInfContext,
    OPTIONAL IN WCHAR const *pwszSection,	// for error logging only
    OPTIONAL IN WCHAR const *pwszKey,		// for error logging only
    IN DWORD Index,
    IN BOOL fLastValue,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszValueExtra = NULL;
    WCHAR *pwszValueError = NULL;
    DWORD cwc;
    WCHAR *pwszT = NULL;
    INFCONTEXT InfContext;

    *ppwszValue = NULL;

    hr = infGetCurrentKeyValueAndAlloc(pInfContext, Index, &pwszValue);
    _JumpIfError2(hr, error, "infGetCurrentKeyValueAndAlloc", E_INVALIDARG);

    if (1 == Index)
    {
	InfContext = *pInfContext;
	for (;;)
	{
	    WCHAR *pwsz;
	    
	    if (!SetupFindNextLine(&InfContext, &InfContext))
	    {
		break;
	    }

	    hr = infGetCurrentKeyValueAndAlloc(&InfContext, 0, &pwszT);
	    _JumpIfError2(hr, error, "infGetCurrentKeyValueAndAlloc", E_INVALIDARG);

	    if (0 != LSTRCMPIS(pwszT, wszINFKEY_CONTINUE))
	    {
		break;
	    }
	    LocalFree(pwszT);
	    pwszT = NULL;

	    hr = infGetCurrentKeyValueAndAlloc(&InfContext, 1, &pwszT);
	    _JumpIfError2(hr, error, "infGetCurrentKeyValueAndAlloc", E_INVALIDARG);

	    cwc = wcslen(pwszValue) + wcslen(pwszT);
	    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	    if (NULL == pwsz)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    wcscpy(pwsz, pwszValue);
	    wcscat(pwsz, pwszT);

	    LocalFree(pwszValue);
	    pwszValue = pwsz;

	    LocalFree(pwszT);
	    pwszT = NULL;
	}
    }

    if (fLastValue)
    {
	DWORD cValue;
	
	cValue = SetupGetFieldCount(pInfContext);
	if (Index != cValue)
	{
	    DWORD i;

	    for (i = Index + 5; i > Index; i--)
	    {
		hr = infGetCurrentKeyValue(
				    pInfContext,
				    pwszSection,
				    pwszKey,
				    i,
				    FALSE,	// fLastValue
				    &pwszValueExtra);
		if (S_OK == hr)
		{
		    DWORD j;

		    cwc = wcslen(pwszValue) + i - 1 + wcslen(pwszValueExtra);
		    pwszValueError = (WCHAR *) LocalAlloc(
						    LMEM_FIXED,
						    (cwc + 1) * sizeof(WCHAR));
		    if (NULL == pwszValueError)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }

		    pwszValueError[0] = L'\0';
		    for (j = 1; j < Index; j++)
		    {
			wcscat(pwszValueError, L",");
		    }
		    wcscat(pwszValueError, pwszValue);
		    for (j = Index; j < i; j++)
		    {
			wcscat(pwszValueError, L",");
		    }
		    wcscat(pwszValueError, pwszValueExtra);
		    CSASSERT(wcslen(pwszValueError) == cwc);

		    hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
		    INFSETERROR(hr, pwszSection, pwszKey, pwszValueError);
		    _PrintErrorStr(hr, "extra values", pwszKey);
		    _JumpErrorStr(hr, error, "extra values", pwszValueError);
		}
	    }
	}
    }
    *ppwszValue = pwszValue;
    pwszValue = NULL;
    hr = S_OK;

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pwszValueExtra)
    {
	LocalFree(pwszValueExtra);
    }
    if (NULL != pwszValueError)
    {
	LocalFree(pwszValueError);
    }
    return(hr);
}


HRESULT
infFindNextKey(
    IN WCHAR const *pwszKey,
    IN OUT INFCONTEXT *pInfContext)
{
    HRESULT hr;
    WCHAR *pwszKeyT = NULL;

    for (;;)
    {
	if (!SetupFindNextLine(pInfContext, pInfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszKey, hr);
	    if ((HRESULT) ERROR_LINE_NOT_FOUND == hr)
	    {
		hr = S_FALSE;
	    }
	    _JumpError2(hr, error, "SetupFindNextLine", hr);
	}
	if (NULL != pwszKeyT)
	{
	    LocalFree(pwszKeyT);
	    pwszKeyT = NULL;
	}
	hr = infGetCurrentKeyValue(
			    pInfContext,
			    NULL,	// pwszSection
			    NULL,	// pwszKey
			    0,
			    FALSE,	// fLastValue
			    &pwszKeyT);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	if (0 == mylstrcmpiL(pwszKey, pwszKeyT))
	{
	    break;
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszKeyT)
    {
	LocalFree(pwszKeyT);
    }
    return(hr);
}


HRESULT
infSetupFindFirstLine(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszKey,
    IN BOOL fUniqueKey,
    IN DWORD cValueMax,
    OPTIONAL WCHAR const * const *ppwszValidKeys,
    IN BOOL fUniqueValidKeys,
    OUT INFCONTEXT *pInfContext)
{
    HRESULT hr;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszKeyT = NULL;
    WCHAR *pwszValueT = NULL;
    
    if (!SetupFindFirstLine(hInf, pwszSection, pwszKey, pInfContext))
    {
        // if the [Section] or Key = does not exist, see if the section is
	// completely empty.  It exists and is empty if SetupGetLineCount
	// returns 0, or if the Empty key is found in the section.

	hr = myHLastError();
	if ((HRESULT) ERROR_LINE_NOT_FOUND == hr &&
	    (0 == SetupGetLineCount(hInf, pwszSection) ||
	     SetupFindFirstLine(
			hInf,
			pwszSection,
			wszINFKEY_EMPTY,
			pInfContext)))
	{
	    hr = infReferenceSectionName(pwszSection);
	    _JumpIfErrorStr(hr, error, "infReferenceSectionName", pwszKey);

	    hr = S_FALSE;	// Section exists, but is empty
	}
        _JumpErrorStr3(
		hr,
		error,
		"SetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);
    }
    hr = infReferenceSectionName(pwszSection);
    _JumpIfErrorStr(hr, error, "infReferenceSectionName", pwszKey);

    if (NULL != pwszKey)
    {
	if (fUniqueKey)
	{
	    INFCONTEXT InfContext = *pInfContext;

	    hr = infFindNextKey(pwszKey, &InfContext);
	    if (S_OK == hr)
	    {
		hr = infGetCurrentKeyValue(
				    &InfContext,
				    pwszSection,
				    pwszKey,
				    1,
				    FALSE,	// fLastValue
				    &pwszValue);
		_PrintIfError(hr, "infGetCurrentKeyValue");

		hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
		INFSETERROR(hr, pwszSection, pwszKey, pwszValue);
		_JumpErrorStr(hr, error, "duplicate key", pwszKey);
	    }
	}
	if (0 != cValueMax)
	{
	    hr = infGetCurrentKeyValue(
				pInfContext,
				pwszSection,
				pwszKey,
				cValueMax,
				TRUE,		// fLastValue
				&pwszValue);
	    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", pwszKey);
	}
    }
    if (NULL != ppwszValidKeys)
    {
	INFCONTEXT InfContext;
	WCHAR const * const *ppwszKey;

	if (!SetupFindFirstLine(hInf, pwszSection, NULL, &InfContext))
	{
	    hr = myHLastError();
	    _JumpErrorStr(hr, error, "SetupFindFirstLine", pwszSection)
	}
	for (;;)
	{
	    hr = infGetCurrentKeyValue(
				&InfContext,
				pwszSection,
				NULL,	// pwszKey
				0,
				FALSE,	// fLastValue
				&pwszKeyT);
	    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", pwszSection);

	    for (ppwszKey = ppwszValidKeys; NULL != *ppwszKey; ppwszKey++)
	    {
		if (0 == mylstrcmpiL(*ppwszKey, pwszKeyT))
		{
		    break;
		}
	    }
	    if (NULL == *ppwszKey)
	    {
		hr = infGetCurrentKeyValue(
				    &InfContext,
				    pwszSection,
				    pwszKeyT,
				    1,
				    FALSE,	// fLastValue
				    &pwszValueT);
		_PrintIfError(hr, "infGetCurrentKeyValue");
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		INFSETERROR(hr, pwszSection, pwszKeyT, pwszValueT);
		_JumpErrorStr(hr, error, "invalid key", pwszKeyT);
	    }
	    if (fUniqueValidKeys)
	    {
		INFCONTEXT InfContextT = InfContext;

		hr = infFindNextKey(pwszKeyT, &InfContextT);
		if (S_OK == hr)
		{
		    hr = infGetCurrentKeyValue(
					&InfContextT,
					pwszSection,
					pwszKeyT,
					1,
					FALSE,	// fLastValue
					&pwszValueT);
		    _PrintIfError(hr, "infGetCurrentKeyValue");

		    hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
		    INFSETERROR(hr, pwszSection, pwszKeyT, pwszValueT);
		    _JumpErrorStr(hr, error, "duplicate key", pwszKeyT);
		}
	    }
	    LocalFree(pwszKeyT);
	    pwszKeyT = NULL;

	    if (!SetupFindNextLine(&InfContext, &InfContext))
	    {
		hr = myHLastError();
		_PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
		break;
	    }
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszKeyT)
    {
	LocalFree(pwszKeyT);
    }
    if (NULL != pwszValueT)
    {
	LocalFree(pwszValueT);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
infBuildPolicyElement(
    IN OUT INFCONTEXT *pInfContext,
    OPTIONAL OUT CERT_POLICY_QUALIFIER_INFO *pcpqi)
{
    HRESULT hr;
    WCHAR *pwszKey = NULL;
    BOOL fURL = FALSE;
    BOOL fNotice = FALSE;
    WCHAR *pwszValue = NULL;
    WCHAR *pwszURL = NULL;
    BYTE *pbData = NULL;
    DWORD cbData;

    hr = infGetCurrentKeyValue(
			pInfContext,
			NULL,	// pwszSection
			NULL,	// pwszKey
			0,
			FALSE,	// fLastValue
			&pwszKey);
    _JumpIfError(hr, error, "infGetCurrentKeyValue");

    DBGPRINT((DBG_SS_CERTLIBI, "Element = %ws\n", pwszKey));

    if (0 == LSTRCMPIS(pwszKey, wszINFKEY_URL))
    {
	fURL = TRUE;
    }
    else
    if (0 == LSTRCMPIS(pwszKey, wszINFKEY_NOTICE))
    {
	fNotice = TRUE;
    }
    else
    {
	if (0 != LSTRCMPIS(pwszKey, wszINFKEY_OID) &&
	    0 != LSTRCMPIS(pwszKey, wszINFKEY_CONTINUE))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "unknown key", pwszKey);
	}
	hr = S_FALSE;		// Skip this key
	_JumpError2(hr, error, "skip OID key", hr);
    }

    hr = infGetCurrentKeyValue(
			pInfContext,
			NULL,		// pwszSection
			pwszKey,
			1,
			TRUE,		// fLastValue
			&pwszValue);
    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", pwszKey);

    DBGPRINT((DBG_SS_CERTLIBI, "%ws = %ws\n", pwszKey, pwszValue));

    if (fURL)
    {
	CERT_NAME_VALUE NameValue;

	hr = myInternetCanonicalizeUrl(pwszValue, &pwszURL);
	_JumpIfError(hr, error, "myInternetCanonicalizeUrl");

	NameValue.dwValueType = CERT_RDN_IA5_STRING;
	NameValue.Value.pbData = (BYTE *) pwszURL;
	NameValue.Value.cbData = 0;

	if (NULL != pcpqi)
	{
	    CSILOG(S_OK, IDS_ILOG_CAPOLICY_ELEMENT, pwszURL, NULL, NULL);
	}

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_UNICODE_NAME_VALUE,
			&NameValue,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pbData,
			&cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }
    else
    {
	CERT_POLICY_QUALIFIER_USER_NOTICE UserNotice;

	ZeroMemory(&UserNotice, sizeof(UserNotice));
	UserNotice.pszDisplayText = pwszValue;

	if (NULL != pcpqi)
	{
	    CSILOG(S_OK, IDS_ILOG_CAPOLICY_ELEMENT, pwszValue, NULL, NULL);
	}

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			X509_PKIX_POLICY_QUALIFIER_USERNOTICE,
			&UserNotice,
			0,
			CERTLIB_USE_LOCALALLOC,
			&pbData,
			&cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}
    }
    if (NULL != pcpqi)
    {
	pcpqi->pszPolicyQualifierId = fURL?
	    szOID_PKIX_POLICY_QUALIFIER_CPS :
	    szOID_PKIX_POLICY_QUALIFIER_USERNOTICE;
	pcpqi->Qualifier.pbData = pbData;
	pcpqi->Qualifier.cbData = cbData;
	pbData = NULL;
    }
    hr = S_OK;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, NULL, pwszKey, pwszValue);
    }
    if (NULL != pwszKey)
    {
	LocalFree(pwszKey);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pwszURL)
    {
	LocalFree(pwszURL);
    }
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


HRESULT
infBuildPolicy(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN OUT CERT_POLICY_INFO *pcpi)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    DWORD i;
    WCHAR *pwszValue = NULL;
    static WCHAR const * const s_apwszKeys[] =
    {
	wszINFKEY_OID,
	wszINFKEY_URL,
	wszINFKEY_NOTICE,
	wszINFKEY_CONTINUE,
	NULL
    };

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			wszINFKEY_OID,
			TRUE,	// fUniqueKey
			1,	// cValueMax
			s_apwszKeys,
			FALSE,	// fUniqueValidKeys
			&InfContext);
    if (S_OK != hr)
    {
	if ((HRESULT) ERROR_LINE_NOT_FOUND == hr)
	{
	    hr = SPAPI_E_LINE_NOT_FOUND;	// don't ignore this error
	}
	INFSETERROR(hr, NULL, wszINFKEY_OID, NULL);
        _JumpErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);
    }
    hr = infGetCurrentKeyValue(
			&InfContext,
			pwszSection,
			wszINFKEY_OID,
			1,
			TRUE,		// fLastValue
			&pwszValue);
    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", wszINFKEY_OID);

    hr = myVerifyObjId(pwszValue);
    _JumpIfErrorStr(hr, error, "myVerifyObjId", pwszValue);

    if (!ConvertWszToSz(&pcpi->pszPolicyIdentifier, pwszValue, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "ConvertWszToSz");
    }
    DBGPRINT((DBG_SS_CERTLIBI, "OID = %hs\n", pcpi->pszPolicyIdentifier));

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    for (i = 0; ; )
    {
	hr = infBuildPolicyElement(&InfContext, NULL);
	if (S_FALSE != hr)
	{
	    _JumpIfErrorStr(hr, error, "infBuildPolicyElement", pwszSection);

	    i++;
	}

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
	    break;
	}
    }

    pcpi->cPolicyQualifier = i;
    pcpi->rgPolicyQualifier = (CERT_POLICY_QUALIFIER_INFO *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				pcpi->cPolicyQualifier *
				    sizeof(pcpi->rgPolicyQualifier[0]));
    if (NULL == pcpi->rgPolicyQualifier)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    for (i = 0; ; )
    {
	// handle one URL or text message

	hr = infBuildPolicyElement(&InfContext, &pcpi->rgPolicyQualifier[i]);
	if (S_FALSE != hr)
	{
	    _JumpIfErrorStr(hr, error, "infBuildPolicyElement", pwszSection);

	    i++;
	}
	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
	    break;
	}
    }
    CSASSERT(i == pcpi->cPolicyQualifier);
    hr = S_OK;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, NULL, L"");
    }
    CSILOG(hr, IDS_ILOG_CAPOLICY_BUILD, pwszSection, pwszValue, NULL);
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


VOID
infFreePolicy(
    IN OUT CERT_POLICY_INFO *pcpi)
{
    DWORD i;
    CERT_POLICY_QUALIFIER_INFO *pcpqi;

    if (NULL != pcpi->pszPolicyIdentifier)
    {
	LocalFree(pcpi->pszPolicyIdentifier);
    }
    if (NULL != pcpi->rgPolicyQualifier)
    {
	for (i = 0; i < pcpi->cPolicyQualifier; i++)
	{
	    pcpqi = &pcpi->rgPolicyQualifier[i];
	    if (NULL != pcpqi->Qualifier.pbData)
	    {
		LocalFree(pcpqi->Qualifier.pbData);
	    }
	}
	LocalFree(pcpi->rgPolicyQualifier);
    }
}


HRESULT
myInfOpenFile(
    OPTIONAL IN WCHAR const *pwszfnPolicy,
    OUT HINF *phInf,
    OUT DWORD *pErrorLine)
{
    HRESULT hr;
    WCHAR wszPath[MAX_PATH];
    UINT ErrorLine;
    DWORD Flags;

    *phInf = INVALID_HANDLE_VALUE;
    *pErrorLine = 0;
    myInfClearError();

    if (NULL == pwszfnPolicy)
    {
	DWORD cwc;

	cwc = GetEnvironmentVariable(
			L"SystemRoot",
			wszPath,
			ARRAYSIZE(wszPath) - ARRAYSIZE(wszBSCAPOLICYFILE));
	if (0 == cwc ||
	    ARRAYSIZE(wszPath) - ARRAYSIZE(wszBSCAPOLICYFILE) <= cwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "GetEnvironmentVariable");
	}
	wcscat(wszPath, wszBSCAPOLICYFILE);
	pwszfnPolicy = wszPath;
    }
    else
    {
	if (NULL == wcschr(pwszfnPolicy, L'\\'))
	{
	    if (ARRAYSIZE(wszPath) <= 2 + wcslen(pwszfnPolicy))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);
		_JumpErrorStr(hr, error, "filename too long", pwszfnPolicy);
	    }
	    wcscpy(wszPath, L".\\");
	    wcscat(wszPath, pwszfnPolicy);
	    pwszfnPolicy = wszPath;
	}
    }
    hr = infCollectSectionNames(pwszfnPolicy);
    _JumpIfErrorStr(hr, error, "infCollectSectionNames", pwszfnPolicy);

    Flags = INF_STYLE_WIN4;
    for (;;)
    {
	ErrorLine = 0;
	*phInf = SetupOpenInfFile(
			    pwszfnPolicy,
			    NULL,
			    Flags,
			    &ErrorLine);
	*pErrorLine = ErrorLine;
	if (INVALID_HANDLE_VALUE != *phInf)
	{
	    break;
	}
	hr = myHLastError();
	if ((HRESULT) ERROR_WRONG_INF_STYLE == hr && INF_STYLE_WIN4 == Flags)
	{
	    Flags = INF_STYLE_OLDNT;
	    continue;
	}
	CSILOG(
	    hr,
	    IDS_ILOG_CAPOLICY_OPEN_FAILED,
	    pwszfnPolicy,
	    NULL,
	    0 == *pErrorLine? NULL : pErrorLine);
        _JumpErrorStr(hr, error, "SetupOpenInfFile", pwszfnPolicy);
    }
    CSILOG(S_OK, IDS_ILOG_CAPOLICY_OPEN, pwszfnPolicy, NULL, NULL);
    hr = S_OK;

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfOpenFile(%ws) hr=%x --> h=%x\n",
	pwszfnPolicy,
	hr,
	*phInf));
    return(hr);
}


VOID
myInfCloseFile(
    IN HINF hInf)
{
    if (NULL != hInf && INVALID_HANDLE_VALUE != hInf)
    {
	WCHAR *pwszInfError = myInfGetError();

	SetupCloseInfFile(hInf);
	CSILOG(S_OK, IDS_ILOG_CAPOLICY_CLOSE, pwszInfError, NULL, NULL);
	if (NULL != pwszInfError)
	{
	    LocalFree(pwszInfError);
	}
    }
    myInfClearError();
    infFreeSectionNames();
    DBGPRINT((DBG_SS_CERTLIBI, "myInfCloseFile(%x)\n", hInf));
}


HRESULT
myInfParseBooleanValue(
    IN WCHAR const *pwszValue,
    OUT BOOL *pfValue)
{
    HRESULT hr;
    DWORD i;
    static WCHAR const * const s_apwszTrue[] = { L"True", L"Yes", L"On", L"1" };
    static WCHAR const * const s_apwszFalse[] = { L"False", L"No", L"Off", L"0" };

    *pfValue = FALSE;
    for (i = 0; i < ARRAYSIZE(s_apwszTrue); i++)
    {
	if (0 == mylstrcmpiL(pwszValue, s_apwszTrue[i]))
	{
	    *pfValue = TRUE;
	    break;
	}
    }
    if (i == ARRAYSIZE(s_apwszTrue))
    {
	for (i = 0; i < ARRAYSIZE(s_apwszFalse); i++)
	{
	    if (0 == mylstrcmpiL(pwszValue, s_apwszFalse[i]))
	    {
		break;
	    }
	}
	if (i == ARRAYSIZE(s_apwszFalse))
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "bad boolean value string", pwszValue);
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, NULL, pwszValue);
    }
    return(hr);
}


HRESULT
myInfGetBooleanValue(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN BOOL fIgnoreMissingKey,
    OUT BOOL *pfValue)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszValue = NULL;

    *pfValue = FALSE;
    myInfClearError();

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			pwszKey,	// pwszKey
			TRUE,		// fUniqueKey
			1,		// cValueMax
			NULL,		// apwszKeys
			FALSE,		// fUniqueValidKeys
			&InfContext);
    _PrintIfErrorStr3(
		hr,
		"infSetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);
    _JumpIfErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszKey,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);

    hr = infGetCurrentKeyValue(
			&InfContext,
			pwszSection,
			pwszKey,
			1,
			TRUE,		// fLastValue
			&pwszValue);
    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", pwszKey);

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetBooleanValue --> '%ws'\n",
	pwszValue));

    hr = myInfParseBooleanValue(pwszValue, pfValue);
    _JumpIfError(hr, error, "myInfParseBooleanValue");

error:
    if (S_OK != hr &&
	((HRESULT) ERROR_LINE_NOT_FOUND != hr || !fIgnoreMissingKey))
    {
	INFSETERROR(hr, pwszSection, pwszKey, pwszValue);
	CSILOG(hr, IDS_ILOG_BAD_BOOLEAN, pwszSection, pwszKey, NULL);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetBooleanValue(%ws, %ws) hr=%x --> f=%d\n",
	pwszSection,
	pwszKey,
	hr,
	*pfValue));
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


HRESULT
infGetCriticalFlag(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN BOOL fDefault,
    OUT BOOL *pfCritical)
{
    HRESULT hr;

    hr = myInfGetBooleanValue(
			hInf,
			pwszSection,
			wszINFKEY_CRITICAL,
			TRUE,
			pfCritical);
    if (S_OK != hr)
    {
	*pfCritical = fDefault;
	if ((HRESULT) ERROR_LINE_NOT_FOUND != hr && S_FALSE != hr)
	{
	    _JumpErrorStr(hr, error, "myInfGetBooleanValue", pwszSection);
	}
	hr = S_OK;
    }

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infGetCriticalFlag(%ws) hr=%x --> f=%d\n",
	pwszSection,
	hr,
	*pfCritical));
    return(hr);
}


//+------------------------------------------------------------------------
// infGetPolicyStatementExtensionSub -- build policy extension from INF file
//
// [pwszSection]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
//
// [LegalPolicy]
// OID = 1.3.6.1.4.1.311.21.43
// Notice = "Legal policy statement text."
//
// [LimitedUsePolicy]
// OID = 1.3.6.1.4.1.311.21.47
// URL = "http://http.site.com/some where/default.asp"
// URL = "ftp://ftp.site.com/some where else/default.asp"
// Notice = "Limited use policy statement text."
// URL = "ldap://ldap.site.com/some where else again/default.asp"
//
// [ExtraPolicy]
// OID = 1.3.6.1.4.1.311.21.53
// URL = http://extra.site.com/Extra Policy/default.asp
//
// Return S_OK if extension has been constructed from the INF file
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//-------------------------------------------------------------------------

HRESULT
infGetPolicyStatementExtensionSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN char const *pszObjId,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_POLICIES_INFO PoliciesInfo;
    INFCONTEXT InfContext;
    DWORD i;
    WCHAR *pwszValue = NULL;
    static WCHAR const * const s_apwszKeys[] =
	{ wszINFKEY_POLICIES, wszINFKEY_CRITICAL, NULL };

    ZeroMemory(&PoliciesInfo, sizeof(PoliciesInfo));
    ZeroMemory(pext, sizeof(*pext));

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			wszINFKEY_POLICIES,
			TRUE,	// fUniqueKey
			0,	// cValueMax
			s_apwszKeys,
			TRUE,	// fUniqueValidKeys
			&InfContext);
    if (S_OK != hr)
    {
	CSILOG(
	    hr,
	    IDS_ILOG_CAPOLICY_NOKEY,
	    pwszSection,
	    wszINFKEY_POLICIES,
	    NULL);
	_JumpErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);
    }

    // First, count the policies.

    PoliciesInfo.cPolicyInfo = SetupGetFieldCount(&InfContext);
    if (0 == PoliciesInfo.cPolicyInfo)
    {
        hr = S_FALSE;
	_JumpError(hr, error, "SetupGetFieldCount");
    }

    // Next, allocate memory.

    PoliciesInfo.rgPolicyInfo = (CERT_POLICY_INFO *) LocalAlloc(
	    LMEM_FIXED | LMEM_ZEROINIT,
	    PoliciesInfo.cPolicyInfo * sizeof(PoliciesInfo.rgPolicyInfo[0]));
    if (NULL == PoliciesInfo.rgPolicyInfo)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // Finally!  Fill in the policies data.

    for (i = 0; i < PoliciesInfo.cPolicyInfo; i++)
    {
	if (NULL != pwszValue)
	{
	    LocalFree(pwszValue);
	    pwszValue = NULL;
	}
	hr = infGetCurrentKeyValue(
			    &InfContext,
			    pwszSection,
			    wszINFKEY_POLICIES,
			    i + 1,
			    FALSE,		// fLastValue
			    &pwszValue);
	_JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", wszINFKEY_POLICIES);

	DBGPRINT((DBG_SS_CERTLIBI, "%ws[%u] = %ws\n", wszINFKEY_POLICIES, i, pwszValue));

	hr = infBuildPolicy(hInf, pwszValue, &PoliciesInfo.rgPolicyInfo[i]);
	_JumpIfErrorStr(hr, error, "infBuildPolicy", pwszValue);
    }

    hr = infGetCriticalFlag(hInf, pwszSection, FALSE, &pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CERT_POLICIES,
		    &PoliciesInfo,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, wszINFKEY_POLICIES, pwszValue);
    }
    CSILOG(hr, IDS_ILOG_CAPOLICY_EXTENSION, pwszValue, NULL, NULL);
    pext->pszObjId = const_cast<char *>(pszObjId);	// on error, too!

    if (NULL != PoliciesInfo.rgPolicyInfo)
    {
	for (i = 0; i < PoliciesInfo.cPolicyInfo; i++)
	{
	    infFreePolicy(&PoliciesInfo.rgPolicyInfo[i]);
	}
	LocalFree(PoliciesInfo.rgPolicyInfo);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetPolicyStatementExtension -- build policy extension from INF file
//
// [PolicyStatementExtension]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
// ...
//
// OR
//
// [CAPolicy]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
// ...
//
// Return S_OK if extension has been constructed from the INF file
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetPolicyStatementExtension;

HRESULT
myInfGetPolicyStatementExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = infGetPolicyStatementExtensionSub(
				hInf,
				wszINFSECTION_POLICYSTATEMENT,
				szOID_CERT_POLICIES,
				pext);
    if (S_OK != hr)
    {
	HRESULT hr2;
	
	hr2 = infGetPolicyStatementExtensionSub(
				    hInf,
				    wszINFSECTION_CAPOLICY,
				    szOID_CERT_POLICIES,
				    pext);
	if (S_OK == hr2 || 
	    (S_FALSE == hr2 && (HRESULT) ERROR_LINE_NOT_FOUND == hr))
	{
	    hr = hr2;
	}
    }
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyStatementExtensionSub",
		wszINFSECTION_POLICYSTATEMENT,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetPolicyStatementExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetApplicationPolicyStatementExtension -- build application policy
// extension from INF file
//
// [ApplicationPolicyStatementExtension]
// Policies = LegalPolicy, LimitedUsePolicy, ExtraPolicy
// ...
//
// Return S_OK if extension has been constructed from the INF file
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetApplicationPolicyStatementExtension;

HRESULT
myInfGetApplicationPolicyStatementExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = infGetPolicyStatementExtensionSub(
				hInf,
				wszINFSECTION_APPLICATIONPOLICYSTATEMENT,
				szOID_APPLICATION_CERT_POLICIES,
				pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyStatementExtensionSub",
		wszINFSECTION_APPLICATIONPOLICYSTATEMENT,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetApplicationPolicyStatementExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


HRESULT
myInfGetCRLPublicationParams(
   IN HINF hInf,
   IN WCHAR const *pwszKeyCRLPeriodString,
   IN WCHAR const *pwszKeyCRLPeriodCount,
   OUT WCHAR **ppwszCRLPeriodString, 
   OUT DWORD *pdwCRLPeriodCount)
{
   HRESULT hr;
   WCHAR const *pwszKey;

   // Retrieve units count and string.  If either fails, both are discarded.

   *ppwszCRLPeriodString = NULL;
   pwszKey = pwszKeyCRLPeriodCount;
   hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,	// fLog
			wszINFSECTION_CERTSERVER,
			pwszKey,
			1,
			TRUE,	// fLastValue
			pdwCRLPeriodCount);
   _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetNumericKeyValue",
		pwszKeyCRLPeriodCount,
		ERROR_LINE_NOT_FOUND);

   pwszKey = pwszKeyCRLPeriodString;
   hr = myInfGetKeyValue(
		    hInf,
		    TRUE,	// fLog
		    wszINFSECTION_CERTSERVER,
		    pwszKey,
		    1,
		    TRUE,	// fLastValue
		    ppwszCRLPeriodString);
   _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetKeyValue",
		pwszKeyCRLPeriodString,
		ERROR_LINE_NOT_FOUND);

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, wszINFSECTION_CERTSERVER, pwszKey, NULL);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetKeyValue -- fetch a string value from INF file
//
// [pwszSection]
// pwszKey = string
//
// Returns: allocated string key value
//-------------------------------------------------------------------------

HRESULT
myInfGetKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    OUT WCHAR **ppwszValue)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszValue = NULL;

    *ppwszValue = NULL;
    myInfClearError();

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			pwszKey,
			TRUE,			// fUniqueKey
			fLastValue? Index : 0,	// cValueMax
			NULL,			// apwszKeys
			FALSE,			// fUniqueValidKeys
			&InfContext);
    if (S_OK != hr)
    {
	if (fLog)
	{
	    CSILOG(hr, IDS_ILOG_CAPOLICY_NOKEY, pwszSection, pwszKey, NULL);
	}
	_JumpErrorStr2(
		    hr,
		    error,
		    "infSetupFindFirstLine",
		    pwszKey,
		    ERROR_LINE_NOT_FOUND);
    }

    hr = infGetCurrentKeyValue(
			&InfContext,
			pwszSection,
			pwszKey,
			Index,
			fLastValue,
			&pwszValue);
    _JumpIfError(hr, error, "infGetCurrentKeyValue");

    *ppwszValue = pwszValue;
    pwszValue = NULL;
    hr = S_OK;

    //wprintf(L"%ws = %ws\n", pwszKey, *ppwszValue);

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (S_OK != hr && fLog)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetNumericKeyValue -- fetch a numeric value from INF file
//
// [pwszSection]
// pwszKey = 2048
//
// Returns: DWORD key value
//-------------------------------------------------------------------------

HRESULT
myInfGetNumericKeyValue(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,
    IN DWORD Index,
    IN BOOL fLastValue,
    OUT DWORD *pdwValue)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszValue = NULL;
    INT Value;

    myInfClearError();
    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			pwszKey,
			TRUE,			// fUniqueKey
			fLastValue? Index : 0,	// cValueMax
			NULL,			// apwszKeys
			FALSE,			// fUniqueValidKeys
			&InfContext);
    if (S_OK != hr)
    {
	if (fLog)
	{
	    CSILOG(hr, IDS_ILOG_CAPOLICY_NOKEY, pwszSection, pwszKey, NULL);
	}
	_PrintErrorStr2(
		hr,
		"infSetupFindFirstLine",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
	_JumpErrorStr2(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND);
    }
    if (fLastValue)
    {
	hr = infGetCurrentKeyValue(
			    &InfContext,
			    pwszSection,
			    pwszKey,
			    Index,
			    fLastValue,
			    &pwszValue);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");
    }

    if (!SetupGetIntField(&InfContext, Index, &Value))
    {
	hr = myHLastError();
	if (fLog)
	{
	    CSILOG(hr, IDS_ILOG_BAD_NUMERICFIELD, pwszSection, pwszKey, NULL);
	}
	_JumpErrorStr(hr, error, "SetupGetIntField", pwszKey);
    }
    *pdwValue = Value;
    DBGPRINT((DBG_SS_CERTLIBI, "%ws = %u\n", pwszKey, *pdwValue));
    hr = S_OK;

error:
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (S_OK != hr && fLog)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetKeyLength -- fetch the renewal key length from CAPolicy.inf
//
// [certsrv_server]
// RenewalKeyLength = 2048
//
// Returns: DWORD key kength
//-------------------------------------------------------------------------

HRESULT
myInfGetKeyLength(
    IN HINF hInf,
    OUT DWORD *pdwKeyLength)
{
    HRESULT hr;

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			wszINFSECTION_CERTSERVER,
			wszINFKEY_RENEWALKEYLENGTH,
			1,
			TRUE,	// fLastValue
			pdwKeyLength);
    _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetNumericKeyValue",
		wszINFKEY_RENEWALKEYLENGTH,
		ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetKeyLength hr=%x --> len=%x\n",
	hr,
	*pdwKeyLength));
    return(hr);
}


//+------------------------------------------------------------------------
// infGetValidityPeriodSub -- fetch validity period & units from CAPolicy.inf
//
// [certsrv_server]
// xxxxValidityPeriod = Years	(string)
// xxxxValidityPeriodUnits = 8	(count)
//
// Returns: validity period count and enum
//-------------------------------------------------------------------------

HRESULT
infGetValidityPeriodSub(
    IN HINF hInf,
    IN BOOL fLog,
    IN WCHAR const *pwszInfKeyNameCount,
    IN WCHAR const *pwszInfKeyNameString,
    OPTIONAL IN WCHAR const *pwszValidityPeriodCount,
    OPTIONAL IN WCHAR const *pwszValidityPeriodString,
    OUT DWORD *pdwValidityPeriodCount,
    OUT ENUM_PERIOD *penumValidityPeriod)
{
    HRESULT hr;
    WCHAR *pwszStringValue = NULL;
    BOOL fValidCount = TRUE;
    UINT idsLog = IDS_ILOG_BAD_VALIDITY_STRING;

    *pdwValidityPeriodCount = 0;
    *penumValidityPeriod = ENUM_PERIOD_INVALID;

    hr = S_OK;
    if (NULL == pwszValidityPeriodCount && NULL == pwszValidityPeriodString)
    {
        if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
        {
            hr = E_HANDLE;
            _JumpError2(hr, error, "hInf", hr);
        }

	hr = myInfGetNumericKeyValue(
			    hInf,
			    fLog,
			    wszINFSECTION_CERTSERVER,
			    pwszInfKeyNameCount,
			    1,
			    TRUE,	// fLastValue
			    pdwValidityPeriodCount);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "myInfGetNumericKeyValue",
		    pwszInfKeyNameCount,
		    ERROR_LINE_NOT_FOUND);

	hr = myInfGetKeyValue(
			hInf,
			fLog,
			wszINFSECTION_CERTSERVER,
			pwszInfKeyNameString,
			1,
			TRUE,	// fLastValue
			&pwszStringValue);
	if (S_OK != hr && fLog)
	{
	    INFSETERROR(hr, wszINFSECTION_CERTSERVER, pwszInfKeyNameString, NULL);
	}
	_JumpIfErrorStr(hr, error, "myInfGetKeyValue", pwszInfKeyNameString);

	pwszValidityPeriodString = pwszStringValue;
    }
    else
    {
	if (NULL != pwszValidityPeriodCount)
	{
	    *pdwValidityPeriodCount = myWtoI(
					pwszValidityPeriodCount,
					&fValidCount);
	}
	idsLog = IDS_ILOG_BAD_VALIDITY_STRING_UNATTEND;
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%ws = %u -- %ws = %ws\n",
	pwszInfKeyNameCount,
	*pdwValidityPeriodCount,
	pwszInfKeyNameString,
	pwszValidityPeriodString));

    if (NULL != pwszValidityPeriodString)
    {
        if (0 == LSTRCMPIS(pwszValidityPeriodString, wszPERIODYEARS))
        {
	    *penumValidityPeriod = ENUM_PERIOD_YEARS;
        }
        else if (0 == LSTRCMPIS(pwszValidityPeriodString, wszPERIODMONTHS))
        {
	    *penumValidityPeriod = ENUM_PERIOD_MONTHS;
        }
        else if (0 == LSTRCMPIS(pwszValidityPeriodString, wszPERIODWEEKS))
        {
	    *penumValidityPeriod = ENUM_PERIOD_WEEKS;
        }
        else if (0 == LSTRCMPIS(pwszValidityPeriodString, wszPERIODDAYS))
        {
	    *penumValidityPeriod = ENUM_PERIOD_DAYS;
        }
	else if (fLog)
	{
	    INFSETERROR(
		    hr,
		    wszINFSECTION_CERTSERVER,
		    pwszInfKeyNameString,
		    pwszValidityPeriodString);
	}
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%ws = %u (%ws)\n",
	pwszInfKeyNameString,
	*penumValidityPeriod,
	pwszValidityPeriodString));

    if (!fValidCount ||
	(ENUM_PERIOD_YEARS == *penumValidityPeriod &&
	 fValidCount && 9999 < *pdwValidityPeriodCount))
    {
	hr = E_INVALIDARG;
	if (fLog)
	{
	    WCHAR awcCount[cwcDWORDSPRINTF];
	    
	    if (NULL == pwszValidityPeriodCount)
	    {
		wsprintf(awcCount, L"%d", *pdwValidityPeriodCount);
	    }
	    INFSETERROR(
		    hr,
		    wszINFSECTION_CERTSERVER,
		    pwszInfKeyNameCount,
		    NULL != pwszValidityPeriodCount? 
			pwszValidityPeriodCount : awcCount);
	    CSILOG(
		hr,
		idsLog,
		wszINFSECTION_CERTSERVER,
		NULL == pwszValidityPeriodCount? pwszInfKeyNameCount : NULL,
		pdwValidityPeriodCount);
	}
	_JumpIfErrorStr(
		hr,
		error,
		"bad ValidityPeriod count value",
		pwszValidityPeriodCount);
    }
    hr = S_OK;

error:
    if (NULL != pwszStringValue)
    {
	LocalFree(pwszStringValue);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetValidityPeriod -- fetch renewal period & units from CAPolicy.inf
//
// [certsrv_server]
// xxxxValidityPeriod = Years	(string)
// xxxxValidityPeriodUnits = 8	(count)
//
// Returns: validity period count and enum
//-------------------------------------------------------------------------

HRESULT
myInfGetValidityPeriod(
    IN HINF hInf,
    OPTIONAL IN WCHAR const *pwszValidityPeriodCount,
    OPTIONAL IN WCHAR const *pwszValidityPeriodString,
    OUT DWORD *pdwValidityPeriodCount,
    OUT ENUM_PERIOD *penumValidityPeriod,
    OPTIONAL OUT BOOL *pfSwap)
{
    HRESULT hr;

    if ((NULL == hInf || INVALID_HANDLE_VALUE == hInf) &&
        NULL == pwszValidityPeriodCount &&
        NULL == pwszValidityPeriodString)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();

    if (NULL != pfSwap)
    {
        *pfSwap = FALSE;
    }

    // Try correct order:
    // [certsrv_server]
    // xxxxValidityPeriod = Years	(string)
    // xxxxValidityPeriodUnits = 8	(count)
    
    hr = infGetValidityPeriodSub(
		hInf,
		TRUE,
		wszINFKEY_RENEWALVALIDITYPERIODCOUNT,
		wszINFKEY_RENEWALVALIDITYPERIODSTRING,
                pwszValidityPeriodCount,
                pwszValidityPeriodString,
		pdwValidityPeriodCount,
		penumValidityPeriod);
    _PrintIfError2(hr, "infGetValidityPeriodSub", ERROR_LINE_NOT_FOUND);

    if (S_OK != hr)
    {
	// Try backwards:
	// [certsrv_server]
	// xxxxValidityPeriodUnits = Years	(string)
	// xxxxValidityPeriod = 8		(count)
    
	hr = infGetValidityPeriodSub(
		    hInf,
		    FALSE,
		    wszINFKEY_RENEWALVALIDITYPERIODSTRING,
		    wszINFKEY_RENEWALVALIDITYPERIODCOUNT,
		    pwszValidityPeriodString,
		    pwszValidityPeriodCount,
		    pdwValidityPeriodCount,
		    penumValidityPeriod);
	_JumpIfError2(
		hr,
		error,
		"infGetValidityPeriodSub",
		ERROR_LINE_NOT_FOUND);

        if (NULL != pfSwap)
        {
            *pfSwap = TRUE;
        }
    }

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetValidityPeriod hr=%x --> c=%d, enum=%d\n",
	hr,
	*pdwValidityPeriodCount,
	*penumValidityPeriod));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetKeyList -- fetch a list of key values from CAPolicy.inf
//
// [pwszSection]
// pwszKey = Value1
// pwszKey = Value2
//
// Returns: double null terminated list of values
//-------------------------------------------------------------------------

HRESULT
myInfGetKeyList(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszKey,
    OPTIONAL WCHAR const * const *ppwszValidKeys,
    OPTIONAL OUT BOOL *pfCritical,
    OPTIONAL OUT WCHAR **ppwszz)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    DWORD iVal;
    DWORD cwc;
    WCHAR *pwsz;
    WCHAR **apwszVal = NULL;
    DWORD cVal;

    if (NULL != pfCritical)
    {
	*pfCritical = FALSE;
    }
    if (NULL != ppwszz)
    {
	*ppwszz = NULL;
    }
    myInfClearError();
    cVal = 0;
    if (NULL == pwszKey)
    {
	if (NULL == ppwszValidKeys || NULL != pfCritical || NULL != ppwszz)
	{
	    hr = E_INVALIDARG;
	    _JumpErrorStr(hr, error, "NULL/non-NULL parms", pwszSection);
	}
    }
    else if (NULL == ppwszz)
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "ppwszz parms", pwszKey);
    }

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			pwszKey,
			FALSE,			// fUniqueKey
			NULL == pwszKey? 0 : 1,	// cValueMax
			ppwszValidKeys,
			FALSE,	// fUniqueValidKeys
			&InfContext);
    if (S_OK != hr)
    {
	CSILOG(hr, IDS_ILOG_CAPOLICY_NOKEY, pwszSection, pwszKey, NULL);
	_JumpErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);
    }

    if (NULL != pwszKey)
    {
	for (;;)
	{
	    cVal++;
	    hr = infFindNextKey(pwszKey, &InfContext);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfErrorStr(hr, error, "infFindNextKey", pwszKey);
	}

	apwszVal = (WCHAR **) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cVal * sizeof(apwszVal[0]));
	if (NULL == apwszVal)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	hr = infSetupFindFirstLine(
			    hInf,
			    pwszSection,
			    pwszKey,
			    FALSE,	// fUniqueKey
			    1,	// cValueMax
			    NULL,	// apwszKeys
			    FALSE,	// fUniqueValidKeys
			    &InfContext);
	_JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

	cwc = 1;
	iVal = 0;
	for (;;)
	{
	    hr = infGetCurrentKeyValue(
				&InfContext,
				pwszSection,
				pwszKey,
				1,
				TRUE,	// fLastValue
				&apwszVal[iVal]);
	    _JumpIfError(hr, error, "infGetCurrentKeyValue");

	    DBGPRINT((DBG_SS_CERTLIBI, "%ws = %ws\n", pwszKey, apwszVal[iVal]));

	    cwc += wcslen(apwszVal[iVal]) + 1;
	    iVal++;

	    hr = infFindNextKey(pwszKey, &InfContext);
	    if (S_FALSE == hr)
	    {
		break;
	    }
	    _JumpIfErrorStr(hr, error, "infFindNextKey", pwszKey);
	}
	CSASSERT(iVal == cVal);

	*ppwszz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == *ppwszz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	pwsz = *ppwszz;
	for (iVal = 0; iVal < cVal; iVal++)
	{
	    wcscpy(pwsz, apwszVal[iVal]);
	    pwsz += wcslen(pwsz) + 1;
	}
	*pwsz = L'\0';
	CSASSERT(cwc == 1 + SAFE_SUBTRACT_POINTERS(pwsz, *ppwszz));

	if (NULL != pfCritical)
	{
	    hr = infGetCriticalFlag(hInf, pwszSection, FALSE, pfCritical);
	    _JumpIfError(hr, error, "infGetCriticalFlag");
	}
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    if (NULL != apwszVal)
    {
	for (iVal = 0; iVal < cVal; iVal++)
	{
	    if (NULL != apwszVal[iVal])
	    {
		LocalFree(apwszVal[iVal]);
	    }
	}
	LocalFree(apwszVal);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetCRLDistributionPoints -- fetch CDP URLs from CAPolicy.inf
//
// [CRLDistributionPoint]
// URL = http://CRLhttp.site.com/Public/MyCA.crl
// URL = ftp://CRLftp.site.com/Public/MyCA.crl
//
// Returns: double null terminated list of CDP URLs
//-------------------------------------------------------------------------

HRESULT
myInfGetCRLDistributionPoints(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    static WCHAR const * const s_apwszKeys[] =
	{ wszINFKEY_URL, wszINFKEY_CRITICAL, NULL };

    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_CDP,
		wszINFKEY_URL,
		s_apwszKeys,
		pfCritical,
		ppwszz);
    _JumpIfErrorStr4(
		hr,
		error,
		"myInfGetKeyList",
		wszINFSECTION_CDP,
		ERROR_LINE_NOT_FOUND,
		S_FALSE,
		E_HANDLE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetCRLDistributionPoints hr=%x --> f=%d\n",
	hr,
	*pfCritical));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetAuthorityInformationAccess -- fetch AIA URLs from CAPolicy.inf
//
// [AuthorityInformationAccess]
// URL = http://CRThttp.site.com/Public/MyCA.crt
// URL = ftp://CRTftp.site.com/Public/MyCA.crt
//
// Returns: double null terminated list of AIA URLs
//-------------------------------------------------------------------------

HRESULT
myInfGetAuthorityInformationAccess(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    static WCHAR const * const s_apwszKeys[] =
	{ wszINFKEY_URL, wszINFKEY_CRITICAL, NULL };

    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_AIA,
		wszINFKEY_URL,
		s_apwszKeys,
		pfCritical,
		ppwszz);
    _JumpIfErrorStr4(
		hr,
		error,
		"myInfGetKeyList",
		wszINFSECTION_AIA,
		ERROR_LINE_NOT_FOUND,
		S_FALSE,
		E_HANDLE);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetAuthorityInformationAccess hr=%x --> f=%d\n",
	hr,
	*pfCritical));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetEnhancedKeyUsage -- fetch EKU OIDS from CAPolicy.inf
//
// [EnhancedKeyUsage]
// OID = 1.2.3.4.5
// OID = 1.2.3.4.6
//
// Returns: double null terminated list of EKU OIDs
//-------------------------------------------------------------------------

HRESULT
myInfGetEnhancedKeyUsage(
    IN HINF hInf,
    OUT BOOL *pfCritical,
    OUT WCHAR **ppwszz)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    WCHAR const *pwsz;
    static WCHAR const * const s_apwszKeys[] =
	{ wszINFKEY_OID, wszINFKEY_CRITICAL, NULL };

    *ppwszz = NULL;

    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_EKU,
		wszINFKEY_OID,
		s_apwszKeys,
		pfCritical,
		&pwszz);
    _JumpIfErrorStr4(
		hr,
		error,
		"myInfGetKeyList",
		wszINFSECTION_EKU,
		ERROR_LINE_NOT_FOUND,
		S_FALSE,
		E_HANDLE);

    for (pwsz = pwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
    {
	hr = myVerifyObjId(pwsz);
	if (S_OK != hr)
	{
	    INFSETERROR(hr, wszINFSECTION_EKU, wszINFKEY_OID, pwsz);
	    _JumpErrorStr(hr, error, "myVerifyObjId", pwsz);
	}
    }
    *ppwszz = pwszz;
    pwszz = NULL;

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetEnhancedKeyUsage hr=%x --> f=%d\n",
	hr,
	*pfCritical));
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// infGetBasicConstraints2CAExtension -- fetch basic constraints extension
// from INF file, setting the SubjectType flag to CA
//
// If the INF handle is bad, or if the INF section does not exist, construct
// a default extension only if fDefault is set, otherwise fail.
//
// [BasicConstraintsExtension]
// ; Subject Type is not supported -- always set to CA
// ; maximum subordinate CA path length
// PathLength = 3
//
// Return S_OK if extension has been constructed from INF file.
//
// Returns: encoded basic constraints extension
//+--------------------------------------------------------------------------

HRESULT
infGetBasicConstraints2CAExtension(
    IN BOOL fDefault,
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_BASIC_CONSTRAINTS2_INFO bc2i;
    INFCONTEXT InfContext;
    static WCHAR const * const s_apwszKeys[] =
	{ wszINFKEY_PATHLENGTH, wszINFKEY_CRITICAL, NULL };

    ZeroMemory(pext, sizeof(*pext));
    ZeroMemory(&bc2i, sizeof(bc2i));
    myInfClearError();

    pext->fCritical = TRUE;	// default value for both INF and default cases
    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	if (!fDefault)
	{
	    hr = E_HANDLE;
	    _JumpError2(hr, error, "hInf", hr);
	}
    }
    else
    {
	hr = infSetupFindFirstLine(
			    hInf,
			    wszINFSECTION_BASICCONSTRAINTS,
			    NULL,	// pwszKey
			    FALSE,	// fUniqueKey
			    0,		// cValueMax
			    s_apwszKeys,
			    TRUE,	// fUniqueValidKeys
			    &InfContext);
	if (S_OK != hr)
	{
	    if (!fDefault)
	    {
		_JumpErrorStr3(
			    hr,
			    error,
			    "infSetupFindFirstLine",
			    wszINFSECTION_BASICCONSTRAINTS,
			    S_FALSE,
			    (HRESULT) ERROR_LINE_NOT_FOUND);
	    }
	}
	else
	{
	    hr = infGetCriticalFlag(
				hInf,
				wszINFSECTION_BASICCONSTRAINTS,
				pext->fCritical,	// fDefault
				&pext->fCritical);
	    _JumpIfError(hr, error, "infGetCriticalFlag");

	    bc2i.fPathLenConstraint = TRUE;
	    hr = myInfGetNumericKeyValue(
				hInf,
				TRUE,			// fLog
				wszINFSECTION_BASICCONSTRAINTS,
				wszINFKEY_PATHLENGTH,
				1,
				TRUE,	// fLastValue
				&bc2i.dwPathLenConstraint);
	    if (S_OK != hr)
	    {
		_PrintErrorStr2(
			    hr,
			    "myInfGetNumericKeyValue",
			    wszINFKEY_PATHLENGTH,
			    ERROR_LINE_NOT_FOUND);
		if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
		{
		    goto error;
		}
		bc2i.dwPathLenConstraint = 0;
		bc2i.fPathLenConstraint = FALSE;
	    }
	}
    }
    bc2i.fCA = TRUE;

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_BASIC_CONSTRAINTS2,
		    &bc2i,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
        hr = myHLastError();
        _JumpError(hr, error, "myEncodeObject");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, wszINFSECTION_BASICCONSTRAINTS, NULL, NULL);
    }
    pext->pszObjId = szOID_BASIC_CONSTRAINTS2;	// on error, too!
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetBasicConstraints2CAExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}

//+--------------------------------------------------------------------------
// myInfGetBasicConstraints2CAExtension -- fetch basic constraints extension
// from INF file, setting the SubjectType flag to CA
//
// [BasicConstraintsExtension]
// ; Subject Type is not supported -- always set to CA
// ; maximum subordinate CA path length
// PathLength = 3
//
// Return S_OK if extension has been constructed from INF file.
//
// Returns: encoded basic constraints extension
//+--------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtension;

HRESULT
myInfGetBasicConstraints2CAExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetBasicConstraints2CAExtension(FALSE, hInf, pext);
    _JumpIfError3(
		hr,
		error,
		"infGetBasicConstraints2CAExtension",
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

error:
    return(hr);
}


FNMYINFGETEXTENSION myInfGetBasicConstraints2CAExtensionOrDefault;

HRESULT
myInfGetBasicConstraints2CAExtensionOrDefault(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetBasicConstraints2CAExtension(TRUE, hInf, pext);
    _JumpIfError(hr, error, "infGetBasicConstraints2CAExtension");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// myInfGetEnhancedKeyUsageExtension -- fetch EKU extension from INF file
//
// [EnhancedKeyUsageExtension]
// OID = 1.2.3.4.5
// OID = 1.2.3.4.6
//
// Return S_OK if extension has been constructed from INF file.
// Return S_FALSE if empty section detected in INF file
// Return other error if no section detected in INF file
//
// Returns: encoded enhanced key usage extension
//+--------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetEnhancedKeyUsageExtension;

HRESULT
myInfGetEnhancedKeyUsageExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    DWORD i;
    DWORD cEKU = 0;
    WCHAR *pwszzEKU = NULL;
    WCHAR *pwszCurrentEKU;
    CERT_ENHKEY_USAGE ceku;

    ceku.rgpszUsageIdentifier = NULL;
    ceku.cUsageIdentifier = 0;
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = myInfGetEnhancedKeyUsage(hInf, &pext->fCritical, &pwszzEKU);
    _JumpIfError3(
		hr,
		error,
		"myInfGetEnhancedKeyUsage",
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

    pwszCurrentEKU = pwszzEKU;
    if (NULL != pwszCurrentEKU)
    {
	while (L'\0' != *pwszCurrentEKU)
	{
	    cEKU++;
	    pwszCurrentEKU += wcslen(pwszCurrentEKU) + 1;
	}
    }
    if (0 == cEKU)
    {
        hr = S_FALSE;
        goto error;
    }

    ceku.cUsageIdentifier = cEKU;
    ceku.rgpszUsageIdentifier = (char **) LocalAlloc(
			LMEM_FIXED | LMEM_ZEROINIT,
			sizeof(ceku.rgpszUsageIdentifier[0]) * cEKU);
    if (NULL == ceku.rgpszUsageIdentifier)
    {
        hr = E_OUTOFMEMORY;
	_JumpIfError(hr, error, "LocalAlloc");
    }

    cEKU = 0;
    pwszCurrentEKU = pwszzEKU;
    while (L'\0' != *pwszCurrentEKU)
    {
	if (!ConvertWszToSz(&ceku.rgpszUsageIdentifier[cEKU], pwszCurrentEKU, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToSz");
	}
	cEKU++;
	pwszCurrentEKU += wcslen(pwszCurrentEKU) + 1;
    }
    CSASSERT(ceku.cUsageIdentifier == cEKU);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ENHANCED_KEY_USAGE,
		    &ceku,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpIfError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && E_HANDLE != hr)
    {
	INFSETERROR(hr, wszINFSECTION_EKU, NULL, NULL);
    }
    pext->pszObjId = szOID_ENHANCED_KEY_USAGE;	// on error, too!
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetEnhancedKeyUsageExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    if (NULL != ceku.rgpszUsageIdentifier)
    {
	for (i = 0; i < ceku.cUsageIdentifier; i++)
	{
	    if (NULL != ceku.rgpszUsageIdentifier[i])
	    {
		LocalFree(ceku.rgpszUsageIdentifier[i]);
	    }
	}
	LocalFree(ceku.rgpszUsageIdentifier);
    }
    if (NULL != pwszzEKU)
    {
	LocalFree(pwszzEKU);
    }
    return(hr);
}


HRESULT
infAddAttribute(
    IN CRYPT_ATTR_BLOB const *pAttribute,
    IN OUT DWORD *pcAttribute,
    IN OUT CRYPT_ATTR_BLOB **ppaAttribute)
{
    HRESULT hr;
    CRYPT_ATTR_BLOB *pAttribT;
    
    if (NULL == *ppaAttribute)
    {
	CSASSERT(0 == *pcAttribute);
	pAttribT = (CRYPT_ATTR_BLOB *) LocalAlloc(
					    LMEM_FIXED,
					    sizeof(**ppaAttribute));
    }
    else
    {
	CSASSERT(0 != *pcAttribute);
	pAttribT = (CRYPT_ATTR_BLOB *) LocalReAlloc(
				*ppaAttribute,
				(*pcAttribute + 1) * sizeof(**ppaAttribute),
				LMEM_MOVEABLE);
    }
    if (NULL == pAttribT)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
		hr,
		error,
		NULL == *ppaAttribute? "LocalAlloc" : "LocalReAlloc");
    }
    *ppaAttribute = pAttribT;
    pAttribT[(*pcAttribute)++] = *pAttribute;
    hr = S_OK;

error:
    return(hr);
}


VOID
myInfFreeRequestAttributes(
    IN DWORD cAttribute,
    IN OUT CRYPT_ATTR_BLOB *paAttribute)
{
    if (NULL != paAttribute)
    {
	DWORD i;
	
	for (i = 0; i < cAttribute; i++)
	{
	    if (NULL != paAttribute[i].pbData)
	    {
		LocalFree(paAttribute[i].pbData);
	    }
	}
	LocalFree(paAttribute);
    }
}


//+------------------------------------------------------------------------
// myInfGetRequestAttributes -- fetch request attributes from INF file
//
// [RequestAttributes]
// AttributeName1 = AttributeValue1
// AttributeName2 = AttributeValue2
// ...
// AttributeNameN = AttributeValueN
//
// Returns: array of encoded attribute blobs
//-------------------------------------------------------------------------

HRESULT
myInfGetRequestAttributes(
    IN  HINF hInf,
    OUT DWORD *pcAttribute,
    OUT CRYPT_ATTR_BLOB **ppaAttribute,
    OUT WCHAR **ppwszTemplateName)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValue = NULL;
    DWORD cAttribute = 0;
    CRYPT_ATTR_BLOB Attribute;
    WCHAR *pwszTemplateName = NULL;

    *ppwszTemplateName = NULL;
    *pcAttribute = 0;
    *ppaAttribute = NULL;
    Attribute.pbData = NULL;
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(
			hInf,
			wszINFSECTION_REQUESTATTRIBUTES,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr2(
		hr,
		error,
		"infSetupFindFirstLine",
		wszINFSECTION_REQUESTATTRIBUTES,
		ERROR_LINE_NOT_FOUND);

    for (;;)
    {
	CRYPT_ENROLLMENT_NAME_VALUE_PAIR NamePair;

	if (NULL != pwszName)
	{
	    LocalFree(pwszName);
	    pwszName = NULL;
	}
	if (NULL != pwszValue)
	{
	    LocalFree(pwszValue);
	    pwszValue = NULL;
	}
	hr = infGetCurrentKeyValue(
			    &InfContext,
			    wszINFSECTION_REQUESTATTRIBUTES,
			    NULL,	// pwszKey
			    0,
			    FALSE,	// fLastValue
			    &pwszName);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	hr = infGetCurrentKeyValue(
			    &InfContext,
			    wszINFSECTION_REQUESTATTRIBUTES,
			    pwszName,
			    1,
			    TRUE,	// fLastValue
			    &pwszValue);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	//wprintf(L"%ws = %ws\n", pwszName, pwszValue);

	NamePair.pwszName = pwszName;
	NamePair.pwszValue = pwszValue;

	if (0 == LSTRCMPIS(pwszName, wszPROPCERTTEMPLATE))
	{
	    if (NULL != pwszTemplateName)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "Duplicate cert template");
	    }
	    pwszTemplateName = pwszValue;
	    pwszValue = NULL;
	}

	if (!myEncodeObject(
			X509_ASN_ENCODING,
			// X509__ENROLLMENT_NAME_VALUE_PAIR
			szOID_ENROLLMENT_NAME_VALUE_PAIR,
			&NamePair,
			0,
			CERTLIB_USE_LOCALALLOC,
			&Attribute.pbData,
			&Attribute.cbData))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "myEncodeObject");
	}

	hr = infAddAttribute(&Attribute, &cAttribute, ppaAttribute);
	_JumpIfError(hr, error, "infAddAttribute");

	Attribute.pbData = NULL;

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupFindNextLine(end)", hr);
	    break;
	}
    }
    *pcAttribute = cAttribute;
    cAttribute = 0;
    *ppwszTemplateName = pwszTemplateName;
    pwszTemplateName = NULL;

    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, wszINFSECTION_REQUESTATTRIBUTES, pwszName, pwszValue);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pwszTemplateName)
    {
	LocalFree(pwszTemplateName);
    }
    if (NULL != Attribute.pbData)
    {
	LocalFree(Attribute.pbData);
    }
    if (0 != cAttribute)
    {
	myInfFreeRequestAttributes(cAttribute, *ppaAttribute);
	*ppaAttribute = NULL;
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetRequestAttributes hr=%x --> c=%d\n",
	hr,
	*pcAttribute));
    return(hr);
}


typedef struct _SUBTREEINFO
{
    BOOL	 fEmptyDefault;
    DWORD	 dwInfMinMaxIndexBase;
    DWORD	 dwAltNameChoice;
    WCHAR const *pwszKey;
} SUBTREEINFO;

SUBTREEINFO g_aSubTreeInfo[] = {
    { TRUE,  2, CERT_ALT_NAME_OTHER_NAME,	wszINFKEY_UPN },
    { TRUE,  2, CERT_ALT_NAME_RFC822_NAME,	wszINFKEY_EMAIL },
    { TRUE,  2, CERT_ALT_NAME_DNS_NAME,		wszINFKEY_DNS },
    { TRUE,  2, CERT_ALT_NAME_DIRECTORY_NAME,	wszINFKEY_DIRECTORYNAME },
    { TRUE,  2, CERT_ALT_NAME_URL,		wszINFKEY_URL },
    { TRUE,  3, CERT_ALT_NAME_IP_ADDRESS,	wszINFKEY_IPADDRESS },
    { FALSE, 2, CERT_ALT_NAME_REGISTERED_ID,	wszINFKEY_REGISTEREDID },
    { FALSE, 3, CERT_ALT_NAME_OTHER_NAME,	wszINFKEY_OTHERNAME },
};
#define CSUBTREEINFO	ARRAYSIZE(g_aSubTreeInfo)

#define STII_OTHERNAMEUPN   0  // CERT_ALT_NAME_OTHER_NAME	pOtherName
#define STII_RFC822NAME	    1  // CERT_ALT_NAME_RFC822_NAME	pwszRfc822Name
#define STII_DNSNAME	    2  // CERT_ALT_NAME_DNS_NAME	pwszDNSName
#define STII_DIRECTORYNAME  3  // CERT_ALT_NAME_DIRECTORY_NAME	DirectoryName
#define STII_URL	    4  // CERT_ALT_NAME_URL		pwszURL
#define STII_IPADDRESS	    5  // CERT_ALT_NAME_IP_ADDRESS	IPAddress
#define STII_REGISTEREDID   6  // CERT_ALT_NAME_REGISTERED_ID	pszRegisteredID
#define STII_OTHERNAMEOID   7  // CERT_ALT_NAME_OTHER_NAME	pOtherName


VOID
infFreeGeneralSubTreeElement(
    IN OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    CERT_ALT_NAME_ENTRY *pName = &pSubTree->Base;
    VOID **ppv = NULL;
    
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infFreeGeneralSubTreeElement: p=%x, choice=%x\n",
	pSubTree,
	pName->dwAltNameChoice));
    switch (pName->dwAltNameChoice)
    {
	case CERT_ALT_NAME_OTHER_NAME:
	    ppv = (VOID **) &pName->pOtherName;
	    if (NULL != pName->pOtherName)
	    {
		if (NULL != pName->pOtherName->Value.pbData)
		{
		    DBGPRINT((
			DBG_SS_CERTLIBI,
			"infFreeGeneralSubTreeElement: p=%x, Free(other.pbData=%x)\n",
			pSubTree,
			pName->pOtherName->Value.pbData));
		    LocalFree(pName->pOtherName->Value.pbData);
		}
		if (NULL != pName->pOtherName->pszObjId)
		{
		    DBGPRINT((
			DBG_SS_CERTLIBI,
			"infFreeGeneralSubTreeElement: p=%x, Free(other.pszObjId=%x)\n",
			pSubTree,
			pName->pOtherName->pszObjId));
		    LocalFree(pName->pOtherName->pszObjId);
		}
	    }
	    break;

	case CERT_ALT_NAME_RFC822_NAME:
	    ppv = (VOID **) &pName->pwszRfc822Name;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    ppv = (VOID **) &pName->pwszDNSName;
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	    ppv = (VOID **) &pName->DirectoryName.pbData;
	    break;

	case CERT_ALT_NAME_URL:
	    ppv = (VOID **) &pName->pwszURL;
	    break;

	case CERT_ALT_NAME_IP_ADDRESS:
	    ppv = (VOID **) &pName->IPAddress.pbData;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    ppv = (VOID **) &pName->pszRegisteredID;
	    break;
    }
    if (NULL != ppv && NULL != *ppv)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infFreeGeneralSubTreeElement: p=%x, Free(pv=%x)\n",
	    pSubTree,
	    *ppv));
	LocalFree(*ppv);
    }
}


VOID
infFreeGeneralSubTree(
    IN DWORD cSubTree,
    IN OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    if (NULL != pSubTree)
    {
	DWORD i;
	
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infFreeGeneralSubTree: p=%x, c=%x\n",
	    pSubTree,
	    cSubTree));
	for (i = 0; i < cSubTree; i++)
	{
	    infFreeGeneralSubTreeElement(&pSubTree[i]);
	}
	LocalFree(pSubTree);
    }
}


HRESULT
infParseIPAddressAndMask(
    IN WCHAR const *pwszIPAddress,
    IN WCHAR const *pwszIPAddressMask,
    OUT BYTE **ppbData,
    OUT DWORD *pcbData)
{
    HRESULT hr;
    BYTE ab[2 * CB_IPV6ADDRESS];
    DWORD cb;
    DWORD cbAddress;
    DWORD cbMask=0;
    WCHAR const *pwszValue = pwszIPAddress;

    *ppbData = NULL;
    *pcbData = 0;

    // if pwszValue is an empty string, encode zero length blob.

    cb = 0;
    if (L'\0' != *pwszIPAddress && L'\0' != *pwszIPAddressMask)
    {
	cbAddress = sizeof(ab) / 2;

	hr = myParseIPAddress(pwszIPAddress, ab, &cbAddress);
	_JumpIfError(hr, error, "myParseIPAddress");

	if (L'\0' != *pwszIPAddressMask)
	{
	    cbMask = sizeof(ab) / 2;
	    pwszValue = pwszIPAddressMask;
	    hr = myParseIPAddress(pwszIPAddressMask, &ab[cbAddress], &cbMask);
	    _JumpIfError(hr, error, "infParseIPMask");
	}
	if (cbAddress != cbMask)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "address and mask lengths differ");
	}
	cb = cbAddress + cbMask;
    }
    else if (L'\0' != *pwszIPAddress || L'\0' != *pwszIPAddressMask)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "address or mask missing");
    }

    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppbData)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *pcbData = cb;
    CopyMemory(*ppbData, ab, cb);
    DBGDUMPHEX((
	    DBG_SS_CERTLIBI,
	    DH_NOADDRESS | DH_NOTABPREFIX | 8,
	    *ppbData,
	    *pcbData));
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, NULL, pwszValue);
    }
    return(hr);
}


HRESULT
infVerifySubtreeElement(
    IN CERT_GENERAL_SUBTREE const *pSubTree)
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;
    CERT_NAME_CONSTRAINTS_INFO *pnci = NULL;
    CERT_NAME_CONSTRAINTS_INFO nci;

    ZeroMemory(&nci, sizeof(nci));
    nci.cPermittedSubtree = 1;
    nci.rgPermittedSubtree = const_cast<CERT_GENERAL_SUBTREE *>(pSubTree);

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME_CONSTRAINTS,
		    &nci,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pb,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME_CONSTRAINTS,
		    pb,
		    cb,
		    CERTLIB_USE_LOCALALLOC,
		    (VOID **) &pnci,
		    &cb))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeObject");
    }
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    if (NULL != pnci)
    {
	LocalFree(pnci);
    }
    return(hr);
}


// [NameConstraintsPermitted]/[NameConstraintsExcluded]
// ; the numeric second and third arguments are optional
// ; when present, the second argument is the minimum depth
// ; when present, the third argument is the maximum depth
// ; The IETF recommends against specifying dwMinimum & dwMaximum
// DNS = foo@domain.com
// DNS = domain1.domain.com, 3, 6

HRESULT
infBuildSubTreeElement(
    IN OUT INFCONTEXT *pInfContext,
    OPTIONAL IN WCHAR const *pwszEmptyEntry,	// NULL means read INF file
    IN DWORD iSubTreeInfo,
    OPTIONAL OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    HRESULT hr;
    SUBTREEINFO const *pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];
    CERT_GENERAL_SUBTREE SubTree;
    WCHAR *pwszValueRead = NULL;
    WCHAR *pwszValueRead2 = NULL;
    WCHAR const *pwszValue = NULL;
    WCHAR const *pwszValue2;

    ZeroMemory(&SubTree, sizeof(SubTree));
    if (NULL != pSubTree)
    {
	ZeroMemory(pSubTree, sizeof(*pSubTree));
    }

    // If pwszEmptyEntry is NULL, read the value from the INF file.
    // Otherwise, encode the specified (empty string) value.

    if (NULL == pwszEmptyEntry)
    {
	INT Value;

	hr = infGetCurrentKeyValue(
			pInfContext,
			NULL,	// pwszSection
			NULL,	// pwszKey
			1,
			2 == pSubTreeInfo->dwInfMinMaxIndexBase, // fLastValue
			&pwszValueRead);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	pwszValue = pwszValueRead;

	if (!SetupGetIntField(
			pInfContext,
			pSubTreeInfo->dwInfMinMaxIndexBase,
			&Value))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupGetIntField:2", hr);

	    Value = 0;
	}
	SubTree.dwMinimum = Value;
	SubTree.fMaximum = TRUE;

	if (!SetupGetIntField(
			pInfContext,
			pSubTreeInfo->dwInfMinMaxIndexBase + 1,
			&Value))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupGetIntField:3", hr);

	    Value = 0;
	    SubTree.fMaximum = FALSE;
	}
	SubTree.dwMaximum = Value;
    }
    else
    {
	pwszValue = pwszEmptyEntry;
    }

    SubTree.Base.dwAltNameChoice = pSubTreeInfo->dwAltNameChoice;
    if (NULL != pSubTree)
    {
	WCHAR **ppwsz = NULL;
	
	CSASSERT(CSUBTREEINFO > iSubTreeInfo);
	switch (iSubTreeInfo)
	{
	    case STII_OTHERNAMEUPN:
	    case STII_OTHERNAMEOID:
	    {
		CERT_NAME_VALUE nameUpn;

		SubTree.Base.pOtherName = (CERT_OTHER_NAME *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT, 
					    sizeof(*SubTree.Base.pOtherName));
		if (NULL == SubTree.Base.pOtherName)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
		if (STII_OTHERNAMEUPN == iSubTreeInfo)
		{
		    hr = myDupStringA(
				szOID_NT_PRINCIPAL_NAME,
				&SubTree.Base.pOtherName->pszObjId);
		    _JumpIfError(hr, error, "myDupStringA");

		    nameUpn.dwValueType = CERT_RDN_UTF8_STRING;
		    nameUpn.Value.pbData = (BYTE *) pwszValue;
		    nameUpn.Value.cbData = 0;

		    if (!myEncodeObject(
				X509_ASN_ENCODING,
				X509_UNICODE_ANY_STRING,
				&nameUpn,
				0,
				CERTLIB_USE_LOCALALLOC,
				&SubTree.Base.pOtherName->Value.pbData,
				&SubTree.Base.pOtherName->Value.cbData))
		    {
			hr = myHLastError();
			_JumpError(hr, error, "myEncodeObject");
		    }
		}
		else
		{
		    hr = myVerifyObjId(pwszValue);
		    _JumpIfErrorStr(hr, error, "myVerifyObjId", pwszValue);

		    if (!myConvertWszToSz(
				&SubTree.Base.pOtherName->pszObjId,
				pwszValue,
				-1))
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "ConvertWszToSz");
		    }
		    if (NULL == pwszEmptyEntry)
		    {
			hr = infGetCurrentKeyValue(
					    pInfContext,
					    NULL,	// pwszSection
					    NULL,	// pwszKey
					    2,
					    TRUE,	// fLastValue
					    &pwszValueRead2);
			_PrintIfError2(hr, "infGetCurrentKeyValue", hr);

			pwszValue2 = pwszValueRead2;
		    }
		    else
		    {
			pwszValue2 = pwszEmptyEntry;
		    }
		    if (NULL == pwszValue2 || L'\0' == *pwszValue2)
		    {
			pwszValue2 = wszPROPOCTETTAG;
		    }
		    hr = myEncodeOtherNameBinary(
			    pwszValue2,
			    &SubTree.Base.pOtherName->Value.pbData,
			    &SubTree.Base.pOtherName->Value.cbData);
		    _JumpIfError(hr, error, "myEncodeOtherNameBinary");
		}
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infBuildSubTreeElement: p=%x, OtherName=%x,%x,%x\n",
		    pSubTree,
		    SubTree.Base.pOtherName,
		    SubTree.Base.pOtherName->pszObjId,
		    SubTree.Base.pOtherName->Value.pbData));
		break;
	    }

	    case STII_RFC822NAME:
		ppwsz = &SubTree.Base.pwszRfc822Name;
		break;

	    case STII_DNSNAME:
		ppwsz = &SubTree.Base.pwszDNSName;
		break;

	    case STII_DIRECTORYNAME:
		hr = myCertStrToName(
			X509_ASN_ENCODING,
			pwszValue,		// pszX500
			CERT_NAME_STR_REVERSE_FLAG,
			NULL,			// pvReserved
			&SubTree.Base.DirectoryName.pbData,
			&SubTree.Base.DirectoryName.cbData,
			NULL);			// ppszError
		_JumpIfError(hr, error, "myCertStrToName");

		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infBuildSubTreeElement: p=%x, DirName=%x\n",
		    pSubTree,
		    SubTree.Base.DirectoryName.pbData));
		break;

	    case STII_URL:
		ppwsz = &SubTree.Base.pwszURL;
		break;

	    case STII_IPADDRESS:

		// convert INF string value to binary IP Address

		if (NULL == pwszEmptyEntry)
		{
		    hr = infGetCurrentKeyValue(
					pInfContext,
					NULL,	// pwszSection
					NULL,	// pwszKey
					2,
					TRUE,	// fLastValue
					&pwszValueRead2);
		    _JumpIfError(hr, error, "infGetCurrentKeyValue");

		    pwszValue2 = pwszValueRead2;
		}
		else
		{
		    pwszValue2 = pwszEmptyEntry;
		}

		hr = infParseIPAddressAndMask(
				pwszValue,
				pwszValue2,
				&SubTree.Base.IPAddress.pbData,
				&SubTree.Base.IPAddress.cbData);
		_JumpIfError(hr, error, "infParseIPAddressAndMask");

		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infBuildSubTreeElement: p=%x, IPAddress=%x\n",
		    pSubTree,
		    SubTree.Base.IPAddress.pbData));
		break;

	    case STII_REGISTEREDID:
		if (!myConvertWszToSz(
			    &SubTree.Base.pszRegisteredID,
			    pwszValue,
			    -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToSz");
		}
		DBGPRINT((
		    DBG_SS_CERTLIBI,
		    "infBuildSubTreeElement: p=%x, psz=%x\n",
		    pSubTree,
		    SubTree.Base.pszRegisteredID));
		break;

	}
	if (NULL != ppwsz)
	{
	    hr = myDupString(pwszValue, ppwsz);
	    _JumpIfError(hr, error, "myDupString");

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"infBuildSubTreeElement: p=%x, pwsz=%x\n",
		pSubTree,
		*ppwsz));
	}
	hr = infVerifySubtreeElement(&SubTree);
	_JumpIfErrorStr(hr, error, "infVerifySubTreeElement", pSubTreeInfo->pwszKey);

	*pSubTree = SubTree;
	ZeroMemory(&SubTree, sizeof(SubTree));
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, NULL, NULL, pwszValue);
    }
    infFreeGeneralSubTreeElement(&SubTree);
    if (NULL != pwszValueRead)
    {
	LocalFree(pwszValueRead);
    }
    if (NULL != pwszValueRead2)
    {
	LocalFree(pwszValueRead2);
    }
    return(hr);
}


HRESULT
infGetGeneralSubTreeByType(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OPTIONAL IN WCHAR const *pwszEmptyEntry,
    IN DWORD iSubTreeInfo,
    IN OUT DWORD *pcName,
    OPTIONAL OUT CERT_GENERAL_SUBTREE *pSubTree)
{
    HRESULT hr;
    SUBTREEINFO const *pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];
    INFCONTEXT InfContext;
    DWORD iName;
    DWORD cName = MAXDWORD;
    BOOL fIgnore = FALSE;

    if (NULL == pSubTree)
    {
	*pcName = 0;
    }
    else
    {
	cName = *pcName;
    }

    // If pwszEmptyEntry is NULL, read the value from the INF file.
    // Otherwise, encode the specified (empty string) value.

    if (!SetupFindFirstLine(
			hInf,
			pwszSection,
			pSubTreeInfo->pwszKey,
			&InfContext))
    {
        hr = myHLastError();
        _PrintErrorStr2(
		    hr,
		    "SetupFindFirstLine",
		    pwszSection,
		    ERROR_LINE_NOT_FOUND);

	// INF file entry does not exist.  Create an empty name constraints
	// entry only if asked to do so (if pwszEmptyEntry is non-NULL).

	if (NULL == pwszEmptyEntry)
	{
	    fIgnore = (HRESULT) ERROR_LINE_NOT_FOUND == hr;
	    goto error;
	}
    }
    else
    {
	// INF file entry exists; don't create an empty name constraints entry.

	pwszEmptyEntry = NULL;
    }

    for (iName = 0; ; )
    {
	CSASSERT(NULL == pSubTree || iName < cName);
	hr = infBuildSubTreeElement(
			    &InfContext,
			    pwszEmptyEntry,
			    iSubTreeInfo,
			    pSubTree);
	_JumpIfErrorStr(hr, error, "infBuildSubTreeElement", pSubTreeInfo->pwszKey);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infBuildSubTreeElement: &p[%u]=%x, type=%ws\n",
	    iName,
	    pSubTree,
	    pSubTreeInfo->pwszKey));
	iName++;
	if (NULL != pSubTree)
	{
	    pSubTree++;
	}

	if (NULL == pwszEmptyEntry)
	{
	    hr = infFindNextKey(pSubTreeInfo->pwszKey, &InfContext);
	}
	else
	{
	    hr = S_FALSE;
	}
	if (S_FALSE == hr)
	{
	    break;
	}
	_JumpIfErrorStr(hr, error, "infFindNextKey", pSubTreeInfo->pwszKey);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infGetGeneralSubTreeByType: i=%x, c=%x\n",
	iName,
	cName));
    CSASSERT(NULL == pSubTree || iName <= cName);
    *pcName = iName;
    hr = S_OK;

error:
    if (S_OK != hr && !fIgnore)
    {
	INFSETERROR(hr, pwszSection, pSubTreeInfo->pwszKey, NULL);
    }
    return(hr);
}


HRESULT
infGetGeneralSubTree(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN WCHAR const *pwszKey,		// key value is sub-section name
    OPTIONAL IN WCHAR const *pwszEmptyEntry,
    OUT DWORD *pcSubTree,
    OUT CERT_GENERAL_SUBTREE **ppSubTree)
{
    HRESULT hr;
    WCHAR *pwszSubTreeSection = NULL;
    DWORD cSubTree = 0;
    CERT_GENERAL_SUBTREE *rgSubTree = NULL;
    CERT_GENERAL_SUBTREE *pSubTree;
    DWORD iSubTreeInfo;
    DWORD count;
    DWORD cRemain;
    SUBTREEINFO const *pSubTreeInfo;
    INFCONTEXT InfContext;
    static WCHAR const * const s_apwszKeys[] =
    {
	wszINFKEY_UPN,
	wszINFKEY_EMAIL,
	wszINFKEY_DNS,
	wszINFKEY_DIRECTORYNAME,
	wszINFKEY_URL,
	wszINFKEY_IPADDRESS,
	wszINFKEY_REGISTEREDID,
	wszINFKEY_OTHERNAME,
	NULL
    };

    *pcSubTree = 0;
    *ppSubTree = NULL;

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    hr = myInfGetKeyValue(
		    hInf,
		    TRUE,	// fLog
		    pwszSection,
		    pwszKey,
		    1,
		    TRUE,	// fLastValue
		    &pwszSubTreeSection);
    _JumpIfErrorStr2(
		hr,
		error,
		"myInfGetKeyValue",
		pwszKey,
		ERROR_LINE_NOT_FOUND);

    hr = infSetupFindFirstLine(
			hInf,
			pwszSubTreeSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			s_apwszKeys,
			FALSE,	// fUniqueValidKeys
			&InfContext);

    // if S_FALSE is returned if the section is empty.  In this case,
    // allow execution to continue, to fill in the empty permitted names.

    if (S_OK != hr &&
	S_FALSE != hr)
    {
	if ((HRESULT) ERROR_LINE_NOT_FOUND == hr)
	{
	    hr = SPAPI_E_LINE_NOT_FOUND;	// don't ignore this error
	}
	INFSETERROR(hr, pwszSubTreeSection, L"", L"");
	_JumpErrorStr(hr, error, "infSetupFindFirstLine", pwszSubTreeSection);
    }

    for (iSubTreeInfo = 0; iSubTreeInfo < CSUBTREEINFO; iSubTreeInfo++)
    {
	pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];

	hr = infGetGeneralSubTreeByType(
			    hInf,
			    pwszSubTreeSection,
			    pSubTreeInfo->fEmptyDefault? pwszEmptyEntry : NULL,
			    iSubTreeInfo,
			    &count,
			    NULL);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infGetGeneralSubTreeByType(%ws, %ws, NULL) -> hr=%x, c=%x\n",
	    pwszSubTreeSection,
	    pSubTreeInfo->pwszKey,
	    hr,
	    count));
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"infGetGeneralSubTreeByType",
			pSubTreeInfo->pwszKey,
			ERROR_LINE_NOT_FOUND);
	    if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	    {
		_JumpErrorStr(
			    hr,
			    error,
			    "infGetGeneralSubTreeByType",
			    pSubTreeInfo->pwszKey);
	    }
	    count = 0;
	}
	cSubTree += count;
    }
    if (0 == cSubTree)
    {
	hr = SPAPI_E_LINE_NOT_FOUND;	// don't ignore this error
	INFSETERROR(hr, pwszSubTreeSection, L"", L"");
	_JumpErrorStr(hr, error, "infSetupFindFirstLine", pwszSubTreeSection);
    }
    rgSubTree = (CERT_GENERAL_SUBTREE *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cSubTree * sizeof(rgSubTree[0]));
    if (NULL == rgSubTree)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"infGetGeneralSubTree: rg=%x, total=%x\n",
	rgSubTree,
	cSubTree));

    pSubTree = rgSubTree;
    cRemain = cSubTree;
    for (iSubTreeInfo = 0; iSubTreeInfo < CSUBTREEINFO; iSubTreeInfo++)
    {
	pSubTreeInfo = &g_aSubTreeInfo[iSubTreeInfo];
	count = cRemain;
	hr = infGetGeneralSubTreeByType(
			    hInf,
			    pwszSubTreeSection,
			    pSubTreeInfo->fEmptyDefault? pwszEmptyEntry : NULL,
			    iSubTreeInfo,
			    &count,
			    pSubTree);
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "infGetGeneralSubTreeByType(%ws, %ws, &p[%x]=%x) -> hr=%x, c=%x\n",
	    pwszSubTreeSection,
	    pSubTreeInfo->pwszKey,
	    SAFE_SUBTRACT_POINTERS(pSubTree, rgSubTree),
	    pSubTree,
	    hr,
	    count));
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
			hr,
			"infGetGeneralSubTreeByType",
			pSubTreeInfo->pwszKey,
			ERROR_LINE_NOT_FOUND);
	    if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	    {
		_JumpErrorStr(
			    hr,
			    error,
			    "infGetGeneralSubTreeByType",
			    pSubTreeInfo->pwszKey);
	    }
	    if (0 < cRemain)
	    {
		ZeroMemory(pSubTree, sizeof(*pSubTree));
	    }
	    count = 0;
	}
	cRemain -= count;
	pSubTree += count;
    }
    CSASSERT(0 == cRemain);
    *pcSubTree = cSubTree;
    *ppSubTree = rgSubTree;
    rgSubTree = NULL;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, pwszSection, pwszKey, pwszSubTreeSection);
    }
    if (NULL != pwszSubTreeSection)
    {
	LocalFree(pwszSubTreeSection);
    }
    if (NULL != rgSubTree)
    {
	infFreeGeneralSubTree(cSubTree, rgSubTree);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetNameConstraintsExtension -- fetch name constraints extension from INF file
//
// [NameConstraintsExtension]
// Include = NameConstraintsPermitted
// Exclude = NameConstraintsExcluded
//
// [NameConstraintsPermitted]
// ; the numeric second and third arguments are optional
// ; when present, the second argument is the minimum depth
// ; when present, the third argument is the maximum depth
// ; The IETF recommends against specifying dwMinimum & dwMaximum
// DNS = foo@domain.com
// DNS = domain1.domain.com, 3, 6
//
// [NameConstraintsExcluded]
// DNS = domain.com
// DNS = domain2.com
//
// Returns: encoded name constraints extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetNameConstraintsExtension;

HRESULT
myInfGetNameConstraintsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    WCHAR const *pwszKey = NULL;
    CERT_NAME_CONSTRAINTS_INFO NameConstraints;
    INFCONTEXT InfContext;
    static WCHAR const * const s_apwszKeys[] =
      { wszINFKEY_EXCLUDE, wszINFKEY_INCLUDE, wszINFKEY_CRITICAL, NULL };

    ZeroMemory(&NameConstraints, sizeof(NameConstraints));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(
			hInf,
			wszINFSECTION_NAMECONSTRAINTS,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			s_apwszKeys,
			TRUE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr2(
		hr,
		error,
		"infSetupFindFirstLine",
		wszINFSECTION_NAMECONSTRAINTS,
		ERROR_LINE_NOT_FOUND);

    pwszKey = wszINFKEY_INCLUDE;
    hr = infGetGeneralSubTree(
		    hInf,
		    wszINFSECTION_NAMECONSTRAINTS,
		    pwszKey,
		    L"",
		    &NameConstraints.cPermittedSubtree,
		    &NameConstraints.rgPermittedSubtree);
    _PrintIfErrorStr2(
		hr,
		"infGetGeneralSubTree",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
    if (S_OK != hr && (HRESULT) ERROR_LINE_NOT_FOUND != hr)
    {
	goto error;
    }

    pwszKey = wszINFKEY_EXCLUDE;
    hr = infGetGeneralSubTree(
		    hInf,
		    wszINFSECTION_NAMECONSTRAINTS,
		    pwszKey,
		    NULL,
		    &NameConstraints.cExcludedSubtree,
		    &NameConstraints.rgExcludedSubtree);
    _PrintIfErrorStr2(
		hr,
		"infGetGeneralSubTree",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
    if (S_OK != hr && (HRESULT) ERROR_LINE_NOT_FOUND != hr)
    {
	goto error;
    }
    pwszKey = NULL;

    if (NULL == NameConstraints.rgPermittedSubtree &&
	NULL == NameConstraints.rgExcludedSubtree)
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "no data", hr);
    }
    hr = infGetCriticalFlag(
			hInf,
			wszINFSECTION_NAMECONSTRAINTS,
			FALSE,
			&pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_NAME_CONSTRAINTS,
		    &NameConstraints,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, wszINFSECTION_NAMECONSTRAINTS, pwszKey, NULL);
    }
    pext->pszObjId = szOID_NAME_CONSTRAINTS;	// on error, too!

    if (NULL != NameConstraints.rgPermittedSubtree)
    {
	infFreeGeneralSubTree(
			NameConstraints.cPermittedSubtree,
			NameConstraints.rgPermittedSubtree);
    }
    if (NULL != NameConstraints.rgExcludedSubtree)
    {
	infFreeGeneralSubTree(
			NameConstraints.cExcludedSubtree,
			NameConstraints.rgExcludedSubtree);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetNameConstraintsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


VOID
infFreePolicyMappings(
    IN DWORD cPolicyMapping,
    IN OUT CERT_POLICY_MAPPING *pPolicyMapping)
{
    if (NULL != pPolicyMapping)
    {
	DWORD i;
	
	for (i = 0; i < cPolicyMapping; i++)
	{
	    CERT_POLICY_MAPPING *pMap = &pPolicyMapping[i];
	    
	    if (NULL != pMap->pszIssuerDomainPolicy)
	    {
		LocalFree(pMap->pszIssuerDomainPolicy);
	    }
	    if (NULL != pMap->pszSubjectDomainPolicy)
	    {
		LocalFree(pMap->pszSubjectDomainPolicy);
	    }
	}
	LocalFree(pPolicyMapping);
    }
}


HRESULT
infGetPolicyMappingsSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN OUT DWORD *pcPolicyMapping,
    OPTIONAL OUT CERT_POLICY_MAPPING *pPolicyMapping)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszIssuer = NULL;
    WCHAR *pwszSubject = NULL;
    DWORD cPolicyMappingIn;
    DWORD cPolicyMapping = 0;

    cPolicyMappingIn = MAXDWORD;
    if (NULL != pPolicyMapping)
    {
	cPolicyMappingIn = *pcPolicyMapping;
    }
    *pcPolicyMapping = 0;

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    cPolicyMapping = 0;
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

    for (;;)
    {
	if (NULL != pwszIssuer)
	{
	    LocalFree(pwszIssuer);
	    pwszIssuer = NULL;
	}
	if (NULL != pwszSubject)
	{
	    LocalFree(pwszSubject);
	    pwszSubject = NULL;
	}
	hr = infGetCurrentKeyValue(
			    &InfContext,
			    pwszSection,
			    NULL,	// pwszKey
			    0,
			    FALSE,	// fLastValue
			    &pwszIssuer);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	if (!iswdigit(pwszIssuer[0]))
	{
	    if (0 != LSTRCMPIS(pwszIssuer, wszINFKEY_CRITICAL))
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpErrorStr(hr, error, "bad key", pwszIssuer);
	    }
	}
	else
	{
	    hr = myVerifyObjId(pwszIssuer);
	    _JumpIfErrorStr(hr, error, "myVerifyObjId", pwszIssuer);

	    hr = infGetCurrentKeyValue(
				&InfContext,
				pwszSection,
				pwszIssuer,
				1,
				TRUE,	// fLastValue
				&pwszSubject);
	    _JumpIfError(hr, error, "infGetCurrentKeyValue");

	    hr = myVerifyObjId(pwszSubject);
	    _JumpIfErrorStr(hr, error, "myVerifyObjId", pwszSubject);

	    if (NULL != pPolicyMapping)
	    {
		CERT_POLICY_MAPPING *pMap;

		if (cPolicyMappingIn <= cPolicyMapping)
		{
		    hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
		    _JumpError(hr, error, "*pcPolicyMapping");
		}

		pMap = &pPolicyMapping[cPolicyMapping];
		if (!ConvertWszToSz(&pMap->pszIssuerDomainPolicy, pwszIssuer, -1) ||
		    !ConvertWszToSz(&pMap->pszSubjectDomainPolicy, pwszSubject, -1))
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "ConvertWszToSz");
		}
	    }
	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"Map[%u]: %ws = %ws\n",
		cPolicyMapping,
		pwszIssuer,
		pwszSubject));

	    cPolicyMapping++;
	}
	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupFindNextLine", hr);
	    break;
	}
    }
    *pcPolicyMapping = cPolicyMapping;
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	INFSETERROR(hr, pwszSection, pwszIssuer, pwszSubject);
    }
    if (NULL != pwszIssuer)
    {
	LocalFree(pwszIssuer);
    }
    if (NULL != pwszSubject)
    {
	LocalFree(pwszSubject);
    }
    return(hr);
}


HRESULT
infGetPolicyMappings(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    OUT DWORD *pcPolicyMapping,
    OUT CERT_POLICY_MAPPING **ppPolicyMapping)
{
    HRESULT hr;
    DWORD cPolicyMapping = 0;
    CERT_POLICY_MAPPING *pPolicyMapping = NULL;

    *pcPolicyMapping = 0;
    *ppPolicyMapping = NULL;

    CSASSERT(NULL != hInf && INVALID_HANDLE_VALUE != hInf);

    cPolicyMapping = 0;
    hr = infGetPolicyMappingsSub(
			hInf,
			pwszSection,
			&cPolicyMapping,
			NULL);
    _JumpIfError3(
		hr,
		error,
		"infGetPolicyMappingsSub",
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

    *pcPolicyMapping = cPolicyMapping;
    pPolicyMapping = (CERT_POLICY_MAPPING *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
				cPolicyMapping * sizeof(*pPolicyMapping));
    if (NULL == pPolicyMapping)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = infGetPolicyMappingsSub(
			hInf,
			pwszSection,
			&cPolicyMapping,
			pPolicyMapping);
    _JumpIfError(hr, error, "infGetPolicyMappingsSub");

    CSASSERT(*pcPolicyMapping == cPolicyMapping);
    *ppPolicyMapping = pPolicyMapping;
    pPolicyMapping = NULL;
    hr = S_OK;

error:
    if (NULL != pPolicyMapping)
    {
	infFreePolicyMappings(*pcPolicyMapping, pPolicyMapping);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// infGetPolicyMappingSub -- fetch policy mapping extension from INF file
//
// [pwszSection]
// ; list of user defined policy mappings
// ; The first OID is for the Issuer Domain Policy, the second is for the
// ; Subject Domain Policy.  Each entry maps one Issuer Domain policy OID
// ; to a Subject Domain policy OID
//
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.87
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.89
//
// Returns: encoded policy mapping extension
//-------------------------------------------------------------------------

HRESULT
infGetPolicyMappingExtensionSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN char const *pszObjId,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_POLICY_MAPPINGS_INFO PolicyMappings;

    ZeroMemory(&PolicyMappings, sizeof(PolicyMappings));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infGetPolicyMappings(
		    hInf,
		    pwszSection,
		    &PolicyMappings.cPolicyMapping,
		    &PolicyMappings.rgPolicyMapping);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyMappings",
		pwszSection,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

    hr = infGetCriticalFlag(
			hInf,
			pwszSection,
			FALSE,
			&pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_POLICY_MAPPINGS,
		    &PolicyMappings,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, NULL, NULL);
    }
    pext->pszObjId = const_cast<char *>(pszObjId);	// on error, too!

    if (NULL != PolicyMappings.rgPolicyMapping)
    {
	infFreePolicyMappings(
			PolicyMappings.cPolicyMapping,
			PolicyMappings.rgPolicyMapping);
    }
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetPolicyMapping -- fetch policy mapping extension from INF file
//
// [PolicyMappingExtension]
// ; list of user defined policy mappings
// ; The first OID is for the Issuer Domain Policy, the second is for the
// ; Subject Domain Policy.  Each entry maps one Issuer Domain policy OID
// ; to a Subject Domain policy OID
//
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.87
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.89
//
// Returns: encoded policy mapping extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetPolicyMappingExtension;

HRESULT
myInfGetPolicyMappingExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyMappingExtensionSub(
				    hInf,
				    wszINFSECTION_POLICYMAPPINGS,
				    szOID_POLICY_MAPPINGS,
				    pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyMappingExtensionSub",
		wszINFSECTION_POLICYMAPPINGS,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetPolicyMappingExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetApplicationPolicyMapping -- fetch application policy mapping
// extension from INF file
//
// [ApplicationPolicyMappingExtension]
// ; list of user defined policy mappings
// ; The first OID is for the Issuer Domain Policy, the second is for the
// ; Subject Domain Policy.  Each entry maps one Issuer Domain policy OID
// ; to a Subject Domain policy OID
//
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.87
// 1.3.6.1.4.1.311.21.53 = 1.2.3.4.89
//
// Returns: encoded policy mapping extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetApplicationPolicyMappingExtension;

HRESULT
myInfGetApplicationPolicyMappingExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyMappingExtensionSub(
				    hInf,
				    wszINFSECTION_APPLICATIONPOLICYMAPPINGS,
				    szOID_APPLICATION_POLICY_MAPPINGS,
				    pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyMappingExtensionSub",
		wszINFSECTION_APPLICATIONPOLICYMAPPINGS,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetApplicationPolicyMappingExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// infGetPolicyConstraintsExtensionSub -- get policy constraints ext from INF
//
// [pwszSection]
// ; consists of two optional DWORDs
// ; They refer to the depth of the CA hierarchy that requires and inhibits
// ; Policy Mapping
// RequireExplicitPolicy = 3
// InhibitPolicyMapping = 5
//
// Returns: encoded policy constraints extension
//-------------------------------------------------------------------------

HRESULT
infGetPolicyConstraintsExtensionSub(
    IN HINF hInf,
    IN WCHAR const *pwszSection,
    IN char const *pszObjId,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    CERT_POLICY_CONSTRAINTS_INFO PolicyConstraints;
    WCHAR const *pwszKey = NULL;
    INFCONTEXT InfContext;
    static WCHAR const * const s_apwszKeys[] =
    {
	wszINFKEY_REQUIREEXPLICITPOLICY,
	wszINFKEY_INHIBITPOLICYMAPPING,
	wszINFKEY_CRITICAL,
	NULL
    };

    ZeroMemory(&PolicyConstraints, sizeof(PolicyConstraints));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			s_apwszKeys,
			TRUE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr2(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND);

    PolicyConstraints.fRequireExplicitPolicy = TRUE;
    pwszKey = wszINFKEY_REQUIREEXPLICITPOLICY;
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			pwszSection,
			pwszKey,
			1,
			TRUE,	// fLastValue
			&PolicyConstraints.dwRequireExplicitPolicySkipCerts);
    if (S_OK != hr)
    {
	if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "myInfGetNumericKeyValue");
	}
	_PrintErrorStr2(
		    hr,
		    "myInfGetNumericKeyValue",
		    wszINFKEY_REQUIREEXPLICITPOLICY,
		    hr);
	PolicyConstraints.dwRequireExplicitPolicySkipCerts = 0;
	PolicyConstraints.fRequireExplicitPolicy = FALSE;
    }

    PolicyConstraints.fInhibitPolicyMapping = TRUE;
    pwszKey = wszINFKEY_INHIBITPOLICYMAPPING;
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			pwszSection,
			pwszKey,
			1,
			TRUE,	// fLastValue
			&PolicyConstraints.dwInhibitPolicyMappingSkipCerts);
    if (S_OK != hr)
    {
	if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	{
	    _JumpError(hr, error, "myInfGetNumericKeyValue");
	}
	_PrintErrorStr2(
		    hr,
		    "myInfGetNumericKeyValue",
		    wszINFKEY_INHIBITPOLICYMAPPING,
		    hr);
	PolicyConstraints.dwInhibitPolicyMappingSkipCerts = 0;
	PolicyConstraints.fInhibitPolicyMapping = FALSE;
    }
    pwszKey = NULL;
    if (!PolicyConstraints.fRequireExplicitPolicy &&
	!PolicyConstraints.fInhibitPolicyMapping)
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "no policy constraints", hr);
    }

    hr = infGetCriticalFlag(
			hInf,
			pwszSection,
			FALSE,
			&pext->fCritical);
    _JumpIfError(hr, error, "infGetCriticalFlag");

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_POLICY_CONSTRAINTS,
		    &PolicyConstraints,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, pwszKey, NULL);
    }
    pext->pszObjId = const_cast<char *>(pszObjId);	// on error, too!

    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetPolicyConstraintsExtension -- get policy constraints ext from INF
//
// [PolicyConstraintsExtension]
// ; consists of two optional DWORDs
// ; They refer to the depth of the CA hierarchy that requires and inhibits
// ; Policy Mapping
// RequireExplicitPolicy = 3
// InhibitPolicyMapping = 5
//
// Returns: encoded policy constraints extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetPolicyConstraintsExtension;

HRESULT
myInfGetPolicyConstraintsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyConstraintsExtensionSub(
			    hInf,
			    wszINFSECTION_POLICYCONSTRAINTS,
			    szOID_POLICY_CONSTRAINTS,
			    pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyConstraintsExtensionSub",
		wszINFSECTION_POLICYCONSTRAINTS,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetPolicyConstraintsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetApplicationPolicyConstraintsExtension -- get application policy
// constraints extension from INF
//
// [ApplicationPolicyConstraintsExtension]
// ; consists of two optional DWORDs
// ; They refer to the depth of the CA hierarchy that requires and inhibits
// ; Policy Mapping
// RequireExplicitPolicy = 3
// InhibitPolicyMapping = 5
//
// Returns: encoded policy constraints extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetApplicationPolicyConstraintsExtension;

HRESULT
myInfGetApplicationPolicyConstraintsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;

    hr = infGetPolicyConstraintsExtensionSub(
			    hInf,
			    wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS,
			    szOID_APPLICATION_POLICY_CONSTRAINTS,
			    pext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infGetPolicyConstraintsExtensionSub",
		wszINFSECTION_APPLICATIONPOLICYCONSTRAINTS,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

error:
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetApplicationPolicyConstraintsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));
    return(hr);
}


//+------------------------------------------------------------------------
// myInfGetCrossCertDistributionPointsExtension -- fetch Cross CertDist Point
//	URLs from CAPolicy.inf
//
// [CrossCertificateDistributionPointsExtension]
// SyncDeltaTime = 24
// URL = http://CRLhttp.site.com/Public/MyCA.crt
// URL = ftp://CRLftp.site.com/Public/MyCA.crt
//
// Returns: encoded cross cert dist points extension
//-------------------------------------------------------------------------

FNMYINFGETEXTENSION myInfGetCrossCertDistributionPointsExtension;

HRESULT
myInfGetCrossCertDistributionPointsExtension(
    IN HINF hInf,
    OUT CERT_EXTENSION *pext)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    CROSS_CERT_DIST_POINTS_INFO ccdpi;
    CERT_ALT_NAME_INFO AltNameInfo;
    CERT_ALT_NAME_ENTRY *rgAltEntry = NULL;
    WCHAR const *pwsz;
    WCHAR *pwszzURL = NULL;
    DWORD i;
    WCHAR const *pwszKey = NULL;
    static WCHAR const * const s_apwszKeys[] =
      { wszINFKEY_CCDPSYNCDELTATIME, wszINFKEY_URL, wszINFKEY_CRITICAL, NULL };

    ZeroMemory(&ccdpi, sizeof(ccdpi));
    ZeroMemory(&AltNameInfo, sizeof(AltNameInfo));
    ZeroMemory(pext, sizeof(*pext));
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }

    hr = infSetupFindFirstLine(
			hInf,
			wszINFSECTION_CCDP,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			s_apwszKeys,
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr3(
		hr,
		error,
		"infSetupFindFirstLine",
		wszINFSECTION_CCDP,
		S_FALSE,
		(HRESULT) ERROR_LINE_NOT_FOUND);

    pwszKey = wszINFKEY_CCDPSYNCDELTATIME;
    hr = myInfGetNumericKeyValue(
			hInf,
			TRUE,			// fLog
			wszINFSECTION_CCDP,
			pwszKey,
			1,
			TRUE,	// fLastValue
			&ccdpi.dwSyncDeltaTime);
    if (S_OK != hr)
    {
	_PrintErrorStr2(
		    hr,
		    "myInfGetNumericKeyValue",
		    pwszKey,
		    ERROR_LINE_NOT_FOUND);
	ccdpi.dwSyncDeltaTime = 0;
    }
    pwszKey = wszINFKEY_URL;
    hr = myInfGetKeyList(
		hInf,
		wszINFSECTION_CCDP,
		pwszKey,
		NULL,	// apwszKeys
		&pext->fCritical,
		&pwszzURL);
    _JumpIfErrorStr3(
		hr,
		error,
		"myInfGetKeyList",
		pwszKey,
		ERROR_LINE_NOT_FOUND,
		S_FALSE);
    pwszKey = NULL;

    if (NULL != pwszzURL)
    {
	for (pwsz = pwszzURL; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    AltNameInfo.cAltEntry++;
        }
    }

    if (0 != AltNameInfo.cAltEntry)
    {
	ccdpi.cDistPoint = 1;
	ccdpi.rgDistPoint = &AltNameInfo;

	AltNameInfo.rgAltEntry = (CERT_ALT_NAME_ENTRY *) LocalAlloc(
		    LMEM_FIXED | LMEM_ZEROINIT,
		    AltNameInfo.cAltEntry * sizeof(AltNameInfo.rgAltEntry[0]));
	if (NULL == AltNameInfo.rgAltEntry)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	i = 0;
	for (pwsz = pwszzURL; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)
	{
	    AltNameInfo.rgAltEntry[i].pwszURL = const_cast<WCHAR *>(pwsz);
	    AltNameInfo.rgAltEntry[i].dwAltNameChoice = CERT_ALT_NAME_URL;
	    i++;
	}
	CSASSERT(i == AltNameInfo.cAltEntry);
    }

    if (!myEncodeObject(
		    X509_ASN_ENCODING,
		    X509_CROSS_CERT_DIST_POINTS,
		    &ccdpi,
		    0,
		    CERTLIB_USE_LOCALALLOC,
		    &pext->Value.pbData,
		    &pext->Value.cbData))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myEncodeObject");
    }

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, wszINFSECTION_CCDP, pwszKey, NULL);
    }
    pext->pszObjId = szOID_CROSS_CERT_DIST_POINTS;	// on error, too!

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetCrossCertDistributionPointsExtension hr=%x --> f=%d, cb=%x\n",
	hr,
	pext->fCritical,
	pext->Value.cbData));

    if (NULL != AltNameInfo.rgAltEntry)
    {
	LocalFree(AltNameInfo.rgAltEntry);
    }
    if (NULL != pwszzURL)
    {
	LocalFree(pwszzURL);
    }
    if (NULL != rgAltEntry)
    {
	LocalFree(rgAltEntry);
    }
    return(hr);
}




HRESULT
infAddKey(
    IN WCHAR const *pwszName,
    IN OUT DWORD *pcValues,
    IN OUT INFVALUES **prgInfValues,
    OUT INFVALUES **ppInfValues)
{
    HRESULT hr;
    INFVALUES *rgInfValues;
    WCHAR *pwszKeyT = NULL;
    
    hr = myDupString(pwszName, &pwszKeyT);
    _JumpIfError(hr, error, "myDupString");

    if (NULL == *prgInfValues)
    {
	CSASSERT(0 == *pcValues);
	rgInfValues = (INFVALUES *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT,
					    sizeof(**prgInfValues));
    }
    else
    {
	CSASSERT(0 != *pcValues);
	rgInfValues = (INFVALUES *) LocalReAlloc(
				*prgInfValues,
				(*pcValues + 1) * sizeof(**prgInfValues),
				LMEM_MOVEABLE | LMEM_ZEROINIT);
    }
    if (NULL == rgInfValues)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
		hr,
		error,
		NULL == *prgInfValues? "LocalAlloc" : "LocalReAlloc");
    }
    *prgInfValues = rgInfValues;
    *ppInfValues = &rgInfValues[*pcValues];
    (*pcValues)++;
    (*ppInfValues)->pwszKey = pwszKeyT;
    pwszKeyT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszKeyT)
    {
	LocalFree(pwszKeyT);
    }
    return(hr);
}


HRESULT
infAddValue(
    IN WCHAR const *pwszValue,
    IN OUT INFVALUES *pInfValues)
{
    HRESULT hr;
    WCHAR *pwszValueT = NULL;
    WCHAR **rgpwszValues = NULL;
    
    hr = myDupString(pwszValue, &pwszValueT);
    _JumpIfError(hr, error, "myDupString");

    if (NULL == pInfValues->rgpwszValues)
    {
	CSASSERT(0 == pInfValues->cValues);
	rgpwszValues = (WCHAR **) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(*pInfValues->rgpwszValues));
    }
    else
    {
	CSASSERT(0 != pInfValues->cValues);
	rgpwszValues = (WCHAR **) LocalReAlloc(
		pInfValues->rgpwszValues,
		(pInfValues->cValues + 1) * sizeof(*pInfValues->rgpwszValues),
		LMEM_MOVEABLE);
    }
    if (NULL == rgpwszValues)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(
	    hr,
	    error,
	    NULL == pInfValues->rgpwszValues? "LocalAlloc" : "LocalReAlloc");
    }
    pInfValues->rgpwszValues = rgpwszValues;
    pInfValues->rgpwszValues[pInfValues->cValues] = pwszValueT;
    pInfValues->cValues++;
    pwszValueT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszValueT)
    {
	LocalFree(pwszValueT);
    }
    return(hr);
}


VOID
myInfFreeSectionValues(
    IN DWORD cInfValues,
    IN OUT INFVALUES *rgInfValues)
{
    DWORD i;
    DWORD ival;
    INFVALUES *pInfValues;
    
    if (NULL != rgInfValues)
    {
	for (i = 0; i < cInfValues; i++)
	{
	    pInfValues = &rgInfValues[i];

	    if (NULL != pInfValues->pwszKey)
	    {
		LocalFree(pInfValues->pwszKey);
	    }
	    if (NULL != pInfValues->rgpwszValues)
	    {
		for (ival = 0; ival < pInfValues->cValues; ival++)
		{
		    if (NULL != pInfValues->rgpwszValues[ival])
		    {
			LocalFree(pInfValues->rgpwszValues[ival]);
		    }
		}
		LocalFree(pInfValues->rgpwszValues);
	    }
	}
	LocalFree(rgInfValues);
    }
}


//+------------------------------------------------------------------------
// myInfGetSectionValues -- fetch all section values from INF file
//
// [pwszSection]
// KeyName1 = KeyValue1a, KeyValue1b, ...
// KeyName2 = KeyValue2a, KeyValue2b, ...
// ...
// KeyNameN = KeyValueNa, KeyValueNb, ...
//
// Returns: array of key names and values
//-------------------------------------------------------------------------

HRESULT
myInfGetSectionValues(
    IN  HINF hInf,
    IN  WCHAR const *pwszSection,
    OUT DWORD *pcInfValues,
    OUT INFVALUES **prgInfValues)
{
    HRESULT hr;
    INFCONTEXT InfContext;
    WCHAR *pwszName = NULL;
    WCHAR *pwszValue = NULL;
    DWORD i;
    DWORD cInfValues = 0;
    INFVALUES *rgInfValues = NULL;
    INFVALUES *pInfValues;

    *pcInfValues = 0;
    *prgInfValues = NULL;
    myInfClearError();

    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    for (;;)
    {
	DWORD cValue;
	
	if (NULL != pwszName)
	{
	    LocalFree(pwszName);
	    pwszName = NULL;
	}
	hr = infGetCurrentKeyValue(
			    &InfContext,
			    pwszSection,
			    NULL,	// pwszKey
			    0,
			    FALSE,	// fLastValue
			    &pwszName);
	_JumpIfError(hr, error, "infGetCurrentKeyValue");

	//wprintf(L"%ws[0]:\n", pwszName);

	hr = infAddKey(pwszName, &cInfValues, &rgInfValues, &pInfValues);
	_JumpIfError(hr, error, "infAddKey");

	cValue = SetupGetFieldCount(&InfContext);
	if (0 == cValue)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    INFSETERROR(hr, pwszSection, pwszName, L"");
	    _JumpErrorStr(hr, error, "SetupGetFieldCount", pwszName);
	}
	for (i = 0; i < cValue; i++)
	{
	    if (NULL != pwszValue)
	    {
		LocalFree(pwszValue);
		pwszValue = NULL;
	    }
	    hr = infGetCurrentKeyValue(
				&InfContext,
				pwszSection,
				pwszName,
				i + 1,
				FALSE,	// fLastValue
				&pwszValue);
	    _JumpIfError(hr, error, "infGetCurrentKeyValue");

	    //wprintf(L"%ws[%u] = %ws\n", pwszName, i, pwszValue);

	    hr = infAddValue(pwszValue, pInfValues);
	    _JumpIfError(hr, error, "infAddValue");
	}

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintError2(hr, "SetupFindNextLine(end)", hr);
	    break;
	}
    }
    *pcInfValues = cInfValues;
    *prgInfValues = rgInfValues;
    rgInfValues = NULL;
    hr = S_OK;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, pwszSection, pwszName, pwszValue);
    }
    if (NULL != rgInfValues)
    {
	myInfFreeSectionValues(cInfValues, rgInfValues);
    }
    if (NULL != pwszName)
    {
	LocalFree(pwszName);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myInfGetSectionValues hr=%x --> c=%d\n",
	hr,
	*pcInfValues));
    return(hr);
}


HRESULT
myInfGetEnableKeyCounting(
    IN HINF hInf,
    OUT BOOL *pfValue)
{
    HRESULT hr;
    
    *pfValue = FALSE;
    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = myInfGetBooleanValue(
                hInf,
                wszINFSECTION_CERTSERVER,
                wszINFKEY_ENABLEKEYCOUNTING,
                TRUE,
                pfValue);
    _JumpIfError2(hr, error, "myDupString", ERROR_LINE_NOT_FOUND);

error:
    return(hr);
}


VOID
myInfFreeExtensions(
    IN DWORD cExt,
    IN CERT_EXTENSION *rgExt)
{
    if (NULL != rgExt)
    {
	DWORD i;

	for (i = 0; i < cExt; i++)
	{
	    if (NULL != rgExt[i].pszObjId)
	    {
		LocalFree(rgExt[i].pszObjId);
	    }
	    if (NULL != rgExt[i].Value.pbData)
	    {
		LocalFree(rgExt[i].Value.pbData);
	    }
	}
	LocalFree(rgExt);
    }
}


HRESULT
infBuildExtension(
    IN OUT INFCONTEXT *pInfContext,
    OPTIONAL OUT CERT_EXTENSION *pExt)
{
    HRESULT hr;
    WCHAR *pwszKey = NULL;
    char *pszObjId = NULL;
    WCHAR *pwszValue = NULL;
    BYTE *pbData = NULL;
    DWORD cbData;

    hr = infGetCurrentKeyValue(
			pInfContext,
			NULL,	// pwszSection
			NULL,	// pwszKey
			0,
			FALSE,	// fLastValue
			&pwszKey);
    _JumpIfError(hr, error, "infGetCurrentKeyValue");

    DBGPRINT((DBG_SS_CERTLIBI, "Element = %ws\n", pwszKey));

    if (0 == LSTRCMPIS(pwszKey, wszINFKEY_CRITICAL) ||
	0 == LSTRCMPIS(pwszKey, wszINFKEY_CONTINUE))
    {
	hr = S_FALSE;		// Skip this key
	_JumpError2(hr, error, "skip Critical/_continue_ key", hr);
    }
    if (!myConvertWszToSz(&pszObjId, pwszKey, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "myConvertWszToSz");
    }
    hr = myVerifyObjIdA(pszObjId);
    _JumpIfErrorStr(hr, error, "myVerifyObjIdA", pwszKey);

    DBGPRINT((DBG_SS_CERTLIBI, "OID = %hs\n", pszObjId));

    hr = infGetCurrentKeyValue(
			pInfContext,
			NULL,		// pwszSection
			pwszKey,
			1,
			TRUE,		// fLastValue
			&pwszValue);
    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", pwszKey);

    DBGPRINT((DBG_SS_CERTLIBI, "%ws = %ws\n", pwszKey, pwszValue));

    cbData = 0;
    if (L'\0' != *pwszValue)	// allow empty values
    {
	hr = myCryptStringToBinary(
			    pwszValue,
			    wcslen(pwszValue),
			    CRYPT_STRING_BASE64,
			    &pbData,
			    &cbData,
			    NULL,
			    NULL);
	_JumpIfErrorStr(hr, error, "myCryptStringToBinary", pwszKey);
    }

    if (NULL != pExt)
    {
	pExt->pszObjId = pszObjId;
	pExt->Value.pbData = pbData;
	pExt->Value.cbData = cbData;
	pszObjId = NULL;
	pbData = NULL;
    }
    hr = S_OK;

error:
    if (S_OK != hr && S_FALSE != hr)
    {
	INFSETERROR(hr, NULL, pwszKey, pwszValue);
    }
    if (NULL != pwszKey)
    {
	LocalFree(pwszKey);
    }
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pbData)
    {
	LocalFree(pbData);
    }
    return(hr);
}


HRESULT
myInfGetExtensions(
    IN HINF hInf,
    OUT DWORD *pcExt,
    OUT CERT_EXTENSION **ppExt)
{
    HRESULT hr;
    DWORD i;
    DWORD cExt;
    CERT_EXTENSION *rgExt = NULL;
    DWORD cCritical;
    INFCONTEXT InfContext;
    WCHAR *pwszValue = NULL;
    char *pszObjId = NULL;
    WCHAR *pwszObjIdKey = NULL;
    WCHAR const *pwszSection = wszINFSECTION_EXTENSIONS;
    WCHAR const *pwszKey = wszINFKEY_CRITICAL;
    DWORD j;
    
    *pcExt = 0;
    *ppExt = NULL;
    cExt = 0;
    if (NULL == hInf || INVALID_HANDLE_VALUE == hInf)
    {
	hr = E_HANDLE;
	_JumpError2(hr, error, "hInf", hr);
    }
    myInfClearError();
    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr2(
		hr,
		error,
		"infSetupFindFirstLine",
		pwszSection,
		ERROR_LINE_NOT_FOUND);

    for (i = 0; ; )
    {
	hr = infBuildExtension(&InfContext, NULL);
	if (S_FALSE != hr)
	{
	    _JumpIfErrorStr(hr, error, "infBuildExtension", pwszSection);

	    i++;
	}

	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
	    break;
	}
    }

    cExt = i;
    rgExt = (CERT_EXTENSION *) LocalAlloc(
				    LMEM_FIXED | LMEM_ZEROINIT,
				    cExt * sizeof(rgExt[0]));
    if (NULL == rgExt)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			NULL,	// pwszKey
			FALSE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _JumpIfErrorStr(hr, error, "infSetupFindFirstLine", pwszSection);

    for (i = 0; ; )
    {
	// handle one URL or text message

	hr = infBuildExtension(&InfContext, &rgExt[i]);
	if (S_FALSE != hr)
	{
	    _JumpIfErrorStr(hr, error, "infBuildExtension", pwszSection);

	    for (j = 0; j < i; j++)
	    {
		if (0 == strcmp(rgExt[j].pszObjId, rgExt[i].pszObjId))
		{
		    if (!myConvertSzToWsz(&pwszObjIdKey, rgExt[i].pszObjId, -1))
		    {
			_PrintError(E_OUTOFMEMORY, "myConvertSzToWsz");
		    }
		    hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
		    INFSETERROR(hr, pwszSection, pwszObjIdKey, NULL);
		    _JumpErrorStr(hr, error, "infBuildExtension", pwszObjIdKey);
		}
	    }
	    i++;
	}
	if (!SetupFindNextLine(&InfContext, &InfContext))
	{
	    hr = myHLastError();
	    _PrintErrorStr2(hr, "SetupFindNextLine", pwszSection, hr);
	    break;
	}
    }
    CSASSERT(i == cExt);

    hr = infSetupFindFirstLine(
			hInf,
			pwszSection,
			pwszKey,
			TRUE,	// fUniqueKey
			0,	// cValueMax
			NULL,	// apwszKeys
			FALSE,	// fUniqueValidKeys
			&InfContext);
    _PrintIfErrorStr2(
		hr,
		"infSetupFindFirstLine",
		pwszKey,
		ERROR_LINE_NOT_FOUND);
    if (S_OK != hr)
    {
	if ((HRESULT) ERROR_LINE_NOT_FOUND != hr)
	{
	    INFSETERROR(hr, pwszSection, pwszKey, NULL);
	    _JumpErrorStr(hr, error, "infSetupFindFirstLine", pwszKey);
	}
    }
    else
    {
	cCritical = SetupGetFieldCount(&InfContext);
	for (i = 1; i <= cCritical; i++)
	{
	    if (NULL != pwszValue)
	    {
		LocalFree(pwszValue);
		pwszValue = NULL;
	    }
	    if (NULL != pszObjId)
	    {
		LocalFree(pszObjId);
		pszObjId = NULL;
	    }
	    hr = infGetCurrentKeyValue(
				&InfContext,
				NULL,		// pwszSection
				pwszKey,
				i,
				FALSE,		// fLastValue
				&pwszValue);
	    _JumpIfErrorStr(hr, error, "infGetCurrentKeyValue", pwszKey);

	    if (!myConvertWszToSz(&pszObjId, pwszValue, -1))
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "myConvertWszToSz");
	    }
	    for (j = 0; j < cExt; j++)
	    {
		if (NULL != rgExt[j].Value.pbData &&
		    0 != rgExt[j].Value.cbData &&
		    0 == strcmp(rgExt[j].pszObjId, pszObjId))
		{
		    if (rgExt[j].fCritical)
		    {
			hr = HRESULT_FROM_WIN32(RPC_S_ENTRY_ALREADY_EXISTS);
			INFSETERROR(hr, pwszSection, pwszKey, pwszValue);
			_JumpErrorStr(hr, error, "duplicate OID", pwszValue);
		    }
		    rgExt[j].fCritical = TRUE;
		    break;
		}
	    }
	    if (j == cExt)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
		INFSETERROR(hr, pwszSection, pwszKey, pwszValue);
		_JumpErrorStr(hr, error, "extraneous OID", pwszValue);
	    }
	}
    }
    *pcExt = cExt;
    *ppExt = rgExt;
    rgExt = NULL;
    hr = S_OK;

error:
    if (S_OK != hr && (HRESULT) ERROR_LINE_NOT_FOUND != hr)
    {
	INFSETERROR(hr, pwszSection, NULL, NULL);
    }
    if (NULL != pwszValue)
    {
	LocalFree(pwszValue);
    }
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    if (NULL != pwszObjIdKey)
    {
	LocalFree(pwszObjIdKey);
    }
    myInfFreeExtensions(cExt, rgExt);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\keygen2.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crypt.cpp
//
// Contents:    Cert Server wrapper routines
//
// History:     17-Oct-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>

#define CRYPT32_SP3_ONLY

#ifdef CRYPT32_SP3_ONLY

#ifdef __cplusplus
extern "C" {
#endif
#include "keygen.h"
#ifdef __cplusplus
}
#endif

#include "crypttls.h"
#include "ossconv.h"
#include "ossutil.h"

// All the *pInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  (((Len) + 7) & ~7)

HCRYPTOSSGLOBAL hOssGlobal;


//+-------------------------------------------------------------------------
//  Function:  GetPog
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized OssGlobal data structure
//--------------------------------------------------------------------------

__inline OssGlobal *
GetPog(VOID)
{
    return(I_CryptGetOssGlobal(hOssGlobal));
}


HRESULT
HError(VOID)
{
    HRESULT hr;

    hr = GetLastError();
    if (hr <= 0xffff)
    {
        hr = HRESULT_FROM_WIN32(hr);
    }

    if (!FAILED(hr))
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return(hr);
}


VOID
OssX509GetIA5ConvertedToUnicode(
    IN IA5STRING *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT LPWSTR *ppwsz,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssUtilGetIA5StringConvertedToUnicode(
				    pOss->length,
				    pOss->value,
				    dwFlags,
				    ppwsz,
				    ppbExtra,
				    plRemainExtra);
}


VOID
OssX509GetObjectId(
    IN ObjectID *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CHAR **pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    DWORD cb;
    DWORD cbExtra;
    char ach[MAX_PATH];
    LONG lRemainExtra;

    cb = sizeof(ach);
    if (!OssConvFromObjectIdentifier(pOss->count, pOss->value, ach, &cb))
    {
	goto error;
    }
    CSASSERT(strlen(ach) + 1 == cb);
    cbExtra = INFO_LEN_ALIGN(cb);

    lRemainExtra = *plRemainExtra;
    lRemainExtra -= cbExtra;
    if (0 <= lRemainExtra)
    {
	*pInfo = (char *) *ppbExtra;
	CopyMemory(*pInfo, ach, cb);
	*ppbExtra += cbExtra;
    }
    *plRemainExtra = lRemainExtra;

error:
    ;
}


__inline VOID
OssX509GetAlgorithmParameters(
    IN OpenType *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CRYPT_OBJID_BLOB *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssUtilGetOctetString(
		    pOss->length,
		    (BYTE *) pOss->encoded,
		    dwFlags,
		    pInfo,
		    ppbExtra,
		    plRemainExtra);
}


VOID
OssX509GetAlgorithm(
    IN AlgorithmIdentifier *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CRYPT_ALGORITHM_IDENTIFIER *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    if (0 <= *plRemainExtra)
    {
	ZeroMemory((VOID *) pInfo, sizeof(*pInfo));
    }
    OssX509GetObjectId(
		    &pOss->algorithm,
		    dwFlags,
		    &pInfo->pszObjId,
		    ppbExtra,
		    plRemainExtra);

    if (pOss->bit_mask & parameters_present)
    {
	OssX509GetAlgorithmParameters(
			    &pOss->parameters,
			    dwFlags,
			    &pInfo->Parameters,
			    ppbExtra,
			    plRemainExtra);
    }
}


__inline VOID
OssX509GetPublicKeyBlob(
    IN BITSTRING const *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CRYPT_BIT_BLOB *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssUtilGetBitString(
		    pOss->length,
		    pOss->value,
		    dwFlags,
		    pInfo,
		    ppbExtra,
		    plRemainExtra);
}


VOID
OssX509GetPublicKeyInfo(
    IN SubjectPublicKeyInfo *pOss,
    IN DWORD dwFlags,
    OPTIONAL OUT CERT_PUBLIC_KEY_INFO *pInfo,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    OssX509GetAlgorithm(
		    &pOss->algorithm,
		    dwFlags,
		    &pInfo->Algorithm,
		    ppbExtra,
		    plRemainExtra);

    OssX509GetPublicKeyBlob(
		    &pOss->subjectPublicKey,
		    dwFlags,
		    &pInfo->PublicKey,
		    ppbExtra,
		    plRemainExtra);
}
//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------

__inline BOOL
OssInfoDecodeAndAlloc(
    IN int pdunum,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded,
    OUT VOID **ppOssInfo)
{
    return(OssUtilDecodeAndAllocInfo(
				GetPog(),
				pdunum,
				pbEncoded,
				cbEncoded,
				ppOssInfo));
}


//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the OssX509*Decode() functions.
//--------------------------------------------------------------------------

VOID
OssInfoFree(
    IN int pdunum,
    IN VOID *pOssInfo)
{
    if (NULL != pOssInfo)
    {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        OssUtilFreeInfo(GetPog(), pdunum, pOssInfo);
        SetLastError(dwErr);
    }
}


//+-------------------------------------------------------------------------
//  KeyGen Info Decode (OSS X509)
//--------------------------------------------------------------------------

BOOL
DecodeKeyGen(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN DWORD dwFlags,
    OUT VOID *pInfo,
    IN OUT DWORD *pcbInfo)
{
    BOOL fResult = FALSE;
    HRESULT hr;
    SignedPublicKeyAndChallenge *pOssInfo = NULL;
    CERT_KEYGEN_REQUEST_INFO *pcgi;
    BYTE *pbExtra;
    LONG lRemainExtra;
    LONG lAlignExtra;

    if (pInfo == NULL)
    {
        *pcbInfo = 0;
    }
    if (0 == hOssGlobal)
    {
	hOssGlobal = I_CryptInstallOssGlobal(keygen, 0, NULL);
	if (0 == hOssGlobal)
	{
	    goto error;
	}
    }
    if (!OssInfoDecodeAndAlloc(
			    SignedPublicKeyAndChallenge_PDU,
			    pbEncoded,
			    cbEncoded,
			    (VOID **) &pOssInfo))
    {
	hr = HError();
	printf("OssInfoDecodeAndAlloc returned %u (%x)\n", hr, hr);
        goto error;
    }

    lRemainExtra = (LONG) *pcbInfo - INFO_LEN_ALIGN(sizeof(*pcgi));
    pbExtra = NULL;

    // for lRemainExtra < 0, LENGTH_ONLY calculation

    if (0 <= lRemainExtra)
    {
	pcgi = (CERT_KEYGEN_REQUEST_INFO *) pInfo;

        // Default all optional fields to zero
        ZeroMemory((VOID *) pcgi, sizeof(*pcgi));
	pcgi->dwVersion = 1;

        pbExtra = (BYTE *) pcgi + INFO_LEN_ALIGN(sizeof(*pcgi));
    }

    OssX509GetPublicKeyInfo(
			&pOssInfo->publicKeyAndChallenge.spki,
			dwFlags,
			&pcgi->SubjectPublicKeyInfo,
			&pbExtra,
			&lRemainExtra);

    OssX509GetIA5ConvertedToUnicode(
			&pOssInfo->publicKeyAndChallenge.challenge,
			dwFlags,
			&pcgi->pwszChallengeString,
			&pbExtra,
			&lRemainExtra);

    if (0 <= lRemainExtra)
    {
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    }
    else
    {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (NULL != pInfo)
	{
	    SetLastError(HRESULT_FROM_WIN32(ERROR_MORE_DATA));
	    goto error;
	}
    }
    fResult = TRUE;

error:
    OssInfoFree(SignedPublicKeyAndChallenge_PDU, pOssInfo);
    if (!fResult)
    {
	*pcbInfo = 0;
    }
    return(fResult);
}
#endif


BOOL
myDecodeKeyGenRequest(
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OUT CERT_KEYGEN_REQUEST_INFO **ppKeyGenRequest,
    OUT DWORD *pcbKeyGenRequest)
{
    BOOL fOk = FALSE;

#ifdef CRYPT32_SP3_ONLY
    *ppKeyGenRequest = NULL;
    *pcbKeyGenRequest = 0;

    if (!DecodeKeyGen(
		pbRequest,
		cbRequest,
		0,				// dwFlags
		NULL,
		pcbKeyGenRequest))
    {
	goto error;
    }
    *ppKeyGenRequest = (CERT_KEYGEN_REQUEST_INFO *) LocalAlloc(LMEM_FIXED, *pcbKeyGenRequest);
    if (NULL == *ppKeyGenRequest)
    {
	_PrintError(E_OUTOFMEMORY, "LocalAlloc(KeyGenRequest)");
	SetLastError(E_OUTOFMEMORY);
	goto error;
    }

    if (!DecodeKeyGen(
		pbRequest,
		cbRequest,
		0,				// dwFlags
		*ppKeyGenRequest,
		pcbKeyGenRequest))
    {
	goto error;
    }
#else
    if (!myDecodeObject(
		    X509_ASN_ENCODING,
		    X509_KEYGEN_REQUEST_TO_BE_SIGNED,
		    pbRequest,
		    cbRequest,
		    (VOID **) ppKeyGenRequest,
		    pcbKeyGenRequest))
    {
	err = myHLastError();
	_JumpError(err, error, "myDecodeObject");
    }
#endif
    fOk = TRUE;

error:
    return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\keygen.h ===
/***************************************************/
/* Copyright (C) Microsoft Corporation, 1996 - 1999*/
/***************************************************/
/* Abstract syntax: keygen */
/* Created: Mon Jan 27 13:51:10 1997 */
/* ASN.1 compiler version: 4.2 Beta B */
/* Target operating system: Windows NT 3.5 or later/Windows 95 */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -listingfile keygen.lst -noshortennames -1990 -noconstraints
 */

#ifndef OSS_keygen
#define OSS_keygen

#include "asn1hdr.h"
#include "asn1code.h"

#define          RSAPublicKey_PDU 1
#define          SubjectPublicKeyInfo_PDU 2
#define          SignedContent_PDU 3
#define          SignedPublicKeyAndChallenge_PDU 4

typedef struct ObjectID {
    unsigned short  count;
    unsigned long   value[16];
} ObjectID;

typedef struct HUGEINTEGER {
    unsigned int    length;
    unsigned char   *value;
} HUGEINTEGER;

typedef struct BITSTRING {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} BITSTRING;

typedef struct IA5STRING {
    unsigned int    length;
    char            *value;
} IA5STRING;

typedef struct AlgorithmIdentifier {
    unsigned char   bit_mask;
#       define      parameters_present 0x80
    ObjectID        algorithm;
    OpenType        parameters;  /* optional */
} AlgorithmIdentifier;

typedef struct RSAPublicKey {
    HUGEINTEGER     modulus;
    int             publicExponent;
} RSAPublicKey;

typedef struct SubjectPublicKeyInfo {
    AlgorithmIdentifier algorithm;
    BITSTRING       subjectPublicKey;
} SubjectPublicKeyInfo;

typedef struct SignedContent {
    OpenType        toBeSigned;
    AlgorithmIdentifier algorithm;
    BITSTRING       signature;
} SignedContent;

typedef struct PublicKeyAndChallenge {
    SubjectPublicKeyInfo spki;
    IA5STRING       challenge;
} PublicKeyAndChallenge;

typedef struct _bit1 {
    unsigned int    length;  /* number of significant bits */
    unsigned char   *value;
} _bit1;

typedef struct SignedPublicKeyAndChallenge {
    PublicKeyAndChallenge publicKeyAndChallenge;
    AlgorithmIdentifier signatureAlgorithm;
    _bit1           signature;
} SignedPublicKeyAndChallenge;


extern void *keygen;    /* encoder-decoder control table */
#endif /* OSS_keygen */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\log.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       log.cpp
//
//  Contents:   cert server logging
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csprop.h"
#include "initcert.h"
#include "certmsg.h"
#include "clibres.h"

#define __dwFILE__	__dwFILE_CERTLIB_LOG_CPP__

FILE *g_pfLog = NULL;
BOOL g_fLogClosed = FALSE;
BOOL g_fInitLogCritSecEnabled = FALSE;
extern FNLOGMESSAGEBOX *g_pfnLogMessagBox = NULL;
extern HINSTANCE g_hInstance;

CRITICAL_SECTION g_InitLogCriticalSection;


VOID
fputsStripCRA(
    IN char const *psz,
    IN FILE *pf)
{
    while ('\0' != *psz)
    {
	DWORD i;

	i = strcspn(psz, "\r");
	if (0 != i)
	{
	    fprintf(pf, "%.*hs", i, psz);
	    psz += i;
	}
	if ('\r' == *psz)
	{
	    psz++;
	}
    }
}


VOID
fputsUTF8(
    IN FILE *pf,
    IN WCHAR const *pwc,
    IN DWORD cwc)
{
    CHAR *psz;

    if (myConvertWszToUTF8(&psz, pwc, cwc))
    {
	fprintf(pf, "%hs", psz);
	LocalFree(psz);
    }
    else
    {
	fprintf(pf, "%.*ws", cwc, pwc);
    }
}


VOID
fputsStripCRW(
    IN WCHAR const *pwsz,
    IN FILE *pf)
{
    while (L'\0' != *pwsz)
    {
	DWORD i;

	i = wcscspn(pwsz, L"\r");
	if (0 != i)
	{
	    fputsUTF8(pf, pwsz, i);
	    pwsz += i;
	}
	if ('\r' == *pwsz)
	{
	    pwsz++;
	}
    }
}


VOID
csiLog(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN HRESULT hrMsg,
    IN UINT idMsg,
    OPTIONAL IN WCHAR const *pwsz1,
    OPTIONAL IN WCHAR const *pwsz2,
    OPTIONAL IN DWORD const *pdw)
{
    HRESULT hr;
    WCHAR const *pwszMsg = NULL; // don't free
    WCHAR const *pwszMsgNoCache = NULL;
    WCHAR const *pwszMessageText = NULL;
    WCHAR awchr[cwcHRESULTSTRING];
    BOOL fCritSecEntered = FALSE;
    
    if (0 != idMsg)
    {
	if (g_fLogClosed)
	{
	    pwszMsgNoCache = myLoadResourceStringNoCache(g_hInstance, idMsg);
	    pwszMsg = pwszMsgNoCache;
	}
	else
	{
	    pwszMsg = myLoadResourceString(idMsg);
	}
	if (NULL == pwszMsg)
	{
	    hr = myHLastError();
	    _PrintError(hr, "myLoadResourceString");
	}
    }
    if (g_fInitLogCritSecEnabled)
    {
	EnterCriticalSection(&g_InitLogCriticalSection);
	fCritSecEntered = TRUE;
    }
    if (NULL != g_pfLog)
    {
	fprintf(g_pfLog, "%u.%u.%u", dwFile, dwLine, idMsg);
	if (NULL != pwszMsg)
	{
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwszMsg, g_pfLog);
	}
	if (NULL != pwsz1)
	{
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwsz1, g_pfLog);
	}
	if (NULL != pwsz2)
	{
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwsz2, g_pfLog);
	}
	if (NULL != pdw)
	{
	    fprintf(g_pfLog, ": 0x%x(%d)", *pdw, *pdw);
	}
	if (hrMsg != S_OK)
	{
	    pwszMessageText = myGetErrorMessageText(hrMsg, TRUE);
	    if (NULL == pwszMessageText)
	    {
		pwszMessageText = myHResultToStringRaw(awchr, hrMsg);
	    }
	    fprintf(g_pfLog, ": ");
	    fputsStripCRW(pwszMessageText, g_pfLog);
	}
	fprintf(g_pfLog, "\n");
	fflush(g_pfLog);
    }

//error:
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
    if (NULL != pwszMsgNoCache)
    {
	LocalFree(const_cast<WCHAR *>(pwszMsgNoCache));
    }
    if (NULL != pwszMessageText && awchr != pwszMessageText)
    {
	LocalFree(const_cast<WCHAR *>(pwszMessageText));
    }
}


VOID
csiLogFileVersion(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg,
    IN WCHAR const *pwszFile,
    IN char const *pszVersion)
{
    HRESULT hr;
    WCHAR *pwszVersion = NULL;
    WCHAR const*pwsz;

    hr = myGetColumnDisplayName(wszPROPCERTCLIDLL_VERSION, &pwsz);
    _PrintIfErrorStr(hr, "myGetColumnDisplayName", wszPROPCERTCLIDLL_VERSION);
    csiLog(dwFile, dwLine, hr, idMsg, L"certcli.dll", pwsz, NULL);

    hr = S_OK;
    if (!myConvertSzToWsz(&pwszVersion, pszVersion, -1))
    {
       hr = E_OUTOFMEMORY;
       _PrintError(hr, "myConvertSzToWsz");
    }
    csiLog(dwFile, dwLine, hr, idMsg, pwszFile, pwszVersion, NULL);

//error:
    if (NULL != pwszVersion)
    {
	LocalFree(pwszVersion);
    }
}


VOID
csiLogTime(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg)
{
    HRESULT hr;
    WCHAR *pwszDate = NULL;
    SYSTEMTIME st;
    FILETIME ft;

    GetSystemTime(&st);
    if (!SystemTimeToFileTime(&st, &ft))
    {
	hr = myHLastError();
	_PrintError(hr, "SystemTimeToFileTime");
    }
    else
    {
	hr = myGMTFileTimeToWszLocalTime(&ft, TRUE, &pwszDate);
	_PrintIfError(hr, "myGMTFileTimeToWszLocalTime");
    }

    csiLog(dwFile, dwLine, S_OK, idMsg, pwszDate, NULL, NULL);

//error:
    if (NULL != pwszDate)
    {
	LocalFree(pwszDate);
    }
}


VOID
csiLogDWord(
    IN DWORD dwFile,
    IN DWORD dwLine,
    IN UINT idMsg,
    IN DWORD dwVal)
{
    csiLog(dwFile, dwLine, S_OK, idMsg, NULL, NULL, &dwVal);
}


FNLOGSTRING csiLogString;

VOID
csiLogString(
    IN char const *psz)
{
    BOOL fCritSecEntered = FALSE;

    if (NULL != g_pfLog)
    {
	if (g_fInitLogCritSecEnabled)
	{
	    EnterCriticalSection(&g_InitLogCriticalSection);
	    fCritSecEntered = TRUE;
	}
	fputsStripCRA(psz, g_pfLog);
	fflush(g_pfLog);
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
}


FNLOGMESSAGEBOX csiLogMessagBox;

VOID
csiLogMessagBox(
    IN HRESULT hrMsg,
    IN UINT idMsg,
    IN WCHAR const *pwszTitle,
    IN WCHAR const *pwszMessage)
{
    // Use file number 0 and the passed idMsg as the line number.
    
    csiLog(0, idMsg, hrMsg, IDS_ILOG_MESSAGEBOX, pwszTitle, pwszMessage, NULL);
}


VOID
csiLogClose()
{
    BOOL fCritSecEntered = FALSE;
    BOOL fDelete;
    
    g_fLogClosed = TRUE;
    if (NULL != g_pfLog)
    {
	CSILOGTIME(IDS_ILOG_END);
    }
    if (g_fInitLogCritSecEnabled)
    {
	EnterCriticalSection(&g_InitLogCriticalSection);
	fCritSecEntered = TRUE;
    }
    if (NULL != g_pfLog)
    {
	fclose(g_pfLog);
	g_pfLog = NULL;
    }
    fDelete = FALSE;
    if (fCritSecEntered)
    {
	if (g_fInitLogCritSecEnabled)
	{
	    g_fInitLogCritSecEnabled = FALSE;
	    fDelete = TRUE;
	}
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
    if (fDelete)
    {
	DeleteCriticalSection(&g_InitLogCriticalSection);
    }
}


char const szHeader[] = "\n========================================================================\n";

VOID
csiLogOpen(
    IN char const *pszFile)
{
    HRESULT hr;
    UINT cch;
    char aszLogFile[MAX_PATH];
    BOOL fAppend = FALSE;
    BOOL fOk = FALSE;
    BOOL fCritSecEntered = FALSE;

    __try
    {
	if (!g_fInitLogCritSecEnabled)
	{
	    InitializeCriticalSection(&g_InitLogCriticalSection);
	    g_fInitLogCritSecEnabled = TRUE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (g_fInitLogCritSecEnabled)
    {
	EnterCriticalSection(&g_InitLogCriticalSection);
	fCritSecEntered = TRUE;
    }
    if ('+' == *pszFile)
    {
	pszFile++;
	fAppend = TRUE;
    }
    cch = GetWindowsDirectoryA(aszLogFile, ARRAYSIZE(aszLogFile));
    if (0 != cch)
    {
	if (L'\\' != aszLogFile[cch - 1])
	{
	    strcat(aszLogFile, "\\");
	}
	strcat(aszLogFile, pszFile);

	for (;;)
	{
	    g_pfLog = fopen(aszLogFile, fAppend? "at" : "wt");
	    if (NULL == g_pfLog)
	    {
		_PrintError(E_FAIL, "fopen(Log)");
	    }
	    else
	    {
		if (fAppend)
		{
		    if (0 == fseek(g_pfLog, 0L, SEEK_END) &&
			CBLOGMAXAPPEND <= ftell(g_pfLog))
		    {
			fclose(g_pfLog);
			g_pfLog = NULL;
			fAppend = FALSE;
			continue;
		    }
		    fwrite(szHeader, SZARRAYSIZE(szHeader), 1, g_pfLog);
		}
		fOk = TRUE;
	    }
	    break;
	}
    }
    if (fCritSecEntered)
    {
	LeaveCriticalSection(&g_InitLogCriticalSection);
    }
    if (fOk)
    {
	CSILOGTIME(IDS_ILOG_BEGIN);
	DbgLogStringInit(csiLogString);
	CSASSERT(NULL == g_pfnLogMessagBox);
	g_pfnLogMessagBox = csiLogMessagBox;
    }

//error:
    ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\manage.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        manage.cpp
//
// Contents:    Cert Server Policy & Exit manage module callouts
//
// History:     10-Sept-98       mattt created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__      __dwFILE_CERTLIB_MANAGE_CPP__


//+-------------------------------------------------------------------------
// IManageModule dispatch support

//+------------------------------------
// GetProperty method:

OLECHAR *managemodule_apszGetProperty[] = {
    TEXT("GetProperty"),
    TEXT("strConfig"),
    TEXT("strStorageLocation"),
    TEXT("strPropertyName"),
    TEXT("Flags"),
};

//+------------------------------------
// SetProperty method:

OLECHAR *managemodule_apszSetProperty[] = {
    TEXT("SetProperty"),
    TEXT("strConfig"),
    TEXT("strStorageLocation"),
    TEXT("strPropertyName"),
    TEXT("Flags"),
    TEXT("pvarProperty"),
};

//+------------------------------------
// Configure method:

OLECHAR *managemodule_apszConfigure[] = {
    TEXT("Configure"),
    TEXT("strConfig"),
    TEXT("strStorageLocation"),
    TEXT("Flags"),
};



//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtManageModule[] =
{
#define MANAGEMODULE_GETPROPERTY            0
    DECLARE_DISPATCH_ENTRY(managemodule_apszGetProperty)

#define MANAGEMODULE_SETPROPERTY            1
    DECLARE_DISPATCH_ENTRY(managemodule_apszSetProperty)

#define MANAGEMODULE_CONFIGURE              2
    DECLARE_DISPATCH_ENTRY(managemodule_apszConfigure)
};
#define CMANAGEMODULEDISPATCH	(ARRAYSIZE(g_adtManageModule))

 
HRESULT
ManageModule_GetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG ColumnType,
    OUT VOID *pProperty)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strStorageLocation = NULL;
    BSTR strPropertyName = NULL;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiManage && NULL != pdiManage->pDispatchTable);

    hr = E_OUTOFMEMORY;
    strConfig = SysAllocString(pwszConfig);
    if (NULL == strConfig)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strStorageLocation = SysAllocString(pwszStorageLocation);
    if (NULL == strStorageLocation)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strPropertyName = SysAllocString(pwszPropertyName);
    if (NULL == strPropertyName)
    {
	_JumpError(hr, error, "SysAllocString");
    }

    switch (ColumnType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    __try
    {
	if (NULL != pdiManage->pDispatch)
	{
	    VARIANT avar[4];

	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
            avar[1].vt = VT_BSTR;
            avar[1].bstrVal = strStorageLocation;
            avar[2].vt = VT_BSTR;
            avar[2].bstrVal = strPropertyName;
            avar[3].vt = VT_I4;
            avar[3].lVal = dwFlags;

	    hr = DispatchInvoke(
			    pdiManage,
			    MANAGEMODULE_GETPROPERTY,
			    ARRAYSIZE(avar),
			    avar,
			    RetType,
                pProperty);
	    _JumpIfError(hr, error, "Invoke(GetName)");
	}
	else
	{
	    hr = ((ICertManageModule *) pdiManage->pUnknown)->GetProperty(
							strConfig,
							strStorageLocation,
							strPropertyName,
							dwFlags,
							&varResult);
	    _JumpIfError(hr, error, "ICertManageModule::GetProperty");

	    hr = DispatchGetReturnValue(&varResult, RetType, pProperty);
	    _JumpIfError2(hr, error, "DispatchGetReturnValue", CERTSRV_E_PROPERTY_EMPTY);
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "GetProperty: Exception");
	fException = TRUE;
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strStorageLocation)
    {
	SysFreeString(strStorageLocation);
    }
    if (NULL != strPropertyName)
    {
	SysFreeString(strPropertyName);
    }
    VariantClear(&varResult);
    return(hr);
}

HRESULT
ManageModule_SetProperty( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN WCHAR const *pwszPropertyName,
    IN DWORD dwFlags,
    IN LONG ColumnType,
    IN VOID* pProperty)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strStorageLocation = NULL;
    BSTR strPropertyName = NULL;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress;
    VARIANT varResult;

    CSASSERT(NULL != pdiManage && NULL != pdiManage->pDispatchTable);

    hr = E_OUTOFMEMORY;
    strConfig = SysAllocString(pwszConfig);
    if (NULL == strConfig)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strStorageLocation = SysAllocString(pwszStorageLocation);
    if (NULL == strStorageLocation)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strPropertyName = SysAllocString(pwszPropertyName);
    if (NULL == strPropertyName)
    {
	_JumpError(hr, error, "SysAllocString");
    }

    switch (ColumnType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    varResult.vt = VT_BSTR;
	    varResult.bstrVal = (BSTR) pProperty;
	    break;

	case PROPTYPE_DATE:
	    varResult.vt = VT_DATE;
	    CopyMemory(&varResult.date, pProperty, sizeof(DATE));
	    break;

	case PROPTYPE_LONG:
	    varResult.vt = VT_I4;
	    varResult.lVal = *(LONG *) pProperty;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    __try
    {
	if (NULL != pdiManage->pDispatch)
	{
	    VARIANT avar[5];

	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
            avar[1].vt = VT_BSTR;
            avar[1].bstrVal = strStorageLocation;
            avar[2].vt = VT_BSTR;
            avar[2].bstrVal = strPropertyName;
            avar[3].vt = VT_I4;
            avar[3].lVal = dwFlags;
            avar[4] = varResult;

	    hr = DispatchInvoke(
			    pdiManage,
			    MANAGEMODULE_SETPROPERTY,
			    ARRAYSIZE(avar),
			    avar,
			    0,
			    NULL);
	    _JumpIfError(hr, error, "Invoke(GetName)");
	}
	else
	{
	    hr = ((ICertManageModule *) pdiManage->pUnknown)->SetProperty(
							strConfig,
							strStorageLocation,
							strPropertyName,
							dwFlags,
							&varResult);
	    _JumpIfError(hr, error, "ICertManageModule::SetProperty");
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "SetProperty: Exception");
	fException = TRUE;
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strStorageLocation)
    {
	SysFreeString(strStorageLocation);
    }
    if (NULL != strPropertyName)
    {
	SysFreeString(strPropertyName);
    }
    //VariantInit(&varResult);    // this owned no memory 
    return(hr);
}




HRESULT 
ManageModule_Configure( 
    IN DISPATCHINTERFACE *pdiManage,
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszStorageLocation,
    IN DWORD dwFlags)
{
    HRESULT hr;
    BOOL fException = FALSE;
    ULONG_PTR ExceptionAddress;
    BSTR strConfig = NULL;
    BSTR strStorageLocation = NULL;

    CSASSERT(NULL != pdiManage && NULL != pdiManage->pDispatchTable);

    hr = E_OUTOFMEMORY;
    strConfig = SysAllocString(pwszConfig);
    if (NULL == strConfig)
    {
	_JumpError(hr, error, "SysAllocString");
    }
    strStorageLocation = SysAllocString(pwszStorageLocation);
    if (NULL == strStorageLocation)
    {
	_JumpError(hr, error, "SysAllocString");
    }

    __try
    {
	if (NULL != pdiManage->pDispatch)
	{
	    VARIANT avar[3];

	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
            avar[1].vt = VT_BSTR;
            avar[1].bstrVal = strStorageLocation;
            avar[2].vt = VT_I4;
            avar[2].lVal = dwFlags;

	    hr = DispatchInvoke(
			    pdiManage,
			    MANAGEMODULE_CONFIGURE,
			    ARRAYSIZE(avar),
			    avar,
			    0,
			    NULL);
	    _JumpIfError(hr, error, "Invoke(Configure)");
	}
	else
	{
	    hr = ((ICertManageModule *) pdiManage->pUnknown)->Configure(
							    strConfig,
							    strStorageLocation,
							    dwFlags);
	    _JumpIfError(hr, error, "ICertManageModule::Configure");
	}
    }
    __except(
	    ExceptionAddress = (ULONG_PTR) (GetExceptionInformation())->ExceptionRecord->ExceptionAddress,
	    hr = myHEXCEPTIONCODE(),
	    EXCEPTION_EXECUTE_HANDLER)
    {
	_PrintError(hr, "Configure: Exception");
	fException = TRUE;
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strStorageLocation)
    {
	SysFreeString(strStorageLocation);
    }
    return(hr);
}


HRESULT
ManageModule_Init(
    IN DWORD Flags,
    IN TCHAR const *pszProgID,      // morph for difft instances of this class
    IN CLSID const *pclsid,		
    OUT DISPATCHINTERFACE *pdiManage)
{
    HRESULT hr;

    hr = DispatchSetup(
		Flags,
		CLSCTX_INPROC_SERVER,
		pszProgID, 
		pclsid,
		&IID_ICertManageModule,
		CMANAGEMODULEDISPATCH,
		g_adtManageModule,
		pdiManage);

    _JumpIfError(hr, error, "DispatchSetup");

    pdiManage->pDispatchTable = g_adtManageModule;

error:
    return(hr);
}


HRESULT
ManageModule_Init2(
    IN BOOL fIDispatch,
    IN ICertManageModule *pManage,
    OUT DISPATCHINTERFACE *pdiManage)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;

    pdiManage->pDispatchTable = NULL;
    pdiManage->pDispatch = NULL;
    pdiManage->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pManage->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CMANAGEMODULEDISPATCH,
			g_adtManageModule,
			pdiManage);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiManage->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pManage->AddRef();
	pdiManage->pUnknown = (IUnknown *) pManage;
	hr = S_OK;
    }
    pdiManage->pDispatchTable = g_adtManageModule;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ManageModule_Release(
    IN OUT DISPATCHINTERFACE *pdiManage)
{
    DispatchRelease(pdiManage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\ldap.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        ldap.cpp
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#undef LdapMapErrorToWin32
#include <winldap.h>
#define LdapMapErrorToWin32	Use_myHLdapError_Instead_Of_LdapMapErrorToWin32

#include <ntldap.h>

#include "csldap.h"
#include "certacl.h"
#include "certtype.h"
#include "cainfop.h"
#include "csber.h"
#include "tptrlist.h"

#define __dwFILE__	__dwFILE_CERTLIB_LDAP_CPP__


static CHAR s_sdBerValue[] = {
    BER_SEQUENCE,
    3 * sizeof(BYTE),		// three byte sequence
    BER_INTEGER,
    1 * sizeof(BYTE),		// of one-byte integer
    DACL_SECURITY_INFORMATION
	//OWNER_SECURITY_INFORMATION |
	//GROUP_SECURITY_INFORMATION
};

static LDAPControl s_se_info_control =
{
    LDAP_SERVER_SD_FLAGS_OID_W,
    { ARRAYSIZE(s_sdBerValue), s_sdBerValue },
    TRUE
};
LDAPControl *g_rgLdapControls[2] = { &s_se_info_control, NULL };


// Revocation templates

WCHAR const g_wszHTTPRevocationURLTemplate[] = // Fetch CRL via http:
    L"http://"
	wszFCSAPARM_SERVERDNSNAME
	L"/CertEnroll/"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CRLFILENAMESUFFIX
	wszFCSAPARM_CRLDELTAFILENAMESUFFIX
	L".crl";

WCHAR const g_wszFILERevocationURLTemplate[] = // Fetch CRL via file:
    L"file://\\\\"
	wszFCSAPARM_SERVERDNSNAME
	L"\\CertEnroll\\"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CRLFILENAMESUFFIX
	wszFCSAPARM_CRLDELTAFILENAMESUFFIX
	L".crl";

WCHAR const g_wszASPRevocationURLTemplate[] = // ASP revocation check via https:
    L"https://"
	wszFCSAPARM_SERVERDNSNAME
	L"/CertEnroll/nsrev_"
	wszFCSAPARM_SANITIZEDCANAME
	L".asp";

#define wszCDPDNTEMPLATE			\
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	wszFCSAPARM_CRLFILENAMESUFFIX		\
	L","					\
	L"CN="					\
	wszFCSAPARM_SERVERSHORTNAME		\
	L","					\
	L"CN=CDP,"				\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszzLDAPRevocationURLTemplate[] = // Fetch CRL via ldap:
    L"ldap:///"
	wszCDPDNTEMPLATE
	wszFCSAPARM_DSCRLATTRIBUTE
	L"\0";

// Publish CRL via ldap:
WCHAR const g_wszCDPDNTemplate[] = wszCDPDNTEMPLATE;


// AIA templates

WCHAR const g_wszHTTPIssuerCertURLTemplate[] = // Fetch CA Cert via http:
    L"http://"
	wszFCSAPARM_SERVERDNSNAME
	L"/CertEnroll/"
	wszFCSAPARM_SERVERDNSNAME
	L"_"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CERTFILENAMESUFFIX
	L".crt"
	L"\0";

WCHAR const g_wszFILEIssuerCertURLTemplate[] = // Fetch CA Cert via http:
    L"file://\\\\"
	wszFCSAPARM_SERVERDNSNAME
	L"\\CertEnroll\\"
	wszFCSAPARM_SERVERDNSNAME
	L"_"
	wszFCSAPARM_SANITIZEDCANAME
	wszFCSAPARM_CERTFILENAMESUFFIX
	L".crt"
	L"\0";

#define wszAIADNTEMPLATE \
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	L","					\
	L"CN=AIA,"				\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszzLDAPIssuerCertURLTemplate[] = // Fetch CA Cert via ldap:
    L"ldap:///"
	wszAIADNTEMPLATE
	wszFCSAPARM_DSCACERTATTRIBUTE
	L"\0";

// Publish CA Cert via ldap:
WCHAR const g_wszAIADNTemplate[] = wszAIADNTEMPLATE;


#define wszNTAUTHDNTEMPLATE \
    L"CN=NTAuthCertificates,"			\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszLDAPNTAuthURLTemplate[] = // Fetch NTAuth Certs via ldap:
    L"ldap:///"
	wszNTAUTHDNTEMPLATE
	wszFCSAPARM_DSCACERTATTRIBUTE;


#define wszROOTTRUSTDNTEMPLATE \
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	L","					\
	L"CN=Certification Authorities,"	\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszLDAPRootTrustURLTemplate[] = // Fetch Root Certs via ldap:
    L"ldap:///"
	wszROOTTRUSTDNTEMPLATE
	wszFCSAPARM_DSCACERTATTRIBUTE;


#define wszKRADNTEMPLATE \
    L"CN="					\
	wszFCSAPARM_SANITIZEDCANAMEHASH		\
	L","					\
	L"CN=KRA,"				\
	L"CN=Public Key Services,"		\
	L"CN=Services,"				\
	wszFCSAPARM_CONFIGDN

WCHAR const g_wszzLDAPKRACertURLTemplate[] = // Fetch KRA Cert via ldap:
    L"ldap:///"
	wszKRADNTEMPLATE
	wszFCSAPARM_DSKRACERTATTRIBUTE
	L"\0";

// Publish KRA Certs via ldap:
WCHAR const g_wszKRADNTemplate[] = wszKRADNTEMPLATE;


DWORD
myGetLDAPFlags()
{
    HRESULT hr;
    DWORD LDAPFlags;
    
    hr = myGetCertRegDWValue(NULL, NULL, NULL, wszREGLDAPFLAGS, &LDAPFlags);
    _PrintIfErrorStr2(
		hr,
		"myGetCertRegDWValue",
		wszREGLDAPFLAGS,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    if (S_OK != hr)
    {
	LDAPFlags = 0;
    }
    return(LDAPFlags);
}


//+--------------------------------------------------------------------------
//
// Routine Description:
//    This routine simply queries the operational attributes for the
//    domaindn and configdn.
//    
//    The strings returned by this routine must be freed by the caller
//    using SysFreeString
//
// Parameters:
//    pld -- a valid handle to an ldap session
//    pstrDomainDN -- a pointer to a string to be allocated in this routine
//    pstrConfigDN -- a pointer to a string to be allocated in this routine
//
// Return Values:
//    HRESULT for operation error.
//    
//---------------------------------------------------------------------------

HRESULT 
myGetAuthoritativeDomainDn(
    IN LDAP *pld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN)
{
    HRESULT hr;
    LDAPMessage *pSearchResult = NULL;
    LDAPMessage *pEntry;
    LDAP_TIMEVAL timeval;
    WCHAR *pwszAttrName;
    BerElement *pber;
    WCHAR **rgpwszValues;
    WCHAR *apwszAttrArray[3];
    WCHAR *pwszDefaultNamingContext = LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W;
    WCHAR *pwszConfigurationNamingContext = LDAP_OPATT_CONFIG_NAMING_CONTEXT_W;
    BSTR strDomainDN = NULL;
    BSTR strConfigDN = NULL;

    // Set the OUT parameters to NULL

    if (NULL != pstrConfigDN)
    {
        *pstrConfigDN = NULL;
    }
    if (NULL != pstrDomainDN)
    {
        *pstrDomainDN = NULL;
    }

    // Query for the ldap server oerational attributes to obtain the default
    // naming context.

    apwszAttrArray[0] = pwszDefaultNamingContext;
    apwszAttrArray[1] = pwszConfigurationNamingContext;
    apwszAttrArray[2] = NULL;	// this is the sentinel

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		    pld,
		    NULL,			// base
		    LDAP_SCOPE_BASE,
		    L"objectClass=*",
		    apwszAttrArray,
		    FALSE,			// attrsonly
		    &timeval,
		    &pSearchResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_st");

    pEntry = ldap_first_entry(pld, pSearchResult);
    if (NULL == pEntry)
    {
	hr = myHLdapLastError(pld, NULL);
	_JumpError(hr, error, "ldap_first_entry");
    }

    pwszAttrName = ldap_first_attribute(pld, pEntry, &pber);
    while (NULL != pwszAttrName)
    {
	BSTR *pstr = NULL;
	
	if (NULL != pstrDomainDN &&
	    0 == mylstrcmpiS(pwszAttrName, pwszDefaultNamingContext))
	{
	    pstr = &strDomainDN;
	}
	else
	if (NULL != pstrConfigDN &&
	    0 == mylstrcmpiS(pwszAttrName, pwszConfigurationNamingContext))
	{
	    pstr = &strConfigDN;
	}
	if (NULL != pstr && NULL == *pstr)
	{
	    rgpwszValues = ldap_get_values(pld, pEntry, pwszAttrName);
	    if (NULL != rgpwszValues)
	    {
		if (NULL != rgpwszValues[0])
		{
		    *pstr = SysAllocString(rgpwszValues[0]);
		    if (NULL == *pstr)
		    { 
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "SysAllocString");
		    }
		}
		ldap_value_free(rgpwszValues);
	    }
	}
	ldap_memfree(pwszAttrName);
	pwszAttrName = ldap_next_attribute(pld, pEntry, pber);
    }
    if ((NULL != pstrDomainDN && NULL == strDomainDN) ||
	(NULL != pstrConfigDN && NULL == strConfigDN))
    {
	// We couldn't get default domain info - bail out

	hr =  HRESULT_FROM_WIN32(ERROR_CANT_ACCESS_DOMAIN_INFO);
	_JumpError(hr, error, "missing domain info");
    }
    if (NULL != pstrDomainDN)
    {
	*pstrDomainDN = strDomainDN;
	strDomainDN = NULL;
    }
    if (NULL != pstrConfigDN)
    {
	*pstrConfigDN = strConfigDN;
	strConfigDN = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pSearchResult)
    {
        ldap_msgfree(pSearchResult);
    }
    myLdapClose(NULL, strDomainDN, strConfigDN);
    return(myHError(hr));
}


HRESULT
myDomainFromDn(
    IN WCHAR const *pwszDN,
    OPTIONAL OUT WCHAR **ppwszDomainDNS)
{
    HRESULT hr;
    DWORD cwcOut;
    WCHAR *pwszOut;
    WCHAR **ppwszExplodedDN = NULL;
    WCHAR **ppwsz;
    WCHAR wszDC[4];
    WCHAR *pwsz;

    *ppwszDomainDNS = NULL;
    ppwszExplodedDN = ldap_explode_dn(const_cast<WCHAR *>(pwszDN), 0);
    if (NULL == ppwszExplodedDN)
    {
	hr = myHLdapLastError(NULL, NULL);
	_JumpError(hr, error, "ldap_explode_dn");
    }

    cwcOut = 0;
    for (ppwsz = ppwszExplodedDN; NULL != *ppwsz; ppwsz++)
    {
	pwsz = *ppwsz;

	wcsncpy(wszDC, pwsz, ARRAYSIZE(wszDC) - 1);
	wszDC[ARRAYSIZE(wszDC) - 1] = L'\0';
	if (0 == LSTRCMPIS(wszDC, L"DC="))
        {
	    pwsz += ARRAYSIZE(wszDC) - 1;
            if (0 != cwcOut)
            {
                cwcOut++;
            }
            cwcOut += wcslen(pwsz);
        }
    }

    pwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwcOut + 1) * sizeof(WCHAR));
    if (NULL == pwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    *ppwszDomainDNS = pwszOut;

    for (ppwsz = ppwszExplodedDN; NULL != *ppwsz; ppwsz++)
    {
	pwsz = *ppwsz;

	wcsncpy(wszDC, pwsz, ARRAYSIZE(wszDC) - 1);
	wszDC[ARRAYSIZE(wszDC) - 1] = L'\0';
	if (0 == LSTRCMPIS(wszDC, L"DC="))
        {
	    pwsz += ARRAYSIZE(wszDC) - 1;
            if (pwszOut != *ppwszDomainDNS)
            {
		*pwszOut++ = L'.';
            }
	    wcscpy(pwszOut, pwsz);
            pwszOut += wcslen(pwsz);
        }
    }
    CSASSERT(wcslen(*ppwszDomainDNS) == cwcOut);
    hr = S_OK;

error:
    if (NULL != ppwszExplodedDN)
    {
        ldap_value_free(ppwszExplodedDN);
    }
    return(hr);
}


HRESULT
myLdapOpen(
    OPTIONAL IN WCHAR const *pwszDomainName,
    IN DWORD dwFlags,	// RLBF_*
    OUT LDAP **ppld,
    OPTIONAL OUT BSTR *pstrDomainDN,
    OPTIONAL OUT BSTR *pstrConfigDN)
{
    HRESULT hr;
    LDAP *pld = NULL;

    *ppld = NULL;
    CSASSERT(NULL == pstrConfigDN || NULL == *pstrConfigDN);
    CSASSERT(NULL == pstrDomainDN || NULL == *pstrDomainDN);

    hr = myRobustLdapBindEx(
	    (RLBF_REQUIRE_GC & dwFlags)? RLBF_TRUE : 0,	// dwFlags1 (was fGC)
	    ~RLBF_TRUE & dwFlags,			// dwFlags2
	    LDAP_VERSION2,
	    pwszDomainName,
	    &pld,
	    NULL);					// ppwszForestDNSName
    _JumpIfError(hr, error, "myRobustLdapBindEx");

    // domain and config containers (%5, %6)

    hr = myGetAuthoritativeDomainDn(pld, pstrDomainDN, pstrConfigDN);
    if (S_OK != hr)
    {
	hr = myHError(hr);
	_JumpError(hr, error, "myGetAuthoritativeDomainDn");
    }
    *ppld = pld;
    pld = NULL;

error:
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
    return(hr);
}


VOID
myLdapClose(
    OPTIONAL IN LDAP *pld,
    OPTIONAL IN BSTR strDomainDN,
    OPTIONAL IN BSTR strConfigDN)
{
    if (NULL != strDomainDN)
    {
	SysFreeString(strDomainDN);
    }
    if (NULL != strConfigDN)
    {
	SysFreeString(strConfigDN);
    }
    if (NULL != pld)
    {
	ldap_unbind(pld);
    }
}


BOOL
myLdapRebindRequired(
    IN ULONG ldaperrParm,
    OPTIONAL IN LDAP *pld)
{
    BOOL fRebindRequired = FALSE;
    
    if (LDAP_SERVER_DOWN == ldaperrParm ||
	LDAP_UNAVAILABLE == ldaperrParm ||
	LDAP_TIMEOUT == ldaperrParm ||
	NULL == pld)
    {
	fRebindRequired = TRUE;
    }
    else
    {
	ULONG ldaperr;
	VOID *pvReachable = NULL;	// clear high bits for 64-bit machines

	ldaperr = ldap_get_option(pld, LDAP_OPT_HOST_REACHABLE, &pvReachable);
	if (LDAP_SUCCESS != ldaperr || LDAP_OPT_ON != pvReachable)
	{
	    fRebindRequired = TRUE;
	}
    }
    return(fRebindRequired);
}


HRESULT
myLdapGetDSHostName(
    IN LDAP *pld,
    OUT WCHAR **ppwszHostName)
{
    HRESULT hr;
    ULONG ldaperr;
    
    ldaperr = ldap_get_option(pld, LDAP_OPT_HOST_NAME, ppwszHostName);
    if (LDAP_SUCCESS != ldaperr)
    {
	*ppwszHostName = NULL;
    }
    hr = myHLdapError(pld, ldaperr, NULL);
    return(hr);
}


HRESULT
myLdapCreateContainer(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN BOOL  fSkipObject,       // Does the DN contain a leaf object name
    IN DWORD cMaxLevel,         // create this many nested containers as needed
    IN PSECURITY_DESCRIPTOR pContainerSD,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR const *pwsz = pwszDN;
    LDAPMod objectClass;
    LDAPMod advancedView;
    LDAPMod securityDescriptor;
    WCHAR *papwszshowInAdvancedViewOnly[2] = { L"TRUE", NULL };
    WCHAR *objectClassVals[3];
    LDAPMod *mods[4];
    struct berval *sdVals[2];
    struct berval sdberval;

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &advancedView;
    mods[2] = &securityDescriptor;
    mods[3] = NULL;

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = TEXT("objectclass");
    objectClass.mod_values = objectClassVals;

    advancedView.mod_op = LDAP_MOD_ADD;
    advancedView.mod_type = TEXT("showInAdvancedViewOnly");
    advancedView.mod_values = papwszshowInAdvancedViewOnly;

    objectClassVals[0] = TEXT("top");
    objectClassVals[1] = TEXT("container");
    objectClassVals[2] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;

    if (IsValidSecurityDescriptor(pContainerSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pContainerSD);
        sdberval.bv_val = (char *)pContainerSD;
    }
    else
    {
        sdberval.bv_len = 0;
        sdberval.bv_val = NULL;
    }
    
    // If the DN passed in was for the full object that goes in the container
    // (and not the container itself), skip past the CN for the leaf object.

    if (fSkipObject)
    {
        // Look for the CN of the container for this object.
        pwsz = wcsstr(&pwsz[3], L"CN=");
        if (NULL == pwsz)
        {
            // If there was no CN, then we are contained in an OU or DC,
            // and we don't need to do the create.

            hr = S_OK;
            goto error;
        }
    }
    if (0 != wcsncmp(pwsz, L"CN=", 3))
    {
        // We're not pointing to a simple container, so don't create this DN.  

        hr = S_OK;
        goto error;
    }

    pwszDN = pwsz;
    if (0 != cMaxLevel)
    {
        pwsz = wcsstr(&pwsz[3], L"CN=");
        if (NULL != pwsz)
        {
            // The remaining DN is a container, so try to create it.

            hr = myLdapCreateContainer(
				    pld,
				    pwsz,
				    FALSE,
				    cMaxLevel - 1,
				    pContainerSD,
				    ppwszError);
            // ignore access denied errors to allow delegation
            if (E_ACCESSDENIED != hr &&
		HRESULT_FROM_WIN32(ERROR_DS_INSUFF_ACCESS_RIGHTS) != hr)
            {
                _JumpIfErrorStr(hr, error, "myLdapCreateContainer", pwsz);
            }
	    if (NULL != ppwszError && NULL != *ppwszError)
	    {
		LocalFree(ppwszError);
		*ppwszError = NULL;
	    }
            hr = S_OK;
        }
    }

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS Container: '%ws'\n", pwszDN));

    // Create the container

    hr = ldap_add_ext_s(
		    pld,
		    const_cast<WCHAR *>(pwszDN),
		    mods,
		    g_rgLdapControls,
		    NULL);
    _PrintIfErrorStr2(
		hr,
		"ldap_add_ext_s(container)",
		pwszDN,
		LDAP_ALREADY_EXISTS);
    if ((HRESULT) LDAP_SUCCESS != hr && (HRESULT) LDAP_ALREADY_EXISTS != hr)
    {
	hr = myHLdapError(pld, hr, ppwszError);
        _JumpIfErrorStr(hr, error, "ldap_add_ext_s(container)", pwszDN);
    }
    hr = S_OK;

error:
    
    if(S_OK==hr && ppwszError && *ppwszError)
    {
        LocalFree(ppwszError);
        *ppwszError = NULL;
    }
    return(hr);
}


HRESULT
TrimURLDN(
    IN WCHAR const *pwszIn,
    OPTIONAL OUT WCHAR **ppwszSuffix,
    OUT WCHAR **ppwszDN)
{
    HRESULT hr;
    DWORD cSlash;
    WCHAR *pwsz;
    
    if (NULL != ppwszSuffix)
    {
	*ppwszSuffix = NULL;
    }
    *ppwszDN = NULL;
    pwsz = wcschr(pwszIn, L':');
    if (NULL != pwsz)
    {
	pwszIn = &pwsz[1];
    }
    cSlash = 0;
    while (L'/' == *pwszIn)
    {
	pwszIn++;
	cSlash++;
    }
    if (2 == cSlash)
    {
	while (L'\0' != *pwszIn && L'/' != *pwszIn)
	{
	    pwszIn++;
	}
	if (L'\0' != *pwszIn)
	{
	    pwszIn++;
	}
    }
    hr = myDupString(pwszIn, ppwszDN);
    _JumpIfError(hr, error, "myDupString");

    pwsz = wcschr(*ppwszDN, L'?');
    if (NULL != pwsz)
    {
	*pwsz++ = L'\0';
	if (NULL != ppwszSuffix)
	{
	    *ppwszSuffix = pwsz;
	}
    }
    CSASSERT(S_OK == hr);

error:
    if (S_OK != hr && NULL != *ppwszDN)
    {
	LocalFree(*ppwszDN);
	*ppwszDN = NULL;
    }
    return(hr);
}


HRESULT
CreateCertObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN DWORD dwObjectType,	// LPC_*
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pContainerSD = NULL;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    // get default DS CA security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY, NULL, &pSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    // get default DS AIA security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY, NULL, &pContainerSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    if (LPC_CREATECONTAINER & dwObjectType)
    {
	hr = myLdapCreateContainer(
			    pld,
			    pwszDN,
			    TRUE,
			    0,
			    pContainerSD,
			    ppwszError);
	if (E_ACCESSDENIED != hr &&
	    HRESULT_FROM_WIN32(ERROR_DS_INSUFF_ACCESS_RIGHTS) != hr)
	{
	    _JumpIfError(hr, error, "myLdapCreateContainer");
	}
	if (NULL != ppwszError && NULL != *ppwszError)
	{
	    LocalFree(ppwszError);
	    *ppwszError = NULL;
	}
    }

    if (LPC_CREATEOBJECT & dwObjectType)
    {
	if (NULL != ppwszError && NULL != *ppwszError)
	{
	    LocalFree(*ppwszError);
	    *ppwszError = NULL;
	}
	switch (LPC_OBJECTMASK & dwObjectType)
	{
	    case LPC_CAOBJECT:
		hr = myLdapCreateCAObject(
				    pld,
				    pwszDN,
				    NULL,
				    0,
				    pSD,
				    pdwDisposition,
				    ppwszError);
		_JumpIfErrorStr(hr, error, "myLdapCreateCAObject", pwszDN);
		break;

	    case LPC_KRAOBJECT:
	    case LPC_USEROBJECT:
	    case LPC_MACHINEOBJECT:
		hr = myLdapCreateUserObject(
				    pld,
				    pwszDN,
				    NULL,
				    0,
				    pSD,
				    dwObjectType,
				    pdwDisposition,
				    ppwszError);
		_JumpIfErrorStr(hr, error, "myLdapCreateUserObject", pwszDN);
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "dwObjectType");
	}
    }
    hr = S_OK;

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    if (NULL != pContainerSD)
    {
        LocalFree(pContainerSD);
    }
    return(hr);
}


HRESULT
AddCertToAttribute(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    IN BOOL fDelete,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    DWORD cber;
    DWORD iber;
    DWORD i;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    struct berval **ppberval = NULL;
    struct berval **prgpberVals = NULL;
    FILETIME ft;
    BOOL fDeleteExpiredCert = FALSE;
    BOOL fFoundCert = FALSE;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    apwszAttrs[0] = const_cast<WCHAR *>(pwszAttribute);
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		LDAP_SCOPE_BASE,		// scope
		NULL,				// filter
		apwszAttrs,			// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, ppwszError);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszDN);
    }
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	// No entries were found.

	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_count_entries");
    }

    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_first_entry");
    }

    ppberval = ldap_get_values_len(
			    pld,
			    pres,
			    const_cast<WCHAR *>(pwszAttribute));
    cber = 0;
    if (NULL != ppberval)
    {
	while (NULL != ppberval[cber])
	{
	    cber++;
	}
    }
    prgpberVals = (struct berval **) LocalAlloc(
					LMEM_FIXED,
					(cber + 2) * sizeof(prgpberVals[0]));
    if (NULL == prgpberVals)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Delete any certs that are at least one day old

    GetSystemTimeAsFileTime(&ft);
    myMakeExprDateTime(&ft, -1, ENUM_PERIOD_DAYS);

    iber = 0;
    if (NULL != ppberval)
    {
	for (i = 0; NULL != ppberval[i]; i++)
	{
	    BOOL fCopyBER = TRUE;
	    struct berval *pberval = ppberval[i];

	    if (pberval->bv_len == 1 && pberval->bv_val[0] == 0)
	    {
		fCopyBER = FALSE;	// remove zero byte placeholder value
	    }
	    else
	    if (pccPublish->cbCertEncoded == pberval->bv_len &&
		0 == memcmp(
			pberval->bv_val,
			pccPublish->pbCertEncoded,
			pccPublish->cbCertEncoded))
	    {
		fCopyBER = FALSE;	// remove duplicates to avoid ldap error
		fFoundCert = TRUE;
	    }
	    else
	    {
		CERT_CONTEXT const *pcc;

		pcc = CertCreateCertificateContext(
					    X509_ASN_ENCODING,
					    (BYTE *) pberval->bv_val,
					    pberval->bv_len);
		if (NULL == pcc)
		{
		    hr = myHLastError();
		    _PrintError(hr, "CertCreateCertificateContext");
		}
		else
		{
		    if (0 > CompareFileTime(&pcc->pCertInfo->NotAfter, &ft))
		    {
			fCopyBER = FALSE;
			fDeleteExpiredCert = TRUE;
			DBGPRINT((DBG_SS_CERTLIB, "Deleting expired cert %u\n", i));
		    }
		    CertFreeCertificateContext(pcc);
		}
	    }
	    if (fCopyBER)
	    {
		prgpberVals[iber++] = pberval;
	    }
	}
    }

    // set disposition assuming there's nothing to do:

    *pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;

    if ((!fFoundCert ^ fDelete) || fDeleteExpiredCert)
    {
	struct berval certberval;
	LDAPMod *mods[2];
	LDAPMod certmod;
	BYTE bZero = 0;

	mods[0] = &certmod;
	mods[1] = NULL;

	certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
	certmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	certmod.mod_bvalues = prgpberVals;

	if (fDelete)
	{
	    if (0 == iber)
	    {
		certberval.bv_val = (char *) &bZero;
		certberval.bv_len = sizeof(bZero);
		prgpberVals[iber++] = &certberval;
	    }
	}
	else
	{
	    certberval.bv_val = (char *) pccPublish->pbCertEncoded;
	    certberval.bv_len = pccPublish->cbCertEncoded;
	    prgpberVals[iber++] = &certberval;
	}
	prgpberVals[iber] = NULL;

	hr = ldap_modify_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    }
    hr = S_OK;

error:
    if (NULL != prgpberVals)
    {
	LocalFree(prgpberVals);
    }
    if (NULL != ppberval)
    {
	ldap_value_free_len(ppberval);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
AddCRLToAttribute(
    IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    struct berval **ppberval = NULL;
    LDAPMod crlmod;
    LDAPMod *mods[2];
    struct berval *crlberVals[2];
    struct berval crlberval;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    apwszAttrs[0] = const_cast<WCHAR *>(pwszAttribute);
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
		pld,				// ld
		const_cast<WCHAR *>(pwszDN),	// base
		LDAP_SCOPE_BASE,		// scope
		NULL,				// filter
		apwszAttrs,			// attrs
		FALSE,				// attrsonly
		&timeval,			// timeout
		&pmsg);				// res
    if (S_OK != hr)
    {
	*pdwDisposition = hr;
	hr = myHLdapError(pld, hr, ppwszError);
	_JumpErrorStr(hr, error, "ldap_search_st", pwszDN);
    }
    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
	// No entries were found.

	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_count_entries");
    }

    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
	hr = NTE_NOT_FOUND;
	_JumpError(hr, error, "ldap_first_entry");
    }

    ppberval = ldap_get_values_len(
			    pld,
			    pres,
			    const_cast<WCHAR *>(pwszAttribute));

    if (NULL != ppberval &&
	NULL != ppberval[0] &&
	pCRLPublish->cbCrlEncoded == ppberval[0]->bv_len &&
	0 == memcmp(
		ppberval[0]->bv_val,
		pCRLPublish->pbCrlEncoded,
		pCRLPublish->cbCrlEncoded))
    {
	// set disposition assuming there's nothing to do:

	*pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;
    }
    else
    {
	mods[0] = &crlmod;
	mods[1] = NULL;

	crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
	crlmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	crlmod.mod_bvalues = crlberVals;

	crlberVals[0] = &crlberval;
	crlberVals[1] = NULL;

	crlberval.bv_val = (char *) pCRLPublish->pbCrlEncoded;
	crlberval.bv_len = pCRLPublish->cbCrlEncoded;

	hr = ldap_modify_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    }
    hr = S_OK;

error:
    if (NULL != ppberval)
    {
	ldap_value_free_len(ppberval);
    }
    if (NULL != pmsg)
    {
	ldap_msgfree(pmsg);
    }
    return(hr);
}


HRESULT
myLdapPublishCertToDS(
    IN LDAP *pld,
    IN CERT_CONTEXT const *pccPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    IN DWORD dwObjectType,	// LPC_*
    IN BOOL fDelete,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    HRESULT hrCreate = S_OK;
    WCHAR *pwszDN = NULL;
    WCHAR *pwszSuffix;
    WCHAR *pwszCreateError = NULL;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    hr = TrimURLDN(pwszURL, &pwszSuffix, &pwszDN);
    _JumpIfError(hr, error, "TrimURLDN");

    if (0 == LSTRCMPIS(pwszAttribute, wszDSUSERCERTATTRIBUTE) ||
	0 == LSTRCMPIS(pwszAttribute, wszDSKRACERTATTRIBUTE))
    {
	if (LPC_CAOBJECT == (LPC_OBJECTMASK & dwObjectType))
	{
	    hr = E_INVALIDARG;
	}
    }
    else
    if (0 == LSTRCMPIS(pwszAttribute, wszDSCACERTATTRIBUTE) ||
	0 == LSTRCMPIS(pwszAttribute, wszDSCROSSCERTPAIRATTRIBUTE))
    {
	if (LPC_CAOBJECT != (LPC_OBJECTMASK & dwObjectType))
	{
	    hr = E_INVALIDARG;
	}
    }
    else
    {
	hr = E_INVALIDARG;
    }
    _JumpIfErrorStr(hr, error, "Bad Cert Attribute", pwszAttribute);

    *pdwDisposition = LDAP_SUCCESS;
    if ((LPC_CREATECONTAINER | LPC_CREATEOBJECT) & dwObjectType)
    {
	hr = CreateCertObject(
			pld,
			pwszDN,
			dwObjectType,
			pdwDisposition,
			&pwszCreateError);
	hrCreate = hr;
	if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
	{
	    _JumpIfError(hr, error, "CreateCertObject");
	}
    }

    hr = AddCertToAttribute(
		    pld,
		    pccPublish,
		    pwszDN,
		    pwszAttribute,
		    fDelete,
		    pdwDisposition,
		    ppwszError);
    _JumpIfError(hr, error, "AddCertToAttribute");

    CSASSERT(NULL == ppwszError || NULL == *ppwszError);

error:
    if (HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND) == hr &&
	HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hrCreate)
    {
	hr = hrCreate;
    }
    if (NULL != pwszCreateError)
    {
	if (S_OK != hr && NULL != ppwszError)
	{
	    if (NULL != *ppwszError)
	    {
		myPrependString(pwszCreateError, L"", ppwszError);
	    }
	    else
	    {
		*ppwszError = pwszCreateError;
		pwszCreateError = NULL;
	    }
	}
	if (NULL != pwszCreateError)
	{
	    LocalFree(pwszCreateError);
	}
    }
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}


HRESULT
myLdapPublishCRLToDS(
    IN LDAP *pld,
    IN CRL_CONTEXT const *pCRLPublish,
    IN WCHAR const *pwszURL,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR *pwszDN = NULL;
    WCHAR *pwszSuffix;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR pContainerSD = NULL;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }

    hr = TrimURLDN(pwszURL, &pwszSuffix, &pwszDN);
    _JumpIfError(hr, error, "TrimURLDN");

    if (0 == LSTRCMPIS(pwszAttribute, wszDSBASECRLATTRIBUTE))
    {
    }
    else if (0 == LSTRCMPIS(pwszAttribute, wszDSDELTACRLATTRIBUTE))
    {
    }
    else
    {
	hr = E_INVALIDARG;
	_JumpErrorStr(hr, error, "Bad CRL Attribute", pwszAttribute);
    }

    // get default DS CDP security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CDP_DS_SECURITY, SDDL_CERT_SERV_ADMINISTRATORS, &pSD);
    if (S_OK != hr)
    {
	_PrintError(hr, "myGetSDFromTemplate");
	pSD = NULL;
    }

    // get default DS AIA security descriptor

    hr = myGetSDFromTemplate(WSZ_DEFAULT_CA_DS_SECURITY, NULL, &pContainerSD);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = myLdapCreateContainer(pld, pwszDN, TRUE, 1, pContainerSD, ppwszError);
    if (E_ACCESSDENIED != hr &&
	HRESULT_FROM_WIN32(ERROR_DS_INSUFF_ACCESS_RIGHTS) != hr)
    {
	_JumpIfErrorStr(hr, error, "myLdapCreateContainer", pwszDN);
    }
    if (NULL != ppwszError && NULL != *ppwszError)
    {
	LocalFree(ppwszError);
	*ppwszError = NULL;
    }

    hr = myLdapCreateCDPObject(
			pld,
			pwszDN,
			NULL != pSD? pSD : pContainerSD,
			pdwDisposition,
			ppwszError);
    _JumpIfErrorStr(hr, error, "myLdapCreateCDPObject", pwszDN);

    hr = AddCRLToAttribute(
		    pld,
		    pCRLPublish,
		    pwszDN,
		    pwszAttribute,
		    pdwDisposition,
		    ppwszError);
    _JumpIfError(hr, error, "AddCRLToAttribute");

error:
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    if (NULL != pContainerSD)
    {
        LocalFree(pContainerSD);
    }
    if (NULL != pwszDN)
    {
	LocalFree(pwszDN);
    }
    return(hr);
}


BOOL
DNExists(
    IN LDAP *pld,
    IN WCHAR const *pwszDN)
{
    ULONG ldaperr;
    BOOL fExists = FALSE;
    LPWSTR pwszAttrArray[2];
    struct l_timeval timeout;
    LDAPMessage *pResult = NULL;

    pwszAttrArray[0] = L"cn";
    pwszAttrArray[1] = NULL;

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    ldaperr = ldap_search_ext_s(
		    pld,
		    const_cast<WCHAR *>(pwszDN),
		    LDAP_SCOPE_BASE,
		    L"objectClass=*",
		    pwszAttrArray,
		    1,
		    g_rgLdapControls,
		    NULL,
		    &timeout,
		    0,
		    &pResult);
    if (NULL != pResult)
    {
	fExists = LDAP_SUCCESS == ldaperr &&
		    1 == ldap_count_entries(pld, pResult);
	ldap_msgfree(pResult);
    }
    return(fExists);
}


HRESULT
CreateOrUpdateDSObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN LDAPMod **prgmodsCreate,
    OPTIONAL IN LDAPMod **prgmodsUpdate,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    ULONG ldaperr;
    WCHAR *pwszError = NULL;

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    ldaperr = ldap_add_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			prgmodsCreate,
			g_rgLdapControls,
			NULL);
    *pdwDisposition = ldaperr;
    _PrintIfErrorStr2(ldaperr, "ldap_add_ext_s", pwszDN, LDAP_ALREADY_EXISTS);

    if (LDAP_ALREADY_EXISTS == ldaperr || LDAP_INSUFFICIENT_RIGHTS == ldaperr)
    {
	if (NULL == prgmodsUpdate)
	{
	    if (LDAP_INSUFFICIENT_RIGHTS == ldaperr)
	    {
		hr = myHLdapError(pld, ldaperr, &pwszError);
		_PrintErrorStr(hr, "ldap_add_ext_s", pwszError);

		if (!DNExists(pld, pwszDN))
		{
		    *ppwszError = pwszError;
		    pwszError = NULL;
		    _JumpErrorStr(hr, error, "ldap_add_ext_s", *ppwszError);
		}
	    }
	    ldaperr = LDAP_SUCCESS;
	}
	else
	{
	    ldaperr = ldap_modify_ext_s(
				pld,
				const_cast<WCHAR *>(pwszDN),
				prgmodsUpdate,
				NULL,
				NULL);
	    *pdwDisposition = ldaperr;
	    _PrintIfErrorStr2(
			ldaperr,
			"ldap_modify_ext_s",
			pwszDN,
			LDAP_ATTRIBUTE_OR_VALUE_EXISTS);
	    if (LDAP_ATTRIBUTE_OR_VALUE_EXISTS == ldaperr)
	    {
		ldaperr = LDAP_SUCCESS;
	    }
	}
    }
    if (ldaperr != LDAP_SUCCESS)
    {
	hr = myHLdapError(pld, ldaperr, ppwszError);
        _JumpError(hr, error, "Add/Update DS");
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(pwszError);
    }
    return(hr);
}


HRESULT
myLdapCreateCAObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    BYTE ZeroByte = 0;

    LDAPMod objectClass;
    LDAPMod securityDescriptor;
    LDAPMod crlmod;
    LDAPMod arlmod;
    LDAPMod certmod;

    struct berval sdberval;
    struct berval crlberval;
    struct berval arlberval;
    struct berval certberval;

    WCHAR *objectClassVals[3];
    struct berval *sdVals[2];
    struct berval *crlVals[2];
    struct berval *arlVals[2];
    struct berval *certVals[2];

    LDAPMod *mods[6];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &securityDescriptor;
    mods[2] = &crlmod;
    mods[3] = &arlmod;
    mods[4] = &certmod;	// must be last!
    mods[5] = NULL;

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;
    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSCACLASSNAME;
    objectClassVals[2] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;
    sdberval.bv_len = 0;
    sdberval.bv_val = NULL;
    if (IsValidSecurityDescriptor(pSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pSD);
	sdberval.bv_val = (char *) pSD;
    }

    crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    crlmod.mod_type = wszDSBASECRLATTRIBUTE;
    crlmod.mod_bvalues = crlVals;
    crlVals[0] = &crlberval;
    crlVals[1] = NULL;
    crlberval.bv_len = sizeof(ZeroByte);
    crlberval.bv_val = (char *) &ZeroByte;

    arlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    arlmod.mod_type = wszDSAUTHORITYCRLATTRIBUTE;
    arlmod.mod_bvalues = arlVals;
    arlVals[0] = &arlberval;
    arlVals[1] = NULL;
    arlberval.bv_len = sizeof(ZeroByte);
    arlberval.bv_val = (char *) &ZeroByte;

    certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    certmod.mod_type = wszDSCACERTATTRIBUTE;
    certmod.mod_bvalues = certVals;
    certVals[0] = &certberval;
    certVals[1] = NULL;
    certberval.bv_len = sizeof(ZeroByte);
    certberval.bv_val = (char *) &ZeroByte;
    if (NULL != pbCert)
    {
	certberval.bv_len = cbCert;
	certberval.bv_val = (char *) pbCert;
    }

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS CA Object: '%ws'\n", pwszDN));

    CSASSERT(&certmod == mods[ARRAYSIZE(mods) - 2]);
    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL != pbCert? &mods[ARRAYSIZE(mods) - 2] : NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(CA object)");

error:
    return(hr);
}


HRESULT
myLdapCreateUserObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    OPTIONAL IN BYTE const *pbCert,
    IN DWORD cbCert,
    IN PSECURITY_DESCRIPTOR pSD,
    IN DWORD dwObjectType,	// LPC_* (but LPC_CREATE* is ignored)
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    BYTE ZeroByte = 0;

    LDAPMod objectClass;
    LDAPMod securityDescriptor;
    LDAPMod certmod;

    struct berval sdberval;
    struct berval certberval;

    WCHAR *objectClassVals[6];
    struct berval *sdVals[2];
    struct berval *certVals[2];

    LDAPMod *mods[4];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &securityDescriptor;
    mods[2] = &certmod;	// must be last!
    mods[3] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;
    sdberval.bv_len = 0;
    sdberval.bv_val = NULL;
    if (IsValidSecurityDescriptor(pSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pSD);
        sdberval.bv_val = (char *) pSD;
    }

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;

    DBGCODE(WCHAR const *pwszObjectType);
    switch (LPC_OBJECTMASK & dwObjectType)
    {
	case LPC_CAOBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSCACLASSNAME;
	    objectClassVals[2] = NULL;
	    DBGCODE(pwszObjectType = L"CA");
	    break;

	case LPC_KRAOBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSKRACLASSNAME;
	    objectClassVals[2] = NULL;
	    DBGCODE(pwszObjectType = L"KRA");
	    break;

	case LPC_USEROBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSPERSONCLASSNAME;
	    objectClassVals[2] = wszDSORGPERSONCLASSNAME;
	    objectClassVals[3] = wszDSUSERCLASSNAME;
	    objectClassVals[4] = NULL;
	    DBGCODE(pwszObjectType = L"User");
	    break;

	case LPC_MACHINEOBJECT:
	    objectClassVals[0] = wszDSTOPCLASSNAME;
	    objectClassVals[1] = wszDSPERSONCLASSNAME;
	    objectClassVals[2] = wszDSORGPERSONCLASSNAME;
	    objectClassVals[3] = wszDSUSERCLASSNAME;
	    objectClassVals[4] = wszDSMACHINECLASSNAME;
	    objectClassVals[5] = NULL;
	    DBGCODE(pwszObjectType = L"Machine");
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "dwObjectType");
    }

    certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    certmod.mod_type = wszDSUSERCERTATTRIBUTE;
    certmod.mod_bvalues = certVals;
    certVals[0] = &certberval;
    certVals[1] = NULL;
    certberval.bv_len = sizeof(ZeroByte);
    certberval.bv_val = (char *) &ZeroByte;
    if (NULL != pbCert)
    {
	certberval.bv_len = cbCert;
	certberval.bv_val = (char *) pbCert;
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"Creating DS %ws Object: '%ws'\n",
	pwszObjectType,
	pwszDN));

    CSASSERT(&certmod == mods[ARRAYSIZE(mods) - 2]);
    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL != pbCert? &mods[ARRAYSIZE(mods) - 2] : NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(KRA object)");

error:
    return(hr);
}


HRESULT
myLdapCreateCDPObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN PSECURITY_DESCRIPTOR pSD,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    BYTE ZeroByte = 0;

    LDAPMod objectClass;
    LDAPMod securityDescriptor;
    LDAPMod crlmod;
    LDAPMod drlmod;

    struct berval sdberval;
    struct berval crlberval;
    struct berval drlberval;

    WCHAR *objectClassVals[3];
    struct berval *sdVals[2];
    struct berval *crlVals[2];
    struct berval *drlVals[2];

    LDAPMod *mods[5];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &securityDescriptor;
    mods[2] = &crlmod;
    mods[3] = &drlmod;
    mods[4] = NULL;

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;
    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSCDPCLASSNAME;
    objectClassVals[2] = NULL;

    securityDescriptor.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_ADD;
    securityDescriptor.mod_type = CERTTYPE_SECURITY_DESCRIPTOR_NAME;
    securityDescriptor.mod_bvalues = sdVals;
    sdVals[0] = &sdberval;
    sdVals[1] = NULL;
    sdberval.bv_len = 0;
    sdberval.bv_val = NULL;
    if (IsValidSecurityDescriptor(pSD))
    {
        sdberval.bv_len = GetSecurityDescriptorLength(pSD);
        sdberval.bv_val = (char *) pSD;
    }

    crlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    crlmod.mod_type = wszDSBASECRLATTRIBUTE;
    crlmod.mod_bvalues = crlVals;
    crlVals[0] = &crlberval;
    crlVals[1] = NULL;
    crlberval.bv_val = (char *) &ZeroByte;
    crlberval.bv_len = sizeof(ZeroByte);

    drlmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
    drlmod.mod_type = wszDSDELTACRLATTRIBUTE;
    drlmod.mod_bvalues = drlVals;
    drlVals[0] = &drlberval;
    drlVals[1] = NULL;
    drlberval.bv_val = (char *) &ZeroByte;
    drlberval.bv_len = sizeof(ZeroByte);

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS CDP Object: '%ws'\n", pwszDN));

    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(CDP object)");

error:
    return(hr);
}


HRESULT
myLdapCreateOIDObject(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN DWORD dwType,
    IN WCHAR const *pwszObjId,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    WCHAR awcType[22];

    LDAPMod objectClass;
    LDAPMod typemod;
    LDAPMod oidmod;

    WCHAR *objectClassVals[3];
    WCHAR *typeVals[2];
    WCHAR *oidVals[2];

    LDAPMod *mods[4];

    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    mods[0] = &objectClass;
    mods[1] = &typemod;
    mods[2] = &oidmod;
    mods[3] = NULL;
    CSASSERT(CSExpr(4 == ARRAYSIZE(mods)));

    objectClass.mod_op = LDAP_MOD_ADD;
    objectClass.mod_type = wszDSOBJECTCLASSATTRIBUTE;
    objectClass.mod_values = objectClassVals;
    objectClassVals[0] = wszDSTOPCLASSNAME;
    objectClassVals[1] = wszDSOIDCLASSNAME;
    objectClassVals[2] = NULL;
    CSASSERT(CSExpr(3 == ARRAYSIZE(objectClassVals)));

    typemod.mod_op = LDAP_MOD_ADD;
    typemod.mod_type = OID_PROP_TYPE;
    typemod.mod_values = typeVals;
    wsprintf(awcType, L"%u", dwType);
    typeVals[0] = awcType;
    typeVals[1] = NULL;
    CSASSERT(CSExpr(2 == ARRAYSIZE(typeVals)));

    oidmod.mod_op = LDAP_MOD_ADD;
    oidmod.mod_type = OID_PROP_OID;
    oidmod.mod_values = oidVals;
    oidVals[0] = const_cast<WCHAR *>(pwszObjId);
    oidVals[1] = NULL;
    CSASSERT(CSExpr(2 == ARRAYSIZE(oidVals)));

    DBGPRINT((DBG_SS_CERTLIBI, "Creating DS OID Object: '%ws'\n", pwszDN));

    hr = CreateOrUpdateDSObject(
			pld,
			pwszDN,
			mods,
			NULL,
			pdwDisposition,
			ppwszError);
    _JumpIfError(hr, error, "CreateOrUpdateDSObject(OID object)");

error:
    return(hr);
}


HRESULT
myLdapOIDIsMatchingLangId(
    IN WCHAR const *pwszDisplayName,
    IN DWORD dwLanguageId,
    OUT BOOL *pfLangIdExists)
{
    DWORD DisplayLangId = _wtoi(pwszDisplayName);

    *pfLangIdExists = FALSE;
    if (iswdigit(*pwszDisplayName) &&
	NULL != wcschr(pwszDisplayName, L',') &&
	DisplayLangId == dwLanguageId)
    {
	*pfLangIdExists = TRUE;
    }
    return(S_OK);
}


HRESULT
myLdapAddOrDeleteOIDDisplayNameToAttribute(
    IN LDAP *pld,
    OPTIONAL IN WCHAR **ppwszOld,
    IN DWORD dwLanguageId,
    OPTIONAL IN WCHAR const *pwszDisplayName,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cname;
    DWORD iname;
    DWORD i;
    WCHAR **ppwszNew = NULL;
    WCHAR *pwszNew = NULL;
    BOOL fDeleteOldName = FALSE;
    BOOL fNewNameMissing;

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    if (NULL != pwszDisplayName)
    {
	pwszNew = (WCHAR *) LocalAlloc(
			LMEM_FIXED,
			(cwcDWORDSPRINTF + 1 + wcslen(pwszDisplayName) + 1) *
			    sizeof(WCHAR));
	if (NULL == pwszNew)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wsprintf(pwszNew, L"%u,%ws", dwLanguageId, pwszDisplayName);
    }

    cname = 0;
    if (NULL != ppwszOld)
    {
	while (NULL != ppwszOld[cname])
	{
	    cname++;
	}
    }
    ppwszNew = (WCHAR **) LocalAlloc(
				LMEM_FIXED,
				(cname + 2) * sizeof(ppwszNew[0]));
    if (NULL == ppwszNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // Delete any display names with matching dwLanguageId

    iname = 0;
    fNewNameMissing = NULL != pwszNew? TRUE : FALSE;
    if (NULL != ppwszOld)
    {
	for (i = 0; NULL != ppwszOld[i]; i++)
	{
	    BOOL fCopy = TRUE;
	    WCHAR *pwsz = ppwszOld[i];

	    // case-sensitive compare:

	    if (NULL != pwszNew && 0 == lstrcmp(pwszNew, ppwszOld[i]))
	    {
		fCopy = FALSE;	// remove duplicates to avoid ldap error
		fNewNameMissing = FALSE;
	    }
	    else
	    {
		BOOL fLangIdExists;
		
		hr = myLdapOIDIsMatchingLangId(
					pwsz,
					dwLanguageId,
					&fLangIdExists);
		_PrintIfError(hr, "myLdapOIDIsMatchingLangId");
		if (S_OK != hr || fLangIdExists)
		{
		    fCopy = FALSE;
		    fDeleteOldName = TRUE;
		    DBGPRINT((DBG_SS_CERTLIB, "Deleting %ws\n", pwsz));
		}
	    }
	    if (fCopy)
	    {
		ppwszNew[iname++] = pwsz;
	    }
	}
    }
    CSASSERT(iname <= cname);

    // set disposition assuming there's nothing to do:

    *pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;

    if (fNewNameMissing || fDeleteOldName)
    {
	LDAPMod *mods[2];
	LDAPMod namemod;

	mods[0] = &namemod;
	mods[1] = NULL;

	namemod.mod_op = LDAP_MOD_REPLACE;
	namemod.mod_type = const_cast<WCHAR *>(pwszAttribute);
	namemod.mod_values = ppwszNew;

	ppwszNew[iname++] = pwszNew;
	ppwszNew[iname] = NULL;

	hr = ldap_modify_ext_s(
			pld,
			const_cast<WCHAR *>(pwszDN),
			mods,
			NULL,
			NULL);
	*pdwDisposition = hr;
	if (hr != S_OK)
	{
	    hr = myHLdapError(pld, hr, ppwszError);
	    _JumpError(hr, error, "ldap_modify_ext_s");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszNew)
    {
	LocalFree(pwszNew);
    }
    if (NULL != ppwszNew)
    {
	LocalFree(ppwszNew);
    }
    return(hr);
}


HRESULT
myHLdapError3(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    IN ULONG ldaperrParmQuiet2,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr = S_OK;
    
    if (NULL != ppwszError)
    {
	*ppwszError = NULL;
    }
    if (LDAP_SUCCESS != ldaperrParm)
    {
	BOOL fXlat = TRUE;
	ULONG ldaperr;
	WCHAR *pwszError = NULL;

	if (NULL != pld)
	{
	    ldaperr = ldap_get_option(pld, LDAP_OPT_SERVER_ERROR, &pwszError);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		_PrintError(ldaperr, "ldap_get_option(server error)");
		pwszError = NULL;
	    }

	    ldaperr = ldap_get_option(pld, LDAP_OPT_SERVER_EXT_ERROR, &hr);
	    if (LDAP_SUCCESS != ldaperr)
	    {
		_PrintError2(
			ldaperr,
			"ldap_get_option(server extended error)",
			ldaperr);
	    }
	    else
	    {
		fXlat = FALSE;
	    }
	}
	if (fXlat)
	{
#undef LdapMapErrorToWin32
	    hr = LdapMapErrorToWin32(ldaperrParm);
#define LdapMapErrorToWin32	Use_myHLdapError_Instead_Of_LdapMapErrorToWin32
	}
	hr = myHError(hr);
	_PrintErrorStr3(
		    ldaperrParm,
		    "ldaperr",
		    pwszError,
		    ldaperrParmQuiet,
		    ldaperrParmQuiet2);
	if (NULL != ppwszError && NULL != pwszError)
	{
	    WCHAR awc[32];
	    DWORD cwc;

	    wsprintf(awc, L"ldap: 0x%x: ", ldaperrParm);
	    cwc = wcslen(awc) + wcslen(pwszError);
	    *ppwszError = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	    if (NULL == *ppwszError)
	    {
		_PrintError(E_OUTOFMEMORY, "LocalAlloc");
	    }
	    else
	    {
		wcscpy(*ppwszError, awc);
		wcscat(*ppwszError, pwszError);
	    }
	} 
	if (NULL != pwszError)
	{
	    ldap_memfree(pwszError);
	}
    }
    return(hr);
}


HRESULT
myHLdapError2(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    IN ULONG ldaperrParmQuiet,
    OPTIONAL OUT WCHAR **ppwszError)
{
    return(myHLdapError3(
		    pld,
		    ldaperrParm,
		    ldaperrParmQuiet,
		    LDAP_SUCCESS,
		    ppwszError));
}


HRESULT
myHLdapError(
    OPTIONAL IN LDAP *pld,
    IN ULONG ldaperrParm,
    OPTIONAL OUT WCHAR **ppwszError)
{
    return(myHLdapError3(
		    pld,
		    ldaperrParm,
		    LDAP_SUCCESS,
		    LDAP_SUCCESS,
		    ppwszError));
}


HRESULT
myHLdapLastError(
    OPTIONAL IN LDAP *pld,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;

    hr = myHLdapError3(
		    pld,
		    LdapGetLastError(),
		    LDAP_SUCCESS,
		    LDAP_SUCCESS,
		    ppwszError);
    // must return error
    if (hr == S_OK)
       return E_UNEXPECTED;

    return hr;
}


HRESULT
myLDAPSetStringAttribute(
    IN LDAP *pld,
    IN WCHAR const *pwszDN,
    IN WCHAR const *pwszAttribute,
    IN WCHAR const *pwszValue,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    LDAPMod *mods[2];
    LDAPMod certmod;
    const WCHAR *ppwszVals[2];
    CAutoLPWSTR pwszDNOnly;
    WCHAR *pwszSuffix; // no free

    hr = TrimURLDN(pwszDN, &pwszSuffix, &pwszDNOnly);
    _JumpIfErrorStr(hr, error, "TrimURLDN", pwszDN);

    mods[0] = &certmod;
    mods[1] = NULL;

    ppwszVals[0] = pwszValue;
    ppwszVals[1] = NULL;

    certmod.mod_op = LDAP_MOD_REPLACE;
    certmod.mod_type = const_cast<WCHAR *>(pwszAttribute);
    certmod.mod_values = const_cast<PWCHAR *>(ppwszVals);

    hr = ldap_modify_ext_s(
		    pld,
		    pwszDNOnly,
		    mods,
		    NULL,
		    NULL);
    *pdwDisposition = hr;
    if (hr != S_OK)
    {
	hr = myHLdapError(pld, hr, ppwszError);
	_JumpError(hr, error, "ldap_modify_ext_s");
    }
    hr = S_OK;

error:
    return hr;
}

HRESULT
CurrentUserCanInstallCA(
    bool& fCanInstall)
{
    HRESULT hr;
    HANDLE hThread = NULL; // no free
    HANDLE hAccessToken = NULL, hDupToken = NULL;
    LDAP *pld = NULL;
    BSTR bstrConfigDN = NULL;
    LPWSTR pwszPKIContainerFilter = 
        L"(&(objectClass=container)(CN=Public Key Services))";
    LPWSTR pwszSDAttr = L"nTSecurityDescriptor";
    LPWSTR pwszAttrArray[3];
    LDAPMessage* pResult = NULL;
    LDAPMessage *pEntry;
    struct berval **bervalSD = NULL;
    PSECURITY_DESCRIPTOR pSD; // no free
    GENERIC_MAPPING mapping;
    PRIVILEGE_SET PrivilegeSet;
    DWORD cPrivilegeSet = sizeof(PrivilegeSet);
    DWORD dwGrantedAccess;
    BOOL fAccess = FALSE;
    struct l_timeval timeout;
    CHAR sdBerValue[] = {0x30, 0x03, 0x02, 0x01, 
        DACL_SECURITY_INFORMATION |
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION};

    LDAPControl se_info_control =
    {
        LDAP_SERVER_SD_FLAGS_OID_W,
        {
            5, sdBerValue
        },
        TRUE
    };

    PLDAPControl    server_controls[2] =
                    {
                        &se_info_control,
                        NULL
                    };

    pwszAttrArray[0] = pwszSDAttr;
    pwszAttrArray[1] = L"name";
    pwszAttrArray[2] = NULL;

    ZeroMemory(&mapping, sizeof(mapping));

    fCanInstall = false;

    // Get the access token for current thread
    hThread = GetCurrentThread();
    if (NULL == hThread)
    {
        hr = myHLastError();
        _JumpIfError(hr, error, "GetCurrentThread");
    }

    if (!OpenThreadToken(
            hThread,
            TOKEN_QUERY | TOKEN_DUPLICATE,
            FALSE,
            &hAccessToken))
    {
        hr = myHLastError();

        if(hr==HRESULT_FROM_WIN32(ERROR_NO_TOKEN))
        {
            HANDLE hProcess = GetCurrentProcess();
            if (NULL == hProcess)
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetCurrentProcess");
            }

            if (!OpenProcessToken(hProcess,
                    TOKEN_DUPLICATE,
                    &hAccessToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "OpenProcessToken");
            }

            if (!DuplicateToken(hAccessToken, SecurityIdentification, &hDupToken))
            {
                hr = myHLastError();
                _JumpError(hr, error, "DuplicateToken");
            }

        }
        else
        {
            _JumpError(hr, error, "OpenThreadToken");
        }
    }

    hr = myLdapOpen(
		NULL,		// pwszDomainName
		RLBF_REQUIRE_GC | RLBF_REQUIRE_SECURE_LDAP, // dwFlags
		&pld,
		NULL,		// pstrDomainDN
		&bstrConfigDN);
    _JumpIfError(hr, error, "myLdapOpen");

    timeout.tv_sec = csecLDAPTIMEOUT;
    timeout.tv_usec = 0;

    hr = ldap_search_ext_s(
                    pld,
                    bstrConfigDN,
                    LDAP_SCOPE_SUBTREE,
                    pwszPKIContainerFilter,
                    pwszAttrArray,
                    0,
                    (PLDAPControl *) server_controls,
                    NULL,
                    &timeout,
                    0,
                    &pResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_ext_s");

    pEntry = ldap_first_entry(pld, pResult);
    if (NULL == pEntry)
    {
        hr = myHLdapLastError(pld, NULL);
        _JumpError(hr, error, "ldap_first_entry");
    }

    bervalSD = ldap_get_values_len(pld, pEntry, pwszSDAttr);

    if(bervalSD && (*bervalSD)->bv_val)
    {
        pSD = (*bervalSD)->bv_val;

        if(IsValidSecurityDescriptor(pSD))
        {
            if(!AccessCheck(
                    pSD,
                    hDupToken,
                    ACTRL_DS_WRITE_PROP |
                    WRITE_DAC |
                    ACTRL_DS_CREATE_CHILD,
                    &mapping,
                    &PrivilegeSet,
                    &cPrivilegeSet,
                    &dwGrantedAccess,
                    &fAccess))
            {
                hr = myHLastError();

                if(E_ACCESSDENIED==hr)
                {
                    hr = S_OK;
                }
                _JumpError(hr, error, "AccessCheck");
            }
        }
        else
        {
            DBGPRINT((DBG_SS_CERTOCM, "Invalid security descriptor for PKI container" ));
        }
    }
    else
    {
        DBGPRINT((DBG_SS_CERTOCM, "No security descriptor for PKI container" ));
    }

    if(fAccess)
    {
        fCanInstall = true;
    }

error:
    if(bervalSD)
    {
        ldap_value_free_len(bervalSD);
    }
    if (NULL != pResult)
    {
        ldap_msgfree(pResult);
    }
    myLdapClose(pld, NULL, bstrConfigDN);
    if (hAccessToken)
    {
        CloseHandle(hAccessToken);
    }
    if (hDupToken)
    {
        CloseHandle(hDupToken);
    }

    //we should always return S_OK; since we do not want to abort
    //ocmsetup just because we failed to contact the directory
    return S_OK;
}

HRESULT myLdapFindObjectInForest(
    IN LDAP *pld,
    IN LPCWSTR pwszFilter,
    OUT LPWSTR *ppwszURL)
{
    HRESULT hr;
    LPWSTR pwszAttrArray[2] = {wszDSDNATTRIBUTE, NULL};
    LDAPMessage* pResult = NULL;
    LDAPMessage *pEntry;
    LPWSTR *pwszValue = NULL;
    hr = ldap_search_s(
                    pld,
                    NULL,
                    LDAP_SCOPE_SUBTREE,
                    const_cast<WCHAR*>(pwszFilter),
                    pwszAttrArray,
                    0,
                    &pResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_s");

    pEntry = ldap_first_entry(pld, pResult);
    if (NULL == pEntry)
    {
        hr = myHLdapLastError(pld, NULL);
        _JumpError(hr, error, "ldap_first_entry");
    }

    pwszValue = ldap_get_values(pld, pEntry, wszDSDNATTRIBUTE);

    if(pwszValue && pwszValue[0])
    {
        hr = myDupString(pwszValue[0], ppwszURL);
        _JumpIfError(hr, error, "myDupString");
    }

error: 
    if(pwszValue)
    {
        ldap_value_free(pwszValue);
    }
    if (NULL != pResult)
    {
        ldap_msgfree(pResult);
    }
    return hr;
}

HRESULT ExtractMachineNameFromDNSName(
    LPCWSTR pcwszDNS,
    LPWSTR *ppcwszMachineName)
{
    HRESULT hr;
    WCHAR *pwszDot = wcschr(pcwszDNS, L'.');
    DWORD nLen;
    
    nLen = (pwszDot?
            SAFE_SUBTRACT_POINTERS(pwszDot, pcwszDNS):
            wcslen(pcwszDNS))+1;

    *ppcwszMachineName = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*nLen);
    _JumpIfAllocFailed(*ppcwszMachineName, error);

    wcsncpy(*ppcwszMachineName, pcwszDNS, nLen);

    (*ppcwszMachineName)[nLen-1] = L'\0';

    hr = S_OK;

error:
    return hr;
}

HRESULT myLdapFindComputerInForest(
    IN LDAP *pld,
    IN LPCWSTR pwszMachineDNS,
    OUT LPWSTR *ppwszURL)
{
    HRESULT hr;
    LPWSTR pwszAttrArray[] = {
        wszDSDNATTRIBUTE, 
        wszDSNAMEATTRIBUTE, 
        wszDSDNSHOSTNAMEATTRIBUTE,
        NULL};
    LDAPMessage* pResult = NULL;
    LDAPMessage *pEntry;
    LPWSTR *pwszValue = NULL;
    LPWSTR *pwszName = NULL;
    LPWSTR *pwszDNSHostName = NULL;
    LPWSTR pwszFilterFormat1 = L"(&(objectCategory=computer)(name=%s))";
    LPWSTR pwszFilterFormat2 = L"(&(objectCategory=computer)(dNSHostName=%s))";
    LPWSTR pwszFilter = NULL;
    LPWSTR pwszMachineName = NULL;
    bool fMachineNameIsInDNSFormat;

    // First, try to find the machine based on the DNS name prefix, which usually
    // matches the computer object name

    hr = ExtractMachineNameFromDNSName(
        pwszMachineDNS,
        &pwszMachineName);
    _JumpIfError(hr, error, "ExtractMachineNameFromDNSName");

    // if extracted name and dns name don't match, then we were called
    // with a DNS name
    fMachineNameIsInDNSFormat = (0!=wcscmp(pwszMachineDNS, pwszMachineName));

    pwszFilter = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*
        (wcslen(pwszFilterFormat1)+wcslen(pwszMachineName)+1));
    _JumpIfAllocFailed(pwszFilter, error);

    wsprintf(pwszFilter, pwszFilterFormat1, pwszMachineName);

    hr = ldap_search_s(
                    pld,
                    NULL,
                    LDAP_SCOPE_SUBTREE,
                    pwszFilter,
                    pwszAttrArray,
                    0,
                    &pResult);
    hr = myHLdapError(pld, hr, NULL);
    _JumpIfError(hr, error, "ldap_search_s");

    pEntry = ldap_first_entry(pld, pResult);
    if (NULL == pEntry)
    {
        hr = CRYPT_E_NOT_FOUND;
        _JumpError(hr, error, "ldap_first_entry");
    }

    pwszName = ldap_get_values(pld, pEntry, wszDSNAMEATTRIBUTE);
    if(pwszName && pwszName[0])
    {
        // found a matching object, but do DNS name match?
        pwszDNSHostName = ldap_get_values(pld, pEntry, wszDSDNSHOSTNAMEATTRIBUTE);

        if(fMachineNameIsInDNSFormat &&
           pwszDNSHostName &&
           pwszDNSHostName[0] &&
           0 != _wcsicmp(pwszDNSHostName[0], pwszMachineDNS))
        {
            // Couldn't find a computer object matching the DNS prefix, try searching
            // on dNSHostName. This attribute is not indexed so the searching will
            // be very slow
            
            LocalFree(pwszFilter);
            pwszFilter = NULL;

            ldap_msgfree(pResult);
            pResult = NULL;

            pEntry = NULL;

            pwszFilter = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*
                (wcslen(pwszFilterFormat2)+wcslen(pwszMachineDNS)+1));
            _JumpIfAllocFailed(pwszFilter, error);

            wsprintf(pwszFilter, pwszFilterFormat2, pwszMachineDNS);
            
            hr = ldap_search_s(
                            pld,
                            NULL,
                            LDAP_SCOPE_SUBTREE,
                            pwszFilter,
                            pwszAttrArray,
                            0,
                            &pResult);
            hr = myHLdapError(pld, hr, NULL);
            _JumpIfError(hr, error, "ldap_search_s");

            pEntry = ldap_first_entry(pld, pResult);
            if (NULL == pEntry)
            {
                hr = CRYPT_E_NOT_FOUND;
                _JumpError(hr, error, "ldap_first_entry");
            }
        }
    }

    pwszValue = ldap_get_values(pld, pEntry, wszDSDNATTRIBUTE);
    
    if(pwszValue)
    {
        hr = myDupString(pwszValue[0], ppwszURL);
        _JumpIfError(hr, error, "myDupString");
    }

error:

    if(pwszValue)
    {
        ldap_value_free(pwszValue);
    }
    if(pwszName)
    {
        ldap_value_free(pwszName);
    }
    if(pwszMachineName)
    {
        LocalFree(pwszMachineName);
    }
    if(pwszFilter)
    {
        LocalFree(pwszFilter);
    }
    if (NULL != pResult)
    {
        ldap_msgfree(pResult);
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
// The following code loads a list of certificates from a DS object (eg 
// AIA CACertificate property), filters out unwanted certs and writes it
// back to DS.
//
// Certs are loaded into a data structure that looks like this:
//
// CFilteredCertList 
//         |
//      CCertBucket1->CCertBucket2->...->CertBucketn
//             |                               |
//         CCertItem1->CertItem2->...       CCertItem1->CCertItem2->...
//
// Each cert bucket has a list of certs that match some criteria, in our
// case they share the same subject and public key. 
//
// After filtering, the buckets in the list must contain:
//
//    if only expired certs were found with this subject&key 
//        keep the most recent expired cert
//    else
//        keep all valid certs only
//
// For that, we process one cert context at a time. The filtering algorithm is:
//
//   if no matching bucket (same subj & key) found
//       create a new bucket it
//   else
//       if cert is expired 
//           if bucket contains only expired certs and 
//              this cert is newer
//                   replace cert in bucket
//       else
//           if bucket contains expired certs
//               replace cert in bucket
//           else
//               add cert to bucket

///////////////////////////////////////////////////////////////////////////////
// CCertItem: wrapper for one certificate context
class CCertItem
{
public:
    CCertItem(PCCERT_CONTEXT pcc) :
      m_pcc(pcc), m_fExpired(false) {}
    ~CCertItem()
    {
        CleanupCertContext();
    }

    void SetExpired(bool fExpired) { m_fExpired = fExpired; }
    void SetCertContext(PCCERT_CONTEXT pccNew)
    {
        CleanupCertContext();
        m_pcc = pccNew;
    }
    PCCERT_CONTEXT GetCertContext() { return m_pcc; }
    bool IsExpired() { return m_fExpired; }

private:
    void CleanupCertContext()
    { 
        if(m_pcc)
            CertFreeCertificateContext(m_pcc);
    }

    PCCERT_CONTEXT m_pcc;
    bool m_fExpired;
};
typedef TPtrList<CCertItem> CERTITEMLIST;
typedef TPtrListEnum<CCertItem> CERTITEMLISTENUM;


///////////////////////////////////////////////////////////////////////////////
// CCertBucket: bucket of certificates with same subject and publick key
class CCertBucket
{
public:

    CCertItem *GetFirstCert() 
    { 
        return m_CertList.GetAt(0); 
    }
    bool AddToBucket(CCertItem *pCertItem) 
    { 
        return m_CertList.AddHead(pCertItem);
    }
    bool CCertBucket::ReplaceBucket(CCertItem *pCertItem)
    {
        m_CertList.Cleanup();
        return m_CertList.AddHead(pCertItem);
    }
    bool InitBucket(CCertItem *pCertItem)
    {
        return m_CertList.AddHead(pCertItem);
    }

    friend class CFilteredCertList;

private:
    CERTITEMLIST m_CertList;
};
typedef TPtrList<CCertBucket> CERTBUCKETLIST;
typedef TPtrListEnum<CCertBucket> CERTBUCKETLISTENUM;


///////////////////////////////////////////////////////////////////////////////
// CFilteredCertList: list of certificate buckets (one bucket contains certs 
// with same subject and public key). Upon insertion we follow the algorithm
// described above. 
//
// To change the filtering behavior, derive from this class and override 
// InsertCert method.
class CFilteredCertList
{
public:
    CFilteredCertList()  {};
    ~CFilteredCertList() {};
    bool InsertCert(CCertItem *pCertItem);
    int GetCount();
    HRESULT ImportFromBervals(struct berval **pBervals);
    HRESULT ExportToBervals(struct berval **&pBervals);

protected:
    CCertBucket * FindBucket(CCertItem *pCertItem);
    bool AddNewBucket(CCertItem *pCertItem);
    bool BelongsToBucket(CCertBucket *pCertBucket, CCertItem *pCertItem);
    bool ReplaceBucket(CCertItem *pCertItem);
    bool InsertCertInBucket(CCertBucket *pCertBucket, CCertItem *pCertItem);

private:
    CERTBUCKETLIST m_BucketList;
};

///////////////////////////////////////////////////////////////////////////////
// CFilteredCertList methods

int CFilteredCertList::GetCount()
{
    int nCount = 0;

    CERTBUCKETLISTENUM BucketListEnum(m_BucketList);
    CCertBucket * pBucket;
    for(pBucket = BucketListEnum.Next();
        pBucket;
        pBucket = BucketListEnum.Next())
    {
        nCount += pBucket->m_CertList.GetCount();
    }

    return nCount;
}

bool CFilteredCertList::BelongsToBucket(
    CCertBucket *pCertBucket, 
    CCertItem *pCertItem)
{
    PCCERT_CONTEXT pCertContext1 = 
        pCertBucket->GetFirstCert()->GetCertContext();
    PCCERT_CONTEXT pCertContext2 = 
        pCertItem->GetCertContext();

    // belongs to this bucket if subject and public key match
    return
        (0 == memcmp(
            pCertContext1->pCertInfo->Subject.pbData,
            pCertContext2->pCertInfo->Subject.pbData,
            pCertContext1->pCertInfo->Subject.cbData)) &&
        (0 == memcmp(
            pCertContext1->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pCertContext2->pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
            pCertContext1->pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData));
}

///////////////////////////////////////////////////////////////////////////////
CCertBucket *CFilteredCertList::FindBucket(CCertItem *pCertItem)
{
    CERTBUCKETLISTENUM BucketListEnum(m_BucketList);
    CCertBucket * pBucket;
    for(pBucket = BucketListEnum.Next();
        pBucket;
        pBucket = BucketListEnum.Next())
    {
        if(BelongsToBucket(pBucket, pCertItem))
            return pBucket;
    }

    return NULL;
}

///////////////////////////////////////////////////////////////////////////////
bool CFilteredCertList::AddNewBucket(CCertItem *pCertItem)
{
    CCertBucket *pBucket = new CCertBucket();
    if(!pBucket->InitBucket(pCertItem))
        return false;

    if(m_BucketList.AddHead(pBucket))
    {
        return true;
    }
    else
    {
        return false;
    }
}

///////////////////////////////////////////////////////////////////////////////
bool CFilteredCertList::InsertCertInBucket(
    CCertBucket *pCertBucket, 
    CCertItem *pCertItem)
{
    bool fRet = false;
    CCertItem * pFirstCert = pCertBucket->GetFirstCert();
//  if cert is expired
    if(pCertItem->IsExpired())
    {
//      if bucket contains only expired certs and 
//         this cert is newer
        if(pFirstCert->IsExpired() &&
           0 < CompareFileTime(
               &(pCertItem->GetCertContext()->pCertInfo->NotAfter), 
               &(pFirstCert->GetCertContext()->pCertInfo->NotAfter)))
        {
//          replace cert in bucket
            fRet = pCertBucket->ReplaceBucket(pCertItem);
        }
    }
    else
    {
//      if bucket contains expired certs
        if(pFirstCert->IsExpired())
        {
//          replace cert in bucket
            fRet = pCertBucket->ReplaceBucket(pCertItem);
        }
        else
        {
//          add cert to bucket
            fRet = pCertBucket->AddToBucket(pCertItem);
        }
    }

    return fRet;

}

bool CFilteredCertList::InsertCert(CCertItem *pCertItem)
{
    CCertBucket *pBucket;

    pBucket = FindBucket(pCertItem);

//   if no matching bucket (same subj & key) found
//       create a new bucket it
    if(!pBucket)
    {
        return AddNewBucket(pCertItem);
    }
    else
    {
        return InsertCertInBucket(pBucket, pCertItem);
    }
}


///////////////////////////////////////////////////////////////////////////////
// Loads cert contexts from LDAP structure, an array of pointers to 
// berval structs which hold cert blobs.

HRESULT
CFilteredCertList::ImportFromBervals(
    struct berval **pBervals)
{
    HRESULT hr;
    PCCERT_CONTEXT pcc;
    int i;
    FILETIME ft;

    // Consider old certs that are one minute old
    GetSystemTimeAsFileTime(&ft);
    myMakeExprDateTime(&ft, -1, ENUM_PERIOD_MINUTES);

    for (i = 0; NULL != pBervals[i]; i++)
    {
        struct berval *pberval = pBervals[i];        
        pcc = CertCreateCertificateContext(
                X509_ASN_ENCODING,
                (BYTE *) pberval->bv_val,
                pberval->bv_len);
        if (NULL == pcc)
        {
            // not a valid cert, ignore
            _PrintError(myHLastError(), "CreateCertificateContext");
            continue;
        }

        CCertItem * pci = new CCertItem(pcc); // CCertItem takes ownership
        _JumpIfAllocFailed(pci, error);       // of this cert context and will
                                              // CertFreeCertificateContext in 
                                              // destructor
        pci->SetExpired(
            0 > CompareFileTime(&pcc->pCertInfo->NotAfter, &ft));

        if(!InsertCert(pci)) // InsertCert returns true if cert
        {                    // was added to the list, in which case
            delete pcc;      // the list destructor will cleanup.
        }                    // If not, we need to delete explicitely
    }
    hr = S_OK;

error:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Builds an LDAP structure from the list of certs, to be written back to DS. 
// LDAP struct is an array of pointers to struct bervals structures, terminated 
// with a NULL pointer. We allocate the pointer array and the space for berval 
// structs in one call.
// Caller is responsible for LocalFree'ing pBervals.
HRESULT CFilteredCertList::ExportToBervals(struct berval **&pBervals)
{
    HRESULT hr;
    CERTBUCKETLISTENUM BucketListEnum(m_BucketList);
    CCertBucket *pBucket;
    int i;
    DWORD dwSize;
    struct berval *pBervalData;

    // total size of pointers array plus size of array of berval structs
    dwSize = (GetCount()+1) * sizeof(pBervals[0]) +
            GetCount() * sizeof(struct berval);

    pBervals = (struct berval **) LocalAlloc(LMEM_FIXED, dwSize);
    _JumpIfAllocFailed(pBervals, error);

    // starting address for the berval arrays
    pBervalData = (struct berval *)(pBervals+GetCount()+1);

    for(i=0, pBucket = BucketListEnum.Next();
        pBucket;
        pBucket = BucketListEnum.Next())
    {
        CERTITEMLISTENUM CertListEnum(pBucket->m_CertList);
        CCertItem *pCertItem;

        for(pCertItem = CertListEnum.Next();
            pCertItem;
            i++, pCertItem = CertListEnum.Next())
        {
            // set the pointer to the associated berval struct
            pBervals[i] = pBervalData+i;
            // init the berval struct
            pBervalData[i].bv_val = (char *) 
                pCertItem->GetCertContext()->pbCertEncoded;
            pBervalData[i].bv_len = pCertItem->GetCertContext()->cbCertEncoded;
        }
    }

    pBervals[i] = NULL;

    hr = S_OK;

error:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Loads the certificate blobs stored in the specified object&property, filters
// them and writes them back to DS. 
// Filtering keeps all valid certificates and no expired certs. If only expired 
// have been found, it keeps the most recent one.

HRESULT
myLdapFilterCertificates(
    IN LDAP *pld,
    IN LPCWSTR pcwszDN,
    IN LPCWSTR pcwszAttribute,
    OUT DWORD *pdwDisposition,
    OPTIONAL OUT WCHAR **ppwszError)
{
    HRESULT hr;
    DWORD cres;
    LONG cber;
    DWORD i;
    LDAP_TIMEVAL timeval;
    LDAPMessage *pmsg = NULL;
    LDAPMessage *pres;
    WCHAR *apwszAttrs[2];
    struct berval **ppberval = NULL;
    struct berval **prgpberVals = NULL;
    CFilteredCertList NewCertList;
    CAutoLPWSTR strDN;
    LPWSTR pcwszSuffix; // no free

    *pdwDisposition = LDAP_OTHER;
    if (NULL != ppwszError)
    {
        *ppwszError = NULL;
    }

    hr = TrimURLDN(pcwszDN, &pcwszSuffix, &strDN);
    _JumpIfError(hr, error, "TrimURLDN");


    apwszAttrs[0] = const_cast<WCHAR *>(pcwszAttribute);
    apwszAttrs[1] = NULL;

    timeval.tv_sec = csecLDAPTIMEOUT;
    timeval.tv_usec = 0;

    hr = ldap_search_st(
        pld,				// ld
        strDN,	// base
        LDAP_SCOPE_BASE,		// scope
        NULL,				// filter
        apwszAttrs,			// attrs
        FALSE,				// attrsonly
        &timeval,			// timeout
        &pmsg);				// res
    if (S_OK != hr)
    {
        *pdwDisposition = hr;
        hr = myHLdapError(pld, hr, NULL);
        _JumpErrorStr(hr, error, "ldap_search_st", pcwszDN);
    }

    cres = ldap_count_entries(pld, pmsg);
    if (0 == cres)
    {
        // No entries were found.

        hr = NTE_NOT_FOUND;
        _JumpError(hr, error, "ldap_count_entries");
    }

    pres = ldap_first_entry(pld, pmsg); 
    if (NULL == pres)
    {
        hr = NTE_NOT_FOUND;
        _JumpError(hr, error, "ldap_first_entry");
    }

    ppberval = ldap_get_values_len(
        pld,
        pres,
        const_cast<WCHAR *>(pcwszAttribute));


    if (NULL != ppberval)
    {
        // count entries
        cber = 0;
        for (i = 0; NULL != ppberval[i]; i++, cber++)
            NULL;

        // load and filter certs
        hr = NewCertList.ImportFromBervals(ppberval);
        _JumpIfError(hr, error, "ImportFromBervals");

        // if number of certs is the same, no need to write it back
        // (order doesn't matter)
        if (cber != NewCertList.GetCount())
        {
            // walk the list and copy the cert blobs
            hr = NewCertList.ExportToBervals(prgpberVals);
            _JumpIfError(hr, error, "ExportToBervals");
        
            // set disposition assuming there's nothing to do:

            *pdwDisposition = LDAP_ATTRIBUTE_OR_VALUE_EXISTS;

            LDAPMod *mods[2];
            LDAPMod certmod;

            mods[0] = &certmod;
            mods[1] = NULL;

            certmod.mod_op = LDAP_MOD_BVALUES | LDAP_MOD_REPLACE;
            certmod.mod_type = const_cast<WCHAR *>(pcwszAttribute);
            certmod.mod_bvalues = prgpberVals;

            hr = ldap_modify_ext_s(
                pld,
                strDN,
                mods,
                NULL,
                NULL);
            *pdwDisposition = hr;
            if (hr != S_OK)
            {
                hr = myHLdapError(pld, hr, ppwszError);
                _JumpError(hr, error, "ldap_modify_ext_s");
            }
        }
    }

    hr = S_OK;

error:
    if (NULL != prgpberVals)
    {
        LocalFree(prgpberVals);
    }
    if (NULL != ppberval)
    {
        ldap_value_free_len(ppberval);
    }
    if (NULL != pmsg)
    {
        ldap_msgfree(pmsg);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\mapi.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        mapi.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <ntlsa.h>

#define __dwFILE__	__dwFILE_CERTLIB_MAPI_CPP__


#define wszCERTMAPIINFO	L"CertServerMapiInfo"


void
InitLsaString(
    OUT LSA_UNICODE_STRING *plus,
    IN WCHAR const *pwsz,
    IN DWORD cb)
{
    if (MAXDWORD == cb)
    {
	cb = lstrlenW(pwsz) * sizeof(WCHAR);
    }

    plus->Buffer = const_cast<WCHAR *>(pwsz);
    plus->Length = (USHORT) cb;
    plus->MaximumLength = plus->Length + sizeof(WCHAR);
}


HRESULT
OpenPolicy(
    IN WCHAR const *pwszServerName,
    DWORD DesiredAccess,
    LSA_HANDLE *phPolicy)
{
    HRESULT hr;
    LSA_OBJECT_ATTRIBUTES oa;
    LSA_UNICODE_STRING ServerString;
    LSA_UNICODE_STRING *plusServer;

    ZeroMemory(&oa, sizeof(oa));

    plusServer = NULL;
    if (NULL != pwszServerName)
    {
        InitLsaString(&ServerString, pwszServerName, MAXDWORD);
        plusServer = &ServerString;
    }
    hr = LsaOpenPolicy(plusServer, &oa, DesiredAccess, phPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "LsaOpenPolicy");
    }
 
error:
    return(hr);
}


HRESULT
SaveString(
    IN WCHAR const *pwszIn,
    IN DWORD cwcIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwsz;

    *ppwszOut = NULL;
    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwcIn + 1) * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwsz, pwszIn, cwcIn * sizeof(WCHAR));
    pwsz[cwcIn] = L'\0';
    *ppwszOut = pwsz;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// myGetMapiInfo -- Retrieve a Name/Password from a global LSA secret
//+--------------------------------------------------------------------------

HRESULT
myGetMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR **ppwszProfileName,
    OUT WCHAR **ppwszLogonName,
    OUT WCHAR **ppwszPassword)
{
    HRESULT hr;
    LSA_HANDLE hPolicy;
    UNICODE_STRING lusSecretKeyName;
    UNICODE_STRING *plusSecretData = NULL;
    DWORD cwc;
    DWORD cwcProfileName;
    DWORD cwcLogonName;
    DWORD cwcPassword;
    WCHAR const *pwsz;
    WCHAR *pwszProfileName = NULL;
    WCHAR *pwszLogonName = NULL;
    WCHAR *pwszPassword = NULL;

    cwcProfileName = 0;
    cwcLogonName = 0;
    cwcPassword = 0;
    if (NULL == ppwszProfileName ||
	NULL == ppwszLogonName ||
	NULL == ppwszPassword)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "no data");
    }

    InitLsaString(&lusSecretKeyName, wszCERTMAPIINFO, MAXDWORD);

    hr = OpenPolicy(pwszServerName, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "OpenPolicy");
    }

    hr = LsaRetrievePrivateData(hPolicy, &lusSecretKeyName, &plusSecretData);
    LsaClose(hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_PrintError2(hr, "LsaRetrievePrivateData", STATUS_OBJECT_NAME_NOT_FOUND);
	if ((HRESULT) STATUS_OBJECT_NAME_NOT_FOUND == hr)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	_JumpError2(hr, error, "LsaRetrievePrivateData", hr);
    }

    if (NULL == plusSecretData || NULL == plusSecretData->Buffer)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	_JumpError(hr, error, "no data");
    }

    pwsz = (WCHAR const *) plusSecretData->Buffer;
    cwc = plusSecretData->Length / sizeof(WCHAR);

    for (cwcProfileName = 0; cwcProfileName < cwc; cwcProfileName++)
    {
	if (L'\0' == pwsz[cwcProfileName])
	{
	    break;
	}
    }
    if (cwcProfileName == cwc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad data");
    }

    for (cwcLogonName = cwcProfileName + 1; cwcLogonName < cwc; cwcLogonName++)
    {
	if (L'\0' == pwsz[cwcLogonName])
	{
	    break;
	}
    }
    if (cwcLogonName == cwc)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "bad data");
    }
    cwcLogonName -= cwcProfileName + 1;

    cwcPassword = cwc - (cwcProfileName + 1 + cwcLogonName + 1);

    hr = SaveString(pwsz, cwcProfileName, &pwszProfileName);
    _JumpIfError(hr, error, "SaveString");

    hr = SaveString(&pwsz[cwcProfileName + 1], cwcLogonName, &pwszLogonName);
    _JumpIfError(hr, error, "SaveString");

    hr = SaveString(
		&pwsz[cwcProfileName + 1 + cwcLogonName + 1],
		cwcPassword,
		&pwszPassword);
    _JumpIfError(hr, error, "SaveString");

    *ppwszProfileName = pwszProfileName;
    pwszProfileName = NULL;

    *ppwszLogonName = pwszLogonName;
    pwszLogonName = NULL;

    *ppwszPassword = pwszPassword;
    pwszPassword = NULL;

error:
    if (NULL != pwszProfileName)
    {
	SecureZeroMemory(pwszProfileName, cwcProfileName * sizeof(WCHAR));
	LocalFree(pwszProfileName);
    }
    if (NULL != pwszLogonName)
    {
	SecureZeroMemory(pwszLogonName, cwcLogonName * sizeof(WCHAR));
	LocalFree(pwszLogonName);
    }
    if (NULL != pwszPassword)
    {
	SecureZeroMemory(pwszPassword, cwcPassword * sizeof(WCHAR));
	LocalFree(pwszPassword);
    }
    if (NULL != plusSecretData)
    {
	if (NULL != plusSecretData->Buffer)
	{
	    SecureZeroMemory(plusSecretData->Buffer, plusSecretData->Length);
	}
	LsaFreeMemory(plusSecretData);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// mySaveMapiInfo -- Persist the specified Name/Password to a global LSA secret
//+--------------------------------------------------------------------------

HRESULT
mySaveMapiInfo(
    OPTIONAL IN WCHAR const *pwszServerName,
    OUT WCHAR const *pwszProfileName,
    OUT WCHAR const *pwszLogonName,
    OUT WCHAR const *pwszPassword)
{
    HRESULT hr;
    LSA_HANDLE hPolicy;
    UNICODE_STRING lusSecretKeyName;
    UNICODE_STRING lusSecretData;
    WCHAR wszSecret[MAX_PATH];
    DWORD cwc;
    WCHAR *pwsz;

    if (NULL == pwszProfileName ||
	NULL == pwszLogonName ||
	NULL == pwszPassword)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    cwc = lstrlen(pwszProfileName) + 1 +
	    lstrlen(pwszLogonName) + 1 +
	    lstrlen(pwszPassword);

    if (ARRAYSIZE(wszSecret) <= cwc)
    {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
	_JumpError(hr, error, "overflow");
    }
    pwsz = wszSecret;
    wcscpy(pwsz, pwszProfileName);

    pwsz += lstrlen(pwsz) + 1;
    wcscpy(pwsz, pwszLogonName);

    pwsz += lstrlen(pwsz) + 1;
    wcscpy(pwsz, pwszPassword);

    InitLsaString(&lusSecretData, wszSecret, cwc * sizeof(WCHAR));
    InitLsaString(&lusSecretKeyName, wszCERTMAPIINFO, MAXDWORD);

    hr = OpenPolicy(pwszServerName, POLICY_CREATE_SECRET, &hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "OpenPolicy");
    }

    hr = LsaStorePrivateData(hPolicy, &lusSecretKeyName, &lusSecretData);
    LsaClose(hPolicy);
    if (!NT_SUCCESS(hr))
    {
	_JumpError(hr, error, "LsaStorePrivateData");
    }
    hr = S_OK;

error:
    SecureZeroMemory(wszSecret, sizeof(wszSecret));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\multisz.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop
#include "tfc.h"
#include "multisz.h"


#define __dwFILE__	__dwFILE_CERTLIB_MULTISZ_CPP__

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CMultiSz
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////


//
// Marshals the list into a multisz buffer. The function allocates space, caller
// is responsible for LocalFree'ing rpBuffer.
//
// Also returns the buffer size in bytes.
//
HRESULT CMultiSz::Marshal(void *&rpBuffer, DWORD &rcbBuffer)
{
    HRESULT hr;
    CMultiSzEnum Enum(*this);
    DWORD cbBuffer;
    void *pBuffer;
    WCHAR *pwszBuf;

    rcbBuffer = 0;
    rpBuffer = NULL;

    cbBuffer = 1; // trailing empty string

    for(CString *pStr=Enum.Next();
        pStr;
        pStr=Enum.Next())
    {
        cbBuffer += pStr->GetLength()+1;
    }

    cbBuffer *= sizeof(WCHAR);

    pBuffer = LocalAlloc(LMEM_FIXED, cbBuffer);
    _JumpIfAllocFailed(pBuffer, error);

    pwszBuf = (WCHAR*)pBuffer;

    Enum.Reset();

    for(CString *pStr=Enum.Next();
        pStr;
        pStr=Enum.Next())
    {
        wcscpy(pwszBuf, *pStr);
        pwszBuf += wcslen(*pStr)+1;
    }

    *pwszBuf = L'\0';

    rcbBuffer = cbBuffer;
    rpBuffer = pBuffer;
    hr = S_OK;

error:
    return hr;
}

HRESULT CMultiSz::Unmarshal(void *pBuffer)
{
    HRESULT hr;
    WCHAR *pchCrt;

    CSASSERT(IsEmpty()); // warn if used on a prepopulated CMultiSz

    for(pchCrt = (WCHAR*)pBuffer; 
        L'\0' != *pchCrt; 
        pchCrt += wcslen(pchCrt)+1)
    {
        CString *pStr = new CString(pchCrt);
        if(!pStr || 
            pStr->IsEmpty() ||
           !AddTail(pStr))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "");
        }
    }

    hr = S_OK;

error:
    return hr;
}

bool CMultiSz::Find(LPCWSTR pcwszValue, bool fCaseSensitive)
{
    CMultiSzEnum ISAPIDependListEnum(*this);
    const CString *pStr;

    for(pStr = ISAPIDependListEnum.Next();
        pStr;
        pStr = ISAPIDependListEnum.Next())
    {
        if(0 == (fCaseSensitive?
                 wcscmp(pcwszValue, *pStr):
                _wcsicmp(pcwszValue, *pStr)))
            return true;
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\poldisp.cpp ===
#include <pch.cpp>
#pragma hdrstop
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__      __dwFILE_CERTLIB_POLDISP_CPP__

//+------------------------------------------------------------------------
// ICertPolicy dispatch support


//+------------------------------------
// VerifyRequest method:

OLECHAR *_apszVerifyRequest[] = {
    TEXT("VerifyRequest"),
    TEXT("strConfig"),
    TEXT("Context"),
    TEXT("bNewRequest"),
    TEXT("Flags")
};


//+------------------------------------
// GetDescription method:

OLECHAR *_apszGetDescription[] = {
    TEXT("GetDescription"),
};


//+------------------------------------
// Initialize method:

OLECHAR *_apszInitialize[] = {
    TEXT("Initialize"),
    TEXT("strConfig"),
};


//+------------------------------------
// ShutDown method:

OLECHAR *_apszShutDown[] = {
    TEXT("ShutDown"),
};


//+------------------------------------
// GetManageModule method:

OLECHAR *_apszGetManageModule[] = {
    TEXT("GetManageModule"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtPolicy[] =
{
    DECLARE_DISPATCH_ENTRY(_apszVerifyRequest)
    DECLARE_DISPATCH_ENTRY(_apszGetDescription)
    DECLARE_DISPATCH_ENTRY(_apszInitialize)
    DECLARE_DISPATCH_ENTRY(_apszShutDown)
    DECLARE_DISPATCH_ENTRY(_apszGetManageModule)
};


DWORD CPOLICYDISPATCH = (ARRAYSIZE(g_adtPolicy));

DWORD s_acPolicyDispatch[2] = {
    CPOLICYDISPATCH_V2,
    CPOLICYDISPATCH_V1,
};

IID const *s_apPolicyiid[2] = {
    &IID_ICertPolicy2,
    &IID_ICertPolicy,
};


HRESULT
PolicyVerifyVersion(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiPolicy && NULL != pdiPolicy->pDispatchTable);

    switch (pdiPolicy->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiPolicy->pDispatch ||
		CPOLICYDISPATCH_V1 == pdiPolicy->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiPolicy->pDispatch ||
		CPOLICYDISPATCH_V2 == pdiPolicy->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiPolicy->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Policy_Init(
    IN DWORD Flags,
    IN LPCWSTR pcwszProgID,
    IN CLSID const *pclsid,
    OUT DISPATCHINTERFACE *pdi)
{
    HRESULT hr;

    hr = DispatchSetup2(
                Flags,
                CLSCTX_INPROC_SERVER,
                pcwszProgID, // g_wszRegKeyCIPolicyClsid,
                pclsid,
                ARRAYSIZE(s_acPolicyDispatch),
                s_apPolicyiid,
                s_acPolicyDispatch,
                g_adtPolicy,
                pdi);
    _JumpIfError(hr, error, "DispatchSetup");

    pdi->pDispatchTable = g_adtPolicy;

error:
    return(hr);
}


VOID
Policy_Release(
    IN OUT DISPATCHINTERFACE *pdiManage)
{
    DispatchRelease(pdiManage);
}


HRESULT
Policy_Initialize(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    hr = S_OK;
    __try
    {
	if (NULL != pdiPolicy->pDispatch)
	{
	    VARIANT avar[1];

	    CSASSERT(NULL != pdiPolicy->pDispatchTable);
	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;

	    hr = DispatchInvoke(
			    pdiPolicy,
			    POLICY_INITIALIZE,
			    ARRAYSIZE(avar),
			    avar,
			    0,
			    NULL);
	    _LeaveIfError(hr, "Invoke(Initialize)");
	}
	else
	{
	    hr = ((ICertPolicy *) pdiPolicy->pUnknown)->Initialize(strConfig);
	    _LeaveIfError(hr, "ICertPolicy::Initialize");
	}
    }
    _finally
    {
	if (NULL != strConfig)
	{
	    SysFreeString(strConfig);
	}
    }

error:
    return(hr);
}


HRESULT
Policy_ShutDown(
    IN DISPATCHINTERFACE *pdiPolicy)
{
    HRESULT hr;

    if (NULL != pdiPolicy->pDispatch)
    {
	CSASSERT(NULL != pdiPolicy->pDispatchTable);

	hr = DispatchInvoke(
			pdiPolicy,
			POLICY_SHUTDOWN,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(ShutDown)");
    }
    else
    {
	hr = ((ICertPolicy *) pdiPolicy->pUnknown)->ShutDown();
	_JumpIfError(hr, error, "ICertPolicy::ShutDown");
    }

error:
    return(hr);
}


HRESULT
Policy_VerifyRequest(
    IN DISPATCHINTERFACE *pdiPolicy,
    IN WCHAR const *pwszConfig,
    IN LONG Context,
    IN LONG bNewRequest,
    IN LONG Flags,
    OUT LONG *pResult)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	goto error;
    }
    hr = S_OK;
    __try
    {
	if (NULL != pdiPolicy->pDispatch)
	{
	    VARIANT avar[4];

	    CSASSERT(NULL != pdiPolicy->pDispatchTable);
	    avar[0].vt = VT_BSTR;
	    avar[0].bstrVal = strConfig;
	    avar[1].vt = VT_I4;
	    avar[1].lVal = Context;
	    avar[2].vt = VT_I4;
	    avar[2].lVal = bNewRequest;
	    avar[3].vt = VT_I4;
	    avar[3].lVal = Flags;

	    hr = DispatchInvoke(
			    pdiPolicy,
			    POLICY_VERIFYREQUEST,
			    ARRAYSIZE(avar),
			    avar,
			    VT_I4,
			    pResult);
	    _PrintIfError(hr, "Invoke(VerifyRequest)");

	    // Emulate the way C++ Policy Modules overload *pRequest with
	    // a FAILED HRESULT:

	    if (FAILED(hr))
	    {
		*pResult = hr;
		hr = S_OK;
	    }
	    _LeaveIfError(hr, "Invoke(VerifyRequest)");
	}
	else
	{
	    hr = ((ICertPolicy *) pdiPolicy->pUnknown)->VerifyRequest(
							    strConfig,
							    Context,
							    bNewRequest,
							    Flags,
							    pResult);
	    _LeaveIfError(hr, "ICertPolicy::VerifyRequest");
	}
    }
    _finally
    {
	if (NULL != strConfig)
	{
	    SysFreeString(strConfig);
	}
    }

error:
    return(hr);
}


HRESULT
Policy_GetDescription(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT BSTR *pstrDescription)
{
    HRESULT hr;

    if (NULL != pdiPolicy->pDispatch)
    {
	CSASSERT(NULL != pdiPolicy->pDispatchTable);

	hr = DispatchInvoke(
			pdiPolicy,
			POLICY_GETDESCRIPTION,
			0,
			NULL,
			VT_BSTR,
			pstrDescription);
	_JumpIfError(hr, error, "Invoke(GetDescription)");
    }
    else
    {
	hr = ((ICertPolicy *) pdiPolicy->pUnknown)->GetDescription(
							pstrDescription);
	_JumpIfError(hr, error, "ICertPolicy::GetDescription");
    }

error:
    return(hr);
}


HRESULT
Policy2_GetManageModule(
    IN DISPATCHINTERFACE *pdiPolicy,
    OUT DISPATCHINTERFACE *pdiManageModule)
{
    HRESULT hr;
    ICertManageModule *pManageModule = NULL;

    hr = PolicyVerifyVersion(pdiPolicy, 2);
    _JumpIfError(hr, error, "PolicyVerifyVersion");

    if (NULL != pdiPolicy->pDispatch)
    {
	CSASSERT(NULL != pdiPolicy->pDispatchTable);

	hr = DispatchInvoke(
			pdiPolicy,
			POLICY2_GETMANAGEMODULE,
			0,
			NULL,
			VT_DISPATCH,
			&pManageModule);
	_JumpIfError(hr, error, "Invoke(GetManageModule)");
    }
    else
    {
	hr = ((ICertPolicy2 *) pdiPolicy->pUnknown)->GetManageModule(
							&pManageModule);
	_JumpIfError(hr, error, "ICertPolicy::GetManageModule");
    }

    hr = ManageModule_Init2(
		NULL != pdiPolicy->pDispatch,
		pManageModule,
		pdiManageModule);
    _JumpIfError(hr, error, "ManageModule_Init2");

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certlib"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifndef MAXDWORD
# define MAXDWORD MAXULONG
#endif
#define CERT_CHAIN_PARA_HAS_EXTRA_FIELDS

#include <windows.h>
#include <wincrypt.h>
#include <setupapi.h>
#include <certsrv.h>
#include <aclapi.h>
#include "ocmanage.h"
#include "certlib.h"	            // debug allocator
#define SECURITY_WIN32
#include <security.h>
#include <sddl.h>
#define CERTLIB_BUILD

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\progress.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       progress.cpp
//
//--------------------------------------------------------------------------

// progress.cpp : implementation file
//

#include <pch.cpp>

#pragma hdrstop

#include "clibres.h"
#include "progress.h"

// defines

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum MYDIALOGBEHAVIORENUM
{
    enumPERCENTCOMPLETEBEHAVIOR = 0,
    enumPROGRESSBARWITHTIMEOUT,
};

typedef struct _PROGRESSPROC_LPARAM
{
    HINSTANCE           hInstance;
    HWND                hwndParent;
    UINT                iRscJobDescription;
    MYDIALOGBEHAVIORENUM enumWhichBehavior;
    DWORD               dwTickerUpperRange;
    DBBACKUPPROGRESS*   pdbp;
} PROGRESSPROC_LPARAM, *PPROGRESSPROC_LPARAM;


static BOOL s_fDisableProgressDialogs = 0;
static BOOL s_fIKnow = 0;

BOOL FICanShowDialogs()
{
   if (s_fIKnow != TRUE)
   {
      s_fIKnow = TRUE;
      DWORD dwVal;

      if (S_OK == myGetCertRegDWValue(
         NULL,
         NULL,
         NULL,
         L"DisableProgress",
         &dwVal))
      {
         s_fDisableProgressDialogs = (dwVal != 0);
      }
   }
   return ! s_fDisableProgressDialogs;
}



////////////////////////////////////////////////////////////////////////////////
// show a progress dialog

int     g_iTimeoutTicks = 0;
BOOL    g_fUseTimer;

INT_PTR CALLBACK dlgProcProgress(
    HWND hwndDlg,  
    UINT uMsg,     
    WPARAM, // wParam
    LPARAM lParam)
{
    PPROGRESSPROC_LPARAM pLParam = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            HWND hwndProgressBar;
            
            pLParam = (PPROGRESSPROC_LPARAM)lParam;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (ULONG_PTR)pLParam);

            hwndProgressBar = GetDlgItem(hwndDlg, IDD_PROGRESS_BAR);
			
            {
                RECT rcParent, rcDlg, rcScreenArea;
                GetWindowRect(pLParam->hwndParent, &rcParent);
            	GetWindowRect(hwndDlg, &rcDlg);
                SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcScreenArea, NULL);

                // calc centers
                int xLeft = (rcParent.left + rcParent.right) / 2 - (rcDlg.right - rcDlg.left) / 2;
                int yTop = (rcParent.top + rcParent.bottom) / 2 - (rcDlg.bottom - rcDlg.top) / 2;

                // careful: if the dialog is outside the screen, move it inside
                if (xLeft < rcScreenArea.left)
	                xLeft = rcScreenArea.left;
                else if (xLeft + (rcDlg.right - rcDlg.left) > rcScreenArea.right)
	                xLeft = rcScreenArea.right - (rcDlg.right - rcDlg.left);

                if (yTop < rcScreenArea.top)
	                yTop = rcScreenArea.top;
                else if (yTop + (rcDlg.bottom - rcDlg.top) > rcScreenArea.bottom)
	                yTop = rcScreenArea.bottom - (rcDlg.bottom - rcDlg.top);

                // map screen coordinates to child coordinates
                SetWindowPos(hwndDlg, HWND_TOPMOST, xLeft, yTop, -1, -1,
                    SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            }
    
            {
                DWORD dwStyle;
                dwStyle = GetWindowLong(hwndProgressBar, GWL_STYLE);
                SetWindowLong(hwndProgressBar, GWL_STYLE, (dwStyle | PBS_SMOOTH)); 
            }

            // Set the range and increment of the progress bar. 
            if (pLParam->enumWhichBehavior == enumPROGRESSBARWITHTIMEOUT)
            {
                SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, pLParam->dwTickerUpperRange));
                SendMessage(hwndProgressBar, PBM_SETSTEP, (WPARAM) 1, 0); 
            }
            else
            {
                SendMessage(hwndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 300));
            }
            SendMessage(hwndProgressBar, PBM_SETPOS, (WPARAM)0, 0);
            
            // set job description if specified
            if (pLParam->iRscJobDescription != 0)
            {
                WCHAR szJobDesc[MAX_PATH];
                if (0 != LoadString(
                             pLParam->hInstance,
                             pLParam->iRscJobDescription,
                             szJobDesc,
                             MAX_PATH))
                    SetDlgItemText(hwndDlg, IDC_JOB_DESCRIPTION, szJobDesc);
            }

            return 1;
        }
    case WM_DESTROY:
        {
            pLParam = (PPROGRESSPROC_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
            if (NULL == pLParam)
                break;

            SetForegroundWindow(pLParam->hwndParent);

            LocalFree(pLParam);
            pLParam = NULL;
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, NULL);
        }
    case PBM_STEPIT:
        {
            pLParam = (PPROGRESSPROC_LPARAM)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
            if (NULL == pLParam)
                break;

            HWND hwndProgressBar = GetDlgItem(hwndDlg, IDD_PROGRESS_BAR);

            if (pLParam->enumWhichBehavior == enumPROGRESSBARWITHTIMEOUT)
                SendMessage(hwndProgressBar, PBM_STEPIT, 0, 0);
            else
            {
                DWORD wProgress = pLParam->pdbp->dwDBPercentComplete + 
                                pLParam->pdbp->dwLogPercentComplete + 
                                pLParam->pdbp->dwTruncateLogPercentComplete ;
                
                DWORD wTop = (DWORD)SendMessage(hwndProgressBar,
		                                PBM_GETRANGE,
						FALSE,
						NULL);
                if (wProgress == wTop)
                {
		    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, S_FALSE);     // we're done!
                    return TRUE;
                }
                else
                    SendMessage(hwndProgressBar, PBM_SETPOS, wProgress, 0); // keep incrementing
            }


            break;
        }
    case PBM_SETPOS:
        {
            HWND hwndProgressBar = GetDlgItem(hwndDlg, IDD_PROGRESS_BAR);
            LRESULT wTop = SendMessage(hwndProgressBar, PBM_GETRANGE, FALSE, NULL);
            
            // if we're not yet at the top make it so
            if (wTop != SendMessage(hwndProgressBar, PBM_GETPOS, 0, 0))
            {
                SendMessage(hwndProgressBar, PBM_SETPOS, (WPARAM)wTop, 0);
                Sleep(400);
            }
        }
    default:
        break;
    }
    return 0;
}


#define PROGRESS_TICKS_PER_SEC 3

DWORD WINAPI StartTimerThread(  LPVOID lpParameter )
{
    if (FICanShowDialogs())
    { 
    PPROGRESSPROC_LPARAM  psParam = (PPROGRESSPROC_LPARAM)lpParameter;

    HWND hwndProgressDlg = CreateDialogParam(  
        psParam->hInstance,
        MAKEINTRESOURCE(IDD_PROGRESS_BOX),
        NULL,
        dlgProcProgress, 
        (LPARAM)lpParameter);
    if (NULL == hwndProgressDlg)
       return 0;

    ShowWindow(hwndProgressDlg, SW_SHOW);
    UpdateWindow(hwndProgressDlg);

    // if not timer based, go forever
    // if timer based, go while timersec is +
    while ((!g_fUseTimer) ||
           (g_iTimeoutTicks-- > 0))
    {
        SendMessage(hwndProgressDlg, PBM_STEPIT, 0, 0);
        UpdateWindow(hwndProgressDlg);
        Sleep(1000/PROGRESS_TICKS_PER_SEC);
    }

    // send "fill the indicator" 
    SendMessage(hwndProgressDlg, PBM_SETPOS, 0, 0);
    
    DestroyWindow(hwndProgressDlg);
    }
    return 0;
}

// callable APIs: Start/End ProgressDlg
BOOL FProgressDlgRunning()
{
    return (!g_fUseTimer || (g_iTimeoutTicks > 0));
}

HANDLE
StartProgressDlg(
    HINSTANCE hInstance,
    HWND      hwndParent,
    DWORD     dwTickerSeconds,
    DWORD     dwTimeoutSeconds,
    UINT      iRscJobDescription)
{
    HANDLE hProgressThread = NULL;
    DWORD dwThread;
    PPROGRESSPROC_LPARAM psParam = NULL;
    
    INITCOMMONCONTROLSEX sCommCtrl;
    sCommCtrl.dwSize = sizeof(sCommCtrl);
    sCommCtrl.dwICC = ICC_PROGRESS_CLASS;
    if (!InitCommonControlsEx(&sCommCtrl))
        goto Ret;

    g_fUseTimer = dwTimeoutSeconds != 0;
    g_iTimeoutTicks = (dwTimeoutSeconds * PROGRESS_TICKS_PER_SEC);
    
    // dialog frees this
    psParam = (PPROGRESSPROC_LPARAM)LocalAlloc(LMEM_FIXED, sizeof(PROGRESSPROC_LPARAM));
    if (psParam == NULL)
        goto Ret;

    psParam->hInstance = hInstance;
    psParam->hwndParent = hwndParent;
    psParam->enumWhichBehavior = enumPROGRESSBARWITHTIMEOUT;
    psParam->dwTickerUpperRange = dwTickerSeconds * PROGRESS_TICKS_PER_SEC;
    psParam->iRscJobDescription = iRscJobDescription;
    psParam->pdbp = NULL;


    hProgressThread = 
        CreateThread(
            NULL,
            0,
            StartTimerThread,
            (void*)psParam,
            0,
            &dwThread);
Ret:
    if (NULL == hProgressThread)
        LocalFree(psParam);

    return hProgressThread;
}

void EndProgressDlg(HANDLE hProgressThread)
{
    // end countdown immediately
    g_iTimeoutTicks = 0;
    if (!g_fUseTimer)
    {
        // make the controlling thread suddenly aware of the timer
        g_fUseTimer = TRUE;
    }

    // don't return until we're certain the progress dlg is gone
    for (;;)
    {
        DWORD dwExitCode;
        // break on error
        if (!GetExitCodeThread(hProgressThread, &dwExitCode) )
            break;

        // continue until goes away
        if (STILL_ACTIVE != dwExitCode)
            break;

        Sleep(100);
    }

    CloseHandle(hProgressThread);
}

///////////////////////////////////////////////////////
// %age complete progress indicator

DWORD WINAPI StartPercentCompleteThread(  LPVOID lpParameter )
{
    if (FICanShowDialogs())
    {
    PPROGRESSPROC_LPARAM  psParam = (PPROGRESSPROC_LPARAM)lpParameter;

    HWND hwndProgressDlg = CreateDialogParam(  
        psParam->hInstance,
        MAKEINTRESOURCE(IDD_PROGRESS_BOX),
        NULL,
        dlgProcProgress, 
        (LPARAM)lpParameter);

if (NULL == hwndProgressDlg) {GetLastError(); return 0;}

    ShowWindow(hwndProgressDlg, SW_SHOW);
    Sleep(0);

    for (;;)
    {
        if (ERROR_SUCCESS != SendMessage(hwndProgressDlg, PBM_STEPIT, 0, 0))
            break;

        UpdateWindow(hwndProgressDlg);
        Sleep(0);
        Sleep(1000/PROGRESS_TICKS_PER_SEC);
    }

    // send "fill the indicator" 
    SendMessage(hwndProgressDlg, PBM_SETPOS, 0, 0);
    
    DestroyWindow(hwndProgressDlg);
    }

    return 0;
}

HANDLE
StartPercentCompleteDlg(
    HINSTANCE  hInstance,
    HWND       hwndParent,
    UINT       iRscJobDescription,
    DBBACKUPPROGRESS *pdbp)
{
    HANDLE hProgressThread = NULL;
    DWORD dwThread;
    PPROGRESSPROC_LPARAM psParam = NULL;

    g_fUseTimer = FALSE;
    g_iTimeoutTicks = 0;    // no timeout

    INITCOMMONCONTROLSEX sCommCtrl;
    sCommCtrl.dwSize = sizeof(sCommCtrl);
    sCommCtrl.dwICC = ICC_PROGRESS_CLASS;
    if (!InitCommonControlsEx(&sCommCtrl))
        goto Ret;

    // dialog frees this
    psParam = (PPROGRESSPROC_LPARAM)LocalAlloc(LMEM_FIXED, sizeof(PROGRESSPROC_LPARAM));
    if (psParam == NULL)
        goto Ret;

    psParam->hInstance = hInstance;
    psParam->hwndParent = hwndParent;
    psParam->enumWhichBehavior = enumPERCENTCOMPLETEBEHAVIOR;
    psParam->dwTickerUpperRange = 300;
    psParam->iRscJobDescription = iRscJobDescription;
    psParam->pdbp = pdbp;
    
    hProgressThread = 
        CreateThread(
            NULL,
            0,
            StartPercentCompleteThread,
            (void*)psParam,
            0,
            &dwThread);
Ret:
    if (NULL == hProgressThread)
        LocalFree(psParam);

    return hProgressThread;
}

void EndPercentCompleteDlg(HANDLE hProgressThread)
{
    // don't return until we're certain the progress dlg is gone
    for (;;)
    {
        DWORD dwExitCode;
        // break on error
        if (!GetExitCodeThread(hProgressThread, &dwExitCode) )
            break;

        // continue until goes away
        if (STILL_ACTIVE != dwExitCode)
            break;

        Sleep(100);
    }

    CloseHandle(hProgressThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\prop2.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       prop2.cpp
//
//  Contents:   ICertAdmin2 & ICertRequest2 IDispatch helper functions
//
//--------------------------------------------------------------------------

#define __dwFILE__	__dwFILE_CERTLIB_PROP2_CPP__

#if defined(CCERTADMIN)

# define CAPropWrapper(IFAdmin, IFRequest, Method) IFAdmin##_##Method
# define ICertProp2		ICertAdmin2
# define szICertProp2		"ICertAdmin2"

#elif defined(CCERTREQUEST)

# define CAPropWrapper(IFAdmin, IFRequest, Method) IFRequest##_##Method
# define ICertProp2		ICertRequest2
# define szICertProp2		"ICertRequest2"

#else
# error -- CCERTADMIN or CCERTREQUEST must be defined
#endif

#define szInvokeICertProp2(szMethod)	"Invoke(" szICertProp2 "::" szMethod ")"


HRESULT
CAPropWrapper(Admin2, Request2, GetCAProperty)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,		// CR_OUT_*
    OUT VOID *pPropertyValue)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiProp && NULL != pdiProp->pDispatchTable);

    switch (PropType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropType");
    }

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiProp->pDispatch)
    {
	VARIANT avar[5];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropId;

	avar[2].vt = VT_I4;
	avar[2].lVal = PropIndex;

	avar[3].vt = VT_I4;
	avar[3].lVal = PropType;

	avar[4].vt = VT_I4;
	avar[4].lVal = Flags;

	hr = DispatchInvoke(
			pdiProp,
			CAPropWrapper(ADMIN2, REQUEST2, GETCAPROPERTY),
			ARRAYSIZE(avar),
			avar,
			RetType,
			pPropertyValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"%hs: Config=%ws PropId=%x Index=%x Type=%x Flags=%x\n",
		szInvokeICertProp2("GetCAProperty"),
		pwszConfig,
		PropId,
		PropIndex,
		PropType,
		Flags));
	}
	_JumpIfError(hr, error, szInvokeICertProp2("GetCAProperty"));
    }
    else
    {
	hr = ((ICertProp2 *) pdiProp->pUnknown)->GetCAProperty(
						    strConfig,
						    PropId,
						    PropIndex,
						    PropType,
						    Flags,
						    &varResult);
	_JumpIfError3(
		    hr,
		    error,
		    szICertProp2 "::GetCAProperty",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		    E_INVALIDARG);

	hr = DispatchGetReturnValue(&varResult, RetType, pPropertyValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    VariantClear(&varResult);
    return(hr);
}


HRESULT
CAPropWrapper(Admin2, Request2, GetCAPropertyFlags)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT LONG *pPropFlags)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiProp && NULL != pdiProp->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiProp->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropId;

	hr = DispatchInvoke(
			pdiProp,
			CAPropWrapper(ADMIN2, REQUEST2, GETCAPROPERTYFLAGS),
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pPropFlags);
	_JumpIfError(hr, error, szInvokeICertProp2("GetCAPropertyFlags"));
    }
    else
    {
	hr = ((ICertProp2 *) pdiProp->pUnknown)->GetCAPropertyFlags(
						    strConfig,
						    PropId,
						    pPropFlags);
	_JumpIfError(hr, error, szICertProp2 "::GetCAPropertyFlags");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
CAPropWrapper(Admin2, Request2, GetCAPropertyDisplayName)(
    IN DISPATCHINTERFACE *pdiProp,
    IN WCHAR const *pwszConfig,
    IN LONG PropId,
    OUT BSTR *pstrDisplayName)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiProp && NULL != pdiProp->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiProp->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropId;

	hr = DispatchInvoke(
		    pdiProp,
		    CAPropWrapper(ADMIN2, REQUEST2, GETCAPROPERTYDISPLAYNAME),
		    ARRAYSIZE(avar),
		    avar,
		    VT_BSTR,
		    pstrDisplayName);
	_JumpIfError(hr, error, szInvokeICertProp2("GetCAPropertyDisplayName"));
    }
    else
    {
	hr = ((ICertProp2 *) pdiProp->pUnknown)->GetCAPropertyDisplayName(
						    strConfig,
						    PropId,
						    pstrDisplayName);
	_JumpIfError(hr, error, szICertProp2 "::GetCAPropertyDisplayName");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\rwlock.cpp ===
#include <pch.cpp>
#pragma hdrstop

#include "rwlock.h"
using namespace CertSrv;

/////////////////////////////////////////////////////////////////////////////
CReadWriteLock::CReadWriteLock()
{
    RtlInitializeResource(&m_RtlLock);
}

/////////////////////////////////////////////////////////////////////////////
CReadWriteLock::~CReadWriteLock()
{
    RtlDeleteResource(&m_RtlLock);
}

/////////////////////////////////////////////////////////////////////////////
void CReadWriteLock::GetExclusive()
{
    RtlAcquireResourceExclusive(&m_RtlLock, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
void CReadWriteLock::GetShared()
{
    RtlAcquireResourceShared(&m_RtlLock, TRUE);
}

/////////////////////////////////////////////////////////////////////////////
void CReadWriteLock::Release()
{
    RtlReleaseResource(&m_RtlLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\officer.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        officer.cpp
//
// Contents:    officer rights implementation
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <certsd.h>
#include <certacl.h>
#include <sid.h>

#define __dwFILE__	__dwFILE_CERTLIB_OFFICER_CPP__


using namespace CertSrv;

HRESULT
COfficerRightsSD::Merge(
        PSECURITY_DESCRIPTOR pOfficerSD,
        PSECURITY_DESCRIPTOR pCASD)
{

    HRESULT hr;
    PACL pCAAcl; // no free
    PACL pOfficerAcl; // no free
    PACL pNewOfficerAcl = NULL;
    ACL_SIZE_INFORMATION CAAclInfo, OfficerAclInfo;
    PBOOL pCAFound = NULL, pOfficerFound = NULL;
    DWORD cCAAce, cOfficerAce;
    PACCESS_ALLOWED_ACE pCAAce;
    PACCESS_ALLOWED_CALLBACK_ACE pOfficerAce;
    PACCESS_ALLOWED_CALLBACK_ACE pNewAce = NULL;
    DWORD dwNewAclSize = sizeof(ACL);
    PSID pSidEveryone = NULL, pSidBuiltinAdministrators = NULL;
    DWORD dwSidEveryoneSize, dwAceSize, dwSidSize;
    PSID_LIST pSidList;
    PSECURITY_DESCRIPTOR pNewOfficerSD = NULL;
    ACL EmptyAcl;
    SECURITY_DESCRIPTOR EmptySD;

    CSASSERT(NULL==pOfficerSD || IsValidSecurityDescriptor(pOfficerSD));
    CSASSERT(IsValidSecurityDescriptor(pCASD));

    // allow NULL officer SD, in that case build an empty SD and use it
    if(NULL==pOfficerSD)
    {
        if(!InitializeAcl(&EmptyAcl, sizeof(ACL), ACL_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeAcl");
        }
   
        if (!InitializeSecurityDescriptor(&EmptySD, SECURITY_DESCRIPTOR_REVISION))
        {
            hr = myHLastError();
            _JumpError(hr, error, "InitializeSecurityDescriptor");
        }

        if(!SetSecurityDescriptorDacl(
            &EmptySD,
            TRUE, // DACL present
            &EmptyAcl,
            FALSE)) // DACL defaulted
        {
            hr = myHLastError();
            _JumpError(hr, error, "SetSecurityDescriptorControl");
        }

        pOfficerSD = &EmptySD;
    }

    hr = myGetSecurityDescriptorDacl(pCASD, &pCAAcl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    hr = myGetSecurityDescriptorDacl(pOfficerSD, &pOfficerAcl);
    _JumpIfError(hr, error, "myGetSecurityDescriptorDacl");

    // allocate a bool array for each DACL

    if(!GetAclInformation(pCAAcl,
                          &CAAclInfo,
                          sizeof(CAAclInfo),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }
    if(!GetAclInformation(pOfficerAcl,
                          &OfficerAclInfo,
                          sizeof(OfficerAclInfo),
                          AclSizeInformation))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }

    pCAFound = (PBOOL)LocalAlloc(LMEM_FIXED, sizeof(BOOL)*CAAclInfo.AceCount);
    if(!pCAFound)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(pCAFound, sizeof(BOOL)*CAAclInfo.AceCount);

    pOfficerFound = (PBOOL)LocalAlloc(LMEM_FIXED, sizeof(BOOL)*OfficerAclInfo.AceCount);
    if(!pOfficerFound)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    ZeroMemory(pOfficerFound, sizeof(BOOL)*OfficerAclInfo.AceCount);

    hr = GetEveryoneSID(&pSidEveryone);
    _JumpIfError(hr, error, "GetEveryoneSID");

    dwSidEveryoneSize = GetLengthSid(pSidEveryone);

    // mark in the bool arrays each ace whose SID is found in both DACLs;
    // also mark CA ACEs we are not interested in (denied ACEs and 
    // non-officer ACEs)

    for(cCAAce=0; cCAAce<CAAclInfo.AceCount; cCAAce++)
    {
        if(!GetAce(pCAAcl, cCAAce, (PVOID*)&pCAAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }
        
        // process only officer allow aces
        if(0==(pCAAce->Mask & CA_ACCESS_OFFICER))
        {
            pCAFound[cCAAce] = TRUE;
            continue;
        }

        // compare SIDs in each officer ace with current CA ace and mark 
        // corresponding bool in arrays if equal
        for(cOfficerAce=0; cOfficerAce<OfficerAclInfo.AceCount; cOfficerAce++)
        {
            if(!GetAce(pOfficerAcl, cOfficerAce, (PVOID*)&pOfficerAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }
            if(EqualSid((PSID)&pOfficerAce->SidStart,
                (PSID)&pCAAce->SidStart))
            {
                pCAFound[cCAAce] = TRUE;
                pOfficerFound[cOfficerAce] = TRUE;
            }
        }
        
        // if the officer is found in the CA ACL but not in the officer ACL,
        // we will add a new ACE allowing him to manage certs for Everyone
        if(!pCAFound[cCAAce])
        {
            dwNewAclSize += sizeof(ACCESS_ALLOWED_CALLBACK_ACE)+
                GetLengthSid((PSID)&pCAAce->SidStart)+
                dwSidEveryoneSize;
        }
    }

    // Calculate the size of the new officer ACL; we already added in the header
    // size and the size of the new ACEs to be added. Now we add the ACEs to be
    // copied over from the old ACL
    for(cOfficerAce=0; cOfficerAce<OfficerAclInfo.AceCount; cOfficerAce++)
    {
        if(pOfficerFound[cOfficerAce])
        {
            if(!GetAce(pOfficerAcl, cOfficerAce, (PVOID*)&pOfficerAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }
            dwNewAclSize += pOfficerAce->Header.AceSize;
        }
    }

    // allocate a new DACL

    pNewOfficerAcl = (PACL)LocalAlloc(LMEM_FIXED, dwNewAclSize);
    if(!pNewOfficerAcl)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

#ifdef _DEBUG
    ZeroMemory(pNewOfficerAcl, dwNewAclSize);
#endif 

    if(!InitializeAcl(pNewOfficerAcl, dwNewAclSize, ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }

    // build the new DACL

    // traverse officer DACL and add only marked ACEs (whose SID was found
    // in the CA DACL, ie principal is an officer)
    for(cOfficerAce=0; cOfficerAce<OfficerAclInfo.AceCount; cOfficerAce++)
    {
        if(pOfficerFound[cOfficerAce])
        {
            if(!GetAce(pOfficerAcl, cOfficerAce, (PVOID*)&pOfficerAce))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }

            if(!AddAce(
                pNewOfficerAcl,
                ACL_REVISION,
                MAXDWORD,
                pOfficerAce,
                pOfficerAce->Header.AceSize))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetAce");
            }
        }
    }

    CSASSERT(IsValidAcl(pNewOfficerAcl));

    hr = GetBuiltinAdministratorsSID(&pSidBuiltinAdministrators);
    _JumpIfError(hr, error, "GetBuiltinAdministratorsSID");
    
    // traverse the CA DACL and add a new officer to list, allowed to manage
    // Everyone
    for(cCAAce=0; cCAAce<CAAclInfo.AceCount; cCAAce++)
    {
        if(pCAFound[cCAAce])
            continue;

        if(!GetAce(pCAAcl, cCAAce, (PVOID*)&pCAAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        // create a new ACE
        dwSidSize = GetLengthSid((PSID)&pCAAce->SidStart);

        dwAceSize = sizeof(ACCESS_ALLOWED_CALLBACK_ACE)+
            dwSidEveryoneSize+dwSidSize;

        pNewAce = (ACCESS_ALLOWED_CALLBACK_ACE*) LocalAlloc(LMEM_FIXED, dwAceSize);
        if(!pNewAce)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
#ifdef _DEBUG
        ZeroMemory(pNewAce, dwAceSize);
#endif 

        pNewAce->Header.AceType = ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
        pNewAce->Header.AceFlags= 0;
        pNewAce->Header.AceSize = (USHORT)dwAceSize;
        pNewAce->Mask = DELETE;
        CopySid(dwSidSize,
            (PSID)&pNewAce->SidStart,
            (PSID)&pCAAce->SidStart);
        pSidList = (PSID_LIST)(((BYTE*)&pNewAce->SidStart)+dwSidSize);
        pSidList->dwSidCount = 1;
        
        CopySid(dwSidEveryoneSize,
            (PSID)&pSidList->SidListStart,
            pSidEveryone);

        CSASSERT(IsValidSid((PSID)&pNewAce->SidStart));
        
        if(!AddAce(
            pNewOfficerAcl,
            ACL_REVISION,
            MAXDWORD,
            pNewAce,
            dwAceSize))
        {
            hr = myHLastError();
            _JumpError(hr, error, "AddAce");
        }

        LocalFree(pNewAce);
        pNewAce = NULL;
    }

    CSASSERT(IsValidAcl(pNewOfficerAcl));

    // setup the new security descriptor
    
    pNewOfficerSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LMEM_FIXED,
                                      SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (pNewOfficerSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
#ifdef _DEBUG
    ZeroMemory(pNewOfficerSD, SECURITY_DESCRIPTOR_MIN_LENGTH);
#endif 

    if (!InitializeSecurityDescriptor(pNewOfficerSD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    if(!SetSecurityDescriptorOwner(
        pNewOfficerSD,
        pSidBuiltinAdministrators,
        FALSE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    if(!SetSecurityDescriptorDacl(
        pNewOfficerSD,
        TRUE, // DACL present
        pNewOfficerAcl,
        FALSE)) // DACL defaulted
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorDacl");
    }

    CSASSERT(IsValidSecurityDescriptor(pNewOfficerSD));

    hr = Set(pNewOfficerSD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    if(pNewAce)
    {
        LocalFree(pNewAce);
    }

    if(pSidEveryone)
    {
        FreeSid(pSidEveryone);
    }

    if(pSidBuiltinAdministrators)
    {
        FreeSid(pSidBuiltinAdministrators);
    }

    if(pNewOfficerAcl)
    {
        LocalFree(pNewOfficerAcl);
    }

    if(pNewOfficerSD)
    {
        LocalFree(pNewOfficerSD);
    }

    return hr;
}

HRESULT 
COfficerRightsSD::Adjust(PSECURITY_DESCRIPTOR pCASD)
{
    return Merge(Get(), pCASD);
}

HRESULT
COfficerRightsSD::InitializeEmpty()
{
    HRESULT hr = S_OK;
    ACL Acl;
    SECURITY_DESCRIPTOR SD;

    hr = Init(NULL);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Init");

    if(!InitializeAcl(&Acl, sizeof(ACL), ACL_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeAcl");
    }
   
    if (!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION))
    {
        hr = myHLastError();
        _JumpError(hr, error, "InitializeSecurityDescriptor");
    }

    if(!SetSecurityDescriptorDacl(
        &SD,
        TRUE, // DACL present
        &Acl,
        FALSE)) // DACL defaulted
    {
        hr = myHLastError();
        _JumpError(hr, error, "SetSecurityDescriptorControl");
    }

    m_fInitialized = true;

    hr = Set(&SD);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Set");

error:
    return hr;
}

HRESULT COfficerRightsSD::Save()
{
    HRESULT hr = S_OK;

    if(IsEnabled())
    {
        hr = CProtectedSecurityDescriptor::Save();
        _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");
    }
    else
    {
        hr = CProtectedSecurityDescriptor::Delete();
        _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Delete");
    }

error:
    return hr;
}

HRESULT COfficerRightsSD::Load()
{
    HRESULT hr;
    
    hr = CProtectedSecurityDescriptor::Load();
    if(S_OK==hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        SetEnable(S_OK==hr);
        hr = S_OK;
    }
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");

error:
    return hr;
}

HRESULT COfficerRightsSD::Initialize(LPCWSTR pwszSanitizedName)
{
    HRESULT hr;
    
    hr = CProtectedSecurityDescriptor::Initialize(pwszSanitizedName);
    _JumpIfError(hr, error, "CProtectedSecurityDescriptor::Save");

    SetEnable(NULL!=m_pSD);

error:
    return hr;
}

HRESULT COfficerRightsSD::ConvertToString(
    IN PSECURITY_DESCRIPTOR pSD,
    OUT LPWSTR& rpwszSD)
{
    HRESULT hr = S_OK;
    LPCWSTR pcwszHeader = L"\n"; // start with a new line
    DWORD dwBufSize = sizeof(WCHAR)*(wcslen(pcwszHeader)+1);
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwIndex;
    PACCESS_ALLOWED_CALLBACK_ACE pAce; // no free
    PACL pDacl; // no free
    LPWSTR pwszAce; // no free

    CSASSERT(IsValidSecurityDescriptor(pSD));
    
    rpwszSD = NULL;

    // get acl
    hr = myGetSecurityDescriptorDacl(
             pSD,
             &pDacl);
    _JumpIfError(hr, error, "myGetDaclFromInfoSecurityDescriptor");

    if(!GetAclInformation(pDacl,
                          &AclInfo,
                          sizeof(ACL_SIZE_INFORMATION),
                          AclSizeInformation))   
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetAclInformation");
    }
    
    
    // calculate text size

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            NULL);
        _JumpIfError(hr, error, "ConvertAceToString");

        dwBufSize += dwAceSize;
    }

    rpwszSD = (LPWSTR)LocalAlloc(LMEM_FIXED, dwBufSize);
    _JumpIfAllocFailed(rpwszSD, error);

    // build the output string
    wcscpy(rpwszSD, pcwszHeader);
    
    pwszAce = rpwszSD + wcslen(pcwszHeader);

    for(dwIndex = 0;  dwIndex < AclInfo.AceCount; dwIndex++) 
    {
        DWORD dwAceSize;
        if(!GetAce(pDacl, dwIndex, (LPVOID*)&pAce))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetAce");
        }

        hr = ConvertAceToString(
            pAce,
            &dwAceSize,
            pwszAce);
        _JumpIfError(hr, error, "ConvertAceToString");

        pwszAce += dwAceSize/sizeof(WCHAR);
    }

error:
    return hr;
}

// Returned string has the following format:
//
// [Allow|Deny]\t[OfficerName|SID]\n
// \t[Client1Name|SID]\n
// \t[Client2Name|SID]\n
// ...
//
// Example:
//
// Allow    OfficerGroup1
//      ClientGroup1
//      ClientGroup2
//
// If SID cannot be converted to friendly name it is displayed
// as a string SID
//
HRESULT COfficerRightsSD::ConvertAceToString(
    IN PACCESS_ALLOWED_CALLBACK_ACE pAce,
    OUT OPTIONAL PDWORD pdwSize,
    IN OUT OPTIONAL LPWSTR pwszSD)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 1; // trailing '\0'
    CSid sid((PSID)(&pAce->SidStart));
    PSID_LIST pSidList = (PSID_LIST) (((BYTE*)&pAce->SidStart)+
        GetLengthSid(&pAce->SidStart));
    PSID pSid;
    DWORD cSids;
    
    LPCWSTR pcwszAllow      = m_pcwszResources[0];
    LPCWSTR pcwszDeny       = m_pcwszResources[1];

    LPCWSTR pcwszPermissionType = 
        (ACCESS_ALLOWED_CALLBACK_ACE_TYPE==pAce->Header.AceType)?
        pcwszAllow:pcwszDeny;
    LPCWSTR pcwszSid; // no free

    // asked for size and/or ace string
    CSASSERT(pdwSize || pwszSD);

    if(pAce->Header.AceType != ACCESS_ALLOWED_CALLBACK_ACE_TYPE &&
       pAce->Header.AceType != ACCESS_DENIED_CALLBACK_ACE_TYPE)
    {
        return E_INVALIDARG;
    }

    pcwszSid = sid.GetName();
    if(!pcwszSid)
    {
        return E_OUTOFMEMORY;
    }
    
    dwSize = wcslen(pcwszSid);

    dwSize += wcslen(pcwszPermissionType);
    
    dwSize += 2; // '\t' between sid an permission and a '\n' after

    if(pwszSD)
    {
        wcscat(pwszSD, pcwszPermissionType);
        wcscat(pwszSD, L"\t");
        wcscat(pwszSD, pcwszSid);
        wcscat(pwszSD, L"\n");
    }

    for(pSid=(PSID)&pSidList->SidListStart, cSids=0; cSids<pSidList->dwSidCount;
        cSids++, pSid = (PSID)(((BYTE*)pSid)+GetLengthSid(pSid)))
    {
        CSASSERT(IsValidSid(pSid));

        CSid sidClient(pSid);
        LPCWSTR pcwszSidClient;
        
        pcwszSidClient = sidClient.GetName();
        if(!pcwszSidClient)
        {
            return E_OUTOFMEMORY;
        }

        dwSize += wcslen(pcwszSidClient) + 2; // \tClientNameOrSid\n
        
        if(pwszSD)
        {
            wcscat(pwszSD, L"\t");
            wcscat(pwszSD, pcwszSidClient);
            wcscat(pwszSD, L"\n");
        }
    }

    dwSize *= sizeof(WCHAR);

    if(pdwSize)
    {
        *pdwSize = dwSize;
    }

    return hr;
}

HRESULT 
CertSrv::GetWellKnownSID(
    PSID *ppSid,
    SID_IDENTIFIER_AUTHORITY *pAuth,
    BYTE  SubauthorityCount,
    DWORD SubAuthority1,
    DWORD SubAuthority2,
    DWORD SubAuthority3,
    DWORD SubAuthority4,
    DWORD SubAuthority5,
    DWORD SubAuthority6,
    DWORD SubAuthority7,
    DWORD SubAuthority8)
{
    HRESULT hr = S_OK;

    // build Everyone SID
    if(!AllocateAndInitializeSid(
            pAuth,
            SubauthorityCount,
            SubAuthority1,
            SubAuthority2,
            SubAuthority3,
            SubAuthority4,
            SubAuthority5,
            SubAuthority6,
            SubAuthority7,
            SubAuthority8,
            ppSid))
    {
        hr = myHLastError();
        _JumpError(hr, error, "AllocateAndInitializeSid");
    }

error:
    return hr;
}

// caller is responsible for LocalFree'ing PSID
HRESULT CertSrv::GetEveryoneSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_WORLD_SID_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        1,
        SECURITY_WORLD_RID);
}
// caller is responsible for LocalFree'ing PSID
HRESULT CertSrv::GetLocalSystemSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        1,
        SECURITY_LOCAL_SYSTEM_RID);
}

// caller is responsible for LocalFree'ing PSID
HRESULT CertSrv::GetBuiltinAdministratorsSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        2,
        SECURITY_BUILTIN_DOMAIN_RID,
        DOMAIN_ALIAS_RID_ADMINS);
}

HRESULT CertSrv::GetLocalSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth =  SECURITY_LOCAL_SID_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        1,
        SECURITY_LOCAL_RID);
}

HRESULT CertSrv::GetNetworkSID(PSID *ppSid)
{
    SID_IDENTIFIER_AUTHORITY SIDAuth =  SECURITY_NT_AUTHORITY;
    return GetWellKnownSID(
        ppSid,
        &SIDAuth,
        1,
        SECURITY_NETWORK_RID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\reg.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        reg.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <sddl.h>
#include <assert.h>

#include "certacl.h"
#include "polreg.h"

#define __dwFILE__	__dwFILE_CERTLIB_REG_CPP__


HRESULT
myFormCertRegPath(
    IN  WCHAR const *pwszName1,
    IN  WCHAR const *pwszName2,
    IN  WCHAR const *pwszName3,
    IN  BOOL         fConfigLevel,  // from CertSrv if FALSE
    OUT WCHAR      **ppwszPath)
{
    HRESULT  hr;
    WCHAR   *pwszPath = NULL;
    DWORD    len1;
    DWORD    len2;
    DWORD    len3;

    len1 = NULL != pwszName1 ? wcslen(pwszName1) + 1 : 0;
    len2 = 0 != len1 && NULL != pwszName2 ? wcslen(pwszName2) + 1 : 0;
    len3 = 0 != len2 && NULL != pwszName3 ? wcslen(pwszName3) + 1 : 0;

    pwszPath = (WCHAR*)LocalAlloc(
			    LMEM_FIXED | LMEM_ZEROINIT,
			    ((fConfigLevel?
				WSZARRAYSIZE(wszREGKEYCONFIGPATH) :
				WSZARRAYSIZE(wszREGKEYCERTSVCPATH)) +
			     len1 +
			     len2 +
			     len3 +
			     1) * sizeof(WCHAR));
    if (NULL == pwszPath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    wcscpy(pwszPath, fConfigLevel? wszREGKEYCONFIGPATH : wszREGKEYCERTSVCPATH);

    if (NULL != pwszName1)
    {
        wcscat(pwszPath, L"\\");
        wcscat(pwszPath, pwszName1);
        if (NULL != pwszName2)
        {
            wcscat(pwszPath, L"\\");
            wcscat(pwszPath, pwszName2);
            if (NULL != pwszName3)
            {
                wcscat(pwszPath, L"\\");
                wcscat(pwszPath, pwszName3);
            }
        }
    }

    *ppwszPath = pwszPath;
    pwszPath = NULL;

    hr = S_OK;
error:
    if (NULL != pwszPath)
    {
        LocalFree(pwszPath);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myDeleteCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN BOOL                  fAbsolutePath)
{
    HRESULT  hr;
    HKEY     hKey = NULL;
    WCHAR    *pwszTemp = NULL;

    if (!fAbsolutePath)
    {
        hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, TRUE, &pwszTemp);
        _JumpIfError(hr, error, "myFormCertRegPath");
    }
    else
    {
        CSASSERT(NULL == pwszName2 && NULL == pwszName3);
    }

    hr = RegOpenKeyEx(
		    HKEY_LOCAL_MACHINE,
		    fAbsolutePath ? pwszName1 : pwszTemp,
		    0,
		    KEY_ALL_ACCESS,
		    &hKey);
    _JumpIfError(hr, error, "RegOpenKeyEx");

    hr = RegDeleteValue(hKey, pwszValueName);
    if ((HRESULT) ERROR_FILE_NOT_FOUND != hr)
    {
	_JumpIfError(hr, error, "RegDeleteValue");
    }
    hr = S_OK;

error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return(myHError(hr));
}


HRESULT
myDeleteCertRegValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName)
{
    return myDeleteCertRegValueEx(pwszName1,
                                  pwszName2,
                                  pwszName3,
                                  pwszValueName,
                                  FALSE);
}

HRESULT
myDeleteCertRegKeyEx(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel)
{
    HRESULT  hr;
    WCHAR    *pwszTemp = NULL;

    hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, fConfigLevel, &pwszTemp);
    _JumpIfError(hr, error, "myFormCertRegPath");

    hr = RegDeleteKey(
		    HKEY_LOCAL_MACHINE,
		    pwszTemp);
    _JumpIfError(hr, error, "RegDeleteKey");

    hr = S_OK;
error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    return(myHError(hr));
}


HRESULT
myDeleteCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3)
{
    return myDeleteCertRegKeyEx(pwszName1, pwszName2, pwszName3, TRUE);
}


HRESULT
myCreateCertRegKeyEx(
    IN BOOL                  fSetAcl,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3)
{
    HRESULT  hr;
    HKEY     hKey = NULL;
    DWORD    dwDisposition;
    WCHAR    *pwszTemp = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;

    hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, TRUE, &pwszTemp);
    _JumpIfError(hr, error, "myFormCertRegPath");

    hr = RegCreateKeyEx(
		    HKEY_LOCAL_MACHINE,
		    pwszTemp,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    if (fSetAcl)
    {
        // construct correct reg acl for the key if upgrade
        hr = myGetSDFromTemplate(WSZ_DEFAULT_UPGRADE_SECURITY,
                                 NULL,
                                 &pSD);
        if (S_OK == hr)
        {
            // set to correct acl
            hr = RegSetKeySecurity(hKey,
                                   DACL_SECURITY_INFORMATION,
                                   pSD);
            _PrintIfErrorStr(hr, "RegSetKeySecurity",  pwszTemp);
        }
        else
        {
            _PrintErrorStr(hr, "myGetSDFromTemplate",  pwszTemp);
        }
    }

    hr = S_OK;
error:
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    if (NULL != pSD)
    {
        LocalFree(pSD);
    }
    return(myHError(hr));
}

HRESULT
myCreateCertRegKey(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3)
{
    return myCreateCertRegKeyEx(FALSE,  // not upgrade
                                pwszName1,
                                pwszName2,
                                pwszName3);
}

HRESULT
mySetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath)
{
    HRESULT  hr;
    HKEY     hKey = NULL;
    WCHAR    *pwszTemp = NULL;
    DWORD    dwDisposition;
    HKEY     hBaseKey = NULL;
    DWORD    cbD = cbData;

    if (!fAbsolutePath)
    {
        hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, fConfigLevel, &pwszTemp);
        _JumpIfError(hr, error, "myFormCertRegPath");
    }

    if (pwszMachine)
    {
        hr = RegConnectRegistry(pwszMachine, HKEY_LOCAL_MACHINE, &hBaseKey);
        _JumpIfErrorStr(hr, error, "RegConnectRegistry", pwszMachine);
    }
    else
        hBaseKey = HKEY_LOCAL_MACHINE;

    hr = RegCreateKeyEx(
		    hBaseKey,
		    fAbsolutePath ? pwszName1 : pwszTemp,
		    0,
		    NULL,
		    REG_OPTION_NON_VOLATILE,
		    KEY_ALL_ACCESS,
		    NULL,
		    &hKey,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    if (NULL != pwszValueName)
    {
        if(NULL == pbData || 0 == cbData)
        {
            switch(dwValueType)
            {
            case REG_EXPAND_SZ:
            case REG_SZ:
                pbData = (BYTE*) L"";
                cbD    = sizeof (L"");
                break;
            case REG_MULTI_SZ:
                pbData = (BYTE*) L"\0";
                cbD    = sizeof (L"\0");
                break;
            }
        }
        hr = RegSetValueEx(
	        hKey,
	        pwszValueName,
	        0,
	        dwValueType,
	        pbData,
	        cbD);
        _JumpIfError(hr, error, "RegSetValueEx");
    }

    hr = S_OK;
error:
    if ((NULL != hBaseKey) && (HKEY_LOCAL_MACHINE != hBaseKey))
    {
        RegCloseKey(hBaseKey);
    }
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return(myHError(hr));
}

HRESULT
mySetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValueType,
    IN BYTE const           *pbData,
    IN DWORD const           cbData,
    IN BOOL                  fAbsolutePath)
{
    return mySetCertRegValueEx(pwszMachine,
                               pwszName1,
                               pwszName2,
                               pwszName3,
                               TRUE, //from Configuration
                               pwszValueName,
                               dwValueType,
                               pbData,
                               cbData,
                               fAbsolutePath);
}

HRESULT
myRegQueryValueEx(
  IN HKEY hKey,
  IN LPCTSTR pwszValueName,
  OUT LPDWORD pValueType,
  OUT LPBYTE *ppbData,
  OUT LPDWORD pcbData)
{
    HRESULT hr;
    DWORD dwType;
    DWORD dwLen;
    BYTE *pbData = NULL;
    DWORD cbZero = 0;

    *ppbData = NULL;
    if (NULL != pcbData)
    {
        *pcbData = 0;
    }
    if (NULL != pValueType)
    {
        *pValueType = REG_NONE;
    }

    for (;;)
    {
	hr = RegQueryValueEx(
		        hKey,
		        pwszValueName,
		        0,
		        &dwType,
		        pbData,
		        &dwLen);
	_JumpIfErrorStr2(
		    hr,
		    error,
		    "RegQueryValueEx",
		    pwszValueName,
		    ERROR_FILE_NOT_FOUND);

        if (NULL != pbData)
        {
	    ZeroMemory(&pbData[dwLen], cbZero);
            break;
        }

        // Enforce WCHAR-aligned double null termination for malformed values.
        // Some callers need to treat REG_SZ values as REG_MULTI_SZ.

        if (REG_MULTI_SZ == dwType || REG_SZ == dwType)
        {
            cbZero = 2 * sizeof(WCHAR);
            if (dwLen & (sizeof(WCHAR) - 1))
            {
                cbZero++;
            }
        }
        pbData = (BYTE *) LocalAlloc(LMEM_FIXED, dwLen + cbZero);
        if (NULL == pbData)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }
    if (NULL != pValueType)
    {
        *pValueType = dwType;
    }
    if (NULL != pcbData)
    {
        *pcbData = dwLen;
    }
    *ppbData = pbData;
    hr = S_OK;

error:
    return(myHError(hr));
}

HRESULT
myGetCertRegValueEx(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN BOOL                  fConfigLevel,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType)
{
    HRESULT hr;
    HKEY hKey = NULL;
    WCHAR *pwszTemp = NULL;
    HKEY hBaseKey = NULL;

    hr = myFormCertRegPath(pwszName1, pwszName2, pwszName3, fConfigLevel, &pwszTemp);
    _JumpIfError(hr, error, "myFormCertRegPath");

    if (pwszMachine)
    {
        hr = RegConnectRegistry(pwszMachine, HKEY_LOCAL_MACHINE, &hBaseKey);
        _JumpIfErrorStr(hr, error, "RegConnectRegistry", pwszMachine);
    }
    else
        hBaseKey = HKEY_LOCAL_MACHINE;

    hr = RegOpenKeyEx(
		    hBaseKey,
		    pwszTemp,
		    0,
		    KEY_READ,
		    &hKey);
    _JumpIfError2(hr, error, "RegOpenKeyEx", ERROR_FILE_NOT_FOUND);

    hr = myRegQueryValueEx(
		        hKey,
		        pwszValueName,
		        pValueType,
		        ppbData,
		        pcbData);
    _JumpIfErrorStr2(
		hr,
		error,
		"myRegQueryValueEx",
		pwszValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

error:
    if ((NULL != hBaseKey) && (hBaseKey != HKEY_LOCAL_MACHINE))
    {
        RegCloseKey(hBaseKey);
    }
    if (NULL != pwszTemp)
    {
        LocalFree(pwszTemp);
    }
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return(myHError(hr));
}

HRESULT
myGetCertRegValue(
    OPTIONAL IN WCHAR const *pwszMachine,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbData,
    OPTIONAL OUT DWORD      *pcbData,
    OPTIONAL OUT DWORD      *pValueType)
{
    return myGetCertRegValueEx(pwszMachine,
                               pwszName1,
                               pwszName2,
                               pwszName3,
                               TRUE, //from Configuration
                               pwszValueName,
                               ppbData,
                               pcbData,
                               pValueType);
}

HRESULT
mySetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszzValue)
{
    DWORD cwc = 0;
    DWORD cwcT;
    WCHAR const *pwc;

    if (NULL != pwszzValue)
    {
	for (pwc = pwszzValue; L'\0' != *pwc; cwc += cwcT, pwc += cwcT)
	{
	    cwcT = wcslen(pwc) + 1;
	}
	cwc++;
    }

    return(mySetCertRegValue(
			 NULL,
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 REG_MULTI_SZ,
			 (BYTE const *) pwszzValue,
			 cwc * sizeof(WCHAR),
			 FALSE));
}


HRESULT
mySetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszValue)
{
    DWORD cwc = 0;

    if (NULL != pwszValue)
    {
        cwc = wcslen(pwszValue) + 1;
    }
    return mySetCertRegValue(
			 NULL,
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 REG_SZ,
			 (BYTE const *) pwszValue,
			 cwc * sizeof(WCHAR),
			 FALSE);
}


HRESULT
mySetAbsRegMultiStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszzValue)
{
    DWORD cwc = 0;
    DWORD cwcT;
    WCHAR const *pwc;

    if (NULL != pwszzValue)
    {
	for (pwc = pwszzValue; L'\0' != *pwc; cwc += cwcT, pwc += cwcT)
	{
	    cwcT = wcslen(pwc) + 1;
	}
	cwc++;
    }
    return(mySetCertRegValue(
			 NULL,
			 pwszName,
			 NULL,
			 NULL,
			 pwszValueName,
			 REG_MULTI_SZ,
			 (BYTE const *) pwszzValue,
			 cwc * sizeof(WCHAR),
			 TRUE));
}


HRESULT
mySetAbsRegStrValue(
    IN WCHAR const *pwszName,
    IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszValue)
{
    DWORD cwc = 0;

    if (NULL != pwszValue)
    {
        cwc = wcslen(pwszValue) + 1;
    }
    return mySetCertRegValue(
			 NULL,
			 pwszName,
			 NULL,
			 NULL,
			 pwszValueName,
			 REG_SZ,
			 (BYTE const *)pwszValue,
			 cwc*sizeof(WCHAR),
			 TRUE);
}


HRESULT
mySetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValue)
{
    return mySetCertRegValue(
			 NULL,
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 REG_DWORD,
			 (BYTE const *)&dwValue,
			 sizeof(DWORD),
			 FALSE);
}


HRESULT
myGetCertRegMultiStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    OUT WCHAR               **ppwszzValue)
{
    HRESULT hr;
    DWORD dwType;

    hr = myGetCertRegValue(
		       NULL,
		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       (BYTE **) ppwszzValue,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (REG_MULTI_SZ != dwType && REG_SZ != dwType)
    {
	LocalFree(*ppwszzValue);
	*ppwszzValue = NULL;

	hr = E_INVALIDARG;
	_JumpError(hr, error, "not REG_SZ or REG_MULTI_SZ");
    }
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}

HRESULT
myGetCertRegBinaryValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT BYTE               **ppbValue)
{
    HRESULT hr;
    DWORD dwType;

    hr = myGetCertRegValue(
		       NULL,
 		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       ppbValue,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszName1,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (REG_BINARY != dwType)
    {
        LocalFree(*ppbValue);
        *ppbValue = NULL;

        hr = E_INVALIDARG;
        _JumpError(hr, error, "not REG_BINARY");
    }
    hr = S_OK;

error:
    return hr;
}

HRESULT
myGetCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT WCHAR               **ppwszValue)
{
    HRESULT hr;
    DWORD dwType;

    hr = myGetCertRegValue(
		       NULL,
 		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       (BYTE **) ppwszValue,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszName1,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    if (REG_SZ != dwType)
    {
        LocalFree(*ppwszValue);
        *ppwszValue = NULL;

        hr = E_INVALIDARG;
        _JumpError(hr, error, "not REG_SZ");
    }
    hr = S_OK;

error:
    return hr;
}


HRESULT
myGetCertRegDWValue(
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    IN WCHAR const          *pwszValueName,
    OUT DWORD               *pdwValue)
{
    HRESULT hr;
    DWORD *pdw = NULL;
    DWORD dwType;

    *pdwValue = 0;
    hr = myGetCertRegValue(
		       NULL,
		       pwszName1,
		       pwszName2,
		       pwszName3,
		       pwszValueName,
		       (BYTE **) &pdw,
		       NULL,
		       &dwType);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegValue",
		pwszValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    if (REG_DWORD != dwType)
    {
        hr = E_INVALIDARG;
        _JumpErrorStr(hr, error, "not REG_DWORD", pwszValueName);
    }
    *pdwValue = *pdw;
    hr = S_OK;

error:
    if (NULL != pdw)
    {
        LocalFree(pdw);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr)
{
    HRESULT   hr;
    WCHAR    *pwszOrzzValue = NULL;
    WCHAR const *pwszName = NULL != pwszDesValueName?
                            pwszDesValueName : pwszSrcValueName;

    // get value from source
    if (fMultiStr)
    {
        hr = myGetCertRegMultiStrValue(
				 pwszSrcName1,
				 pwszSrcName2,
				 pwszSrcName3,
				 pwszSrcValueName,
				 &pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "myGetCertRegMultiStrValue", pwszSrcValueName);

        // set it to destination
        hr = mySetCertRegMultiStrValue(
				 pwszDesName1,
				 pwszDesName2,
				 pwszDesName3,
				 pwszName,
				 pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszName);
    }
    else
    {
        hr = myGetCertRegStrValue(
			     pwszSrcName1,
			     pwszSrcName2,
			     pwszSrcName3,
			     pwszSrcValueName,
			     &pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "myGetCertRegStrValue", pwszSrcValueName);

        // set it to destination
        hr = mySetCertRegStrValue(
			     pwszDesName1,
			     pwszDesName2,
			     pwszDesName3,
			     pwszName,
			     pwszOrzzValue);
        _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszName);
    }
    hr = S_OK;

error:
    if (NULL != pwszOrzzValue)
    {
        LocalFree(pwszOrzzValue);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myMoveCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr)
{
    HRESULT hr;

    hr = myCopyCertRegStrValue(
			pwszSrcName1,
			pwszSrcName2,
			pwszSrcName3,
			pwszSrcValueName,
			pwszDesName1,
			pwszDesName2,
			pwszDesName3,
			pwszDesValueName,
			fMultiStr);
    _JumpIfErrorStr(hr, error, "myCopyCertRegStrValue", pwszSrcValueName);

    hr = myDeleteCertRegValue(
			pwszSrcName1,
			pwszSrcName2,
			pwszSrcName3,
			pwszSrcValueName);
    _PrintIfErrorStr(hr, "myDeleteCertRegValue", pwszSrcValueName);
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}

HRESULT
myMoveOrCopyCertRegStrValue(
    OPTIONAL IN WCHAR const *pwszSrcName1,
    OPTIONAL IN WCHAR const *pwszSrcName2,
    OPTIONAL IN WCHAR const *pwszSrcName3,
    IN WCHAR const          *pwszSrcValueName,
    OPTIONAL IN WCHAR const *pwszDesName1,
    OPTIONAL IN WCHAR const *pwszDesName2,
    OPTIONAL IN WCHAR const *pwszDesName3,
    OPTIONAL IN WCHAR const *pwszDesValueName,
    IN BOOL                  fMultiStr,
    IN BOOL                  fMove)
{
    HRESULT hr;

    if (fMove)
    {
        hr = myMoveCertRegStrValue(
                     pwszSrcName1,
                     pwszSrcName2,
                     pwszSrcName3,
                     pwszSrcValueName,
                     pwszDesName1,
                     pwszDesName2,
                     pwszDesName3,
                     pwszDesValueName,
                     fMultiStr);
    }
    else
    {
        hr = myCopyCertRegStrValue(
                     pwszSrcName1,
                     pwszSrcName2,
                     pwszSrcName3,
                     pwszSrcValueName,
                     pwszDesName1,
                     pwszDesName2,
                     pwszDesName3,
                     pwszDesValueName,
                     fMultiStr);
    }

    return hr;
}

// Description: it does the same thing as mySetCertRegStrValue but it takes
//              upgrade flag, if upgrade and entry exists, do nothing
HRESULT
mySetCertRegStrValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const          *pwszValue)
{
    HRESULT hr;
    WCHAR *pwszDummy = NULL;

    if (fUpgrade)
    {
        // see if it exists
        hr = myGetCertRegStrValue(
			     pwszName1,
			     pwszName2,
			     pwszName3,
			     pwszValueName,
			     &pwszDummy);
        if (S_OK == hr)
	{
	    if (NULL != pwszDummy && L'\0' != pwszDummy[0])
	    {
		goto error;	// keep existing entry
	    }
	}
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegStrValue", pwszValueName);
        }
    }
    // cases: 1) not upgrade
    //        2) upgrade but no existing entry
    //        3) upgrade, existing but empty reg string
    hr = mySetCertRegStrValue(
			 pwszName1,
			 pwszName2,
			 pwszName3,
			 pwszValueName,
			 pwszValue);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszValueName);

error:
    if (NULL != pwszDummy)
    {
        LocalFree(pwszDummy);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// calculate multi string character length including double zero terminators

DWORD
myWCSZZLength(
    IN WCHAR const *pwszz)
{
    DWORD cwc = 0;

    if (NULL != pwszz)
    {
	WCHAR const *pwsz;

        for (pwsz = pwszz; L'\0' != *pwsz; pwsz += wcslen(pwsz) + 1)  
        {
        }
        cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszz) + 1;
	if (1 == cwc)
	{
	    CSASSERT(L'\0' == pwsz[1]);
	    cwc++;	// empty values are double terminated, too
	}
    }
    return(cwc);
}


// merge two multi strings into one
// ignore redundant strings

HRESULT
myMergeMultiStrings(
    IN WCHAR const *pwszzStr1,
    IN WCHAR const *pwszzStr2,
    OUT WCHAR **ppwszzStr)
{
    HRESULT hr;
    DWORD cwcStr1 = myWCSZZLength(pwszzStr1);
    DWORD cwcStr2;	// doesn't include second terminator
    DWORD iStr2;
    DWORD cStr2;
    WCHAR const *pwsz1;
    WCHAR const *pwsz2;
    WCHAR *pwsz;
    BOOL *pfRedundant = NULL;
    WCHAR *pwszzMerge = NULL;

    *ppwszzStr = NULL;

    // calculate string count

    cStr2 = 0;
    for (pwsz2 = pwszzStr2; L'\0' != *pwsz2; pwsz2 += wcslen(pwsz2) + 1)
    {
        cStr2++;
    }
    cwcStr2 = 0;
    if (0 == cStr2)
    {
        goto only_str1;		// no merge needed
    }
    pfRedundant = (BOOL *) LocalAlloc(
				LMEM_FIXED | LMEM_ZEROINIT,
                                cStr2 * sizeof(*pfRedundant));
    if (NULL == pfRedundant)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }

    // calculate size

    iStr2 = 0;
    for (pwsz2 = pwszzStr2; L'\0' != *pwsz2; pwsz2 += wcslen(pwsz2) + 1)
    {
        for (pwsz1 = pwszzStr1; L'\0' != *pwsz1; pwsz1 += wcslen(pwsz1) + 1)
        {
            if (0 == mylstrcmpiL(pwsz2, pwsz1))
            {
                // pwsz2 exists in pwszzStr1, skip it -- save redundant flag

                pfRedundant[iStr2] = TRUE;
                break;	// for pwsz1
            }
        }
        if (L'\0' == *pwsz1)	// if not redundant ...
	{
	    cwcStr2 += wcslen(pwsz2) + 1;
	}
        iStr2++;
    }

only_str1:
    pwszzMerge = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(cwcStr1 + cwcStr2) * sizeof(WCHAR));
    if (NULL == pwszzMerge)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // copy existing

    CopyMemory(pwszzMerge, pwszzStr1, cwcStr1 * sizeof(WCHAR));
 
    if (0 < cStr2)
    {
        // merge begins
        // point to end at 2nd terminator

        iStr2 = 0;
	pwsz = &pwszzMerge[cwcStr1 - 1];
	if (L'\0' == *pwszzMerge)
	{
	    CSASSERT(2 == cwcStr1);
	    pwsz = pwszzMerge;
	}
        for (pwsz2 = pwszzStr2; L'\0' != *pwsz2; pwsz2 += wcslen(pwsz2) + 1)
        {
            if (!pfRedundant[iStr2])
            {
                wcscpy(pwsz, pwsz2);
                pwsz += wcslen(pwsz) + 1;
            }
            iStr2++;
        }
        *pwsz = L'\0';	// double terminate
	CSASSERT(
	    SAFE_SUBTRACT_POINTERS(pwsz, pwszzMerge) + 1 <= cwcStr1 + cwcStr2);
    }
    CSASSERT(myWCSZZLength(pwszzMerge) <= cwcStr1 + cwcStr2);
    *ppwszzStr = pwszzMerge;
    pwszzMerge = NULL;
    hr = S_OK;

error:
    if (NULL != pfRedundant)
    {
        LocalFree(pfRedundant);
    }
    if (NULL != pwszzMerge)
    {
        LocalFree(pwszzMerge);
    }
    return(hr);
}


// append one multi_sz to another

HRESULT
myAppendMultiStrings(
    IN WCHAR const *pwszzStr1,
    IN WCHAR const *pwszzStr2,
    OUT WCHAR **ppwszzStr)
{
    HRESULT  hr;
    DWORD cwcStr1 = myWCSZZLength(pwszzStr1);
    DWORD cwcStr2 = myWCSZZLength(pwszzStr2);
    WCHAR *pwszzMerge;
    WCHAR *pwsz;

    *ppwszzStr = NULL;
    pwszzMerge = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(cwcStr1 + cwcStr2 - 1) * sizeof(WCHAR));
    if (NULL == pwszzMerge)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // copy existing

    CopyMemory(pwszzMerge, pwszzStr1, (cwcStr1 - 1) * sizeof(WCHAR));

    // append second

    pwsz = &pwszzMerge[cwcStr1 - 1];
    if (L'\0' == *pwszzMerge)
    {
	CSASSERT(2 == cwcStr1);
	pwsz = pwszzMerge;
    }
    CopyMemory(pwsz, pwszzStr2, cwcStr2 * sizeof(WCHAR));
    CSASSERT(myWCSZZLength(pwszzMerge) <= cwcStr1 + cwcStr2);
    *ppwszzStr = pwszzMerge;
    hr = S_OK;

error:
    return(hr);
}


// Description: mySetCertRegMultiStrValueEx is the same as
// mySetCertRegMultiStrValue but it takes an upgrade | append flag.
// if upgrade and entry exists, do nothing.
// if upgrade & append, merge existing entry with input pwszz.

HRESULT
mySetCertRegMultiStrValueEx(
    IN DWORD dwFlags, // CSREG_UPGRADE | CSREG_APPEND | CSREG_REPLACE | CSREG_MERGE
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN WCHAR const *pwszzValue)
{
    HRESULT hr;
    WCHAR *pwszzExisting = NULL;
    WCHAR const *pwszzFinal = pwszzValue;	// default
    WCHAR *pwszzMerge = NULL;

    if (0 == (CSREG_REPLACE & dwFlags) && (CSREG_UPGRADE & dwFlags))
    {
        // to see if it exist
        hr = myGetCertRegMultiStrValue(
				 pwszName1,
				 pwszName2,
				 pwszName3,
				 pwszValueName,
				 &pwszzExisting);
        if (S_OK == hr)
        {
            if (NULL != pwszzExisting)
            {
                if (0 == ((CSREG_MERGE | CSREG_APPEND) & dwFlags))
                {
		    goto error;		// keep existing entry
                }
                if (CSREG_MERGE & dwFlags)
                {
                    hr = myMergeMultiStrings(
                                 pwszzExisting,
                                 pwszzValue,
                                 &pwszzMerge);
                    _JumpIfError(hr, error, "myMergeMultiStrings");
                }
                else if (CSREG_APPEND & dwFlags)
                {
                    hr = myAppendMultiStrings(
                                 pwszzExisting,
                                 pwszzValue,
                                 &pwszzMerge);
                    _JumpIfError(hr, error, "myAppendMultiStrings");
                }
		pwszzFinal = pwszzMerge;
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegMultiStrValue", pwszValueName);
        }
    }
    hr = mySetCertRegMultiStrValue(
			     pwszName1,
			     pwszName2,
			     pwszName3,
			     pwszValueName,
			     pwszzFinal);
    _JumpIfErrorStr(hr, error, "mySetCertRegMultiStrValue", pwszValueName);

error:
    if (NULL != pwszzExisting)
    {
        LocalFree(pwszzExisting);
    }
    if (NULL != pwszzMerge)
    {
        LocalFree(pwszzMerge);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Description: it does the same thing as mySetCertRegDWValue but it takes
//              upgrade flag, if upgrade and entry exists, do nothing
HRESULT
mySetCertRegDWValueEx(
    IN BOOL                  fUpgrade,
    OPTIONAL IN WCHAR const *pwszName1,
    OPTIONAL IN WCHAR const *pwszName2,
    OPTIONAL IN WCHAR const *pwszName3,
    OPTIONAL IN WCHAR const *pwszValueName,
    IN DWORD const           dwValue)
{
    HRESULT hr;
    DWORD   dwDummy;

    if (fUpgrade)
    {
        // to see if it exist
        hr = myGetCertRegDWValue(
                     pwszName1,
                     pwszName2,
                     pwszName3,
                     pwszValueName,
                     &dwDummy);
        if (S_OK == hr)
        {
	    goto error;	// keep existing entry
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
        {
            _JumpErrorStr(hr, error, "myGetCertRegDWValue", pwszValueName);
        }
    }
    hr = mySetCertRegDWValue(
                     pwszName1,
                     pwszName2,
                     pwszName3,
                     pwszValueName,
                     dwValue);
    _JumpIfErrorStr(hr, error, "mySetCertRegDWValue", pwszValueName);

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


WCHAR const *
wszRegCertChoice(
    IN DWORD dwRegHashChoice)
{
    WCHAR const *pwsz;
    
    switch (dwRegHashChoice)
    {
	case CSRH_CASIGCERT:
	    pwsz = wszREGCACERTHASH;
	    break;

	case CSRH_CAXCHGCERT:
	    pwsz = wszREGCAXCHGCERTHASH;
	    break;

	case CSRH_CAKRACERT:
	    pwsz = wszREGKRACERTHASH;
	    break;

	default:
	    CSASSERT(CSExpr(!"dwRegHashChoice"));
	    pwsz = L"";
	    break;
    }
    return(pwsz);
}


WCHAR const g_wszNoHash[] = L"-";


HRESULT myShrinkCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index)
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwType;
    DWORD count;
    WCHAR *pwszzOld = NULL;
    WCHAR *pwchr = NULL; // no free

    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszzOld,
		    &i,		// ignore &cb
		    &dwType);
    _JumpIfErrorStr(hr, error, "myGetCertRegValue", wszRegCertChoice(dwRegHashChoice));

    for (count = 0, pwchr = pwszzOld;
         count < Index && L'\0' != *pwchr;
         count++, pwchr += wcslen(pwchr) + 1)
	NULL;

    // valid only if shrinking the list
    if(L'\0' == *pwchr)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "new hash count should be smaller than current count");
    }

    *pwchr = L'\0';

    hr = mySetCertRegValue(
			NULL,
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszRegCertChoice(dwRegHashChoice),
			REG_MULTI_SZ,
			(BYTE const *) pwszzOld,
			(SAFE_SUBTRACT_POINTERS(pwchr, pwszzOld) + 1) * sizeof(WCHAR),
			FALSE);
    _JumpIfError(hr, error, "mySetCertRegValue");

error:
    if(pwszzOld)
        LocalFree(pwszzOld);
    return hr;
}

HRESULT
mySetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    IN CERT_CONTEXT const *pCert)
{
    HRESULT hr;
    BSTR strHash = NULL;
    BYTE abHash[CBMAX_CRYPT_HASH_LEN];
    DWORD cbHash;
    WCHAR *pwszzOld = NULL;
    WCHAR *pwszzNew = NULL;
    DWORD cOld;
    DWORD i;
    DWORD cNew;
    DWORD cwcNew;
    WCHAR const **apwsz = NULL;
    DWORD dwType;
    WCHAR *pwc;

    if (NULL == pwszSanitizedCAName)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "empty ca name");
    }

    cbHash = sizeof(abHash);
    if (!CertGetCertificateContextProperty(
			pCert,
			CERT_HASH_PROP_ID,
			abHash,
			&cbHash))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateContextProperty");
    }

    hr = MultiByteIntegerToBstr(TRUE, cbHash, abHash, &strHash);
    _JumpIfError(hr, error, "MultiByteIntegerToBstr");

    cOld = 0;
    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszzOld,
		    &i,		// ignore &cb
		    &dwType);
    _PrintIfError2(hr, "myGetCertRegValue", HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    if (S_OK == hr && REG_MULTI_SZ == dwType)
    {
	for (pwc = pwszzOld; L'\0' != *pwc; pwc += wcslen(pwc) + 1)
	{
	    cOld++;
	}
    }

    cNew = max(Index + 1, cOld);
    apwsz = (WCHAR const **) LocalAlloc(LMEM_FIXED, cNew * sizeof(*apwsz));
    if (NULL == apwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    i = 0;
    if (0 != cOld)
    {
	for (pwc = pwszzOld; L'\0' != *pwc; pwc += wcslen(pwc) + 1)
	{
	    DBGPRINT((DBG_SS_CERTLIBI, "Old CARegHash[%u] = \"%ws\"\n", i, pwc));
	    apwsz[i++] = pwc;
	}
	CSASSERT(i == cOld);
    }
    while (i < Index)
    {
	DBGPRINT((DBG_SS_CERTLIBI, "CARegHash[%u] Unused\n", i));
	apwsz[i++] = g_wszNoHash;
    }
    if (Index < cOld)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "Replacing CARegHash[%u] = \"%ws\"\n",
	    Index,
	    apwsz[Index]));
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"Adding CARegHash[%u] = \"%ws\"\n",
	Index,
	strHash));
    apwsz[Index] = strHash;

    cwcNew = 1;		// wszz double termination
    for (i = 0; i < cNew; i++)
    {
	cwcNew += wcslen(apwsz[i]) + 1;
    }

    pwszzNew = (WCHAR *) LocalAlloc(LMEM_FIXED, cwcNew * sizeof(WCHAR));
    if (NULL == pwszzNew)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    pwc = pwszzNew;
    for (i = 0; i < cNew; i++)
    {
	wcscpy(pwc, apwsz[i]);
	DBGPRINT((DBG_SS_CERTLIBI, "New CARegHash[%u] = \"%ws\"\n", i, pwc));
	pwc += wcslen(pwc) + 1;
    }
    *pwc = L'\0';

    CSASSERT(&pwszzNew[cwcNew - 1] == pwc);

    hr = mySetCertRegValue(
			NULL,
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszRegCertChoice(dwRegHashChoice),
			REG_MULTI_SZ,
			(BYTE const *) pwszzNew,
			cwcNew * sizeof(WCHAR),
			FALSE);
    _JumpIfError(hr, error, "mySetCertRegValue");

error:
    if (NULL != apwsz)
    {
	LocalFree(apwsz);
    }
    if (NULL != pwszzOld)
    {
	LocalFree(pwszzOld);
    }
    if (NULL != pwszzNew)
    {
	LocalFree(pwszzNew);
    }
    if (NULL != strHash)
    {
	SysFreeString(strHash);
    }
    return(hr);
}


HRESULT
myGetCARegHash(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OUT BYTE **ppbHash,
    OUT DWORD *pcbHash)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    DWORD cb;
    DWORD dwType;
    WCHAR *pwc;
    DWORD i;

    *ppbHash = NULL;
    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszz,
		    &cb,
		    &dwType);
    _JumpIfError(hr, error, "myGetCertRegValue");

    if (REG_MULTI_SZ != dwType)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "dwType");
    }
    pwc = pwszz;
    for (i = 0; i < Index; i++)
    {
	if (L'\0' == *pwc)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    _JumpError(hr, error, "Index too large");
	}
	pwc += wcslen(pwc) + 1;
    }
    if (0 == lstrcmp(g_wszNoHash, pwc))
    {
	hr = S_FALSE;
	_JumpError2(hr, error, "Unused hash", S_FALSE);
    }
    hr = WszToMultiByteInteger(TRUE, pwc, pcbHash, ppbHash);
    _JumpIfError(hr, error, "WszToMultiByteInteger");

error:
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


HRESULT
myGetCARegHashCount(
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    OUT DWORD *pCount)
{
    HRESULT hr;
    WCHAR *pwszz = NULL;
    DWORD cb;
    DWORD dwType;
    WCHAR *pwc;
    DWORD Count = 0;

    hr = myGetCertRegValue(
		    NULL,
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszRegCertChoice(dwRegHashChoice),
		    (BYTE **) &pwszz,
		    &cb,
		    &dwType);
    if (S_OK == hr)
    {
	if (REG_MULTI_SZ == dwType)
	{
	    for (pwc = pwszz; L'\0' != *pwc; pwc += wcslen(pwc) + 1)
	    {
		Count++;
	    }
	}
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr)
    {
	_JumpError(hr, error, "myGetCertRegValue");
    }
    hr = S_OK;

error:
    *pCount = Count;
    if (NULL != pwszz)
    {
	LocalFree(pwszz);
    }
    return(hr);
}


HRESULT
myFindCACertByHash(
    IN HCERTSTORE hStore,
    IN BYTE const *pbHash,
    IN DWORD cbHash,
    OUT OPTIONAL DWORD *pdwNameId,
    CERT_CONTEXT const **ppCACert)
{
    HRESULT hr;
    CRYPT_DATA_BLOB Hash;

    CSASSERT(
	NULL != hStore &&
	NULL != pbHash &&
	NULL != ppCACert);

    *ppCACert = NULL;
    Hash.pbData = const_cast<BYTE *>(pbHash);
    Hash.cbData = cbHash;

    *ppCACert = CertFindCertificateInStore(
				    hStore,
				    X509_ASN_ENCODING,
				    0,
				    CERT_FIND_HASH,
				    &Hash,
				    NULL);
    if (NULL == *ppCACert)
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertFindCertificateInStore");
    }

    if (NULL != pdwNameId)
    {
        *pdwNameId = MAXDWORD;
        hr = myGetNameId(*ppCACert, pdwNameId);
        _PrintIfError(hr, "myGetNameId");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
myFindCACertByHashIndex(
    IN HCERTSTORE hStore,
    IN WCHAR const *pwszSanitizedCAName,
    IN DWORD dwRegHashChoice,
    IN DWORD Index,
    OPTIONAL OUT DWORD *pdwNameId,
    CERT_CONTEXT const **ppCACert)
{
    HRESULT hr;
    DWORD cbHash;
    BYTE *pbHash = NULL;

    CSASSERT(NULL != hStore && NULL != ppCACert);

    if (NULL != pdwNameId)
    {
        *pdwNameId = MAXDWORD;
    }
    *ppCACert = NULL;

    hr = myGetCARegHash(
		    pwszSanitizedCAName,
		    dwRegHashChoice,
		    Index,
		    &pbHash,
		    &cbHash);
    _JumpIfError2(hr, error, "myGetCARegHash", S_FALSE);

    hr = myFindCACertByHash(hStore, pbHash, cbHash, pdwNameId, ppCACert);
    _JumpIfError(hr, error, "myFindCACertByHash");

error:
    if (NULL != pbHash)
    {
	LocalFree(pbHash);
    }
    return(hr);
}


HRESULT
GetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    OUT DWORD *pdwStatus)
{
    HRESULT hr;

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGSETUPSTATUS,
			pdwStatus);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegDWValue",
		wszREGSETUPSTATUS,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    DBGPRINT((DBG_SS_CERTLIBI, "GetSetupStatus(%ws) --> %x\n", pwszSanitizedCAName, *pdwStatus));

error:
    return(hr);
}


HRESULT
SetSetupStatus(
    OPTIONAL IN WCHAR const *pwszSanitizedCAName,
    IN const DWORD  dwFlag,
    IN const BOOL   fSetBit)
{
    HRESULT  hr;
    DWORD    dwCurrentStatus;
    DWORD    dwStatus = dwFlag;

    hr = myGetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGSETUPSTATUS,
			&dwCurrentStatus);
    _PrintIfError2(
	    hr,
	    "myGetCertRegDWValue",
	    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    // check to if there is existing status
    if (S_OK == hr || 0xFFFFFFFF == dwStatus)
    {
        // existing status, set according to dwFlag

        if (fSetBit)
        {
            // set corresponding bit
            dwStatus = dwCurrentStatus | dwStatus;
        }
        else
        {
            // unset corresponding
            dwStatus = dwCurrentStatus & ~dwStatus;
        }
    }
    else if(HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)==hr)
    {
        hr = S_OK;

        // entry doesn't exist, if fSetBit, keep dwStatus=dwFlag
        if (!fSetBit)
        {
            // otherwise set all 0
            dwStatus = 0;
        }
    }
    else
    {
        _JumpIfError(hr, error, "myGetCertRegDWValue(wszREGSETUPSTATUS)");
    }

    hr = mySetCertRegDWValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGSETUPSTATUS,
			dwStatus);
    _JumpIfError(hr, error, "mySetCertRegDWValue");

    DBGPRINT((DBG_SS_CERTLIBI, "SetSetupStatus(%ws, %x)\n", pwszSanitizedCAName, dwStatus));

error:
    return(hr);
}


HRESULT
myGetActiveManageModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OUT LPOLESTR *ppwszProgIdManageModule,           // CoTaskMem*
    OUT CLSID *pclsidManageModule)
{
    DWORD dw;
    PBYTE pb = NULL;
    DWORD cbClassName;
    LPOLESTR lpszProgID = NULL;
    LPWSTR szClassName = NULL;

    if (NULL != *ppwszProgIdManageModule)
    {
        CoTaskMemFree(*ppwszProgIdManageModule);
        *ppwszProgIdManageModule = NULL;
    }

    dw = myGetActiveModule(
		    pwszMachine,
		    pwszSanitizedCAName,
		    fPolicyModule,
		    Index,
		    &lpszProgID,
		    NULL);
    if (S_OK != dw)
        goto error;

    {
        // terminate class name at first '.'
        LPWSTR pAddTermination = wcschr(lpszProgID, L'.');

        if (NULL != pAddTermination)
	{
            pAddTermination[0] = L'\0';
	}
    }

    cbClassName = (wcslen(lpszProgID) + 1) * sizeof(WCHAR);
    cbClassName += (fPolicyModule) ? sizeof(wszCERTMANAGEPOLICY_POSTFIX) : sizeof(wszCERTMANAGEEXIT_POSTFIX);

    szClassName = (LPWSTR) CoTaskMemAlloc(cbClassName);
    if (NULL == szClassName)
        goto error;

    wcscpy(szClassName, lpszProgID);
    wcscat(szClassName, fPolicyModule? wszCERTMANAGEPOLICY_POSTFIX : wszCERTMANAGEEXIT_POSTFIX);

    // Now we have class module name, cvt to clsid
    dw = CLSIDFromProgID(szClassName, pclsidManageModule);
    if (S_OK != dw)
        goto error;   // clsid not found?

error:
    if (pb)
        LocalFree(pb);

    // intermediate ProgId
    if (lpszProgID)
        CoTaskMemFree(lpszProgID);

    *ppwszProgIdManageModule = szClassName;

    return dw;
}


HRESULT
myGetActiveModule(
    OPTIONAL IN WCHAR const *pwszMachine,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fPolicyModule,
    IN DWORD Index,
    OPTIONAL OUT LPOLESTR *ppwszProgIdModule,   // CoTaskMem*
    OPTIONAL OUT CLSID *pclsidModule)
{
    HRESULT hr;
    WCHAR *pwszzValue = NULL;
    WCHAR *pwsz;
    DWORD dwType;
    DWORD cb = 0;
    LPWSTR pwszModuleSubkey = NULL;
    DWORD chModule;
    
    chModule = wcslen(pwszSanitizedCAName) + 1 + 1; // (L'\\' + trailing L'\0');
    chModule += fPolicyModule?
	WSZARRAYSIZE(wszREGKEYPOLICYMODULES) :
	WSZARRAYSIZE(wszREGKEYEXITMODULES);

    pwszModuleSubkey = (LPWSTR) LocalAlloc(
				    LMEM_FIXED,
				    chModule * sizeof(WCHAR));
    if (NULL == pwszModuleSubkey)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszModuleSubkey, pwszSanitizedCAName);
    wcscat(pwszModuleSubkey, L"\\");
    wcscat(
	pwszModuleSubkey,
	fPolicyModule? wszREGKEYPOLICYMODULES : wszREGKEYEXITMODULES);

    // grab entry under CA with the active module ProgID
    hr = myGetCertRegValue(
		    pwszMachine,
		    pwszModuleSubkey,
		    NULL,
		    NULL,
		    wszREGACTIVE,
		    (BYTE **) &pwszzValue,
		    &cb,
		    &dwType);
    _JumpIfError(hr, error, "myGetCertRegValue");

    hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);

    // might or might not have an active entry
    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
    {
	_JumpError(hr, error, "Bad active entry type");
    }
    if (0 == cb || NULL == pwszzValue)
    {
	_JumpError(hr, error, "No active entry");
    }
    if (0 != Index && (REG_SZ == dwType || fPolicyModule))
    {
	_JumpError(hr, error, "only one policy module or REG_SZ entry");
    }
    
    pwsz = pwszzValue;

    if (REG_MULTI_SZ == dwType)
    {
        // look for Index'th entry
        for ( ; 0 != Index; pwsz += wcslen(pwsz) + 1, Index--)
        {
	    if (L'\0' == *pwsz)
	    {
		_JumpError(hr, error, "No more active entries");
	    }
        }
    }

    // Verify nth entry exists
    if (L'\0' == *pwsz)
    {
	_JumpError(hr, error, "No active entries");
    }

    if (NULL != pclsidModule)
    {
        hr = CLSIDFromProgID(pwsz, pclsidModule);
        _JumpIfError(hr, error, "CLSIDFromProgID");
    }
    
    if (NULL != ppwszProgIdModule)
    {
        *ppwszProgIdModule = (LPOLESTR) CoTaskMemAlloc(
            (wcslen(pwsz) + 1) * sizeof(WCHAR));
        if (NULL == *ppwszProgIdModule)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "CoTaskMemAlloc");
        }
        wcscpy(*ppwszProgIdModule, pwsz);
    }
    hr = S_OK;      // not reset after ERROR_MOD_NOT_FOUND in all cases

error:
    if (NULL != pwszModuleSubkey)
    {
        LocalFree(pwszModuleSubkey);
    }
    if (NULL != pwszzValue)
    {
        LocalFree(pwszzValue);
    }
    return(hr);
}


BOOL
IsPrefix(
    WCHAR const *pwszPrefix,
    WCHAR const *pwszString,
    DWORD cwcPrefix)
{
    return(
	0 == _wcsnicmp(pwszPrefix, pwszString, cwcPrefix) &&
	(L'\\' == pwszString[cwcPrefix] ||
	 L'\0' == pwszString[cwcPrefix]));
}


//+------------------------------------------------------------------------
//  Function:	myRegOpenRelativeKey
//
//  Synopsis:	Compute CA-relative, Policy-relative or Exit-relative registry
//		path, and retrieve the value, type, and parent registry key.
//
// IN params:
//
// pwszConfig is the config string of the CA:
//	if NULL, the local machine's first active CA is used.
//	if a server name (no \CAName is present), the specified machine's
//	first active CA is used.
//
// pwszRegName can specify any of the following the targets:
//	Passed String:			ValueName Relative Key Opened:
//	-------------			------------------------------
//      "ValueName"			Configuration key
//      "CA[\ValueName]"		CAName key
//      "policy[\ValueName]"		CAName\PolicyModules\<ActivePolicy>
//      "policy\ModuleProgId[\ValueName]" CAName\PolicyModules\ModuleProgId
//      "exit[\ValueName]"		CAName\ExitModules\<ActiveExit>
//      "exit\ModuleProgId[\ValueName]"	CAName\ExitModules\ModuleProgId
//      "Template[\ValueName]"		Template
//
//
// RORKF_FULLPATH specifies whether the path returned is relative from HKLM or
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration.
//
// RORKF_CREATESUBKEYS will allow subkeys to be created if necessary and the
// returned hkey opened for WRITE access
//
// RORKF_CREATEKEY will allow the top level key to be created if necessary
//
// On successful execution:
//
// *ppwszPath will contain a LocalAlloc'd registry path relative to
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\CertSvc\Configuration.
//
// *ppwszName will contain a LocalAlloc'd registry value name string relative to
// the returned parent key. If NULL, pwszRegName specifies a key, not a value.
//
// *phkey contains the opened reg key, if phkey non-NULL. Caller is responsible
// for freeing this key.
//-------------------------------------------------------------------------

HRESULT
myRegOpenRelativeKey(
    OPTIONAL IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszRegName,
    IN DWORD Flags,		// RORKF_*
    OUT WCHAR **ppwszPath,
    OUT OPTIONAL WCHAR **ppwszName,
    OUT OPTIONAL HKEY *phkey)
{
    HRESULT hr;
    WCHAR awc[MAX_PATH];
    WCHAR awc2[MAX_PATH];
    HKEY hkeyRoot = HKEY_LOCAL_MACHINE;
    HKEY hkeyConfig = NULL;
    HKEY hkeyMod = NULL;
    HKEY hkeyRequested = NULL;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwszModules = NULL;
    WCHAR const *pwszName;
    WCHAR const *pwsz;
    DWORD dwType;
    DWORD cb;
    DWORD cwc;
    DWORD i;
    BOOL fTemplateCache;
    DWORD dwDisposition;
    
    // Parameter checking
    
    if (NULL != phkey)
    {
        *phkey = NULL;
    }
    if (NULL != ppwszName)
    {
        *ppwszName = NULL;
    }
    if (NULL == ppwszPath)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "ppwszPath not optional");
    }
    *ppwszPath = NULL;
    
    fTemplateCache = IsPrefix(L"Template", pwszRegName, 8);
    if (fTemplateCache && (RORKF_USERKEY & Flags))
    {
	hkeyRoot = HKEY_CURRENT_USER;
    }

    // take care of remote machine access
    
    if (NULL != pwszConfig)
    {
        BOOL fLocal;
        
        hr = myIsConfigLocal(pwszConfig, &pwszMachine, &fLocal);
        _JumpIfError(hr, error, "myIsConfigLocal");
        
        if (!fLocal)
        {
            hr = RegConnectRegistry(pwszMachine, hkeyRoot, &hkeyRoot);
	    _JumpIfErrorStr(hr, error, "RegConnectRegistry", pwszMachine);
        }
    }
    
    if (!fTemplateCache)
    {
	hr = RegOpenKeyEx(
		    hkeyRoot,
		    wszREGKEYCONFIGPATH,
		    0,
		    (RORKF_CREATESUBKEYS & Flags)? KEY_ALL_ACCESS : KEY_READ,
		    &hkeyConfig);
	if ((HRESULT) ERROR_FILE_NOT_FOUND == hr && (RORKF_CREATEKEY & Flags))
	{
	    _PrintError(hr, "RegOpenKey(config)");
	    hr = RegCreateKey(hkeyRoot, wszREGKEYCONFIGPATH, &hkeyConfig);
	    _JumpIfError(hr, error, "RegCreateKey(config)");
	}
	_JumpIfError(hr, error, "RegOpenKey(config)");
    }
    
    // value or key\value passed in under pwszRegName?

    pwsz = wcschr(pwszRegName, L'\\');
    if (NULL == pwsz &&
        !IsPrefix(L"CA", pwszRegName, 2) &&
        !IsPrefix(L"Policy", pwszRegName, 6) &&
        !IsPrefix(L"Exit", pwszRegName, 4) &&
        !IsPrefix(L"Restore", pwszRegName, 7) &&
        !IsPrefix(L"Config", pwszRegName, 6) &&
	!fTemplateCache)
    {
        // Operate on registry value under the Configuration registry key
        
        pwszName = pwszRegName;
        
        // this is the final key we'll open
        
        hkeyRequested = hkeyConfig;
        hkeyConfig = NULL;
        awc[0] = L'\0';
    }
    else if (fTemplateCache)
    {
	pwszName = &pwszRegName[8];
	wcscpy(awc, wszCERTTYPECACHE);
    }
    else
    {
        //printf("RegName = '%ws'\n", pwszRegName);
        // load config of the active CA
        
	awc[0] = L'\0';
        if (!IsPrefix(L"Config", pwszRegName, 6))
	{
	    cb = sizeof(awc);
	    hr = RegQueryValueEx(
			    hkeyConfig,
			    wszREGACTIVE,
			    NULL,
			    &dwType,
			    (BYTE *) awc,
			    &cb);
	    _JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGACTIVE);
	
	    if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpIfErrorStr(hr, error, "RegQueryValueEx TYPE", wszREGACTIVE);
	    }
        
	    //printf("Active CA = '%ws'\n", awc);
	}
        
        // operate on key\value
        
        // first, subdivide into policymodules\exitmodules subkey
        
        if (IsPrefix(L"CA", pwszRegName, 2))
        {
            // Operate on registry value under the Active CA registry key
            
            pwszName = &pwszRegName[2];
        }
        else if (IsPrefix(L"Policy", pwszRegName, 6))
        {
            // Operate on registry value under a Policy Module registry key
            
            pwszModules = wszREGKEYPOLICYMODULES;
            pwszName = &pwszRegName[6];
        }
        else if (IsPrefix(L"Exit", pwszRegName, 4))
        {
            // Operate on registry value under an Exit Module registry key
            
            pwszModules = wszREGKEYEXITMODULES;
            pwszName = &pwszRegName[4];
        }
        else if (IsPrefix(L"Restore", pwszRegName, 7))
        {
            // Operate on registry value under Restore registry key
            
            pwszName = &pwszRegName[7];
            wcscpy(awc, wszREGKEYRESTOREINPROGRESS);
        }
        else if (IsPrefix(L"Config", pwszRegName, 6))
        {
            // Operate on registry value under Configuration registry key
            
            pwszName = &pwszRegName[6];
        }
        else
        {
            hr = E_INVALIDARG;
            _JumpError(hr, error, "pwszRegName: no subkey description");
        }
        
        // expand module ProgId if necessary: get active ProgId
        
        if (NULL != pwszModules)	// if a policy or exit module
        {
            wcscat(awc, L"\\");
            wcscat(awc, pwszModules);
        }
        
        //printf("CA|restore|policy|exit key = '%ws'\n", awc);
        
        if (NULL != ppwszName)		// if a registry value expected
        {
            // Find active policy/exit module's ProgId
            hr = RegOpenKeyEx(
                hkeyConfig,
                awc,
                0,
                KEY_READ,
                &hkeyMod);
            _JumpIfErrorStr(hr, error, "RegOpenKey", awc);
            
            if (NULL != pwszModules)	// if a policy or exit module
            {
                cb = sizeof(awc2);
                hr = RegQueryValueEx(
                    hkeyMod,
                    wszREGACTIVE,
                    NULL,
                    &dwType,
                    (BYTE *) awc2,
                    &cb);
                _JumpIfErrorStr(hr, error, "RegQueryValueEx", wszREGACTIVE);
                
                if (REG_SZ != dwType && REG_MULTI_SZ != dwType)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                    _JumpIfErrorStr(hr, error, "RegQueryValueEx Active Module", awc);
                }
                
                //printf("Active Module = '%ws'\n", awc2);
                
                wcscat(awc, L"\\");
                wcscat(awc, awc2);
            }
        }
        else	// else a registry key name is expected
        {
            // key\value: ProgId was passed in
            // concatenate key name (including the \\ prefix) onto end of awc
            
            if (NULL != pwsz)
            {
                CSASSERT(L'\\' == *pwsz);
                wcscat(awc, pwsz);
            }
        }
    } // end if (operate on key/value or value)

    if (NULL == hkeyRequested)
    {
        //printf("Creating key = '%ws'\n", awc);
        
        // open this key
        hr = RegCreateKeyEx(
		    NULL != hkeyConfig? hkeyConfig : hkeyRoot,
		    awc,
		    0,
		    NULL,
		    0,
		    (RORKF_CREATESUBKEYS & Flags)? KEY_ALL_ACCESS : KEY_READ,
		    NULL,
		    &hkeyRequested,
		    &dwDisposition);
	_JumpIfErrorStr(hr, error, "RegCreateKeyEx(parent)", awc);
        
    } // end if (operate on key/value or value)
    
    if (L'\\' == *pwszName)
    {
	pwszName++;
    }
    if (NULL != ppwszName && L'\0' != *pwszName)
    {
        // Look for case-ignore matching registry value name, & use the value's
        // correct upper/lower case spelling if an existing registry value:
        
        for (i = 0; ; i++)
        {
            cwc = ARRAYSIZE(awc2);
            hr = RegEnumValue(hkeyRequested, i, awc2, &cwc, NULL, NULL, NULL, NULL);
            if (S_OK != hr)
            {
                hr = S_OK;
                break;
            }
            if (0 == mylstrcmpiL(awc2, pwszName))
            {
                pwszName = awc2;
                break;
            }
        }
    }
    
    cb = (wcslen(awc) + 1) * sizeof(WCHAR);
    if (!fTemplateCache && (RORKF_FULLPATH & Flags))
    {
        cb += WSZARRAYSIZE(wszREGKEYCONFIGPATH_BS) * sizeof(WCHAR);
    }
    
    *ppwszPath = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszPath)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    (*ppwszPath)[0] = L'\0';
    if (!fTemplateCache && (RORKF_FULLPATH & Flags))
    {
	wcscpy(*ppwszPath, wszREGKEYCONFIGPATH_BS);
    }
    wcscat(*ppwszPath, awc);
    CSASSERT((wcslen(*ppwszPath) + 1) * sizeof(WCHAR) == cb);
    if (L'\0' == awc[0] && L'\\' == (*ppwszPath)[cb / sizeof(WCHAR) - 2])
    {
        (*ppwszPath)[cb / sizeof(WCHAR) - 2] = L'\0';
    }
    
    if (NULL != ppwszName)
    {
        *ppwszName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (wcslen(pwszName) + 1) * sizeof(WCHAR));
        if (NULL == *ppwszName)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(*ppwszName, pwszName);
    }
    if (NULL != phkey)
    {
        *phkey = hkeyRequested;
        hkeyRequested = NULL;
    }
    hr = S_OK;
    
    //printf("key path = '%ws'\n", *ppwszPath);
    //if (NULL != ppwszName) printf("value name = '%ws'\n", *ppwszName);
    
error:
    if (HKEY_LOCAL_MACHINE != hkeyRoot && HKEY_CURRENT_USER != hkeyRoot)
    {
        RegCloseKey(hkeyRoot);
    }
    if (NULL != hkeyConfig)
    {
        RegCloseKey(hkeyConfig);
    }
    if (NULL != hkeyMod)
    {
        RegCloseKey(hkeyMod);
    }
    if (NULL != hkeyRequested)
    {
        RegCloseKey(hkeyRequested);
    }
    if (NULL != pwszMachine)
    {
        LocalFree(pwszMachine);
    }
    if (S_OK != hr)
    {
        if (NULL != ppwszPath && NULL != *ppwszPath)
        {
            LocalFree(*ppwszPath);
            *ppwszPath = NULL;
        }
        if (NULL != ppwszName && NULL != *ppwszName)
        {
            LocalFree(*ppwszName);
            *ppwszName = NULL;
        }
    }
    return(myHError(hr));
}


#define wszTEMPLATE wszFCSAPARM_SERVERDNSNAME L"_" wszFCSAPARM_SANITIZEDCANAME
#define cwcTEMPLATE WSZARRAYSIZE(wszTEMPLATE)

HRESULT
mySetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN WCHAR const *pwszFileName)
{
    HRESULT hr;
    WCHAR *pwszMatch = NULL;
    WCHAR *pwszMatchIn;
    WCHAR const *pwszBase;
    WCHAR const *pwszExt;
    DWORD cwcPath;
    DWORD cwcBase;
    DWORD cwcMatch;
    DWORD cwcT;
    WCHAR *pwszT = NULL;
    WCHAR *pwszT2;

    pwszBase = wcsrchr(pwszFileName, L'\\');
    if (NULL == pwszBase)
    {
	hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
	_JumpErrorStr(hr, error, "bad path", pwszFileName);
    }
    pwszBase++;
    cwcPath = SAFE_SUBTRACT_POINTERS(pwszBase, pwszFileName);
    pwszExt = wcsrchr(pwszBase, L'.');
    if (NULL == pwszExt)
    {
	pwszExt = &pwszBase[wcslen(pwszBase)];
    }
    cwcBase = SAFE_SUBTRACT_POINTERS(pwszExt, pwszBase);

    cwcMatch = wcslen(pwszServerName) + 1 + wcslen(pwszSanitizedName);
    if (cwcBase == cwcMatch)
    {
	// Allocate space for both strings at once:

	pwszMatch = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    2 * (cwcMatch + 1) * sizeof(WCHAR));
	if (NULL == pwszMatch)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwszMatch, pwszServerName);
	wcscat(pwszMatch, L"_");
	wcscat(pwszMatch, pwszSanitizedName);

	pwszMatchIn = &pwszMatch[cwcMatch + 1];
	CopyMemory(pwszMatchIn, pwszBase, cwcMatch * sizeof(WCHAR));
	pwszMatchIn[cwcMatch] = L'\0';

	if (0 == mylstrcmpiL(pwszMatch, pwszMatchIn))
	{
	    pwszBase = wszTEMPLATE;
	    cwcBase = cwcTEMPLATE;
	}
    }

    cwcT = cwcPath +
		cwcBase +
		WSZARRAYSIZE(wszFCSAPARM_CERTFILENAMESUFFIX) +
		wcslen(pwszExt);

    pwszT = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (cwcT + 1) * sizeof(WCHAR));
    if (NULL == pwszT)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    pwszT2 = pwszT;

    CopyMemory(pwszT2, pwszFileName, cwcPath * sizeof(WCHAR));
    pwszT2 += cwcPath;

    CopyMemory(pwszT2, pwszBase, cwcBase * sizeof(WCHAR));
    pwszT2 += cwcBase;

    wcscpy(pwszT2, wszFCSAPARM_CERTFILENAMESUFFIX);
    wcscat(pwszT2, pwszExt);

    hr = mySetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegValueName,
			pwszT);
    _JumpIfErrorStr(hr, error, "mySetCertRegStrValue", pwszRegValueName);

error:
    if (NULL != pwszMatch)
    {
	LocalFree(pwszMatch);
    }
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    return(hr);
}


HRESULT
myGetCARegFileNameTemplate(
    IN WCHAR const *pwszRegValueName,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszSanitizedName,
    IN DWORD iCert,
    IN DWORD iCRL,
    OUT WCHAR **ppwszFileName)
{
    HRESULT hr;
    WCHAR *pwszT = NULL;

    *ppwszFileName = NULL;

    hr = myGetCertRegStrValue(
			pwszSanitizedName,
			NULL,
			NULL,
			pwszRegValueName,
			&pwszT);
    _JumpIfErrorStr2(
		hr,
		error,
		"myGetCertRegStrValue",
		pwszRegValueName,
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

    hr = myFormatCertsrvStringArray(
			    FALSE,		// fURL
			    pwszServerName,	// pwszServerName_p1_2
			    pwszSanitizedName,	// pwszSanitizedName_p3_7
			    iCert,		// iCert_p4
			    MAXDWORD,		// iCertTarget_p4
			    L"",		// pwszDomainDN_p5
			    L"", 		// pwszConfigDN_p6
			    iCRL,		// iCRL_p8
			    FALSE,		// fDeltaCRL_p9
			    FALSE,		// fDSAttrib_p10_11
			    1,			// cStrings
			    (LPCWSTR *) &pwszT,	// apwszStringsIn
			    ppwszFileName);	// apwszStringsOut
    _JumpIfError(hr, error, "myFormatCertsrvStringArray");

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\request.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       request.cpp
//
//  Contents:   ICertRequest IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTLIB_REQUEST_CPP__


//+------------------------------------------------------------------------
// ICertRequest dispatch support

//TCHAR szRegKeyRequestClsid[] = wszCLASS_CERTREQUEST TEXT("\\Clsid");

//+------------------------------------
// Submit method:

static OLECHAR *_apszSubmit[] = {
    TEXT("Submit"),
    TEXT("Flags"),
    TEXT("strRequest"),
    TEXT("strAttributes"),
    TEXT("strConfig"),
};

//+------------------------------------
// RetrievePending method:

static OLECHAR *_apszRetrievePending[] = {
    TEXT("RetrievePending"),
    TEXT("RequestId"),
    TEXT("strConfig"),
};

//+------------------------------------
// GetLastStatus method:

static OLECHAR *_apszGetLastStatus[] = {
    TEXT("GetLastStatus"),
};

//+------------------------------------
// GetRequestId method:

static OLECHAR *_apszGetRequestId[] = {
    TEXT("GetRequestId"),
};

//+------------------------------------
// GetDispositionMessage method:

static OLECHAR *_apszGetDispositionMessage[] = {
    TEXT("GetDispositionMessage"),
};

//+------------------------------------
// GetCACertificate method:

static OLECHAR *_apszGetCACertificate[] = {
    TEXT("GetCACertificate"),
    TEXT("fExchangeCertificate"),
    TEXT("strConfig"),
    TEXT("Flags"),
};

//+------------------------------------
// GetCertificate method:

static OLECHAR *_apszGetCertificate[] = {
    TEXT("GetCertificate"),
    TEXT("Flags"),
};

//+------------------------------------
// GetIssuedCertificate method:

static OLECHAR *_apszGetIssuedCertificate[] = {
    TEXT("GetIssuedCertificate"),
    TEXT("strConfig"),
    TEXT("RequestId"),
    TEXT("strSerialNumber"),
};

//+------------------------------------
// GetErrorMessageText method:

static OLECHAR *_apszGetErrorMessageText[] = {
    TEXT("GetErrorMessageText"),
    TEXT("hrMessage"),
    TEXT("Flags"),
};

//+------------------------------------
// GetCAProperty method:

static OLECHAR *_apszGetCAProperty[] = {
    TEXT("GetCAProperty"),
    TEXT("strConfig"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("Flags"),
};

//+------------------------------------
// GetCAPropertyFlags method:

static OLECHAR *_apszGetCAPropertyFlags[] = {
    TEXT("GetCAPropertyFlags"),
    TEXT("strConfig"),
    TEXT("PropId"),
};

//+------------------------------------
// GetCAPropertyDisplayName method:

static OLECHAR *_apszGetCAPropertyDisplayName[] = {
    TEXT("GetCAPropertyDisplayName"),
    TEXT("strConfig"),
    TEXT("PropId"),
};


//+------------------------------------
// GetFullResponseProperty method:

static OLECHAR *_apszGetFullResponseProperty[] = {
    TEXT("GetFullResponseProperty"),
    TEXT("PropId"),
    TEXT("PropIndex"),
    TEXT("PropType"),
    TEXT("Flags"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtRequest[] =
{
#define REQUEST_SUBMIT				0
    DECLARE_DISPATCH_ENTRY(_apszSubmit)

#define REQUEST_RETRIEVEPENDING			1
    DECLARE_DISPATCH_ENTRY(_apszRetrievePending)

#define REQUEST_GETLASTSTATUS			2
    DECLARE_DISPATCH_ENTRY(_apszGetLastStatus)

#define REQUEST_GETREQUESTID			3
    DECLARE_DISPATCH_ENTRY(_apszGetRequestId)

#define REQUEST_GETDISPOSITIONMESSAGE		4
    DECLARE_DISPATCH_ENTRY(_apszGetDispositionMessage)

#define REQUEST_GETCACERTIFICATE		5
    DECLARE_DISPATCH_ENTRY(_apszGetCACertificate)

#define REQUEST_GETCERTIFICATE			6
    DECLARE_DISPATCH_ENTRY(_apszGetCertificate)

#define REQUEST2_GETISSUEDCERTIFICATE		7
    DECLARE_DISPATCH_ENTRY(_apszGetIssuedCertificate)

#define REQUEST2_GETERRORMESSAGETEXT		8
    DECLARE_DISPATCH_ENTRY(_apszGetErrorMessageText)

#define REQUEST2_GETCAPROPERTY 			9
    DECLARE_DISPATCH_ENTRY(_apszGetCAProperty)

#define REQUEST2_GETCAPROPERTYFLAGS 		10
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyFlags)

#define REQUEST2_GETCAPROPERTYDISPLAYNAME	11
    DECLARE_DISPATCH_ENTRY(_apszGetCAPropertyDisplayName)

#define REQUEST2_GETFULLRESPONSEPROPERTY	12
    DECLARE_DISPATCH_ENTRY(_apszGetFullResponseProperty)
};
#define CREQUESTDISPATCH	(ARRAYSIZE(s_adtRequest))
#define CREQUESTDISPATCH_V1	REQUEST2_GETISSUEDCERTIFICATE
#define CREQUESTDISPATCH_V2	CREQUESTDISPATCH


DWORD s_acRequestDispatch[] = {
    CREQUESTDISPATCH_V2,
    CREQUESTDISPATCH_V1,
};

IID const *s_apRequestiid[] = {
    &IID_ICertRequest2,
    &IID_ICertRequest,
};


HRESULT
Request_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiRequest)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTREQUEST,
		&CLSID_CCertRequest,
		ARRAYSIZE(s_acRequestDispatch),		// cver
		s_apRequestiid,
		s_acRequestDispatch,
		s_adtRequest,
		pdiRequest);
    _JumpIfError(hr, error, "DispatchSetup2(ICertRequest)");

error:
    return(hr);
}


VOID
Request_Release(
    IN OUT DISPATCHINTERFACE *pdiRequest)
{
    DispatchRelease(pdiRequest);
}


HRESULT
RequestVerifyVersion(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    switch (pdiRequest->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiRequest->pDispatch ||
		CREQUESTDISPATCH_V1 == pdiRequest->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiRequest->pDispatch ||
		CREQUESTDISPATCH_V2 == pdiRequest->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiRequest->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
Request_Submit(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG Flags,
    IN WCHAR const *pwszRequest,
    IN DWORD cbRequest,
    IN WCHAR const *pwszAttributes,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strRequest = NULL;
    BSTR strAttributes = NULL;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL == pwszRequest || NULL == pwszConfig)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "NULL parm");
    }
    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strRequest, pwszRequest, cbRequest))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strAttributes, pwszAttributes, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strRequest;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strAttributes;

	avar[3].vt = VT_BSTR;
	avar[3].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_SUBMIT,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(Submit)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->Submit(
							Flags,
							strRequest,
							strAttributes,
							strConfig,
							pDisposition);
	_JumpIfError2(
		hr,
		error,
		"ICertRequest::Submit",
		HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
    }

error:
    if (NULL != strRequest)
    {
	SysFreeString(strRequest);
    }
    if (NULL != strAttributes)
    {
	SysFreeString(strAttributes);
    }
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Request_RetrievePending(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG RequestId,
    IN WCHAR const *pwszConfig,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = RequestId;

	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_RETRIEVEPENDING,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(RetrievePending)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->RetrievePending(
							RequestId,
							strConfig,
							pDisposition);
	_JumpIfError(hr, error, "ICertRequest::RetrievePending");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Request_GetLastStatus(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pLastStatus)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETLASTSTATUS,
			0,
			NULL,
			VT_I4,
			pLastStatus);
	_JumpIfError(hr, error, "Invoke(GetLastStatus)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetLastStatus(
							pLastStatus);
	_JumpIfError(hr, error, "ICertRequest::GetLastStatus");
    }

error:
    return(hr);
}


HRESULT
Request_GetRequestId(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT LONG *pRequestId)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETREQUESTID,
			0,
			NULL,
			VT_I4,
			pRequestId);
	_JumpIfError(hr, error, "Invoke(GetRequestId)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetRequestId(pRequestId);
	_JumpIfError(hr, error, "ICertRequest::GetRequestId");
    }

error:
    return(hr);
}


HRESULT
Request_GetDispositionMessage(
    IN DISPATCHINTERFACE *pdiRequest,
    OUT BSTR *pstrMessage)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETDISPOSITIONMESSAGE,
			0,
			NULL,
			VT_BSTR,
			pstrMessage);
	_JumpIfError(hr, error, "Invoke(GetDispositionMessage)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetDispositionMessage(
							pstrMessage);
	_JumpIfError(hr, error, "ICertRequest::GetDispositionMessage");
    }

error:
    return(hr);
}


HRESULT
Request_GetCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN DWORD Flags,
    OUT BSTR *pstrCert)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrCert);
	_JumpIfError(hr, error, "Invoke(GetCertificate)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetCertificate(
							Flags,
							pstrCert);
	_JumpIfError(hr, error, "ICertRequest::GetCertificate");
    }

error:
    return(hr);
}


HRESULT
Request_GetCACertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG fExchangeCertificate,
    IN WCHAR const *pwszConfig,
    IN DWORD Flags,
    OUT BSTR *pstrCert)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_I4;
	avar[0].lVal = fExchangeCertificate;

	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strConfig;

	avar[2].vt = VT_I4;
	avar[2].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST_GETCACERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrCert);
	_JumpIfError(hr, error, "Invoke(GetCACertificate)");
    }
    else
    {
	hr = ((ICertRequest *) pdiRequest->pUnknown)->GetCACertificate(
							fExchangeCertificate,
							strConfig,
							Flags,
							pstrCert);
	_JumpIfError2(
		    hr,
		    error,
		    "ICertRequest::GetCACertificate",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
Request2_GetIssuedCertificate(
    IN DISPATCHINTERFACE *pdiRequest,
    IN WCHAR const *pwszConfig,
    IN LONG RequestId,
    IN WCHAR const *pwszSerialNumber,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    BSTR strConfig = NULL;
    BSTR strSerialNumber = NULL;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    hr = RequestVerifyVersion(pdiRequest, 2);
    _JumpIfError(hr, error, "RequestVerifyVersion");

    hr = E_OUTOFMEMORY;
    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pwszSerialNumber &&
	!ConvertWszToBstr(&strSerialNumber, pwszSerialNumber, -1))
    {
	_JumpError(hr, error, "ConvertWszToBstr");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[3];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	avar[1].vt = VT_I4;
	avar[1].lVal = RequestId;

	avar[2].vt = VT_BSTR;
	avar[2].bstrVal = strSerialNumber;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST2_GETISSUEDCERTIFICATE,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pDisposition);
	_JumpIfError(hr, error, "Invoke(GetIssuedCertificate)");
    }
    else
    {
	hr = ((ICertRequest2 *) pdiRequest->pUnknown)->GetIssuedCertificate(
							strConfig,
							RequestId,
							strSerialNumber,
							pDisposition);
	_JumpIfError(hr, error, "ICertRequest2::GetIssuedCertificate");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    if (NULL != strSerialNumber)
    {
	SysFreeString(strSerialNumber);
    }
    return(hr);
}


HRESULT
Request2_GetErrorMessageText(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG hrMessage,
    IN LONG Flags,
    OUT BSTR *pstrErrorMessageText)
{
    HRESULT hr;

    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    hr = RequestVerifyVersion(pdiRequest, 2);
    _JumpIfError(hr, error, "RequestVerifyVersion");

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = hrMessage;

	avar[1].vt = VT_I4;
	avar[1].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST2_GETERRORMESSAGETEXT,
			ARRAYSIZE(avar),
			avar,
			VT_BSTR,
			pstrErrorMessageText);
	_JumpIfError(hr, error, "Invoke(GetErrorMessageText)");
    }
    else
    {
	hr = ((ICertRequest2 *) pdiRequest->pUnknown)->GetErrorMessageText(
							hrMessage,
							Flags,
							pstrErrorMessageText);
	_JumpIfError(hr, error, "ICertRequest2::GetErrorMessageText");
    }

error:
    return(hr);
}


HRESULT
Request2_GetFullResponseProperty(
    IN DISPATCHINTERFACE *pdiRequest,
    IN LONG PropId,
    IN LONG PropIndex,
    IN LONG PropType,
    IN LONG Flags,		// CR_OUT_*
    OUT VOID *pPropertyValue)
{
    HRESULT hr;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiRequest && NULL != pdiRequest->pDispatchTable);

    switch (PropType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropType");
    }

    if (NULL != pdiRequest->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_I4;
	avar[0].lVal = PropId;

	avar[1].vt = VT_I4;
	avar[1].lVal = PropIndex;

	avar[2].vt = VT_I4;
	avar[2].lVal = PropType;

	avar[3].vt = VT_I4;
	avar[3].lVal = Flags;

	hr = DispatchInvoke(
			pdiRequest,
			REQUEST2_GETFULLRESPONSEPROPERTY,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pPropertyValue);
	if (S_OK != hr)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"GetFullResponseProperty: PropId=%x Index=%x Type=%x Flags=%x\n",
		PropId,
		PropIndex,
		PropType,
		Flags));
	}
	_JumpIfError2(
		    hr,
		    error,
		    "GetFullResponseProperty",
		    CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = ((ICertRequest2 *) pdiRequest->pUnknown)->GetFullResponseProperty(
						    PropId,
						    PropIndex,
						    PropType,
						    Flags,
						    &varResult);
	_JumpIfError2(
		    hr,
		    error,
		    "ICertRequest2::GetFullResponseProperty",
		    CERTSRV_E_PROPERTY_EMPTY);

	hr = DispatchGetReturnValue(&varResult, RetType, pPropertyValue);
	_JumpIfError(hr, error, "DispatchGetReturnValue");
    }

error:
    VariantClear(&varResult);
    return(hr);
}


#undef __dwFILE__
#define CCERTREQUEST
#include "prop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\view.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       view.cpp
//
//  Contents:   ICertView IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_VIEW_CPP__


//+------------------------------------------------------------------------
// ICertView dispatch support

//WCHAR wszRegKeyViewClsid[] = wszCLASS_CERTVIEW TEXT("\\Clsid");

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszOpenConnection[] = {
    TEXT("OpenConnection"),
    TEXT("strConfig"),
};

//+------------------------------------
// EnumCertViewColumn method:

static OLECHAR *_apszEnumCertViewColumn[] = {
    TEXT("EnumCertViewColumn"),
    TEXT("fResultColumn"),
};

//+------------------------------------
// GetColumnCount method:

static OLECHAR *_apszGetColumnCount[] = {
    TEXT("GetColumnCount"),
    TEXT("fResultColumn"),
};

//+------------------------------------
// GetColumnIndex method:

static OLECHAR *_apszGetColumnIndex[] = {
    TEXT("GetColumnIndex"),
    TEXT("fResultColumn"),
    TEXT("strColumnName"),
};

//+------------------------------------
// SetResultColumnCount method:

static OLECHAR *_apszSetResultColumnCount[] = {
    TEXT("SetResultColumnCount"),
    TEXT("cResultColumn"),
};

//+------------------------------------
// SetResultColumn method:

static OLECHAR *_apszSetResultColumn[] = {
    TEXT("SetResultColumn"),
    TEXT("ColumnIndex"),
};

//+------------------------------------
// SetRestriction method:

static OLECHAR *_apszSetRestriction[] = {
    TEXT("SetRestriction"),
    TEXT("ColumnIndex"),
    TEXT("SeekOperator"),
    TEXT("SortOrder"),
    TEXT("pvarValue"),
};

//+------------------------------------
// OpenView method:

static OLECHAR *_apszOpenView[] = {
    TEXT("OpenView"),
};

//+------------------------------------
// SetTable method:

static OLECHAR *_apszSetTable[] = {
    TEXT("SetTable"),
    TEXT("Table"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE s_adtView[] =
{
#define VIEW_OPENCONNECTION		0
    DECLARE_DISPATCH_ENTRY(_apszOpenConnection)

#define VIEW_ENUMCERTVIEWCOLUMN		1
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewColumn)

#define VIEW_GETCOLUMNCOUNT		2
    DECLARE_DISPATCH_ENTRY(_apszGetColumnCount)

#define VIEW_GETCOLUMNINDEX		3
    DECLARE_DISPATCH_ENTRY(_apszGetColumnIndex)

#define VIEW_SETRESULTCOLUMNCOUNT	4
    DECLARE_DISPATCH_ENTRY(_apszSetResultColumnCount)

#define VIEW_SETRESULTCOLUMN		5
    DECLARE_DISPATCH_ENTRY(_apszSetResultColumn)

#define VIEW_SETRESTRICTION		6
    DECLARE_DISPATCH_ENTRY(_apszSetRestriction)

#define VIEW_OPENVIEW			7
    DECLARE_DISPATCH_ENTRY(_apszOpenView)

#define VIEW2_SETTABLE			8
    DECLARE_DISPATCH_ENTRY(_apszSetTable)
};
#define CVIEWDISPATCH		(ARRAYSIZE(s_adtView))
#define CVIEWDISPATCH_V1	VIEW2_SETTABLE
#define CVIEWDISPATCH_V2	CVIEWDISPATCH


DWORD s_acViewDispatch[] = {
    CVIEWDISPATCH_V2,
    CVIEWDISPATCH_V1,
};

IID const *s_apViewiid[] = {
    &IID_ICertView2,
    &IID_ICertView,
};


HRESULT
View_Init(
    IN DWORD Flags,
    OUT DISPATCHINTERFACE *pdiView)
{
    HRESULT hr;

    hr = DispatchSetup2(
		Flags,
		CLSCTX_INPROC_SERVER,
		wszCLASS_CERTVIEW,
		&CLSID_CCertView,
		ARRAYSIZE(s_acViewDispatch),		// cver
		s_apViewiid,
		s_acViewDispatch,
		s_adtView,
		pdiView);
    _JumpIfError(hr, error, "DispatchSetup2(ICertView)");

error:
    return(hr);
}


VOID
View_Release(
    IN OUT DISPATCHINTERFACE *pdiView)
{
    DispatchRelease(pdiView);
}


HRESULT
ViewVerifyVersion(
    IN DISPATCHINTERFACE *pdiView,
    IN DWORD RequiredVersion)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    switch (pdiView->m_dwVersion)
    {
	case 1:
	    CSASSERT(
		NULL == pdiView->pDispatch ||
		CVIEWDISPATCH_V1 == pdiView->m_cDispatchTable);
	    break;

	case 2:
	    CSASSERT(
		NULL == pdiView->pDispatch ||
		CVIEWDISPATCH_V2 == pdiView->m_cDispatchTable);
	    break;

	default:
	    hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
	    _JumpError(hr, error, "m_dwVersion");
    }
    if (pdiView->m_dwVersion < RequiredVersion)
    {
	hr = E_NOTIMPL;
	_JumpError(hr, error, "old interface");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
View_OpenConnection(
    IN DISPATCHINTERFACE *pdiView,
    IN WCHAR const *pwszConfig)
{
    HRESULT hr;
    BSTR strConfig = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (!ConvertWszToBstr(&strConfig, pwszConfig, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_BSTR;
	avar[0].bstrVal = strConfig;

	hr = DispatchInvoke(
			pdiView,
			VIEW_OPENCONNECTION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(OpenConnection)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->OpenConnection(strConfig);
	_JumpIfError(hr, error, "OpenConnection");
    }

error:
    if (NULL != strConfig)
    {
	SysFreeString(strConfig);
    }
    return(hr);
}


HRESULT
View_GetColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    OUT LONG *pcColumn)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = fResultColumn;

	hr = DispatchInvoke(
			pdiView,
			VIEW_GETCOLUMNCOUNT,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pcColumn);
	_JumpIfError(hr, error, "Invoke(GetColumnCount)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->GetColumnCount(
							fResultColumn,
							pcColumn);
	_JumpIfError(hr, error, "GetColumnCount");
    }

error:
    return(hr);
}


HRESULT
View_GetColumnIndex(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    IN WCHAR const *pwszColumnName,
    OUT LONG *pColumnIndex)
{
    HRESULT hr;
    BSTR strColumnName = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (!ConvertWszToBstr(&strColumnName, pwszColumnName, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[2];

	avar[0].vt = VT_I4;
	avar[0].lVal = fResultColumn;
	avar[1].vt = VT_BSTR;
	avar[1].bstrVal = strColumnName;

	hr = DispatchInvoke(
			pdiView,
			VIEW_GETCOLUMNINDEX,
			ARRAYSIZE(avar),
			avar,
			VT_I4,
			pColumnIndex);
	_JumpIfError(hr, error, "Invoke(GetColumnIndex)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->GetColumnIndex(
							fResultColumn,
							strColumnName,
							pColumnIndex);
	_JumpIfError(hr, error, "GetColumnIndex");
    }

error:
    if (NULL != strColumnName)
    {
	SysFreeString(strColumnName);
    }
    return(hr);
}


HRESULT
View_SetResultColumnCount(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG cResultColumn)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = cResultColumn;

	hr = DispatchInvoke(
			pdiView,
			VIEW_SETRESULTCOLUMNCOUNT,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetResultColumnCount)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->SetResultColumnCount(cResultColumn);
	_JumpIfError(hr, error, "SetResultColumnCount");
    }

error:
    return(hr);
}


HRESULT
View_SetResultColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = ColumnIndex;

	hr = DispatchInvoke(
			pdiView,
			VIEW_SETRESULTCOLUMN,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetResultColumn)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->SetResultColumn(ColumnIndex);
	_JumpIfError(hr, error, "SetResultColumn");
    }

error:
    return(hr);
}


HRESULT
View_SetRestriction(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG ColumnIndex,
    IN LONG SeekOperator,
    IN LONG SortOrder,
    IN VARIANT const *pvarValue)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[4];

	avar[0].vt = VT_I4;
	avar[0].lVal = ColumnIndex;

	avar[1].vt = VT_I4;
	avar[1].lVal = SeekOperator;

	avar[2].vt = VT_I4;
	avar[2].lVal = SortOrder;

	avar[3] = *pvarValue;

	hr = DispatchInvoke(
			pdiView,
			VIEW_SETRESTRICTION,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetRestriction)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->SetRestriction(
							ColumnIndex,
							SeekOperator,
							SortOrder,
							pvarValue);
	_JumpIfError(hr, error, "SetRestriction");
    }

error:
    return(hr);
}


HRESULT
View_OpenView(
    IN DISPATCHINTERFACE *pdiView,
    OUT DISPATCHINTERFACE *pdiViewRow)
{
    HRESULT hr;
    IEnumCERTVIEWROW *pEnumRow = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	hr = DispatchInvoke(
			pdiView,
			VIEW_OPENVIEW,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumRow);
	_JumpIfError(hr, error, "Invoke(OpenView)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->OpenView(&pEnumRow);
	_JumpIfError(hr, error, "OpenView");
    }
    hr = ViewRow_Init2(NULL != pdiView->pDispatch, pEnumRow, pdiViewRow);
    _JumpIfError(hr, error, "ViewRow_Init2");

error:
    if (NULL != pEnumRow)
    {
	pEnumRow->Release();
    }
    return(hr);
}


HRESULT
View2_SetTable(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG Table)
{
    HRESULT hr;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    hr = ViewVerifyVersion(pdiView, 2);
    _JumpIfError(hr, error, "ViewVerifyVersion");

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Table;

	hr = DispatchInvoke(
			pdiView,
			VIEW2_SETTABLE,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(SetTable)");
    }
    else
    {
	hr = ((ICertView2 *) pdiView->pUnknown)->SetTable(Table);
	_JumpIfError(hr, error, "SetTable");
    }

error:
    return(hr);
}


HRESULT
View_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiView,
    IN LONG fResultColumn,
    OUT DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pEnumColumn = NULL;

    CSASSERT(NULL != pdiView && NULL != pdiView->pDispatchTable);

    if (NULL != pdiView->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = fResultColumn;

	hr = DispatchInvoke(
			pdiView,
			VIEW_ENUMCERTVIEWCOLUMN,
			ARRAYSIZE(avar),
			avar,
			VT_DISPATCH,
			&pEnumColumn);
	_JumpIfError(hr, error, "Invoke(EnumCertViewColumn)");
    }
    else
    {
	hr = ((ICertView *) pdiView->pUnknown)->EnumCertViewColumn(
								 fResultColumn,
								 &pEnumColumn);
	_JumpIfError(hr, error, "EnumCertViewColumn");
    }
    hr = ViewColumn_Init2(
		    NULL != pdiView->pDispatch,
		    pEnumColumn,
		    pdiViewColumn);
    _JumpIfError(hr, error, "ViewColumn_Init2");

error:
    if (NULL != pEnumColumn)
    {
	pEnumColumn->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\tmpllist.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        tmpllist.cpp
//
// Contents:    certificate template list class
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certadmd.h"
#include "tmpllist.h"

#define __dwFILE__	__dwFILE_CERTLIB_TMPLLIST_CPP__


using namespace CertSrv;

HRESULT CTemplateInfo::SetInfo(
    LPCWSTR pcwszTemplateName,
    LPCWSTR pcwszTemplateOID)
{
    HRESULT hr = S_OK;

    if(pcwszTemplateName)
    {
        m_pwszTemplateName = (LPWSTR)LocalAlloc(
            LMEM_FIXED, 
            sizeof(WCHAR)*(wcslen(pcwszTemplateName)+1));
        _JumpIfAllocFailed(m_pwszTemplateName, error);
        wcscpy(m_pwszTemplateName, pcwszTemplateName);
    }

    if(pcwszTemplateOID)
    {
        m_pwszTemplateOID = (LPWSTR)LocalAlloc(
            LMEM_FIXED, 
            sizeof(WCHAR)*(wcslen(pcwszTemplateOID)+1));
        _JumpIfAllocFailed(m_pwszTemplateOID, error);
        wcscpy(m_pwszTemplateOID, pcwszTemplateOID);
    }

error:
    return hr;
}

LPCWSTR CTemplateInfo::GetName()
{
    if(!m_pwszTemplateName && m_hCertType)
    {
        FillInfoFromProperty(
            m_pwszTemplateName, 
            CERTTYPE_PROP_CN);
    }
    return m_pwszTemplateName;
}

LPCWSTR CTemplateInfo::GetOID()
{
    if(!m_pwszTemplateOID && m_hCertType)
    {
        FillInfoFromProperty(
            m_pwszTemplateOID, 
            CERTTYPE_PROP_OID);
    }
    return m_pwszTemplateOID;
}

void CTemplateInfo::FillInfoFromProperty(
    LPWSTR& pwszProp, 
    LPCWSTR pcwszPropName)
{
    LPWSTR *ppwszProp = NULL;
    CAGetCertTypeProperty(
            m_hCertType,
            pcwszPropName,
            &ppwszProp);

    if(ppwszProp && ppwszProp[0])
    {
        pwszProp = (LPWSTR)LocalAlloc(
            LMEM_FIXED,
            sizeof(WCHAR)*(wcslen(ppwszProp[0])+1));
        if(pwszProp)
            wcscpy(pwszProp, ppwszProp[0]);
    }

    if(ppwszProp)
    {
        CAFreeCertTypeProperty(
                    m_hCertType,
                    ppwszProp);
    }
}

bool CTemplateInfo::operator==(CTemplateInfo& rh)
{
    if(GetName() && rh.GetName())
        return 0==_wcsicmp(GetName(), rh.GetName());
    
    if(GetOID() && rh.GetOID())
        return 0==wcscmp(GetOID(), rh.GetOID());

    return false;
}



HRESULT CTemplateList::AddTemplateInfo(
    LPCWSTR pcwszTemplateName,
    LPCWSTR pcwszTemplateOID)
{
    HRESULT hr = S_OK;

    CTemplateInfo *pTI = NULL;

    pTI = new CTemplateInfo;
    _JumpIfAllocFailed(pTI, error);

    hr = pTI->SetInfo(pcwszTemplateName, pcwszTemplateOID);
    _JumpIfError(hr, error, "SetInfo");

    if(!AddTail(pTI))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "AddTail");
    }

error:
    return hr;
}

HRESULT CTemplateList::AddTemplateInfo(
    IN HCERTTYPE hCertType,
    IN BOOL fTransientCertTypeHandle) // don't hang onto hCertType
{
    HRESULT hr = S_OK;
    CTemplateInfo *pTI = NULL;
    WCHAR **apwszCertTypeCN = NULL;
    WCHAR **apwszCertTypeOID = NULL;
    WCHAR const *pwszCertTypeOID;

    pTI = new CTemplateInfo;
    _JumpIfAllocFailed(pTI, error);

    if (fTransientCertTypeHandle)
    {
        hr = CAGetCertTypeProperty(
                            hCertType,
                            CERTTYPE_PROP_CN,
                            &apwszCertTypeCN);
        _JumpIfError(hr, error, "CAGetCertTypeProperty CERTTYPE_PROP_CN");

	if (NULL == apwszCertTypeCN || NULL == apwszCertTypeCN[0])
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "CERTTYPE_PROP_CN");
	}

        hr = CAGetCertTypeProperty(
                            hCertType,
                            CERTTYPE_PROP_OID,
                            &apwszCertTypeOID);
	// ignore errors, V1 templates don't have OIDs
        _PrintIfError2(hr, "CAGetCertTypeProperty CERTTYPE_PROP_OID", hr);
	pwszCertTypeOID = NULL != apwszCertTypeOID? apwszCertTypeCN[0] : NULL;

	pTI->SetInfo(apwszCertTypeCN[0], pwszCertTypeOID);
	_JumpIfErrorStr(hr, error, "SetInfr", apwszCertTypeCN[0]);
    }
    else
    {
	hr = pTI->SetInfo(hCertType);
	_JumpIfError(hr, error, "SetInfo");
    }

    if(!AddTail(pTI))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "AddTail");
    }

error:
    if (NULL != apwszCertTypeCN)
    {
	CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
    }
    if (NULL != apwszCertTypeOID)
    {
	CAFreeCertTypeProperty(hCertType, apwszCertTypeOID);
    }
    return hr;
}

DWORD CTemplateList::GetMarshalBufferSize() const
{
    DWORD dwSize = sizeof(WCHAR); // at least a trailing zero
    CTemplateListEnum EnumList(*this);

    for(CTemplateInfo *pData=EnumList.Next(); 
        pData; 
        pData=EnumList.Next())
    {
        dwSize += pData->GetMarshalBufferSize();
    }

    return dwSize;
}


// Marshals the template information into a buffer, strings separated
// by new lines:
//
//     "name1\nOID1\nname2\OID2...\nnameN\nOIDN\0"
//
// If the template doesn't have an OID (Win2k domain) there will
// be an empty string in its place

HRESULT CTemplateList::Marshal(BYTE*& rpBuffer, DWORD& rcBuffer) const
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = GetMarshalBufferSize();
    CTemplateListEnum EnumList(*this);
    WCHAR *pb;

    rpBuffer = NULL;
    rcBuffer = 0;

    // build the marshaling buffer
    rpBuffer = (BYTE*) MIDL_user_allocate(dwBufferSize);
    _JumpIfAllocFailed(rpBuffer, error);

    pb=(WCHAR*)rpBuffer;
    for(CTemplateInfo *pData=EnumList.Next();
        pData; 
        pData=EnumList.Next())
    {
        if(pData->GetName())
        {
            wcscpy(pb, pData->GetName());
            pb += wcslen(pData->GetName());
        }
        // replace trailing zero with the separator character
        *pb = m_gcchSeparator;
        // jump over to insert the OID
        pb++;

        if(pData->GetOID())
        {
            wcscpy(pb, pData->GetOID());
            pb += wcslen(pData->GetOID());
        }
        // replace trailing zero with the separator character
        *pb = m_gcchSeparator;
        // jump over to insert the OID
        pb++;

    }

    // add string terminator
    *pb = L'\0';

    rcBuffer = dwBufferSize;

error:
    return hr;
}

HRESULT CTemplateList::ValidateMarshalBuffer(const BYTE *pBuffer, DWORD cBuffer) const
{
    const hrError = E_INVALIDARG;

    if(cBuffer&1)
    {
        _PrintError(hrError,
            "ValidateMarshalBuffer: buffer contains unicode string, "
            "buffer size should be even");
        return hrError;
    }

    if(cBuffer==0)
    {
        return S_OK;
    }
    
    if(cBuffer==2)
    {
        if(*(WCHAR*)pBuffer==L'\0')
            return S_OK;
        else
        {
            _PrintErrorStr(hrError, 
                "ValidateMarshalBuffer: buffer size is 2 but string is not empty",
                (WCHAR*)pBuffer);
            return hrError;
        }
    }
    
    if(L'\0' != *(WCHAR*)(pBuffer+cBuffer-sizeof(WCHAR)))
    {
        _PrintErrorStr(hrError, 
            "ValidateMarshalBuffer: buffer doesn't end with a null string terminator",
            (WCHAR*)pBuffer);
        return hrError;
    }

    // should contain an even number of separators
    DWORD cSeparators = 0;

    for(WCHAR *pCrt = (WCHAR*)pBuffer; 
        pCrt && *pCrt!=L'\0' && ((BYTE*)pCrt) < pBuffer+cBuffer;
        pCrt++, cSeparators++)
    {
        pCrt = wcschr(pCrt, m_gcchSeparator);
        if(!pCrt)
            break;
    }

    if(cSeparators&1)
    {
        _PrintErrorStr(hrError, 
            "ValidateMarshalBuffer: buffer should contain an even number of separators",
            (WCHAR*)pBuffer);
        return hrError;
    }

    if(cBuffer>1 && cSeparators<2)
    {
        _PrintErrorStr(hrError, 
            "ValidateMarshalBuffer: nonempty buffer should contain at least two separators",
            (WCHAR*)pBuffer);
        return hrError;
    }


    return S_OK;
}

HRESULT CTemplateList::Unmarshal(const BYTE *pBuffer, DWORD cBuffer)
{
    HRESULT hr = S_OK;
    WCHAR *pCrt, *pNext, *pwszName, *pwszOID;

    hr = ValidateMarshalBuffer(pBuffer, cBuffer);
    _JumpIfError(hr, error, "CTemplateList::ValidateMarshalBuffer");

    for(pCrt = (WCHAR*)pBuffer; *pCrt!=L'\0';)
    {
        pwszName = pCrt;
        pNext = wcschr(pCrt, m_gcchSeparator);
        if(!pNext)
            break;
        *pNext++ = L'\0';
        pwszOID = pNext;
        pNext = wcschr(pNext, m_gcchSeparator);
        if(!pNext)
            break;
        *pNext++ = L'\0';
        hr = AddTemplateInfo(pwszName, pwszOID);
        _JumpIfError(hr, error, "CTemplateList::AddTemplateInfo");

        pCrt = pNext;
    }

error:
    return hr;
}

HRESULT CTemplateList::RemoveTemplateInfo(HCERTTYPE hCertType)
{
    HRESULT hr = S_OK;
    CTemplateListEnum EnumList(*this);
    CTemplateInfo *pData;
    DWORD dwPosition = 0;
    CTemplateInfo tempInfo;

    hr = tempInfo.SetInfo(hCertType);
    if(S_OK!=hr)
        return hr;

    for(pData = EnumList.Next();
        pData;
        pData = EnumList.Next(), dwPosition++)
    {
        if(*pData == tempInfo)
            break;
    }

    if(!pData)
        return S_FALSE;

    RemoveAt(dwPosition);

    return S_OK;
}

//
// Loads the structure with all known templates from DS
HRESULT CTemplateList::LoadTemplatesFromDS()
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;
    WCHAR **apwszCertTypeCN = NULL;
    WCHAR **apwszCertTypeOID = NULL;

    hr = CAEnumCertTypes(
        CT_ENUM_USER_TYPES |
        CT_ENUM_MACHINE_TYPES |
        CT_FLAG_NO_CACHE_LOOKUP,
        &hCertType);
    _JumpIfError(hr, error, "CAEnumCertTypes");

    while (hCertType)
    {
	HCERTTYPE hCertTypeNext;

        CAGetCertTypeProperty(
            hCertType,
            CERTTYPE_PROP_DN,
            &apwszCertTypeCN);

        CAGetCertTypeProperty(
            hCertType,
            CERTTYPE_PROP_OID,
            &apwszCertTypeOID);

        if((apwszCertTypeCN && apwszCertTypeCN[0])||
           (apwszCertTypeOID && apwszCertTypeOID[0]))
        {
            hr = AddTemplateInfo(
                apwszCertTypeCN[0],
                apwszCertTypeOID[0]);
            _JumpIfError(hr, error, "AddTemplateInfo");
        }

        CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
        CAFreeCertTypeProperty(hCertType, apwszCertTypeOID);
	apwszCertTypeCN = NULL;
	apwszCertTypeOID = NULL;

        hr = CAEnumNextCertType(hCertType, &hCertTypeNext);
        _JumpIfError(hr, error, "CAEnumNextCertType");

        CACloseCertType(hCertType);
	hCertType = hCertTypeNext;
    }

    hr = S_OK;

error:
    if (NULL != hCertType)
    {
	if (NULL != apwszCertTypeCN)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeCN);
	}
	if (NULL != apwszCertTypeOID)
	{
	    CAFreeCertTypeProperty(hCertType, apwszCertTypeOID);
	}
        CACloseCertType(hCertType);
    }
    return hr;
}


HRESULT
RetrieveCATemplateListFromCA(
    IN HCAINFO hCAInfo,
    OUT CTemplateList& list)
{
    HRESULT hr = S_OK;
    LPWSTR *ppwszDNSName = NULL;
    LPWSTR *ppwszAuthority = NULL;
    ICertAdminD2 *pAdminD2 = NULL;
    DWORD dwServerVersion = 2;
    CERTTRANSBLOB ctbSD;

    ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &ppwszDNSName);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_DNSNAME");

    hr = CAGetCAProperty(hCAInfo, CA_PROP_NAME, &ppwszAuthority);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_NAME");

    ASSERT(ppwszDNSName[0]);

    hr = myOpenAdminDComConnection(
                    ppwszDNSName[0],
                    NULL,
                    NULL,
                    &dwServerVersion,
                    &pAdminD2);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, error, "old server");
    }

    CSASSERT(ppwszAuthority[0]);

    hr = pAdminD2->GetCAProperty(
        ppwszAuthority[0],
        CR_PROP_TEMPLATES,
        0,
        PROPTYPE_STRING,
        &ctbSD);
    _JumpIfErrorStr(hr, error, "ICertAdminD2::GetCAProperty CR_PROP_TEMPLATES",
        ppwszDNSName[0]);

    hr = list.Unmarshal(ctbSD.pb, ctbSD.cb);
    _JumpIfError(hr, error, "CTemplateList::Unmarshal");

error:
    if(ppwszDNSName)
        CAFreeCAProperty(hCAInfo, ppwszDNSName);
    
    if(ppwszAuthority)
        CAFreeCAProperty(hCAInfo, ppwszAuthority);

    if(pAdminD2)
        pAdminD2->Release();

    return hr;
}


HRESULT
RetrieveCATemplateListFromDS(
    IN HCAINFO hCAInfo,
    IN BOOL fTransientCertTypeHandle,	// don't hang onto hCertType
    OUT CTemplateList& list)
{
    HRESULT hr;
    HCERTTYPE hCertType = NULL;

    hr = CAEnumCertTypesForCA(
            hCAInfo,
            CT_ENUM_MACHINE_TYPES |
            CT_ENUM_USER_TYPES |
            CT_FLAG_NO_CACHE_LOOKUP,
            &hCertType);
    _JumpIfError(hr, error, "CAEnumCertTypesForCA");

    while (hCertType != NULL)
    {
	HCERTTYPE hCertTypeNext;

        hr = list.AddTemplateInfo(hCertType, fTransientCertTypeHandle);
        _JumpIfError(hr, error, "CTemplateList::AddTemplate");

        hr = CAEnumNextCertType(hCertType, &hCertTypeNext);
        _JumpIfError(hr, error, "CAEnumNextCertType");

	if (fTransientCertTypeHandle)
	{
	    CACloseCertType(hCertType);
	}
        hCertType = hCertTypeNext;
    }
    hr = S_OK;

error:
    if (NULL != hCertType)
    {
        CACloseCertType(hCertType);
    }
    return hr;
}


HRESULT
myRetrieveCATemplateList(
    IN HCAINFO hCAInfo,
    IN BOOL fTransientCertTypeHandle,	// don't hang onto hCertType
    OUT CTemplateList& list)
{
    HRESULT hr = S_OK;

    hr = RetrieveCATemplateListFromCA(hCAInfo, list);
    if(S_OK != hr)
    {
        // if failed to retrieve from the CA for any reason, try
        // fetching from DS

        hr = RetrieveCATemplateListFromDS(
				    hCAInfo,
				    fTransientCertTypeHandle,
				    list);
    }
    return hr;
}


HRESULT
myUpdateCATemplateListToDS(
    IN HCAINFO hCAInfo)
{
    HRESULT hr = S_OK;

    hr = CAUpdateCA(hCAInfo);
    _JumpIfError(hr, error, "CAUpdateCA");

error:
    return hr;
}


HRESULT
myUpdateCATemplateListToCA(
    IN HCAINFO hCAInfo,
    IN const CTemplateList& list)
{
    HRESULT hr = S_OK;
    LPWSTR *ppwszDNSName = NULL;
    LPWSTR *ppwszAuthority = NULL;
    ICertAdminD2 *pAdminD2 = NULL;
    DWORD dwServerVersion = 2;
    CERTTRANSBLOB ctbSD;

    ZeroMemory(&ctbSD, sizeof(CERTTRANSBLOB));

    hr = CAGetCAProperty(hCAInfo, CA_PROP_DNSNAME, &ppwszDNSName);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_DNSNAME");

    hr = CAGetCAProperty(hCAInfo, CA_PROP_NAME, &ppwszAuthority);
    _JumpIfError(hr, error, "CAGetCAProperty CA_PROP_NAME");

    ASSERT(ppwszDNSName[0]);

    hr = myOpenAdminDComConnection(
                    ppwszDNSName[0],
                    NULL,
                    NULL,
                    &dwServerVersion,
                    &pAdminD2);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    if (2 > dwServerVersion)
    {
        hr = RPC_E_VERSION_MISMATCH;
        _JumpError(hr, error, "old server");
    }

    CSASSERT(ppwszAuthority[0]);

    hr = list.Marshal(ctbSD.pb, ctbSD.cb);
    _JumpIfError(hr, error, "CTemplateList::Marshal");

    CSASSERT(S_OK==list.ValidateMarshalBuffer(ctbSD.pb, ctbSD.cb));

    hr = pAdminD2->SetCAProperty(
        ppwszAuthority[0],
        CR_PROP_TEMPLATES,
        0,
        PROPTYPE_STRING,
        &ctbSD);
    _JumpIfErrorStr(hr, error, "ICertAdminD2::SetCAProperty CR_PROP_TEMPLATES",
        ppwszDNSName[0]);

error:
    if(ppwszDNSName)
        CAFreeCAProperty(hCAInfo, ppwszDNSName);
    
    if(ppwszAuthority)
        CAFreeCAProperty(hCAInfo, ppwszAuthority);

    if(pAdminD2)
        pAdminD2->Release();

    if(ctbSD.pb)
        MIDL_user_free(ctbSD.pb);
    return hr;
}

       
HRESULT
myAddToCATemplateList(
    IN HCAINFO hCAInfo,
    IN OUT CTemplateList& list,
    IN HCERTTYPE hCertType,
    IN BOOL fTransientCertTypeHandle)	// don't hang onto hCertType
{
    HRESULT hr;

    hr = CAAddCACertificateType(hCAInfo, hCertType);
    _JumpIfError(hr, error, "CAAddCACertificateType");

    hr = list.AddTemplateInfo(hCertType, fTransientCertTypeHandle);
    _JumpIfError(hr, error, "CTemplateList::AddTemplateInfo HCERTTYPE");

error:
    return hr;
}


HRESULT
myRemoveFromCATemplateList(
    IN HCAINFO hCAInfo,
    IN OUT CTemplateList& list,
    IN HCERTTYPE hCertType)
{
    HRESULT hr = S_OK;

    hr = CARemoveCACertificateType(hCAInfo, hCertType);
    _JumpIfError(hr, error, "CARemoveCACertificateType");

    hr = list.RemoveTemplateInfo(hCertType);
    _JumpIfError(hr, error, "CTemplateList::RemoveTemplateInfo HCERTTYPE");

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\viewattr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewattr.cpp
//
//  Contents:   IEnumCERTVIEWATTRIBUTE IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_VIEWATTR_CPP__


//+------------------------------------------------------------------------
// IEnumCERTVIEWATTRIBUTE dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetName method:

static OLECHAR *_apszGetName[] = {
    TEXT("GetName"),
};

//+------------------------------------
// GetValue method:

static OLECHAR *_apszGetValue[] = {
    TEXT("GetValue"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewAttribute[] =
{
#define VIEWATTR_NEXT		0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWATTR_GETNAME	1
    DECLARE_DISPATCH_ENTRY(_apszGetName)

#define VIEWATTR_GETVALUE	2
    DECLARE_DISPATCH_ENTRY(_apszGetValue)

#define VIEWATTR_SKIP		3
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWATTR_RESET		4
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWATTR_CLONE		5
    DECLARE_DISPATCH_ENTRY(_apszClone)
};
#define CVIEWATTRDISPATCH	(ARRAYSIZE(g_adtViewAttribute))


HRESULT
ViewAttribute_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWATTRIBUTE *pEnumAttribute,
    OUT DISPATCHINTERFACE *pdiViewAttribute)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;
    static BOOL s_fInitialized = FALSE;

    pdiViewAttribute->pDispatchTable = NULL;
    pdiViewAttribute->pDispatch = NULL;
    pdiViewAttribute->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumAttribute->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWATTRDISPATCH,
			g_adtViewAttribute,
			pdiViewAttribute);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewAttribute->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumAttribute->AddRef();
	pdiViewAttribute->pUnknown = (IUnknown *) pEnumAttribute;
	hr = S_OK;
    }
    pdiViewAttribute->pDispatchTable = g_adtViewAttribute;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ViewAttribute_Release(
    IN OUT DISPATCHINTERFACE *pdiViewAttribute)
{
    DispatchRelease(pdiViewAttribute);
}


HRESULT
ViewAttribute_Next(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_GetName(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_GETNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->GetName(pstrOut);
	_JumpIfError(hr, error, "GetName");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_GetValue(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_GETVALUE,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetValue)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->GetValue(
								    pstrOut);
	_JumpIfError(hr, error, "GetValue");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_Skip(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_Reset(
    IN DISPATCHINTERFACE *pdiViewAttribute)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewAttribute_Clone(
    IN DISPATCHINTERFACE *pdiViewAttribute,
    OUT DISPATCHINTERFACE *pdiViewAttributeClone)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *pEnumAttribute = NULL;

    CSASSERT(NULL != pdiViewAttribute && NULL != pdiViewAttribute->pDispatchTable);

    if (NULL != pdiViewAttribute->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewAttribute,
			VIEWATTR_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumAttribute);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWATTRIBUTE *) pdiViewAttribute->pUnknown)->Clone(
							    &pEnumAttribute);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewAttribute_Init2(
		    NULL != pdiViewAttribute->pDispatch,
		    pEnumAttribute,
		    pdiViewAttributeClone);
    _JumpIfError(hr, error, "ViewAttribute_Init2");

error:
    if (NULL != pEnumAttribute)
    {
	pEnumAttribute->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\tfc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfc.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#include "tfc.h"

#include <stdarg.h>

#define __dwFILE__	__dwFILE_CERTLIB_TFC_CPP__


extern HINSTANCE g_hInstance;


BOOL AssertFailedLine(LPCSTR lpszFileName, int nLine)
{
    WCHAR szMessage[_MAX_PATH*2];
    
    // format message into buffer
    wsprintf(szMessage, L"File %hs, Line %d\n",
        lpszFileName, nLine);
    
    OutputDebugString(szMessage);
    int iCode = MessageBox(NULL, szMessage, L"Assertion Failed!",
        MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);
    
    if (iCode == IDIGNORE)
        return FALSE;
    
    if (iCode == IDRETRY)
        return TRUE;
    
    // abort!
    ExitProcess(0);
    // NOTREACHED return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CBitmap
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

CBitmap::CBitmap()
{
    m_hBmp = NULL; 
}

CBitmap::~CBitmap()
{
    if(m_hBmp) 
        DeleteObject(m_hBmp); 
    m_hBmp = NULL;
}

HBITMAP CBitmap::LoadBitmap(UINT iRsc)
{ 
    m_hBmp = (HBITMAP)LoadImage(g_hInstance, MAKEINTRESOURCE(iRsc), IMAGE_BITMAP, 0, 0, 0); 
    return m_hBmp; 
}


//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////
// CComboBox
//////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

void CComboBox::Init(HWND hWnd)
{
    m_hWnd = hWnd;
}

void CComboBox::ResetContent()         
{ 
    ASSERT(m_hWnd); 
    SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); 
}

int CComboBox::SetItemData(int idx, DWORD dwData) 
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_SETITEMDATA, (WPARAM)idx, (LPARAM)dwData); 
}

DWORD CComboBox::GetItemData(int idx) 
{ 
    ASSERT(m_hWnd); 
    return (DWORD)SendMessage(m_hWnd, CB_GETITEMDATA, (WPARAM)idx, 0);
}

int CComboBox::AddString(LPWSTR sz)    
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM) sz);
}

int CComboBox::AddString(LPCWSTR sz)  
{ 
    return (INT)AddString((LPWSTR)sz); 
}

int CComboBox::GetCurSel()           
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_GETCURSEL, 0, 0);
}

int CComboBox::SetCurSel(int iSel)    
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_SETCURSEL, (WPARAM)iSel, 0); 
}

int CComboBox::SelectString(int nAfter, LPCWSTR szItem)
{ 
    ASSERT(m_hWnd); 
    return (INT)SendMessage(m_hWnd, CB_SELECTSTRING, (WPARAM) nAfter, (LPARAM)szItem); 
}


int ListView_NewItem(HWND hList, int iIndex, LPCWSTR szText, LPARAM lParam /* = NULL*/, int iImage /*=-1*/)
{
	LVITEM sItem;
	ZeroMemory(&sItem, sizeof(sItem));
	sItem.iItem = iIndex;
    sItem.iImage = iImage;
	
	if (lParam)
	{
            sItem.mask = LVIF_PARAM;
            if(-1!=iImage)
                sItem.mask |= LVIF_IMAGE;
            sItem.lParam = lParam;
	}

	sItem.iItem = ListView_InsertItem(hList, &sItem);

	ListView_SetItemText(hList, sItem.iItem, 0, (LPWSTR)szText);

	return sItem.iItem;
}

int ListView_NewColumn(HWND hwndListView, int iCol, int cx, LPCWSTR szHeading /*=NULL*/, int fmt/*=0*/)
{
    LVCOLUMN lvCol;
    lvCol.mask = LVCF_WIDTH;
    lvCol.cx = cx;
    
    if (szHeading)
    {
        lvCol.mask |= LVCF_TEXT;
        lvCol.pszText = (LPWSTR)szHeading;
    }

    if (fmt)
    {
        lvCol.mask |= LVCF_FMT;
        lvCol.fmt = fmt;
    }

    return ListView_InsertColumn(hwndListView, iCol, &lvCol);
}

LPARAM ListView_GetItemData(HWND hListView, int iItem)
{
    LVITEM lvItem;
    lvItem.iItem = iItem;
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;
    ListView_GetItem(hListView, &lvItem);

    return lvItem.lParam;
}

int ListView_GetCurSel(HWND hwndList)
{
    int iTot = ListView_GetItemCount(hwndList);
    int i=0;

    while(i<iTot)
    {
        if (LVIS_SELECTED == ListView_GetItemState(hwndList, i, LVIS_SELECTED))
            break;

        i++;
    }

    return (i<iTot) ? i : -1;
}

void
ListView_SetItemFiletime(
    IN HWND hwndList,
    IN int  iItem,
    IN int  iColumn,
    IN FILETIME const *pft)
{
    HRESULT hr;
    WCHAR *pwszDateTime = NULL;

    // convert filetime to string
    hr = myGMTFileTimeToWszLocalTime(pft, FALSE, &pwszDateTime);
    if (S_OK != hr)
    {
        _PrintError(hr, "myGMTFileTimeToWszLocalTime");
    }
    else
    {
        ListView_SetItemText(hwndList, iItem, iColumn, pwszDateTime); 
    }

    if (NULL != pwszDateTime)
    {
        LocalFree(pwszDateTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\viewcol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewcol.cpp
//
//  Contents:   IEnumCERTVIEWCOLUMN IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_VIEWCOL_CPP__


//+------------------------------------------------------------------------
// IEnumCERTVIEWCOLUMN dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// GetName method:

static OLECHAR *_apszGetName[] = {
    TEXT("GetName"),
};

//+------------------------------------
// GetDisplayName method:

static OLECHAR *_apszGetDisplayName[] = {
    TEXT("GetDisplayName"),
};

//+------------------------------------
// GetType method:

static OLECHAR *_apszGetType[] = {
    TEXT("GetType"),
};

//+------------------------------------
// IsIndexed method:

static OLECHAR *_apszIsIndexed[] = {
    TEXT("IsIndexed"),
};

//+------------------------------------
// GetMaxLength method:

static OLECHAR *_apszGetMaxLength[] = {
    TEXT("GetMaxLength"),
};

//+------------------------------------
// GetValue method:

static OLECHAR *_apszGetValue[] = {
    TEXT("GetValue"),
    TEXT("Flags"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewColumn[] =
{
#define VIEWCOL_NEXT		0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWCOL_GETNAME		1
    DECLARE_DISPATCH_ENTRY(_apszGetName)

#define VIEWCOL_GETDISPLAYNAME	2
    DECLARE_DISPATCH_ENTRY(_apszGetDisplayName)

#define VIEWCOL_GETTYPE		3
    DECLARE_DISPATCH_ENTRY(_apszGetType)

#define VIEWCOL_ISINDEXED	4
    DECLARE_DISPATCH_ENTRY(_apszIsIndexed)

#define VIEWCOL_GETMAXLENGTH	5
    DECLARE_DISPATCH_ENTRY(_apszGetMaxLength)

#define VIEWCOL_GETVALUE	6
    DECLARE_DISPATCH_ENTRY(_apszGetValue)

#define VIEWCOL_SKIP		7
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWCOL_RESET		8
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWCOL_CLONE		9
    DECLARE_DISPATCH_ENTRY(_apszClone)
};
#define CVIEWCOLDISPATCH	(ARRAYSIZE(g_adtViewColumn))


HRESULT
ViewColumn_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWCOLUMN *pEnumColumn,
    OUT DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;
    static BOOL s_fInitialized = FALSE;

    pdiViewColumn->pDispatchTable = NULL;
    pdiViewColumn->pDispatch = NULL;
    pdiViewColumn->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumColumn->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWCOLDISPATCH,
			g_adtViewColumn,
			pdiViewColumn);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewColumn->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumColumn->AddRef();
	pdiViewColumn->pUnknown = (IUnknown *) pEnumColumn;
	hr = S_OK;
    }
    pdiViewColumn->pDispatchTable = g_adtViewColumn;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}


VOID
ViewColumn_Release(
    IN OUT DISPATCHINTERFACE *pdiViewColumn)
{
    DispatchRelease(pdiViewColumn);
}


HRESULT
ViewColumn_Next(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetName(pstrOut);
	_JumpIfError(hr, error, "GetName");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetDisplayName(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT BSTR *pstrOut)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETDISPLAYNAME,
			0,
			NULL,
			VT_BSTR,
			pstrOut);
	_JumpIfError(hr, error, "Invoke(GetDisplayName)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetDisplayName(pstrOut);
	_JumpIfError(hr, error, "GetDisplayName");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetType(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pType)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETTYPE,
			0,
			NULL,
			VT_I4,
			pType);
	_JumpIfError(hr, error, "Invoke(GetType)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetType(pType);
	_JumpIfError(hr, error, "GetType");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_IsIndexed(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pIndexed)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_ISINDEXED,
			0,
			NULL,
			VT_I4,
			pIndexed);
	_JumpIfError(hr, error, "Invoke(IsIndexed)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->IsIndexed(pIndexed);
	_JumpIfError(hr, error, "IsIndexed");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_GetMaxLength(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT LONG *pMaxLength)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETMAXLENGTH,
			0,
			NULL,
			VT_I4,
			pMaxLength);
	_JumpIfError(hr, error, "Invoke(GetMaxLength)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetMaxLength(
								pMaxLength);
	_JumpIfError(hr, error, "GetMaxLength");
    }

error:
    return(hr);
}

HRESULT
ViewColumn_GetValue(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG Flags,
    IN LONG ColumnType,
    OUT VOID *pColumnValue)
{
    HRESULT hr;
    LONG RetType;
    VARIANT varResult;

    VariantInit(&varResult);
    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    switch (ColumnType)
    {
	case PROPTYPE_BINARY:
	case PROPTYPE_STRING:
	    RetType = VT_BSTR;
	    break;

	case PROPTYPE_DATE:
	    RetType = VT_DATE;
	    break;

	case PROPTYPE_LONG:
	    RetType = VT_I4;
	    break;

	default:
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "PropertyType");
    }

    if (NULL != pdiViewColumn->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_GETVALUE,
			ARRAYSIZE(avar),
			avar,
			RetType,
			pColumnValue);
	_JumpIfError2(hr, error, "Invoke(GetValue)", CERTSRV_E_PROPERTY_EMPTY);
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->GetValue(
								Flags,
								&varResult);
	_JumpIfError(hr, error, "GetValue");

	hr = DispatchGetReturnValue(&varResult, RetType, pColumnValue);
	_JumpIfError2(hr, error, "DispatchGetReturnValue", CERTSRV_E_PROPERTY_EMPTY);
    }

error:
    VariantClear(&varResult);
    return(hr);
}


HRESULT
ViewColumn_Skip(
    IN DISPATCHINTERFACE *pdiViewColumn,
    IN LONG celt)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = celt;

	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_SKIP,
			ARRAYSIZE(avar),
			avar,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Skip)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Skip(celt);
	_JumpIfError(hr, error, "Skip");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_Reset(
    IN DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_RESET,
			0,
			NULL,
			0,
			NULL);
	_JumpIfError(hr, error, "Invoke(Reset)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Reset();
	_JumpIfError(hr, error, "Reset");
    }

error:
    return(hr);
}


HRESULT
ViewColumn_Clone(
    IN DISPATCHINTERFACE *pdiViewColumn,
    OUT DISPATCHINTERFACE *pdiViewColumnClone)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pEnumColumn = NULL;

    CSASSERT(NULL != pdiViewColumn && NULL != pdiViewColumn->pDispatchTable);

    if (NULL != pdiViewColumn->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewColumn,
			VIEWCOL_CLONE,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumColumn);
	_JumpIfError(hr, error, "Invoke(Clone)");
    }
    else
    {
	hr = ((IEnumCERTVIEWCOLUMN *) pdiViewColumn->pUnknown)->Clone(
								&pEnumColumn);
	_JumpIfError(hr, error, "Clone");
    }
    hr = ViewColumn_Init2(
		    NULL != pdiViewColumn->pDispatch,
		    pEnumColumn,
		    pdiViewColumnClone);
    _JumpIfError(hr, error, "ViewColumn_Init2");

error:
    if (NULL != pEnumColumn)
    {
	pEnumColumn->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\string.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        string.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define __dwFILE__	__dwFILE_CERTLIB_STRING_CPP__


extern HINSTANCE g_hInstance;

DWORD g_cStringAlloc;
DWORD g_cStringUsed;

typedef struct _RESOURCESTRING
{
    DWORD	 id;
    WCHAR const *pwsz;
} RESOURCESTRING;


#define CRS_CHUNK		100

RESOURCESTRING *g_rgrs = NULL;
DWORD g_crsMax = 0;
DWORD g_crs = 0;


RESOURCESTRING *
AllocStringHeader()
{
    if (g_crs >= g_crsMax)
    {
	DWORD cb = (CRS_CHUNK + g_crsMax) * sizeof(g_rgrs[0]);
	RESOURCESTRING *rgrsT;

	if (NULL == g_rgrs)
	{
	    rgrsT = (RESOURCESTRING *) LocalAlloc(LMEM_FIXED, cb);
	}
	else
	{
	    rgrsT = (RESOURCESTRING *) LocalReAlloc(g_rgrs, cb, LMEM_MOVEABLE);
	}
	if (NULL == rgrsT)
	{
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"Error allocating resource string header\n"));
	    return(NULL);
	}
	g_rgrs = rgrsT;
	g_crsMax += CRS_CHUNK;
    }
    return(&g_rgrs[g_crs++]);
}


#define cwcRESOURCEMIN	128
#define cwcRESOURCEMAX	8192

WCHAR *
myLoadResourceStringNoCache(
    IN HINSTANCE hInstance,
    IN DWORD ResourceId)
{
    HRESULT hr;
    WCHAR awc[cwcRESOURCEMIN];
    WCHAR *pwsz = NULL;
    DWORD cwc;
    WCHAR *pwszString = NULL;

    pwsz = awc;
    cwc = ARRAYSIZE(awc);

    for (;;)
    {
	if (!LoadString(hInstance, ResourceId, pwsz, cwc))
	{
	    hr = myHLastError();
	    if (S_OK == hr)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	    }
	    DBGPRINT((
		DBG_SS_CERTLIB,
		"LoadString(%d) -> %x\n",
		ResourceId,
		hr));
	    _JumpError(hr, error, "LoadString");
	}
#if 0
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "myLoadResourceString(%d) %x/%x\n",
	    ResourceId,
	    wcslen(pwsz),
	    cwc));
#endif

	// if there's any room left, the resource was not truncated.
	// if the buffer is already at the maximum size we support, we just
	// live with the truncation.

	if (wcslen(pwsz) < cwc - 1 || cwcRESOURCEMAX <= cwc)
	{
	    break;
	}

	// LoadString filled the buffer completely, so the string may have
	// been truncated.  Double the buffer size and try again.

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "myLoadResourceString(%d) %x/%x ==> %x\n",
	    ResourceId,
	    wcslen(pwsz),
	    cwc,
	    cwc << 1));
	if (awc != pwsz)
	{
	    LocalFree(pwsz);
	    pwsz = NULL;
	}
	cwc <<= 1;
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    hr = myDupString(pwsz, &pwszString);
    _JumpIfError(hr, error, "myDupString");

error:
    if (NULL != pwsz && awc != pwsz)
    {
	LocalFree(pwsz);
    }
    if (NULL == pwszString)
    {
	SetLastError(hr);
    }
    return(pwszString);
}


WCHAR const *
myLoadResourceString(
    IN DWORD ResourceId)
{
    DWORD i;
    WCHAR const *pwszString = NULL;
    WCHAR *pwszAlloc;

    for (i = 0; i < g_crs; i++)
    {
	if (g_rgrs[i].id == ResourceId)
	{
	    pwszString = g_rgrs[i].pwsz;
	    break;
	}
    }
    if (NULL == pwszString)
    {
	RESOURCESTRING *prs;

	pwszAlloc = myLoadResourceStringNoCache(g_hInstance, ResourceId);
	if (NULL == pwszAlloc)
	{
	    goto error;		// myLoadResourceStringNoCache sets LastError
	}
	prs = AllocStringHeader();
	if (NULL != prs)
	{
	    prs->id = ResourceId;
	    prs->pwsz = pwszAlloc;
	}
	pwszString = pwszAlloc;
	g_cStringAlloc++;
    }
    g_cStringUsed++;
    CSASSERT(NULL != pwszString);

error:
    return(pwszString);
}


VOID
myFreeResourceStrings(
    IN char const *DBGPARMREFERENCED(pszModule))
{
    DWORD i;

    if (0 != g_cStringAlloc || 0 != g_crs || 0 != g_cStringUsed)
    {
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%hs Strings: alloc = %d, saved = %d, used = %d\n",
	    pszModule,
	    g_cStringAlloc,
	    g_crs,
	    g_cStringUsed));
    }

    if (NULL != g_rgrs)
    {
	for (i = 0; i < g_crs; i++)
	{
	    LocalFree(const_cast<WCHAR *>(g_rgrs[i].pwsz));
	    g_rgrs[i].pwsz = NULL;
	    g_rgrs[i].id = 0;
	}
	LocalFree(g_rgrs);
	g_rgrs = NULL;
    }
    g_crsMax = 0;
    g_crs = 0;
    g_cStringAlloc = 0;
    g_cStringUsed = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\tfcprop.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       tfcprop.cpp
//
//--------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#include "tfcprop.h"

extern HINSTANCE g_hInstance;

PropertyPage::PropertyPage(UINT uIDD)
{
    m_hWnd = NULL;

    ZeroMemory(&m_psp, sizeof(PROPSHEETPAGE));
    m_psp.dwSize = sizeof(PROPSHEETPAGE);
    m_psp.dwFlags = PSP_DEFAULT;
    m_psp.hInstance = g_hInstance;
    m_psp.pszTemplate = MAKEINTRESOURCE(uIDD);

    m_psp.pfnDlgProc = dlgProcPropPage;
    m_psp.lParam = (LPARAM)this;
}

PropertyPage::~PropertyPage()
{
}

BOOL PropertyPage::OnCommand(WPARAM, LPARAM)
{
    return TRUE;
}

BOOL
PropertyPage::OnNotify(
    UINT, // idCtrl
    NMHDR * /* pnmh */ )
{
    return FALSE;
}

BOOL
PropertyPage::UpdateData(
    BOOL /* fSuckFromDlg = TRUE */ )
{
    return TRUE;
}

BOOL PropertyPage::OnSetActive()
{
    return TRUE;
}

BOOL PropertyPage::OnKillActive()
{
    return TRUE;
}

BOOL PropertyPage::OnInitDialog()
{
    UpdateData(FALSE);  // push to dlg
    return TRUE;
}

void PropertyPage::OnDestroy()
{
    return;
}


BOOL PropertyPage::OnApply()
{
    SetModified(FALSE);
    return TRUE;
}

void PropertyPage::OnCancel()
{
    return;
}

void PropertyPage::OnOK()
{
    return;
}

BOOL PropertyPage::OnWizardFinish()
{
    return TRUE;
}

LRESULT PropertyPage::OnWizardNext()
{
    return 0;
}

LRESULT PropertyPage::OnWizardBack()
{
    return 0;
}

void
PropertyPage::OnHelp(
    LPHELPINFO /* lpHelp */ )
{
    return;
}

void
PropertyPage::OnContextHelp(
    HWND /* hwnd */ )
{
    return;
}


INT_PTR CALLBACK
dlgProcPropPage(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    PropertyPage* pPage = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
    {
        // save off PropertyPage*
        ASSERT(lParam);
        pPage = (PropertyPage*) ((PROPSHEETPAGE*)lParam)->lParam;
        ASSERT(pPage);
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LPARAM)pPage);


        // pass notification through
        pPage->m_hWnd = hwndDlg;           // save our hwnd
        return pPage->OnInitDialog();      // call virtual fxn
    }
    case WM_DESTROY:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;
        pPage->OnDestroy();
        break;
    }
    case WM_NOTIFY:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;

        LRESULT lr;

        // catch special commands, drop other notifications
        switch( ((LPNMHDR)lParam) -> code)
        {
        case PSN_SETACTIVE:
            lr = (pPage->OnSetActive() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);       // bool
            break;
    	case PSN_KILLACTIVE:
            lr = (pPage->OnKillActive() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);      // bool
            break;
        case PSN_APPLY:
            pPage->UpdateData(TRUE);  // take from dlg
            lr = (pPage->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);           // bool
            break;
        case PSN_WIZFINISH:
            pPage->UpdateData(TRUE);  // take from dlg
            lr = (pPage->OnWizardFinish() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE);    // bool
            break;
        case PSN_WIZBACK:
            pPage->UpdateData(TRUE);  // take from dlg
            lr = pPage->OnWizardBack();
            break;
        case PSN_WIZNEXT:
        {
            pPage->UpdateData(TRUE);  // take from dlg
            lr = pPage->OnWizardNext();
            break;
        }
        default:
            return pPage->OnNotify((int)wParam, (NMHDR*)lParam);
        }

        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, lr);
        return TRUE;
    }
    case WM_COMMAND:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;

        // catch special commands, pass others through
        switch(LOWORD(wParam))
        {
        case IDOK:
            pPage->OnOK();
//            EndDialog(hwndDlg, 0);
            return 0;
        case IDCANCEL:
            pPage->OnCancel();
//            EndDialog(hwndDlg, 1);
            return 0;
        default:
            return pPage->OnCommand(wParam, lParam);
        }
    }
    case WM_HELP:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;
        pPage->OnHelp((LPHELPINFO) lParam);
        break;
    }
    case WM_CONTEXTMENU:
    {
        pPage = (PropertyPage*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pPage == NULL)
            break;
        pPage->OnContextHelp((HWND)wParam);
        break;
    }
    default:

        break;
    }

    return 0;
}


BOOL
EnumHideChildProc(
    HWND hwnd,
    LPARAM /* lParam */ )
{
    ShowWindow(hwnd, SW_HIDE);
    EnableWindow(hwnd, FALSE);
    return TRUE;
}


void PropertyPage::HideControls()
{
    EnumChildWindows(m_hWnd, EnumHideChildProc, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\browsedi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       browsedi.cpp
//
//--------------------------------------------------------------------------

//
// BrowseDir.cpp
//

#include "stdafx.h"
#include <shlobj.h>


int 
InitStartDir( 
    HWND hwnd, 
    UINT uMsg, 
    LPARAM, // lParam
    LPARAM lpData)
{
    // we just capture Init Message
    if (BFFM_INITIALIZED == uMsg)
    {
        // we expect lpData to be our start path
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
    }

    return 0;
}
 



BOOL
BrowseForDirectory(
    HWND hwndParent,
    LPCTSTR pszInitialDir,
    LPTSTR pszBuf,
    int cchBuf,
    LPCTSTR pszDialogTitle)
{
    LPITEMIDLIST pItem = NULL;
    TCHAR szPath[MAX_PATH+1];
    BOOL bGotLocation = FALSE;

    BROWSEINFO bi;
    ZeroMemory(&bi, sizeof(bi));
    bi.hwndOwner = hwndParent;

    // initial folder
    if (pszInitialDir != NULL)
    {
        bi.lpfn = InitStartDir;
        bi.lParam = (LPARAM)pszInitialDir;
    }

    bi.pszDisplayName = szPath;   
    bi.lpszTitle = pszDialogTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS;            // return only directories in the filesystem, not other folders


    pItem = SHBrowseForFolder(&bi);
    if (pItem == NULL)
        goto Ret;

    bGotLocation = SHGetPathFromIDList(pItem, szPath);
    if (!bGotLocation)
        goto Ret;
    
    ASSERT((_tcslen(szPath)+1)*sizeof(TCHAR) <= (UINT)cchBuf);
    if ((_tcslen(szPath)+1)*sizeof(TCHAR) > (UINT)cchBuf)
        return FALSE;

    _tcscpy(pszBuf, szPath);
   
Ret:
    LPMALLOC pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc))) 
    {
       if (pItem)
           pMalloc->Free(pItem);
       if (bi.pidlRoot)
           pMalloc->Free((ITEMIDLIST*)bi.pidlRoot);

       pMalloc->Release();
    }

    return bGotLocation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certmmc\about.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include <stdafx.h>

#define __dwFILE__	__dwFILE_CERTMMC_ABOUT_CPP__

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CSnapinAboutImpl::CSnapinAboutImpl()
{
}


CSnapinAboutImpl::~CSnapinAboutImpl()
{
}


HRESULT CSnapinAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR> 
                ( CoTaskMemAlloc( (s.GetLength()+1)*sizeof(WCHAR) ));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

    // this is freed by mmc, not our tracking
    myRegisterMemFree(*lpPtr, CSM_COTASKALLOC);

	USES_CONVERSION;
    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}

HRESULT CSnapinAboutImpl::AboutHelper2(LPSTR str, LPOLESTR* lpPtr)
{
    HRESULT hr;
    LPWSTR pwszTmp = NULL;

    if (!myConvertSzToWsz(&pwszTmp, str, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "myConvertSzToWsz");
    }

    *lpPtr = reinterpret_cast<LPOLESTR>
        (CoTaskMemAlloc((wcslen(pwszTmp)+1)*sizeof(wchar_t)));
    if (NULL == *lpPtr)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "CoTaskMemAlloc");
    }

    // this is freed by mmc, not our tracking
    myRegisterMemFree(*lpPtr, CSM_COTASKALLOC);

    wcscpy(*lpPtr, pwszTmp);
    hr = S_OK;

error:
    if (NULL != pwszTmp)
    {
	LocalFree(pwszTmp);
    }
    return(hr);
}

STDMETHODIMP CSnapinAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_DESCRIPTION, lpDescription);
}


STDMETHODIMP CSnapinAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper2(VER_PRODUCTVERSION_STR, lpVersion);
}


STDMETHODIMP CSnapinAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // in MMC 1.1, this will be used as root node icon!!
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CSnapinAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(cLargeMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COMPUTER_SMALL));
	*hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COMPUTER_SMALL));
	*hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_COMPUTER_LARGE));

	*cLargeMask = RGB(255, 0, 255);

	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
		OutputDebugString(L"WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
		}
	#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certlib\viewrow.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       viewrow.cpp
//
//  Contents:   IEnumCERTVIEWROW IDispatch helper functions
//
//--------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include <stdlib.h>
#include "csdisp.h"
#include "csprop.h"

#define __dwFILE__	__dwFILE_CERTLIB_VIEWROW_CPP__


//+------------------------------------------------------------------------
// IEnumCERTVIEWROW dispatch support

//+------------------------------------
// OpenConnection method:

static OLECHAR *_apszNext[] = {
    TEXT("Next"),
};

//+------------------------------------
// EnumCertViewColumn method:

static OLECHAR *_apszEnumCertViewColumn[] = {
    TEXT("EnumCertViewColumn"),
};

//+------------------------------------
// EnumCertViewAttribute method:

static OLECHAR *_apszEnumCertViewAttribute[] = {
    TEXT("EnumCertViewAttribute"),
    TEXT("Flags"),
};

//+------------------------------------
// EnumCertViewExtension method:

static OLECHAR *_apszEnumCertViewExtension[] = {
    TEXT("EnumCertViewExtension"),
    TEXT("Flags"),
};

//+------------------------------------
// Skip method:

static OLECHAR *_apszSkip[] = {
    TEXT("Skip"),
    TEXT("celt"),
};

//+------------------------------------
// Reset method:

static OLECHAR *_apszReset[] = {
    TEXT("Reset"),
};

//+------------------------------------
// Clone method:

static OLECHAR *_apszClone[] = {
    TEXT("Clone"),
};

//+------------------------------------
// GetMaxIndex method:

static OLECHAR *_apszGetMaxIndex[] = {
    TEXT("GetMaxIndex"),
};


//+------------------------------------
// Dispatch Table:

DISPATCHTABLE g_adtViewRow[] =
{
#define VIEWROW_NEXT			0
    DECLARE_DISPATCH_ENTRY(_apszNext)

#define VIEWROW_ENUMCERTVIEWCOLUMN	1
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewColumn)

#define VIEWROW_ENUMCERTVIEWATTRIBUTE	2
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewAttribute)

#define VIEWROW_ENUMCERTVIEWEXTENSION	3
    DECLARE_DISPATCH_ENTRY(_apszEnumCertViewExtension)

#define VIEWROW_SKIP			4
    DECLARE_DISPATCH_ENTRY(_apszSkip)

#define VIEWROW_RESET			5
    DECLARE_DISPATCH_ENTRY(_apszReset)

#define VIEWROW_CLONE			6
    DECLARE_DISPATCH_ENTRY(_apszClone)

#define VIEWROW_GETMAXINDEX		7
    DECLARE_DISPATCH_ENTRY(_apszGetMaxIndex)
};
#define CVIEWROWDISPATCH	(ARRAYSIZE(g_adtViewRow))


HRESULT
ViewRow_Init2(
    IN BOOL fIDispatch,
    IN IEnumCERTVIEWROW *pEnumRow,
    OUT DISPATCHINTERFACE *pdiViewRow)
{
    HRESULT hr;
    IDispatch *pDispatch = NULL;

    pdiViewRow->pDispatchTable = NULL;
    pdiViewRow->pDispatch = NULL;
    pdiViewRow->pUnknown = NULL;
    if (fIDispatch)
    {
	hr = pEnumRow->QueryInterface(
				    IID_IDispatch,
				    (VOID **) &pDispatch);
	_JumpIfError(hr, error, "QueryInterface");

	hr = DispatchGetIds(
			pDispatch,
			CVIEWROWDISPATCH,
			g_adtViewRow,
			pdiViewRow);
	_JumpIfError(hr, error, "DispatchGetIds");

	pdiViewRow->pDispatch = pDispatch;
	pDispatch = NULL;
    }
    else
    {
	pEnumRow->AddRef();
	pdiViewRow->pUnknown = (IUnknown *) pEnumRow;
	hr = S_OK;
    }
    pdiViewRow->pDispatchTable = g_adtViewRow;

error:
    if (NULL != pDispatch)
    {
	pDispatch->Release();
    }
    return(hr);
}



VOID
ViewRow_Release(
    IN OUT DISPATCHINTERFACE *pdiViewRow)
{
    DispatchRelease(pdiViewRow);
}


HRESULT
ViewRow_Next(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT LONG *pIndex)
{
    HRESULT hr;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_NEXT,
			0,
			NULL,
			VT_I4,
			pIndex);
	_JumpIfError2(hr, error, "Invoke(Next)", S_FALSE);
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->Next(pIndex);
	_JumpIfError2(hr, error, "Next", S_FALSE);
    }

error:
    return(hr);
}


HRESULT
ViewRow_EnumCertViewColumn(
    IN DISPATCHINTERFACE *pdiViewRow,
    OUT DISPATCHINTERFACE *pdiViewColumn)
{
    HRESULT hr;
    IEnumCERTVIEWCOLUMN *pEnumColumn = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_ENUMCERTVIEWCOLUMN,
			0,
			NULL,
			VT_DISPATCH,
			&pEnumColumn);
	_JumpIfError(hr, error, "Invoke(EnumCertViewColumn)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->EnumCertViewColumn(
								&pEnumColumn);
	_JumpIfError(hr, error, "EnumCertViewColumn");
    }
    hr = ViewColumn_Init2(
		    NULL != pdiViewRow->pDispatch, 
		    pEnumColumn,
		    pdiViewColumn);
    _JumpIfError(hr, error, "ViewColumn_Init2");

error:
    if (NULL != pEnumColumn)
    {
	pEnumColumn->Release();
    }
    return(hr);
}


HRESULT
ViewRow_EnumCertViewAttribute(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    OUT DISPATCHINTERFACE *pdiViewAttribute)
{
    HRESULT hr;
    IEnumCERTVIEWATTRIBUTE *pEnumAttribute = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_ENUMCERTVIEWATTRIBUTE,
			ARRAYSIZE(avar),
			avar,
			VT_DISPATCH,
			&pEnumAttribute);
	_JumpIfError(hr, error, "Invoke(EnumCertViewAttribute)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->EnumCertViewAttribute(
							    Flags,
							    &pEnumAttribute);
	_JumpIfError(hr, error, "EnumCertViewAttribute");
    }
    hr = ViewAttribute_Init2(
		    NULL != pdiViewRow->pDispatch, 
		    pEnumAttribute,
		    pdiViewAttribute);
    _JumpIfError(hr, error, "ViewAttribute_Init2");

error:
    if (NULL != pEnumAttribute)
    {
	pEnumAttribute->Release();
    }
    return(hr);
}


HRESULT
ViewRow_EnumCertViewExtension(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG Flags,
    OUT DISPATCHINTERFACE *pdiViewExtension)
{
    HRESULT hr;
    IEnumCERTVIEWEXTENSION *pEnumExtension = NULL;

    CSASSERT(NULL != pdiViewRow && NULL != pdiViewRow->pDispatchTable);

    if (NULL != pdiViewRow->pDispatch)
    {
	VARIANT avar[1];

	avar[0].vt = VT_I4;
	avar[0].lVal = Flags;

	hr = DispatchInvoke(
			pdiViewRow,
			VIEWROW_ENUMCERTVIEWEXTENSION,
			ARRAYSIZE(avar),
			avar,
			VT_DISPATCH,
			&pEnumExtension);
	_JumpIfError(hr, error, "Invoke(EnumCertViewExtension)");
    }
    else
    {
	hr = ((IEnumCERTVIEWROW *) pdiViewRow->pUnknown)->EnumCertViewExtension(
							    Flags,
							    &pEnumExtension);
	_JumpIfError(hr, error, "EnumCertViewExtension");
    }
    hr = ViewExtension_Init2(
		    NULL != pdiViewRow->pDispatch, 
		    pEnumExtension,
		    pdiViewExtension);
    _JumpIfError(hr, error, "ViewExtension_Init2");

error:
    if (NULL != pEnumExtension)
    {
	pEnumExtension->Release();
    }
    return(hr);
}


HRESULT
ViewRow_Skip(
    IN DISPATCHINTERFACE *pdiViewRow,
    IN LONG celt)
{
    HRESULT h