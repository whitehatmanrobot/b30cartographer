eader_getGLlongv_text(
    __GLSreader *inoutReader, GLuint inCount, GLlong *outVec
);

extern GLboolean __glsReader_getGLshort_text(
    __GLSreader *inoutReader, GLshort *outVal
);

extern GLboolean __glsReader_getGLshortv_text(
    __GLSreader *inoutReader, GLuint inCount, GLshort *outVec
);

extern GLboolean __glsReader_getGLstencilOp_text(
    __GLSreader *inoutReader, GLenum *outVal
);

extern GLboolean __glsReader_getGLtextureComponentCount_text(
    __GLSreader *inoutReader, GLint *outVal
);

extern GLboolean __glsReader_getGLubyte_text(
    __GLSreader *inoutReader, GLubyte *outVal
);

extern GLboolean __glsReader_getGLubytev_text(
    __GLSreader *inoutReader, GLuint inCount, GLubyte *outVec
);

extern GLboolean __glsReader_getGLuint_text(
    __GLSreader *inoutReader, GLuint *outVal
);

extern GLboolean __glsReader_getGLuintv_text(
    __GLSreader *inoutReader, GLuint inCount, GLuint *outVec
);

extern GLboolean __glsReader_getGLulong_text(
    __GLSreader *inoutReader, GLulong *outVal
);

extern GLboolean __glsReader_getGLulongv_text(
    __GLSreader *inoutReader, GLuint inCount, GLulong *outVec
);

extern GLboolean __glsReader_getGLushort_text(
    __GLSreader *inoutReader, GLushort *outVal
);

extern GLboolean __glsReader_getGLushortv_text(
    __GLSreader *inoutReader, GLuint inCount, GLushort *outVec
);

extern GLboolean __glsReader_nextList_text(__GLSreader *inoutReader);

extern GLSenum __glsReader_readBeginGLS_text(
    __GLSreader *inoutReader, __GLSversion *outVersion
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\cap.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

void __gls_capture_glMap1d(
    GLenum target,
    GLdouble u1,
    GLdouble u2,
    GLint stride,
    GLint order,
    const GLdouble *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap1d);
    captureFlags = ctx->captureFlags[GLS_OP_glMap1d];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap1d);
        glMap1d(target, u1, u2, stride, order, points);
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap1d);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (stride >= k) {
        pad = stride - k;
        stride = k;
    } else {
        k = pad = 0;
    }
    if (!writer->padWordCount(writer, 0)) goto end;
    if (
        !writer->beginCommand(
            writer, GLS_OP_glMap1d, 28 + __GLS_MAX(k * order * 8, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
    } else {
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
    }
    if (pad) {
        writer->putGLdoublevs(
            writer, GL_FALSE, k, pad * 8, order, 0, 1, points
        );
    } else {
        writer->putGLdoublev(writer, k * order, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap1d);
    --ctx->captureEntryCount;
}

void __gls_capture_glMap1f(
    GLenum target,
    GLfloat u1,
    GLfloat u2,
    GLint stride,
    GLint order,
    const GLfloat *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap1f);
    captureFlags = ctx->captureFlags[GLS_OP_glMap1f];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap1f);
        glMap1f(target, u1, u2, stride, order, points);
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap1f);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (stride >= k) {
        pad = stride - k;
        stride = k;
    } else {
        k = pad = 0;
    }
    if (
        !writer->beginCommand(
            writer, GLS_OP_glMap1f, 20 + __GLS_MAX(k * order * 4, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
    } else {
        writer->putGLint(writer, stride);
        writer->putGLint(writer, order);
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
    }
    if (pad) {
        writer->putGLfloatvs(
            writer, GL_FALSE, k, pad * 4, order, 0, 1, points
        );
    } else {
        writer->putGLfloatv(writer, k * order, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap1f);
    --ctx->captureEntryCount;
}

void __gls_capture_glMap2d( \
    GLenum target,
    GLdouble u1,
    GLdouble u2,
    GLint ustride,
    GLint uorder,
    GLdouble v1,
    GLdouble v2,
    GLint vstride,
    GLint vorder,
    const GLdouble *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad0, pad1;
    GLint *const order0 = (ustride >= vstride) ? &vorder : &uorder;
    GLint *const order1 = (ustride >= vstride) ? &uorder : &vorder;
    GLint *const stride0 = (ustride >= vstride) ? &vstride : &ustride;
    GLint *const stride1 = (ustride >= vstride) ? &ustride : &vstride;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap2d);
    captureFlags = ctx->captureFlags[GLS_OP_glMap2d];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap2d);
        glMap2d(
            target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
        );
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap2d);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (*stride0 >= k) {
        pad0 = *stride0 - k;
        pad1 = *stride1 - *order0 * k;
        *stride0 = k;
        *stride1 = *order0 * k;
    } else {
        k = pad0 = pad1 = 0;
    }
    if (!writer->padWordCount(writer, 0)) goto end;
    if (
        !writer->beginCommand(
            writer,
            GLS_OP_glMap2d,
            52 + __GLS_MAX(k * vorder * uorder * 8, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
    } else {
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
    }
    if (pad1 || pad0) {
        writer->putGLdoublevs(
            writer, GL_FALSE, k, pad0 * 8, *order0, pad1 * 8, *order1, points
        );
    } else {
        writer->putGLdoublev(writer, k * vorder * uorder, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap2d);
    --ctx->captureEntryCount;
}

void __gls_capture_glMap2f( \
    GLenum target,
    GLfloat u1,
    GLfloat u2,
    GLint ustride,
    GLint uorder,
    GLfloat v1,
    GLfloat v2,
    GLint vstride,
    GLint vorder,
    const GLfloat *points
) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    extern GLint __glsEvalComputeK(GLenum inTarget);
    GLint k, pad0, pad1;
    GLint *const order0 = (ustride >= vstride) ? &vorder : &uorder;
    GLint *const order1 = (ustride >= vstride) ? &uorder : &vorder;
    GLint *const stride0 = (ustride >= vstride) ? &vstride : &ustride;
    GLint *const stride1 = (ustride >= vstride) ? &ustride : &vstride;

    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(GLS_OP_glMap2f);
    captureFlags = ctx->captureFlags[GLS_OP_glMap2f];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glMap2f);
        glMap2f(
            target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
        );
        __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glMap2f);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    k = __glsEvalComputeK(target);
    if (*stride0 >= k) {
        pad0 = *stride0 - k;
        pad1 = *stride1 - *order0 * k;
        *stride0 = k;
        *stride1 = *order0 * k;
    } else {
        k = pad0 = pad1 = 0;
    }
    if (
        !writer->beginCommand(
            writer,
            GLS_OP_glMap2f,
            36 + __GLS_MAX(k * vorder * uorder * 4, 0)
        )
    ) {
        goto end;
    }
    writer->putGLenum(writer, target);
    if (writer->type == GLS_TEXT) {
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLfloat(writer, v1);
        writer->putGLfloat(writer, v2);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
    } else {
        writer->putGLint(writer, ustride);
        writer->putGLint(writer, uorder);
        writer->putGLint(writer, vstride);
        writer->putGLint(writer, vorder);
        writer->putGLfloat(writer, u1);
        writer->putGLfloat(writer, u2);
        writer->putGLfloat(writer, v1);
        writer->putGLfloat(writer, v2);
    }
    if (pad0 || pad1) {
        writer->putGLfloatvs(
            writer, GL_FALSE, k, pad0 * 4, *order0, pad1 * 4, *order1, points
        );
    } else {
        writer->putGLfloatv(writer, k * vorder * uorder, points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(GLS_OP_glMap2f);
    --ctx->captureEntryCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\dec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

// DrewB - All functions changed to use passed in context

void __gls_decode_bin_glsBeginPoints(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_POINTS
    );
}

void __gls_decode_bin_glsBeginLines(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_LINES
    );
}

void __gls_decode_bin_glsBeginLineLoop(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_LINE_LOOP
    );
}

void __gls_decode_bin_glsBeginLineStrip(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_LINE_STRIP
    );
}

void __gls_decode_bin_glsBeginTriangles(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_TRIANGLES
    );
}

void __gls_decode_bin_glsBeginTriangleStrip(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_TRIANGLE_STRIP
    );
}

void __gls_decode_bin_glsBeginTriangleFan(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_TRIANGLE_FAN
    );
}

void __gls_decode_bin_glsBeginQuads(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_QUADS
    );
}

void __gls_decode_bin_glsBeginQuadStrip(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_QUAD_STRIP
    );
}

void __gls_decode_bin_glsBeginPolygon(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glBegin])(
        GL_POLYGON
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\ctx.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

/******************************************************************************
__GLScontext
******************************************************************************/

static GLvoid* __glsGLRCbuf_alloc(__GLSglrcBuf *inoutBuf, size_t inByteCount) {
    GLvoid *base;

    if (inoutBuf->base && inoutBuf->byteCount >= inByteCount) {
        return inoutBuf->base;
    }
    if (base = __glsMalloc(inByteCount)) {
        free(inoutBuf->base);
        inoutBuf->base = base;
        inoutBuf->byteCount = inByteCount;
    }
    return base;
}

GLvoid* __glsContext_allocFeedbackBuf(
    __GLScontext *inoutContext, size_t inByteCount
) {
    return __glsGLRCbuf_alloc(
        &inoutContext->header.glrcs[inoutContext->currentGLRC].feedbackBuf,
        inByteCount
    );
}

GLvoid* __glsContext_allocSelectBuf(
    __GLScontext *inoutContext, size_t inByteCount
) {
    return __glsGLRCbuf_alloc(
        &inoutContext->header.glrcs[inoutContext->currentGLRC].selectBuf,
        inByteCount
    );
}

#if __GL_EXT_vertex_array
GLvoid* __glsContext_allocVertexArrayBuf(
    __GLScontext *inoutContext, GLSopcode inOpcode, size_t inByteCount
) {
    __GLSglrcBuf *buf;
    __GLSglrc *const glrc = (
        inoutContext->header.glrcs + inoutContext->currentGLRC
    );

    switch (inOpcode) {
        case GLS_OP_glColorPointerEXT:
            buf = &glrc->colorBuf;
            break;
        case GLS_OP_glEdgeFlagPointerEXT:
            buf = &glrc->edgeFlagBuf;
            break;
        case GLS_OP_glIndexPointerEXT:
            buf = &glrc->indexBuf;
            break;
        case GLS_OP_glNormalPointerEXT:
            buf = &glrc->normalBuf;
            break;
        case GLS_OP_glTexCoordPointerEXT:
            buf = &glrc->texCoordBuf;
            break;
        case GLS_OP_glVertexPointerEXT:
            buf = &glrc->vertexBuf;
            break;
        default:
            return GLS_NONE;
    }
    return __glsGLRCbuf_alloc(buf, inByteCount);
}
#endif /* __GL_EXT_vertex_array */

__GLScontext* __glsContext_create(GLuint inName) {
    const GLubyte *listSep;
    GLSopcode op;
    __GLScontext *const outContext = __glsCalloc(1, sizeof(__GLScontext));
    GLubyte *prefixPtr;
    __GLSlistString *readPrefix;

    if (!outContext) return GLS_NONE;
    outContext->blockType = GLS_FRAME;
    for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
        outContext->captureFlags[op] = GLS_CAPTURE_WRITE_BIT;
    }
    outContext->captureFlags[GLS_OP_glsBeginGLS] = GLS_NONE;
    outContext->captureFlags[GLS_OP_glsEndGLS] = GLS_NONE;
    outContext->captureFlags[GLS_OP_glsPad] = GLS_NONE;
    __glsString_init(&outContext->returnString);
    __glsString_init(&outContext->savedLocale);
    if (!__glsHeader_init(&outContext->header)) {
        return __glsContext_destroy(outContext);
    }
    outContext->contextStreamDict = __glsStrDict_create(1, GL_FALSE);
    if (!outContext->contextStreamDict) {
        return __glsContext_destroy(outContext);
    }
    outContext->currentGLRC = 1;
    outContext->defaultReadChannel = stdin;
    outContext->defaultWriteChannel = stdout;
    listSep = glsCSTR(getenv("GLS_LIST_SEPARATOR"));
    outContext->name = inName;
    outContext->pixelSetupGen = GL_TRUE;
#if __GLS_PLATFORM_WIN32
    // DrewB
    outContext->captureExecOverride = GL_FALSE;
#endif
    if (!listSep) listSep = glsCSTR(":");
    if (prefixPtr = glsSTR(getenv("GLS_READ_PREFIX_LIST"))) {
        __GLSstring prefixString;

        __glsString_init(&prefixString);
        if (!__glsString_append(&prefixString, prefixPtr)) {
            __glsString_final(&prefixString);
            return __glsContext_destroy(outContext);
        }
        prefixPtr = prefixString.head;
        while (
            prefixPtr = glsSTR(
                strtok((char *)prefixPtr, (const char *)listSep)
            )
        ) {
            readPrefix = __glsListString_create(prefixPtr);
            if (!readPrefix) {
                __glsString_final(&prefixString);
                return __glsContext_destroy(outContext);
            }
            __GLS_ITERLIST_APPEND(&outContext->readPrefixList, readPrefix);
            prefixPtr = GLS_NONE;
        }
        __glsString_final(&prefixString);
    }
    readPrefix = __glsListString_create(glsCSTR(""));
    if (!readPrefix) return __glsContext_destroy(outContext);
    __GLS_ITERLIST_APPEND(&outContext->readPrefixList, readPrefix);
    outContext->writePrefix = __glsListString_create(
        glsCSTR(getenv("GLS_WRITE_PREFIX"))
    );
    if (!outContext->writePrefix) return __glsContext_destroy(outContext);
    __glsContext_updateDispatchTables(outContext);
    return outContext;
}

__GLScontext* __glsContext_destroy(__GLScontext *inContext) {
    GLint i;

    if (!inContext) return GLS_NONE;
    __glsStrDict_destroy(inContext->contextStreamDict);
    __GLS_ITERLIST_CLEAR_DESTROY(
        &inContext->contextStreamList, __glsContextStream_destroy
    );
    __glsHeader_final(&inContext->header);
    __GLS_ITERLIST_CLEAR_DESTROY(
        &inContext->readPrefixList, __glsListString_destroy
    );
    __glsString_final(&inContext->returnString);
    __glsString_final(&inContext->savedLocale);
    for (i = 0 ; i < inContext->captureNesting ; ++i) {
        __glsWriter_destroy(inContext->writers[i]);
    }
    __glsListString_destroy(inContext->writePrefix);
    free(inContext);
    return GLS_NONE;
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsNullDecodeBinFunc(GLubyte *inoutPtr) {
}
#else
static void __glsNullDecodeBinFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
}
#endif

void __glsContext_updateDispatchDecode_bin(__GLScontext *inoutContext) {
    GLSopcode op;

    if (inoutContext->abortMode) {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            inoutContext->dispatchDecode_bin[op] = __glsNullDecodeBinFunc;
        }
    } else {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            __GLSdecodeBinFunc decode = __glsDispatchDecode_bin_default[op];

            if (decode) {
                inoutContext->dispatchDecode_bin[op] = decode;
            } else {
                inoutContext->dispatchDecode_bin[op] = (
                    (__GLSdecodeBinFunc)inoutContext->dispatchCall[op]
                );
            }
        }
    }
}

void __glsContext_updateDispatchTables(__GLScontext *inoutContext) {
    GLSopcode op;

    if (inoutContext->captureNesting) {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            inoutContext->dispatchAPI[op] = (GLSfunc)__glsDispatchCapture[op];
        }
    } else {
        for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
            inoutContext->dispatchAPI[op] = __glsDispatchExec[op];
        }
    }
    for (op = 0 ; op < __GLS_OPCODE_COUNT ; ++op) {
        const GLSfunc commandFunc = inoutContext->commandFuncs[op];

        if (commandFunc) {
            inoutContext->dispatchCall[op] = commandFunc;
        } else {
            inoutContext->dispatchCall[op] = inoutContext->dispatchAPI[op];
        }
    }
    __glsContext_updateDispatchDecode_bin(inoutContext);
    __glsUpdateDispatchTables();
}

/******************************************************************************
__GLScontextStream
******************************************************************************/

__GLScontextStream* __glsContextStream_create(const GLubyte *inName) {
    __GLScontextStream *const outStream = __glsCalloc(
        1, sizeof(__GLScontextStream)
    );
    __GLScontextStreamBlock *block;

    if (!outStream) return GLS_NONE;
    __glsString_init(&outStream->name);
    if (!__glsString_append(&outStream->name, inName)) {
        return __glsContextStream_destroy(outStream);
    }
    block = __glsContextStream_appendBlock(outStream, __GLS_JUMP_ALLOC);
    if (!block) return __glsContextStream_destroy(outStream);
    __glsContextStreamBlock_addJump(block, GLS_NONE);
    return outStream;
}

__GLScontextStream* __glsContextStream_destroy(__GLScontextStream *inStream) {
    if (!inStream) return GLS_NONE;

    __glsString_final(&inStream->name);
    __GLS_LIST_CLEAR_DESTROY(
        &inStream->blockList, __glsContextStreamBlock_destroy
    );
    free(inStream);
    return GLS_NONE;
}

__GLScontextStreamBlock* __glsContextStream_appendBlock(
    __GLScontextStream *inoutStream, size_t inBufSize
) {
    __GLScontextStreamBlock *const outBlock = (
        __glsContextStreamBlock_create(inBufSize)
    );

    __GLS_LIST_APPEND(&inoutStream->blockList, outBlock);
    return outBlock;
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
#define __GLS_CONTEXT_STREAM_CALL_STEP \
    if (word = *(GLuint *)pc) { \
        dispatchDecode[__GLS_OP_SMALL(word)](pc + 4); \
        pc += __GLS_COUNT_SMALL(word) << 2; \
    } else if (word = __GLS_HEAD_LARGE(pc)->opLarge) { \
        dispatchDecode[word](pc + 12); \
        pc += __GLS_HEAD_LARGE(pc)->countLarge << 2; \
    } else { \
        pc = __GLS_COMMAND_JUMP(pc)->dest; \
        if (!pc || __GLS_CONTEXT->abortMode) break; \
    }
#else
#define __GLS_CONTEXT_STREAM_CALL_STEP \
    if (word = *(GLuint *)pc) { \
        dispatchDecode[__GLS_OP_SMALL(word)](ctx, pc + 4); \
        pc += __GLS_COUNT_SMALL(word) << 2; \
    } else if (word = __GLS_HEAD_LARGE(pc)->opLarge) { \
        dispatchDecode[word](ctx, pc + 12); \
        pc += __GLS_HEAD_LARGE(pc)->countLarge << 2; \
    } else { \
        pc = __GLS_COMMAND_JUMP(pc)->dest; \
        if (!pc || __GLS_CONTEXT->abortMode) break; \
    }
#endif

void __glsContextStream_call(__GLScontextStream *inoutStream) {
    GLboolean callSave;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSdecodeBinFunc *const dispatchDecode = ctx->dispatchDecode_bin;
    GLubyte *pc = inoutStream->blockList.head->buf;
    GLuint word;

    ++inoutStream->callCount;
    callSave = ctx->contextCall;
    ctx->contextCall = GL_TRUE;
    for (;;) {
        __GLS_CONTEXT_STREAM_CALL_STEP
        __GLS_CONTEXT_STREAM_CALL_STEP
        __GLS_CONTEXT_STREAM_CALL_STEP
        __GLS_CONTEXT_STREAM_CALL_STEP
    }
    ctx->contextCall = callSave;
    if (!--inoutStream->callCount && inoutStream->deleted) {
        __glsContextStream_destroy(inoutStream);
    }
}

__GLScontextStreamBlock* __glsContextStream_firstBlock(
    __GLScontextStream *inoutStream
) {
    return inoutStream->blockList.head;
}

size_t __glsContextStream_getByteCount(__GLScontextStream *inoutStream) {
    __GLScontextStreamBlockIter iter;
    size_t outVal = 0;

    __GLS_LIST_FIRST(&inoutStream->blockList, &iter);
    while (iter.elem) {
        outVal += (size_t)(iter.elem->writeTail - iter.elem->buf);
        if (__glsContextStreamBlock_hasJump(iter.elem)) {
            outVal -= sizeof(__GLSbinCommand_jump);
        }
        __GLS_LIST_NEXT(&inoutStream->blockList, &iter);
    }
    return outVal;
}

GLuint __glsContextStream_getCRC32(__GLScontextStream *inoutStream) {
    __GLScontextStreamBlockIter iter;
    GLuint outVal = 0xffffffff;
    GLubyte *ptr, *tail;

    __GLS_LIST_FIRST(&inoutStream->blockList, &iter);
    while (iter.elem) {
        ptr = iter.elem->buf;
        tail = iter.elem->writeTail;
        if (__glsContextStreamBlock_hasJump(iter.elem)) {
            tail -= sizeof(__GLSbinCommand_jump);
        }
        while (ptr < tail) __GLS_CRC32_STEP(outVal, *ptr++);
        __GLS_LIST_NEXT(&inoutStream->blockList, &iter);
    }
    return ~outVal;
}

__GLScontextStreamBlock* __glsContextStream_lastBlock(
    __GLScontextStream *inoutStream
) {
    __GLScontextStreamBlockIter iter;
    __GLS_LIST_LAST(&inoutStream->blockList, &iter);
    return iter.elem;
}

void __glsContextStream_truncate(
    __GLScontextStream *inoutStream,
    __GLScontextStreamBlock *inBlock,
    size_t inOffset
) {
    __GLScontextStreamBlockIter iter;

    inBlock->writeTail = inBlock->buf + inOffset;
    __glsContextStreamBlock_addJump(inBlock, GLS_NONE);
    if (inBlock->writeTail < inBlock->bufTail) {
        const size_t fillBytes = (size_t)(inBlock->writeTail - inBlock->buf);
        GLubyte *const buf = __glsMalloc(fillBytes);

        if (buf) {
            size_t i;

            for (i = 0 ; i < fillBytes ; ++i) buf[i] = inBlock->buf[i];
            free(inBlock->buf);
            inBlock->buf = buf;
            inBlock->bufTail = inBlock->writeTail = buf + fillBytes;
            iter.elem = inBlock;
            __GLS_LIST_PREV(&inoutStream->blockList, &iter);
            if (iter.elem) {
                __glsContextStreamBlock_removeJump(iter.elem);
                __glsContextStreamBlock_addJump(iter.elem, buf);
            }
        }
    }
    __GLS_LIST_LAST(&inoutStream->blockList, &iter);
    while (iter.elem != inBlock) {
        __GLScontextStreamBlock *const block = iter.elem;

        __GLS_LIST_PREV(&inoutStream->blockList, &iter);
        __GLS_LIST_REMOVE_DESTROY(
            &inoutStream->blockList, block, __glsContextStreamBlock_destroy
        );
    }
}

__GLScontextStreamBlock* __glsContextStreamBlock_create(size_t inBufSize) {
    __GLScontextStreamBlock *const outBlock = (
        __glsCalloc(1, sizeof(__GLScontextStreamBlock))
    );

    if (!outBlock) return GLS_NONE;
    outBlock->buf = __glsMalloc(inBufSize);
    if (!outBlock->buf) return __glsContextStreamBlock_destroy(outBlock);
    outBlock->bufTail = outBlock->buf + inBufSize;
    outBlock->writeTail = outBlock->buf;
    return outBlock;
}

__GLScontextStreamBlock* __glsContextStreamBlock_destroy(
    __GLScontextStreamBlock *inBlock
) {
    if (!inBlock) return GLS_NONE;
    free(inBlock->buf);
    free(inBlock);
    return GLS_NONE;
}

GLboolean __glsContextStreamBlock_addJump(
    __GLScontextStreamBlock *inoutBlock, GLubyte *inDest
) {
    __GLSbinCommand_jump *jump;
    const size_t wordCount = (
        ((size_t)(inoutBlock->writeTail - inoutBlock->buf)) >> 2
    );

    if ((wordCount & 1) && !__glsContextStreamBlock_addPad(inoutBlock)) {
        return GL_FALSE;
    }
    jump = (__GLSbinCommand_jump *)inoutBlock->writeTail;
    if (inoutBlock->writeTail + sizeof(*jump) > inoutBlock->bufTail) {
        return GL_FALSE;
    }
    jump->head.opSmall = GLS_NONE;
    jump->head.countSmall = 0;
    jump->head.opLarge = GLS_NONE;
    jump->head.countLarge = 0;
    jump->pad = 0;
    jump->dest = inDest;
    inoutBlock->writeTail += sizeof(*jump);
    return GL_TRUE;
}

GLboolean __glsContextStreamBlock_addPad(__GLScontextStreamBlock *inoutBlock) {
    __GLSbinCommand_pad *const pad = (
        (__GLSbinCommand_pad *)inoutBlock->writeTail
    );

    if (inoutBlock->writeTail + sizeof(*pad) > inoutBlock->bufTail) {
        return GL_FALSE;
    }
    pad->head.opSmall = GLS_OP_glsPad;
    pad->head.countSmall = 1;
    inoutBlock->writeTail += sizeof(*pad);
    return GL_TRUE;
}

GLboolean __glsContextStreamBlock_hasJump(__GLScontextStreamBlock *inBlock) {
    GLubyte *const jumpPos = (
        inBlock->writeTail - sizeof(__GLSbinCommand_jump)
    );
    __GLSbinCommand_jump *const jump = (__GLSbinCommand_jump *)jumpPos;

    return (GLboolean)(
        jumpPos >= inBlock->buf &&
        !jump->head.opSmall &&
        !jump->head.countSmall &&
        !jump->head.opLarge &&
        !jump->head.countLarge &&
        !jump->pad
    );
}

GLboolean __glsContextStreamBlock_removeJump(
    __GLScontextStreamBlock *inoutBlock
) {
    if (__glsContextStreamBlock_hasJump(inoutBlock)) {
        inoutBlock->writeTail -= sizeof(__GLSbinCommand_jump);
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/******************************************************************************
__GLSglrc
******************************************************************************/

void __glsGLRC_final(__GLSglrc *inoutGLRC) {
    free(inoutGLRC->feedbackBuf.base);
    free(inoutGLRC->selectBuf.base);
    #if __GL_EXT_vertex_array
        free(inoutGLRC->colorBuf.base);
        free(inoutGLRC->edgeFlagBuf.base);
        free(inoutGLRC->indexBuf.base);
        free(inoutGLRC->normalBuf.base);
        free(inoutGLRC->texCoordBuf.base);
        free(inoutGLRC->vertexBuf.base);
    #endif /* __GL_EXT_vertex_array */
}

void __glsGLRC_init(__GLSglrc *outGLRC) {
    memset(outGLRC, 0, sizeof(__GLSglrc));
    outGLRC->layer = 1;
}

/******************************************************************************
__GLSlayer
******************************************************************************/

void __glsLayer_init(__GLSlayer *outLayer) {
    memset(outLayer, 0, sizeof(__GLSlayer));
    outLayer->displayFormat = GLS_RGBA;
}

/******************************************************************************
__GLSheader
******************************************************************************/

void __glsHeader_final(__GLSheader *inoutHeader) {
    while (inoutHeader->glrcCount > 0) {
        __glsGLRC_final(inoutHeader->glrcs + --inoutHeader->glrcCount);
    }
    free(inoutHeader->glrcs);
    free(inoutHeader->layers);
    __glsString_final(&inoutHeader->extensions);
    __glsString_final(&inoutHeader->author);
    __glsString_final(&inoutHeader->description);
    __glsString_final(&inoutHeader->notes);
    __glsString_final(&inoutHeader->title);
    __glsString_final(&inoutHeader->tools);
    __glsString_final(&inoutHeader->version);
}

GLboolean __glsHeader_init(__GLSheader *outHeader) {
    memset(outHeader, 0, sizeof(__GLSheader));
    outHeader->glrcs = __glsMalloc(sizeof(__GLSglrc));
    outHeader->layers = __glsMalloc(sizeof(__GLSlayer));
    if (!outHeader->glrcs || !outHeader->layers) return GL_FALSE;
    __glsGLRC_init(outHeader->glrcs);
    __glsLayer_init(outHeader->layers);
    outHeader->glrcCount = 1;
    outHeader->layerCount = 1;
    outHeader->tileable = GL_TRUE;
    __glsString_init(&outHeader->extensions);
    __glsString_init(&outHeader->author);
    __glsString_init(&outHeader->description);
    __glsString_init(&outHeader->notes);
    __glsString_init(&outHeader->title);
    __glsString_init(&outHeader->tools);
    __glsString_init(&outHeader->version);
    return GL_TRUE;
}

GLboolean __glsHeader_reset(__GLSheader *inoutHeader) {
    __glsHeader_final(inoutHeader);
    return __glsHeader_init(inoutHeader);
}

/******************************************************************************
__GLSlistString
******************************************************************************/

GLboolean __glsListString_prefix(
    const __GLSlistString *inString,
    const GLubyte *inName,
    __GLSstring *outPath
) {
    if (
        __glsString_assign(outPath, inString->val.head) &&
        __glsString_append(outPath, inName)
    ) {
        return GL_TRUE;
    } else {
        __glsString_reset(outPath);
        return GL_FALSE;
    }
}

__GLSlistString* __glsListString_create(const GLubyte *inVal) {
    __GLSlistString *const outString = __glsCalloc(1, sizeof(__GLSlistString));

    if (!outString) return GLS_NONE;
    __glsString_init(&outString->val);
    if (inVal && !__glsString_append(&outString->val, inVal)) {
        return __glsListString_destroy(outString);
    }
    return outString;
}

__GLSlistString* __glsListString_destroy(__GLSlistString *inString) {
    if (!inString) return GLS_NONE;
    __glsString_final(&inString->val);
    free(inString);
    return GLS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\encoding.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

const GLubyte __glsCharType[256] = {
    /* nul 0x00 */    0,
    /* soh 0x01 */    0,
    /* stx 0x02 */    0,
    /* etx 0x03 */    0,
    /* eot 0x04 */    0,
    /* enq 0x05 */    0,
    /* ack 0x06 */    0,
    /* bel 0x07 */    0,
    /* bs  0x08 */    0,
    /* ht  0x09 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* nl  0x0A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* vt  0x0B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* np  0x0C */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* cr  0x0D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* so  0x0E */    0,
    /* si  0x0F */    0,
    /* dle 0x10 */    0,
    /* dc1 0x11 */    0,
    /* dc2 0x12 */    0,
    /* dc3 0x13 */    0,
    /* dc4 0x14 */    0,
    /* nak 0x15 */    0,
    /* syn 0x16 */    0,
    /* etb 0x17 */    0,
    /* can 0x18 */    0,
    /* em  0x19 */    0,
    /* sub 0x1A */    0,
    /* esc 0x1B */    0,
    /* fs  0x1C */    0,
    /* gs  0x1D */    0,
    /* rs  0x1E */    0,
    /* us  0x1F */    0,
    /* sp  0x20 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_SPACE_BIT,
    /* !   0x21 */    __GLS_CHAR_GRAPHIC_BIT,
    /* "   0x22 */    __GLS_CHAR_GRAPHIC_BIT,
    /* #   0x23 */    __GLS_CHAR_GRAPHIC_BIT,
    /* $   0x24 */    __GLS_CHAR_GRAPHIC_BIT,
    /* %   0x25 */    __GLS_CHAR_GRAPHIC_BIT,
    /* &   0x26 */    __GLS_CHAR_GRAPHIC_BIT,
    /* '   0x27 */    __GLS_CHAR_GRAPHIC_BIT,
    /* (   0x28 */    __GLS_CHAR_GRAPHIC_BIT,
    /* )   0x29 */    __GLS_CHAR_GRAPHIC_BIT,
    /* *   0x2A */    __GLS_CHAR_GRAPHIC_BIT,
    /* +   0x2B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* ,   0x2C */    __GLS_CHAR_GRAPHIC_BIT,
    /* -   0x2D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* .   0x2E */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* /   0x2F */    __GLS_CHAR_GRAPHIC_BIT,
    /* 0   0x30 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 1   0x31 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 2   0x32 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 3   0x33 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 4   0x34 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 5   0x35 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 6   0x36 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 7   0x37 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 8   0x38 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* 9   0x39 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* :   0x3A */    __GLS_CHAR_GRAPHIC_BIT,
    /* ;   0x3B */    __GLS_CHAR_GRAPHIC_BIT,
    /* <   0x3C */    __GLS_CHAR_GRAPHIC_BIT,
    /* =   0x3D */    __GLS_CHAR_GRAPHIC_BIT,
    /* >   0x3E */    __GLS_CHAR_GRAPHIC_BIT,
    /* ?   0x3F */    __GLS_CHAR_GRAPHIC_BIT,
    /* @   0x40 */    __GLS_CHAR_GRAPHIC_BIT,
    /* A   0x41 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* B   0x42 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* C   0x43 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* D   0x44 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* E   0x45 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* F   0x46 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* G   0x47 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* H   0x48 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* I   0x49 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* J   0x4A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* K   0x4B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* L   0x4C */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* M   0x4D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* N   0x4E */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* O   0x4F */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* P   0x50 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* Q   0x51 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* R   0x52 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* S   0x53 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* T   0x54 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* U   0x55 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* V   0x56 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* W   0x57 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* X   0x58 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* Y   0x59 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* Z   0x5A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* [   0x5B */    __GLS_CHAR_GRAPHIC_BIT,
    /* \   0x5C */    __GLS_CHAR_GRAPHIC_BIT,
    /* ]   0x5D */    __GLS_CHAR_GRAPHIC_BIT,
    /* ^   0x5E */    __GLS_CHAR_GRAPHIC_BIT,
    /* _   0x5F */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* `   0x60 */    __GLS_CHAR_GRAPHIC_BIT,
    /* a   0x61 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* b   0x62 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* c   0x63 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* d   0x64 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* e   0x65 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* f   0x66 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* g   0x67 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* h   0x68 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* i   0x69 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* j   0x6A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* k   0x6B */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* l   0x6C */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* m   0x6D */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* n   0x6E */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* o   0x6F */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* p   0x70 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* q   0x71 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* r   0x72 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* s   0x73 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* t   0x74 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* u   0x75 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* v   0x76 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* w   0x77 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* x   0x78 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* y   0x79 */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* z   0x7A */    __GLS_CHAR_GRAPHIC_BIT | __GLS_CHAR_TOKEN_BIT,
    /* {   0x7B */    __GLS_CHAR_GRAPHIC_BIT,
    /* |   0x7C */    __GLS_CHAR_GRAPHIC_BIT,
    /* }   0x7D */    __GLS_CHAR_GRAPHIC_BIT,
    /* ~   0x7E */    __GLS_CHAR_GRAPHIC_BIT,
    /* del 0x7F */    0,
    /*     0x80 */    0,
    /*     0x81 */    0,
    /*     0x82 */    0,
    /*     0x83 */    0,
    /*     0x84 */    0,
    /*     0x85 */    0,
    /*     0x86 */    0,
    /*     0x87 */    0,
    /*     0x88 */    0,
    /*     0x89 */    0,
    /*     0x8A */    0,
    /*     0x8B */    0,
    /*     0x8C */    0,
    /*     0x8D */    0,
    /*     0x8E */    0,
    /*     0x8F */    0,
    /*     0x90 */    0,
    /*     0x91 */    0,
    /*     0x92 */    0,
    /*     0x93 */    0,
    /*     0x94 */    0,
    /*     0x95 */    0,
    /*     0x96 */    0,
    /*     0x97 */    0,
    /*     0x98 */    0,
    /*     0x99 */    0,
    /*     0x9A */    0,
    /*     0x9B */    0,
    /*     0x9C */    0,
    /*     0x9D */    0,
    /*     0x9E */    0,
    /*     0x9F */    0,
    /*     0xA0 */    0,
    /*     0xA1 */    0,
    /*     0xA2 */    0,
    /*     0xA3 */    0,
    /*     0xA4 */    0,
    /*     0xA5 */    0,
    /*     0xA6 */    0,
    /*     0xA7 */    0,
    /*     0xA8 */    0,
    /*     0xA9 */    0,
    /*     0xAA */    0,
    /*     0xAB */    0,
    /*     0xAC */    0,
    /*     0xAD */    0,
    /*     0xAE */    0,
    /*     0xAF */    0,
    /*     0xB0 */    0,
    /*     0xB1 */    0,
    /*     0xB2 */    0,
    /*     0xB3 */    0,
    /*     0xB4 */    0,
    /*     0xB5 */    0,
    /*     0xB6 */    0,
    /*     0xB7 */    0,
    /*     0xB8 */    0,
    /*     0xB9 */    0,
    /*     0xBA */    0,
    /*     0xBB */    0,
    /*     0xBC */    0,
    /*     0xBD */    0,
    /*     0xBE */    0,
    /*     0xBF */    0,
    /*     0xC0 */    0,
    /*     0xC1 */    0,
    /*     0xC2 */    0,
    /*     0xC3 */    0,
    /*     0xC4 */    0,
    /*     0xC5 */    0,
    /*     0xC6 */    0,
    /*     0xC7 */    0,
    /*     0xC8 */    0,
    /*     0xC9 */    0,
    /*     0xCA */    0,
    /*     0xCB */    0,
    /*     0xCC */    0,
    /*     0xCD */    0,
    /*     0xCE */    0,
    /*     0xCF */    0,
    /*     0xD0 */    0,
    /*     0xD1 */    0,
    /*     0xD2 */    0,
    /*     0xD3 */    0,
    /*     0xD4 */    0,
    /*     0xD5 */    0,
    /*     0xD6 */    0,
    /*     0xD7 */    0,
    /*     0xD8 */    0,
    /*     0xD9 */    0,
    /*     0xDA */    0,
    /*     0xDB */    0,
    /*     0xDC */    0,
    /*     0xDD */    0,
    /*     0xDE */    0,
    /*     0xDF */    0,
    /*     0xE0 */    0,
    /*     0xE1 */    0,
    /*     0xE2 */    0,
    /*     0xE3 */    0,
    /*     0xE4 */    0,
    /*     0xE5 */    0,
    /*     0xE6 */    0,
    /*     0xE7 */    0,
    /*     0xE8 */    0,
    /*     0xE9 */    0,
    /*     0xEA */    0,
    /*     0xEB */    0,
    /*     0xEC */    0,
    /*     0xED */    0,
    /*     0xEE */    0,
    /*     0xEF */    0,
    /*     0xF0 */    0,
    /*     0xF1 */    0,
    /*     0xF2 */    0,
    /*     0xF3 */    0,
    /*     0xF4 */    0,
    /*     0xF5 */    0,
    /*     0xF6 */    0,
    /*     0xF7 */    0,
    /*     0xF8 */    0,
    /*     0xF9 */    0,
    /*     0xFA */    0,
    /*     0xFB */    0,
    /*     0xFC */    0,
    /*     0xFD */    0,
    /*     0xFE */    0,
    /*     0xFF */    0,
};

GLSenum __glsBinCommand_BeginGLS_getType(
    __GLSbinCommand_BeginGLS *inCommand, __GLSversion *outVersion
) {
    GLuint countLarge = inCommand->head.countLarge;
    GLuint opLarge = inCommand->head.opLarge;
    __GLSversion version = inCommand->version;

    if (inCommand->head.opSmall || inCommand->head.countSmall) return GLS_NONE;
    if (
        opLarge == GLS_OP_glsBeginGLS &&
        countLarge == sizeof(*inCommand) / 4 &&
        (!version.major || version.major == __GLS_VERSION_MAJOR)
    ) {
        *outVersion = version;
        return __GLS_BINARY_SWAP0;
    }
    __glsSwap4(&opLarge);
    __glsSwap4(&countLarge);
    __glsSwap4(&version.major);
    __glsSwap4(&version.minor);
    if (
        opLarge == GLS_OP_glsBeginGLS &&
        countLarge == sizeof(*inCommand) / 4 &&
        (!version.major || version.major == __GLS_VERSION_MAJOR)
    ) {
        *outVersion = version;
        return __GLS_BINARY_SWAP1;
    }
    return GLS_NONE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\glref.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* Force loading of libGL.a.  Needed only for AIX */

void __gls_glRef(void) {
    if (0) glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\exec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

static GLclampf __glsFloatToClampf(GLfloat inVal) {
    if (inVal < 0.f) inVal = 0.f;
    if (inVal > 1.f) inVal = 1.f;
    return inVal;
}

void __gls_exec_glsBeginGLS(
    GLint inVersionMajor, GLint inVersionMinor
) {
    __GLS_CONTEXT->streamVersion.major = inVersionMajor;
    __GLS_CONTEXT->streamVersion.minor = inVersionMinor;
}

void __gls_exec_glsBlock(GLSenum inBlockType) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    switch (inBlockType) {
        case GLS_FRAME:
        case GLS_INIT:
        case GLS_STATIC:
            ctx->blockType = inBlockType;
            break;
        case GLS_HEADER:
            if (__glsHeader_reset(&ctx->header)) ctx->blockType = inBlockType;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

GLSenum __gls_exec_glsCallStream(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;
    GLSenum outType = GLS_NONE;
    __GLSversion versionSave;

    if (ctx->abortMode) return outType;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        glsAbortCall(GLS_ALL);
        return outType;
    }
    if (!__glsValidateString(inName)) return outType;
    ++ctx->callNesting;
    versionSave = ctx->streamVersion;
    ctx->streamVersion.major = ctx->streamVersion.minor = 0;
    if (
        contextStream = __glsStr2PtrDict_find(ctx->contextStreamDict, inName)
    ) {
        GLint i;

        outType = GLS_CONTEXT;
        for (i = 0 ; i < ctx->captureNesting ; ++i) {
            if (ctx->writers[i]->contextStream == contextStream) {
                __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                outType = GLS_NONE;
                break;
            }
        }
        if (outType == GLS_CONTEXT) __glsContextStream_call(contextStream);
    } else if (readStream = __glsReadStream_create(inName)) {
        __GLSreader reader;

        if (__glsReader_init_stream(
            &reader, readStream, __GLS_READER_BUF_BYTES
        )) {
            outType = reader.type;
            __glsReader_call(&reader);
            __glsReader_final(&reader);
        } else {
            __GLS_RAISE_ERROR(GLS_INVALID_STREAM);
        }
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
    }
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) glsAbortCall(GLS_NONE);
            break;
        case GLS_LAST:
            glsAbortCall(GLS_NONE);
            break;
    }
    ctx->streamVersion = versionSave;
    return outType;
}

void __gls_exec_glsEndGLS(void) {
    __GLS_CONTEXT->streamVersion.major = 0;
    __GLS_CONTEXT->streamVersion.minor = 0;
}

void __gls_exec_glsError(GLSopcode inOpcode, GLSenum inError) {
    if (
        inError &&
        (inError < GLS_CALL_OVERFLOW || inError > GLS_UNSUPPORTED_EXTENSION)
    ) {
        inError = GLS_INVALID_ENUM;
    }
    __GLS_RAISE_ERROR( UintToPtr(inError) );
}

void __gls_exec_glsGLRC(GLuint inGLRC) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!inGLRC || inGLRC > (GLuint)ctx->header.glrcCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
    } else {
        ctx->currentGLRC = inGLRC;
    }
}

void __gls_exec_glsGLRCLayer(
    GLuint inGLRC, GLuint inLayer, GLuint inReadLayer
) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (
        !inGLRC ||
        inGLRC > (GLuint)ctx->header.glrcCount ||
        !inLayer ||
        inLayer > (GLuint)ctx->header.layerCount ||
        inReadLayer > (GLuint)ctx->header.layerCount
    ) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
    } else {
        __GLSglrc *const glrc = ctx->header.glrcs + inGLRC - 1;

        glrc->layer = inLayer;
        glrc->readLayer = inReadLayer;
    }
}

void __gls_exec_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSglrc *glrc;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!inGLRC || inGLRC > (GLuint)ctx->header.glrcCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    glrc = ctx->header.glrcs + inGLRC - 1;
    switch (inAttrib) {
        case GLS_LAYER:
            if (inVal < 1 || inVal > ctx->header.layerCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else {
                glrc->layer = inVal;
            }
            break;
        case GLS_READ_LAYER:
            if (inVal < 0 || inVal > ctx->header.layerCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else {
                glrc->readLayer = inVal;
            }
            break;
        case GLS_SHARE_GLRC:
            if (inVal < 0 || inVal > ctx->header.glrcCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else {
                glrc->shareGLRC = inVal;
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderLayerf(
    GLuint inLayer, GLSenum inAttrib, GLfloat inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_INVISIBLE_ASPECT:
            layer->invisibleAspect = inVal > 0.f ? inVal : 0.f;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderLayeri(
    GLuint inLayer, GLSenum inAttrib, GLint inVal
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_DISPLAY_FORMAT:
            switch (inVal) {
                case GLS_IIII:
                case GLS_RGBA:
                case GLS_RRRA:
                    layer->displayFormat = inVal;
                    break;
                default:
                    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
                    break;
            }
            break;
        case GLS_DOUBLEBUFFER:
            layer->doubleBuffer = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_INVISIBLE:
            layer->invisible = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_INVISIBLE_HEIGHT_PIXELS:
            layer->invisibleHeightPixels = inVal > 0 ? inVal : 0;
            break;
        case GLS_LEVEL:
            layer->level = inVal;
            break;
        case GLS_STEREO:
            layer->stereo = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_TRANSPARENT:
            layer->transparent = inVal ? GL_TRUE : GL_FALSE;
            break;
        case GLS_INDEX_BITS:
            layer->indexBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_RED_BITS:
            layer->redBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_GREEN_BITS:
            layer->greenBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_BLUE_BITS:
            layer->blueBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ALPHA_BITS:
            layer->alphaBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_DEPTH_BITS:
            layer->depthBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_STENCIL_BITS:
            layer->stencilBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_RED_BITS:
            layer->accumRedBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_GREEN_BITS:
            layer->accumGreenBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_BLUE_BITS:
            layer->accumBlueBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_ACCUM_ALPHA_BITS:
            layer->accumAlphaBits = inVal > 0 ? inVal : 0;
            break;
        case GLS_AUX_BUFFERS:
            layer->auxBuffers = inVal > 0 ? inVal : 0;
            break;
        #if __GL_SGIS_multisample
            case GLS_SAMPLE_BUFFERS_SGIS:
                layer->sampleBuffers = inVal > 0 ? inVal : 0;
                break;
            case GLS_SAMPLES_SGIS:
                layer->samples = inVal > 0 ? inVal : 0;
                break;
        #endif /* __GL_SGIS_multisample */
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderf(GLSenum inAttrib, GLfloat inVal) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_ASPECT:
            header->aspect = inVal > 0.f ? inVal : 0.f;
            break;
        case GLS_BORDER_WIDTH:
            header->borderWidth = inVal > 0.f ? inVal : 0.f;
            break;
        case GLS_CONTRAST_RATIO:
            header->contrastRatio = inVal > 0.f ? inVal : 0.f;
            break;
        case GLS_HEIGHT_MM:
            header->heightMM = inVal > 0.f ? inVal : 0.f;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;
    GLint i;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_BORDER_COLOR:
            for (i = 0 ; i < 4 ; ++i) {
                header->borderColor[i] = __glsFloatToClampf(inVec[i]);
            }
            break;
        case GLS_GAMMA:
            for (i = 0 ; i < 4 ; ++i) {
                header->gamma[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_ORIGIN:
            for (i = 0 ; i < 2 ; ++i) header->origin[i] = inVec[i];
            break;
        case GLS_PAGE_COLOR:
            for (i = 0 ; i < 4 ; ++i) {
                header->pageColor[i] = __glsFloatToClampf(inVec[i]);
            }
            break;
        case GLS_PAGE_SIZE:
            for (i = 0 ; i < 2 ; ++i) {
                header->pageSize[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_RED_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->redPoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_GREEN_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->greenPoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_BLUE_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->bluePoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        case GLS_WHITE_POINT:
            for (i = 0 ; i < 2 ; ++i) {
                header->whitePoint[i] = inVec[i] > 0.f ? inVec[i] : 0.f;
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderi(GLSenum inAttrib, GLint inVal) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_FRAME_COUNT:
            header->frameCount = inVal > 0 ? inVal : 0;
            break;
        case GLS_GLRC_COUNT:
            if (inVal < header->glrcCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else if (inVal > header->glrcCount) {
                GLint i;
                __GLSglrc *glrcs = __glsMalloc(inVal * sizeof(__GLSglrc));

                if (!glrcs) break;
                memcpy(
                    glrcs,
                    header->glrcs,
                    header->glrcCount * sizeof(__GLSglrc)
                );
                for (i = header->glrcCount ; i < inVal ; ++i) {
                    __glsGLRC_init(glrcs + i);
                }
                header->glrcCount = inVal;
                free(header->glrcs);
                header->glrcs = glrcs;
            }
            break;
        case GLS_HEIGHT_PIXELS:
            header->heightPixels = inVal > 0 ? inVal : 0;
            break;
        case GLS_LAYER_COUNT:
            if (inVal < header->layerCount) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            } else if (inVal > header->layerCount) {
                GLint i;
                __GLSlayer *layers = __glsMalloc(inVal * sizeof(__GLSlayer));

                if (!layers) break;
                memcpy(
                    layers,
                    header->layers,
                    header->layerCount * sizeof(__GLSlayer)
                );
                for (i = header->layerCount ; i < inVal ; ++i) {
                    __glsLayer_init(layers + i);
                }
                header->layerCount = inVal;
                free(header->layers);
                header->layers = layers;
            }
            break;
        case GLS_TILEABLE:
            header->tileable = inVal ? GL_TRUE : GL_FALSE;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;
    GLint i;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_CREATE_TIME:
            for (i = 0 ; i < 6 ; ++i) {
                header->createTime[i] = inVec[i] > 0 ? inVec[i] : 0;
            }
            break;
        case GLS_MODIFY_TIME:
            for (i = 0 ; i < 6 ; ++i) {
                header->modifyTime[i] = inVec[i] > 0 ? inVec[i] : 0;
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSheader *header;

    if (ctx->blockType != GLS_HEADER) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (!__glsValidateString(inString)) return;
    header = &ctx->header;
    switch (inAttrib) {
        case GLS_EXTENSIONS:
            __glsString_assign(&header->extensions, inString);
            break;
        case GLS_AUTHOR:
            __glsString_assign(&header->author, inString);
            break;
        case GLS_DESCRIPTION:
            __glsString_assign(&header->description, inString);
            break;
        case GLS_NOTES:
            __glsString_assign(&header->notes, inString);
            break;
        case GLS_TITLE:
            __glsString_assign(&header->title, inString);
            break;
        case GLS_TOOLS:
            __glsString_assign(&header->tools, inString);
            break;
        case GLS_VERSION:
            __glsString_assign(&header->version, inString);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void __gls_exec_glsRequireExtension(const GLubyte *inExtension) {
    if (!__glsValidateString(inExtension)) return;
    if (!glsIsExtensionSupported(inExtension)) {
        __GLS_RAISE_ERROR(GLS_UNSUPPORTED_EXTENSION);
    }
}

void __gls_exec_glsUnsupportedCommand(void) {
    __GLS_RAISE_ERROR(GLS_UNSUPPORTED_COMMAND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\glslib.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

/******************************************************************************
Global data
******************************************************************************/

const GLSenum __glsAllAPIs[__GLS_API_COUNT + 1] = {
    GLS_API_GLS,
    GLS_API_GL,
    GLS_NONE,
};

const GLubyte *const __glsExtensions = (const GLubyte *)(
    ""

    #if __GL_EXT_abgr
        "GL_EXT_abgr "
    #endif /* __GL_EXT_abgr */

    #if __GL_EXT_blend_color
        "GL_EXT_blend_color "
    #endif /* __GL_EXT_blend_color */

    #if __GL_EXT_blend_logic_op
        "GL_EXT_blend_logic_op "
    #endif /* __GL_EXT_blend_logic_op */

    #if __GL_EXT_blend_minmax
        "GL_EXT_blend_minmax "
    #endif /* __GL_EXT_blend_minmax */

    #if __GL_EXT_blend_subtract
        "GL_EXT_blend_subtract "
    #endif /* __GL_EXT_blend_subtract */

    #if __GL_EXT_cmyka
        "GL_EXT_cmyka "
    #endif /* __GL_EXT_cmyka */

    #if __GL_EXT_convolution
        "GL_EXT_convolution "
    #endif /* __GL_EXT_convolution */

    #if __GL_EXT_copy_texture
        "GL_EXT_copy_texture "
    #endif /* __GL_EXT_copy_texture */

    #if __GL_EXT_histogram
        "GL_EXT_histogram "
    #endif /* __GL_EXT_histogram */

    #if __GL_EXT_packed_pixels
        "GL_EXT_packed_pixels "
    #endif /* __GL_EXT_packed_pixels */

    #if __GL_EXT_polygon_offset
        "GL_EXT_polygon_offset "
    #endif /* __GL_EXT_polygon_offset */

    #if __GL_EXT_rescale_normal
        "GL_EXT_rescale_normal "
    #endif /* __GL_EXT_rescale_normal */

    #if __GL_EXT_subtexture
        "GL_EXT_subtexture "
    #endif /* __GL_EXT_subtexture */

    #if __GL_EXT_texture
        "GL_EXT_texture "
    #endif /* __GL_EXT_texture */

    #if __GL_EXT_texture_object
        "GL_EXT_texture_object "
    #endif /* __GL_EXT_texture_object */

    #if __GL_EXT_texture3D
        "GL_EXT_texture3D "
    #endif /* __GL_EXT_texture3D */

    #if __GL_EXT_vertex_array
        "GL_EXT_vertex_array "
    #endif /* __GL_EXT_vertex_array */

    #if __GL_SGI_color_matrix
        "GL_SGI_color_matrix "
    #endif /* __GL_SGI_color_matrix */

    #if __GL_SGI_color_table
        "GL_SGI_color_table "
    #endif /* __GL_SGI_color_table */

    #if __GL_SGI_texture_color_table
        "GL_SGI_texture_color_table "
    #endif /* __GL_SGI_texture_color_table */

    #if __GL_SGIS_component_select
        "GL_SGIS_component_select "
    #endif /* __GL_SGIS_component_select */

    #if __GL_SGIS_detail_texture
        "GL_SGIS_detail_texture "
    #endif /* __GL_SGIS_detail_texture */

    #if __GL_SGIS_multisample
        "GL_SGIS_multisample "
    #endif /* __GL_SGIS_multisample */

    #if __GL_SGIS_sharpen_texture
        "GL_SGIS_sharpen_texture "
    #endif /* __GL_SGIS_sharpen_texture */

    #if __GL_SGIS_texture_border_clamp
        "GL_SGIS_texture_border_clamp "
    #endif /* __GL_SGIS_texture_border_clamp */

    #if __GL_SGIS_texture_edge_clamp
        "GL_SGIS_texture_edge_clamp "
    #endif /* __GL_SGIS_texture_edge_clamp */

    #if __GL_SGIS_texture_filter4
        "GL_SGIS_texture_filter4 "
    #endif /* __GL_SGIS_texture_filter4 */

    #if __GL_SGIS_texture_lod
        "GL_SGIS_texture_lod "
    #endif /* __GL_SGIS_texture_lod */

    #if __GL_SGIS_texture4D
        "GL_SGIS_texture4D "
    #endif /* __GL_SGIS_texture4D */

    #if __GL_SGIX_interlace
        "GL_SGIX_interlace "
    #endif /* __GL_SGIX_interlace */

    #if __GL_SGIX_multipass
        "GL_SGIX_multipass "
    #endif /* __GL_SGIX_multipass */

    #if __GL_SGIX_multisample
        "GL_SGIX_multisample "
    #endif /* __GL_SGIX_multisample */

    #if __GL_SGIX_pixel_texture
        "GL_SGIX_pixel_texture "
    #endif /* __GL_SGIX_pixel_texture */

    #if __GL_SGIX_pixel_tiles
        "GL_SGIX_pixel_tiles "
    #endif /* __GL_SGIX_pixel_tiles */

    #if __GL_SGIX_sprite
        "GL_SGIX_sprite "
    #endif /* __GL_SGIX_sprite */

    #if __GL_SGIX_texture_multi_buffer
        "GL_SGIX_texture_multi_buffer "
    #endif /* __GL_SGIX_texture_multi_buffer */
);

__GLSdict *__glsContextDict = GLS_NONE;
__GLScontextList __glsContextList = {GLS_NONE};
__GLSparser *__glsParser = GLS_NONE;

/******************************************************************************
Global functions
******************************************************************************/

#ifndef __GLS_PLATFORM_WIN32
// DrewB
void __glsCallError(GLSopcode inOpcode, GLSenum inError) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);

    ((__GLSdispatch)__GLS_CONTEXT->dispatchCall[GLS_OP_glsError])(
        inOpcode, inError
    );
}

void __glsCallUnsupportedCommand(void) {
    typedef void (*__GLSdispatch)(void);

    ((__GLSdispatch)__GLS_CONTEXT->dispatchCall[GLS_OP_glsUnsupportedCommand])(
    );
}
#else
void __glsCallError(__GLScontext *ctx, GLSopcode inOpcode, GLSenum inError) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);

    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glsError])(
        inOpcode, inError
    );
}

void __glsCallUnsupportedCommand(__GLScontext *ctx) {
    typedef void (*__GLSdispatch)(void);

    ((__GLSdispatch)ctx->dispatchCall[GLS_OP_glsUnsupportedCommand])(
    );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\glsutil.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

/******************************************************************************
Array
******************************************************************************/

void __glsArray_final(__GLSarray *inoutArray) {
    free(inoutArray->base);
    __glsArray_init(inoutArray);
}

void __glsArray_init(__GLSarray *outArray) {
    outArray->base = GLS_NONE;
    outArray->bufCount = outArray->count = 0;
}

void __glsArray_compact(__GLSarray *inoutArray, size_t inElemSize) {
    if (inoutArray->bufCount == inoutArray->count) return;
    if (inoutArray->count) {
        GLvoid *const newBase = realloc(
            inoutArray->base, inoutArray->count * inElemSize
        );

        if (newBase) {
            inoutArray->base = newBase;
            inoutArray->bufCount = inoutArray->count;
        }
    } else {
        __glsArray_final(inoutArray);
    }
}

void __glsArray_delete(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    size_t inElemSize
) { 
    if (inIndex >= inoutArray->count) return;
    if (inIndex + inCount >= inoutArray->count) {
        inoutArray->count = inIndex;
    } else {
        GLubyte *const p = (GLubyte *)inoutArray->base + inIndex * inElemSize;

        memmove(
            p,
            p + inCount * inElemSize,
            (inoutArray->count - (inIndex + inCount)) * inElemSize
        );
        inoutArray->count -= inCount;
    }
}

GLboolean __glsArray_insert(
    __GLSarray *inoutArray,
    size_t inIndex,
    size_t inCount,
    GLboolean inInit,
    size_t inElemSize
) {
    const size_t newCount = inoutArray->count + inCount;

    if (newCount > inoutArray->bufCount) {
        size_t newBufCount = __glsCeilBase2(newCount);
        GLvoid *buf = malloc(newBufCount * inElemSize);

        if (!buf) {
            newBufCount = newCount;
            buf = __glsMalloc(newBufCount * inElemSize);
            if (!buf) return GL_FALSE;
        }
        memmove(buf, inoutArray->base, inoutArray->count);
        free(inoutArray->base);
        inoutArray->base = buf;
        inoutArray->bufCount = newBufCount;
    }
    if (inIndex < inoutArray->count) {
        GLubyte *const p = (GLubyte *)inoutArray->base + inIndex * inElemSize;

        memmove(
            p + inCount * inElemSize,
            p,
            (inoutArray->count - inIndex) * inElemSize
        );
    } else {
        inIndex = inoutArray->count;
    }
    if (inInit) {
        memset(
            (GLubyte *)inoutArray->base + inIndex * inElemSize,
            0,
            inCount * inElemSize
        );
    }
    inoutArray->count = newCount;
    return GL_TRUE;
}

/******************************************************************************
Checksum
******************************************************************************/

#define __GLS_CRC32_POLY 0x04c11db7 /* AUTODIN II, Ethernet, & FDDI */

#if __GLS_UNUSED
static void __glsCRC32tableInit(void) {
    GLuint c, i, j;

    for (i = 0; i < 256; ++i) {
        for (c = i << 24, j = 8; j ; --j) {
           c = c & 0x80000000 ? (c << 1) ^ __GLS_CRC32_POLY : (c << 1);
        }
        __glsCRC32table[i] = c;
    }
}
#endif /* __GLS_UNUSED */

const GLuint __glsCRC32table[256] = {
    0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,
    0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,
    0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
    0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,
    0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,
    0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
    0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,
    0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,
    0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
    0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,
    0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,
    0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
    0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,
    0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,
    0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
    0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,
    0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,
    0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
    0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,
    0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,
    0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
    0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,
    0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,
    0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
    0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,
    0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,
    0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
    0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,
    0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,
    0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
    0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,
    0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,
    0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
    0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,
    0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,
    0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
    0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,
    0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,
    0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
    0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,
    0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,
    0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
    0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,
    0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,
    0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
    0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,
    0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,
    0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
    0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,
    0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,
    0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
    0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,
    0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,
    0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
    0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,
    0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,
    0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
    0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,
    0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,
    0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
    0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,
    0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,
    0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
    0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4,
};

/******************************************************************************
Dict
******************************************************************************/

typedef struct {
    __GLS_LIST_ELEM;
    union {
        GLint intKey;
        const GLubyte *strKey;
    } key;
    union {
        GLint intVal;
        GLvoid *ptrVal;
    } val;
} __GLSdictEntry;

typedef __GLS_LIST(__GLSdictEntry) __GLSdictEntryList;
typedef __GLS_LIST_ITER(__GLSdictEntry) __GLSdictEntryIter;

struct __GLSdict{
    size_t count;
    __GLSdictEntryList *table;
    size_t tableMax;
    GLboolean staticKeys;
};

static __GLSdict* __glsDict_create(
    size_t inTableCount, GLboolean inStaticKeys
) {
    __GLSdict *outDict;

    if (inTableCount < 1) return GLS_NONE;
    outDict = __glsCalloc(1, sizeof(__GLSdict));
    if (!outDict) return GLS_NONE;
    outDict->staticKeys = inStaticKeys;
    inTableCount = __glsCeilBase2(inTableCount);
    outDict->table = __glsCalloc(inTableCount, sizeof(__GLSdictEntryList));
    if (!outDict->table) return __glsStrDict_destroy(outDict);
    outDict->tableMax = inTableCount - 1;
    return outDict;
}

__GLS_FORWARD static __GLSdictEntry* __glsIntDictEntry_destroy(
    __GLSdictEntry *inEntry
);

static __GLSdictEntry* __glsIntDictEntry_create(GLint inKey) {
    __GLSdictEntry *const outEntry = __glsCalloc(1, sizeof(__GLSdictEntry));

    if (!outEntry) return GLS_NONE;
    outEntry->key.intKey = inKey;
    return outEntry;
}

static __GLSdictEntry* __glsIntDictEntry_destroy(__GLSdictEntry *inEntry) {
    free(inEntry);
    return GLS_NONE;
}

static size_t __glsIntHash(const __GLSdict *inDict, GLint inKey) {
    return inKey & inDict->tableMax;
}

static GLboolean __glsIntDict_add(
    __GLSdict *inoutDict, GLint inKey, __GLSdictEntry *inEntry
) {
    if (inoutDict->count++ > inoutDict->tableMax) {
        const size_t newTableSize = (inoutDict->tableMax + 1) * 2;
        __GLSdictEntryList *const newTable = (
            __glsCalloc(newTableSize, sizeof(__GLSdictEntryList))
        );
        if (newTable) {
            size_t i = inoutDict->tableMax;

            inoutDict->tableMax = newTableSize - 1;
            for ( ; i != (size_t)-1; --i) {
                __GLSdictEntry *oldEntry;

                while (oldEntry = inoutDict->table[i].head) {
                    __GLS_LIST_REMOVE(inoutDict->table + i, oldEntry);
                    __GLS_LIST_APPEND(
                      newTable + __glsIntHash(inoutDict, oldEntry->key.intKey),
                      oldEntry
                    );
                }
            }
            free(inoutDict->table);
            inoutDict->table = newTable;
        }
    }
    __GLS_LIST_PREPEND(
        inoutDict->table + __glsIntHash(inoutDict, inKey), inEntry
    );

    return GL_TRUE;
}

__GLSdict* __glsIntDict_create(size_t inTableCount) {
    return __glsDict_create(inTableCount, GL_FALSE);
}

__GLSdict* __glsIntDict_destroy(__GLSdict *inDict) {
    size_t i;

    if (!inDict) return GLS_NONE;
    if (inDict->table) for (i = inDict->tableMax ; i != (size_t)-1; --i) {
        __GLS_LIST_CLEAR_DESTROY(inDict->table + i, __glsIntDictEntry_destroy);
    }
    free(inDict->table);
    free(inDict);
    return GLS_NONE;
}

void __glsIntDict_print(__GLSdict *inoutDict, const GLubyte *inName) {
    size_t i;

    fprintf(stdout, "%s(\n", inName);
    for (i = 0 ; i <= inoutDict->tableMax ; ++i) {
        __GLSdictEntryIter iter;

        __GLS_LIST_FIRST(inoutDict->table + i, &iter);
        if (iter.elem) {
            fprintf(stdout, "   ");
            while (iter.elem) {
                fprintf(stdout, " %d", iter.elem->key.intKey);
                __GLS_LIST_NEXT(inoutDict->table + i, &iter);
            }
            fprintf(stdout, "\n");
        }
    }
    fprintf(stdout, ")\n");
}

void __glsIntDict_remove(__GLSdict *inoutDict, GLint inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsIntHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            __GLS_LIST_REMOVE_DESTROY(
                list, iter.elem, __glsIntDictEntry_destroy
            );
            --inoutDict->count;
            return;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
}

GLboolean __glsInt2IntDict_add(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
) {
    __GLSdictEntry *entry;

    if (__glsInt2IntDict_find(inoutDict, inKey, GLS_NONE)) return GL_FALSE;
    entry = __glsIntDictEntry_create(inKey);
    if (!entry) return GL_FALSE;
    entry->val.intVal = inVal;
    return __glsIntDict_add(inoutDict, inKey, entry);
}

GLboolean __glsInt2PtrDict_add(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
) {
    __GLSdictEntry *entry;

    if (__glsInt2PtrDict_find(inoutDict, inKey)) return GL_FALSE;
    entry = __glsIntDictEntry_create(inKey);
    if (!entry) return GL_FALSE;
    entry->val.ptrVal = inVal;
    return __glsIntDict_add(inoutDict, inKey, entry);
}

GLboolean __glsInt2IntDict_find(
    const __GLSdict *inDict, GLint inKey, GLint *optoutVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsIntHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            if (optoutVal) *optoutVal = iter.elem->val.intVal;
            return GL_TRUE;
        }   
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLvoid* __glsInt2PtrDict_find(const __GLSdict *inDict, GLint inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsIntHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            return iter.elem->val.ptrVal;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GLS_NONE;
}

GLboolean __glsInt2IntDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLint inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsIntHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            iter.elem->val.intVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLboolean __glsInt2PtrDict_replace(
    __GLSdict *inoutDict, GLint inKey, GLvoid *inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsIntHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (inKey == iter.elem->key.intKey) {
            iter.elem->val.ptrVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

__GLS_FORWARD static __GLSdictEntry* __glsStrDictEntry_destroy(
    __GLSdictEntry *inEntry, GLboolean inStaticKey
);

static __GLSdictEntry* __glsStrDictEntry_create(
    const GLubyte *inKey, GLboolean inStaticKey
) {
    __GLSdictEntry *const outEntry = __glsCalloc(1, sizeof(__GLSdictEntry));

    if (!outEntry) return GLS_NONE;
    if (inStaticKey) {
        outEntry->key.strKey = inKey;
    } else {
        GLubyte *const buf = __glsMalloc(strlen((const char *)inKey) + 1);

        if (!buf) {
            return __glsStrDictEntry_destroy(outEntry, GL_FALSE);
        }
        strcpy((char *)buf, (const char *)inKey);
        outEntry->key.strKey = buf;
    }
    return outEntry;
}

static __GLSdictEntry* __glsStrDictEntry_destroy(
    __GLSdictEntry *inEntry, GLboolean inStaticKey
) {
    if (!inEntry) return GLS_NONE;
    if (!inStaticKey) free((GLvoid *)inEntry->key.strKey);
    free(inEntry);
    return GLS_NONE;
}

static size_t __glsStrHash(const __GLSdict *inDict, const GLubyte *inKey) {
    GLubyte charVal;
    size_t outHash = 0;

    while (charVal = *inKey++) outHash += charVal;
    return outHash & inDict->tableMax;
}

static GLboolean __glsStrDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, __GLSdictEntry *inEntry
) {
    if (inoutDict->count++ > inoutDict->tableMax) {
        const size_t newTableSize = (inoutDict->tableMax + 1) * 2;
        __GLSdictEntryList *const newTable = (
            __glsCalloc(newTableSize, sizeof(__GLSdictEntryList))
        );

        if (newTable) {
            size_t i = inoutDict->tableMax;

            inoutDict->tableMax = newTableSize - 1;
            for ( ; i != (size_t)-1; --i) {
                __GLSdictEntry *oldEntry;

                while (oldEntry = inoutDict->table[i].head) {
                    __GLS_LIST_REMOVE(inoutDict->table + i, oldEntry);
                    __GLS_LIST_APPEND(
                      newTable + __glsStrHash(inoutDict, oldEntry->key.strKey),
                      oldEntry
                    );
                }
            }
            free(inoutDict->table);
            inoutDict->table = newTable;
        }
    }
    __GLS_LIST_PREPEND(
        inoutDict->table + __glsStrHash(inoutDict, inKey), inEntry
    );
    return GL_TRUE;
}

__GLSdict* __glsStrDict_create(size_t inTableCount, GLboolean inStaticKeys) {
    return __glsDict_create(inTableCount, inStaticKeys);
}

__GLSdict* __glsStrDict_destroy(__GLSdict *inDict) {
    size_t i;

    if (!inDict) return GLS_NONE;
    if (inDict->table) for (i = inDict->tableMax ; i != (size_t)-1; --i) {
        __GLSdictEntry *entry;

        while (entry = inDict->table[i].head) {
            __GLS_LIST_REMOVE(inDict->table + i, entry);
            __glsStrDictEntry_destroy(entry, inDict->staticKeys);
        }
    }
    free(inDict->table);
    free(inDict);
    return GLS_NONE;
}

void __glsStrDict_print(__GLSdict *inoutDict, const GLubyte *inName) {
    size_t i;

    fprintf(stdout, "%s(\n", inName);
    for (i = 0 ; i <= inoutDict->tableMax ; ++i) {
        __GLSdictEntryIter iter;
        __GLS_LIST_FIRST(inoutDict->table + i, &iter);
        if (iter.elem) {
            fprintf(stdout, "   ");
            while (iter.elem) {
                fprintf(stdout, " %s", iter.elem->key.strKey);
                __GLS_LIST_NEXT(inoutDict->table + i, &iter);
            }
            fprintf(stdout, "\n");
        }
    }
    fprintf(stdout, ")\n");
}

void __glsStrDict_remove(__GLSdict *inoutDict, const GLubyte *inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsStrHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            __GLS_LIST_REMOVE(list, iter.elem);
            __glsStrDictEntry_destroy(iter.elem, inoutDict->staticKeys);
            --inoutDict->count;
            return;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
}

GLboolean __glsStr2IntDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
) {
    __GLSdictEntry *entry;

    if (__glsStr2IntDict_find(inoutDict, inKey, GLS_NONE)) return GL_FALSE;
    entry = __glsStrDictEntry_create(inKey, inoutDict->staticKeys);
    if (!entry) return GL_FALSE;
    entry->val.intVal = inVal;
    return __glsStrDict_add(inoutDict, inKey, entry);
}

GLboolean __glsStr2PtrDict_add(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
) {
    __GLSdictEntry *entry;

    if (__glsStr2PtrDict_find(inoutDict, inKey)) return GL_FALSE;
    entry = __glsStrDictEntry_create(inKey, inoutDict->staticKeys);
    if (!entry) return GL_FALSE;
    entry->val.ptrVal = inVal;
    return __glsStrDict_add(inoutDict, inKey, entry);
}

GLboolean __glsStr2IntDict_find(
    const __GLSdict *inDict, const GLubyte *inKey, GLint *optoutVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsStrHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            if (optoutVal) *optoutVal = iter.elem->val.intVal;
            return GL_TRUE;
        }   
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLvoid* __glsStr2PtrDict_find(const __GLSdict *inDict, const GLubyte *inKey) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inDict->table + __glsStrHash(inDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            return iter.elem->val.ptrVal;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GLS_NONE;
}

GLboolean __glsStr2IntDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLint inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsStrHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            iter.elem->val.intVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

GLboolean __glsStr2PtrDict_replace(
    __GLSdict *inoutDict, const GLubyte *inKey, GLvoid *inVal
) {
    __GLSdictEntryIter iter;
    __GLSdictEntryList *const list = (
        inoutDict->table + __glsStrHash(inoutDict, inKey)
    );

    __GLS_LIST_FIRST(list, &iter);
    while (iter.elem) {
        if (
            !strcmp((const char *)inKey, (const char *)iter.elem->key.strKey)
        ) {
            iter.elem->val.ptrVal = inVal;
            return GL_TRUE;
        }
        __GLS_LIST_NEXT(list, &iter);
    }
    return GL_FALSE;
}

/******************************************************************************
List
******************************************************************************/

void __glsListAppend(__GLSlist *inoutList, __GLSlistElem *inoutElem) {
    if (inoutList->head) {
        inoutList->head->prev->next = inoutElem;
        inoutElem->prev = inoutList->head->prev;
        inoutElem->next = inoutList->head;
        inoutList->head->prev = inoutElem;
    } else {
        inoutList->head = inoutElem;
        inoutElem->prev = inoutElem->next = inoutElem;
    }
}

void __glsListClearDestroy(
    __GLSlist *inoutList, __GLSlistElemDestructor inDestructor
) {
    while (inoutList->head) {
        __glsListRemoveDestroy(inoutList, inoutList->head, inDestructor);
    }
}

void __glsListFirst(__GLSlist *inList, __GLSlistIter *inoutIter) {
    inoutIter->elem = inList->head;
}

void __glsListLast(__GLSlist *inList, __GLSlistIter *inoutIter) {
    inoutIter->elem = inList->head ? inList->head->prev : GLS_NONE;
}

void __glsListNext(__GLSlist *inList, __GLSlistIter *inoutIter) {
    if (inoutIter->elem) {
        inoutIter->elem = inoutIter->elem->next;
        if (inoutIter->elem == inList->head) inoutIter->elem = GLS_NONE;
    }
}

void __glsListPrepend(__GLSlist *inoutList, __GLSlistElem *inoutElem) {
    if (inoutList->head) {
        inoutList->head->prev->next = inoutElem;
        inoutElem->prev = inoutList->head->prev;
        inoutElem->next = inoutList->head;
        inoutList->head->prev = inoutElem;
        inoutList->head = inoutElem;
    } else {
        inoutList->head = inoutElem;
        inoutElem->prev = inoutElem->next = inoutElem;
    }
}

void __glsListPrev(__GLSlist *inList, __GLSlistIter *inoutIter) {
    if (inoutIter->elem) {
        inoutIter->elem = (
            (inoutIter->elem == inList->head) ?
            GLS_NONE :
            inoutIter->elem->prev
        );
    }
}

void __glsListRemove(__GLSlist *inoutList, __GLSlistElem *inoutElem) {
    if (inoutList->head == inoutList->head->next) {
        inoutList->head = GLS_NONE;
    } else {
        inoutElem->next->prev = inoutElem->prev;
        inoutElem->prev->next = inoutElem->next;
        if (inoutList->head == inoutElem) {
            inoutList->head = inoutList->head->next;
        }
    }
}

void __glsListRemoveDestroy(
    __GLSlist *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
) {
    __glsListRemove(inoutList, inElem);
    inDestructor(inElem);
}

/******************************************************************************
IterList
******************************************************************************/

void __glsIterListAppend(__GLSiterList *inoutList, __GLSlistElem *inoutElem) {
    __glsListAppend((__GLSlist *)&inoutList->head, inoutElem);
    ++inoutList->count;
}

void __glsIterListClearDestroy(
    __GLSiterList *inoutList, __GLSlistElemDestructor inDestructor
) {
    __glsListClearDestroy((__GLSlist *)&inoutList->head, inDestructor);
    inoutList->iterElem = GLS_NONE;
    inoutList->count = inoutList->iterIndex = 0;
}

void __glsIterListFirst(__GLSiterList *inoutList) {
    __glsListFirst(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = 0;
}

void __glsIterListLast(__GLSiterList *inoutList) {
    __glsListLast(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = inoutList->iterElem ? inoutList->count - 1 : 0;
}

void __glsIterListNext(__GLSiterList *inoutList) {
    __glsListNext(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = inoutList->iterElem ? inoutList->iterIndex + 1 : 0;
}

void __glsIterListPrepend(__GLSiterList *inoutList, __GLSlistElem *inoutElem) {
    __glsListPrepend((__GLSlist *)&inoutList->head, inoutElem);
    ++inoutList->count;
    if (inoutList->iterElem) ++inoutList->iterIndex;
}

void __glsIterListPrev(__GLSiterList *inoutList) {
    __glsListPrev(
        (__GLSlist *)&inoutList->head, (__GLSlistIter *)&inoutList->iterElem
    );
    inoutList->iterIndex = inoutList->iterElem ? inoutList->iterIndex - 1 : 0;
}

void __glsIterListRemove(__GLSiterList *inoutList, __GLSlistElem *inoutElem) {
    __glsListRemove((__GLSlist *)&inoutList->head, inoutElem);
    inoutList->iterElem = GLS_NONE;
    --inoutList->count;
    inoutList->iterIndex = 0;
}

void __glsIterListRemoveDestroy(
    __GLSiterList *inoutList,
    __GLSlistElem *inElem,
    __GLSlistElemDestructor inDestructor
) {
    __glsListRemoveDestroy(
        (__GLSlist *)&inoutList->head, inElem, inDestructor
    );
    inoutList->iterElem = GLS_NONE;
    --inoutList->count;
    inoutList->iterIndex = 0;
}

void __glsIterListSeek(__GLSiterList *inoutList, size_t inIndex) {
    if (inIndex < inoutList->count) {
        if (!inoutList->iterElem) inoutList->iterElem = inoutList->head;
        while (inoutList->iterIndex < inIndex) __glsIterListNext(inoutList);
        while (inoutList->iterIndex > inIndex) __glsIterListPrev(inoutList);
    }
}

/******************************************************************************
Memory
******************************************************************************/

GLvoid* __glsCalloc(size_t inCount, size_t inSize) {
    GLvoid *outAddr;

    if (!inCount) inCount = 1;
    if (!inSize) inSize = 1;
    outAddr = calloc(inCount, inSize);
    if (!outAddr) __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
    return outAddr;
}

GLvoid* __glsMalloc(size_t inSize) {
    GLvoid *outAddr;
    
    if (!inSize) inSize = 1;
    outAddr = malloc(inSize);
    if (!outAddr) __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
    return outAddr;
}

/******************************************************************************
Nop
******************************************************************************/

void __glsNop(void) {}

/******************************************************************************
Number
******************************************************************************/

const GLubyte __glsBitReverse[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

const GLubyte __glsQuietNaN[8] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

size_t __glsCeilBase2(size_t inVal) {
    const size_t outVal = 1 << __glsLogBase2(inVal);

    return outVal < inVal ? outVal << 1 : outVal;
}

size_t __glsLogBase2(size_t inVal) {
    size_t outLog = 0;

    while (inVal >>= 1) ++outLog;
    return outLog;
}

GLulong __glsPtrToULong(const GLvoid *inPtr) {
    #if __GLS_INT64
        return (GLulong)(SIZE_T)inPtr;
    #else /* !__GLS_INT64 */
        return glsULong(0, (GLuint)inPtr);
    #endif /* __GLS_INT64 */
}

GLlong __glsSizeToLong(size_t inSize) {
    #if __GLS_INT64
        return (GLlong)inSize;
    #else /* !__GLS_INT64 */
        if (sizeof(GLuint) >= sizeof(size_t)) {
            return glsLong(0, inSize);
        } else {
            return glsLong(inSize >> 32, inSize & 0xffffffff);
        }
    #endif /* __GLS_INT64 */
}

void __glsSwap2(GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP2(inoutVec);
}

void __glsSwap2v(size_t inCount, GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;
    GLubyte *ptr = (GLubyte *)inoutVec;

    while (inCount--) {
        __GLS_SWAP2(ptr);
        ptr += 2;
    }
}

void __glsSwap4(GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP4(inoutVec);
}

void __glsSwap4v(size_t inCount, GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;
    GLubyte *ptr = (GLubyte *)inoutVec;

    while (inCount--) {
        __GLS_SWAP4(ptr);
        ptr += 4;
    }
}

void __glsSwap8(GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP8(inoutVec);
}

void __glsSwap8v(size_t inCount, GLvoid *inoutVec) {
    __GLS_SWAP_DECLARE;
    GLubyte *ptr = (GLubyte *)inoutVec;

    while (inCount-- > 0) {
        __GLS_SWAP8(ptr);
        ptr += 8;
    }
}

GLint __glsSwapi(GLint inVal) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP4(&inVal);
    return inVal;
}

GLshort __glsSwaps(GLshort inVal) {
    __GLS_SWAP_DECLARE;

    __GLS_SWAP2(&inVal);
    return inVal;
}

void __glsSwapv(GLenum inType, size_t inBytes, GLvoid *inoutVec) {
    switch (inType) {
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            __glsSwap4v(inBytes / 4, (GLubyte *)inoutVec);
            break;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            __glsSwap2v(inBytes / 2, (GLubyte *)inoutVec);
            break;
        #if __GL_EXT_vertex_array
            case GL_DOUBLE_EXT:
                __glsSwap8v(inBytes / 8, (GLubyte *)inoutVec);
                break;
        #endif /* __GL_EXT_vertex_array */
    }
}

/******************************************************************************
String
******************************************************************************/

static GLboolean __glsString_addRoom(
    __GLSstring *inoutString, size_t inCount
) {
    const size_t newSize = __glsCeilBase2(
        (size_t)((ULONG_PTR)(inoutString->bufTail - inoutString->head) + 1 + inCount)
    );
    GLubyte *buf = __glsMalloc(newSize);

    if (!buf) return GL_FALSE;
    strcpy((char *)buf, (const char *)inoutString->head);
    inoutString->tail = buf + (inoutString->tail - inoutString->head);
    if (inoutString->head != inoutString->buf) free(inoutString->head);
    inoutString->head = buf;
    inoutString->bufTail = buf + newSize - 1;
    return GL_TRUE;
}

GLboolean __glsString_append(
    __GLSstring *inoutString, const GLubyte* inAppend
) {
    const size_t count = strlen((const char *)inAppend);

    if (
        inoutString->tail + count > inoutString->bufTail &&
        !__glsString_addRoom(inoutString, count)
    ) {
        return GL_FALSE;
    }
    strcpy((char *)inoutString->tail, (const char *)inAppend);
    inoutString->tail += count;
    return GL_TRUE;
}

GLboolean __glsString_appendChar(
    __GLSstring *inoutString, GLubyte inAppend
) {
    *inoutString->tail++ = inAppend;
    if (inoutString->tail > inoutString->bufTail) {
        *--inoutString->tail = 0;
        if (!__glsString_addRoom(inoutString, 1)) return GL_FALSE;
        *inoutString->tail++ = inAppend;
    }
    *inoutString->tail = 0;
    return GL_TRUE;
}

GLboolean __glsString_appendCounted(
    __GLSstring *inoutString, const GLubyte* inAppend, size_t inCount
) {
    if (
        inoutString->tail + inCount > inoutString->bufTail &&
        !__glsString_addRoom(inoutString, inCount)
    ) {
        return GL_FALSE;
    }
    strncpy((char *)inoutString->tail, (const char *)inAppend, inCount);
    inoutString->tail += inCount;
    *inoutString->tail = 0;
    return GL_TRUE;
}

GLboolean __glsString_appendInt(
    __GLSstring *inoutString, const GLubyte* inFormat, GLint inVal
) {
    __GLSstringBuf buf;
    size_t count;
    
    if (sprintf((char *)buf, (const char *)inFormat, inVal) < 0) {
        fprintf(stderr, "GLS fatal: sprintf failed\n");
        exit(EXIT_FAILURE);
    }
    count = strlen((const char *)buf);
    if (
        inoutString->tail + count > inoutString->bufTail &&
        !__glsString_addRoom(inoutString, count)
    ) {
        return GL_FALSE;
    }
    strcpy((char *)inoutString->tail, (const char *)buf);
    inoutString->tail += count;
    return GL_TRUE;
}

GLboolean __glsString_assign(
    __GLSstring *inoutString, const GLubyte *inAssign
) {
    inoutString->tail = inoutString->head;
    return __glsString_append(inoutString, inAssign);
}

GLboolean __glsString_assignCounted(
    __GLSstring *inoutString, const GLubyte *inAssign, size_t inCount
) {
    inoutString->tail = inoutString->head;
    return __glsString_appendCounted(inoutString, inAssign, inCount);
}

void __glsString_final(__GLSstring *inoutString) {
    if (inoutString->head != inoutString->buf) {
        free(inoutString->head);
        inoutString->head = inoutString->buf;
    }
}

void __glsString_init(__GLSstring *outString) {
    outString->head = outString->tail = outString->buf;
    outString->bufTail = outString->buf + __GLS_STRING_BUF_BYTES - 1;
    outString->buf[0] = 0;
}

size_t __glsString_length(const __GLSstring *inString) {
    return (size_t)((ULONG_PTR)(inString->tail - inString->head));
}

void __glsString_reset(__GLSstring *inoutString) {
    __glsString_final(inoutString);
    __glsString_init(inoutString);
}

const GLubyte* __glsUCS1String(const GLubyte *inUTF8String) {
    GLuint b;
    const GLubyte *cp = inUTF8String;
    GLubyte *outVal, *p;

    while (b = *cp++) if (b & 0x80) break;
    if (!b) return inUTF8String;
    p = outVal = (GLubyte *)__glsMalloc(strlen((const char *)inUTF8String));
    if (!p) return GLS_NONE;
    while (*inUTF8String) {
        const GLint n = glsUTF8toUCS4(inUTF8String, &b);

        if (n && b <= 0xff) {
            inUTF8String += n;
            *p++ = (GLubyte)b;
        } else {
            free(outVal);
            if (!n) __GLS_RAISE_ERROR(GLS_INVALID_STRING);
            return GLS_NONE;
        }
    }
    *p = 0;
    return outVal;
}

GLboolean __glsValidateString(const GLubyte *inString) {
    if (!glsIsUTF8String(inString)) {
        __GLS_RAISE_ERROR(GLS_INVALID_STRING);
        return GL_FALSE;
    }
    return GL_TRUE;
}

/******************************************************************************
Vertex array
******************************************************************************/

void __glsGetArrayState(__GLScontext *ctx, __GLSarrayState *arrayState)
{
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glIsEnabled);
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetPointerv);

    arrayState->enabled = 0;

    if (glIsEnabled(GL_VERTEX_ARRAY))
    {
        arrayState->enabled |= __GLS_VERTEX_ARRAY_ENABLE;

        glGetIntegerv(GL_VERTEX_ARRAY_SIZE, &arrayState->vertex.size);
        glGetIntegerv(GL_VERTEX_ARRAY_TYPE, &arrayState->vertex.type);
        glGetIntegerv(GL_VERTEX_ARRAY_STRIDE, &arrayState->vertex.stride);
        glGetPointerv(GL_VERTEX_ARRAY_POINTER,
                      (GLvoid **)&arrayState->vertex.data);
    }
    
    if (glIsEnabled(GL_NORMAL_ARRAY))
    {
        arrayState->enabled |= __GLS_NORMAL_ARRAY_ENABLE;

        arrayState->normal.size = 3;
        glGetIntegerv(GL_NORMAL_ARRAY_TYPE, &arrayState->normal.type);
        glGetIntegerv(GL_NORMAL_ARRAY_STRIDE, &arrayState->normal.stride);
        glGetPointerv(GL_NORMAL_ARRAY_POINTER,
                      (GLvoid **)&arrayState->normal.data);
    }
    
    if (glIsEnabled(GL_COLOR_ARRAY))
    {
        arrayState->enabled |= __GLS_COLOR_ARRAY_ENABLE;

        glGetIntegerv(GL_COLOR_ARRAY_SIZE, &arrayState->color.size);
        glGetIntegerv(GL_COLOR_ARRAY_TYPE, &arrayState->color.type);
        glGetIntegerv(GL_COLOR_ARRAY_STRIDE, &arrayState->color.stride);
        glGetPointerv(GL_COLOR_ARRAY_POINTER,
                      (GLvoid **)&arrayState->color.data);
    }
    
    if (glIsEnabled(GL_INDEX_ARRAY))
    {
        arrayState->enabled |= __GLS_INDEX_ARRAY_ENABLE;

        arrayState->index.size = 1;
        glGetIntegerv(GL_INDEX_ARRAY_TYPE, &arrayState->index.type);
        glGetIntegerv(GL_INDEX_ARRAY_STRIDE, &arrayState->index.stride);
        glGetPointerv(GL_INDEX_ARRAY_POINTER,
                      (GLvoid **)&arrayState->index.data);
    }
    
    if (glIsEnabled(GL_TEXTURE_COORD_ARRAY))
    {
        arrayState->enabled |= __GLS_TEXTURE_COORD_ARRAY_ENABLE;

        glGetIntegerv(GL_TEXTURE_COORD_ARRAY_SIZE,
                      &arrayState->textureCoord.size);
        glGetIntegerv(GL_TEXTURE_COORD_ARRAY_TYPE,
                      &arrayState->textureCoord.type);
        glGetIntegerv(GL_TEXTURE_COORD_ARRAY_STRIDE,
                      &arrayState->textureCoord.stride);
        glGetPointerv(GL_TEXTURE_COORD_ARRAY_POINTER,
                      (GLvoid **)&arrayState->textureCoord.data);
    }
    
    if (glIsEnabled(GL_EDGE_FLAG_ARRAY))
    {
        arrayState->enabled |= __GLS_EDGE_FLAG_ARRAY_ENABLE;

        arrayState->edgeFlag.size = 1;
        arrayState->edgeFlag.type = __GLS_BOOLEAN;
        glGetIntegerv(GL_EDGE_FLAG_ARRAY_STRIDE, &arrayState->edgeFlag.stride);
        glGetPointerv(GL_EDGE_FLAG_ARRAY_POINTER,
                      (GLvoid **)&arrayState->edgeFlag.data);
    }
    
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glIsEnabled);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetIntegerv);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetPointerv);
}

GLint __glsArrayDataSize(GLsizei count, __GLSarrayState *arrayState)
{
    GLint size;
    GLint i;
    __GLSsingleArrayState *array;
    GLuint arrayBit;

    /* Start with space for the data size, count and enables */
    size = 12;

    /* Every array stores its size and type fields even
       for the cases where size and type are fixed.  This
       allows one piece of code to handle any array */

    array = &arrayState->vertex;
    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (arrayState->enabled & arrayBit)
        {
            size += 8 + __GLS_ARRAY_SIZE(count, array->size, array->type);
        }

        array++;
        arrayBit <<= 1;
    }

    return size;
}

typedef struct _DeHashEntry
{
    GLuint original;
    struct _DeHashEntry *next;
} DeHashEntry;

typedef GLubyte DeHashIndex;
#define DE_HASH_SIZE    256
#define DE_HASH(ui)     ((DeHashIndex)(ui))

GLint __glsDrawElementsDataSize(GLsizei count, GLenum type,
                                const GLvoid *indices,
                                __GLSarrayState *arrayState,
                                __GLSdrawElementsState *deState)
{
    GLubyte *allData;
    DeHashEntry *hashTable[DE_HASH_SIZE];
    GLint vtxCount;
    GLint i;
    GLubyte *idxData;
    GLuint idx;
    DeHashEntry *hashEntries;
    GLuint *outIndices;
    DeHashEntry *ent;
    DeHashIndex hash;
    
    // Determine the set of unique vertex indices by hashing
    // all the input indices and checking for duplicates
    // There can't be more unique indices than input indices
    // so count is an upper bound for our allocations
    
    allData = __glsMalloc(count * (sizeof(GLuint)+sizeof(DeHashEntry)));
    if (allData == NULL)
    {
        return -1;
    }

    deState->freePtr = allData;
    outIndices = (GLuint *)allData;
    deState->indices = outIndices;
    hashEntries = (DeHashEntry *)(outIndices+count);

    memset(hashTable, 0, DE_HASH_SIZE*sizeof(DeHashEntry *));

    vtxCount = 0;
    idxData = (GLubyte *)indices;

    for (i = 0; i < count; i++)
    {
        // Get incoming index
        switch(type)
        {
        case GL_UNSIGNED_BYTE:
            idx = *idxData++;
            break;
        case GL_UNSIGNED_SHORT:
            idx = *(GLushort *)idxData;
            idxData += sizeof(GLushort);
            break;
        case GL_UNSIGNED_INT:
            idx = *(GLuint *)idxData;
            idxData += sizeof(GLuint);
            break;
        }
        
        // Look for a matching index in the hash table
        hash = DE_HASH(idx);
        ent = hashTable[hash];
        while (ent != NULL && ent->original != idx)
        {
            ent = ent->next;
        }

        // If we didn't find a match, add a new vertex
        // reference
        if (ent == NULL)
        {
            ent = &hashEntries[vtxCount++];
            ent->original = idx;
            ent->next = hashTable[hash];
            hashTable[hash] = ent;
        }

        // Create index into unique vertex set
        *outIndices++ = (GLuint)((ULONG_PTR)(ent-hashEntries));
    }

    // Overwrite hash entries with just the vertex mappings for return
    outIndices = (GLuint *)hashEntries;
    deState->vertices = outIndices;
    deState->vtxCount = vtxCount;

    for (i = 0; i < vtxCount; i++)
    {
        *outIndices++ = hashEntries->original;
        hashEntries++;
    }

    // Return the combined size of the unique vertex data and
    // the new element indices
    return __glsArrayDataSize(vtxCount, arrayState) + count*sizeof(GLuint);
}

void __glsWriteArrayValues(__GLSwriter *writer, GLint first,
                           GLsizei count, __GLSsingleArrayState *array)
{
    GLint elStep;
    const GLvoid *data;

    if (array->stride > 0)
    {
        elStep = array->stride;
    }
    else
    {
        elStep = array->size * __glsTypeSize(array->type);
    }
    data = (const GLvoid *)((GLubyte *)array->data + first*elStep);
    
    __glsWriter_putVertexv(writer, array->size, array->type, array->stride,
                           count, data);
}

// This routine must be called with an odd writer alignment
void __glsWriteArrayData(__GLSwriter *writer, GLint size,
                         GLint first, GLsizei count,
                         GLenum type, const GLvoid *indices,
                         __GLSarrayState *arrayState)
{
    GLint i, el;
    __GLSsingleArrayState *array;
    GLuint arrayBit;
    GLubyte *ubIndices;
    GLushort *usIndices;
    GLuint *uiIndices;

    writer->putGLint(writer, size);
    writer->putGLint(writer, count);
    writer->putGLuint(writer, arrayState->enabled);

    array = &arrayState->vertex;
    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (arrayState->enabled & arrayBit)
        {
            writer->putGLint(writer, array->size);
            writer->putGLint(writer, array->type);

            if (indices != NULL)
            {
                switch(type)
                {
                case GL_UNSIGNED_BYTE:
                    ubIndices = (GLubyte *)indices;
                    for (el = 0; el < count; el++)
                    {
                        __glsWriteArrayValues(writer, ubIndices[el], 1, array);
                    }
                    break;
                case GL_UNSIGNED_SHORT:
                    usIndices = (GLshort *)indices;
                    for (el = 0; el < count; el++)
                    {
                        __glsWriteArrayValues(writer, usIndices[el], 1, array);
                    }
                    break;
                case GL_UNSIGNED_INT:
                    uiIndices = (GLuint *)indices;
                    for (el = 0; el < count; el++)
                    {
                        __glsWriteArrayValues(writer, uiIndices[el], 1, array);
                    }
                    break;
                }
            }
            else
            {
                __glsWriteArrayValues(writer, first, count, array);
            }

            // Pad data out to an eight-byte boundary
            if (writer->type != GLS_TEXT)
            {
                GLint pad;
                double padValue = 0.0;
        
                pad = 8 - (__GLS_EXACT_ARRAY_SIZE(count, array->size,
                                                  array->type) & 7);
                if (pad < 8)
                {
                    writer->putGLubytev(writer, pad,
                                        (const GLubyte *)&padValue);
                }
            }
        }

        array++;
        arrayBit <<= 1;
    }
}

// This routine must be called with an odd writer alignment
void __glsWriteDrawElementsData(__GLSwriter *writer, GLint size,
                                GLsizei count, __GLSarrayState *arrayState,
                                __GLSdrawElementsState *deState)
{
    __glsWriteArrayData(writer, size, 0, deState->vtxCount, GL_UNSIGNED_INT,
                        deState->vertices, arrayState);
    writer->putGLuintv(writer, count, deState->indices);
    free(deState->freePtr);
}

typedef void (*__GLSdispatchVertexPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchColorPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchEdgeFlagPointer)(GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchIndexPointer)(GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchNormalPointer)(GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (*__GLSdispatchTexCoordPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);

void __glsSetArrayState(__GLScontext *ctx, GLubyte *data)
{
    GLsizei count;
    GLuint enabled;

    count = *(GLsizei *)(data+4);
    enabled = *(GLuint *)(data+8);
    data += 12;

    // Enable/DisableClientState produce their own records so
    // the current enable state should be correct
    
    if (enabled & __GLS_VERTEX_ARRAY_ENABLE)
    {
        ((__GLSdispatchVertexPointer)ctx->dispatchCall[385])
            (*(GLint *)(data+0),
             *(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, *(GLint *)(data+0),
                                     *(GLenum *)(data+4));
    }
    if (enabled & __GLS_NORMAL_ARRAY_ENABLE)
    {
        ((__GLSdispatchNormalPointer)ctx->dispatchCall[382])
            (*(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, 3, *(GLenum *)(data+4));
    }
    if (enabled & __GLS_COLOR_ARRAY_ENABLE)
    {
        ((__GLSdispatchColorPointer)ctx->dispatchCall[372])
            (*(GLint *)(data+0),
             *(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, *(GLint *)(data+0),
                                     *(GLenum *)(data+4));
    }
    if (enabled & __GLS_INDEX_ARRAY_ENABLE)
    {
        ((__GLSdispatchIndexPointer)ctx->dispatchCall[378])
            (*(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, 1, *(GLenum *)(data+4));
    }
    if (enabled & __GLS_TEXTURE_COORD_ARRAY_ENABLE)
    {
        ((__GLSdispatchTexCoordPointer)ctx->dispatchCall[384])
            (*(GLint *)(data+0),
             *(GLenum *)(data+4),
             0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, *(GLint *)(data+0),
                                     *(GLenum *)(data+4));
    }
    if (enabled & __GLS_EDGE_FLAG_ARRAY_ENABLE)
    {
        ((__GLSdispatchEdgeFlagPointer)ctx->dispatchCall[376])
            (0,
             data+8);
        data += 8 + __GLS_ARRAY_SIZE(count, 1, __GLS_BOOLEAN);
    }
}

GLvoid *__glsSetArrayStateText(__GLScontext *ctx, __GLSreader *reader,
                               GLuint *enabled, GLsizei *count)
{
    GLint size;
    GLubyte *ptr;
    int i;
    GLuint arrayBit;
    GLvoid *data = GLS_NONE;
        
    __glsReader_getGLint_text(reader, &size);
    __glsReader_getGLint_text(reader, count);
    __glsReader_getGLuint_text(reader, enabled);

    data = __glsMalloc(size);
    if (!data) goto end;

    ptr = (GLubyte *)data;
    *(GLint *)(ptr+0) = size;
    *(GLsizei *)(ptr+4) = *count;
    *(GLuint *)(ptr+8) = *enabled;
    ptr += 12;

    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (*enabled & arrayBit)
        {
            __glsReader_getGLint_text(reader, (GLint *)(ptr+0));
            __glsReader_getGLenum_text(reader, (GLenum *)(ptr+4));
            
            size = __GLS_EXACT_ARRAY_SIZE(*count, *(GLint *)(ptr+0),
                                          *(GLenum *)(ptr+4));
            __glsReader_getGLcompv_text(reader, *(GLenum *)(ptr+4),
                                        size, ptr+8);
            
            ptr += 8 + __GLS_PAD_EIGHT(size);
        }

        arrayBit <<= 1;
    }
    
    if (reader->error)
    {
        free(data);
        data = NULL;
        goto end;
    }
    
    __glsSetArrayState(ctx, data);

end:
    return data;
}

void __glsDisableArrayState(__GLScontext *ctx, GLuint enabled)
{
    // Doesn't currently need to do anything because
    // enable/disable are handled by their own records
}

void __glsSwapArrayData(GLubyte *data)
{
    int i;
    GLuint arrayBit;
    GLsizei count;
    GLuint enabled;
    GLint size;
    
    __glsSwap4(data+0);
    __glsSwap4(data+4);
    count = *(GLsizei *)(data+4);
    __glsSwap4(data+8);
    enabled = *(GLuint *)(data+8);
    data += 12;
    
    arrayBit = __GLS_VERTEX_ARRAY_ENABLE;
    for (i = 0; i < __GLS_ARRAY_COUNT; i++)
    {
        if (enabled & arrayBit)
        {
            __glsSwap4(data+0);
            __glsSwap4(data+4);
            
            size = __GLS_EXACT_ARRAY_SIZE(count, *(GLint *)(data+0),
                                          *(GLenum *)(data+4));
            __glsSwapv(*(GLenum *)(data+4), size, data+8);

            data += 8 + __GLS_PAD_EIGHT(size);
        }

        arrayBit <<= 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\global.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <string.h>
#include <time.h>

static GLuint __glsContextCount = 0;
static GLuint __glsNextContext = 1;

typedef struct {
    GLuint mask1;
    GLuint val1;
    GLuint shift;
    GLuint mask4;
    GLuint val4;
} __GLSutf8format;

static const __GLSutf8format __glsUTF8formats[] = {
    {0x80, 0x00, 0,  0x0000007f, 0x00000000,},
    {0xe0, 0xc0, 6,  0x000007ff, 0x00000080,},
    {0xf0, 0xe0, 12, 0x0000ffff, 0x00000800,},
    {0xf8, 0xf0, 18, 0x001fffff, 0x00010000,},
    {0xfc, 0xf8, 24, 0x03ffffff, 0x00200000,},
    {0xfe, 0xfc, 30, 0x7fffffff, 0x04000000,},
    {0x00, 0x00, 0,  0x00000000, 0x00000000,},
};

GLSenum glsBinary(GLboolean inSwapped) {
    return inSwapped ? __GLS_BINARY_SWAP1 : __GLS_BINARY_SWAP0;
}

GLSenum glsCommandAPI(GLSopcode inOpcode) {
    const GLSenum outVal = __glsOpcodeAPI(inOpcode);

    if (!outVal) __GLS_RAISE_ERROR(GLS_UNSUPPORTED_COMMAND);
    return outVal;
}

const GLubyte* glsCommandString(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return __glsOpcodeString[__glsMapOpcode(inOpcode)];
}

void glsContext(GLuint inContext) {
    __GLScontext *ctx = __GLS_CONTEXT;
    __GLScontext *newCtx;

    if (ctx && (ctx->callNesting || ctx->captureEntryCount)) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return;
    }
    if (inContext) {
        __glsBeginCriticalSection();
        if (
            newCtx = (__GLScontext *)__glsInt2PtrDict_find(
                    __glsContextDict, (GLint)inContext
            )
        ) {
            if (newCtx == ctx) {
                newCtx = GLS_NONE;
            } else {
                if (newCtx->current) {
                    __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                    newCtx = GLS_NONE;
                } else {
                    newCtx->current = GL_TRUE;
                    if (ctx)
                    {
                        if (ctx->deleted)
                        {
                            __glsContext_destroy(ctx);
                        }
                        else
                        {
                            ctx->current = GL_FALSE;
                        }
                    }
                }
            }
        } else {
            __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        }
        __glsEndCriticalSection();
        if (newCtx) {
            __GLS_PUT_CONTEXT(newCtx);
            __glsUpdateDispatchTables();
        }
    } else if (ctx) {
        __glsBeginCriticalSection();
        if (ctx->deleted) {
            __glsContext_destroy(ctx);
        } else {
            ctx->current = GL_FALSE;
        }
        __glsEndCriticalSection();
        __GLS_PUT_CONTEXT(GLS_NONE);
        __glsUpdateDispatchTables();
    }
}

void glsDeleteContext(GLuint inContext) {
    if (inContext) {
        __GLScontext *ctx;

        __glsBeginCriticalSection();
        if (
            ctx = (__GLScontext *)__glsInt2PtrDict_find(
                __glsContextDict, (GLint)inContext
            )
        ) {
            __glsIntDict_remove(__glsContextDict, (GLint)inContext);
            __GLS_LIST_REMOVE(&__glsContextList, ctx);
            --__glsContextCount;
            if (ctx->current) {
                ctx->deleted = GL_TRUE;
            } else {
                __glsContext_destroy(ctx);
            }
        } else {
            __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        }
        __glsEndCriticalSection();
    } else {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
    }
}

const GLubyte* glsEnumString(GLSenum inAPI, GLSenum inEnum) {
    GLint offset, page;

    switch (inAPI) {
        case GLS_API_GLS:
            page = __GLS_ENUM_PAGE(inEnum);
            offset = __GLS_ENUM_OFFSET(inEnum);
            if (
                page < __GLS_ENUM_PAGE_COUNT &&
                offset < __glsEnumStringCount[page] &&
                __glsEnumString[page][offset]
            ) {
                return __glsEnumString[page][offset];
            }
            break;
        case GLS_API_GL:
            page = __GL_ENUM_PAGE(inEnum);
            offset = __GL_ENUM_OFFSET(inEnum);
            if (
                page < __GL_ENUM_PAGE_COUNT &&
                offset < __glEnumStringCount[page] &&
                __glEnumString[page][offset]
            ) {
                return __glEnumString[page][offset];
            }
            break;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

GLuint glsGenContext(void) {
    GLboolean added = GL_FALSE;
    __GLScontext *ctx;
    GLuint name;

    __glsBeginCriticalSection();
    name = __glsNextContext;
    if (
        (ctx = __glsContext_create(name)) &&
        (added = __glsInt2PtrDict_add(__glsContextDict, (GLint)name, ctx))
    ) {
        ++__glsContextCount;
        ++__glsNextContext;
        __GLS_LIST_APPEND(&__glsContextList, ctx);
    }
    __glsEndCriticalSection();
    if (added) {
        return name;
    } else {
        __glsContext_destroy(ctx);
        return 0;
    }
}

GLuint* glsGetAllContexts(void) {
    GLuint *buf = GLS_NONE;
    GLint i = 0;

    __glsBeginCriticalSection();
    if (buf = __glsMalloc((__glsContextCount + 1) * sizeof(GLuint))) {
        __GLS_LIST_ITER(__GLScontext) iter;

        __GLS_LIST_FIRST(&__glsContextList, &iter);
        while (iter.elem) {
            buf[i++] = iter.elem->name;
            __GLS_LIST_NEXT(&__glsContextList, &iter);
        }
        buf[i] = 0;
    }
    __glsEndCriticalSection();
    return buf;
}

GLScommandAlignment* glsGetCommandAlignment(
    GLSopcode inOpcode,
    GLSenum inExternStreamType,
    GLScommandAlignment *outAlignment
) {
    GLbitfield attrib;

    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    attrib = __glsOpcodeAttrib[__glsMapOpcode(inOpcode)];
    switch (inExternStreamType) {
        case GLS_BINARY_LSB_FIRST:
        case GLS_BINARY_MSB_FIRST:
            if (attrib & __GLS_COMMAND_ALIGN_EVEN32_BIT) {
                outAlignment->mask = 7;
                outAlignment->value = 0;
            } else if (attrib & __GLS_COMMAND_ALIGN_ODD32_BIT) {
                outAlignment->mask = 7;
                outAlignment->value = 4;
            } else {
                outAlignment->mask = 3;
                outAlignment->value = 0;
            }
            break;
        case GLS_TEXT:
            outAlignment->mask = 0;
            outAlignment->value = 0;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return outAlignment;
}

GLbitfield glsGetCommandAttrib(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return (
        __glsOpcodeAttrib[__glsMapOpcode(inOpcode)] &
        __GLS_COMMAND_ATTRIB_MASK
    );
}

GLint glsGetConsti(GLSenum inAttrib) {
    switch (inAttrib) {
        case GLS_API_COUNT:
            return __GLS_API_COUNT;
        case GLS_MAX_CALL_NESTING:
            return __GLS_MAX_CALL_NESTING;
        case GLS_MAX_CAPTURE_NESTING:
            return __GLS_MAX_CAPTURE_NESTING;
        case GLS_VERSION_MAJOR:
            return __GLS_VERSION_MAJOR;
        case GLS_VERSION_MINOR:
            return __GLS_VERSION_MINOR;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

const GLint* glsGetConstiv(GLSenum inAttrib) {
    switch (inAttrib) {
        case GLS_ALL_APIS:
            return (const GLint *)__glsAllAPIs;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

const GLubyte* glsGetConstubz(GLSenum inAttrib) {
    switch (inAttrib) {
        case GLS_EXTENSIONS:
            return __glsExtensions;
        case GLS_PLATFORM:
            return glsCSTR(__GLS_PLATFORM);
        case GLS_RELEASE:
            return glsCSTR(__GLS_RELEASE);
        case GLS_VENDOR:
            return glsCSTR(__GLS_VENDOR);
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

GLuint glsGetCurrentContext(void) {
    return __GLS_CONTEXT ? __GLS_CONTEXT->name : 0;
}

GLint* glsGetCurrentTime(GLint *outTime) {
    GLint i;
    const time_t t = time(GLS_NONE);
    struct tm utc, *utcp;

    __glsBeginCriticalSection();
    if (utcp = gmtime(&t)) utc = *utcp;
    __glsEndCriticalSection();
    if (t != (time_t)-1 && utcp) {
        outTime[0] = 1900 + utc.tm_year;
        outTime[1] = 1 + utc.tm_mon;
        outTime[2] = utc.tm_mday;
        outTime[3] = utc.tm_hour;
        outTime[4] = utc.tm_min;
        outTime[5] = utc.tm_sec;
        return outTime;
    }
    for (i = 0 ; i < 6 ; ++i) outTime[i] = 0;
    return GLS_NONE;
}

GLSenum glsGetError(GLboolean inClear) {
    const GLSenum outError = __GLS_ERROR;

    if (inClear) __GLS_PUT_ERROR(GLS_NONE);
    return outError;
}

GLint glsGetOpcodeCount(GLSenum inAPI) {
    switch (inAPI) {
        case GLS_API_GLS:
            return __glsOpcodesGLSCount;
        case GLS_API_GL:
            return __glsOpcodesGLCount;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

const GLSopcode* glsGetOpcodes(GLSenum inAPI) {
    switch (inAPI) {
        case GLS_API_GLS:
            return __glsOpcodesGLS;
        case GLS_API_GL:
            return __glsOpcodesGL;
    }
    __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    return GLS_NONE;
}

GLboolean glsIsContext(GLuint inContext) {
    __GLScontext *ctx;

    __glsBeginCriticalSection();
    ctx = (__GLScontext *)__glsInt2PtrDict_find(
        __glsContextDict, (GLint)inContext
    );
    __glsEndCriticalSection();
    return (GLboolean)(ctx != GLS_NONE);
}

static GLboolean __glsFindExtension(
    const GLubyte *inExtension, const GLubyte *inList
) {
    const GLubyte *p0 = inList;
    
    while (
        p0 =
        (const GLubyte *)strstr((const char *)p0, (const char *)inExtension)
    ) {
        const GLubyte *const p1 = p0 + strlen((const char *)inExtension);

        if (!*p1 || *p1 == ' ') return GL_TRUE;
        p0 = p1;
    }
    return GL_FALSE;
}

GLboolean glsIsExtensionSupported(const GLubyte *inExtension) {
    if (!__glsValidateString(inExtension)) return GL_FALSE;
    if (!__glsFindExtension(inExtension, __glsExtensions)) return GL_FALSE;
    if (!strncmp((const char *)inExtension, "GL_", 3)) {
        const GLubyte *const p = glGetString(GL_EXTENSIONS);

        if (!p || !__glsFindExtension(inExtension, p)) return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean glsIsUTF8String(const GLubyte *inString) {
    GLuint b;

    while (b = *inString) {
        if (b & 0x80) goto slowPath;
        ++inString;
    }
    return GL_TRUE;
slowPath:
    while (*inString) {
        const GLint n = glsUTF8toUCS4(inString, &b);

        if (!n) return GL_FALSE;
        inString += n;
    }
    return GL_TRUE;
}

GLlong glsLong(GLint inHigh, GLuint inLow) {
    #if __GLS_INT64
        return ((GLlong)inHigh) << 32 | inLow;
    #elif __GLS_MSB_FIRST
        GLlong outVal;

        outVal.uint0 = inHigh;
        outVal.uint1 = inLow;
        return outVal;
    #else /* !__GLS_MSB_FIRST */
        GLlong outVal;

        outVal.uint0 = inLow;
        outVal.uint1 = inHigh;
        return outVal;
    #endif /* __GLS_INT64 */
}

GLint glsLongHigh(GLlong inVal) {
    #if __GLS_INT64
        return (GLint)(inVal >> 32 & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint0;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint1;
    #endif /* __GLS_INT64 */
}

GLuint glsLongLow(GLlong inVal) {
    #if __GLS_INT64
        return (GLuint)(inVal & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint1;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint0;
    #endif /* __GLS_INT64 */
}

void glsPixelSetup(void) {
    __glsPixelSetup_pack();
    __glsPixelSetup_unpack();
}

GLulong glsULong(GLuint inHigh, GLuint inLow) {
    #if __GLS_INT64
        return ((GLulong)inHigh) << 32 | inLow;
    #elif __GLS_MSB_FIRST
        GLulong outVal;

        outVal.uint0 = inHigh;
        outVal.uint1 = inLow;
        return outVal;
    #else /* !__GLS_MSB_FIRST */
        GLulong outVal;

        outVal.uint0 = inLow;
        outVal.uint1 = inHigh;
        return outVal;
    #endif /* __GLS_INT64 */
}

GLuint glsULongHigh(GLulong inVal) {
    #if __GLS_INT64
        return (GLuint)(inVal >> 32 & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint0;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint1;
    #endif /* __GLS_INT64 */
}

GLuint glsULongLow(GLulong inVal) {
    #if __GLS_INT64
        return (GLuint)(inVal & 0xffffffff);
    #elif __GLS_MSB_FIRST
        return inVal.uint1;
    #else /* !__GLS_MSB_FIRST */
        return inVal.uint0;
    #endif /* __GLS_INT64 */
}

GLint glsUCS4toUTF8(GLuint inUCS4, GLubyte *outUTF8) {
    const __GLSutf8format *format;
    GLint outVal = 1;

    for (format = __glsUTF8formats ; format->mask1 ; ++format, ++outVal) {
        if (inUCS4 <= format->mask4) {
            GLuint shift = format->shift;

            *outUTF8++ = (GLubyte)(format->val1 | (inUCS4 >> shift));
            while (shift) {
                shift -= 6;
                *outUTF8++ = (GLubyte)(0x80 | ((inUCS4 >> shift) & 0x3f));
            }
            return outVal;
        }
    }
    return 0;
}

GLubyte* glsUCStoUTF8z(
    size_t inUCSbytes,
    const GLvoid *inUCSz,
    size_t inUTF8max,
    GLubyte *outUTF8z
) {
    switch (inUCSbytes) {
        case 1:
            return glsUCS1toUTF8z(
                (const GLubyte *)inUCSz, inUTF8max, outUTF8z
            );
        case 2:
            return glsUCS2toUTF8z(
                (const GLushort *)inUCSz, inUTF8max, outUTF8z
            );
        case 4:
            return glsUCS4toUTF8z(
                (const GLuint *)inUCSz, inUTF8max, outUTF8z
            );
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            return GLS_NONE;
    }
}

GLubyte* glsUCS1toUTF8z(
    const GLubyte *inUCS1z, size_t inUTF8max, GLubyte *outUTF8z
) {
    GLuint b;
    GLubyte *const limit = outUTF8z + inUTF8max - 1;
    GLubyte *p = outUTF8z;

    while (b = *inUCS1z++) {
        if (p >= limit) return GLS_NONE;
        p += glsUCS4toUTF8(b, p);
    }
    if (p > limit) return GLS_NONE;
    *p = 0;
    return outUTF8z;
}

GLubyte* glsUCS2toUTF8z(
    const GLushort *inUCS2z, size_t inUTF8max, GLubyte *outUTF8z
) {
    GLuint b;
    GLubyte buf[3];
    GLubyte *const limit = outUTF8z + inUTF8max - 1;
    GLubyte *p = outUTF8z;

    while (b = *inUCS2z++) {
        GLubyte *bufPtr = buf;
        GLubyte *p0 = p;

        p += glsUCS4toUTF8(b, bufPtr);
        if (p > limit) return GLS_NONE;
        while (p0 < p) *p0++ = *bufPtr++;
    }
    *p = 0;
    return outUTF8z;
}

GLubyte* glsUCS4toUTF8z(
    const GLuint *inUCS4z, size_t inUTF8max, GLubyte *outUTF8z
) {
    GLuint b;
    GLubyte buf[6];
    GLubyte *const limit = outUTF8z + inUTF8max - 1;
    GLubyte *p = outUTF8z;

    while (b = *inUCS4z++) {
        GLubyte *bufPtr = buf;
        GLubyte *p0 = p;

        p += glsUCS4toUTF8(b, bufPtr);
        if (p > limit) return GLS_NONE;
        while (p0 < p) *p0++ = *bufPtr++;
    }
    *p = 0;
    return outUTF8z;
}

GLint glsUTF8toUCS4(const GLubyte *inUTF8, GLuint *outUCS4) {
    GLuint b, b0, ucs4;
    const __GLSutf8format *format;
    GLint outVal = 1;
  
    ucs4 = b0 = *inUTF8++;
    for (format = __glsUTF8formats ; format->mask1 ; ++format, ++outVal) {
        if ((b0 & format->mask1) == format->val1) {
            ucs4 &= format->mask4;
            if (ucs4 < format->val4) return 0;
            *outUCS4 = ucs4;
            return outVal;
        }
        b = *inUTF8++ ^ 0x80;
        if (b & 0xc0) return 0;
        ucs4 = (ucs4 << 6) | b;
    }
    return 0;
}

GLboolean glsUTF8toUCSz(
    size_t inUCSbytes,
    const GLubyte *inUTF8z,
    size_t inUCSmax,
    GLvoid *outUCSz
) {
    switch (inUCSbytes) {
        case 1:
            return glsUTF8toUCS1z(inUTF8z, inUCSmax, (GLubyte *)outUCSz);
        case 2:
            return glsUTF8toUCS2z(inUTF8z, inUCSmax, (GLushort *)outUCSz);
        case 4:
            return glsUTF8toUCS4z(inUTF8z, inUCSmax, (GLuint *)outUCSz);
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
            return GL_FALSE;
    }
}

GLboolean glsUTF8toUCS1z(
    const GLubyte *inUTF8z, size_t inUCS1max, GLubyte *outUCS1z
) {
    GLuint b;
    GLubyte *const limit = outUCS1z + inUCS1max - 1;

    while (*inUTF8z) {
        const GLint n = glsUTF8toUCS4(inUTF8z, &b);

        if (n && b <= 0xff && outUCS1z < limit) {
            inUTF8z += n;
            *outUCS1z++ = (GLubyte)b;
        } else {
            return GL_FALSE;
        }
    }
    if (outUCS1z > limit) return GL_FALSE;
    *outUCS1z = 0;
    return GL_TRUE;
}

GLboolean glsUTF8toUCS2z(
    const GLubyte *inUTF8z, size_t inUCS2max, GLushort *outUCS2z
) {
    GLuint b;
    GLushort *const limit = outUCS2z + inUCS2max - 1;

    while (*inUTF8z) {
        const GLint n = glsUTF8toUCS4(inUTF8z, &b);

        if (n && b <= 0xffff && outUCS2z < limit) {
            inUTF8z += n;
            *outUCS2z++ = (GLushort)b;
        } else {
            return GL_FALSE;
        }
    }
    if (outUCS2z > limit) return GL_FALSE;
    *outUCS2z = 0;
    return GL_TRUE;
}

GLboolean glsUTF8toUCS4z(
    const GLubyte *inUTF8z, size_t inUCS4max, GLuint *outUCS4z
) {
    GLuint b;
    GLuint *const limit = outUCS4z + inUCS4max - 1;

    while (*inUTF8z) {
        const GLint n = glsUTF8toUCS4(inUTF8z, &b);

        if (n && outUCS4z < limit) {
            inUTF8z += n;
            *outUCS4z++ = b;
        } else {
            return GL_FALSE;
        }
    }
    if (outUCS4z > limit) return GL_FALSE;
    *outUCS4z = 0;
    return GL_TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_decbin.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

// DrewB - All functions changed to use passed in context
// DrewB - Added optimized vector functions missing in original
// DrewB - Removed size externs

void __gls_decode_bin_glsBeginGLS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[16])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsBlock(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum);
    ((__GLSdispatch)ctx->dispatchCall[17])(
        *(GLSenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsError(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);
    ((__GLSdispatch)ctx->dispatchCall[20])(
        *(GLSopcode *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsGLRC(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[21])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsGLRCLayer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[22])(
        *(GLuint *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderGLRCi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[23])(
        *(GLuint *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderLayerf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[24])(
        *(GLuint *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderLayeri(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[25])(
        *(GLuint *)(inoutPtr + 0),
        *(GLSenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsHeaderf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[26])(
        *(GLSenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[27])(
        *(GLSenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[28])(
        *(GLSenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[29])(
        *(GLSenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsHeaderubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLSenum, const GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[30])(
        *(GLSenum *)(inoutPtr + 0),
        (GLubyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsAppRef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLulong, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[33])(
        *(GLulong *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glsCharubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, const GLubyte *);
    GLint inTag_count;
    inTag_count = (GLint)strlen((const char *)(inoutPtr + 0)) + 1;
    ((__GLSdispatch)ctx->dispatchCall[35])(
        (GLubyte *)(inoutPtr + 0),
        (GLubyte *)(inoutPtr + 0 + inTag_count)
    );
}

void __gls_decode_bin_glsDisplayMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLuint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[37])(
        *(GLuint *)(inoutPtr + 4),
        *(GLSenum *)(inoutPtr + 8),
        *(GLuint *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glsNumb(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[39])(
        (GLubyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumbv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLbyte *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[40])(
        (GLubyte *)(inoutPtr + 4 + 1 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLbyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[41])(
        (GLubyte *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLdouble *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[42])(
        (GLubyte *)(inoutPtr + 4 + 8 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLdouble *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[43])(
        (GLubyte *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLfloat *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[44])(
        (GLubyte *)(inoutPtr + 4 + 4 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLint);
    ((__GLSdispatch)ctx->dispatchCall[45])(
        (GLubyte *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLint *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[46])(
        (GLubyte *)(inoutPtr + 4 + 4 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNuml(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLlong);
    ((__GLSdispatch)ctx->dispatchCall[47])(
        (GLubyte *)(inoutPtr + 8),
        *(GLlong *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumlv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLlong *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[48])(
        (GLubyte *)(inoutPtr + 4 + 8 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLlong *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNums(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[49])(
        (GLubyte *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLshort *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[50])(
        (GLubyte *)(inoutPtr + 4 + 2 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLubyte);
    ((__GLSdispatch)ctx->dispatchCall[51])(
        (GLubyte *)(inoutPtr + 1),
        *(GLubyte *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLubyte *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[52])(
        (GLubyte *)(inoutPtr + 4 + 1 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLubyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumui(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[53])(
        (GLubyte *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLuint *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[54])(
        (GLubyte *)(inoutPtr + 4 + 4 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumul(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLulong);
    ((__GLSdispatch)ctx->dispatchCall[55])(
        (GLubyte *)(inoutPtr + 8),
        *(GLulong *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumulv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLulong *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[56])(
        (GLubyte *)(inoutPtr + 4 + 8 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLulong *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsNumus(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[57])(
        (GLubyte *)(inoutPtr + 2),
        *(GLushort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glsNumusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLushort *);
    GLuint inCount;
    inCount = *(GLuint *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[58])(
        (GLubyte *)(inoutPtr + 4 + 2 * __GLS_MAX(inCount, 0)),
        *(GLuint *)(inoutPtr + 0),
        (GLushort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glsSwapBuffers(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[60])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glNewList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[64])(
        *(GLuint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glCallList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[66])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glCallLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, const GLvoid *);
    ((__GLSdispatch)ctx->dispatchCall[67])(
        *(GLsizei *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLvoid *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glDeleteLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[68])(
        *(GLuint *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glGenLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[69])(
        *(GLsizei *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glListBase(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[70])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glBegin(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[71])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glBitmap(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[72])(
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12),
        *(GLfloat *)(inoutPtr + 16),
        *(GLfloat *)(inoutPtr + 20),
        *(GLfloat *)(inoutPtr + 24),
        (GLubyte *)(inoutPtr + 28)
    );
}

void __gls_decode_bin_glColor3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[73])(
        *(GLbyte *)(inoutPtr + 0),
        *(GLbyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glColor3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[75])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glColor3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[77])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glColor3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[79])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glColor3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[81])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glColor3ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte);
    ((__GLSdispatch)ctx->dispatchCall[83])(
        *(GLubyte *)(inoutPtr + 0),
        *(GLubyte *)(inoutPtr + 1),
        *(GLubyte *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glColor3ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[85])(
        *(GLuint *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glColor3us(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[87])(
        *(GLushort *)(inoutPtr + 0),
        *(GLushort *)(inoutPtr + 2),
        *(GLushort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glColor4b(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[89])(
        *(GLbyte *)(inoutPtr + 0),
        *(GLbyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 2),
        *(GLbyte *)(inoutPtr + 3)
    );
}

void __gls_decode_bin_glColor4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[91])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glColor4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[93])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glColor4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[95])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glColor4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[97])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glColor4ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte, GLubyte);
    ((__GLSdispatch)ctx->dispatchCall[99])(
        *(GLubyte *)(inoutPtr + 0),
        *(GLubyte *)(inoutPtr + 1),
        *(GLubyte *)(inoutPtr + 2),
        *(GLubyte *)(inoutPtr + 3)
    );
}

void __gls_decode_bin_glColor4ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[101])(
        *(GLuint *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8),
        *(GLuint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glColor4us(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[103])(
        *(GLushort *)(inoutPtr + 0),
        *(GLushort *)(inoutPtr + 2),
        *(GLushort *)(inoutPtr + 4),
        *(GLushort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glEdgeFlag(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[105])(
        *(GLboolean *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[108])(
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[110])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[112])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexs(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort);
    ((__GLSdispatch)ctx->dispatchCall[114])(
        *(GLshort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort);
    ((__GLSdispatch)ctx->dispatchCall[379])(
        *(GLubyte *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glNormal3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    ((__GLSdispatch)ctx->dispatchCall[116])(
        *(GLbyte *)(inoutPtr + 0),
        *(GLbyte *)(inoutPtr + 1),
        *(GLbyte *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glNormal3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[118])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glNormal3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[120])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glNormal3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[122])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glNormal3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[124])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[126])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRasterPos2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[128])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[130])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[132])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glRasterPos3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[134])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glRasterPos3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[136])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRasterPos3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[138])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRasterPos3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[140])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glRasterPos4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[142])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glRasterPos4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[144])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRasterPos4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[146])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRasterPos4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[148])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glRectd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[150])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glRectdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLdouble *, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[151])(
        (GLdouble *)(inoutPtr + 0),
        (GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glRectf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[152])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRectfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLfloat *, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[153])(
        (GLfloat *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRecti(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[154])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glRectiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLint *, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[155])(
        (GLint *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glRects(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[156])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glRectsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLshort *, const GLshort *);
    ((__GLSdispatch)ctx->dispatchCall[157])(
        (GLshort *)(inoutPtr + 0),
        (GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[158])(
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[160])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord1i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[162])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord1s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort);
    ((__GLSdispatch)ctx->dispatchCall[164])(
        *(GLshort *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[166])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[168])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[170])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[172])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glTexCoord3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[174])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glTexCoord3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[176])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexCoord3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[178])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexCoord3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[180])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexCoord4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[182])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glTexCoord4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[184])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glTexCoord4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[186])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glTexCoord4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[188])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glVertex2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[190])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glVertex2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[192])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glVertex2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[194])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glVertex2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[196])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2)
    );
}

void __gls_decode_bin_glVertex3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[198])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glVertex3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[200])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glVertex3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[202])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glVertex3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[204])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glVertex4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[206])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glVertex4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[208])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glVertex4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[210])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glVertex4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    ((__GLSdispatch)ctx->dispatchCall[212])(
        *(GLshort *)(inoutPtr + 0),
        *(GLshort *)(inoutPtr + 2),
        *(GLshort *)(inoutPtr + 4),
        *(GLshort *)(inoutPtr + 6)
    );
}

void __gls_decode_bin_glClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[214])(
        *(GLenum *)(inoutPtr + 32),
        (GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glColorMaterial(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[215])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glCullFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[216])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glFogf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[217])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFogfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[218])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFogi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[219])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFogiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[220])(
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glFrontFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[221])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glHint(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[222])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[223])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[224])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLighti(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[225])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[226])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glLightModelf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[227])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightModelfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[228])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightModeli(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[229])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLightModeliv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[230])(
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLineStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLushort);
    ((__GLSdispatch)ctx->dispatchCall[231])(
        *(GLint *)(inoutPtr + 0),
        *(GLushort *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLineWidth(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[232])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glMaterialf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[233])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[234])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMateriali(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[235])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[236])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glPointSize(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[237])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPolygonMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[238])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[239])(
        (GLubyte *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glScissor(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[240])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glShadeModel(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[241])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexParameterf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[242])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[243])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexParameteri(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[244])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[245])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[246])(
        *(GLenum *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 28),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 32)
    );
}

void __gls_decode_bin_glTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[247])(
        *(GLenum *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 32),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 36)
    );
}

void __gls_decode_bin_glTexEnvf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[248])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[249])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexEnvi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[250])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[251])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGend(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[252])(
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLdouble *);
    GLenum pname;
    GLint params_count;
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glTexGendv_params_size(pname);
    ((__GLSdispatch)ctx->dispatchCall[253])(
        *(GLenum *)(inoutPtr + 4 + 8 * params_count),
        *(GLenum *)(inoutPtr + 0),
        (GLdouble *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glTexGenf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[254])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[255])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGeni(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[256])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[257])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glFeedbackBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei size;
    GLfloat *buffer = GLS_NONE;
    size = *(GLsizei *)(inoutPtr + 0);
    buffer = (GLfloat *)__glsContext_allocFeedbackBuf(ctx, 4 * __GLS_MAX(size, 0));
    if (!buffer) {
        __GLS_CALL_ERROR(ctx, 258, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[258])(
        *(GLsizei *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 12),
        (GLfloat *)buffer
    );
end:
    ctx->outArgs = __outArgsSave;
}

void __gls_decode_bin_glSelectBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei size;
    GLuint *buffer = GLS_NONE;
    size = *(GLsizei *)(inoutPtr + 0);
    buffer = (GLuint *)__glsContext_allocSelectBuf(ctx, 4 * __GLS_MAX(size, 0));
    if (!buffer) {
        __GLS_CALL_ERROR(ctx, 259, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[259])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)buffer
    );
end:
    ctx->outArgs = __outArgsSave;
}

void __gls_decode_bin_glRenderMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[260])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glLoadName(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[262])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPassThrough(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[263])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPushName(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[265])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glDrawBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[266])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClear(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbitfield);
    ((__GLSdispatch)ctx->dispatchCall[267])(
        *(GLbitfield *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClearAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[268])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glClearIndex(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[269])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClearColor(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    ((__GLSdispatch)ctx->dispatchCall[270])(
        *(GLclampf *)(inoutPtr + 0),
        *(GLclampf *)(inoutPtr + 4),
        *(GLclampf *)(inoutPtr + 8),
        *(GLclampf *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glClearStencil(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[271])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glClearDepth(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampd);
    ((__GLSdispatch)ctx->dispatchCall[272])(
        *(GLclampd *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glStencilMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[273])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glColorMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLboolean, GLboolean, GLboolean, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[274])(
        *(GLboolean *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 1),
        *(GLboolean *)(inoutPtr + 2),
        *(GLboolean *)(inoutPtr + 3)
    );
}

void __gls_decode_bin_glDepthMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[275])(
        *(GLboolean *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIndexMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[276])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[277])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glDisable(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[278])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEnable(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[279])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPushAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbitfield);
    ((__GLSdispatch)ctx->dispatchCall[283])(
        *(GLbitfield *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glMap1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[284])(
        *(GLenum *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 12),
        *(GLdouble *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        (GLdouble *)(inoutPtr + 28)
    );
}

void __gls_decode_bin_glMap1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[285])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 12),
        *(GLfloat *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        (GLfloat *)(inoutPtr + 20)
    );
}

void __gls_decode_bin_glMap2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    ((__GLSdispatch)ctx->dispatchCall[286])(
        *(GLenum *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 20),
        *(GLdouble *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 36),
        *(GLdouble *)(inoutPtr + 44),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        (GLdouble *)(inoutPtr + 52)
    );
}

void __gls_decode_bin_glMap2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[287])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 20),
        *(GLfloat *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 28),
        *(GLfloat *)(inoutPtr + 32),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        (GLfloat *)(inoutPtr + 36)
    );
}

void __gls_decode_bin_glMapGrid1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[288])(
        *(GLint *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMapGrid1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[289])(
        *(GLint *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glMapGrid2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[290])(
        *(GLint *)(inoutPtr + 32),
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 36),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glMapGrid2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[291])(
        *(GLint *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLfloat *)(inoutPtr + 16),
        *(GLfloat *)(inoutPtr + 20)
    );
}

void __gls_decode_bin_glEvalCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[292])(
        *(GLdouble *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEvalCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[294])(
        *(GLfloat *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEvalCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[296])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glEvalCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[298])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glEvalMesh1(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[300])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glEvalPoint1(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[301])(
        *(GLint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEvalMesh2(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[302])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glEvalPoint2(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    ((__GLSdispatch)ctx->dispatchCall[303])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glAlphaFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLclampf);
    ((__GLSdispatch)ctx->dispatchCall[304])(
        *(GLenum *)(inoutPtr + 0),
        *(GLclampf *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glBlendFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[305])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glLogicOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[306])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glStencilFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[307])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glStencilOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[308])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glDepthFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[309])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glPixelZoom(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[310])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelTransferf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[311])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelTransferi(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[312])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelStoref(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[313])(
        *(GLenum *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelStorei(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[314])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4)
    );
}

void __gls_decode_bin_glPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[315])(
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLuint *);
    ((__GLSdispatch)ctx->dispatchCall[316])(
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLushort *);
    ((__GLSdispatch)ctx->dispatchCall[317])(
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 0),
        (GLushort *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glReadBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[318])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glCopyPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum);
    ((__GLSdispatch)ctx->dispatchCall[319])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glReadPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    width = *(GLsizei *)(inoutPtr + 0);
    height = *(GLsizei *)(inoutPtr + 4);
    format = *(GLenum *)(inoutPtr + 8);
    type = *(GLenum *)(inoutPtr + 12);
    pixels_count = __gls_glReadPixels_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_BIN(pixels, GLvoid, 1 * pixels_count);
    if (!pixels) {
        __GLS_CALL_ERROR(ctx, 320, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 16);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[320])(
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLsizei *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
}

void __gls_decode_bin_glDrawPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[321])(
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 20)
    );
}

void __gls_decode_bin_glGetBooleanv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLboolean *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetBooleanv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLboolean, 1 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 322, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[322])(
        *(GLenum *)(inoutPtr + 0),
        (GLboolean *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLdouble equation[4];
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[323])(
        *(GLenum *)(inoutPtr + 8),
        equation
    );
    ctx->outArgs = __outArgsSave;
}

void __gls_decode_bin_glGetDoublev(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetDoublev_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLdouble, 8 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 324, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[324])(
        *(GLenum *)(inoutPtr + 0),
        (GLdouble *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetFloatv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetFloatv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 326, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[326])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetIntegerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetIntegerv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 327, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[327])(
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetLightfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 328, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[328])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetLightiv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 329, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[329])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetMapdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum query;
    GLint v_count;
    GLdouble *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    target = *(GLenum *)(inoutPtr + 0);
    query = *(GLenum *)(inoutPtr + 4);
    v_count = __gls_glGetMapdv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_BIN(v, GLdouble, 8 * v_count);
    if (!v) {
        __GLS_CALL_ERROR(ctx, 330, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 8);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[330])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLdouble *)v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
}

void __gls_decode_bin_glGetMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum query;
    GLint v_count;
    GLfloat *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    target = *(GLenum *)(inoutPtr + 0);
    query = *(GLenum *)(inoutPtr + 4);
    v_count = __gls_glGetMapfv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_BIN(v, GLfloat, 4 * v_count);
    if (!v) {
        __GLS_CALL_ERROR(ctx, 331, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 8);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[331])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLfloat *)v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
}

void __gls_decode_bin_glGetMapiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum query;
    GLint v_count;
    GLint *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    target = *(GLenum *)(inoutPtr + 0);
    query = *(GLenum *)(inoutPtr + 4);
    v_count = __gls_glGetMapiv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_BIN(v, GLint, 4 * v_count);
    if (!v) {
        __GLS_CALL_ERROR(ctx, 332, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 8);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[332])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        (GLint *)v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
}

void __gls_decode_bin_glGetMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMaterialfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 333, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[333])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMaterialiv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 334, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[334])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum map;
    GLint values_count;
    GLfloat *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    map = *(GLenum *)(inoutPtr + 0);
    values_count = __gls_glGetPixelMapfv_values_size(ctx, map);
    __GLS_DEC_ALLOC_BIN(values, GLfloat, 4 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 335, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[335])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}

void __gls_decode_bin_glGetPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum map;
    GLint values_count;
    GLuint *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    map = *(GLenum *)(inoutPtr + 0);
    values_count = __gls_glGetPixelMapuiv_values_size(ctx, map);
    __GLS_DEC_ALLOC_BIN(values, GLuint, 4 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 336, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[336])(
        *(GLenum *)(inoutPtr + 0),
        (GLuint *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}

void __gls_decode_bin_glGetPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLushort *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum map;
    GLint values_count;
    GLushort *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    map = *(GLenum *)(inoutPtr + 0);
    values_count = __gls_glGetPixelMapusv_values_size(ctx, map);
    __GLS_DEC_ALLOC_BIN(values, GLushort, 2 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 337, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[337])(
        *(GLenum *)(inoutPtr + 0),
        (GLushort *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}

void __gls_decode_bin_glGetPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLint mask_count;
    GLubyte *mask = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(mask)
    mask_count = __gls_glGetPolygonStipple_mask_size();
    __GLS_DEC_ALLOC_BIN(mask, GLubyte, 1 * mask_count);
    if (!mask) {
        __GLS_CALL_ERROR(ctx, 338, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[338])(
        (GLubyte *)mask
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(mask);
}

void __gls_decode_bin_glGetString(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[339])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glGetTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexEnvfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 340, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[340])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexEnviv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 341, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[341])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexGendv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLdouble, 8 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 342, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[342])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLdouble *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexGenfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 343, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[343])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexGeniv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 344, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[344])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexImage(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    target = *(GLenum *)(inoutPtr + 0);
    level = *(GLint *)(inoutPtr + 4);
    format = *(GLenum *)(inoutPtr + 8);
    type = *(GLenum *)(inoutPtr + 12);
    pixels_count = __gls_glGetTexImage_pixels_size(ctx, target, level, format, type);
    __GLS_DEC_ALLOC_BIN(pixels, GLvoid, 1 * pixels_count);
    if (!pixels) {
        __GLS_CALL_ERROR(ctx, 345, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 16);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[345])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
}

void __gls_decode_bin_glGetTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 346, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[346])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 347, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[347])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexLevelParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexLevelParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 348, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[348])(
        *(GLenum *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glGetTexLevelParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexLevelParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 349, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[349])(
        *(GLenum *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}

void __gls_decode_bin_glIsEnabled(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[350])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glIsList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[351])(
        *(GLuint *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glDepthRange(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampd, GLclampd);
    ((__GLSdispatch)ctx->dispatchCall[352])(
        *(GLclampd *)(inoutPtr + 0),
        *(GLclampd *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glFrustum(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[353])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24),
        *(GLdouble *)(inoutPtr + 32),
        *(GLdouble *)(inoutPtr + 40)
    );
}

void __gls_decode_bin_glMatrixMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[357])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glOrtho(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[360])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24),
        *(GLdouble *)(inoutPtr + 32),
        *(GLdouble *)(inoutPtr + 40)
    );
}

void __gls_decode_bin_glRotated(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[363])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16),
        *(GLdouble *)(inoutPtr + 24)
    );
}

void __gls_decode_bin_glRotatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[364])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8),
        *(GLfloat *)(inoutPtr + 12)
    );
}

void __gls_decode_bin_glScaled(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[365])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glScalef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[366])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glTranslated(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    ((__GLSdispatch)ctx->dispatchCall[367])(
        *(GLdouble *)(inoutPtr + 0),
        *(GLdouble *)(inoutPtr + 8),
        *(GLdouble *)(inoutPtr + 16)
    );
}

void __gls_decode_bin_glTranslatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[368])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}

void __gls_decode_bin_glViewport(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[369])(
        *(GLint *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12)
    );
}

#if __GL_EXT_blend_color
void __gls_decode_bin_glBlendColorEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    ((__GLSdispatch)ctx->dispatchCall[384])(
        *(GLclampf *)(inoutPtr + 0),
        *(GLclampf *)(inoutPtr + 4),
        *(GLclampf *)(inoutPtr + 8),
        *(GLclampf *)(inoutPtr + 12)
    );
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_decode_bin_glBlendEquationEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[385])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_decode_bin_glPolygonOffsetEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[386])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}
#endif /* __GL_EXT_polygon_offset */

void __gls_decode_bin_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[383])(
        *(GLfloat *)(inoutPtr + 0),
        *(GLfloat *)(inoutPtr + 4)
    );
}

#if __GL_EXT_subtexture
void __gls_decode_bin_glTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[387])(
        *(GLenum *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[396])(
        *(GLenum *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 28)
    );
}

#if __GL_EXT_subtexture
void __gls_decode_bin_glTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[388])(
        *(GLenum *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 36)
    );
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[397])(
        *(GLenum *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 36)
    );
}

#if __GL_SGIS_multisample
void __gls_decode_bin_glSampleMaskSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLclampf, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[389])(
        *(GLclampf *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 4)
    );
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_decode_bin_glSamplePatternSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[390])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_SGIS_multisample */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[392])(
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 24)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[393])(
        *(GLenum *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        (GLvoid *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameterfEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    ((__GLSdispatch)ctx->dispatchCall[394])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[395])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameteriEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    ((__GLSdispatch)ctx->dispatchCall[396])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[397])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glCopyConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[398])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glCopyConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[399])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetConvolutionFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    image_count = __gls_glGetConvolutionFilterEXT_image_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(image, GLvoid, 1 * image_count);
    if (!image) {
        __GLS_CALL_ERROR(ctx, 65504, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[400])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)image
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(image);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetConvolutionParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65505, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[401])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetConvolutionParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65506, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[402])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glGetSeparableFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLint column_count;
    GLint span_count;
    GLvoid *row = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(row)
    GLvoid *column = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(column)
    GLvoid *span = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(span)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    row_count = __gls_glGetSeparableFilterEXT_row_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(row, GLvoid, 1 * row_count);
    if (!row) {
        __GLS_CALL_ERROR(ctx, 65507, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    column_count = __gls_glGetSeparableFilterEXT_column_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(column, GLvoid, 1 * column_count);
    if (!column) {
        __GLS_CALL_ERROR(ctx, 65507, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[1] = *(GLulong*)(inoutPtr + 20);
    span_count = __gls_glGetSeparableFilterEXT_span_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(span, GLvoid, 1 * span_count);
    if (!span) {
        __GLS_CALL_ERROR(ctx, 65507, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[2] = *(GLulong*)(inoutPtr + 28);
    ctx->outArgs.count = 3;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[403])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)row,
        (GLvoid *)column,
        (GLvoid *)span
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(row);
    __GLS_DEC_FREE(column);
    __GLS_DEC_FREE(span);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_glSeparableFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
    GLenum target;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint row_count;
    target = *(GLenum *)(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 20);
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[404])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        (GLvoid *)(inoutPtr + 28),
        (GLvoid *)(inoutPtr + 28 + 1 * row_count)
    );
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    values_count = __gls_glGetHistogramEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(values, GLvoid, 1 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 65509, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[405])(
        *(GLenum *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetHistogramParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetHistogramParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65510, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[406])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetHistogramParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetHistogramParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65511, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[407])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    values_count = __gls_glGetMinmaxEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_BIN(values, GLvoid, 1 * values_count);
    if (!values) {
        __GLS_CALL_ERROR(ctx, 65512, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[408])(
        *(GLenum *)(inoutPtr + 0),
        *(GLboolean *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetMinmaxParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMinmaxParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65513, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[409])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glGetMinmaxParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetMinmaxParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65514, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[410])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[411])(
        *(GLenum *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLboolean *)(inoutPtr + 12)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLboolean);
    ((__GLSdispatch)ctx->dispatchCall[412])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLboolean *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glResetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[413])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_glResetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[414])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_decode_bin_glTexImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[415])(
        *(GLenum *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLenum *)(inoutPtr + 32),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 36),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 40)
    );
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture
void __gls_decode_bin_glTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[416])(
        *(GLenum *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLint *)(inoutPtr + 36),
        *(GLint *)(inoutPtr + 40),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        (GLvoid *)(inoutPtr + 44)
    );
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_glDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[417])(
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_glGetDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    target = *(GLenum *)(inoutPtr + 0);
    points_count = __gls_glGetDetailTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_BIN(points, GLfloat, 4 * points_count);
    if (!points) {
        __GLS_CALL_ERROR(ctx, 65490, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[418])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_glSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[419])(
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_glGetSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    target = *(GLenum *)(inoutPtr + 0);
    points_count = __gls_glGetSharpenTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_BIN(points, GLfloat, 4 * points_count);
    if (!points) {
        __GLS_CALL_ERROR(ctx, 65492, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[420])(
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void __gls_decode_bin_glArrayElementEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    ((__GLSdispatch)ctx->dispatchCall[437])(
        *(GLint *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint);
    __glsSetArrayState(ctx, inoutPtr);
    ((__GLSdispatch)ctx->dispatchCall[370])(
        0
    );
    __glsDisableArrayState(ctx, *(GLuint *)inoutPtr);
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glColorPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    size = *(GLint *)(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65494, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65494, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 16, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 16;
    ((__GLSdispatch)ctx->dispatchCall[438])(
        *(GLint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because ColorPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glDrawArraysEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[439])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8)
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    __glsSetArrayState(ctx, inoutPtr+4);
    ((__GLSdispatch)ctx->dispatchCall[374])(
        *(GLenum *)(inoutPtr + 0),
        0,
        *(GLint *)(inoutPtr + 8)
    );
    __glsDisableArrayState(ctx, *(GLuint *)(inoutPtr+12));
}

void __gls_decode_bin_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr) {
    GLsizei count;
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, const GLvoid *);
    __glsSetArrayState(ctx, inoutPtr+8);
    count = *(GLsizei *)(inoutPtr+4);
    ((__GLSdispatch)ctx->dispatchCall[375])(
        *(GLenum *)(inoutPtr+0),
        count,
        GL_UNSIGNED_INT,
        inoutPtr + *(GLint *)(inoutPtr+8) + 8 - count*sizeof(GLuint)
    );
    __glsDisableArrayState(ctx, *(GLuint *)(inoutPtr+16));
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glEdgeFlagPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, const GLboolean *);
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLboolean *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    stride = *(GLsizei *)(inoutPtr + 0);
    count = *(GLsizei *)(inoutPtr + 4);
    pointer_count = __gls_glEdgeFlagPointerEXT_pointer_size(stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65496, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65496, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 8, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 8;
    ((__GLSdispatch)ctx->dispatchCall[440])(
        *(GLsizei *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        (GLboolean *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because EdgeFlagPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glGetPointervEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLvoid* params[1];
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[441])(
        *(GLenum *)(inoutPtr + 8),
        params
    );
    ctx->outArgs = __outArgsSave;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLvoid* params[1];
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[393])(
        *(GLenum *)(inoutPtr + 8),
        params
    );
    ctx->outArgs = __outArgsSave;
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glIndexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    type = *(GLenum *)(inoutPtr + 0);
    stride = *(GLsizei *)(inoutPtr + 4);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65498, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65498, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 12, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 12;
    ((__GLSdispatch)ctx->dispatchCall[442])(
        *(GLenum *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because IndexPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glNormalPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    type = *(GLenum *)(inoutPtr + 0);
    stride = *(GLsizei *)(inoutPtr + 4);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65499, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65499, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 12, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 12;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        *(GLenum *)(inoutPtr + 0),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because NormalPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glTexCoordPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    size = *(GLint *)(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65500, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65500, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 16, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 16;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        *(GLint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because TexCoordPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_glVertexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    if (ctx->contextCall) goto ctxTest;
    size = *(GLint *)(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    pointer = __glsContext_allocVertexArrayBuf(ctx, 65501, pointer_count);
    if (!pointer) {
        __GLS_CALL_ERROR(ctx, 65501, GLS_OUT_OF_MEMORY);
        return;
    }
    memcpy(pointer, inoutPtr + 16, pointer_count);
ctxTest:
    if (ctx->contextCall) pointer = inoutPtr + 16;
    ((__GLSdispatch)ctx->dispatchCall[445])(
        *(GLint *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        (GLvoid *)pointer
    );
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because VertexPointer isn't captured
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glAreTexturesResidentEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) {
        __GLS_CALL_ERROR(ctx, 65502, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[430])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 12),
        (GLboolean *)residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(residences);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) {
        __GLS_CALL_ERROR(ctx, 65502, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[386])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 12),
        (GLboolean *)residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(residences);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glBindTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[431])(
        *(GLenum *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4)
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    ((__GLSdispatch)ctx->dispatchCall[371])(
        *(GLenum *)(inoutPtr + 0),
        *(GLuint *)(inoutPtr + 4)
    );
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glDeleteTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    ((__GLSdispatch)ctx->dispatchCall[432])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4)
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    ((__GLSdispatch)ctx->dispatchCall[391])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4)
    );
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) {
        __GLS_CALL_ERROR(ctx, 65473, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[433])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    n = *(GLsizei *)(inoutPtr + 0);
    __GLS_DEC_ALLOC_BIN(textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) {
        __GLS_CALL_ERROR(ctx, 65473, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[392])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glIsTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[434])(
        *(GLuint *)(inoutPtr + 0)
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLuint);
    ((__GLSdispatch)ctx->dispatchCall[394])(
        *(GLuint *)(inoutPtr + 0)
    );
}

#if __GL_EXT_texture_object
void __gls_decode_bin_glPrioritizeTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    n = *(GLsizei *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[435])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4),
        (GLclampf *)(inoutPtr + 4 + 4 * __GLS_MAX(n, 0))
    );
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    n = *(GLsizei *)(inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[395])(
        *(GLsizei *)(inoutPtr + 0),
        (GLuint *)(inoutPtr + 4),
        (GLclampf *)(inoutPtr + 4 + 4 * __GLS_MAX(n, 0))
    );
}

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[452])(
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLenum *)(inoutPtr + 12),
        (GLvoid *)(inoutPtr + 24)
    );
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_decode_bin_glColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[437])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_glColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[438])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_glCopyColorTableSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[439])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16)
    );
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glGetColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum target;
    GLenum format;
    GLenum type;
    GLint table_count;
    GLvoid *table = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(table)
    target = *(GLenum *)(inoutPtr + 0);
    format = *(GLenum *)(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 8);
    table_count = __gls_glGetColorTableEXT_table_size(ctx, target, format, type);
    __GLS_DEC_ALLOC_BIN(table, GLvoid, 1 * table_count);
    if (!table) {
        __GLS_CALL_ERROR(ctx, 65480, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 12);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[456])(
        *(GLenum *)(inoutPtr + 0),
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        (GLvoid *)table
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(table);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glGetColorTableParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetColorTableParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65481, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[457])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glGetColorTableParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetColorTableParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65482, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[458])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glGetTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLfloat, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65483, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glGetTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glGetTexColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_BIN(params, GLint, 4 * params_count);
    if (!params) {
        __GLS_CALL_ERROR(ctx, 65484, GLS_OUT_OF_MEMORY);
        goto end;
    }
    ctx->outArgs.vals[0] = *(GLulong*)(inoutPtr + 4);
    ctx->outArgs.count = 1;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        *(GLenum *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    ((__GLSdispatch)ctx->dispatchCall[445])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLfloat *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_glTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    ((__GLSdispatch)ctx->dispatchCall[446])(
        *(GLenum *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 0),
        (GLint *)(inoutPtr + 8)
    );
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[447])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[387])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[448])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    ((__GLSdispatch)ctx->dispatchCall[388])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLenum *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLint *)(inoutPtr + 28)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[449])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[389])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLsizei *)(inoutPtr + 20)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[450])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 28)
    );
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[390])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLsizei *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 28)
    );
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_glCopyTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    ((__GLSdispatch)ctx->dispatchCall[451])(
        *(GLenum *)(inoutPtr + 0),
        *(GLint *)(inoutPtr + 4),
        *(GLint *)(inoutPtr + 8),
        *(GLint *)(inoutPtr + 12),
        *(GLint *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 20),
        *(GLint *)(inoutPtr + 24),
        *(GLsizei *)(inoutPtr + 28),
        *(GLsizei *)(inoutPtr + 32)
    );
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_decode_bin_glTexImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[452])(
        *(GLenum *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLenum *)(inoutPtr + 36),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16),
        *(GLint *)(inoutPtr + 40),
        *(GLenum *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 24),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 44)
    );
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_decode_bin_glTexSubImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[453])(
        *(GLenum *)(inoutPtr + 28),
        *(GLint *)(inoutPtr + 32),
        *(GLint *)(inoutPtr + 36),
        *(GLint *)(inoutPtr + 40),
        *(GLint *)(inoutPtr + 44),
        *(GLint *)(inoutPtr + 48),
        *(GLsizei *)(inoutPtr + 4),
        *(GLsizei *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLsizei *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        *(GLenum *)(inoutPtr + 24),
        (GLvoid *)(inoutPtr + 52)
    );
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_decode_bin_glPixelTexGenSGIX(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[454])(
        *(GLenum *)(inoutPtr + 0)
    );
}
#endif /* __GL_SGIX_pixel_texture */

#ifdef __GLS_PLATFORM_WIN32
void __gls_decode_bin_glsCallStream(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[18])(
        inoutPtr
    );
}

void __gls_decode_bin_glsRequireExtension(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[31])(
        inoutPtr
    );
}

void __gls_decode_bin_glsBeginObj(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[34])(
        inoutPtr
    );
}

void __gls_decode_bin_glsComment(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[36])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[74])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[76])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[78])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[80])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[82])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[84])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[86])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor3usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[88])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[90])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[92])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[94])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[96])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[98])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[100])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[102])(
        inoutPtr
    );
}

void __gls_decode_bin_glColor4usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[104])(
        inoutPtr
    );
}

void __gls_decode_bin_glEdgeFlagv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[106])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[109])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[111])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[113])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[115])(
        inoutPtr
    );
}

void __gls_decode_bin_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[380])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[117])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[119])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[121])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[123])(
        inoutPtr
    );
}

void __gls_decode_bin_glNormal3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[125])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[127])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[129])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[131])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[133])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[135])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[137])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[139])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[141])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[143])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[145])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[147])(
        inoutPtr
    );
}

void __gls_decode_bin_glRasterPos4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[149])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[159])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[161])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[163])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord1sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[165])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[167])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[169])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[171])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[173])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[175])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[177])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[179])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[181])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[183])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[185])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[187])(
        inoutPtr
    );
}

void __gls_decode_bin_glTexCoord4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[189])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[191])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[193])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[195])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[197])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[199])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[201])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[203])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[205])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[207])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[209])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[211])(
        inoutPtr
    );
}

void __gls_decode_bin_glVertex4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[213])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[293])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[295])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[297])(
        inoutPtr
    );
}

void __gls_decode_bin_glEvalCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[299])(
        inoutPtr
    );
}

void __gls_decode_bin_glLoadMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[355])(
        inoutPtr
    );
}

void __gls_decode_bin_glLoadMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[356])(
        inoutPtr
    );
}

void __gls_decode_bin_glMultMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[358])(
        inoutPtr
    );
}

void __gls_decode_bin_glMultMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void *);
    ((__GLSdispatch)ctx->dispatchCall[359])(
        inoutPtr
    );
}
#endif

#if __GL_EXT_paletted_texture
void __gls_decode_bin_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum, GLuint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLbitfield imageFlags;
    imageFlags = *(GLint *)(inoutPtr + 0);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    ((__GLSdispatch)ctx->dispatchCall[496])(
        *(GLenum *)(inoutPtr + 4),
        *(GLuint *)(inoutPtr + 8),
        *(GLsizei *)(inoutPtr + 12),
        *(GLenum *)(inoutPtr + 16),
        *(GLenum *)(inoutPtr + 20),
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : (GLvoid *)(inoutPtr + 24)
    );
}
#endif // __GL_EXT_paletted_texture

void __gls_decode_bin_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[373])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLenum);
    ((__GLSdispatch)ctx->dispatchCall[377])(
        *(GLenum *)(inoutPtr + 0)
    );
}

void __gls_decode_bin_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because InterleavedArrays isn't captured
}

void __gls_decode_bin_glPushClientAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLbitfield);
    ((__GLSdispatch)ctx->dispatchCall[398])(
        *(GLbitfield *)(inoutPtr + 0)
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_cap.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"
#include <string.h>

// DrewB - Removed size externs
// DrewB - All inactive extension functions have had their capture
//         flags index removed since they all need to be reset to
//         account for the added 1.1 functions

void __gls_capture_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(16);
    captureFlags = ctx->captureFlags[16];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsBeginGLS(GLint, GLint);
        __gls_exec_glsBeginGLS(inVersionMajor, inVersionMinor);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 16, 8)) goto end;
    writer->putGLint(writer, inVersionMajor);
    writer->putGLint(writer, inVersionMinor);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(16);
    --ctx->captureEntryCount;
}

void __gls_capture_glsBlock(GLSenum inBlockType) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(17);
    captureFlags = ctx->captureFlags[17];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsBlock(GLSenum);
        __gls_exec_glsBlock(inBlockType);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 17, 4)) goto end;
    writer->putGLSenum(writer, inBlockType);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(17);
    --ctx->captureEntryCount;
}

GLSenum __gls_capture_glsCallStream(const GLubyte *inName) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLSenum _outVal = 0;
    GLint inName_count;
    if (!glsIsUTF8String(inName)) {
        glsError(18, GLS_INVALID_STRING);
        return _outVal;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(18);
    captureFlags = ctx->captureFlags[18];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern GLSenum __gls_exec_glsCallStream(const GLubyte *);
        _outVal = __gls_exec_glsCallStream(inName);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inName_count = (GLint)strlen((const char *)inName) + 1;
    if (!writer->beginCommand(writer, 18, 0 + inName_count)) goto end;
    writer->putGLcharv(writer, inName_count, inName);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(18);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glsEndGLS(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(19);
    captureFlags = ctx->captureFlags[19];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsEndGLS(void);
        __gls_exec_glsEndGLS();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 19, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(19);
    --ctx->captureEntryCount;
}

void __gls_capture_glsError(GLSopcode inOpcode, GLSenum inError) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(20);
    captureFlags = ctx->captureFlags[20];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsError(GLSopcode, GLSenum);
        __gls_exec_glsError(inOpcode, inError);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 20, 8)) goto end;
    writer->putGLSopcode(writer, inOpcode);
    writer->putGLSenum(writer, inError);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(20);
    --ctx->captureEntryCount;
}

void __gls_capture_glsGLRC(GLuint inGLRC) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(21);
    captureFlags = ctx->captureFlags[21];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsGLRC(GLuint);
        __gls_exec_glsGLRC(inGLRC);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 21, 4)) goto end;
    writer->putGLuint(writer, inGLRC);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(21);
    --ctx->captureEntryCount;
}

void __gls_capture_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(22);
    captureFlags = ctx->captureFlags[22];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsGLRCLayer(GLuint, GLuint, GLuint);
        __gls_exec_glsGLRCLayer(inGLRC, inLayer, inReadLayer);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 22, 12)) goto end;
    writer->putGLuint(writer, inGLRC);
    writer->putGLuint(writer, inLayer);
    writer->putGLuint(writer, inReadLayer);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(22);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(23);
    captureFlags = ctx->captureFlags[23];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderGLRCi(GLuint, GLSenum, GLint);
        __gls_exec_glsHeaderGLRCi(inGLRC, inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 23, 12)) goto end;
    writer->putGLuint(writer, inGLRC);
    writer->putGLSenum(writer, inAttrib);
    writer->putGLint(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(23);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(24);
    captureFlags = ctx->captureFlags[24];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderLayerf(GLuint, GLSenum, GLfloat);
        __gls_exec_glsHeaderLayerf(inLayer, inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 24, 12)) goto end;
    writer->putGLuint(writer, inLayer);
    writer->putGLSenum(writer, inAttrib);
    writer->putGLfloat(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(24);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(25);
    captureFlags = ctx->captureFlags[25];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderLayeri(GLuint, GLSenum, GLint);
        __gls_exec_glsHeaderLayeri(inLayer, inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 25, 12)) goto end;
    writer->putGLuint(writer, inLayer);
    writer->putGLSenum(writer, inAttrib);
    writer->putGLintOrGLSenum(writer, inAttrib, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(25);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderf(GLSenum inAttrib, GLfloat inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(26);
    captureFlags = ctx->captureFlags[26];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderf(GLSenum, GLfloat);
        __gls_exec_glsHeaderf(inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 26, 8)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLfloat(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(26);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inVec_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(27);
    captureFlags = ctx->captureFlags[27];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderfv(GLSenum, const GLfloat *);
        __gls_exec_glsHeaderfv(inAttrib, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inVec_count = __gls_glsHeaderfv_inVec_size(inAttrib);
    if (!writer->beginCommand(writer, 27, 4 + inVec_count * 4)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLfloatv(writer, inVec_count, inVec);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(27);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderi(GLSenum inAttrib, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(28);
    captureFlags = ctx->captureFlags[28];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderi(GLSenum, GLint);
        __gls_exec_glsHeaderi(inAttrib, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 28, 8)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLint(writer, inVal);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(28);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inVec_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(29);
    captureFlags = ctx->captureFlags[29];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderiv(GLSenum, const GLint *);
        __gls_exec_glsHeaderiv(inAttrib, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inVec_count = __gls_glsHeaderiv_inVec_size(inAttrib);
    if (!writer->beginCommand(writer, 29, 4 + inVec_count * 4)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLintv(writer, inVec_count, inVec);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(29);
    --ctx->captureEntryCount;
}

void __gls_capture_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inString_count;
    if (!glsIsUTF8String(inString)) {
        glsError(30, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(30);
    captureFlags = ctx->captureFlags[30];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsHeaderubz(GLSenum, const GLubyte *);
        __gls_exec_glsHeaderubz(inAttrib, inString);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inString_count = (GLint)strlen((const char *)inString) + 1;
    if (!writer->beginCommand(writer, 30, 4 + inString_count)) goto end;
    writer->putGLSenum(writer, inAttrib);
    writer->putGLcharv(writer, inString_count, inString);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(30);
    --ctx->captureEntryCount;
}

void __gls_capture_glsRequireExtension(const GLubyte *inExtension) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inExtension_count;
    if (!glsIsUTF8String(inExtension)) {
        glsError(31, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(31);
    captureFlags = ctx->captureFlags[31];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsRequireExtension(const GLubyte *);
        __gls_exec_glsRequireExtension(inExtension);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inExtension_count = (GLint)strlen((const char *)inExtension) + 1;
    if (!writer->beginCommand(writer, 31, 0 + inExtension_count)) goto end;
    writer->putGLcharv(writer, inExtension_count, inExtension);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(31);
    --ctx->captureEntryCount;
}

void __gls_capture_glsUnsupportedCommand(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(32);
    captureFlags = ctx->captureFlags[32];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsUnsupportedCommand(void);
        __gls_exec_glsUnsupportedCommand();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 32, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(32);
    --ctx->captureEntryCount;
}

void __gls_capture_glsAppRef(GLulong inAddress, GLuint inCount) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(33);
    captureFlags = ctx->captureFlags[33];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsAppRef(GLulong, GLuint);
        __gls_exec_glsAppRef(inAddress, inCount);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 33, 12)) goto end;
    writer->putGLulonghex(writer, inAddress);
    writer->putGLuint(writer, inCount);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(33);
    --ctx->captureEntryCount;
}

void __gls_capture_glsBeginObj(const GLubyte *inTag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(34, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(34);
    captureFlags = ctx->captureFlags[34];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsBeginObj(const GLubyte *);
        __gls_exec_glsBeginObj(inTag);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 34, 0 + inTag_count)) goto end;
    writer->putGLcharv(writer, inTag_count, inTag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(34);
    --ctx->captureEntryCount;
}

void __gls_capture_glsCharubz(const GLubyte *inTag, const GLubyte *inString) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    GLint inString_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(35, GLS_INVALID_STRING);
        return;
    }
    if (!glsIsUTF8String(inString)) {
        glsError(35, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(35);
    captureFlags = ctx->captureFlags[35];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsCharubz(const GLubyte *, const GLubyte *);
        __gls_exec_glsCharubz(inTag, inString);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    inString_count = (GLint)strlen((const char *)inString) + 1;
    if (!writer->beginCommand(writer, 35, 0 + inTag_count + inString_count)) goto end;
    writer->putGLcharv(writer, inTag_count, inTag);
    writer->putGLcharv(writer, inString_count, inString);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(35);
    --ctx->captureEntryCount;
}

void __gls_capture_glsComment(const GLubyte *inComment) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inComment_count;
    if (!glsIsUTF8String(inComment)) {
        glsError(36, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(36);
    captureFlags = ctx->captureFlags[36];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsComment(const GLubyte *);
        __gls_exec_glsComment(inComment);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inComment_count = (GLint)strlen((const char *)inComment) + 1;
    if (!writer->beginCommand(writer, 36, 0 + inComment_count)) goto end;
    writer->putGLcharv(writer, inComment_count, inComment);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(36);
    --ctx->captureEntryCount;
}

void __gls_capture_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(37);
    captureFlags = ctx->captureFlags[37];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsDisplayMapfv(GLuint, GLSenum, GLuint, const GLfloat *);
        __gls_exec_glsDisplayMapfv(inLayer, inMap, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 37, 12 + __GLS_MAX(inCount, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLuint(writer, inLayer);
        writer->putGLSenum(writer, inMap);
        writer->putGLuint(writer, inCount);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLuint(writer, inLayer);
        writer->putGLSenum(writer, inMap);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(37);
    --ctx->captureEntryCount;
}

void __gls_capture_glsEndObj(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(38);
    captureFlags = ctx->captureFlags[38];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsEndObj(void);
        __gls_exec_glsEndObj();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 38, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(38);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumb(const GLubyte *inTag, GLbyte inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(39, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(39);
    captureFlags = ctx->captureFlags[39];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumb(const GLubyte *, GLbyte);
        __gls_exec_glsNumb(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 39, 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLbyte(writer, inVal);
    } else {
        writer->putGLbyte(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(39);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(40, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(40);
    captureFlags = ctx->captureFlags[40];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumbv(const GLubyte *, GLuint, const GLbyte *);
        __gls_exec_glsNumbv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 40, 4 + __GLS_MAX(inCount, 0) * 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLbytev(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLbytev(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(40);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumd(const GLubyte *inTag, GLdouble inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(41, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(41);
    captureFlags = ctx->captureFlags[41];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumd(const GLubyte *, GLdouble);
        __gls_exec_glsNumd(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 41, 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLdouble(writer, inVal);
    } else {
        writer->putGLdouble(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(41);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(42, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(42);
    captureFlags = ctx->captureFlags[42];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumdv(const GLubyte *, GLuint, const GLdouble *);
        __gls_exec_glsNumdv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 42, 4 + __GLS_MAX(inCount, 0) * 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLdoublev(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLdoublev(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(42);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumf(const GLubyte *inTag, GLfloat inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(43, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(43);
    captureFlags = ctx->captureFlags[43];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumf(const GLubyte *, GLfloat);
        __gls_exec_glsNumf(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 43, 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLfloat(writer, inVal);
    } else {
        writer->putGLfloat(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(43);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(44, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(44);
    captureFlags = ctx->captureFlags[44];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumfv(const GLubyte *, GLuint, const GLfloat *);
        __gls_exec_glsNumfv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 44, 4 + __GLS_MAX(inCount, 0) * 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLfloatv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(44);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumi(const GLubyte *inTag, GLint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(45, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(45);
    captureFlags = ctx->captureFlags[45];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumi(const GLubyte *, GLint);
        __gls_exec_glsNumi(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 45, 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLint(writer, inVal);
    } else {
        writer->putGLint(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(45);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(46, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(46);
    captureFlags = ctx->captureFlags[46];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumiv(const GLubyte *, GLuint, const GLint *);
        __gls_exec_glsNumiv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 46, 4 + __GLS_MAX(inCount, 0) * 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLintv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLintv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(46);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNuml(const GLubyte *inTag, GLlong inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(47, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(47);
    captureFlags = ctx->captureFlags[47];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNuml(const GLubyte *, GLlong);
        __gls_exec_glsNuml(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 47, 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLlong(writer, inVal);
    } else {
        writer->putGLlong(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(47);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(48, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(48);
    captureFlags = ctx->captureFlags[48];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumlv(const GLubyte *, GLuint, const GLlong *);
        __gls_exec_glsNumlv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 48, 4 + __GLS_MAX(inCount, 0) * 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLlongv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLlongv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(48);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNums(const GLubyte *inTag, GLshort inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(49, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(49);
    captureFlags = ctx->captureFlags[49];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNums(const GLubyte *, GLshort);
        __gls_exec_glsNums(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 49, 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLshort(writer, inVal);
    } else {
        writer->putGLshort(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(49);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(50, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(50);
    captureFlags = ctx->captureFlags[50];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumsv(const GLubyte *, GLuint, const GLshort *);
        __gls_exec_glsNumsv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 50, 4 + __GLS_MAX(inCount, 0) * 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLshortv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLshortv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(50);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumub(const GLubyte *inTag, GLubyte inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(51, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(51);
    captureFlags = ctx->captureFlags[51];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumub(const GLubyte *, GLubyte);
        __gls_exec_glsNumub(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 51, 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLubyte(writer, inVal);
    } else {
        writer->putGLubyte(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(51);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(52, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(52);
    captureFlags = ctx->captureFlags[52];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumubv(const GLubyte *, GLuint, const GLubyte *);
        __gls_exec_glsNumubv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 52, 4 + __GLS_MAX(inCount, 0) * 1 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLubytev(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLubytev(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(52);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumui(const GLubyte *inTag, GLuint inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(53, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(53);
    captureFlags = ctx->captureFlags[53];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumui(const GLubyte *, GLuint);
        __gls_exec_glsNumui(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 53, 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inVal);
    } else {
        writer->putGLuint(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(53);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(54, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(54);
    captureFlags = ctx->captureFlags[54];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumuiv(const GLubyte *, GLuint, const GLuint *);
        __gls_exec_glsNumuiv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 54, 4 + __GLS_MAX(inCount, 0) * 4 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLuintv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLuintv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(54);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumul(const GLubyte *inTag, GLulong inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(55, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(55);
    captureFlags = ctx->captureFlags[55];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumul(const GLubyte *, GLulong);
        __gls_exec_glsNumul(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 55, 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLulong(writer, inVal);
    } else {
        writer->putGLulong(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(55);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(56, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(56);
    captureFlags = ctx->captureFlags[56];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumulv(const GLubyte *, GLuint, const GLulong *);
        __gls_exec_glsNumulv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 56, 4 + __GLS_MAX(inCount, 0) * 8 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLulongv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLulongv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(56);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumus(const GLubyte *inTag, GLushort inVal) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(57, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(57);
    captureFlags = ctx->captureFlags[57];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumus(const GLubyte *, GLushort);
        __gls_exec_glsNumus(inTag, inVal);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 57, 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLushort(writer, inVal);
    } else {
        writer->putGLushort(writer, inVal);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(57);
    --ctx->captureEntryCount;
}

void __gls_capture_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint inTag_count;
    if (!glsIsUTF8String(inTag)) {
        glsError(58, GLS_INVALID_STRING);
        return;
    }
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(58);
    captureFlags = ctx->captureFlags[58];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsNumusv(const GLubyte *, GLuint, const GLushort *);
        __gls_exec_glsNumusv(inTag, inCount, inVec);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    inTag_count = (GLint)strlen((const char *)inTag) + 1;
    if (!writer->beginCommand(writer, 58, 4 + __GLS_MAX(inCount, 0) * 2 + inTag_count)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLcharv(writer, inTag_count, inTag);
        writer->putGLuint(writer, inCount);
        writer->putGLushortv(writer, __GLS_MAX(inCount, 0), inVec);
    } else {
        writer->putGLuint(writer, inCount);
        writer->putGLushortv(writer, __GLS_MAX(inCount, 0), inVec);
        writer->putGLcharv(writer, inTag_count, inTag);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(58);
    --ctx->captureEntryCount;
}

void __gls_capture_glsPad(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(59);
    captureFlags = ctx->captureFlags[59];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsPad(void);
        __gls_exec_glsPad();
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 59, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(59);
    --ctx->captureEntryCount;
}

void __gls_capture_glsSwapBuffers(GLuint inLayer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(60);
    captureFlags = ctx->captureFlags[60];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        extern void __gls_exec_glsSwapBuffers(GLuint);
        __gls_exec_glsSwapBuffers(inLayer);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 60, 4)) goto end;
    writer->putGLuint(writer, inLayer);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(60);
    --ctx->captureEntryCount;
}

void __gls_capture_glNewList(GLuint list, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(64);
    captureFlags = ctx->captureFlags[64];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 64);
        glNewList(list, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 64);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 64, 8)) goto end;
    writer->putGLuint(writer, list);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(64);
    --ctx->captureEntryCount;
}

void __gls_capture_glEndList(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65);
    captureFlags = ctx->captureFlags[65];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65);
        glEndList();
        __GLS_END_CAPTURE_EXEC(ctx, 65);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65);
    --ctx->captureEntryCount;
}

void __gls_capture_glCallList(GLuint list) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(66);
    captureFlags = ctx->captureFlags[66];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 66);
        glCallList(list);
        __GLS_END_CAPTURE_EXEC(ctx, 66);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 66, 4)) goto end;
    writer->putGLuint(writer, list);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(66);
    --ctx->captureEntryCount;
}

void __gls_capture_glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint lists_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(67);
    captureFlags = ctx->captureFlags[67];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 67);
        glCallLists(n, type, lists);
        __GLS_END_CAPTURE_EXEC(ctx, 67);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    lists_count = __gls_glCallLists_lists_size(n, type);
    if (!writer->beginCommand(writer, 67, 8 + lists_count * 1)) goto end;
    writer->putGLint(writer, n);
    writer->putGLenum(writer, type);
    __glsWriter_putListv(writer, type, n, lists);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(67);
    --ctx->captureEntryCount;
}

void __gls_capture_glDeleteLists(GLuint list, GLsizei range) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(68);
    captureFlags = ctx->captureFlags[68];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 68);
        glDeleteLists(list, range);
        __GLS_END_CAPTURE_EXEC(ctx, 68);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 68, 8)) goto end;
    writer->putGLuint(writer, list);
    writer->putGLint(writer, range);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(68);
    --ctx->captureEntryCount;
}

GLuint __gls_capture_glGenLists(GLsizei range) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLuint _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(69);
    captureFlags = ctx->captureFlags[69];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 69);
        _outVal = glGenLists(range);
        __GLS_END_CAPTURE_EXEC(ctx, 69);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 69, 4)) goto end;
    writer->putGLint(writer, range);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(69);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glListBase(GLuint base) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(70);
    captureFlags = ctx->captureFlags[70];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 70);
        glListBase(base);
        __GLS_END_CAPTURE_EXEC(ctx, 70);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 70, 4)) goto end;
    writer->putGLuint(writer, base);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(70);
    --ctx->captureEntryCount;
}

void __gls_capture_glBegin(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(71);
    captureFlags = ctx->captureFlags[71];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 71);
        glBegin(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 71);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (writer->contextStream && mode <= GL_POLYGON) {
        if (!writer->beginCommand(writer, 1 + mode, 0)) goto end;
        writer->endCommand(writer);
        goto end;
    }
    if (!writer->beginCommand(writer, 71, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(71);
    --ctx->captureEntryCount;
}

void __gls_capture_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint bitmap_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(72);
    captureFlags = ctx->captureFlags[72];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 72);
        glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
        __GLS_END_CAPTURE_EXEC(ctx, 72);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    bitmap_count = __gls_glBitmap_bitmap_size(width, height);
    if (!writer->beginCommand(writer, 72, 28 + bitmap_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLfloat(writer, xorig);
    writer->putGLfloat(writer, yorig);
    writer->putGLfloat(writer, xmove);
    writer->putGLfloat(writer, ymove);
    __glsWriter_putPixelv(writer, GL_COLOR_INDEX, GL_BITMAP, width, height, bitmap_count ? bitmap : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(72);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(73);
    captureFlags = ctx->captureFlags[73];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 73);
        glColor3b(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 73);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 73, 3)) goto end;
    writer->putGLbyte(writer, red);
    writer->putGLbyte(writer, green);
    writer->putGLbyte(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(73);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3bv(const GLbyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(74);
    captureFlags = ctx->captureFlags[74];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 74);
        glColor3bv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 74);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 74, 3)) goto end;
    writer->putGLbytev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(74);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(75);
    captureFlags = ctx->captureFlags[75];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 75);
        glColor3d(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 75);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 75, 24)) goto end;
    writer->putGLdouble(writer, red);
    writer->putGLdouble(writer, green);
    writer->putGLdouble(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(75);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(76);
    captureFlags = ctx->captureFlags[76];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 76);
        glColor3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 76);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 76, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(76);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(77);
    captureFlags = ctx->captureFlags[77];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 77);
        glColor3f(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 77);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 77, 12)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(77);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(78);
    captureFlags = ctx->captureFlags[78];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 78);
        glColor3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 78);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 78, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(78);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3i(GLint red, GLint green, GLint blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(79);
    captureFlags = ctx->captureFlags[79];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 79);
        glColor3i(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 79);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 79, 12)) goto end;
    writer->putGLint(writer, red);
    writer->putGLint(writer, green);
    writer->putGLint(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(79);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(80);
    captureFlags = ctx->captureFlags[80];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 80);
        glColor3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 80);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 80, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(80);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3s(GLshort red, GLshort green, GLshort blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(81);
    captureFlags = ctx->captureFlags[81];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 81);
        glColor3s(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 81);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 81, 6)) goto end;
    writer->putGLshort(writer, red);
    writer->putGLshort(writer, green);
    writer->putGLshort(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(81);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(82);
    captureFlags = ctx->captureFlags[82];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 82);
        glColor3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 82);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 82, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(82);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(83);
    captureFlags = ctx->captureFlags[83];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 83);
        glColor3ub(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 83);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 83, 3)) goto end;
    writer->putGLubyte(writer, red);
    writer->putGLubyte(writer, green);
    writer->putGLubyte(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(83);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3ubv(const GLubyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(84);
    captureFlags = ctx->captureFlags[84];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 84);
        glColor3ubv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 84);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 84, 3)) goto end;
    writer->putGLubytev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(84);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3ui(GLuint red, GLuint green, GLuint blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(85);
    captureFlags = ctx->captureFlags[85];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 85);
        glColor3ui(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 85);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 85, 12)) goto end;
    writer->putGLuint(writer, red);
    writer->putGLuint(writer, green);
    writer->putGLuint(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(85);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3uiv(const GLuint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(86);
    captureFlags = ctx->captureFlags[86];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 86);
        glColor3uiv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 86);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 86, 12)) goto end;
    writer->putGLuintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(86);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3us(GLushort red, GLushort green, GLushort blue) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(87);
    captureFlags = ctx->captureFlags[87];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 87);
        glColor3us(red, green, blue);
        __GLS_END_CAPTURE_EXEC(ctx, 87);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 87, 6)) goto end;
    writer->putGLushort(writer, red);
    writer->putGLushort(writer, green);
    writer->putGLushort(writer, blue);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(87);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor3usv(const GLushort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(88);
    captureFlags = ctx->captureFlags[88];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 88);
        glColor3usv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 88);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 88, 6)) goto end;
    writer->putGLushortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(88);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(89);
    captureFlags = ctx->captureFlags[89];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 89);
        glColor4b(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 89);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 89, 4)) goto end;
    writer->putGLbyte(writer, red);
    writer->putGLbyte(writer, green);
    writer->putGLbyte(writer, blue);
    writer->putGLbyte(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(89);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4bv(const GLbyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(90);
    captureFlags = ctx->captureFlags[90];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 90);
        glColor4bv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 90);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 90, 4)) goto end;
    writer->putGLbytev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(90);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(91);
    captureFlags = ctx->captureFlags[91];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 91);
        glColor4d(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 91);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 91, 32)) goto end;
    writer->putGLdouble(writer, red);
    writer->putGLdouble(writer, green);
    writer->putGLdouble(writer, blue);
    writer->putGLdouble(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(91);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(92);
    captureFlags = ctx->captureFlags[92];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 92);
        glColor4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 92);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 92, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(92);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(93);
    captureFlags = ctx->captureFlags[93];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 93);
        glColor4f(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 93);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 93, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(93);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(94);
    captureFlags = ctx->captureFlags[94];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 94);
        glColor4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 94);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 94, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(94);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(95);
    captureFlags = ctx->captureFlags[95];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 95);
        glColor4i(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 95);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 95, 16)) goto end;
    writer->putGLint(writer, red);
    writer->putGLint(writer, green);
    writer->putGLint(writer, blue);
    writer->putGLint(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(95);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(96);
    captureFlags = ctx->captureFlags[96];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 96);
        glColor4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 96);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 96, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(96);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(97);
    captureFlags = ctx->captureFlags[97];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 97);
        glColor4s(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 97);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 97, 8)) goto end;
    writer->putGLshort(writer, red);
    writer->putGLshort(writer, green);
    writer->putGLshort(writer, blue);
    writer->putGLshort(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(97);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(98);
    captureFlags = ctx->captureFlags[98];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 98);
        glColor4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 98);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 98, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(98);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(99);
    captureFlags = ctx->captureFlags[99];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 99);
        glColor4ub(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 99);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 99, 4)) goto end;
    writer->putGLubyte(writer, red);
    writer->putGLubyte(writer, green);
    writer->putGLubyte(writer, blue);
    writer->putGLubyte(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(99);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4ubv(const GLubyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(100);
    captureFlags = ctx->captureFlags[100];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 100);
        glColor4ubv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 100);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 100, 4)) goto end;
    writer->putGLubytev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(100);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(101);
    captureFlags = ctx->captureFlags[101];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 101);
        glColor4ui(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 101);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 101, 16)) goto end;
    writer->putGLuint(writer, red);
    writer->putGLuint(writer, green);
    writer->putGLuint(writer, blue);
    writer->putGLuint(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(101);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4uiv(const GLuint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(102);
    captureFlags = ctx->captureFlags[102];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 102);
        glColor4uiv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 102);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 102, 16)) goto end;
    writer->putGLuintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(102);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(103);
    captureFlags = ctx->captureFlags[103];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 103);
        glColor4us(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 103);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 103, 8)) goto end;
    writer->putGLushort(writer, red);
    writer->putGLushort(writer, green);
    writer->putGLushort(writer, blue);
    writer->putGLushort(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(103);
    --ctx->captureEntryCount;
}

void __gls_capture_glColor4usv(const GLushort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(104);
    captureFlags = ctx->captureFlags[104];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 104);
        glColor4usv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 104);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 104, 8)) goto end;
    writer->putGLushortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(104);
    --ctx->captureEntryCount;
}

void __gls_capture_glEdgeFlag(GLboolean flag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(105);
    captureFlags = ctx->captureFlags[105];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 105);
        glEdgeFlag(flag);
        __GLS_END_CAPTURE_EXEC(ctx, 105);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 105, 1)) goto end;
    writer->putGLboolean(writer, flag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(105);
    --ctx->captureEntryCount;
}

void __gls_capture_glEdgeFlagv(const GLboolean *flag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(106);
    captureFlags = ctx->captureFlags[106];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 106);
        glEdgeFlagv(flag);
        __GLS_END_CAPTURE_EXEC(ctx, 106);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 106, 1)) goto end;
    writer->putGLbooleanv(writer, 1, flag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(106);
    --ctx->captureEntryCount;
}

void __gls_capture_glEnd(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(107);
    captureFlags = ctx->captureFlags[107];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 107);
        glEnd();
        __GLS_END_CAPTURE_EXEC(ctx, 107);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 107, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(107);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexd(GLdouble c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(108);
    captureFlags = ctx->captureFlags[108];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 108);
        glIndexd(c);
        __GLS_END_CAPTURE_EXEC(ctx, 108);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 108, 8)) goto end;
    writer->putGLdouble(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(108);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexdv(const GLdouble *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(109);
    captureFlags = ctx->captureFlags[109];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 109);
        glIndexdv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 109);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 109, 8)) goto end;
    writer->putGLdoublev(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(109);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexf(GLfloat c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(110);
    captureFlags = ctx->captureFlags[110];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 110);
        glIndexf(c);
        __GLS_END_CAPTURE_EXEC(ctx, 110);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 110, 4)) goto end;
    writer->putGLfloat(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(110);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexfv(const GLfloat *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(111);
    captureFlags = ctx->captureFlags[111];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 111);
        glIndexfv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 111);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 111, 4)) goto end;
    writer->putGLfloatv(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(111);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexub(GLubyte c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(379);
    captureFlags = ctx->captureFlags[379];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 379);
        glIndexub(c);
        __GLS_END_CAPTURE_EXEC(ctx, 379);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 379, 1)) goto end;
    writer->putGLubyte(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(379);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexubv(const GLubyte *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(380);
    captureFlags = ctx->captureFlags[380];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 380);
        glIndexubv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 380);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 380, 1)) goto end;
    writer->putGLubytev(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(380);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexi(GLint c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(112);
    captureFlags = ctx->captureFlags[112];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 112);
        glIndexi(c);
        __GLS_END_CAPTURE_EXEC(ctx, 112);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 112, 4)) goto end;
    writer->putGLint(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(112);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexiv(const GLint *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(113);
    captureFlags = ctx->captureFlags[113];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 113);
        glIndexiv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 113);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 113, 4)) goto end;
    writer->putGLintv(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(113);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexs(GLshort c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(114);
    captureFlags = ctx->captureFlags[114];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 114);
        glIndexs(c);
        __GLS_END_CAPTURE_EXEC(ctx, 114);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 114, 2)) goto end;
    writer->putGLshort(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(114);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexsv(const GLshort *c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(115);
    captureFlags = ctx->captureFlags[115];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 115);
        glIndexsv(c);
        __GLS_END_CAPTURE_EXEC(ctx, 115);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 115, 2)) goto end;
    writer->putGLshortv(writer, 1, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(115);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(116);
    captureFlags = ctx->captureFlags[116];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 116);
        glNormal3b(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 116);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 116, 3)) goto end;
    writer->putGLbyte(writer, nx);
    writer->putGLbyte(writer, ny);
    writer->putGLbyte(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(116);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3bv(const GLbyte *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(117);
    captureFlags = ctx->captureFlags[117];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 117);
        glNormal3bv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 117);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 117, 3)) goto end;
    writer->putGLbytev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(117);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(118);
    captureFlags = ctx->captureFlags[118];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 118);
        glNormal3d(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 118);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 118, 24)) goto end;
    writer->putGLdouble(writer, nx);
    writer->putGLdouble(writer, ny);
    writer->putGLdouble(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(118);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(119);
    captureFlags = ctx->captureFlags[119];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 119);
        glNormal3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 119);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 119, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(119);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(120);
    captureFlags = ctx->captureFlags[120];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 120);
        glNormal3f(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 120);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 120, 12)) goto end;
    writer->putGLfloat(writer, nx);
    writer->putGLfloat(writer, ny);
    writer->putGLfloat(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(120);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(121);
    captureFlags = ctx->captureFlags[121];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 121);
        glNormal3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 121);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 121, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(121);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3i(GLint nx, GLint ny, GLint nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(122);
    captureFlags = ctx->captureFlags[122];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 122);
        glNormal3i(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 122);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 122, 12)) goto end;
    writer->putGLint(writer, nx);
    writer->putGLint(writer, ny);
    writer->putGLint(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(122);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(123);
    captureFlags = ctx->captureFlags[123];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 123);
        glNormal3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 123);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 123, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(123);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(124);
    captureFlags = ctx->captureFlags[124];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 124);
        glNormal3s(nx, ny, nz);
        __GLS_END_CAPTURE_EXEC(ctx, 124);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 124, 6)) goto end;
    writer->putGLshort(writer, nx);
    writer->putGLshort(writer, ny);
    writer->putGLshort(writer, nz);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(124);
    --ctx->captureEntryCount;
}

void __gls_capture_glNormal3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(125);
    captureFlags = ctx->captureFlags[125];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 125);
        glNormal3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 125);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 125, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(125);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2d(GLdouble x, GLdouble y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(126);
    captureFlags = ctx->captureFlags[126];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 126);
        glRasterPos2d(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 126);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 126, 16)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(126);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(127);
    captureFlags = ctx->captureFlags[127];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 127);
        glRasterPos2dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 127);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 127, 16)) goto end;
    writer->putGLdoublev(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(127);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2f(GLfloat x, GLfloat y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(128);
    captureFlags = ctx->captureFlags[128];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 128);
        glRasterPos2f(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 128);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 128, 8)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(128);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(129);
    captureFlags = ctx->captureFlags[129];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 129);
        glRasterPos2fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 129);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 129, 8)) goto end;
    writer->putGLfloatv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(129);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2i(GLint x, GLint y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(130);
    captureFlags = ctx->captureFlags[130];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 130);
        glRasterPos2i(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 130);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 130, 8)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(130);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(131);
    captureFlags = ctx->captureFlags[131];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 131);
        glRasterPos2iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 131);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 131, 8)) goto end;
    writer->putGLintv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(131);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2s(GLshort x, GLshort y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(132);
    captureFlags = ctx->captureFlags[132];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 132);
        glRasterPos2s(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 132);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 132, 4)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(132);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos2sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(133);
    captureFlags = ctx->captureFlags[133];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 133);
        glRasterPos2sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 133);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 133, 4)) goto end;
    writer->putGLshortv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(133);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(134);
    captureFlags = ctx->captureFlags[134];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 134);
        glRasterPos3d(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 134);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 134, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(134);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(135);
    captureFlags = ctx->captureFlags[135];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 135);
        glRasterPos3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 135);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 135, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(135);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(136);
    captureFlags = ctx->captureFlags[136];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 136);
        glRasterPos3f(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 136);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 136, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(136);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(137);
    captureFlags = ctx->captureFlags[137];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 137);
        glRasterPos3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 137);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 137, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(137);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3i(GLint x, GLint y, GLint z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(138);
    captureFlags = ctx->captureFlags[138];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 138);
        glRasterPos3i(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 138);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 138, 12)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(138);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(139);
    captureFlags = ctx->captureFlags[139];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 139);
        glRasterPos3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 139);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 139, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(139);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(140);
    captureFlags = ctx->captureFlags[140];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 140);
        glRasterPos3s(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 140);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 140, 6)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(140);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(141);
    captureFlags = ctx->captureFlags[141];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 141);
        glRasterPos3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 141);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 141, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(141);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(142);
    captureFlags = ctx->captureFlags[142];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 142);
        glRasterPos4d(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 142);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 142, 32)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->putGLdouble(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(142);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(143);
    captureFlags = ctx->captureFlags[143];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 143);
        glRasterPos4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 143);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 143, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(143);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(144);
    captureFlags = ctx->captureFlags[144];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 144);
        glRasterPos4f(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 144);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 144, 16)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->putGLfloat(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(144);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(145);
    captureFlags = ctx->captureFlags[145];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 145);
        glRasterPos4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 145);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 145, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(145);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(146);
    captureFlags = ctx->captureFlags[146];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 146);
        glRasterPos4i(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 146);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 146, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->putGLint(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(146);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(147);
    captureFlags = ctx->captureFlags[147];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 147);
        glRasterPos4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 147);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 147, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(147);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(148);
    captureFlags = ctx->captureFlags[148];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 148);
        glRasterPos4s(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 148);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 148, 8)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->putGLshort(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(148);
    --ctx->captureEntryCount;
}

void __gls_capture_glRasterPos4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(149);
    captureFlags = ctx->captureFlags[149];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 149);
        glRasterPos4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 149);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 149, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(149);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(150);
    captureFlags = ctx->captureFlags[150];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 150);
        glRectd(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 150);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 150, 32)) goto end;
    writer->putGLdouble(writer, x1);
    writer->putGLdouble(writer, y1);
    writer->putGLdouble(writer, x2);
    writer->putGLdouble(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(150);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectdv(const GLdouble *v1, const GLdouble *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(151);
    captureFlags = ctx->captureFlags[151];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 151);
        glRectdv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 151);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 151, 32)) goto end;
    writer->putGLdoublev(writer, 2, v1);
    writer->putGLdoublev(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(151);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(152);
    captureFlags = ctx->captureFlags[152];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 152);
        glRectf(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 152);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 152, 16)) goto end;
    writer->putGLfloat(writer, x1);
    writer->putGLfloat(writer, y1);
    writer->putGLfloat(writer, x2);
    writer->putGLfloat(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(152);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectfv(const GLfloat *v1, const GLfloat *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(153);
    captureFlags = ctx->captureFlags[153];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 153);
        glRectfv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 153);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 153, 16)) goto end;
    writer->putGLfloatv(writer, 2, v1);
    writer->putGLfloatv(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(153);
    --ctx->captureEntryCount;
}

void __gls_capture_glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(154);
    captureFlags = ctx->captureFlags[154];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 154);
        glRecti(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 154);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 154, 16)) goto end;
    writer->putGLint(writer, x1);
    writer->putGLint(writer, y1);
    writer->putGLint(writer, x2);
    writer->putGLint(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(154);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectiv(const GLint *v1, const GLint *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(155);
    captureFlags = ctx->captureFlags[155];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 155);
        glRectiv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 155);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 155, 16)) goto end;
    writer->putGLintv(writer, 2, v1);
    writer->putGLintv(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(155);
    --ctx->captureEntryCount;
}

void __gls_capture_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(156);
    captureFlags = ctx->captureFlags[156];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 156);
        glRects(x1, y1, x2, y2);
        __GLS_END_CAPTURE_EXEC(ctx, 156);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 156, 8)) goto end;
    writer->putGLshort(writer, x1);
    writer->putGLshort(writer, y1);
    writer->putGLshort(writer, x2);
    writer->putGLshort(writer, y2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(156);
    --ctx->captureEntryCount;
}

void __gls_capture_glRectsv(const GLshort *v1, const GLshort *v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(157);
    captureFlags = ctx->captureFlags[157];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 157);
        glRectsv(v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 157);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 157, 8)) goto end;
    writer->putGLshortv(writer, 2, v1);
    writer->putGLshortv(writer, 2, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(157);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1d(GLdouble s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(158);
    captureFlags = ctx->captureFlags[158];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 158);
        glTexCoord1d(s);
        __GLS_END_CAPTURE_EXEC(ctx, 158);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 158, 8)) goto end;
    writer->putGLdouble(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(158);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(159);
    captureFlags = ctx->captureFlags[159];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 159);
        glTexCoord1dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 159);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 159, 8)) goto end;
    writer->putGLdoublev(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(159);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1f(GLfloat s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(160);
    captureFlags = ctx->captureFlags[160];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 160);
        glTexCoord1f(s);
        __GLS_END_CAPTURE_EXEC(ctx, 160);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 160, 4)) goto end;
    writer->putGLfloat(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(160);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(161);
    captureFlags = ctx->captureFlags[161];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 161);
        glTexCoord1fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 161);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 161, 4)) goto end;
    writer->putGLfloatv(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(161);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1i(GLint s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(162);
    captureFlags = ctx->captureFlags[162];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 162);
        glTexCoord1i(s);
        __GLS_END_CAPTURE_EXEC(ctx, 162);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 162, 4)) goto end;
    writer->putGLint(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(162);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(163);
    captureFlags = ctx->captureFlags[163];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 163);
        glTexCoord1iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 163);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 163, 4)) goto end;
    writer->putGLintv(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(163);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1s(GLshort s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(164);
    captureFlags = ctx->captureFlags[164];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 164);
        glTexCoord1s(s);
        __GLS_END_CAPTURE_EXEC(ctx, 164);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 164, 2)) goto end;
    writer->putGLshort(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(164);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord1sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(165);
    captureFlags = ctx->captureFlags[165];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 165);
        glTexCoord1sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 165);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 165, 2)) goto end;
    writer->putGLshortv(writer, 1, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(165);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2d(GLdouble s, GLdouble t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(166);
    captureFlags = ctx->captureFlags[166];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 166);
        glTexCoord2d(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 166);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 166, 16)) goto end;
    writer->putGLdouble(writer, s);
    writer->putGLdouble(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(166);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(167);
    captureFlags = ctx->captureFlags[167];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 167);
        glTexCoord2dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 167);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 167, 16)) goto end;
    writer->putGLdoublev(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(167);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2f(GLfloat s, GLfloat t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(168);
    captureFlags = ctx->captureFlags[168];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 168);
        glTexCoord2f(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 168);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 168, 8)) goto end;
    writer->putGLfloat(writer, s);
    writer->putGLfloat(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(168);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(169);
    captureFlags = ctx->captureFlags[169];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 169);
        glTexCoord2fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 169);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 169, 8)) goto end;
    writer->putGLfloatv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(169);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2i(GLint s, GLint t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(170);
    captureFlags = ctx->captureFlags[170];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 170);
        glTexCoord2i(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 170);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 170, 8)) goto end;
    writer->putGLint(writer, s);
    writer->putGLint(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(170);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(171);
    captureFlags = ctx->captureFlags[171];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 171);
        glTexCoord2iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 171);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 171, 8)) goto end;
    writer->putGLintv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(171);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2s(GLshort s, GLshort t) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(172);
    captureFlags = ctx->captureFlags[172];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 172);
        glTexCoord2s(s, t);
        __GLS_END_CAPTURE_EXEC(ctx, 172);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 172, 4)) goto end;
    writer->putGLshort(writer, s);
    writer->putGLshort(writer, t);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(172);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord2sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(173);
    captureFlags = ctx->captureFlags[173];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 173);
        glTexCoord2sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 173);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 173, 4)) goto end;
    writer->putGLshortv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(173);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(174);
    captureFlags = ctx->captureFlags[174];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 174);
        glTexCoord3d(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 174);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 174, 24)) goto end;
    writer->putGLdouble(writer, s);
    writer->putGLdouble(writer, t);
    writer->putGLdouble(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(174);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(175);
    captureFlags = ctx->captureFlags[175];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 175);
        glTexCoord3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 175);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 175, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(175);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(176);
    captureFlags = ctx->captureFlags[176];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 176);
        glTexCoord3f(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 176);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 176, 12)) goto end;
    writer->putGLfloat(writer, s);
    writer->putGLfloat(writer, t);
    writer->putGLfloat(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(176);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(177);
    captureFlags = ctx->captureFlags[177];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 177);
        glTexCoord3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 177);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 177, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(177);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3i(GLint s, GLint t, GLint r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(178);
    captureFlags = ctx->captureFlags[178];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 178);
        glTexCoord3i(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 178);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 178, 12)) goto end;
    writer->putGLint(writer, s);
    writer->putGLint(writer, t);
    writer->putGLint(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(178);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(179);
    captureFlags = ctx->captureFlags[179];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 179);
        glTexCoord3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 179);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 179, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(179);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(180);
    captureFlags = ctx->captureFlags[180];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 180);
        glTexCoord3s(s, t, r);
        __GLS_END_CAPTURE_EXEC(ctx, 180);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 180, 6)) goto end;
    writer->putGLshort(writer, s);
    writer->putGLshort(writer, t);
    writer->putGLshort(writer, r);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(180);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(181);
    captureFlags = ctx->captureFlags[181];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 181);
        glTexCoord3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 181);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 181, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(181);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(182);
    captureFlags = ctx->captureFlags[182];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 182);
        glTexCoord4d(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 182);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 182, 32)) goto end;
    writer->putGLdouble(writer, s);
    writer->putGLdouble(writer, t);
    writer->putGLdouble(writer, r);
    writer->putGLdouble(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(182);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(183);
    captureFlags = ctx->captureFlags[183];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 183);
        glTexCoord4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 183);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 183, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(183);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(184);
    captureFlags = ctx->captureFlags[184];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 184);
        glTexCoord4f(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 184);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 184, 16)) goto end;
    writer->putGLfloat(writer, s);
    writer->putGLfloat(writer, t);
    writer->putGLfloat(writer, r);
    writer->putGLfloat(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(184);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(185);
    captureFlags = ctx->captureFlags[185];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 185);
        glTexCoord4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 185);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 185, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(185);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(186);
    captureFlags = ctx->captureFlags[186];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 186);
        glTexCoord4i(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 186);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 186, 16)) goto end;
    writer->putGLint(writer, s);
    writer->putGLint(writer, t);
    writer->putGLint(writer, r);
    writer->putGLint(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(186);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(187);
    captureFlags = ctx->captureFlags[187];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 187);
        glTexCoord4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 187);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 187, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(187);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(188);
    captureFlags = ctx->captureFlags[188];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 188);
        glTexCoord4s(s, t, r, q);
        __GLS_END_CAPTURE_EXEC(ctx, 188);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 188, 8)) goto end;
    writer->putGLshort(writer, s);
    writer->putGLshort(writer, t);
    writer->putGLshort(writer, r);
    writer->putGLshort(writer, q);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(188);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexCoord4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(189);
    captureFlags = ctx->captureFlags[189];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 189);
        glTexCoord4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 189);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 189, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(189);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2d(GLdouble x, GLdouble y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(190);
    captureFlags = ctx->captureFlags[190];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 190);
        glVertex2d(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 190);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 190, 16)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(190);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(191);
    captureFlags = ctx->captureFlags[191];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 191);
        glVertex2dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 191);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 191, 16)) goto end;
    writer->putGLdoublev(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(191);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2f(GLfloat x, GLfloat y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(192);
    captureFlags = ctx->captureFlags[192];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 192);
        glVertex2f(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 192);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 192, 8)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(192);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(193);
    captureFlags = ctx->captureFlags[193];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 193);
        glVertex2fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 193);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 193, 8)) goto end;
    writer->putGLfloatv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(193);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2i(GLint x, GLint y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(194);
    captureFlags = ctx->captureFlags[194];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 194);
        glVertex2i(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 194);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 194, 8)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(194);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(195);
    captureFlags = ctx->captureFlags[195];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 195);
        glVertex2iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 195);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 195, 8)) goto end;
    writer->putGLintv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(195);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2s(GLshort x, GLshort y) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(196);
    captureFlags = ctx->captureFlags[196];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 196);
        glVertex2s(x, y);
        __GLS_END_CAPTURE_EXEC(ctx, 196);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 196, 4)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(196);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex2sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(197);
    captureFlags = ctx->captureFlags[197];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 197);
        glVertex2sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 197);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 197, 4)) goto end;
    writer->putGLshortv(writer, 2, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(197);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(198);
    captureFlags = ctx->captureFlags[198];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 198);
        glVertex3d(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 198);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 198, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(198);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(199);
    captureFlags = ctx->captureFlags[199];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 199);
        glVertex3dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 199);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 199, 24)) goto end;
    writer->putGLdoublev(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(199);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(200);
    captureFlags = ctx->captureFlags[200];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 200);
        glVertex3f(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 200);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 200, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(200);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(201);
    captureFlags = ctx->captureFlags[201];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 201);
        glVertex3fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 201);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 201, 12)) goto end;
    writer->putGLfloatv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(201);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3i(GLint x, GLint y, GLint z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(202);
    captureFlags = ctx->captureFlags[202];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 202);
        glVertex3i(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 202);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 202, 12)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(202);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(203);
    captureFlags = ctx->captureFlags[203];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 203);
        glVertex3iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 203);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 203, 12)) goto end;
    writer->putGLintv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(203);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3s(GLshort x, GLshort y, GLshort z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(204);
    captureFlags = ctx->captureFlags[204];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 204);
        glVertex3s(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 204);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 204, 6)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(204);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex3sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(205);
    captureFlags = ctx->captureFlags[205];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 205);
        glVertex3sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 205);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 205, 6)) goto end;
    writer->putGLshortv(writer, 3, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(205);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(206);
    captureFlags = ctx->captureFlags[206];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 206);
        glVertex4d(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 206);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 206, 32)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->putGLdouble(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(206);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4dv(const GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(207);
    captureFlags = ctx->captureFlags[207];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 207);
        glVertex4dv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 207);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 207, 32)) goto end;
    writer->putGLdoublev(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(207);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(208);
    captureFlags = ctx->captureFlags[208];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 208);
        glVertex4f(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 208);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 208, 16)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->putGLfloat(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(208);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4fv(const GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(209);
    captureFlags = ctx->captureFlags[209];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 209);
        glVertex4fv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 209);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 209, 16)) goto end;
    writer->putGLfloatv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(209);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(210);
    captureFlags = ctx->captureFlags[210];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 210);
        glVertex4i(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 210);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 210, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, z);
    writer->putGLint(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(210);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4iv(const GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(211);
    captureFlags = ctx->captureFlags[211];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 211);
        glVertex4iv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 211);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 211, 16)) goto end;
    writer->putGLintv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(211);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(212);
    captureFlags = ctx->captureFlags[212];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 212);
        glVertex4s(x, y, z, w);
        __GLS_END_CAPTURE_EXEC(ctx, 212);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 212, 8)) goto end;
    writer->putGLshort(writer, x);
    writer->putGLshort(writer, y);
    writer->putGLshort(writer, z);
    writer->putGLshort(writer, w);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(212);
    --ctx->captureEntryCount;
}

void __gls_capture_glVertex4sv(const GLshort *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(213);
    captureFlags = ctx->captureFlags[213];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 213);
        glVertex4sv(v);
        __GLS_END_CAPTURE_EXEC(ctx, 213);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 213, 8)) goto end;
    writer->putGLshortv(writer, 4, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(213);
    --ctx->captureEntryCount;
}

void __gls_capture_glClipPlane(GLenum plane, const GLdouble *equation) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(214);
    captureFlags = ctx->captureFlags[214];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 214);
        glClipPlane(plane, equation);
        __GLS_END_CAPTURE_EXEC(ctx, 214);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 214, 36)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, plane);
        writer->putGLdoublev(writer, 4, equation);
    } else {
        writer->putGLdoublev(writer, 4, equation);
        writer->putGLenum(writer, plane);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(214);
    --ctx->captureEntryCount;
}

void __gls_capture_glColorMaterial(GLenum face, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(215);
    captureFlags = ctx->captureFlags[215];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 215);
        glColorMaterial(face, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 215);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 215, 8)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(215);
    --ctx->captureEntryCount;
}

void __gls_capture_glCullFace(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(216);
    captureFlags = ctx->captureFlags[216];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 216);
        glCullFace(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 216);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 216, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(216);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogf(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(217);
    captureFlags = ctx->captureFlags[217];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 217);
        glFogf(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 217);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 217, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(217);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogfv(GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(218);
    captureFlags = ctx->captureFlags[218];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 218);
        glFogfv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 218);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glFogfv_params_size(pname);
    if (!writer->beginCommand(writer, 218, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(218);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogi(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(219);
    captureFlags = ctx->captureFlags[219];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 219);
        glFogi(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 219);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 219, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(219);
    --ctx->captureEntryCount;
}

void __gls_capture_glFogiv(GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(220);
    captureFlags = ctx->captureFlags[220];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 220);
        glFogiv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 220);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glFogiv_params_size(pname);
    if (!writer->beginCommand(writer, 220, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(220);
    --ctx->captureEntryCount;
}

void __gls_capture_glFrontFace(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(221);
    captureFlags = ctx->captureFlags[221];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 221);
        glFrontFace(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 221);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 221, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(221);
    --ctx->captureEntryCount;
}

void __gls_capture_glHint(GLenum target, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(222);
    captureFlags = ctx->captureFlags[222];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 222);
        glHint(target, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 222);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 222, 8)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(222);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightf(GLenum light, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(223);
    captureFlags = ctx->captureFlags[223];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 223);
        glLightf(light, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 223);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 223, 12)) goto end;
    writer->putGLenum(writer, light);
    writer->putGLenum(writer, pname);
    writer->putGLfloat(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(223);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightfv(GLenum light, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(224);
    captureFlags = ctx->captureFlags[224];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 224);
        glLightfv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 224);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightfv_params_size(pname);
    if (!writer->beginCommand(writer, 224, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, light);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(224);
    --ctx->captureEntryCount;
}

void __gls_capture_glLighti(GLenum light, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(225);
    captureFlags = ctx->captureFlags[225];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 225);
        glLighti(light, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 225);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 225, 12)) goto end;
    writer->putGLenum(writer, light);
    writer->putGLenum(writer, pname);
    writer->putGLint(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(225);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightiv(GLenum light, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(226);
    captureFlags = ctx->captureFlags[226];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 226);
        glLightiv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 226);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightiv_params_size(pname);
    if (!writer->beginCommand(writer, 226, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, light);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(226);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModelf(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(227);
    captureFlags = ctx->captureFlags[227];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 227);
        glLightModelf(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 227);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 227, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(227);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModelfv(GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(228);
    captureFlags = ctx->captureFlags[228];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 228);
        glLightModelfv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 228);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightModelfv_params_size(pname);
    if (!writer->beginCommand(writer, 228, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(228);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModeli(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(229);
    captureFlags = ctx->captureFlags[229];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 229);
        glLightModeli(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 229);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 229, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(229);
    --ctx->captureEntryCount;
}

void __gls_capture_glLightModeliv(GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(230);
    captureFlags = ctx->captureFlags[230];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 230);
        glLightModeliv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 230);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glLightModeliv_params_size(pname);
    if (!writer->beginCommand(writer, 230, 4 + params_count * 4)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenumv(writer, pname, params_count, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(230);
    --ctx->captureEntryCount;
}

void __gls_capture_glLineStipple(GLint factor, GLushort pattern) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(231);
    captureFlags = ctx->captureFlags[231];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 231);
        glLineStipple(factor, pattern);
        __GLS_END_CAPTURE_EXEC(ctx, 231);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 231, 8)) goto end;
    writer->putGLint(writer, factor);
    writer->putGLushorthex(writer, pattern);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(231);
    --ctx->captureEntryCount;
}

void __gls_capture_glLineWidth(GLfloat width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(232);
    captureFlags = ctx->captureFlags[232];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 232);
        glLineWidth(width);
        __GLS_END_CAPTURE_EXEC(ctx, 232);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 232, 4)) goto end;
    writer->putGLfloat(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(232);
    --ctx->captureEntryCount;
}

void __gls_capture_glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(233);
    captureFlags = ctx->captureFlags[233];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 233);
        glMaterialf(face, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 233);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 233, 12)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, pname);
    writer->putGLfloat(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(233);
    --ctx->captureEntryCount;
}

void __gls_capture_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(234);
    captureFlags = ctx->captureFlags[234];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 234);
        glMaterialfv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 234);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glMaterialfv_params_size(pname);
    if (!writer->beginCommand(writer, 234, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, face);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(234);
    --ctx->captureEntryCount;
}

void __gls_capture_glMateriali(GLenum face, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(235);
    captureFlags = ctx->captureFlags[235];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 235);
        glMateriali(face, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 235);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 235, 12)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, pname);
    writer->putGLint(writer, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(235);
    --ctx->captureEntryCount;
}

void __gls_capture_glMaterialiv(GLenum face, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(236);
    captureFlags = ctx->captureFlags[236];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 236);
        glMaterialiv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 236);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glMaterialiv_params_size(pname);
    if (!writer->beginCommand(writer, 236, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, face);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(236);
    --ctx->captureEntryCount;
}

void __gls_capture_glPointSize(GLfloat size) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(237);
    captureFlags = ctx->captureFlags[237];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 237);
        glPointSize(size);
        __GLS_END_CAPTURE_EXEC(ctx, 237);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 237, 4)) goto end;
    writer->putGLfloat(writer, size);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(237);
    --ctx->captureEntryCount;
}

void __gls_capture_glPolygonMode(GLenum face, GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(238);
    captureFlags = ctx->captureFlags[238];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 238);
        glPolygonMode(face, mode);
        __GLS_END_CAPTURE_EXEC(ctx, 238);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 238, 8)) goto end;
    writer->putGLenum(writer, face);
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(238);
    --ctx->captureEntryCount;
}

void __gls_capture_glPolygonStipple(const GLubyte *mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint mask_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(239);
    captureFlags = ctx->captureFlags[239];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 239);
        glPolygonStipple(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 239);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    mask_count = __gls_glPolygonStipple_mask_size();
    if (!writer->beginCommand(writer, 239, 4 + mask_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    __glsWriter_putPixelv(writer, GL_COLOR_INDEX, GL_BITMAP, 32, 32, mask_count ? mask : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(239);
    --ctx->captureEntryCount;
}

void __gls_capture_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(240);
    captureFlags = ctx->captureFlags[240];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 240);
        glScissor(x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 240);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 240, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(240);
    --ctx->captureEntryCount;
}

void __gls_capture_glShadeModel(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(241);
    captureFlags = ctx->captureFlags[241];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 241);
        glShadeModel(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 241);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 241, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(241);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(242);
    captureFlags = ctx->captureFlags[242];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 242);
        glTexParameterf(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 242);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 242, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(242);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(243);
    captureFlags = ctx->captureFlags[243];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 243);
        glTexParameterfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 243);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexParameterfv_params_size(pname);
    if (!writer->beginCommand(writer, 243, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(243);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameteri(GLenum target, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(244);
    captureFlags = ctx->captureFlags[244];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 244);
        glTexParameteri(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 244);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 244, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(244);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(245);
    captureFlags = ctx->captureFlags[245];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 245);
        glTexParameteriv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 245);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexParameteriv_params_size(pname);
    if (!writer->beginCommand(writer, 245, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(245);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(246);
    captureFlags = ctx->captureFlags[246];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 246);
        glTexImage1D(target, level, components, width, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 246);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage1D_pixels_size(format, type, width) : 0;
    if (!writer->beginCommand(writer, 246, 32 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, width);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(246);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(247);
    captureFlags = ctx->captureFlags[247];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 247);
        glTexImage2D(target, level, components, width, height, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 247);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage2D_pixels_size(format, type, width, height) : 0;
    if (!writer->beginCommand(writer, 247, 36 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLtextureComponentCount(writer, components);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(247);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(248);
    captureFlags = ctx->captureFlags[248];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 248);
        glTexEnvf(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 248);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 248, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(248);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(249);
    captureFlags = ctx->captureFlags[249];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 249);
        glTexEnvfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 249);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexEnvfv_params_size(pname);
    if (!writer->beginCommand(writer, 249, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(249);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnvi(GLenum target, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(250);
    captureFlags = ctx->captureFlags[250];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 250);
        glTexEnvi(target, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 250);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 250, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(250);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexEnviv(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(251);
    captureFlags = ctx->captureFlags[251];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 251);
        glTexEnviv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 251);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexEnviv_params_size(pname);
    if (!writer->beginCommand(writer, 251, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(251);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(252);
    captureFlags = ctx->captureFlags[252];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 252);
        glTexGend(coord, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 252);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 252, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLdoubleOrGLenum(writer, pname, param);
    } else {
        writer->putGLdoubleOrGLenum(writer, pname, param);
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(252);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(253);
    captureFlags = ctx->captureFlags[253];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 253);
        glTexGendv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 253);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexGendv_params_size(pname);
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 253, 8 + params_count * 8)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLdoubleOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLdoubleOrGLenumv(writer, pname, params_count, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(253);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(254);
    captureFlags = ctx->captureFlags[254];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 254);
        glTexGenf(coord, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 254);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 254, 12)) goto end;
    writer->putGLenum(writer, coord);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(254);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(255);
    captureFlags = ctx->captureFlags[255];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 255);
        glTexGenfv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 255);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexGenfv_params_size(pname);
    if (!writer->beginCommand(writer, 255, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, coord);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(255);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGeni(GLenum coord, GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(256);
    captureFlags = ctx->captureFlags[256];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 256);
        glTexGeni(coord, pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 256);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 256, 12)) goto end;
    writer->putGLenum(writer, coord);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(256);
    --ctx->captureEntryCount;
}

void __gls_capture_glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(257);
    captureFlags = ctx->captureFlags[257];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 257);
        glTexGeniv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 257);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexGeniv_params_size(pname);
    if (!writer->beginCommand(writer, 257, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, coord);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(257);
    --ctx->captureEntryCount;
}

void __gls_capture_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(258);
    captureFlags = ctx->captureFlags[258];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 258);
        glFeedbackBuffer(size, type, buffer);
        __GLS_END_CAPTURE_EXEC(ctx, 258);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 258, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, size);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, buffer);
    } else {
        writer->putGLint(writer, size);
        writer->putGLoutArg(writer, 0, buffer);
        writer->putGLenum(writer, type);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(258);
    --ctx->captureEntryCount;
}

void __gls_capture_glSelectBuffer(GLsizei size, GLuint *buffer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(259);
    captureFlags = ctx->captureFlags[259];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 259);
        glSelectBuffer(size, buffer);
        __GLS_END_CAPTURE_EXEC(ctx, 259);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 259, 12)) goto end;
    writer->putGLint(writer, size);
    writer->putGLoutArg(writer, 0, buffer);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(259);
    --ctx->captureEntryCount;
}

GLint __gls_capture_glRenderMode(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(260);
    captureFlags = ctx->captureFlags[260];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 260);
        _outVal = glRenderMode(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 260);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 260, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(260);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glInitNames(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(261);
    captureFlags = ctx->captureFlags[261];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 261);
        glInitNames();
        __GLS_END_CAPTURE_EXEC(ctx, 261);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 261, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(261);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadName(GLuint name) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(262);
    captureFlags = ctx->captureFlags[262];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 262);
        glLoadName(name);
        __GLS_END_CAPTURE_EXEC(ctx, 262);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 262, 4)) goto end;
    writer->putGLuint(writer, name);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(262);
    --ctx->captureEntryCount;
}

void __gls_capture_glPassThrough(GLfloat token) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(263);
    captureFlags = ctx->captureFlags[263];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 263);
        glPassThrough(token);
        __GLS_END_CAPTURE_EXEC(ctx, 263);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 263, 4)) goto end;
    writer->putGLfloat(writer, token);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(263);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopName(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(264);
    captureFlags = ctx->captureFlags[264];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 264);
        glPopName();
        __GLS_END_CAPTURE_EXEC(ctx, 264);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 264, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(264);
    --ctx->captureEntryCount;
}

void __gls_capture_glPushName(GLuint name) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(265);
    captureFlags = ctx->captureFlags[265];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 265);
        glPushName(name);
        __GLS_END_CAPTURE_EXEC(ctx, 265);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 265, 4)) goto end;
    writer->putGLuint(writer, name);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(265);
    --ctx->captureEntryCount;
}

void __gls_capture_glDrawBuffer(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(266);
    captureFlags = ctx->captureFlags[266];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 266);
        glDrawBuffer(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 266);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 266, 4)) goto end;
    writer->putGLdrawBufferMode(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(266);
    --ctx->captureEntryCount;
}

void __gls_capture_glClear(GLbitfield mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(267);
    captureFlags = ctx->captureFlags[267];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 267);
        glClear(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 267);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 267, 4)) goto end;
    writer->putGLclearBufferMask(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(267);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(268);
    captureFlags = ctx->captureFlags[268];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 268);
        glClearAccum(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 268);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 268, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(268);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearIndex(GLfloat c) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(269);
    captureFlags = ctx->captureFlags[269];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 269);
        glClearIndex(c);
        __GLS_END_CAPTURE_EXEC(ctx, 269);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 269, 4)) goto end;
    writer->putGLfloat(writer, c);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(269);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(270);
    captureFlags = ctx->captureFlags[270];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 270);
        glClearColor(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 270);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 270, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(270);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearStencil(GLint s) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(271);
    captureFlags = ctx->captureFlags[271];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 271);
        glClearStencil(s);
        __GLS_END_CAPTURE_EXEC(ctx, 271);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 271, 4)) goto end;
    writer->putGLint(writer, s);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(271);
    --ctx->captureEntryCount;
}

void __gls_capture_glClearDepth(GLclampd depth) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(272);
    captureFlags = ctx->captureFlags[272];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 272);
        glClearDepth(depth);
        __GLS_END_CAPTURE_EXEC(ctx, 272);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 272, 8)) goto end;
    writer->putGLdouble(writer, depth);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(272);
    --ctx->captureEntryCount;
}

void __gls_capture_glStencilMask(GLuint mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(273);
    captureFlags = ctx->captureFlags[273];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 273);
        glStencilMask(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 273);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 273, 4)) goto end;
    writer->putGLuinthex(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(273);
    --ctx->captureEntryCount;
}

void __gls_capture_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(274);
    captureFlags = ctx->captureFlags[274];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 274);
        glColorMask(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 274);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 274, 4)) goto end;
    writer->putGLboolean(writer, red);
    writer->putGLboolean(writer, green);
    writer->putGLboolean(writer, blue);
    writer->putGLboolean(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(274);
    --ctx->captureEntryCount;
}

void __gls_capture_glDepthMask(GLboolean flag) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(275);
    captureFlags = ctx->captureFlags[275];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 275);
        glDepthMask(flag);
        __GLS_END_CAPTURE_EXEC(ctx, 275);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 275, 1)) goto end;
    writer->putGLboolean(writer, flag);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(275);
    --ctx->captureEntryCount;
}

void __gls_capture_glIndexMask(GLuint mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(276);
    captureFlags = ctx->captureFlags[276];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 276);
        glIndexMask(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 276);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 276, 4)) goto end;
    writer->putGLuinthex(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(276);
    --ctx->captureEntryCount;
}

void __gls_capture_glAccum(GLenum op, GLfloat value) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(277);
    captureFlags = ctx->captureFlags[277];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 277);
        glAccum(op, value);
        __GLS_END_CAPTURE_EXEC(ctx, 277);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 277, 8)) goto end;
    writer->putGLenum(writer, op);
    writer->putGLfloat(writer, value);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(277);
    --ctx->captureEntryCount;
}

void __gls_capture_glDisable(GLenum cap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(278);
    captureFlags = ctx->captureFlags[278];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 278);
        glDisable(cap);
        __GLS_END_CAPTURE_EXEC(ctx, 278);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 278, 4)) goto end;
    writer->putGLenum(writer, cap);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(278);
    --ctx->captureEntryCount;
}

void __gls_capture_glEnable(GLenum cap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(279);
    captureFlags = ctx->captureFlags[279];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 279);
        glEnable(cap);
        __GLS_END_CAPTURE_EXEC(ctx, 279);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 279, 4)) goto end;
    writer->putGLenum(writer, cap);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(279);
    --ctx->captureEntryCount;
}

void __gls_capture_glFinish(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(280);
    captureFlags = ctx->captureFlags[280];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 280);
        glFinish();
        __GLS_END_CAPTURE_EXEC(ctx, 280);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 280, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(280);
    --ctx->captureEntryCount;
}

void __gls_capture_glFlush(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(281);
    captureFlags = ctx->captureFlags[281];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 281);
        glFlush();
        __GLS_END_CAPTURE_EXEC(ctx, 281);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 281, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(281);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopAttrib(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(282);
    captureFlags = ctx->captureFlags[282];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 282);
        glPopAttrib();
        __GLS_END_CAPTURE_EXEC(ctx, 282);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 282, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(282);
    --ctx->captureEntryCount;
}

void __gls_capture_glPushAttrib(GLbitfield mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(283);
    captureFlags = ctx->captureFlags[283];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 283);
        glPushAttrib(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 283);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 283, 4)) goto end;
    writer->putGLattribMask(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(283);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(288);
    captureFlags = ctx->captureFlags[288];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 288);
        glMapGrid1d(un, u1, u2);
        __GLS_END_CAPTURE_EXEC(ctx, 288);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 288, 20)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, un);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
    } else {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, un);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(288);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(289);
    captureFlags = ctx->captureFlags[289];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 289);
        glMapGrid1f(un, u1, u2);
        __GLS_END_CAPTURE_EXEC(ctx, 289);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 289, 12)) goto end;
    writer->putGLint(writer, un);
    writer->putGLfloat(writer, u1);
    writer->putGLfloat(writer, u2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(289);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(290);
    captureFlags = ctx->captureFlags[290];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 290);
        glMapGrid2d(un, u1, u2, vn, v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 290);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 290, 40)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, un);
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLint(writer, vn);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
    } else {
        writer->putGLdouble(writer, u1);
        writer->putGLdouble(writer, u2);
        writer->putGLdouble(writer, v1);
        writer->putGLdouble(writer, v2);
        writer->putGLint(writer, un);
        writer->putGLint(writer, vn);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(290);
    --ctx->captureEntryCount;
}

void __gls_capture_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(291);
    captureFlags = ctx->captureFlags[291];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 291);
        glMapGrid2f(un, u1, u2, vn, v1, v2);
        __GLS_END_CAPTURE_EXEC(ctx, 291);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 291, 24)) goto end;
    writer->putGLint(writer, un);
    writer->putGLfloat(writer, u1);
    writer->putGLfloat(writer, u2);
    writer->putGLint(writer, vn);
    writer->putGLfloat(writer, v1);
    writer->putGLfloat(writer, v2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(291);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1d(GLdouble u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(292);
    captureFlags = ctx->captureFlags[292];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 292);
        glEvalCoord1d(u);
        __GLS_END_CAPTURE_EXEC(ctx, 292);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 292, 8)) goto end;
    writer->putGLdouble(writer, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(292);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1dv(const GLdouble *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(293);
    captureFlags = ctx->captureFlags[293];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 293);
        glEvalCoord1dv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 293);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 293, 8)) goto end;
    writer->putGLdoublev(writer, 1, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(293);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1f(GLfloat u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(294);
    captureFlags = ctx->captureFlags[294];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 294);
        glEvalCoord1f(u);
        __GLS_END_CAPTURE_EXEC(ctx, 294);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 294, 4)) goto end;
    writer->putGLfloat(writer, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(294);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord1fv(const GLfloat *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(295);
    captureFlags = ctx->captureFlags[295];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 295);
        glEvalCoord1fv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 295);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 295, 4)) goto end;
    writer->putGLfloatv(writer, 1, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(295);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2d(GLdouble u, GLdouble v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(296);
    captureFlags = ctx->captureFlags[296];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 296);
        glEvalCoord2d(u, v);
        __GLS_END_CAPTURE_EXEC(ctx, 296);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 296, 16)) goto end;
    writer->putGLdouble(writer, u);
    writer->putGLdouble(writer, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(296);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2dv(const GLdouble *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(297);
    captureFlags = ctx->captureFlags[297];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 297);
        glEvalCoord2dv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 297);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 297, 16)) goto end;
    writer->putGLdoublev(writer, 2, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(297);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2f(GLfloat u, GLfloat v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(298);
    captureFlags = ctx->captureFlags[298];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 298);
        glEvalCoord2f(u, v);
        __GLS_END_CAPTURE_EXEC(ctx, 298);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 298, 8)) goto end;
    writer->putGLfloat(writer, u);
    writer->putGLfloat(writer, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(298);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalCoord2fv(const GLfloat *u) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(299);
    captureFlags = ctx->captureFlags[299];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 299);
        glEvalCoord2fv(u);
        __GLS_END_CAPTURE_EXEC(ctx, 299);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 299, 8)) goto end;
    writer->putGLfloatv(writer, 2, u);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(299);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(300);
    captureFlags = ctx->captureFlags[300];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 300);
        glEvalMesh1(mode, i1, i2);
        __GLS_END_CAPTURE_EXEC(ctx, 300);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 300, 12)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, i1);
    writer->putGLint(writer, i2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(300);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalPoint1(GLint i) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(301);
    captureFlags = ctx->captureFlags[301];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 301);
        glEvalPoint1(i);
        __GLS_END_CAPTURE_EXEC(ctx, 301);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 301, 4)) goto end;
    writer->putGLint(writer, i);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(301);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(302);
    captureFlags = ctx->captureFlags[302];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 302);
        glEvalMesh2(mode, i1, i2, j1, j2);
        __GLS_END_CAPTURE_EXEC(ctx, 302);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 302, 20)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, i1);
    writer->putGLint(writer, i2);
    writer->putGLint(writer, j1);
    writer->putGLint(writer, j2);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(302);
    --ctx->captureEntryCount;
}

void __gls_capture_glEvalPoint2(GLint i, GLint j) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(303);
    captureFlags = ctx->captureFlags[303];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 303);
        glEvalPoint2(i, j);
        __GLS_END_CAPTURE_EXEC(ctx, 303);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 303, 8)) goto end;
    writer->putGLint(writer, i);
    writer->putGLint(writer, j);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(303);
    --ctx->captureEntryCount;
}

void __gls_capture_glAlphaFunc(GLenum func, GLclampf ref) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(304);
    captureFlags = ctx->captureFlags[304];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 304);
        glAlphaFunc(func, ref);
        __GLS_END_CAPTURE_EXEC(ctx, 304);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 304, 8)) goto end;
    writer->putGLenum(writer, func);
    writer->putGLfloat(writer, ref);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(304);
    --ctx->captureEntryCount;
}

void __gls_capture_glBlendFunc(GLenum sfactor, GLenum dfactor) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(305);
    captureFlags = ctx->captureFlags[305];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 305);
        glBlendFunc(sfactor, dfactor);
        __GLS_END_CAPTURE_EXEC(ctx, 305);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 305, 8)) goto end;
    writer->putGLblendingFactor(writer, sfactor);
    writer->putGLblendingFactor(writer, dfactor);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(305);
    --ctx->captureEntryCount;
}

void __gls_capture_glLogicOp(GLenum opcode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(306);
    captureFlags = ctx->captureFlags[306];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 306);
        glLogicOp(opcode);
        __GLS_END_CAPTURE_EXEC(ctx, 306);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 306, 4)) goto end;
    writer->putGLenum(writer, opcode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(306);
    --ctx->captureEntryCount;
}

void __gls_capture_glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(307);
    captureFlags = ctx->captureFlags[307];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 307);
        glStencilFunc(func, ref, mask);
        __GLS_END_CAPTURE_EXEC(ctx, 307);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 307, 12)) goto end;
    writer->putGLenum(writer, func);
    writer->putGLint(writer, ref);
    writer->putGLuinthex(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(307);
    --ctx->captureEntryCount;
}

void __gls_capture_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(308);
    captureFlags = ctx->captureFlags[308];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 308);
        glStencilOp(fail, zfail, zpass);
        __GLS_END_CAPTURE_EXEC(ctx, 308);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 308, 12)) goto end;
    writer->putGLstencilOp(writer, fail);
    writer->putGLstencilOp(writer, zfail);
    writer->putGLstencilOp(writer, zpass);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(308);
    --ctx->captureEntryCount;
}

void __gls_capture_glDepthFunc(GLenum func) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(309);
    captureFlags = ctx->captureFlags[309];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 309);
        glDepthFunc(func);
        __GLS_END_CAPTURE_EXEC(ctx, 309);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 309, 4)) goto end;
    writer->putGLenum(writer, func);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(309);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(310);
    captureFlags = ctx->captureFlags[310];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 310);
        glPixelZoom(xfactor, yfactor);
        __GLS_END_CAPTURE_EXEC(ctx, 310);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 310, 8)) goto end;
    writer->putGLfloat(writer, xfactor);
    writer->putGLfloat(writer, yfactor);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(310);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelTransferf(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(311);
    captureFlags = ctx->captureFlags[311];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 311);
        glPixelTransferf(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 311);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 311, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(311);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelTransferi(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(312);
    captureFlags = ctx->captureFlags[312];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 312);
        glPixelTransferi(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 312);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 312, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(312);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelStoref(GLenum pname, GLfloat param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(313);
    captureFlags = ctx->captureFlags[313];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 313);
        glPixelStoref(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 313);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 313, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(313);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelStorei(GLenum pname, GLint param) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(314);
    captureFlags = ctx->captureFlags[314];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 314);
        glPixelStorei(pname, param);
        __GLS_END_CAPTURE_EXEC(ctx, 314);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 314, 8)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, param);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(314);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(315);
    captureFlags = ctx->captureFlags[315];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 315);
        glPixelMapfv(map, mapsize, values);
        __GLS_END_CAPTURE_EXEC(ctx, 315);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 315, 8 + __GLS_MAX(mapsize, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, map);
        writer->putGLint(writer, mapsize);
        writer->putGLfloatv(writer, __GLS_MAX(mapsize, 0), values);
    } else {
        writer->putGLint(writer, mapsize);
        writer->putGLenum(writer, map);
        writer->putGLfloatv(writer, __GLS_MAX(mapsize, 0), values);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(315);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(316);
    captureFlags = ctx->captureFlags[316];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 316);
        glPixelMapuiv(map, mapsize, values);
        __GLS_END_CAPTURE_EXEC(ctx, 316);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 316, 8 + __GLS_MAX(mapsize, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, map);
        writer->putGLint(writer, mapsize);
        writer->putGLuintv(writer, __GLS_MAX(mapsize, 0), values);
    } else {
        writer->putGLint(writer, mapsize);
        writer->putGLenum(writer, map);
        writer->putGLuintv(writer, __GLS_MAX(mapsize, 0), values);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(316);
    --ctx->captureEntryCount;
}

void __gls_capture_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(317);
    captureFlags = ctx->captureFlags[317];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 317);
        glPixelMapusv(map, mapsize, values);
        __GLS_END_CAPTURE_EXEC(ctx, 317);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 317, 8 + __GLS_MAX(mapsize, 0) * 2)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, map);
        writer->putGLint(writer, mapsize);
        writer->putGLushortv(writer, __GLS_MAX(mapsize, 0), values);
    } else {
        writer->putGLint(writer, mapsize);
        writer->putGLenum(writer, map);
        writer->putGLushortv(writer, __GLS_MAX(mapsize, 0), values);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(317);
    --ctx->captureEntryCount;
}

void __gls_capture_glReadBuffer(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(318);
    captureFlags = ctx->captureFlags[318];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 318);
        glReadBuffer(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 318);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 318, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(318);
    --ctx->captureEntryCount;
}

void __gls_capture_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(319);
    captureFlags = ctx->captureFlags[319];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 319);
        glCopyPixels(x, y, width, height, type);
        __GLS_END_CAPTURE_EXEC(ctx, 319);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 319, 20)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLenum(writer, type);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(319);
    --ctx->captureEntryCount;
}

void __gls_capture_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(320);
    captureFlags = ctx->captureFlags[320];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 320);
        glReadPixels(x, y, width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 320);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 320, 32)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, x);
        writer->putGLint(writer, y);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, pixels);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, pixels);
        writer->putGLint(writer, x);
        writer->putGLint(writer, y);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(320);
    --ctx->captureEntryCount;
}

void __gls_capture_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(321);
    captureFlags = ctx->captureFlags[321];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 321);
        glDrawPixels(width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 321);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glDrawPixels_pixels_size(format, type, width, height);
    if (!writer->beginCommand(writer, 321, 20 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(321);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetBooleanv(GLenum pname, GLboolean *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(322);
    captureFlags = ctx->captureFlags[322];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 322);
        glGetBooleanv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 322);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 322, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(322);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetClipPlane(GLenum plane, GLdouble *equation) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(323);
    captureFlags = ctx->captureFlags[323];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 323);
        glGetClipPlane(plane, equation);
        __GLS_END_CAPTURE_EXEC(ctx, 323);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 323, 12)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, plane);
        writer->putGLoutArg(writer, 0, equation);
    } else {
        writer->putGLoutArg(writer, 0, equation);
        writer->putGLenum(writer, plane);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(323);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetDoublev(GLenum pname, GLdouble *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(324);
    captureFlags = ctx->captureFlags[324];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 324);
        glGetDoublev(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 324);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 324, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(324);
    --ctx->captureEntryCount;
}

GLenum __gls_capture_glGetError(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLenum _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(325);
    captureFlags = ctx->captureFlags[325];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 325);
        _outVal = glGetError();
        __GLS_END_CAPTURE_EXEC(ctx, 325);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 325, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(325);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glGetFloatv(GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(326);
    captureFlags = ctx->captureFlags[326];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 326);
        glGetFloatv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 326);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 326, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(326);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetIntegerv(GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(327);
    captureFlags = ctx->captureFlags[327];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 327);
        glGetIntegerv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 327);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 327, 12)) goto end;
    writer->putGLenum(writer, pname);
    writer->putGLoutArg(writer, 0, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(327);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(328);
    captureFlags = ctx->captureFlags[328];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 328);
        glGetLightfv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 328);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 328, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, light);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(328);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetLightiv(GLenum light, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(329);
    captureFlags = ctx->captureFlags[329];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 329);
        glGetLightiv(light, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 329);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 329, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, light);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, light);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(329);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMapdv(GLenum target, GLenum query, GLdouble *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(330);
    captureFlags = ctx->captureFlags[330];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 330);
        glGetMapdv(target, query, v);
        __GLS_END_CAPTURE_EXEC(ctx, 330);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 330, 16)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, query);
    writer->putGLoutArg(writer, 0, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(330);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMapfv(GLenum target, GLenum query, GLfloat *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(331);
    captureFlags = ctx->captureFlags[331];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 331);
        glGetMapfv(target, query, v);
        __GLS_END_CAPTURE_EXEC(ctx, 331);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 331, 16)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, query);
    writer->putGLoutArg(writer, 0, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(331);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMapiv(GLenum target, GLenum query, GLint *v) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(332);
    captureFlags = ctx->captureFlags[332];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 332);
        glGetMapiv(target, query, v);
        __GLS_END_CAPTURE_EXEC(ctx, 332);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 332, 16)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, query);
    writer->putGLoutArg(writer, 0, v);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(332);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(333);
    captureFlags = ctx->captureFlags[333];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 333);
        glGetMaterialfv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 333);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 333, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, face);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(333);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(334);
    captureFlags = ctx->captureFlags[334];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 334);
        glGetMaterialiv(face, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 334);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 334, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, face);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, face);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(334);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPixelMapfv(GLenum map, GLfloat *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(335);
    captureFlags = ctx->captureFlags[335];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 335);
        glGetPixelMapfv(map, values);
        __GLS_END_CAPTURE_EXEC(ctx, 335);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 335, 12)) goto end;
    writer->putGLenum(writer, map);
    writer->putGLoutArg(writer, 0, values);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(335);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPixelMapuiv(GLenum map, GLuint *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(336);
    captureFlags = ctx->captureFlags[336];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 336);
        glGetPixelMapuiv(map, values);
        __GLS_END_CAPTURE_EXEC(ctx, 336);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 336, 12)) goto end;
    writer->putGLenum(writer, map);
    writer->putGLoutArg(writer, 0, values);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(336);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPixelMapusv(GLenum map, GLushort *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(337);
    captureFlags = ctx->captureFlags[337];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 337);
        glGetPixelMapusv(map, values);
        __GLS_END_CAPTURE_EXEC(ctx, 337);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 337, 12)) goto end;
    writer->putGLenum(writer, map);
    writer->putGLoutArg(writer, 0, values);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(337);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetPolygonStipple(GLubyte *mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(338);
    captureFlags = ctx->captureFlags[338];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 338);
        glGetPolygonStipple(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 338);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 338, 8)) goto end;
    writer->putGLoutArg(writer, 0, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(338);
    --ctx->captureEntryCount;
}

const GLubyte * __gls_capture_glGetString(GLenum name) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    const GLubyte * _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(339);
    captureFlags = ctx->captureFlags[339];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 339);
        _outVal = glGetString(name);
        __GLS_END_CAPTURE_EXEC(ctx, 339);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 339, 4)) goto end;
    writer->putGLenum(writer, name);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(339);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(340);
    captureFlags = ctx->captureFlags[340];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 340);
        glGetTexEnvfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 340);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 340, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(340);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(341);
    captureFlags = ctx->captureFlags[341];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 341);
        glGetTexEnviv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 341);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 341, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(341);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(342);
    captureFlags = ctx->captureFlags[342];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 342);
        glGetTexGendv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 342);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 342, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(342);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(343);
    captureFlags = ctx->captureFlags[343];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 343);
        glGetTexGenfv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 343);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 343, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(343);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(344);
    captureFlags = ctx->captureFlags[344];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 344);
        glGetTexGeniv(coord, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 344);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 344, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, coord);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, coord);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(344);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(345);
    captureFlags = ctx->captureFlags[345];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 345);
        glGetTexImage(target, level, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 345);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 345, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, pixels);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(345);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(346);
    captureFlags = ctx->captureFlags[346];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 346);
        glGetTexParameterfv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 346);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 346, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(346);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(347);
    captureFlags = ctx->captureFlags[347];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 347);
        glGetTexParameteriv(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 347);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 347, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(347);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(348);
    captureFlags = ctx->captureFlags[348];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 348);
        glGetTexLevelParameterfv(target, level, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 348);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 348, 20)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(348);
    --ctx->captureEntryCount;
}

void __gls_capture_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(349);
    captureFlags = ctx->captureFlags[349];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 349);
        glGetTexLevelParameteriv(target, level, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 349);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 349, 20)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(349);
    --ctx->captureEntryCount;
}

GLboolean __gls_capture_glIsEnabled(GLenum cap) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(350);
    captureFlags = ctx->captureFlags[350];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 350);
        _outVal = glIsEnabled(cap);
        __GLS_END_CAPTURE_EXEC(ctx, 350);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 350, 4)) goto end;
    writer->putGLenum(writer, cap);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(350);
    --ctx->captureEntryCount;
    return _outVal;
}

GLboolean __gls_capture_glIsList(GLuint list) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(351);
    captureFlags = ctx->captureFlags[351];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 351);
        _outVal = glIsList(list);
        __GLS_END_CAPTURE_EXEC(ctx, 351);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 351, 4)) goto end;
    writer->putGLuint(writer, list);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(351);
    --ctx->captureEntryCount;
    return _outVal;
}

void __gls_capture_glDepthRange(GLclampd zNear, GLclampd zFar) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(352);
    captureFlags = ctx->captureFlags[352];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 352);
        glDepthRange(zNear, zFar);
        __GLS_END_CAPTURE_EXEC(ctx, 352);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 352, 16)) goto end;
    writer->putGLdouble(writer, zNear);
    writer->putGLdouble(writer, zFar);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(352);
    --ctx->captureEntryCount;
}

void __gls_capture_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(353);
    captureFlags = ctx->captureFlags[353];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 353);
        glFrustum(left, right, bottom, top, zNear, zFar);
        __GLS_END_CAPTURE_EXEC(ctx, 353);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 353, 48)) goto end;
    writer->putGLdouble(writer, left);
    writer->putGLdouble(writer, right);
    writer->putGLdouble(writer, bottom);
    writer->putGLdouble(writer, top);
    writer->putGLdouble(writer, zNear);
    writer->putGLdouble(writer, zFar);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(353);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadIdentity(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(354);
    captureFlags = ctx->captureFlags[354];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 354);
        glLoadIdentity();
        __GLS_END_CAPTURE_EXEC(ctx, 354);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 354, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(354);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadMatrixf(const GLfloat *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(355);
    captureFlags = ctx->captureFlags[355];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 355);
        glLoadMatrixf(m);
        __GLS_END_CAPTURE_EXEC(ctx, 355);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 355, 64)) goto end;
    writer->putGLfloatm(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(355);
    --ctx->captureEntryCount;
}

void __gls_capture_glLoadMatrixd(const GLdouble *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(356);
    captureFlags = ctx->captureFlags[356];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 356);
        glLoadMatrixd(m);
        __GLS_END_CAPTURE_EXEC(ctx, 356);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 356, 128)) goto end;
    writer->putGLdoublem(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(356);
    --ctx->captureEntryCount;
}

void __gls_capture_glMatrixMode(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(357);
    captureFlags = ctx->captureFlags[357];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 357);
        glMatrixMode(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 357);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 357, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(357);
    --ctx->captureEntryCount;
}

void __gls_capture_glMultMatrixf(const GLfloat *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(358);
    captureFlags = ctx->captureFlags[358];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 358);
        glMultMatrixf(m);
        __GLS_END_CAPTURE_EXEC(ctx, 358);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 358, 64)) goto end;
    writer->putGLfloatm(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(358);
    --ctx->captureEntryCount;
}

void __gls_capture_glMultMatrixd(const GLdouble *m) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(359);
    captureFlags = ctx->captureFlags[359];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 359);
        glMultMatrixd(m);
        __GLS_END_CAPTURE_EXEC(ctx, 359);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 359, 128)) goto end;
    writer->putGLdoublem(writer, m);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(359);
    --ctx->captureEntryCount;
}

void __gls_capture_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(360);
    captureFlags = ctx->captureFlags[360];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 360);
        glOrtho(left, right, bottom, top, zNear, zFar);
        __GLS_END_CAPTURE_EXEC(ctx, 360);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 360, 48)) goto end;
    writer->putGLdouble(writer, left);
    writer->putGLdouble(writer, right);
    writer->putGLdouble(writer, bottom);
    writer->putGLdouble(writer, top);
    writer->putGLdouble(writer, zNear);
    writer->putGLdouble(writer, zFar);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(360);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopMatrix(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(361);
    captureFlags = ctx->captureFlags[361];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 361);
        glPopMatrix();
        __GLS_END_CAPTURE_EXEC(ctx, 361);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 361, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(361);
    --ctx->captureEntryCount;
}

void __gls_capture_glPushMatrix(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(362);
    captureFlags = ctx->captureFlags[362];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 362);
        glPushMatrix();
        __GLS_END_CAPTURE_EXEC(ctx, 362);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 362, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(362);
    --ctx->captureEntryCount;
}

void __gls_capture_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(363);
    captureFlags = ctx->captureFlags[363];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 363);
        glRotated(angle, x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 363);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 363, 32)) goto end;
    writer->putGLdouble(writer, angle);
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(363);
    --ctx->captureEntryCount;
}

void __gls_capture_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(364);
    captureFlags = ctx->captureFlags[364];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 364);
        glRotatef(angle, x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 364);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 364, 16)) goto end;
    writer->putGLfloat(writer, angle);
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(364);
    --ctx->captureEntryCount;
}

void __gls_capture_glScaled(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(365);
    captureFlags = ctx->captureFlags[365];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 365);
        glScaled(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 365);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 365, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(365);
    --ctx->captureEntryCount;
}

void __gls_capture_glScalef(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(366);
    captureFlags = ctx->captureFlags[366];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 366);
        glScalef(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 366);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 366, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(366);
    --ctx->captureEntryCount;
}

void __gls_capture_glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(367);
    captureFlags = ctx->captureFlags[367];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 367);
        glTranslated(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 367);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 367, 24)) goto end;
    writer->putGLdouble(writer, x);
    writer->putGLdouble(writer, y);
    writer->putGLdouble(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(367);
    --ctx->captureEntryCount;
}

void __gls_capture_glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(368);
    captureFlags = ctx->captureFlags[368];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 368);
        glTranslatef(x, y, z);
        __GLS_END_CAPTURE_EXEC(ctx, 368);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 368, 12)) goto end;
    writer->putGLfloat(writer, x);
    writer->putGLfloat(writer, y);
    writer->putGLfloat(writer, z);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(368);
    --ctx->captureEntryCount;
}

void __gls_capture_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(369);
    captureFlags = ctx->captureFlags[369];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 369);
        glViewport(x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 369);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 369, 16)) goto end;
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(369);
    --ctx->captureEntryCount;
}

#if __GL_EXT_blend_color
void __gls_capture_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65520);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65520);
        glBlendColorEXT(red, green, blue, alpha);
        __GLS_END_CAPTURE_EXEC(ctx, 65520);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65520, 16)) goto end;
    writer->putGLfloat(writer, red);
    writer->putGLfloat(writer, green);
    writer->putGLfloat(writer, blue);
    writer->putGLfloat(writer, alpha);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65520);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_capture_glBlendEquationEXT(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65521);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65521);
        glBlendEquationEXT(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 65521);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65521, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65521);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_capture_glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65522);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65522);
        glPolygonOffsetEXT(factor, bias);
        __GLS_END_CAPTURE_EXEC(ctx, 65522);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65522, 8)) goto end;
    writer->putGLfloat(writer, factor);
    writer->putGLfloat(writer, bias);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65522);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_polygon_offset */

void __gls_capture_glPolygonOffset(GLfloat factor, GLfloat units) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(383);
    captureFlags = ctx->captureFlags[383];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 383);
        glPolygonOffset(factor, units);
        __GLS_END_CAPTURE_EXEC(ctx, 383);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 383, 8)) goto end;
    writer->putGLfloat(writer, factor);
    writer->putGLfloat(writer, units);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(383);
    --ctx->captureEntryCount;
}

#if __GL_EXT_subtexture
void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
void __gls_capture_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65523);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65523);
        glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65523);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage1DEXT_pixels_size(format, type, width);
    if (!writer->beginCommand(writer, 65523, 28 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65523);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_subtexture */

void __gls_capture_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(396);
    captureFlags = ctx->captureFlags[396];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 396);
        glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 396);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage1D_pixels_size(format, type, width);
    if (!writer->beginCommand(writer, 396, 28 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        __glsWriter_putPixelv(writer, format, type, width, 1, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(396);
    --ctx->captureEntryCount;
}

#if __GL_EXT_subtexture
void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
void __gls_capture_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65524);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65524);
        glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65524);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage2DEXT_pixels_size(format, type, width, height);
    if (!writer->beginCommand(writer, 65524, 36 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65524);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_subtexture */

void __gls_capture_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(397);
    captureFlags = ctx->captureFlags[397];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 397);
        glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 397);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage2D_pixels_size(format, type, width, height);
    if (!writer->beginCommand(writer, 397, 36 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        __glsWriter_putPixelv(writer, format, type, width, height, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(397);
    --ctx->captureEntryCount;
}

#if __GL_SGIS_multisample
void __gls_capture_glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65525);
    captureFlags = ctx->captureFlags[389];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65525);
        glSampleMaskSGIS(value, invert);
        __GLS_END_CAPTURE_EXEC(ctx, 65525);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65525, 5)) goto end;
    writer->putGLfloat(writer, value);
    writer->putGLboolean(writer, invert);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65525);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_capture_glSamplePatternSGIS(GLenum pattern) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65526);
    captureFlags = ctx->captureFlags[390];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65526);
        glSamplePatternSGIS(pattern);
        __GLS_END_CAPTURE_EXEC(ctx, 65526);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65526, 4)) goto end;
    writer->putGLenum(writer, pattern);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65526);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIX_multisample
void __gls_capture_glTagSampleBufferSGIX(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65527);
    captureFlags = ctx->captureFlags[391];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65527);
        glTagSampleBufferSGIX();
        __GLS_END_CAPTURE_EXEC(ctx, 65527);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65527, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65527);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIX_multisample */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint image_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65528);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65528);
        glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
        __GLS_END_CAPTURE_EXEC(ctx, 65528);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    image_count = __gls_glConvolutionFilter1DEXT_image_size(format, type, width);
    if (!writer->beginCommand(writer, 65528, 24 + image_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, image_count ? image : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, 1, image_count ? image : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65528);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint image_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65529);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65529);
        glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
        __GLS_END_CAPTURE_EXEC(ctx, 65529);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    image_count = __gls_glConvolutionFilter2DEXT_image_size(format, type, width, height);
    if (!writer->beginCommand(writer, 65529, 28 + image_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height, image_count ? image : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, height, image_count ? image : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65529);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65530);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65530);
        glConvolutionParameterfEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65530);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65530, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLfloatOrGLenum(writer, pname, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65530);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65531);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65531);
        glConvolutionParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65531);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glConvolutionParameterfvEXT_params_size(pname);
    if (!writer->beginCommand(writer, 65531, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65531);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65532);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65532);
        glConvolutionParameteriEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65532);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65532, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, pname);
    writer->putGLintOrGLenum(writer, pname, params);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65532);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65533);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65533);
        glConvolutionParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65533);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glConvolutionParameterivEXT_params_size(pname);
    if (!writer->beginCommand(writer, 65533, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintOrGLenumv(writer, pname, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65533);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65534);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65534);
        glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 65534);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65534, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65534);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65535);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65535);
        glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 65535);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65535, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65535);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65504);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65504);
        glGetConvolutionFilterEXT(target, format, type, image);
        __GLS_END_CAPTURE_EXEC(ctx, 65504);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65504, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, image);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65504);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65505);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65505);
        glGetConvolutionParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65505);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65505, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65505);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65506);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65506);
        glGetConvolutionParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65506);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65506, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65506);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65507);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65507);
        glGetSeparableFilterEXT(target, format, type, row, column, span);
        __GLS_END_CAPTURE_EXEC(ctx, 65507);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65507, 36)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, row);
    writer->putGLoutArg(writer, 0, column);
    writer->putGLoutArg(writer, 0, span);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65507);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_capture_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint row_count;
    GLint column_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65508);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65508);
        glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
        __GLS_END_CAPTURE_EXEC(ctx, 65508);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    column_count = __gls_glSeparableFilter2DEXT_column_size(target, format, type, height);
    if (!writer->beginCommand(writer, 65508, 28 + row_count * 1 + column_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, row_count ? row : GLS_NONE);
        __glsWriter_putPixelv(writer, format, type, height, 1, column_count ? column : GLS_NONE);
    } else {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, 1, row_count ? row : GLS_NONE);
        __glsWriter_putPixelv(writer, format, type, height, 1, column_count ? column : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65508);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_capture_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65509);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65509);
        glGetHistogramEXT(target, reset, format, type, values);
        __GLS_END_CAPTURE_EXEC(ctx, 65509);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65509, 21)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLboolean(writer, reset);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
    } else {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
        writer->putGLboolean(writer, reset);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65509);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65510);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65510);
        glGetHistogramParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65510);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65510, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65510);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65511);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65511);
        glGetHistogramParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65511);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65511, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65511);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65512);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65512);
        glGetMinmaxEXT(target, reset, format, type, values);
        __GLS_END_CAPTURE_EXEC(ctx, 65512);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65512, 21)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLboolean(writer, reset);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
    } else {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLoutArg(writer, 0, values);
        writer->putGLboolean(writer, reset);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65512);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65513);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65513);
        glGetMinmaxParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65513);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65513, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65513);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65514);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65514);
        glGetMinmaxParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65514);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65514, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65514);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65515);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65515);
        glHistogramEXT(target, width, internalformat, sink);
        __GLS_END_CAPTURE_EXEC(ctx, 65515);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65515, 13)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, width);
    writer->putGLenum(writer, internalformat);
    writer->putGLboolean(writer, sink);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65515);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65516);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65516);
        glMinmaxEXT(target, internalformat, sink);
        __GLS_END_CAPTURE_EXEC(ctx, 65516);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65516, 9)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLboolean(writer, sink);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65516);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glResetHistogramEXT(GLenum target) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65517);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65517);
        glResetHistogramEXT(target);
        __GLS_END_CAPTURE_EXEC(ctx, 65517);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65517, 4)) goto end;
    writer->putGLenum(writer, target);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65517);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_capture_glResetMinmaxEXT(GLenum target) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65518);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65518);
        glResetMinmaxEXT(target);
        __GLS_END_CAPTURE_EXEC(ctx, 65518);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65518, 4)) goto end;
    writer->putGLenum(writer, target);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65518);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_capture_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65519);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65519);
        glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65519);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage3DEXT_pixels_size(format, type, width, height, depth) : 0;
    if (!writer->beginCommand(writer, 65519, 40 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65519);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture && __GL_EXT_texture3D
void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
void __gls_capture_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65488);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65488);
        glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65488);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage3DEXT_pixels_size(format, type, width, height, depth);
    if (!writer->beginCommand(writer, 65488, 44 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        __glsWriter_putPixelv(writer, format, type, width, height * depth, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65488);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_capture_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65489);
    captureFlags = ctx->captureFlags[417];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65489);
        glDetailTexFuncSGIS(target, n, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65489);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65489, 8 + __GLS_MAX(n*2, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, n);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    } else {
        writer->putGLint(writer, n);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65489);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_capture_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65490);
    captureFlags = ctx->captureFlags[418];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65490);
        glGetDetailTexFuncSGIS(target, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65490);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65490, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLoutArg(writer, 0, points);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65490);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_capture_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65491);
    captureFlags = ctx->captureFlags[419];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65491);
        glSharpenTexFuncSGIS(target, n, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65491);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65491, 8 + __GLS_MAX(n*2, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, n);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    } else {
        writer->putGLint(writer, n);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, __GLS_MAX(n*2, 0), points);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65491);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_capture_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65492);
    captureFlags = ctx->captureFlags[420];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65492);
        glGetSharpenTexFuncSGIS(target, points);
        __GLS_END_CAPTURE_EXEC(ctx, 65492);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65492, 12)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLoutArg(writer, 0, points);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65492);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void glArrayElementEXT(GLint i);
void __gls_capture_glArrayElementEXT(GLint i) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65493);
    captureFlags = ctx->captureFlags[437];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65493);
        glArrayElementEXT(i);
        __GLS_END_CAPTURE_EXEC(ctx, 65493);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65493, 4)) goto end;
    writer->putGLint(writer, i);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65493);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glArrayElement(GLint i) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint size;
    __GLSarrayState arrayState;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(370);
    captureFlags = ctx->captureFlags[370];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 370);
        glArrayElement(i);
        __GLS_END_CAPTURE_EXEC(ctx, 370);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    __glsGetArrayState(ctx, &arrayState);
    size = __glsArrayDataSize(1, &arrayState);
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 370, size)) goto end;
    __glsWriteArrayData(writer, size, i, 1, GL_NONE, NULL, &arrayState);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(370);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65494);
    captureFlags = ctx->captureFlags[438];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65494);
        glColorPointerEXT(size, type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65494);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    if (!writer->beginCommand(writer, 65494, 16 + pointer_count * 1)) goto end;
    writer->putGLint(writer, size);
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, size, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65494);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(372);
    captureFlags = ctx->captureFlags[372];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 372);
        glColorPointer(size, type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 372);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(372);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
void __gls_capture_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65495);
    captureFlags = ctx->captureFlags[439];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65495);
        glDrawArraysEXT(mode, first, count);
        __GLS_END_CAPTURE_EXEC(ctx, 65495);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65495, 12)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, first);
    writer->putGLint(writer, count);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65495);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint size;
    __GLSarrayState arrayState;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(374);
    captureFlags = ctx->captureFlags[374];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 374);
        glDrawArrays(mode, first, count);
        __GLS_END_CAPTURE_EXEC(ctx, 374);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    __glsGetArrayState(ctx, &arrayState);
    size = __glsArrayDataSize(count, &arrayState);
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 374, size+4)) goto end;
    writer->putGLenum(writer, mode);
    __glsWriteArrayData(writer, size, first, count, GL_NONE, NULL, &arrayState);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(374);
    --ctx->captureEntryCount;
}

void __gls_capture_glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint size;
    __GLSarrayState arrayState;
    __GLSdrawElementsState deState;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(375);
    captureFlags = ctx->captureFlags[375];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 375);
        glDrawElements(mode, count, type, indices);
        __GLS_END_CAPTURE_EXEC(ctx, 375);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    __glsGetArrayState(ctx, &arrayState);
    size = __glsDrawElementsDataSize(count, type, indices, &arrayState,
                                     &deState);
    if (size < 0)
    {
        goto end;
    }
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 375, size+8)) goto end;
    writer->putGLenum(writer, mode);
    writer->putGLint(writer, count);
    __glsWriteDrawElementsData(writer, size, count, &arrayState, &deState);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(375);
    --ctx->captureEntryCount;
}

#if __GL_WIN_draw_range_elements
void __gls_capture_glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) {
    // XXX : For best performance, flesh out this function instead of calling
    // DrawElements.
    __gls_capture_glDrawElements(mode, count, type, indices);
}
#endif

void __gls_capture_glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(381);
    captureFlags = ctx->captureFlags[381];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 381);
        glInterleavedArrays(format, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 381);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(381);
    --ctx->captureEntryCount;
}

void __gls_capture_glEnableClientState(GLenum array) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(377);
    captureFlags = ctx->captureFlags[377];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 377);
        glEnableClientState(array);
        __GLS_END_CAPTURE_EXEC(ctx, 377);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 377, 4)) goto end;
    writer->putGLenum(writer, array);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(377);
    --ctx->captureEntryCount;
}

void __gls_capture_glDisableClientState(GLenum array) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(373);
    captureFlags = ctx->captureFlags[373];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 373);
        glDisableClientState(array);
        __GLS_END_CAPTURE_EXEC(ctx, 373);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 373, 4)) goto end;
    writer->putGLenum(writer, array);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(373);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
void __gls_capture_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65496);
    captureFlags = ctx->captureFlags[440];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65496);
        glEdgeFlagPointerEXT(stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65496);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glEdgeFlagPointerEXT_pointer_size(stride, count);
    if (!writer->beginCommand(writer, 65496, 8 + pointer_count * 1)) goto end;
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, 1, __GLS_BOOLEAN, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65496);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(376);
    captureFlags = ctx->captureFlags[376];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 376);
        glEdgeFlagPointer(stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 376);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(376);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glGetPointervEXT(GLenum pname, GLvoid* *params);
void __gls_capture_glGetPointervEXT(GLenum pname, GLvoid* *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65497);
    captureFlags = ctx->captureFlags[441];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65497);
        glGetPointervEXT(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65497);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 65497, 12)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, pname);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65497);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glGetPointerv(GLenum pname, GLvoid* *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(393);
    captureFlags = ctx->captureFlags[393];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 393);
        glGetPointerv(pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 393);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 1)) goto end;
    if (!writer->beginCommand(writer, 393, 12)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, pname);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(393);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65498);
    captureFlags = ctx->captureFlags[442];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65498);
        glIndexPointerEXT(type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65498);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    if (!writer->beginCommand(writer, 65498, 12 + pointer_count * 1)) goto end;
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, 1, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65498);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(378);
    captureFlags = ctx->captureFlags[378];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 378);
        glIndexPointer(type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 378);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(378);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65499);
    captureFlags = ctx->captureFlags[443];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65499);
        glNormalPointerEXT(type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65499);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    if (!writer->beginCommand(writer, 65499, 12 + pointer_count * 1)) goto end;
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, 3, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65499);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(382);
    captureFlags = ctx->captureFlags[382];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 382);
        glNormalPointer(type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 382);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(382);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65500);
    captureFlags = ctx->captureFlags[444];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65500);
        glTexCoordPointerEXT(size, type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65500);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    if (!writer->beginCommand(writer, 65500, 16 + pointer_count * 1)) goto end;
    writer->putGLint(writer, size);
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, size, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65500);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(384);
    captureFlags = ctx->captureFlags[384];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 384);
        glTexCoordPointer(size, type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 384);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(384);
    --ctx->captureEntryCount;
}

#if __GL_EXT_vertex_array
void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
void __gls_capture_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pointer_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65501);
    captureFlags = ctx->captureFlags[445];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65501);
        glVertexPointerEXT(size, type, stride, count, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 65501);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    if (!writer->beginCommand(writer, 65501, 16 + pointer_count * 1)) goto end;
    writer->putGLint(writer, size);
    writer->putGLenum(writer, type);
    writer->putGLint(writer, __GLS_MIN(stride, 0));
    writer->putGLint(writer, count);
    __glsWriter_putVertexv(writer, size, type, stride, count, pointer_count ? pointer : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65501);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_vertex_array */

void __gls_capture_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(385);
    captureFlags = ctx->captureFlags[385];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 385);
        glVertexPointer(size, type, stride, pointer);
        __GLS_END_CAPTURE_EXEC(ctx, 385);
    }
    // No record produced
    if (ctx->captureExitFunc) ctx->captureExitFunc(385);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
GLboolean __gls_capture_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65502);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65502);
        _outVal = glAreTexturesResidentEXT(n, textures, residences);
        __GLS_END_CAPTURE_EXEC(ctx, 65502);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65502, 12 + __GLS_MAX(n, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, n);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
        writer->putGLoutArg(writer, 0, residences);
    } else {
        writer->putGLint(writer, n);
        writer->putGLoutArg(writer, 0, residences);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65502);
    --ctx->captureEntryCount;
    return _outVal;
}
#endif /* __GL_EXT_texture_object */

GLboolean __gls_capture_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(386);
    captureFlags = ctx->captureFlags[386];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 386);
        _outVal = glAreTexturesResident(n, textures, residences);
        __GLS_END_CAPTURE_EXEC(ctx, 386);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 386, 12 + __GLS_MAX(n, 0) * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLint(writer, n);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
        writer->putGLoutArg(writer, 0, residences);
    } else {
        writer->putGLint(writer, n);
        writer->putGLoutArg(writer, 0, residences);
        writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(386);
    --ctx->captureEntryCount;
    return _outVal;
}

#if __GL_EXT_texture_object
void glBindTextureEXT(GLenum target, GLuint texture);
void __gls_capture_glBindTextureEXT(GLenum target, GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65503);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65503);
        glBindTextureEXT(target, texture);
        __GLS_END_CAPTURE_EXEC(ctx, 65503);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65503, 8)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65503);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glBindTexture(GLenum target, GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(371);
    captureFlags = ctx->captureFlags[371];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 371);
        glBindTexture(target, texture);
        __GLS_END_CAPTURE_EXEC(ctx, 371);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 371, 8)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(371);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
void glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
void __gls_capture_glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65472);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65472);
        glDeleteTexturesEXT(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 65472);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65472, 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65472);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glDeleteTextures(GLsizei n, const GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(391);
    captureFlags = ctx->captureFlags[391];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 391);
        glDeleteTextures(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 391);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 391, 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(391);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
void glGenTexturesEXT(GLsizei n, GLuint *textures);
void __gls_capture_glGenTexturesEXT(GLsizei n, GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65473);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65473);
        glGenTexturesEXT(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 65473);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65473, 12)) goto end;
    writer->putGLint(writer, n);
    writer->putGLoutArg(writer, 0, textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65473);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glGenTextures(GLsizei n, GLuint *textures) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(392);
    captureFlags = ctx->captureFlags[392];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 392);
        glGenTextures(n, textures);
        __GLS_END_CAPTURE_EXEC(ctx, 392);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 392, 12)) goto end;
    writer->putGLint(writer, n);
    writer->putGLoutArg(writer, 0, textures);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(392);
    --ctx->captureEntryCount;
}

#if __GL_EXT_texture_object
GLboolean glIsTextureEXT(GLuint texture);
GLboolean __gls_capture_glIsTextureEXT(GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65474);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65474);
        _outVal = glIsTextureEXT(texture);
        __GLS_END_CAPTURE_EXEC(ctx, 65474);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65474, 4)) goto end;
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65474);
    --ctx->captureEntryCount;
    return _outVal;
}
#endif /* __GL_EXT_texture_object */

GLboolean __gls_capture_glIsTexture(GLuint texture) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLboolean _outVal = 0;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(394);
    captureFlags = ctx->captureFlags[394];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 394);
        _outVal = glIsTexture(texture);
        __GLS_END_CAPTURE_EXEC(ctx, 394);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 394, 4)) goto end;
    writer->putGLuint(writer, texture);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(394);
    --ctx->captureEntryCount;
    return _outVal;
}

#if __GL_EXT_texture_object
void glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);
void __gls_capture_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65475);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65475);
        glPrioritizeTexturesEXT(n, textures, priorities);
        __GLS_END_CAPTURE_EXEC(ctx, 65475);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65475, 4 + __GLS_MAX(n, 0) * 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->putGLfloatv(writer, __GLS_MAX(n, 0), priorities);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65475);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_texture_object */

void __gls_capture_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(395);
    captureFlags = ctx->captureFlags[395];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 395);
        glPrioritizeTextures(n, textures, priorities);
        __GLS_END_CAPTURE_EXEC(ctx, 395);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 395, 4 + __GLS_MAX(n, 0) * 4 + __GLS_MAX(n, 0) * 4)) goto end;
    writer->putGLint(writer, n);
    writer->putGLuintv(writer, __GLS_MAX(n, 0), textures);
    writer->putGLfloatv(writer, __GLS_MAX(n, 0), priorities);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(395);
    --ctx->captureEntryCount;
}

#if __GL_EXT_paletted_texture
void glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
void __gls_capture_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint table_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65476);
    captureFlags = ctx->captureFlags[452];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65476);
        glColorTableEXT(target, internalformat, width, format, type, table);
        __GLS_END_CAPTURE_EXEC(ctx, 65476);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    table_count = __gls_glColorTableEXT_table_size(format, type, width);
    if (!writer->beginCommand(writer, 65476, 24 + table_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, 1, table_count ? table : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, internalformat);
        __glsWriter_putPixelv(writer, format, type, width, 1, table_count ? table : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65476);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_capture_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65477);
    captureFlags = ctx->captureFlags[437];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65477);
        glColorTableParameterfvSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65477);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glColorTableParameterfvSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65477, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65477);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_capture_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65478);
    captureFlags = ctx->captureFlags[438];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65478);
        glColorTableParameterivSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65478);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glColorTableParameterivSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65478, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65478);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_capture_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65479);
    captureFlags = ctx->captureFlags[439];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65479);
        glCopyColorTableSGI(target, internalformat, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 65479);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65479, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65479);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table);
void __gls_capture_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65480);
    captureFlags = ctx->captureFlags[456];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65480);
        glGetColorTableEXT(target, format, type, table);
        __GLS_END_CAPTURE_EXEC(ctx, 65480);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65480, 20)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    writer->putGLoutArg(writer, 0, table);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65480);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
void __gls_capture_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65481);
    captureFlags = ctx->captureFlags[457];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65481);
        glGetColorTableParameterfvEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65481);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65481, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65481);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);
void __gls_capture_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65482);
    captureFlags = ctx->captureFlags[458];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65482);
        glGetColorTableParameterivEXT(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65482);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65482, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65482);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_capture_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65483);
    captureFlags = ctx->captureFlags[443];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65483);
        glGetTexColorTableParameterfvSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65483);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65483, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65483);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_capture_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65484);
    captureFlags = ctx->captureFlags[444];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65484);
        glGetTexColorTableParameterivSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65484);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->padWordCount(writer, 0)) goto end;
    if (!writer->beginCommand(writer, 65484, 16)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLoutArg(writer, 0, params);
        writer->putGLenum(writer, target);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65484);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_capture_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65485);
    captureFlags = ctx->captureFlags[445];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65485);
        glTexColorTableParameterfvSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65485);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexColorTableParameterfvSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65485, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLfloatv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLfloatv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65485);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_capture_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint params_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65486);
    captureFlags = ctx->captureFlags[446];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65486);
        glTexColorTableParameterivSGI(target, pname, params);
        __GLS_END_CAPTURE_EXEC(ctx, 65486);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    params_count = __gls_glTexColorTableParameterivSGI_params_size(pname);
    if (!writer->beginCommand(writer, 65486, 8 + params_count * 4)) goto end;
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLenum(writer, pname);
        writer->putGLintv(writer, params_count, params);
    } else {
        writer->putGLenum(writer, pname);
        writer->putGLenum(writer, target);
        writer->putGLintv(writer, params_count, params);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65486);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
void __gls_capture_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65487);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65487);
        glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
        __GLS_END_CAPTURE_EXEC(ctx, 65487);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65487, 28)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65487);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(387);
    captureFlags = ctx->captureFlags[387];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 387);
        glCopyTexImage1D(target, level, internalformat, x, y, width, border);
        __GLS_END_CAPTURE_EXEC(ctx, 387);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 387, 28)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(387);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture
void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
void __gls_capture_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65456);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65456);
        glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
        __GLS_END_CAPTURE_EXEC(ctx, 65456);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65456, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65456);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(388);
    captureFlags = ctx->captureFlags[388];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 388);
        glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
        __GLS_END_CAPTURE_EXEC(ctx, 388);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 388, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLenum(writer, internalformat);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->putGLint(writer, border);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(388);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture
void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
void __gls_capture_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65457);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65457);
        glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 65457);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65457, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65457);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(389);
    captureFlags = ctx->captureFlags[389];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 389);
        glCopyTexSubImage1D(target, level, xoffset, x, y, width);
        __GLS_END_CAPTURE_EXEC(ctx, 389);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 389, 24)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(389);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture
void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
void __gls_capture_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65458);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65458);
        glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 65458);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65458, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, yoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65458);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

void __gls_capture_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(390);
    captureFlags = ctx->captureFlags[390];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 390);
        glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 390);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 390, 32)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, yoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(390);
    --ctx->captureEntryCount;
}

#if __GL_EXT_copy_texture && __GL_EXT_texture3D
void __gls_capture_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65459);
    captureFlags = ctx->captureFlags[];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65459);
        glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        __GLS_END_CAPTURE_EXEC(ctx, 65459);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65459, 36)) goto end;
    writer->putGLenum(writer, target);
    writer->putGLint(writer, level);
    writer->putGLint(writer, xoffset);
    writer->putGLint(writer, yoffset);
    writer->putGLint(writer, zoffset);
    writer->putGLint(writer, x);
    writer->putGLint(writer, y);
    writer->putGLint(writer, width);
    writer->putGLint(writer, height);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65459);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_capture_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65460);
    captureFlags = ctx->captureFlags[452];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65460);
        glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65460);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = pixels ? __gls_glTexImage4DSGIS_pixels_size(format, type, width, height, depth, size4d) : 0;
    if (!writer->beginCommand(writer, 65460, 44 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, pixels ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLint(writer, border);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLenum(writer, internalformat);
        writer->putGLint(writer, border);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65460);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_capture_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint pixels_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65461);
    captureFlags = ctx->captureFlags[453];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65461);
        glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
        __GLS_END_CAPTURE_EXEC(ctx, 65461);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    pixels_count = __gls_glTexSubImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    if (!writer->beginCommand(writer, 65461, 52 + pixels_count * 1)) goto end;
    writer->putGLSimageFlags(writer, GLS_NONE);
    writer->nextList(writer);
    if (writer->type == GLS_TEXT) {
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        writer->putGLint(writer, woffset);
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    } else {
        writer->putGLint(writer, width);
        writer->putGLint(writer, height);
        writer->putGLint(writer, depth);
        writer->putGLint(writer, size4d);
        writer->putGLenum(writer, format);
        writer->putGLenum(writer, type);
        writer->putGLenum(writer, target);
        writer->putGLint(writer, level);
        writer->putGLint(writer, xoffset);
        writer->putGLint(writer, yoffset);
        writer->putGLint(writer, zoffset);
        writer->putGLint(writer, woffset);
        __glsWriter_putPixelv(writer, format, type, width, height * depth * size4d, pixels_count ? pixels : GLS_NONE);
    }
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65461);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_capture_glPixelTexGenSGIX(GLenum mode) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65462);
    captureFlags = ctx->captureFlags[454];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65462);
        glPixelTexGenSGIX(mode);
        __GLS_END_CAPTURE_EXEC(ctx, 65462);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 65462, 4)) goto end;
    writer->putGLenum(writer, mode);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65462);
    --ctx->captureEntryCount;
}
#endif /* __GL_SGIX_pixel_texture */

#if __GL_EXT_paletted_texture
extern void glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
void __gls_capture_glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    GLint entries_count;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(65424);
    captureFlags = ctx->captureFlags[496];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 65424);
        glColorSubTableEXT(target, start, count, format, type, data);
        __GLS_END_CAPTURE_EXEC(ctx, 65424);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    entries_count = data ? __gls_glColorSubTableEXT_entries_size(format, type, count) : 0;
    if (!writer->beginCommand(writer, 65424, 24 + entries_count * 1)) goto end;
    writer->putGLSimageFlags(writer, data ? GLS_NONE : GLS_IMAGE_NULL_BIT);
    writer->nextList(writer);
    writer->putGLenum(writer, target);
    writer->putGLuint(writer, start);
    writer->putGLint(writer, count);
    writer->putGLenum(writer, format);
    writer->putGLenum(writer, type);
    __glsWriter_putPixelv(writer, format, type, count, 1, entries_count ? data : GLS_NONE);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(65424);
    --ctx->captureEntryCount;
}
#endif /* __GL_EXT_paletted_texture */

void __gls_capture_glPushClientAttrib(GLbitfield mask) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(398);
    captureFlags = ctx->captureFlags[398];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 398);
        glPushClientAttrib(mask);
        __GLS_END_CAPTURE_EXEC(ctx, 398);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 398, 4)) goto end;
    // Consider - Breaks enum representation, should have
    // clientAttribMask
    writer->putGLuint(writer, mask);
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(398);
    --ctx->captureEntryCount;
}

void __gls_capture_glPopClientAttrib(void) {
    GLbitfield captureFlags;
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;
    ++ctx->captureEntryCount;
    if (ctx->captureEntryFunc) ctx->captureEntryFunc(399);
    captureFlags = ctx->captureFlags[399];
    if (captureFlags & GLS_CAPTURE_EXECUTE_BIT) {
        __GLS_BEGIN_CAPTURE_EXEC(ctx, 399);
        glPopClientAttrib();
        __GLS_END_CAPTURE_EXEC(ctx, 399);
    }
    if (!(captureFlags & GLS_CAPTURE_WRITE_BIT)) goto end;
    writer = ctx->writer;
    if (!writer->beginCommand(writer, 399, 0)) goto end;
    writer->endCommand(writer);
end:
    if (ctx->captureExitFunc) ctx->captureExitFunc(399);
    --ctx->captureEntryCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_decswp.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

// DrewB - All functions changed to use passed in context

void __gls_decode_bin_swap_glsBeginGLS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsBeginGLS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsBeginGLS(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsBlock(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsBlock(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsBlock(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsCallStream(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[18])(inoutPtr);
}

void __gls_decode_bin_swap_glsEndGLS(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[19])();
}

void __gls_decode_bin_swap_glsError(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsError(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsError(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsGLRC(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsGLRC(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsGLRC(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsGLRCLayer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsGLRCLayer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsGLRCLayer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderGLRCi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderGLRCi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsHeaderGLRCi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderLayerf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderLayerf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsHeaderLayerf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderLayeri(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderLayeri(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsHeaderLayeri(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsHeaderf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderfv(__GLScontext *, GLubyte *);
    GLSenum inAttrib;
    GLint inVec_count;
    __glsSwap4(inoutPtr + 0);
    inAttrib = *(GLSenum *)(inoutPtr + 0);
    inVec_count = __gls_glsHeaderfv_inVec_size(inAttrib);
    __glsSwap4v(inVec_count, inoutPtr + 4);
    __gls_decode_bin_glsHeaderfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glsHeaderi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderiv(__GLScontext *, GLubyte *);
    GLSenum inAttrib;
    GLint inVec_count;
    __glsSwap4(inoutPtr + 0);
    inAttrib = *(GLSenum *)(inoutPtr + 0);
    inVec_count = __gls_glsHeaderiv_inVec_size(inAttrib);
    __glsSwap4v(inVec_count, inoutPtr + 4);
    __gls_decode_bin_glsHeaderiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsHeaderubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsHeaderubz(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsHeaderubz(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsRequireExtension(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[31])(inoutPtr);
}

void __gls_decode_bin_swap_glsUnsupportedCommand(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[32])();
}

void __gls_decode_bin_swap_glsAppRef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsAppRef(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glsAppRef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsBeginObj(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[34])(inoutPtr);
}

void __gls_decode_bin_swap_glsCharubz(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsCharubz(__GLScontext *, GLubyte *);
    __gls_decode_bin_glsCharubz(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsComment(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[36])(inoutPtr);
}

void __gls_decode_bin_swap_glsDisplayMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsDisplayMapfv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 12);
    __gls_decode_bin_glsDisplayMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsEndObj(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[38])();
}

void __gls_decode_bin_swap_glsNumb(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumb(__GLScontext *, GLubyte *);
    __gls_decode_bin_glsNumb(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumbv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumbv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumbv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumd(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumd(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glsNumd(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumdv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap8v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumdv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumfv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumiv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNuml(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNuml(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glsNuml(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumlv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumlv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap8v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumlv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNums(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNums(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glsNums(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumsv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap2v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumsv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glsNumub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumubv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumubv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumui(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumui(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsNumui(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumuiv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumuiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumul(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumul(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glsNumul(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumulv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumulv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap8v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumulv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumus(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumus(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glsNumus(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsNumusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsNumusv(__GLScontext *, GLubyte *);
    GLuint inCount;
    __glsSwap4(inoutPtr + 0);
    inCount = *(GLuint *)(inoutPtr + 0);
    __glsSwap2v(__GLS_MAX(inCount, 0), inoutPtr + 4);
    __gls_decode_bin_glsNumusv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glsPad(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[59])();
}

void __gls_decode_bin_swap_glsSwapBuffers(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glsSwapBuffers(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glsSwapBuffers(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNewList(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNewList(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glNewList(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEndList(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[65])();
}

void __gls_decode_bin_swap_glCallList(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCallList(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glCallList(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glCallLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCallLists(__GLScontext *, GLubyte *);
    GLsizei n;
    GLenum type;
    GLint lists_count;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    lists_count = __gls_glCallLists_lists_size(n, type);
    __glsSwapv(type, lists_count, inoutPtr + 8);
    __gls_decode_bin_glCallLists(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDeleteLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDeleteLists(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glDeleteLists(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGenLists(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGenLists(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glGenLists(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glListBase(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glListBase(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glListBase(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glBegin(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBegin(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glBegin(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glBitmap(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBitmap(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __gls_decode_bin_glBitmap(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3b(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor3b(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[74])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glColor3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[76])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glColor3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[78])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glColor3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[80])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glColor3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[82])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3ub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor3ub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[84])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3ui(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glColor3ui(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[86])(inoutPtr);
}

void __gls_decode_bin_swap_glColor3us(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor3us(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glColor3us(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor3usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[88])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4b(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4b(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor4b(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[90])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glColor4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[92])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glColor4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[94])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glColor4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[96])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glColor4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[98])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4ub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4ub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColor4ub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4ubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[100])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4ui(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4ui(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glColor4ui(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4uiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[102])(inoutPtr);
}

void __gls_decode_bin_swap_glColor4us(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColor4us(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glColor4us(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColor4usv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[104])(inoutPtr);
}

void __gls_decode_bin_swap_glEdgeFlag(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEdgeFlag(__GLScontext *, GLubyte *);
    __gls_decode_bin_glEdgeFlag(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEdgeFlagv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[106])(inoutPtr);
}

void __gls_decode_bin_swap_glEnd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[107])();
}

void __gls_decode_bin_swap_glIndexd(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexd(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glIndexd(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[109])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIndexf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[111])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIndexi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[113])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexs(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexs(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glIndexs(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[115])(inoutPtr);
}

void __gls_decode_bin_swap_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexub(__GLScontext *, GLubyte *);
    __gls_decode_bin_glIndexub(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[380])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3b(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3b(__GLScontext *, GLubyte *);
    __gls_decode_bin_glNormal3b(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3bv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    ((__GLSdispatch)ctx->dispatchCall[117])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glNormal3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[119])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glNormal3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[121])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glNormal3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[123])(inoutPtr);
}

void __gls_decode_bin_swap_glNormal3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormal3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glNormal3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glNormal3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[125])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glRasterPos2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[127])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glRasterPos2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[129])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glRasterPos2i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[131])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos2s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __gls_decode_bin_glRasterPos2s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[133])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glRasterPos3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[135])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glRasterPos3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[137])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glRasterPos3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[139])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glRasterPos3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[141])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glRasterPos4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[143])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRasterPos4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[145])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRasterPos4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[147])(inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRasterPos4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glRasterPos4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRasterPos4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[149])(inoutPtr);
}

void __gls_decode_bin_swap_glRectd(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectd(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glRectd(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectdv(__GLScontext *, GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    __glsSwap8v(2, inoutPtr + 16);
    __gls_decode_bin_glRectdv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRectf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectfv(__GLScontext *, GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    __glsSwap4v(2, inoutPtr + 8);
    __gls_decode_bin_glRectfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRecti(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRecti(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRecti(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectiv(__GLScontext *, GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    __glsSwap4v(2, inoutPtr + 8);
    __gls_decode_bin_glRectiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRects(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRects(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glRects(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRectsv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRectsv(__GLScontext *, GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    __glsSwap2v(2, inoutPtr + 4);
    __gls_decode_bin_glRectsv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[159])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[161])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[163])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord1s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __gls_decode_bin_glTexCoord1s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord1sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[165])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glTexCoord2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[167])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glTexCoord2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[169])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glTexCoord2i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[171])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord2s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __gls_decode_bin_glTexCoord2s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[173])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glTexCoord3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[175])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexCoord3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[177])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexCoord3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[179])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glTexCoord3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[181])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glTexCoord4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[183])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glTexCoord4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[185])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glTexCoord4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[187])(inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoord4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glTexCoord4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexCoord4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[189])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glVertex2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[191])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glVertex2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[193])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glVertex2i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[195])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex2s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex2s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __gls_decode_bin_glVertex2s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex2sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[197])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glVertex3d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[199])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glVertex3f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[201])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glVertex3i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[203])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex3s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex3s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __gls_decode_bin_glVertex3s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex3sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(3, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[205])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glVertex4d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[207])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glVertex4f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[209])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4i(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4i(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glVertex4i(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4iv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[211])(inoutPtr);
}

void __gls_decode_bin_swap_glVertex4s(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertex4s(__GLScontext *, GLubyte *);
    __glsSwap2(inoutPtr + 0);
    __glsSwap2(inoutPtr + 2);
    __glsSwap2(inoutPtr + 4);
    __glsSwap2(inoutPtr + 6);
    __gls_decode_bin_glVertex4s(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glVertex4sv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap2v(4, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[213])(inoutPtr);
}

void __gls_decode_bin_swap_glClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClipPlane(__GLScontext *, GLubyte *);
    __glsSwap8v(4, inoutPtr + 0);
    __glsSwap4(inoutPtr + 32);
    __gls_decode_bin_glClipPlane(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColorMaterial(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorMaterial(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glColorMaterial(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glCullFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCullFace(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glCullFace(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glFogf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glFogfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glFogfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glFogi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFogiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFogiv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glFogiv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glFogiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFrontFace(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFrontFace(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glFrontFace(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glHint(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glHint(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glHint(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glLightf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glLightfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glLightfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLighti(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLighti(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glLighti(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightiv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glLightiv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glLightiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModelf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModelf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glLightModelf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModelfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModelfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glLightModelfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glLightModelfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModeli(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModeli(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glLightModeli(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLightModeliv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLightModeliv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glLightModeliv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 4);
    __gls_decode_bin_glLightModeliv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLineStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLineStipple(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glLineStipple(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLineWidth(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLineWidth(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glLineWidth(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMaterialf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMaterialf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glMaterialf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMaterialfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glMaterialfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glMaterialfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMateriali(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMateriali(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glMateriali(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMaterialiv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glMaterialiv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glMaterialiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPointSize(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPointSize(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPointSize(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPolygonMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonMode(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPolygonMode(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonStipple(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPolygonStipple(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glScissor(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glScissor(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glScissor(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glShadeModel(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glShadeModel(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glShadeModel(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameterf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameterf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexParameterf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameterfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexParameterfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexParameterfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameteri(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameteri(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexParameteri(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexParameteriv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexParameteriv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexParameteriv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage1D(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage1D_pixels_size(format, type, width);
    __glsSwapv(type, pixels_count, inoutPtr + 32);
    __gls_decode_bin_glTexImage1D(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage2D(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage2D_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 36);
    __gls_decode_bin_glTexImage2D(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnvf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnvf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexEnvf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnvfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexEnvfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexEnvfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnvi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnvi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexEnvi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexEnviv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexEnviv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexEnviv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGend(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGend(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glTexGend(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGendv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    params_count = __gls_glTexGendv_params_size(pname);
    __glsSwap8v(params_count, inoutPtr + 4);
    __glsSwap4(inoutPtr + 4 + 8 * params_count);
    __gls_decode_bin_glTexGendv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGenf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGenf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexGenf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGenfv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexGenfv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexGenfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGeni(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGeni(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTexGeni(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexGeniv(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexGeniv_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexGeniv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFeedbackBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFeedbackBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glFeedbackBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glSelectBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSelectBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glSelectBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRenderMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRenderMode(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glRenderMode(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glInitNames(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[261])();
}

void __gls_decode_bin_swap_glLoadName(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLoadName(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glLoadName(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPassThrough(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPassThrough(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPassThrough(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPopName(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[264])();
}

void __gls_decode_bin_swap_glPushName(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPushName(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPushName(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDrawBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDrawBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClear(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClear(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glClear(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearAccum(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glClearAccum(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearIndex(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearIndex(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glClearIndex(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearColor(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearColor(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glClearColor(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearStencil(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearStencil(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glClearStencil(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glClearDepth(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glClearDepth(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glClearDepth(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glStencilMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glStencilMask(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glStencilMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glColorMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorMask(__GLScontext *, GLubyte *);
    __gls_decode_bin_glColorMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDepthMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDepthMask(__GLScontext *, GLubyte *);
    __gls_decode_bin_glDepthMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIndexMask(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexMask(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIndexMask(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glAccum(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAccum(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glAccum(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDisable(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDisable(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDisable(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEnable(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEnable(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEnable(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFinish(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[280])();
}

void __gls_decode_bin_swap_glFlush(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[281])();
}

void __gls_decode_bin_swap_glPopAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[282])();
}

void __gls_decode_bin_swap_glPushAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPushAttrib(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPushAttrib(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap1d(__GLScontext *, GLubyte *);
    GLenum target;
    GLint stride;
    GLint order;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    order = *(GLint *)(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __glsSwap8(inoutPtr + 20);
    points_count = __gls_glMap1d_points_size(target, stride, order);
    __glsSwap8v(points_count, inoutPtr + 28);
    __gls_decode_bin_glMap1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap1f(__GLScontext *, GLubyte *);
    GLenum target;
    GLint stride;
    GLint order;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    order = *(GLint *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    points_count = __gls_glMap1f_points_size(target, stride, order);
    __glsSwap4v(points_count, inoutPtr + 20);
    __gls_decode_bin_glMap1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap2d(__GLScontext *, GLubyte *);
    GLenum target;
    GLint ustride;
    GLint uorder;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    ustride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    uorder = *(GLint *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    vstride = *(GLint *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    vorder = *(GLint *)(inoutPtr + 16);
    __glsSwap8(inoutPtr + 20);
    __glsSwap8(inoutPtr + 28);
    __glsSwap8(inoutPtr + 36);
    __glsSwap8(inoutPtr + 44);
    points_count = __gls_glMap2d_points_size(target, ustride, uorder, vstride, vorder);
    __glsSwap8v(points_count, inoutPtr + 52);
    __gls_decode_bin_glMap2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMap2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMap2f(__GLScontext *, GLubyte *);
    GLenum target;
    GLint ustride;
    GLint uorder;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    __glsSwap4(inoutPtr + 0);
    target = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    ustride = *(GLint *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    uorder = *(GLint *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    vstride = *(GLint *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    vorder = *(GLint *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    points_count = __gls_glMap2f_points_size(target, ustride, uorder, vstride, vorder);
    __glsSwap4v(points_count, inoutPtr + 36);
    __gls_decode_bin_glMap2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid1d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glMapGrid1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid1f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glMapGrid1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __gls_decode_bin_glMapGrid2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMapGrid2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMapGrid2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glMapGrid2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord1d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glEvalCoord1d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[293])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord1f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEvalCoord1f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(1, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[295])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2d(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord2d(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glEvalCoord2d(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[297])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2f(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalCoord2f(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glEvalCoord2f(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(2, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[299])(inoutPtr);
}

void __gls_decode_bin_swap_glEvalMesh1(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalMesh1(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glEvalMesh1(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalPoint1(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalPoint1(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEvalPoint1(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalMesh2(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalMesh2(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glEvalMesh2(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEvalPoint2(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEvalPoint2(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glEvalPoint2(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glAlphaFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAlphaFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glAlphaFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glBlendFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBlendFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glBlendFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLogicOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glLogicOp(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glLogicOp(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glStencilFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glStencilFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glStencilFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glStencilOp(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glStencilOp(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glStencilOp(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDepthFunc(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDepthFunc(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDepthFunc(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelZoom(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelZoom(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelZoom(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelTransferf(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelTransferf(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelTransferf(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelTransferi(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelTransferi(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelTransferi(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelStoref(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelStoref(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelStoref(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelStorei(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelStorei(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPixelStorei(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelMapfv(__GLScontext *, GLubyte *);
    GLint mapsize;
    __glsSwap4(inoutPtr + 0);
    mapsize = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(mapsize, 0), inoutPtr + 8);
    __gls_decode_bin_glPixelMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelMapuiv(__GLScontext *, GLubyte *);
    GLint mapsize;
    __glsSwap4(inoutPtr + 0);
    mapsize = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(mapsize, 0), inoutPtr + 8);
    __gls_decode_bin_glPixelMapuiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelMapusv(__GLScontext *, GLubyte *);
    GLint mapsize;
    __glsSwap4(inoutPtr + 0);
    mapsize = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap2v(__GLS_MAX(mapsize, 0), inoutPtr + 8);
    __gls_decode_bin_glPixelMapusv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glReadBuffer(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glReadBuffer(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glReadBuffer(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glCopyPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyPixels(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glCopyPixels(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glReadPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glReadPixels(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap8(inoutPtr + 16);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glReadPixels(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDrawPixels(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawPixels(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    pixels_count = __gls_glDrawPixels_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 20);
    __gls_decode_bin_glDrawPixels(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetBooleanv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetBooleanv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetBooleanv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetClipPlane(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetClipPlane(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glGetClipPlane(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetDoublev(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetDoublev(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetDoublev(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetError(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[325])();
}

void __gls_decode_bin_swap_glGetFloatv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetFloatv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetFloatv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetIntegerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetIntegerv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetIntegerv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetLightfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetLightfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetLightfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetLightiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetLightiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetLightiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMapdv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMapdv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glGetMapdv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMapfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glGetMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMapiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMapiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glGetMapiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMaterialfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMaterialfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMaterialfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetMaterialiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMaterialiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMaterialiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPixelMapfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPixelMapfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetPixelMapfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPixelMapuiv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPixelMapuiv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetPixelMapuiv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPixelMapusv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPixelMapusv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetPixelMapusv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetPolygonStipple(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPolygonStipple(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __gls_decode_bin_glGetPolygonStipple(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetString(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetString(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glGetString(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexEnvfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexEnvfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexEnvfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexEnviv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexEnviv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexEnviv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexGendv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexGendv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexGendv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexGenfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexGenfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexGenfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexGeniv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexGeniv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexGeniv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexImage(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexImage(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glGetTexImage(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexParameterfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexParameterfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexParameteriv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexParameteriv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexLevelParameterfv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexLevelParameterfv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glGetTexLevelParameterfv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glGetTexLevelParameteriv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexLevelParameteriv(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glGetTexLevelParameteriv(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIsEnabled(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsEnabled(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsEnabled(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glIsList(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsList(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsList(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDepthRange(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDepthRange(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __gls_decode_bin_glDepthRange(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glFrustum(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glFrustum(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __glsSwap8(inoutPtr + 32);
    __glsSwap8(inoutPtr + 40);
    __gls_decode_bin_glFrustum(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glLoadIdentity(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[354])();
}

void __gls_decode_bin_swap_glLoadMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[355])(inoutPtr);
}

void __gls_decode_bin_swap_glLoadMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[356])(inoutPtr);
}

void __gls_decode_bin_swap_glMatrixMode(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMatrixMode(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glMatrixMode(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glMultMatrixf(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap4v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[358])(inoutPtr);
}

void __gls_decode_bin_swap_glMultMatrixd(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __glsSwap8v(16, inoutPtr + 0);
    ((__GLSdispatch)ctx->dispatchCall[359])(inoutPtr);
}

void __gls_decode_bin_swap_glOrtho(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glOrtho(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __glsSwap8(inoutPtr + 32);
    __glsSwap8(inoutPtr + 40);
    __gls_decode_bin_glOrtho(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPopMatrix(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[361])();
}

void __gls_decode_bin_swap_glPushMatrix(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[362])();
}

void __gls_decode_bin_swap_glRotated(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRotated(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __glsSwap8(inoutPtr + 24);
    __gls_decode_bin_glRotated(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glRotatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glRotatef(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glRotatef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glScaled(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glScaled(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glScaled(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glScalef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glScalef(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glScalef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTranslated(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTranslated(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap8(inoutPtr + 8);
    __glsSwap8(inoutPtr + 16);
    __gls_decode_bin_glTranslated(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glTranslatef(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTranslatef(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glTranslatef(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glViewport(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glViewport(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glViewport(ctx, inoutPtr);
}

#if __GL_EXT_blend_color
void __gls_decode_bin_swap_glBlendColorEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBlendColorEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glBlendColorEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_decode_bin_swap_glBlendEquationEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBlendEquationEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glBlendEquationEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_decode_bin_swap_glPolygonOffsetEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonOffsetEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPolygonOffsetEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_polygon_offset */

void __gls_decode_bin_swap_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPolygonOffset(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glPolygonOffset(ctx, inoutPtr);
}

#if __GL_EXT_subtexture
void __gls_decode_bin_swap_glTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage1DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    pixels_count = __gls_glTexSubImage1DEXT_pixels_size(format, type, width);
    __glsSwapv(type, pixels_count, inoutPtr + 28);
    __gls_decode_bin_glTexSubImage1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_swap_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage1D(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    pixels_count = __gls_glTexSubImage1D_pixels_size(format, type, width);
    __glsSwapv(type, pixels_count, inoutPtr + 28);
    __gls_decode_bin_glTexSubImage1D(ctx, inoutPtr);
}

#if __GL_EXT_subtexture
void __gls_decode_bin_swap_glTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage2DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    pixels_count = __gls_glTexSubImage2DEXT_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 36);
    __gls_decode_bin_glTexSubImage2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_bin_swap_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage2D(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    pixels_count = __gls_glTexSubImage2D_pixels_size(format, type, width, height);
    __glsSwapv(type, pixels_count, inoutPtr + 36);
    __gls_decode_bin_glTexSubImage2D(ctx, inoutPtr);
}

#if __GL_SGIS_multisample
void __gls_decode_bin_swap_glSampleMaskSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSampleMaskSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glSampleMaskSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_decode_bin_swap_glSamplePatternSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSamplePatternSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glSamplePatternSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIX_multisample
void __gls_decode_bin_swap_glTagSampleBufferSGIX(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[391])();
}
#endif /* __GL_SGIX_multisample */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint image_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    image_count = __gls_glConvolutionFilter1DEXT_image_size(format, type, width);
    __glsSwapv(type, image_count, inoutPtr + 24);
    __gls_decode_bin_glConvolutionFilter1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint image_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    format = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    type = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    image_count = __gls_glConvolutionFilter2DEXT_image_size(format, type, width, height);
    __glsSwapv(type, image_count, inoutPtr + 28);
    __gls_decode_bin_glConvolutionFilter2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameterfEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameterfEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameterfEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glConvolutionParameterfvEXT_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameteriEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameteriEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameteriEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glConvolutionParameterivEXT(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glConvolutionParameterivEXT_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glConvolutionParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glCopyConvolutionFilter1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glCopyConvolutionFilter1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glCopyConvolutionFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glCopyConvolutionFilter2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetConvolutionFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetConvolutionFilterEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetConvolutionFilterEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetConvolutionParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetConvolutionParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetConvolutionParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetConvolutionParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetConvolutionParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glGetSeparableFilterEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetSeparableFilterEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __glsSwap8(inoutPtr + 20);
    __glsSwap8(inoutPtr + 28);
    __gls_decode_bin_glGetSeparableFilterEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_bin_swap_glSeparableFilter2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSeparableFilter2DEXT(__GLScontext *, GLubyte *);
    GLenum target;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLint column_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    target = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    width = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    height = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    __glsSwapv(type, row_count, inoutPtr + 28);
    column_count = __gls_glSeparableFilter2DEXT_column_size(target, format, type, height);
    __glsSwapv(type, column_count, inoutPtr + 28 + 1 * row_count);
    __gls_decode_bin_glSeparableFilter2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetHistogramEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetHistogramEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetHistogramParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetHistogramParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetHistogramParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetHistogramParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetHistogramParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetHistogramParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMinmaxEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetMinmaxEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetMinmaxParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMinmaxParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMinmaxParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glGetMinmaxParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetMinmaxParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetMinmaxParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glHistogramEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glHistogramEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glMinmaxEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glMinmaxEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glResetHistogramEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glResetHistogramEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glResetHistogramEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_bin_swap_glResetMinmaxEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glResetMinmaxEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glResetMinmaxEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_decode_bin_swap_glTexImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage3DEXT(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage3DEXT_pixels_size(format, type, width, height, depth);
    __glsSwapv(type, pixels_count, inoutPtr + 40);
    __gls_decode_bin_glTexImage3DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture
void __gls_decode_bin_swap_glTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage3DEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __glsSwap4(inoutPtr + 40);
    pixels_count = __gls_glTexSubImage3DEXT_pixels_size(format, type, width, height, depth);
    __glsSwapv(type, pixels_count, inoutPtr + 44);
    __gls_decode_bin_glTexSubImage3DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_swap_glDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDetailTexFuncSGIS(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n*2, 0), inoutPtr + 8);
    __gls_decode_bin_glDetailTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_decode_bin_swap_glGetDetailTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetDetailTexFuncSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetDetailTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_swap_glSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n*2, 0), inoutPtr + 8);
    __gls_decode_bin_glSharpenTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_bin_swap_glGetSharpenTexFuncSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGetSharpenTexFuncSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glArrayElementEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glArrayElementEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glArrayElementEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glArrayElement(__GLScontext *, GLubyte *);
    __glsSwapArrayData(inoutPtr);
    __gls_decode_bin_glArrayElement(ctx, inoutPtr);
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glColorPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorPointerEXT(__GLScontext *, GLubyte *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    size = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    stride = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 16);
    __gls_decode_bin_glColorPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because ColorPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glDrawArraysEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawArraysEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glDrawArraysEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDrawArrays(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwapArrayData(inoutPtr + 4);
    __gls_decode_bin_glDrawArrays(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr) {
    // DrewB - Non-functional
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glEdgeFlagPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEdgeFlagPointerEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glEdgeFlagPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because EdgeFlagPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glGetPointervEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPointervEXT(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glGetPointervEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetPointerv(__GLScontext *, GLubyte *);
    __glsSwap8(inoutPtr + 0);
    __glsSwap4(inoutPtr + 8);
    __gls_decode_bin_glGetPointerv(ctx, inoutPtr);
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glIndexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIndexPointerEXT(__GLScontext *, GLubyte *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 12);
    __gls_decode_bin_glIndexPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because IndexPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glNormalPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glNormalPointerEXT(__GLScontext *, GLubyte *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    type = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    stride = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    count = *(GLsizei *)(inoutPtr + 8);
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 12);
    __gls_decode_bin_glNormalPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because NormalPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glTexCoordPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexCoordPointerEXT(__GLScontext *, GLubyte *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    size = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    stride = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 16);
    __gls_decode_bin_glTexCoordPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because TexCoordPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_bin_swap_glVertexPointerEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glVertexPointerEXT(__GLScontext *, GLubyte *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    __glsSwap4(inoutPtr + 0);
    size = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    type = *(GLenum *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    stride = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    count = *(GLsizei *)(inoutPtr + 12);
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    __glsSwapv(type, pointer_count, inoutPtr + 16);
    __gls_decode_bin_glVertexPointerEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_bin_swap_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because VertexPointer isn't captured
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glAreTexturesResidentEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAreTexturesResidentEXT(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 12);
    __gls_decode_bin_glAreTexturesResidentEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glAreTexturesResident(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 12);
    __gls_decode_bin_glAreTexturesResident(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glBindTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBindTextureEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glBindTextureEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glBindTexture(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __gls_decode_bin_glBindTexture(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glDeleteTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDeleteTexturesEXT(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __gls_decode_bin_glDeleteTexturesEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDeleteTextures(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __gls_decode_bin_glDeleteTextures(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glGenTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGenTexturesEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGenTexturesEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGenTextures(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __gls_decode_bin_glGenTextures(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glIsTextureEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsTextureEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsTextureEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glIsTexture(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glIsTexture(ctx, inoutPtr);
}

#if __GL_EXT_texture_object
void __gls_decode_bin_swap_glPrioritizeTexturesEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPrioritizeTexturesEXT(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4 + 4 * __GLS_MAX(n, 0));
    __gls_decode_bin_glPrioritizeTexturesEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_bin_swap_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPrioritizeTextures(__GLScontext *, GLubyte *);
    GLsizei n;
    __glsSwap4(inoutPtr + 0);
    n = *(GLsizei *)(inoutPtr + 0);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4);
    __glsSwap4v(__GLS_MAX(n, 0), inoutPtr + 4 + 4 * __GLS_MAX(n, 0));
    __gls_decode_bin_glPrioritizeTextures(ctx, inoutPtr);
}

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorTableEXT(__GLScontext *, GLubyte *);
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint table_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    format = *(GLenum *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    type = *(GLenum *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    table_count = __gls_glColorTableEXT_table_size(format, type, width);
    __glsSwapv(type, table_count, inoutPtr + 24);
    __gls_decode_bin_glColorTableEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_decode_bin_swap_glColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorTableParameterfvSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glColorTableParameterfvSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glColorTableParameterfvSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_swap_glColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorTableParameterivSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glColorTableParameterivSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glColorTableParameterivSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_bin_swap_glCopyColorTableSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyColorTableSGI(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __gls_decode_bin_glCopyColorTableSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glGetColorTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetColorTableEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap8(inoutPtr + 12);
    __gls_decode_bin_glGetColorTableEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glGetColorTableParameterfvEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetColorTableParameterfvEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetColorTableParameterfvEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glGetColorTableParameterivEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetColorTableParameterivEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetColorTableParameterivEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glGetTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexColorTableParameterfvSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glGetTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glGetTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap8(inoutPtr + 4);
    __glsSwap4(inoutPtr + 12);
    __gls_decode_bin_glGetTexColorTableParameterivSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glTexColorTableParameterfvSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexColorTableParameterfvSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexColorTableParameterfvSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_bin_swap_glTexColorTableParameterivSGI(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
    GLenum pname;
    GLint params_count;
    __glsSwap4(inoutPtr + 0);
    pname = *(GLenum *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    params_count = __gls_glTexColorTableParameterivSGI_params_size(pname);
    __glsSwap4v(params_count, inoutPtr + 8);
    __gls_decode_bin_glTexColorTableParameterivSGI(ctx, inoutPtr);
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage1DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __gls_decode_bin_glCopyTexImage1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage1D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __gls_decode_bin_glCopyTexImage1D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage2DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexImage2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexImage2D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexImage2D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexSubImage1DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage1DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glCopyTexSubImage1DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage1D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __gls_decode_bin_glCopyTexSubImage1D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexSubImage2DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage2DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexSubImage2DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_bin_swap_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage2D(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __gls_decode_bin_glCopyTexSubImage2D(ctx, inoutPtr);
}

#if __GL_EXT_copy_texture
void __gls_decode_bin_swap_glCopyTexSubImage3DEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glCopyTexSubImage3DEXT(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __gls_decode_bin_glCopyTexSubImage3DEXT(ctx, inoutPtr);
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_decode_bin_swap_glTexImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexImage4DSGIS(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    size4d = *(GLsizei *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    format = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    type = *(GLenum *)(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __glsSwap4(inoutPtr + 40);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __glsSwapv(type, pixels_count, inoutPtr + 44);
    __gls_decode_bin_glTexImage4DSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_decode_bin_swap_glTexSubImage4DSGIS(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glTexSubImage4DSGIS(__GLScontext *, GLubyte *);
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    __glsSwap4(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    width = *(GLsizei *)(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    height = *(GLsizei *)(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    depth = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    size4d = *(GLsizei *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    format = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    type = *(GLenum *)(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    __glsSwap4(inoutPtr + 40);
    __glsSwap4(inoutPtr + 44);
    __glsSwap4(inoutPtr + 48);
    pixels_count = __gls_glTexSubImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __glsSwapv(type, pixels_count, inoutPtr + 52);
    __gls_decode_bin_glTexSubImage4DSGIS(ctx, inoutPtr);
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_decode_bin_swap_glPixelTexGenSGIX(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPixelTexGenSGIX(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPixelTexGenSGIX(ctx, inoutPtr);
}
#endif /* __GL_SGIX_pixel_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_bin_swap_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glColorSubTableEXT(__GLScontext *, GLubyte *);
    GLbitfield imageFlags;
    GLsizei entries;
    GLenum format;
    GLenum type;
    GLint entries_count;
    __glsSwap4(inoutPtr + 0);
    imageFlags = *(GLint *)(inoutPtr + 0);
    __glsSwap4(inoutPtr + 4);
    __glsSwap4(inoutPtr + 8);
    __glsSwap4(inoutPtr + 12);
    entries = *(GLsizei *)(inoutPtr + 12);
    __glsSwap4(inoutPtr + 16);
    format = *(GLenum *)(inoutPtr + 16);
    __glsSwap4(inoutPtr + 20);
    type = *(GLenum *)(inoutPtr + 20);
    __glsSwap4(inoutPtr + 24);
    __glsSwap4(inoutPtr + 28);
    __glsSwap4(inoutPtr + 32);
    __glsSwap4(inoutPtr + 36);
    entries_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glColorSubTableEXT_entries_size(format, type, entries);
    __glsSwapv(type, entries_count, inoutPtr + 40);
    __gls_decode_bin_glColorSubTableEXT(ctx, inoutPtr);
}
#endif // __GL_EXT_paletted_texture

void __gls_decode_bin_swap_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glDisableClientState(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glDisableClientState(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glEnableClientState(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glEnableClientState(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr) {
    // This should never be called because InterleavedArrays isn't captured
}

void __gls_decode_bin_swap_glPushClientAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    extern void __gls_decode_bin_glPushClientAttrib(__GLScontext *, GLubyte *);
    __glsSwap4(inoutPtr + 0);
    __gls_decode_bin_glPushClientAttrib(ctx, inoutPtr);
}

void __gls_decode_bin_swap_glPopClientAttrib(__GLScontext *ctx, GLubyte *inoutPtr) {
    typedef void (*__GLSdispatch)(void);
    ((__GLSdispatch)ctx->dispatchCall[399])();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_dectxt.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"
#include "stdlib.h"

void __gls_decode_text_glsBeginGLS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint inVersionMajor;
    GLint inVersionMinor;
    __glsReader_getGLint_text(inoutReader, &inVersionMajor);
    __glsReader_getGLint_text(inoutReader, &inVersionMinor);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[16])(
        inVersionMajor,
        inVersionMinor
    );
end:
    return;
}

void __gls_decode_text_glsBlock(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum);
    GLSenum inBlockType;
    __glsReader_getGLSenum_text(inoutReader, &inBlockType);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[17])(
        inBlockType
    );
end:
    return;
}

void __gls_decode_text_glsCallStream(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inName;
    __glsString_init(&inName);
    __glsReader_getGLcharv_text(inoutReader, &inName);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[18])(
        inName.head
    );
end:
    __glsString_final(&inName);
    return;
}

void __gls_decode_text_glsEndGLS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[19])(
    );
end:
    return;
}

void __gls_decode_text_glsError(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);
    GLSopcode inOpcode;
    GLSenum inError;
    __glsReader_getGLSopcode_text(inoutReader, &inOpcode);
    __glsReader_getGLSenum_text(inoutReader, &inError);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[20])(
        inOpcode,
        inError
    );
end:
    return;
}

void __gls_decode_text_glsGLRC(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint inGLRC;
    __glsReader_getGLuint_text(inoutReader, &inGLRC);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[21])(
        inGLRC
    );
end:
    return;
}

void __gls_decode_text_glsGLRCLayer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    GLuint inGLRC;
    GLuint inLayer;
    GLuint inReadLayer;
    __glsReader_getGLuint_text(inoutReader, &inGLRC);
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLuint_text(inoutReader, &inReadLayer);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[22])(
        inGLRC,
        inLayer,
        inReadLayer
    );
end:
    return;
}

void __gls_decode_text_glsHeaderGLRCi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    GLuint inGLRC;
    GLSenum inAttrib;
    GLint inVal;
    __glsReader_getGLuint_text(inoutReader, &inGLRC);
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[23])(
        inGLRC,
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderLayerf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLfloat);
    GLuint inLayer;
    GLSenum inAttrib;
    GLfloat inVal;
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLfloat_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[24])(
        inLayer,
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderLayeri(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    GLuint inLayer;
    GLSenum inAttrib;
    GLint inVal;
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[25])(
        inLayer,
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, GLfloat);
    GLSenum inAttrib;
    GLfloat inVal;
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLfloat_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[26])(
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, const GLfloat *);
    GLSenum inAttrib;
    GLint inVec_count;
    GLfloat *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    inVec_count = __gls_glsHeaderfv_inVec_size(inAttrib);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLfloat, 4 * inVec_count);
    if (!inVec) goto end;
    __glsReader_getGLfloatv_text(inoutReader, inVec_count, inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[27])(
        inAttrib,
        inVec
    );
end:
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsHeaderi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, GLint);
    GLSenum inAttrib;
    GLint inVal;
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[28])(
        inAttrib,
        inVal
    );
end:
    return;
}

void __gls_decode_text_glsHeaderiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, const GLint *);
    GLSenum inAttrib;
    GLint inVec_count;
    GLint *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    inVec_count = __gls_glsHeaderiv_inVec_size(inAttrib);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLint, 4 * inVec_count);
    if (!inVec) goto end;
    __glsReader_getGLintv_text(inoutReader, inVec_count, inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[29])(
        inAttrib,
        inVec
    );
end:
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsHeaderubz(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLSenum, const GLubyte *);
    GLSenum inAttrib;
    __GLSstring inString;
    __glsReader_getGLSenum_text(inoutReader, &inAttrib);
    __glsString_init(&inString);
    __glsReader_getGLcharv_text(inoutReader, &inString);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[30])(
        inAttrib,
        inString.head
    );
end:
    __glsString_final(&inString);
    return;
}

void __gls_decode_text_glsRequireExtension(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inExtension;
    __glsString_init(&inExtension);
    __glsReader_getGLcharv_text(inoutReader, &inExtension);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[31])(
        inExtension.head
    );
end:
    __glsString_final(&inExtension);
    return;
}

void __gls_decode_text_glsUnsupportedCommand(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[32])(
    );
end:
    return;
}

void __gls_decode_text_glsAppRef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLulong, GLuint);
    GLulong inAddress;
    GLuint inCount;
    __glsReader_getGLulong_text(inoutReader, &inAddress);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[33])(
        inAddress,
        inCount
    );
end:
    return;
}

void __gls_decode_text_glsBeginObj(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inTag;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[34])(
        inTag.head
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsCharubz(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, const GLubyte *);
    __GLSstring inTag;
    __GLSstring inString;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsString_init(&inString);
    __glsReader_getGLcharv_text(inoutReader, &inString);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[35])(
        inTag.head,
        inString.head
    );
end:
    __glsString_final(&inTag);
    __glsString_final(&inString);
    return;
}

void __gls_decode_text_glsComment(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLSstring inComment;
    __glsString_init(&inComment);
    __glsReader_getGLcharv_text(inoutReader, &inComment);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[36])(
        inComment.head
    );
end:
    __glsString_final(&inComment);
    return;
}

void __gls_decode_text_glsDisplayMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLuint, const GLfloat *);
    GLuint inLayer;
    GLSenum inMap;
    GLuint inCount;
    GLfloat *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    __glsReader_getGLSenum_text(inoutReader, &inMap);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLfloat, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[37])(
        inLayer,
        inMap,
        inCount,
        inVec
    );
end:
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsEndObj(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[38])(
    );
end:
    return;
}

void __gls_decode_text_glsNumb(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLbyte);
    __GLSstring inTag;
    GLbyte inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLbyte_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[39])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumbv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLbyte *);
    __GLSstring inTag;
    GLuint inCount;
    GLbyte *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLbyte, 1 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLbytev_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[40])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLdouble);
    __GLSstring inTag;
    GLdouble inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLdouble_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[41])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLdouble *);
    __GLSstring inTag;
    GLuint inCount;
    GLdouble *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLdouble, 8 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLdoublev_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[42])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLfloat);
    __GLSstring inTag;
    GLfloat inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLfloat_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[43])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLfloat *);
    __GLSstring inTag;
    GLuint inCount;
    GLfloat *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLfloat, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[44])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLint);
    __GLSstring inTag;
    GLint inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[45])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLint *);
    __GLSstring inTag;
    GLuint inCount;
    GLint *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLint, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLintv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[46])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNuml(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLlong);
    __GLSstring inTag;
    GLlong inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLlong_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[47])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumlv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLlong *);
    __GLSstring inTag;
    GLuint inCount;
    GLlong *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLlong, 8 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLlongv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[48])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNums(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLshort);
    __GLSstring inTag;
    GLshort inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLshort_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[49])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumsv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLshort *);
    __GLSstring inTag;
    GLuint inCount;
    GLshort *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLshort, 2 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLshortv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[50])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLubyte);
    __GLSstring inTag;
    GLubyte inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLubyte_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[51])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLubyte *);
    __GLSstring inTag;
    GLuint inCount;
    GLubyte *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLubyte, 1 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLubytev_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[52])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumui(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint);
    __GLSstring inTag;
    GLuint inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[53])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumuiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLuint *);
    __GLSstring inTag;
    GLuint inCount;
    GLuint *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLuint, 4 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[54])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumul(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLulong);
    __GLSstring inTag;
    GLulong inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLulong_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[55])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumulv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLulong *);
    __GLSstring inTag;
    GLuint inCount;
    GLulong *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLulong, 8 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLulongv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[56])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsNumus(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLushort);
    __GLSstring inTag;
    GLushort inVal;
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLushort_text(inoutReader, &inVal);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[57])(
        inTag.head,
        inVal
    );
end:
    __glsString_final(&inTag);
    return;
}

void __gls_decode_text_glsNumusv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLushort *);
    __GLSstring inTag;
    GLuint inCount;
    GLushort *inVec = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(inVec)
    __glsString_init(&inTag);
    __glsReader_getGLcharv_text(inoutReader, &inTag);
    __glsReader_getGLuint_text(inoutReader, &inCount);
    __GLS_DEC_ALLOC_TEXT(inoutReader, inVec, GLushort, 2 * __GLS_MAX(inCount, 0));
    if (!inVec) goto end;
    __glsReader_getGLushortv_text(inoutReader, __GLS_MAX(inCount, 0), inVec);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[58])(
        inTag.head,
        inCount,
        inVec
    );
end:
    __glsString_final(&inTag);
    __GLS_DEC_FREE(inVec);
    return;
}

void __gls_decode_text_glsPad(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[59])(
    );
end:
    return;
}

void __gls_decode_text_glsSwapBuffers(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint inLayer;
    __glsReader_getGLuint_text(inoutReader, &inLayer);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[60])(
        inLayer
    );
end:
    return;
}

void __gls_decode_text_glNewList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLenum);
    GLuint list;
    GLenum mode;
    __glsReader_getGLuint_text(inoutReader, &list);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[64])(
        list,
        mode
    );
end:
    return;
}

void __gls_decode_text_glEndList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[65])(
    );
end:
    return;
}

void __gls_decode_text_glCallList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint list;
    __glsReader_getGLuint_text(inoutReader, &list);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[66])(
        list
    );
end:
    return;
}

void __gls_decode_text_glCallLists(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, const GLvoid *);
    GLsizei n;
    GLenum type;
    GLint lists_count;
    GLvoid *lists = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(lists)
    __glsReader_getGLint_text(inoutReader, &n);
    __glsReader_getGLenum_text(inoutReader, &type);
    lists_count = __gls_glCallLists_lists_size(n, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, lists, GLvoid, 1 * lists_count);
    if (!lists) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, lists_count, lists);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[67])(
        n,
        type,
        lists
    );
end:
    __GLS_DEC_FREE(lists);
    return;
}

void __gls_decode_text_glDeleteLists(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLsizei);
    GLuint list;
    GLsizei range;
    __glsReader_getGLuint_text(inoutReader, &list);
    __glsReader_getGLint_text(inoutReader, &range);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[68])(
        list,
        range
    );
end:
    return;
}

void __gls_decode_text_glGenLists(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei);
    GLsizei range;
    __glsReader_getGLint_text(inoutReader, &range);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[69])(
        range
    );
end:
    return;
}

void __gls_decode_text_glListBase(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint base;
    __glsReader_getGLuint_text(inoutReader, &base);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[70])(
        base
    );
end:
    return;
}

void __gls_decode_text_glBegin(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[71])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glBitmap(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
    GLsizei width;
    GLsizei height;
    GLfloat xorig;
    GLfloat yorig;
    GLfloat xmove;
    GLfloat ymove;
    GLint bitmap_count;
    GLubyte *bitmap = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(bitmap)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLfloat_text(inoutReader, &xorig);
    __glsReader_getGLfloat_text(inoutReader, &yorig);
    __glsReader_getGLfloat_text(inoutReader, &xmove);
    __glsReader_getGLfloat_text(inoutReader, &ymove);
    bitmap_count = __gls_glBitmap_bitmap_size(width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, bitmap, GLubyte, 1 * bitmap_count);
    if (!bitmap) goto end;
    __glsReader_getGLubytev_text(inoutReader, bitmap_count, bitmap);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[72])(
        width,
        height,
        xorig,
        yorig,
        xmove,
        ymove,
        bitmap
    );
end:
    __GLS_DEC_FREE(bitmap);
    return;
}

void __gls_decode_text_glColor3b(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    __glsReader_getGLbyte_text(inoutReader, &red);
    __glsReader_getGLbyte_text(inoutReader, &green);
    __glsReader_getGLbyte_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[73])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3bv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    GLbyte v[3];
    __glsReader_getGLbytev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[74])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble red;
    GLdouble green;
    GLdouble blue;
    __glsReader_getGLdouble_text(inoutReader, &red);
    __glsReader_getGLdouble_text(inoutReader, &green);
    __glsReader_getGLdouble_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[75])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[76])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[77])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[78])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint red;
    GLint green;
    GLint blue;
    __glsReader_getGLint_text(inoutReader, &red);
    __glsReader_getGLint_text(inoutReader, &green);
    __glsReader_getGLint_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[79])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[80])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort red;
    GLshort green;
    GLshort blue;
    __glsReader_getGLshort_text(inoutReader, &red);
    __glsReader_getGLshort_text(inoutReader, &green);
    __glsReader_getGLshort_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[81])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[82])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3ub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte);
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    __glsReader_getGLubyte_text(inoutReader, &red);
    __glsReader_getGLubyte_text(inoutReader, &green);
    __glsReader_getGLubyte_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[83])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3ubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLubyte v[3];
    __glsReader_getGLubytev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[84])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3ui(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    GLuint red;
    GLuint green;
    GLuint blue;
    __glsReader_getGLuint_text(inoutReader, &red);
    __glsReader_getGLuint_text(inoutReader, &green);
    __glsReader_getGLuint_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[85])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3uiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLuint *);
    GLuint v[3];
    __glsReader_getGLuintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[86])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor3us(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort);
    GLushort red;
    GLushort green;
    GLushort blue;
    __glsReader_getGLushort_text(inoutReader, &red);
    __glsReader_getGLushort_text(inoutReader, &green);
    __glsReader_getGLushort_text(inoutReader, &blue);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[87])(
        red,
        green,
        blue
    );
end:
    return;
}

void __gls_decode_text_glColor3usv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLushort *);
    GLushort v[3];
    __glsReader_getGLushortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[88])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4b(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte, GLbyte);
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    GLbyte alpha;
    __glsReader_getGLbyte_text(inoutReader, &red);
    __glsReader_getGLbyte_text(inoutReader, &green);
    __glsReader_getGLbyte_text(inoutReader, &blue);
    __glsReader_getGLbyte_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[89])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4bv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    GLbyte v[4];
    __glsReader_getGLbytev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[90])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble red;
    GLdouble green;
    GLdouble blue;
    GLdouble alpha;
    __glsReader_getGLdouble_text(inoutReader, &red);
    __glsReader_getGLdouble_text(inoutReader, &green);
    __glsReader_getGLdouble_text(inoutReader, &blue);
    __glsReader_getGLdouble_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[91])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[92])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[93])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[94])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;
    __glsReader_getGLint_text(inoutReader, &red);
    __glsReader_getGLint_text(inoutReader, &green);
    __glsReader_getGLint_text(inoutReader, &blue);
    __glsReader_getGLint_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[95])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[96])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort red;
    GLshort green;
    GLshort blue;
    GLshort alpha;
    __glsReader_getGLshort_text(inoutReader, &red);
    __glsReader_getGLshort_text(inoutReader, &green);
    __glsReader_getGLshort_text(inoutReader, &blue);
    __glsReader_getGLshort_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[97])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[98])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4ub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte, GLubyte);
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;
    __glsReader_getGLubyte_text(inoutReader, &red);
    __glsReader_getGLubyte_text(inoutReader, &green);
    __glsReader_getGLubyte_text(inoutReader, &blue);
    __glsReader_getGLubyte_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[99])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4ubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLubyte v[4];
    __glsReader_getGLubytev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[100])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4ui(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint, GLuint);
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;
    __glsReader_getGLuint_text(inoutReader, &red);
    __glsReader_getGLuint_text(inoutReader, &green);
    __glsReader_getGLuint_text(inoutReader, &blue);
    __glsReader_getGLuint_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[101])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4uiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLuint *);
    GLuint v[4];
    __glsReader_getGLuintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[102])(
        v
    );
end:
    return;
}

void __gls_decode_text_glColor4us(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort, GLushort);
    GLushort red;
    GLushort green;
    GLushort blue;
    GLushort alpha;
    __glsReader_getGLushort_text(inoutReader, &red);
    __glsReader_getGLushort_text(inoutReader, &green);
    __glsReader_getGLushort_text(inoutReader, &blue);
    __glsReader_getGLushort_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[103])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glColor4usv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLushort *);
    GLushort v[4];
    __glsReader_getGLushortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[104])(
        v
    );
end:
    return;
}

void __gls_decode_text_glEdgeFlag(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLboolean);
    GLboolean flag;
    __glsReader_getGLboolean_text(inoutReader, &flag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[105])(
        flag
    );
end:
    return;
}

void __gls_decode_text_glEdgeFlagv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLboolean *);
    GLboolean flag[1];
    __glsReader_getGLbooleanv_text(inoutReader, 1, flag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[106])(
        flag
    );
end:
    return;
}

void __gls_decode_text_glEnd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[107])(
    );
end:
    return;
}

void __gls_decode_text_glIndexd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble);
    GLdouble c;
    __glsReader_getGLdouble_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[108])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble c[1];
    __glsReader_getGLdoublev_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[109])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat c;
    __glsReader_getGLfloat_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[110])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat c[1];
    __glsReader_getGLfloatv_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[111])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint c;
    __glsReader_getGLint_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[112])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint c[1];
    __glsReader_getGLintv_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[113])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexs(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort);
    GLshort c;
    __glsReader_getGLshort_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[114])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexsv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort c[1];
    __glsReader_getGLshortv_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[115])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexub(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte);
    GLubyte c;
    __glsReader_getGLubyte_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[379])(
        c
    );
end:
    return;
}

void __gls_decode_text_glIndexubv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLubyte c[1];
    __glsReader_getGLubytev_text(inoutReader, 1, c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[380])(
        c
    );
end:
    return;
}

void __gls_decode_text_glNormal3b(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;
    __glsReader_getGLbyte_text(inoutReader, &nx);
    __glsReader_getGLbyte_text(inoutReader, &ny);
    __glsReader_getGLbyte_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[116])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3bv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    GLbyte v[3];
    __glsReader_getGLbytev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[117])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble nx;
    GLdouble ny;
    GLdouble nz;
    __glsReader_getGLdouble_text(inoutReader, &nx);
    __glsReader_getGLdouble_text(inoutReader, &ny);
    __glsReader_getGLdouble_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[118])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[119])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    __glsReader_getGLfloat_text(inoutReader, &nx);
    __glsReader_getGLfloat_text(inoutReader, &ny);
    __glsReader_getGLfloat_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[120])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[121])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint nx;
    GLint ny;
    GLint nz;
    __glsReader_getGLint_text(inoutReader, &nx);
    __glsReader_getGLint_text(inoutReader, &ny);
    __glsReader_getGLint_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[122])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[123])(
        v
    );
end:
    return;
}

void __gls_decode_text_glNormal3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort nx;
    GLshort ny;
    GLshort nz;
    __glsReader_getGLshort_text(inoutReader, &nx);
    __glsReader_getGLshort_text(inoutReader, &ny);
    __glsReader_getGLshort_text(inoutReader, &nz);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[124])(
        nx,
        ny,
        nz
    );
end:
    return;
}

void __gls_decode_text_glNormal3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[125])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[126])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[127])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[128])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[129])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint x;
    GLint y;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[130])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[2];
    __glsReader_getGLintv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[131])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    GLshort x;
    GLshort y;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[132])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glRasterPos2sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[133])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[134])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[135])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[136])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[137])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[138])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[139])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[140])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRasterPos3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[141])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    __glsReader_getGLdouble_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[142])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[143])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    __glsReader_getGLfloat_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[144])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[145])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    GLint w;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    __glsReader_getGLint_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[146])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[147])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    __glsReader_getGLshort_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[148])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glRasterPos4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[149])(
        v
    );
end:
    return;
}

void __gls_decode_text_glRectd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble x1;
    GLdouble y1;
    GLdouble x2;
    GLdouble y2;
    __glsReader_getGLdouble_text(inoutReader, &x1);
    __glsReader_getGLdouble_text(inoutReader, &y1);
    __glsReader_getGLdouble_text(inoutReader, &x2);
    __glsReader_getGLdouble_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[150])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *, const GLdouble *);
    GLdouble v1[2];
    GLdouble v2[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v1);
    __glsReader_getGLdoublev_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[151])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glRectf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat x1;
    GLfloat y1;
    GLfloat x2;
    GLfloat y2;
    __glsReader_getGLfloat_text(inoutReader, &x1);
    __glsReader_getGLfloat_text(inoutReader, &y1);
    __glsReader_getGLfloat_text(inoutReader, &x2);
    __glsReader_getGLfloat_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[152])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *, const GLfloat *);
    GLfloat v1[2];
    GLfloat v2[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v1);
    __glsReader_getGLfloatv_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[153])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glRecti(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint x1;
    GLint y1;
    GLint x2;
    GLint y2;
    __glsReader_getGLint_text(inoutReader, &x1);
    __glsReader_getGLint_text(inoutReader, &y1);
    __glsReader_getGLint_text(inoutReader, &x2);
    __glsReader_getGLint_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[154])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *, const GLint *);
    GLint v1[2];
    GLint v2[2];
    __glsReader_getGLintv_text(inoutReader, 2, v1);
    __glsReader_getGLintv_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[155])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glRects(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort x1;
    GLshort y1;
    GLshort x2;
    GLshort y2;
    __glsReader_getGLshort_text(inoutReader, &x1);
    __glsReader_getGLshort_text(inoutReader, &y1);
    __glsReader_getGLshort_text(inoutReader, &x2);
    __glsReader_getGLshort_text(inoutReader, &y2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[156])(
        x1,
        y1,
        x2,
        y2
    );
end:
    return;
}

void __gls_decode_text_glRectsv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *, const GLshort *);
    GLshort v1[2];
    GLshort v2[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v1);
    __glsReader_getGLshortv_text(inoutReader, 2, v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[157])(
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble);
    GLdouble s;
    __glsReader_getGLdouble_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[158])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[1];
    __glsReader_getGLdoublev_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[159])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat s;
    __glsReader_getGLfloat_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[160])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[1];
    __glsReader_getGLfloatv_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[161])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint s;
    __glsReader_getGLint_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[162])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[1];
    __glsReader_getGLintv_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[163])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort);
    GLshort s;
    __glsReader_getGLshort_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[164])(
        s
    );
end:
    return;
}

void __gls_decode_text_glTexCoord1sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[1];
    __glsReader_getGLshortv_text(inoutReader, 1, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[165])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble s;
    GLdouble t;
    __glsReader_getGLdouble_text(inoutReader, &s);
    __glsReader_getGLdouble_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[166])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[167])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat s;
    GLfloat t;
    __glsReader_getGLfloat_text(inoutReader, &s);
    __glsReader_getGLfloat_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[168])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[169])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint s;
    GLint t;
    __glsReader_getGLint_text(inoutReader, &s);
    __glsReader_getGLint_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[170])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[2];
    __glsReader_getGLintv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[171])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    GLshort s;
    GLshort t;
    __glsReader_getGLshort_text(inoutReader, &s);
    __glsReader_getGLshort_text(inoutReader, &t);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[172])(
        s,
        t
    );
end:
    return;
}

void __gls_decode_text_glTexCoord2sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[173])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble s;
    GLdouble t;
    GLdouble r;
    __glsReader_getGLdouble_text(inoutReader, &s);
    __glsReader_getGLdouble_text(inoutReader, &t);
    __glsReader_getGLdouble_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[174])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[175])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat s;
    GLfloat t;
    GLfloat r;
    __glsReader_getGLfloat_text(inoutReader, &s);
    __glsReader_getGLfloat_text(inoutReader, &t);
    __glsReader_getGLfloat_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[176])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[177])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint s;
    GLint t;
    GLint r;
    __glsReader_getGLint_text(inoutReader, &s);
    __glsReader_getGLint_text(inoutReader, &t);
    __glsReader_getGLint_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[178])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[179])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort s;
    GLshort t;
    GLshort r;
    __glsReader_getGLshort_text(inoutReader, &s);
    __glsReader_getGLshort_text(inoutReader, &t);
    __glsReader_getGLshort_text(inoutReader, &r);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[180])(
        s,
        t,
        r
    );
end:
    return;
}

void __gls_decode_text_glTexCoord3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[181])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble s;
    GLdouble t;
    GLdouble r;
    GLdouble q;
    __glsReader_getGLdouble_text(inoutReader, &s);
    __glsReader_getGLdouble_text(inoutReader, &t);
    __glsReader_getGLdouble_text(inoutReader, &r);
    __glsReader_getGLdouble_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[182])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[183])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
    __glsReader_getGLfloat_text(inoutReader, &s);
    __glsReader_getGLfloat_text(inoutReader, &t);
    __glsReader_getGLfloat_text(inoutReader, &r);
    __glsReader_getGLfloat_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[184])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[185])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint s;
    GLint t;
    GLint r;
    GLint q;
    __glsReader_getGLint_text(inoutReader, &s);
    __glsReader_getGLint_text(inoutReader, &t);
    __glsReader_getGLint_text(inoutReader, &r);
    __glsReader_getGLint_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[186])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[187])(
        v
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
    __glsReader_getGLshort_text(inoutReader, &s);
    __glsReader_getGLshort_text(inoutReader, &t);
    __glsReader_getGLshort_text(inoutReader, &r);
    __glsReader_getGLshort_text(inoutReader, &q);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[188])(
        s,
        t,
        r,
        q
    );
end:
    return;
}

void __gls_decode_text_glTexCoord4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[189])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[190])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[191])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[192])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[193])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint x;
    GLint y;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[194])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[2];
    __glsReader_getGLintv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[195])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex2s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    GLshort x;
    GLshort y;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[196])(
        x,
        y
    );
end:
    return;
}

void __gls_decode_text_glVertex2sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[2];
    __glsReader_getGLshortv_text(inoutReader, 2, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[197])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[198])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[3];
    __glsReader_getGLdoublev_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[199])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[200])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[3];
    __glsReader_getGLfloatv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[201])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[202])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[3];
    __glsReader_getGLintv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[203])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex3s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[204])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glVertex3sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[3];
    __glsReader_getGLshortv_text(inoutReader, 3, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[205])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    GLdouble w;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    __glsReader_getGLdouble_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[206])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble v[4];
    __glsReader_getGLdoublev_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[207])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    __glsReader_getGLfloat_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[208])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat v[4];
    __glsReader_getGLfloatv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[209])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4i(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    GLint x;
    GLint y;
    GLint z;
    GLint w;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &z);
    __glsReader_getGLint_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[210])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4iv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLint *);
    GLint v[4];
    __glsReader_getGLintv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[211])(
        v
    );
end:
    return;
}

void __gls_decode_text_glVertex4s(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
    __glsReader_getGLshort_text(inoutReader, &x);
    __glsReader_getGLshort_text(inoutReader, &y);
    __glsReader_getGLshort_text(inoutReader, &z);
    __glsReader_getGLshort_text(inoutReader, &w);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[212])(
        x,
        y,
        z,
        w
    );
end:
    return;
}

void __gls_decode_text_glVertex4sv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLshort *);
    GLshort v[4];
    __glsReader_getGLshortv_text(inoutReader, 4, v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[213])(
        v
    );
end:
    return;
}

void __gls_decode_text_glClipPlane(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLdouble *);
    GLenum plane;
    GLdouble equation[4];
    __glsReader_getGLenum_text(inoutReader, &plane);
    __glsReader_getGLdoublev_text(inoutReader, 4, equation);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[214])(
        plane,
        equation
    );
end:
    return;
}

void __gls_decode_text_glColorMaterial(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum face;
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[215])(
        face,
        mode
    );
end:
    return;
}

void __gls_decode_text_glCullFace(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[216])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glFogf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[217])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glFogfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glFogfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[218])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glFogi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[219])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glFogiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glFogiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[220])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glFrontFace(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[221])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glHint(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum target;
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[222])(
        target,
        mode
    );
end:
    return;
}

void __gls_decode_text_glLightf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum light;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[223])(
        light,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[224])(
        light,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLighti(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum light;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[225])(
        light,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[226])(
        light,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLightModelf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[227])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightModelfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightModelfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[228])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLightModeli(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[229])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glLightModeliv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glLightModeliv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[230])(
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glLineStipple(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLushort);
    GLint factor;
    GLushort pattern;
    __glsReader_getGLint_text(inoutReader, &factor);
    __glsReader_getGLushort_text(inoutReader, &pattern);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[231])(
        factor,
        pattern
    );
end:
    return;
}

void __gls_decode_text_glLineWidth(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat width;
    __glsReader_getGLfloat_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[232])(
        width
    );
end:
    return;
}

void __gls_decode_text_glMaterialf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum face;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[233])(
        face,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glMaterialfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glMaterialfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[234])(
        face,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glMateriali(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum face;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[235])(
        face,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glMaterialiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glMaterialiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[236])(
        face,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glPointSize(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat size;
    __glsReader_getGLfloat_text(inoutReader, &size);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[237])(
        size
    );
end:
    return;
}

void __gls_decode_text_glPolygonMode(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum face;
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[238])(
        face,
        mode
    );
end:
    return;
}

void __gls_decode_text_glPolygonStipple(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    GLint mask_count;
    GLubyte *mask = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(mask)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    mask_count = __gls_glPolygonStipple_mask_size();
    __GLS_DEC_ALLOC_TEXT(inoutReader, mask, GLubyte, 1 * mask_count);
    if (!mask) goto end;
    __glsReader_getGLubytev_text(inoutReader, mask_count, mask);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[239])(
        mask
    );
end:
    __GLS_DEC_FREE(mask);
    return;
}

void __gls_decode_text_glScissor(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[240])(
        x,
        y,
        width,
        height
    );
end:
    return;
}

void __gls_decode_text_glShadeModel(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[241])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glTexParameterf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum target;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[242])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexParameterfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[243])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexParameteri(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum target;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[244])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexParameteriv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[245])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint components;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLtextureComponentCount_text(inoutReader, &components);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage1D_pixels_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[246])(
        target,
        level,
        components,
        width,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glTexImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint components;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLtextureComponentCount_text(inoutReader, &components);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage2D_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[247])(
        target,
        level,
        components,
        width,
        height,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glTexEnvf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum target;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[248])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexEnvfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexEnvfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[249])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexEnvi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum target;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[250])(
        target,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexEnviv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexEnviv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[251])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexGend(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble);
    GLenum coord;
    GLenum pname;
    GLdouble param;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLdouble_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[252])(
        coord,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexGendv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLdouble *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexGendv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLdouble, 8 * params_count);
    if (!params) goto end;
    __glsReader_getGLdoublev_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[253])(
        coord,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexGenf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum coord;
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[254])(
        coord,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexGenfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexGenfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[255])(
        coord,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glTexGeni(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum coord;
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[256])(
        coord,
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glTexGeniv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexGeniv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[257])(
        coord,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glFeedbackBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, GLfloat *);
    GLsizei size;
    GLenum type;
    GLfloat *buffer = GLS_NONE;
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    buffer = (GLfloat *)__glsReader_allocFeedbackBuf(inoutReader, 4 * __GLS_MAX(size, 0));
    if (!buffer) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[258])(
        size,
        type,
        buffer
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

void __gls_decode_text_glSelectBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    GLsizei size;
    GLuint *buffer = GLS_NONE;
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &size);
    buffer = (GLuint *)__glsReader_allocSelectBuf(inoutReader, 4 * __GLS_MAX(size, 0));
    if (!buffer) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[259])(
        size,
        buffer
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

void __gls_decode_text_glRenderMode(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[260])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glInitNames(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[261])(
    );
end:
    return;
}

void __gls_decode_text_glLoadName(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint name;
    __glsReader_getGLuint_text(inoutReader, &name);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[262])(
        name
    );
end:
    return;
}

void __gls_decode_text_glPassThrough(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat token;
    __glsReader_getGLfloat_text(inoutReader, &token);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[263])(
        token
    );
end:
    return;
}

void __gls_decode_text_glPopName(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[264])(
    );
end:
    return;
}

void __gls_decode_text_glPushName(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint name;
    __glsReader_getGLuint_text(inoutReader, &name);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[265])(
        name
    );
end:
    return;
}

void __gls_decode_text_glDrawBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLdrawBufferMode_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[266])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glClear(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbitfield);
    GLbitfield mask;
    __glsReader_getGLclearBufferMask_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[267])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glClearAccum(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[268])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glClearIndex(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat c;
    __glsReader_getGLfloat_text(inoutReader, &c);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[269])(
        c
    );
end:
    return;
}

void __gls_decode_text_glClearColor(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[270])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glClearStencil(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint s;
    __glsReader_getGLint_text(inoutReader, &s);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[271])(
        s
    );
end:
    return;
}

void __gls_decode_text_glClearDepth(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampd);
    GLclampd depth;
    __glsReader_getGLdouble_text(inoutReader, &depth);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[272])(
        depth
    );
end:
    return;
}

void __gls_decode_text_glStencilMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint mask;
    __glsReader_getGLuint_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[273])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glColorMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLboolean, GLboolean, GLboolean, GLboolean);
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
    __glsReader_getGLboolean_text(inoutReader, &red);
    __glsReader_getGLboolean_text(inoutReader, &green);
    __glsReader_getGLboolean_text(inoutReader, &blue);
    __glsReader_getGLboolean_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[274])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}

void __gls_decode_text_glDepthMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLboolean);
    GLboolean flag;
    __glsReader_getGLboolean_text(inoutReader, &flag);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[275])(
        flag
    );
end:
    return;
}

void __gls_decode_text_glIndexMask(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint mask;
    __glsReader_getGLuint_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[276])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glAccum(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum op;
    GLfloat value;
    __glsReader_getGLenum_text(inoutReader, &op);
    __glsReader_getGLfloat_text(inoutReader, &value);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[277])(
        op,
        value
    );
end:
    return;
}

void __gls_decode_text_glDisable(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[278])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glEnable(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[279])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glFinish(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[280])(
    );
end:
    return;
}

void __gls_decode_text_glFlush(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[281])(
    );
end:
    return;
}

void __gls_decode_text_glPopAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[282])(
    );
end:
    return;
}

void __gls_decode_text_glPushAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLbitfield);
    GLbitfield mask;
    __glsReader_getGLattribMask_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[283])(
        mask
    );
end:
    return;
}

void __gls_decode_text_glMap1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint stride;
    GLint order;
    GLint points_count;
    GLdouble *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &order);
    points_count = __gls_glMap1d_points_size(target, stride, order);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLdouble, 8 * points_count);
    if (!points) goto end;
    __glsReader_getGLdoublev_text(inoutReader, points_count, points);
    if (stride > __glsEvalComputeK(target)) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[284])(
        target,
        u1,
        u2,
        stride,
        order,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMap1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &order);
    points_count = __gls_glMap1f_points_size(target, stride, order);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, points_count, points);
    if (stride > __glsEvalComputeK(target)) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[285])(
        target,
        u1,
        u2,
        stride,
        order,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMap2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    GLenum target;
    GLdouble u1;
    GLdouble u2;
    GLint ustride;
    GLint uorder;
    GLdouble v1;
    GLdouble v2;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    GLdouble *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &ustride);
    __glsReader_getGLint_text(inoutReader, &uorder);
    __glsReader_getGLdouble_text(inoutReader, &v1);
    __glsReader_getGLdouble_text(inoutReader, &v2);
    __glsReader_getGLint_text(inoutReader, &vstride);
    __glsReader_getGLint_text(inoutReader, &vorder);
    points_count = __gls_glMap2d_points_size(target, ustride, uorder, vstride, vorder);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLdouble, 8 * points_count);
    if (!points) goto end;
    __glsReader_getGLdoublev_text(inoutReader, points_count, points);
    if (!(
        vstride <= __glsEvalComputeK(target) && ustride <= vstride * vorder ||
        ustride <= __glsEvalComputeK(target) && vstride <= ustride * uorder
    )) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[286])(
        target,
        u1,
        u2,
        ustride,
        uorder,
        v1,
        v2,
        vstride,
        vorder,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMap2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &ustride);
    __glsReader_getGLint_text(inoutReader, &uorder);
    __glsReader_getGLfloat_text(inoutReader, &v1);
    __glsReader_getGLfloat_text(inoutReader, &v2);
    __glsReader_getGLint_text(inoutReader, &vstride);
    __glsReader_getGLint_text(inoutReader, &vorder);
    points_count = __gls_glMap2f_points_size(target, ustride, uorder, vstride, vorder);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, points_count, points);
    if (!(
        vstride <= __glsEvalComputeK(target) && ustride <= vstride * vorder ||
        ustride <= __glsEvalComputeK(target) && vstride <= ustride * uorder
    )) {
        __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    }
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[287])(
        target,
        u1,
        u2,
        ustride,
        uorder,
        v1,
        v2,
        vstride,
        vorder,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}

void __gls_decode_text_glMapGrid1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble);
    GLint un;
    GLdouble u1;
    GLdouble u2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[288])(
        un,
        u1,
        u2
    );
end:
    return;
}

void __gls_decode_text_glMapGrid1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat);
    GLint un;
    GLfloat u1;
    GLfloat u2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[289])(
        un,
        u1,
        u2
    );
end:
    return;
}

void __gls_decode_text_glMapGrid2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
    GLint un;
    GLdouble u1;
    GLdouble u2;
    GLint vn;
    GLdouble v1;
    GLdouble v2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLdouble_text(inoutReader, &u1);
    __glsReader_getGLdouble_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &vn);
    __glsReader_getGLdouble_text(inoutReader, &v1);
    __glsReader_getGLdouble_text(inoutReader, &v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[290])(
        un,
        u1,
        u2,
        vn,
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glMapGrid2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
    GLint un;
    GLfloat u1;
    GLfloat u2;
    GLint vn;
    GLfloat v1;
    GLfloat v2;
    __glsReader_getGLint_text(inoutReader, &un);
    __glsReader_getGLfloat_text(inoutReader, &u1);
    __glsReader_getGLfloat_text(inoutReader, &u2);
    __glsReader_getGLint_text(inoutReader, &vn);
    __glsReader_getGLfloat_text(inoutReader, &v1);
    __glsReader_getGLfloat_text(inoutReader, &v2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[291])(
        un,
        u1,
        u2,
        vn,
        v1,
        v2
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble);
    GLdouble u;
    __glsReader_getGLdouble_text(inoutReader, &u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[292])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble u[1];
    __glsReader_getGLdoublev_text(inoutReader, 1, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[293])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat);
    GLfloat u;
    __glsReader_getGLfloat_text(inoutReader, &u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[294])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord1fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat u[1];
    __glsReader_getGLfloatv_text(inoutReader, 1, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[295])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2d(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    GLdouble u;
    GLdouble v;
    __glsReader_getGLdouble_text(inoutReader, &u);
    __glsReader_getGLdouble_text(inoutReader, &v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[296])(
        u,
        v
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2dv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble u[2];
    __glsReader_getGLdoublev_text(inoutReader, 2, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[297])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2f(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat u;
    GLfloat v;
    __glsReader_getGLfloat_text(inoutReader, &u);
    __glsReader_getGLfloat_text(inoutReader, &v);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[298])(
        u,
        v
    );
end:
    return;
}

void __gls_decode_text_glEvalCoord2fv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat u[2];
    __glsReader_getGLfloatv_text(inoutReader, 2, u);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[299])(
        u
    );
end:
    return;
}

void __gls_decode_text_glEvalMesh1(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint);
    GLenum mode;
    GLint i1;
    GLint i2;
    __glsReader_getGLenum_text(inoutReader, &mode);
    __glsReader_getGLint_text(inoutReader, &i1);
    __glsReader_getGLint_text(inoutReader, &i2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[300])(
        mode,
        i1,
        i2
    );
end:
    return;
}

void __gls_decode_text_glEvalPoint1(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint i;
    __glsReader_getGLint_text(inoutReader, &i);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[301])(
        i
    );
end:
    return;
}

void __gls_decode_text_glEvalMesh2(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint);
    GLenum mode;
    GLint i1;
    GLint i2;
    GLint j1;
    GLint j2;
    __glsReader_getGLenum_text(inoutReader, &mode);
    __glsReader_getGLint_text(inoutReader, &i1);
    __glsReader_getGLint_text(inoutReader, &i2);
    __glsReader_getGLint_text(inoutReader, &j1);
    __glsReader_getGLint_text(inoutReader, &j2);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[302])(
        mode,
        i1,
        i2,
        j1,
        j2
    );
end:
    return;
}

void __gls_decode_text_glEvalPoint2(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    GLint i;
    GLint j;
    __glsReader_getGLint_text(inoutReader, &i);
    __glsReader_getGLint_text(inoutReader, &j);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[303])(
        i,
        j
    );
end:
    return;
}

void __gls_decode_text_glAlphaFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLclampf);
    GLenum func;
    GLclampf ref;
    __glsReader_getGLenum_text(inoutReader, &func);
    __glsReader_getGLfloat_text(inoutReader, &ref);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[304])(
        func,
        ref
    );
end:
    return;
}

void __gls_decode_text_glBlendFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    GLenum sfactor;
    GLenum dfactor;
    __glsReader_getGLblendingFactor_text(inoutReader, &sfactor);
    __glsReader_getGLblendingFactor_text(inoutReader, &dfactor);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[305])(
        sfactor,
        dfactor
    );
end:
    return;
}

void __gls_decode_text_glLogicOp(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum opcode;
    __glsReader_getGLenum_text(inoutReader, &opcode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[306])(
        opcode
    );
end:
    return;
}

void __gls_decode_text_glStencilFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLuint);
    GLenum func;
    GLint ref;
    GLuint mask;
    __glsReader_getGLenum_text(inoutReader, &func);
    __glsReader_getGLint_text(inoutReader, &ref);
    __glsReader_getGLuint_text(inoutReader, &mask);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[307])(
        func,
        ref,
        mask
    );
end:
    return;
}

void __gls_decode_text_glStencilOp(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum);
    GLenum fail;
    GLenum zfail;
    GLenum zpass;
    __glsReader_getGLstencilOp_text(inoutReader, &fail);
    __glsReader_getGLstencilOp_text(inoutReader, &zfail);
    __glsReader_getGLstencilOp_text(inoutReader, &zpass);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[308])(
        fail,
        zfail,
        zpass
    );
end:
    return;
}

void __gls_decode_text_glDepthFunc(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum func;
    __glsReader_getGLenum_text(inoutReader, &func);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[309])(
        func
    );
end:
    return;
}

void __gls_decode_text_glPixelZoom(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat xfactor;
    GLfloat yfactor;
    __glsReader_getGLfloat_text(inoutReader, &xfactor);
    __glsReader_getGLfloat_text(inoutReader, &yfactor);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[310])(
        xfactor,
        yfactor
    );
end:
    return;
}

void __gls_decode_text_glPixelTransferf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[311])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelTransferi(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[312])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelStoref(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    GLenum pname;
    GLfloat param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[313])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelStorei(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    GLenum pname;
    GLint param;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &param);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[314])(
        pname,
        param
    );
end:
    return;
}

void __gls_decode_text_glPixelMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLfloat *);
    GLenum map;
    GLint mapsize;
    GLfloat *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    __glsReader_getGLenum_text(inoutReader, &map);
    __glsReader_getGLint_text(inoutReader, &mapsize);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLfloat, 4 * __GLS_MAX(mapsize, 0));
    if (!values) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(mapsize, 0), values);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[315])(
        map,
        mapsize,
        values
    );
end:
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glPixelMapuiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLuint *);
    GLenum map;
    GLint mapsize;
    GLuint *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    __glsReader_getGLenum_text(inoutReader, &map);
    __glsReader_getGLint_text(inoutReader, &mapsize);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLuint, 4 * __GLS_MAX(mapsize, 0));
    if (!values) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(mapsize, 0), values);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[316])(
        map,
        mapsize,
        values
    );
end:
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glPixelMapusv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLushort *);
    GLenum map;
    GLint mapsize;
    GLushort *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    __glsReader_getGLenum_text(inoutReader, &map);
    __glsReader_getGLint_text(inoutReader, &mapsize);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLushort, 2 * __GLS_MAX(mapsize, 0));
    if (!values) goto end;
    __glsReader_getGLushortv_text(inoutReader, __GLS_MAX(mapsize, 0), values);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[317])(
        map,
        mapsize,
        values
    );
end:
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glReadBuffer(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[318])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glCopyPixels(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum type;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &type);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[319])(
        x,
        y,
        width,
        height,
        type
    );
end:
    return;
}

void __gls_decode_text_glReadPixels(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glReadPixels_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[320])(
        x,
        y,
        width,
        height,
        format,
        type,
        pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glDrawPixels(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glDrawPixels_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[321])(
        width,
        height,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glGetBooleanv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean *);
    GLenum pname;
    GLint params_count;
    GLboolean *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetBooleanv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLboolean, 1 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[322])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetClipPlane(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    GLenum plane;
    GLdouble equation[4];
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &plane);
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[323])(
        plane,
        equation
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

void __gls_decode_text_glGetDoublev(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetDoublev_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLdouble, 8 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[324])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetError(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[325])(
    );
end:
    return;
}

void __gls_decode_text_glGetFloatv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetFloatv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[326])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetIntegerv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint *);
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetIntegerv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[327])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetLightfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetLightfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[328])(
        light,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetLightiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum light;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &light);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetLightiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[329])(
        light,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetMapdv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    GLenum target;
    GLenum query;
    GLint v_count;
    GLdouble *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &query);
    v_count = __gls_glGetMapdv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_TEXT(inoutReader, v, GLdouble, 8 * v_count);
    if (!v) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[330])(
        target,
        query,
        v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
    return;
}

void __gls_decode_text_glGetMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum query;
    GLint v_count;
    GLfloat *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &query);
    v_count = __gls_glGetMapfv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_TEXT(inoutReader, v, GLfloat, 4 * v_count);
    if (!v) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[331])(
        target,
        query,
        v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
    return;
}

void __gls_decode_text_glGetMapiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum query;
    GLint v_count;
    GLint *v = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(v)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &query);
    v_count = __gls_glGetMapiv_v_size(ctx, target, query);
    __GLS_DEC_ALLOC_TEXT(inoutReader, v, GLint, 4 * v_count);
    if (!v) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[332])(
        target,
        query,
        v
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(v);
    return;
}

void __gls_decode_text_glGetMaterialfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMaterialfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[333])(
        face,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetMaterialiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum face;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &face);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMaterialiv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[334])(
        face,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetPixelMapfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum map;
    GLint values_count;
    GLfloat *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &map);
    values_count = __gls_glGetPixelMapfv_values_size(ctx, map);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLfloat, 4 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[335])(
        map,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glGetPixelMapuiv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint *);
    GLenum map;
    GLint values_count;
    GLuint *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &map);
    values_count = __gls_glGetPixelMapuiv_values_size(ctx, map);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLuint, 4 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[336])(
        map,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glGetPixelMapusv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLushort *);
    GLenum map;
    GLint values_count;
    GLushort *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &map);
    values_count = __gls_glGetPixelMapusv_values_size(ctx, map);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLushort, 2 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[337])(
        map,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}

void __gls_decode_text_glGetPolygonStipple(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLubyte *);
    GLint mask_count;
    GLubyte *mask = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(mask)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    mask_count = __gls_glGetPolygonStipple_mask_size();
    __GLS_DEC_ALLOC_TEXT(inoutReader, mask, GLubyte, 1 * mask_count);
    if (!mask) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[338])(
        mask
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(mask);
    return;
}

void __gls_decode_text_glGetString(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum name;
    __glsReader_getGLenum_text(inoutReader, &name);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[339])(
        name
    );
end:
    return;
}

void __gls_decode_text_glGetTexEnvfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexEnvfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[340])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexEnviv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexEnviv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[341])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexGendv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLdouble *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexGendv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLdouble, 8 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[342])(
        coord,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexGenfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexGenfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[343])(
        coord,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexGeniv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum coord;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &coord);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexGeniv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[344])(
        coord,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexImage(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glGetTexImage_pixels_size(ctx, target, level, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[345])(
        target,
        level,
        format,
        type,
        pixels
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(pixels);
    return;
}

void __gls_decode_text_glGetTexParameterfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[346])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexParameteriv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[347])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexLevelParameterfv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLfloat *);
    GLenum target;
    GLint level;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexLevelParameterfv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[348])(
        target,
        level,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glGetTexLevelParameteriv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint *);
    GLenum target;
    GLint level;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexLevelParameteriv_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[349])(
        target,
        level,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}

void __gls_decode_text_glIsEnabled(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[350])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glIsList(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint list;
    __glsReader_getGLuint_text(inoutReader, &list);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[351])(
        list
    );
end:
    return;
}

void __gls_decode_text_glDepthRange(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampd, GLclampd);
    GLclampd zNear;
    GLclampd zFar;
    __glsReader_getGLdouble_text(inoutReader, &zNear);
    __glsReader_getGLdouble_text(inoutReader, &zFar);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[352])(
        zNear,
        zFar
    );
end:
    return;
}

void __gls_decode_text_glFrustum(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;
    __glsReader_getGLdouble_text(inoutReader, &left);
    __glsReader_getGLdouble_text(inoutReader, &right);
    __glsReader_getGLdouble_text(inoutReader, &bottom);
    __glsReader_getGLdouble_text(inoutReader, &top);
    __glsReader_getGLdouble_text(inoutReader, &zNear);
    __glsReader_getGLdouble_text(inoutReader, &zFar);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[353])(
        left,
        right,
        bottom,
        top,
        zNear,
        zFar
    );
end:
    return;
}

void __gls_decode_text_glLoadIdentity(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[354])(
    );
end:
    return;
}

void __gls_decode_text_glLoadMatrixf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat m[16];
    __glsReader_getGLfloatv_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[355])(
        m
    );
end:
    return;
}

void __gls_decode_text_glLoadMatrixd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble m[16];
    __glsReader_getGLdoublev_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[356])(
        m
    );
end:
    return;
}

void __gls_decode_text_glMatrixMode(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[357])(
        mode
    );
end:
    return;
}

void __gls_decode_text_glMultMatrixf(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    GLfloat m[16];
    __glsReader_getGLfloatv_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[358])(
        m
    );
end:
    return;
}

void __gls_decode_text_glMultMatrixd(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    GLdouble m[16];
    __glsReader_getGLdoublev_text(inoutReader, 16, m);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[359])(
        m
    );
end:
    return;
}

void __gls_decode_text_glOrtho(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble left;
    GLdouble right;
    GLdouble bottom;
    GLdouble top;
    GLdouble zNear;
    GLdouble zFar;
    __glsReader_getGLdouble_text(inoutReader, &left);
    __glsReader_getGLdouble_text(inoutReader, &right);
    __glsReader_getGLdouble_text(inoutReader, &bottom);
    __glsReader_getGLdouble_text(inoutReader, &top);
    __glsReader_getGLdouble_text(inoutReader, &zNear);
    __glsReader_getGLdouble_text(inoutReader, &zFar);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[360])(
        left,
        right,
        bottom,
        top,
        zNear,
        zFar
    );
end:
    return;
}

void __gls_decode_text_glPopMatrix(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[361])(
    );
end:
    return;
}

void __gls_decode_text_glPushMatrix(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[362])(
    );
end:
    return;
}

void __gls_decode_text_glRotated(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    GLdouble angle;
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &angle);
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[363])(
        angle,
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glRotatef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &angle);
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[364])(
        angle,
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glScaled(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[365])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glScalef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[366])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glTranslated(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    GLdouble x;
    GLdouble y;
    GLdouble z;
    __glsReader_getGLdouble_text(inoutReader, &x);
    __glsReader_getGLdouble_text(inoutReader, &y);
    __glsReader_getGLdouble_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[367])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glTranslatef(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    GLfloat x;
    GLfloat y;
    GLfloat z;
    __glsReader_getGLfloat_text(inoutReader, &x);
    __glsReader_getGLfloat_text(inoutReader, &y);
    __glsReader_getGLfloat_text(inoutReader, &z);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[368])(
        x,
        y,
        z
    );
end:
    return;
}

void __gls_decode_text_glViewport(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[369])(
        x,
        y,
        width,
        height
    );
end:
    return;
}

#if __GL_EXT_blend_color
void __gls_decode_text_glBlendColorEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
    __glsReader_getGLfloat_text(inoutReader, &red);
    __glsReader_getGLfloat_text(inoutReader, &green);
    __glsReader_getGLfloat_text(inoutReader, &blue);
    __glsReader_getGLfloat_text(inoutReader, &alpha);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[384])(
        red,
        green,
        blue,
        alpha
    );
end:
    return;
}
#endif /* __GL_EXT_blend_color */

#if __GL_EXT_blend_minmax
void __gls_decode_text_glBlendEquationEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[385])(
        mode
    );
end:
    return;
}
#endif /* __GL_EXT_blend_minmax */

#if __GL_EXT_polygon_offset
void __gls_decode_text_glPolygonOffsetEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat factor;
    GLfloat bias;
    __glsReader_getGLfloat_text(inoutReader, &factor);
    __glsReader_getGLfloat_text(inoutReader, &bias);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[386])(
        factor,
        bias
    );
end:
    return;
}
#endif /* __GL_EXT_polygon_offset */

void __gls_decode_text_glPolygonOffset(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    GLfloat factor;
    GLfloat units;
    __glsReader_getGLfloat_text(inoutReader, &factor);
    __glsReader_getGLfloat_text(inoutReader, &units);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[383])(
        factor,
        units
    );
end:
    return;
}

#if __GL_EXT_subtexture
void __gls_decode_text_glTexSubImage1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage1DEXT_pixels_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[387])(
        target,
        level,
        xoffset,
        width,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_text_glTexSubImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage1D_pixels_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[396])(
        target,
        level,
        xoffset,
        width,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

#if __GL_EXT_subtexture
void __gls_decode_text_glTexSubImage2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage2DEXT_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[388])(
        target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_subtexture */

void __gls_decode_text_glTexSubImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage2D_pixels_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[397])(
        target,
        level,
        xoffset,
        yoffset,
        width,
        height,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}

#if __GL_SGIS_multisample
void __gls_decode_text_glSampleMaskSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLclampf, GLboolean);
    GLclampf value;
    GLboolean invert;
    __glsReader_getGLfloat_text(inoutReader, &value);
    __glsReader_getGLboolean_text(inoutReader, &invert);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[389])(
        value,
        invert
    );
end:
    return;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIS_multisample
void __gls_decode_text_glSamplePatternSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum pattern;
    __glsReader_getGLenum_text(inoutReader, &pattern);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[390])(
        pattern
    );
end:
    return;
}
#endif /* __GL_SGIS_multisample */

#if __GL_SGIX_multisample
void __gls_decode_text_glTagSampleBufferSGIX(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(void);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[391])(
    );
end:
    return;
}
#endif /* __GL_SGIX_multisample */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionFilter1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    image_count = __gls_glConvolutionFilter1DEXT_image_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, image, GLvoid, 1 * image_count);
    if (!image) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, image_count, image);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[392])(
        target,
        internalformat,
        width,
        format,
        type,
        image
    );
end:
    __GLS_DEC_FREE(image);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionFilter2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    image_count = __gls_glConvolutionFilter2DEXT_image_size(format, type, width, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, image, GLvoid, 1 * image_count);
    if (!image) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, image_count, image);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[393])(
        target,
        internalformat,
        width,
        height,
        format,
        type,
        image
    );
end:
    __GLS_DEC_FREE(image);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameterfEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    GLenum target;
    GLenum pname;
    GLfloat params;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLfloat_text(inoutReader, &params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[394])(
        target,
        pname,
        params
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glConvolutionParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[395])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameteriEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    GLenum target;
    GLenum pname;
    GLint params;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLint_text(inoutReader, &params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[396])(
        target,
        pname,
        params
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glConvolutionParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glConvolutionParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[397])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glCopyConvolutionFilter1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[398])(
        target,
        internalformat,
        x,
        y,
        width
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glCopyConvolutionFilter2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[399])(
        target,
        internalformat,
        x,
        y,
        width,
        height
    );
end:
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetConvolutionFilterEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLenum format;
    GLenum type;
    GLint image_count;
    GLvoid *image = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(image)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    image_count = __gls_glGetConvolutionFilterEXT_image_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, image, GLvoid, 1 * image_count);
    if (!image) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[400])(
        target,
        format,
        type,
        image
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(image);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetConvolutionParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetConvolutionParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[401])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetConvolutionParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetConvolutionParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[402])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glGetSeparableFilterEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
    GLenum target;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLvoid *row = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(row)
    GLint column_count;
    GLvoid *column = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(column)
    GLint span_count;
    GLvoid *span = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(span)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    row_count = __gls_glGetSeparableFilterEXT_row_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, row, GLvoid, 1 * row_count);
    if (!row) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    column_count = __gls_glGetSeparableFilterEXT_column_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, column, GLvoid, 1 * column_count);
    if (!column) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 1);
    span_count = __gls_glGetSeparableFilterEXT_span_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, span, GLvoid, 1 * span_count);
    if (!span) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 2);
    ctx->outArgs.count = 3;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[403])(
        target,
        format,
        type,
        row,
        column,
        span
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(row);
    __GLS_DEC_FREE(column);
    __GLS_DEC_FREE(span);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_convolution
void __gls_decode_text_glSeparableFilter2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLint row_count;
    GLvoid *row = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(row)
    GLint column_count;
    GLvoid *column = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(column)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    row_count = __gls_glSeparableFilter2DEXT_row_size(target, format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, row, GLvoid, 1 * row_count);
    if (!row) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, row_count, row);
    column_count = __gls_glSeparableFilter2DEXT_column_size(target, format, type, height);
    __GLS_DEC_ALLOC_TEXT(inoutReader, column, GLvoid, 1 * column_count);
    if (!column) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, column_count, column);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[404])(
        target,
        internalformat,
        width,
        height,
        format,
        type,
        row,
        column
    );
end:
    __GLS_DEC_FREE(row);
    __GLS_DEC_FREE(column);
    return;
}
#endif /* __GL_EXT_convolution */

#if __GL_EXT_histogram
void __gls_decode_text_glGetHistogramEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLboolean_text(inoutReader, &reset);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    values_count = __gls_glGetHistogramEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLvoid, 1 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[405])(
        target,
        reset,
        format,
        type,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetHistogramParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetHistogramParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[406])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetHistogramParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetHistogramParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[407])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetMinmaxEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLint values_count;
    GLvoid *values = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(values)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLboolean_text(inoutReader, &reset);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    values_count = __gls_glGetMinmaxEXT_values_size(target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, values, GLvoid, 1 * values_count);
    if (!values) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[408])(
        target,
        reset,
        format,
        type,
        values
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(values);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetMinmaxParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMinmaxParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[409])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glGetMinmaxParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetMinmaxParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[410])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glHistogramEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, GLboolean);
    GLenum target;
    GLsizei width;
    GLenum internalformat;
    GLboolean sink;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLboolean_text(inoutReader, &sink);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[411])(
        target,
        width,
        internalformat,
        sink
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glMinmaxEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLboolean);
    GLenum target;
    GLenum internalformat;
    GLboolean sink;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLboolean_text(inoutReader, &sink);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[412])(
        target,
        internalformat,
        sink
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glResetHistogramEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum target;
    __glsReader_getGLenum_text(inoutReader, &target);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[413])(
        target
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_histogram
void __gls_decode_text_glResetMinmaxEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum target;
    __glsReader_getGLenum_text(inoutReader, &target);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[414])(
        target
    );
end:
    return;
}
#endif /* __GL_EXT_histogram */

#if __GL_EXT_texture3D
void __gls_decode_text_glTexImage3DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage3DEXT_pixels_size(format, type, width, height, depth);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[415])(
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_texture3D */

#if __GL_EXT_subtexture
void __gls_decode_text_glTexSubImage3DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &zoffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage3DEXT_pixels_size(format, type, width, height, depth);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[416])(
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        width,
        height,
        depth,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_EXT_subtexture */

#if __GL_SGIS_detail_texture
void __gls_decode_text_glDetailTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    GLenum target;
    GLsizei n;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * __GLS_MAX(n*2, 0));
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n*2, 0), points);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[417])(
        target,
        n,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_detail_texture
void __gls_decode_text_glGetDetailTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    points_count = __gls_glGetDetailTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[418])(
        target,
        points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_detail_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_text_glSharpenTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    GLenum target;
    GLsizei n;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * __GLS_MAX(n*2, 0));
    if (!points) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n*2, 0), points);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[419])(
        target,
        n,
        points
    );
end:
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_SGIS_sharpen_texture
void __gls_decode_text_glGetSharpenTexFuncSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    GLenum target;
    GLint points_count;
    GLfloat *points = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(points)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    points_count = __gls_glGetSharpenTexFuncSGIS_points_size(target);
    __GLS_DEC_ALLOC_TEXT(inoutReader, points, GLfloat, 4 * points_count);
    if (!points) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[420])(
        target,
        points
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(points);
    return;
}
#endif /* __GL_SGIS_sharpen_texture */

#if __GL_EXT_vertex_array
void __gls_decode_text_glArrayElementEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLint i;
    __glsReader_getGLint_text(inoutReader, &i);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[437])(
        i
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glArrayElement(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint);
    GLuint enabled;
    GLsizei count;
    GLvoid *data;
    data = __glsSetArrayStateText(ctx, inoutReader, &enabled, &count);
    if (data == NULL) goto end;
    ((__GLSdispatch)ctx->dispatchCall[370])(
        0
    );
    __glsDisableArrayState(ctx, enabled);
    free(data);
end:
    return;
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glColorPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glColorPointerEXT_pointer_size(size, type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65494, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[438])(
        size,
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glColorPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because ColorPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glDrawArraysEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    GLenum mode;
    GLint first;
    GLsizei count;
    __glsReader_getGLenum_text(inoutReader, &mode);
    __glsReader_getGLint_text(inoutReader, &first);
    __glsReader_getGLint_text(inoutReader, &count);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[439])(
        mode,
        first,
        count
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glDrawArrays(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    GLenum mode;
    GLuint enabled;
    GLsizei count;
    GLvoid *data;
    __glsReader_getGLenum_text(inoutReader, &mode);
    data = __glsSetArrayStateText(ctx, inoutReader, &enabled, &count);
    if (data == NULL) goto end;
    ((__GLSdispatch)ctx->dispatchCall[374])(
        mode,
        0,
        count
    );
    __glsDisableArrayState(ctx, enabled);
    free(data);
end:
    return;
}

void __gls_decode_text_glDrawElements(__GLScontext *ctx, __GLSreader *inoutReader) {
    // DrewB - Non-functional
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glEdgeFlagPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, const GLboolean *);
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLboolean *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glEdgeFlagPointerEXT_pointer_size(stride, count);
    pointer = (GLboolean *)__glsReader_allocVertexArrayBuf(inoutReader, 65496, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLbooleanv_text(inoutReader, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[440])(
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glEdgeFlagPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because EdgeFlagPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glGetPointervEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    GLenum pname;
    GLvoid* params[1];
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[441])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glGetPointerv(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    GLenum pname;
    GLvoid* params[1];
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &pname);
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[393])(
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    return;
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glIndexPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glIndexPointerEXT_pointer_size(type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65498, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[442])(
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glIndexPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because IndexPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glNormalPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glNormalPointerEXT_pointer_size(type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65499, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glNormalPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because NormalPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glTexCoordPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glTexCoordPointerEXT_pointer_size(size, type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65500, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        size,
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glTexCoordPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because TexCoordPointer isn't captured
}

#if __GL_EXT_vertex_array
void __gls_decode_text_glVertexPointerEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLint pointer_count;
    GLvoid *pointer = GLS_NONE;
    __glsReader_getGLint_text(inoutReader, &size);
    __glsReader_getGLenum_text(inoutReader, &type);
    __glsReader_getGLint_text(inoutReader, &stride);
    __glsReader_getGLint_text(inoutReader, &count);
    pointer_count = __gls_glVertexPointerEXT_pointer_size(size, type, stride, count);
    pointer = (GLvoid *)__glsReader_allocVertexArrayBuf(inoutReader, 65501, pointer_count);
    if (!pointer) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pointer_count, pointer);
    if (stride > 0) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[445])(
        size,
        type,
        stride,
        count,
        pointer
    );
end:
    return;
}
#endif /* __GL_EXT_vertex_array */

void __gls_decode_text_glVertexPointer(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because VertexPointer isn't captured
}

#if __GL_EXT_texture_object
void __gls_decode_text_glAreTexturesResidentEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[430])(
        n,
        textures,
        residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(residences);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glAreTexturesResident(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLboolean *residences = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(residences)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, residences, GLboolean, 1 * __GLS_MAX(n, 0));
    if (!residences) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[386])(
        n,
        textures,
        residences
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(residences);
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glBindTextureEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    GLenum target;
    GLuint texture;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[431])(
        target,
        texture
    );
end:
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glBindTexture(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    GLenum target;
    GLuint texture;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[371])(
        target,
        texture
    );
end:
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glDeleteTexturesEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[432])(
        n,
        textures
    );
end:
    __GLS_DEC_FREE(textures);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glDeleteTextures(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[391])(
        n,
        textures
    );
end:
    __GLS_DEC_FREE(textures);
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glGenTexturesEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[433])(
        n,
        textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glGenTextures(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[392])(
        n,
        textures
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(textures);
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glIsTextureEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint texture;
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[434])(
        texture
    );
end:
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glIsTexture(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLuint);
    GLuint texture;
    __glsReader_getGLuint_text(inoutReader, &texture);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[394])(
        texture
    );
end:
    return;
}

#if __GL_EXT_texture_object
void __gls_decode_text_glPrioritizeTexturesEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLclampf *priorities = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(priorities)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, priorities, GLclampf, 4 * __GLS_MAX(n, 0));
    if (!priorities) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n, 0), priorities);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[435])(
        n,
        textures,
        priorities
    );
end:
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(priorities);
    return;
}
#endif /* __GL_EXT_texture_object */

void __gls_decode_text_glPrioritizeTextures(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    GLsizei n;
    GLuint *textures = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(textures)
    GLclampf *priorities = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(priorities)
    __glsReader_getGLint_text(inoutReader, &n);
    __GLS_DEC_ALLOC_TEXT(inoutReader, textures, GLuint, 4 * __GLS_MAX(n, 0));
    if (!textures) goto end;
    __glsReader_getGLuintv_text(inoutReader, __GLS_MAX(n, 0), textures);
    __GLS_DEC_ALLOC_TEXT(inoutReader, priorities, GLclampf, 4 * __GLS_MAX(n, 0));
    if (!priorities) goto end;
    __glsReader_getGLfloatv_text(inoutReader, __GLS_MAX(n, 0), priorities);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[395])(
        n,
        textures,
        priorities
    );
end:
    __GLS_DEC_FREE(textures);
    __GLS_DEC_FREE(priorities);
    return;
}

#if __GL_EXT_paletted_texture
void __gls_decode_text_glColorTableEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLint table_count;
    GLvoid *table = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(table)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    table_count = __gls_glColorTableEXT_table_size(format, type, width);
    __GLS_DEC_ALLOC_TEXT(inoutReader, table, GLvoid, 1 * table_count);
    if (!table) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, table_count, table);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[452])(
        target,
        internalformat,
        width,
        format,
        type,
        table
    );
end:
    __GLS_DEC_FREE(table);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_color_table
void __gls_decode_text_glColorTableParameterfvSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[437])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_text_glColorTableParameterivSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[438])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_color_table */

#if __GL_SGI_color_table
void __gls_decode_text_glCopyColorTableSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[439])(
        target,
        internalformat,
        x,
        y,
        width
    );
end:
    return;
}
#endif /* __GL_SGI_color_table */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glGetColorTableEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    GLenum target;
    GLenum format;
    GLenum type;
    GLint table_count;
    GLvoid *table = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(table)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    table_count = __gls_glGetColorTableEXT_table_size(ctx, target, format, type);
    __GLS_DEC_ALLOC_TEXT(inoutReader, table, GLvoid, 1 * table_count);
    if (!table) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (ctx->pixelSetupGen) __glsGenPixelSetup_pack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[456])(
        target,
        format,
        type,
        table
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(table);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glGetColorTableParameterfvEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetColorTableParameterfvEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[457])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glGetColorTableParameterivEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetColorTableParameterivEXT_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[458])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_EXT_paletted_texture */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glGetTexColorTableParameterfvSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[443])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glGetTexColorTableParameterivSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    const __GLSoutArgs __outArgsSave = ctx->outArgs;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glGetTexColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLulong_text(inoutReader, ctx->outArgs.vals + 0);
    ctx->outArgs.count = 1;
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[444])(
        target,
        pname,
        params
    );
end:
    ctx->outArgs = __outArgsSave;
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glTexColorTableParameterfvSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLfloat *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexColorTableParameterfvSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLfloat, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLfloatv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[445])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_SGI_texture_color_table
void __gls_decode_text_glTexColorTableParameterivSGI(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    GLenum target;
    GLenum pname;
    GLint params_count;
    GLint *params = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(params)
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLenum_text(inoutReader, &pname);
    params_count = __gls_glTexColorTableParameterivSGI_params_size(pname);
    __GLS_DEC_ALLOC_TEXT(inoutReader, params, GLint, 4 * params_count);
    if (!params) goto end;
    __glsReader_getGLintv_text(inoutReader, params_count, params);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[446])(
        target,
        pname,
        params
    );
end:
    __GLS_DEC_FREE(params);
    return;
}
#endif /* __GL_SGI_texture_color_table */

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexImage1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[447])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[387])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        border
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexImage2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[448])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        height,
        border
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &border);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[388])(
        target,
        level,
        internalformat,
        x,
        y,
        width,
        height,
        border
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexSubImage1DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[449])(
        target,
        level,
        xoffset,
        x,
        y,
        width
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexSubImage1D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[389])(
        target,
        level,
        xoffset,
        x,
        y,
        width
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexSubImage2DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[450])(
        target,
        level,
        xoffset,
        yoffset,
        x,
        y,
        width,
        height
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

void __gls_decode_text_glCopyTexSubImage2D(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[390])(
        target,
        level,
        xoffset,
        yoffset,
        x,
        y,
        width,
        height
    );
end:
    return;
}

#if __GL_EXT_copy_texture
void __gls_decode_text_glCopyTexSubImage3DEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &zoffset);
    __glsReader_getGLint_text(inoutReader, &x);
    __glsReader_getGLint_text(inoutReader, &y);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[451])(
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        x,
        y,
        width,
        height
    );
end:
    return;
}
#endif /* __GL_EXT_copy_texture */

#if __GL_SGIS_texture4D
void __gls_decode_text_glTexImage4DSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLint border;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLenum_text(inoutReader, &internalformat);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLint_text(inoutReader, &size4d);
    __glsReader_getGLint_text(inoutReader, &border);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glTexImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[452])(
        target,
        level,
        internalformat,
        width,
        height,
        depth,
        size4d,
        border,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIS_texture4D
void __gls_decode_text_glTexSubImage4DSGIS(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint woffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLint pixels_count;
    GLvoid *pixels = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(pixels)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLint_text(inoutReader, &level);
    __glsReader_getGLint_text(inoutReader, &xoffset);
    __glsReader_getGLint_text(inoutReader, &yoffset);
    __glsReader_getGLint_text(inoutReader, &zoffset);
    __glsReader_getGLint_text(inoutReader, &woffset);
    __glsReader_getGLint_text(inoutReader, &width);
    __glsReader_getGLint_text(inoutReader, &height);
    __glsReader_getGLint_text(inoutReader, &depth);
    __glsReader_getGLint_text(inoutReader, &size4d);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    pixels_count = __gls_glTexSubImage4DSGIS_pixels_size(format, type, width, height, depth, size4d);
    __GLS_DEC_ALLOC_TEXT(inoutReader, pixels, GLvoid, 1 * pixels_count);
    if (!pixels) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, pixels_count, pixels);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[453])(
        target,
        level,
        xoffset,
        yoffset,
        zoffset,
        woffset,
        width,
        height,
        depth,
        size4d,
        format,
        type,
        pixels
    );
end:
    __GLS_DEC_FREE(pixels);
    return;
}
#endif /* __GL_SGIS_texture4D */

#if __GL_SGIX_pixel_texture
void __gls_decode_text_glPixelTexGenSGIX(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum mode;
    __glsReader_getGLenum_text(inoutReader, &mode);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[454])(
        mode
    );
end:
    return;
}
#endif /* __GL_SGIX_pixel_texture */

#if __GL_EXT_paletted_texture
void __gls_decode_text_glColorSubTableEXT(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum, GLuint, GLsizei, GLenum, GLenum, const GLvoid *);
    GLenum target;
    GLuint start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLint entries_count;
    GLvoid *entries = GLS_NONE;
    __GLS_DEC_ALLOC_DECLARE(entries)
    GLbitfield imageFlags = GLS_NONE;
    __glsReader_getGLSimageFlags_text(inoutReader, &imageFlags);
    if (imageFlags & ~GLS_IMAGE_NULL_BIT) __glsReader_raiseError(inoutReader, GLS_INVALID_VALUE);
    __glsReader_nextList_text(inoutReader);
    __glsReader_getGLenum_text(inoutReader, &target);
    __glsReader_getGLuint_text(inoutReader, &start);
    __glsReader_getGLint_text(inoutReader, &count);
    __glsReader_getGLenum_text(inoutReader, &format);
    __glsReader_getGLenum_text(inoutReader, &type);
    entries_count = imageFlags & GLS_IMAGE_NULL_BIT ? 0 : __gls_glColorSubTableEXT_entries_size(format, type, count);
    __GLS_DEC_ALLOC_TEXT(inoutReader, entries, GLvoid, 1 * entries_count);
    if (!entries) goto end;
    __glsReader_getGLcompv_text(inoutReader, type, entries_count, entries);
    if (ctx->pixelSetupGen) __glsGenPixelSetup_unpack(ctx);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[496])(
        target,
        start,
        count,
        format,
        type,
        imageFlags & GLS_IMAGE_NULL_BIT ? GLS_NONE : entries
    );
end:
    __GLS_DEC_FREE(entries);
    return;
}
#endif // __GL_EXT_paletted_texture

void __gls_decode_text_glDisableClientState(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[373])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glEnableClientState(__GLScontext *ctx, __GLSreader *inoutReader) {
    typedef void (*__GLSdispatch)(GLenum);
    GLenum cap;
    __glsReader_getGLenum_text(inoutReader, &cap);
    if (inoutReader->error) goto end;
    ((__GLSdispatch)ctx->dispatchCall[377])(
        cap
    );
end:
    return;
}

void __gls_decode_text_glInterleavedArrays(__GLScontext *ctx, __GLSreader *inoutReader) {
    // This should never be called because InterleavedArrays isn't captured
}

void __gls_decode_text_glPushClientAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    // Nonfunctional
}

void __gls_decode_text_glPopClientAttrib(__GLScontext *ctx, __GLSreader *inoutReader) {
    // Nonfunctional
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_const.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

const GLubyte *const __glAttribMaskString[__GL_ATTRIB_MASK_COUNT] = {
    glsCSTR("GL_NONE"),
    glsCSTR("GL_CURRENT_BIT"),
    glsCSTR("GL_POINT_BIT"),
    glsCSTR("GL_LINE_BIT"),
    glsCSTR("GL_POLYGON_BIT"),
    glsCSTR("GL_POLYGON_STIPPLE_BIT"),
    glsCSTR("GL_PIXEL_MODE_BIT"),
    glsCSTR("GL_LIGHTING_BIT"),
    glsCSTR("GL_FOG_BIT"),
    glsCSTR("GL_DEPTH_BUFFER_BIT"),
    glsCSTR("GL_ACCUM_BUFFER_BIT"),
    glsCSTR("GL_STENCIL_BUFFER_BIT"),
    glsCSTR("GL_VIEWPORT_BIT"),
    glsCSTR("GL_TRANSFORM_BIT"),
    glsCSTR("GL_ENABLE_BIT"),
    glsCSTR("GL_COLOR_BUFFER_BIT"),
    glsCSTR("GL_HINT_BIT"),
    glsCSTR("GL_EVAL_BIT"),
    glsCSTR("GL_LIST_BIT"),
    glsCSTR("GL_TEXTURE_BIT"),
    glsCSTR("GL_SCISSOR_BIT"),
    glsCSTR("GL_ALL_ATTRIB_BITS"),
    glsCSTR("GL_MULTISAMPLE_BIT_EXT"),
};
const GLbitfield __glAttribMaskVal[__GL_ATTRIB_MASK_COUNT] = {
    0,
    0x00000001,
    0x00000002,
    0x00000004,
    0x00000008,
    0x00000010,
    0x00000020,
    0x00000040,
    0x00000080,
    0x00000100,
    0x00000200,
    0x00000400,
    0x00000800,
    0x00001000,
    0x00002000,
    0x00004000,
    0x00008000,
    0x00010000,
    0x00020000,
    0x00040000,
    0x00080000,
    0x000fffff,
    0x20000000,
};

const GLubyte *const __glsImageFlagsString[__GLS_IMAGE_FLAGS_COUNT] = {
    glsCSTR("GLS_NONE"),
    glsCSTR("GLS_IMAGE_NULL_BIT"),
};
const GLbitfield __glsImageFlagsVal[__GLS_IMAGE_FLAGS_COUNT] = {
    0,
    0x00000001,
};

static const GLubyte *const __glEnumString0[10] = {
    glsCSTR("GL_POINTS"),
    glsCSTR("GL_LINES"),
    glsCSTR("GL_LINE_LOOP"),
    glsCSTR("GL_LINE_STRIP"),
    glsCSTR("GL_TRIANGLES"),
    glsCSTR("GL_TRIANGLE_STRIP"),
    glsCSTR("GL_TRIANGLE_FAN"),
    glsCSTR("GL_QUADS"),
    glsCSTR("GL_QUAD_STRIP"),
    glsCSTR("GL_POLYGON"),
};
static const GLubyte *const __glEnumString1[5] = {
    glsCSTR("GL_ACCUM"),
    glsCSTR("GL_LOAD"),
    glsCSTR("GL_RETURN"),
    glsCSTR("GL_MULT"),
    glsCSTR("GL_ADD"),
};
static const GLubyte *const __glEnumString2[8] = {
    glsCSTR("GL_NEVER"),
    glsCSTR("GL_LESS"),
    glsCSTR("GL_EQUAL"),
    glsCSTR("GL_LEQUAL"),
    glsCSTR("GL_GREATER"),
    glsCSTR("GL_NOTEQUAL"),
    glsCSTR("GL_GEQUAL"),
    glsCSTR("GL_ALWAYS"),
};
static const GLubyte *const __glEnumString3[9] = {
    glsCSTR("GL_SRC_COLOR"),
    glsCSTR("GL_ONE_MINUS_SRC_COLOR"),
    glsCSTR("GL_SRC_ALPHA"),
    glsCSTR("GL_ONE_MINUS_SRC_ALPHA"),
    glsCSTR("GL_DST_ALPHA"),
    glsCSTR("GL_ONE_MINUS_DST_ALPHA"),
    glsCSTR("GL_DST_COLOR"),
    glsCSTR("GL_ONE_MINUS_DST_COLOR"),
    glsCSTR("GL_SRC_ALPHA_SATURATE"),
};
static const GLubyte *const __glEnumString4[13] = {
    glsCSTR("GL_FRONT_LEFT"),
    glsCSTR("GL_FRONT_RIGHT"),
    glsCSTR("GL_BACK_LEFT"),
    glsCSTR("GL_BACK_RIGHT"),
    glsCSTR("GL_FRONT"),
    glsCSTR("GL_BACK"),
    glsCSTR("GL_LEFT"),
    glsCSTR("GL_RIGHT"),
    glsCSTR("GL_FRONT_AND_BACK"),
    glsCSTR("GL_AUX0"),
    glsCSTR("GL_AUX1"),
    glsCSTR("GL_AUX2"),
    glsCSTR("GL_AUX3"),
};
static const GLubyte *const __glEnumString5[6] = {
    glsCSTR("GL_INVALID_ENUM"),
    glsCSTR("GL_INVALID_VALUE"),
    glsCSTR("GL_INVALID_OPERATION"),
    glsCSTR("GL_STACK_OVERFLOW"),
    glsCSTR("GL_STACK_UNDERFLOW"),
    glsCSTR("GL_OUT_OF_MEMORY"),
};
static const GLubyte *const __glEnumString6[5] = {
    glsCSTR("GL_2D"),
    glsCSTR("GL_3D"),
    glsCSTR("GL_3D_COLOR"),
    glsCSTR("GL_3D_COLOR_TEXTURE"),
    glsCSTR("GL_4D_COLOR_TEXTURE"),
};
static const GLubyte *const __glEnumString7[8] = {
    glsCSTR("GL_PASS_THROUGH_TOKEN"),
    glsCSTR("GL_POINT_TOKEN"),
    glsCSTR("GL_LINE_TOKEN"),
    glsCSTR("GL_POLYGON_TOKEN"),
    glsCSTR("GL_BITMAP_TOKEN"),
    glsCSTR("GL_DRAW_PIXEL_TOKEN"),
    glsCSTR("GL_COPY_PIXEL_TOKEN"),
    glsCSTR("GL_LINE_RESET_TOKEN"),
};
static const GLubyte *const __glEnumString8[2] = {
    glsCSTR("GL_EXP"),
    glsCSTR("GL_EXP2"),
};
static const GLubyte *const __glEnumString9[2] = {
    glsCSTR("GL_CW"),
    glsCSTR("GL_CCW"),
};
static const GLubyte *const __glEnumString10[3] = {
    glsCSTR("GL_COEFF"),
    glsCSTR("GL_ORDER"),
    glsCSTR("GL_DOMAIN"),
};
static const GLubyte *const __glEnumString11[242] = {
    glsCSTR("GL_CURRENT_COLOR"),
    glsCSTR("GL_CURRENT_INDEX"),
    glsCSTR("GL_CURRENT_NORMAL"),
    glsCSTR("GL_CURRENT_TEXTURE_COORDS"),
    glsCSTR("GL_CURRENT_RASTER_COLOR"),
    glsCSTR("GL_CURRENT_RASTER_INDEX"),
    glsCSTR("GL_CURRENT_RASTER_TEXTURE_COORDS"),
    glsCSTR("GL_CURRENT_RASTER_POSITION"),
    glsCSTR("GL_CURRENT_RASTER_POSITION_VALID"),
    glsCSTR("GL_CURRENT_RASTER_DISTANCE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_POINT_SMOOTH"),
    glsCSTR("GL_POINT_SIZE"),
    glsCSTR("GL_POINT_SIZE_RANGE"),
    glsCSTR("GL_POINT_SIZE_GRANULARITY"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LINE_SMOOTH"),
    glsCSTR("GL_LINE_WIDTH"),
    glsCSTR("GL_LINE_WIDTH_RANGE"),
    glsCSTR("GL_LINE_WIDTH_GRANULARITY"),
    glsCSTR("GL_LINE_STIPPLE"),
    glsCSTR("GL_LINE_STIPPLE_PATTERN"),
    glsCSTR("GL_LINE_STIPPLE_REPEAT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LIST_MODE"),
    glsCSTR("GL_MAX_LIST_NESTING"),
    glsCSTR("GL_LIST_BASE"),
    glsCSTR("GL_LIST_INDEX"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_POLYGON_MODE"),
    glsCSTR("GL_POLYGON_SMOOTH"),
    glsCSTR("GL_POLYGON_STIPPLE"),
    glsCSTR("GL_EDGE_FLAG"),
    glsCSTR("GL_CULL_FACE"),
    glsCSTR("GL_CULL_FACE_MODE"),
    glsCSTR("GL_FRONT_FACE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LIGHTING"),
    glsCSTR("GL_LIGHT_MODEL_LOCAL_VIEWER"),
    glsCSTR("GL_LIGHT_MODEL_TWO_SIDE"),
    glsCSTR("GL_LIGHT_MODEL_AMBIENT"),
    glsCSTR("GL_SHADE_MODEL"),
    glsCSTR("GL_COLOR_MATERIAL_FACE"),
    glsCSTR("GL_COLOR_MATERIAL_PARAMETER"),
    glsCSTR("GL_COLOR_MATERIAL"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_FOG"),
    glsCSTR("GL_FOG_INDEX"),
    glsCSTR("GL_FOG_DENSITY"),
    glsCSTR("GL_FOG_START"),
    glsCSTR("GL_FOG_END"),
    glsCSTR("GL_FOG_MODE"),
    glsCSTR("GL_FOG_COLOR"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_DEPTH_RANGE"),
    glsCSTR("GL_DEPTH_TEST"),
    glsCSTR("GL_DEPTH_WRITEMASK"),
    glsCSTR("GL_DEPTH_CLEAR_VALUE"),
    glsCSTR("GL_DEPTH_FUNC"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_ACCUM_CLEAR_VALUE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_STENCIL_TEST"),
    glsCSTR("GL_STENCIL_CLEAR_VALUE"),
    glsCSTR("GL_STENCIL_FUNC"),
    glsCSTR("GL_STENCIL_VALUE_MASK"),
    glsCSTR("GL_STENCIL_FAIL"),
    glsCSTR("GL_STENCIL_PASS_DEPTH_FAIL"),
    glsCSTR("GL_STENCIL_PASS_DEPTH_PASS"),
    glsCSTR("GL_STENCIL_REF"),
    glsCSTR("GL_STENCIL_WRITEMASK"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MATRIX_MODE"),
    glsCSTR("GL_NORMALIZE"),
    glsCSTR("GL_VIEWPORT"),
    glsCSTR("GL_MODELVIEW_STACK_DEPTH"),
    glsCSTR("GL_PROJECTION_STACK_DEPTH"),
    glsCSTR("GL_TEXTURE_STACK_DEPTH"),
    glsCSTR("GL_MODELVIEW_MATRIX"),
    glsCSTR("GL_PROJECTION_MATRIX"),
    glsCSTR("GL_TEXTURE_MATRIX"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_ATTRIB_STACK_DEPTH"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_ALPHA_TEST"),
    glsCSTR("GL_ALPHA_TEST_FUNC"),
    glsCSTR("GL_ALPHA_TEST_REF"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_DITHER"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_BLEND_DST"),
    glsCSTR("GL_BLEND_SRC"),
    glsCSTR("GL_BLEND"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_LOGIC_OP_MODE"),
    glsCSTR("GL_INDEX_LOGIC_OP"),
};
static const GLubyte *const __glEnumString12[246] = {
    glsCSTR("GL_AUX_BUFFERS"),
    glsCSTR("GL_DRAW_BUFFER"),
    glsCSTR("GL_READ_BUFFER"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_SCISSOR_BOX"),
    glsCSTR("GL_SCISSOR_TEST"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_INDEX_CLEAR_VALUE"),
    glsCSTR("GL_INDEX_WRITEMASK"),
    glsCSTR("GL_COLOR_CLEAR_VALUE"),
    glsCSTR("GL_COLOR_WRITEMASK"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_INDEX_MODE"),
    glsCSTR("GL_RGBA_MODE"),
    glsCSTR("GL_DOUBLEBUFFER"),
    glsCSTR("GL_STEREO"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_RENDER_MODE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PERSPECTIVE_CORRECTION_HINT"),
    glsCSTR("GL_POINT_SMOOTH_HINT"),
    glsCSTR("GL_LINE_SMOOTH_HINT"),
    glsCSTR("GL_POLYGON_SMOOTH_HINT"),
    glsCSTR("GL_FOG_HINT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_TEXTURE_GEN_S"),
    glsCSTR("GL_TEXTURE_GEN_T"),
    glsCSTR("GL_TEXTURE_GEN_R"),
    glsCSTR("GL_TEXTURE_GEN_Q"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PIXEL_MAP_I_TO_I"),
    glsCSTR("GL_PIXEL_MAP_S_TO_S"),
    glsCSTR("GL_PIXEL_MAP_I_TO_R"),
    glsCSTR("GL_PIXEL_MAP_I_TO_G"),
    glsCSTR("GL_PIXEL_MAP_I_TO_B"),
    glsCSTR("GL_PIXEL_MAP_I_TO_A"),
    glsCSTR("GL_PIXEL_MAP_R_TO_R"),
    glsCSTR("GL_PIXEL_MAP_G_TO_G"),
    glsCSTR("GL_PIXEL_MAP_B_TO_B"),
    glsCSTR("GL_PIXEL_MAP_A_TO_A"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PIXEL_MAP_I_TO_I_SIZE"),
    glsCSTR("GL_PIXEL_MAP_S_TO_S_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_R_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_G_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_B_SIZE"),
    glsCSTR("GL_PIXEL_MAP_I_TO_A_SIZE"),
    glsCSTR("GL_PIXEL_MAP_R_TO_R_SIZE"),
    glsCSTR("GL_PIXEL_MAP_G_TO_G_SIZE"),
    glsCSTR("GL_PIXEL_MAP_B_TO_B_SIZE"),
    glsCSTR("GL_PIXEL_MAP_A_TO_A_SIZE"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_UNPACK_SWAP_BYTES"),
    glsCSTR("GL_UNPACK_LSB_FIRST"),
    glsCSTR("GL_UNPACK_ROW_LENGTH"),
    glsCSTR("GL_UNPACK_SKIP_ROWS"),
    glsCSTR("GL_UNPACK_SKIP_PIXELS"),
    glsCSTR("GL_UNPACK_ALIGNMENT"),
};
static const GLubyte *const __glEnumString13[226] = {
    glsCSTR("GL_PACK_SWAP_BYTES"),
    glsCSTR("GL_PACK_LSB_FIRST"),
    glsCSTR("GL_PACK_ROW_LENGTH"),
    glsCSTR("GL_PACK_SKIP_ROWS"),
    glsCSTR("GL_PACK_SKIP_PIXELS"),
    glsCSTR("GL_PACK_ALIGNMENT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP_COLOR"),
    glsCSTR("GL_MAP_STENCIL"),
    glsCSTR("GL_INDEX_SHIFT"),
    glsCSTR("GL_INDEX_OFFSET"),
    glsCSTR("GL_RED_SCALE"),
    glsCSTR("GL_RED_BIAS"),
    glsCSTR("GL_ZOOM_X"),
    glsCSTR("GL_ZOOM_Y"),
    glsCSTR("GL_GREEN_SCALE"),
    glsCSTR("GL_GREEN_BIAS"),
    glsCSTR("GL_BLUE_SCALE"),
    glsCSTR("GL_BLUE_BIAS"),
    glsCSTR("GL_ALPHA_SCALE"),
    glsCSTR("GL_ALPHA_BIAS"),
    glsCSTR("GL_DEPTH_SCALE"),
    glsCSTR("GL_DEPTH_BIAS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAX_EVAL_ORDER"),
    glsCSTR("GL_MAX_LIGHTS"),
    glsCSTR("GL_MAX_CLIP_PLANES"),
    glsCSTR("GL_MAX_TEXTURE_SIZE"),
    glsCSTR("GL_MAX_PIXEL_MAP_TABLE"),
    glsCSTR("GL_MAX_ATTRIB_STACK_DEPTH"),
    glsCSTR("GL_MAX_MODELVIEW_STACK_DEPTH"),
    glsCSTR("GL_MAX_NAME_STACK_DEPTH"),
    glsCSTR("GL_MAX_PROJECTION_STACK_DEPTH"),
    glsCSTR("GL_MAX_TEXTURE_STACK_DEPTH"),
    glsCSTR("GL_MAX_VIEWPORT_DIMS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_SUBPIXEL_BITS"),
    glsCSTR("GL_INDEX_BITS"),
    glsCSTR("GL_RED_BITS"),
    glsCSTR("GL_GREEN_BITS"),
    glsCSTR("GL_BLUE_BITS"),
    glsCSTR("GL_ALPHA_BITS"),
    glsCSTR("GL_DEPTH_BITS"),
    glsCSTR("GL_STENCIL_BITS"),
    glsCSTR("GL_ACCUM_RED_BITS"),
    glsCSTR("GL_ACCUM_GREEN_BITS"),
    glsCSTR("GL_ACCUM_BLUE_BITS"),
    glsCSTR("GL_ACCUM_ALPHA_BITS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_NAME_STACK_DEPTH"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_AUTO_NORMAL"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP1_COLOR_4"),
    glsCSTR("GL_MAP1_INDEX"),
    glsCSTR("GL_MAP1_NORMAL"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_1"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_2"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_3"),
    glsCSTR("GL_MAP1_TEXTURE_COORD_4"),
    glsCSTR("GL_MAP1_VERTEX_3"),
    glsCSTR("GL_MAP1_VERTEX_4"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP2_COLOR_4"),
    glsCSTR("GL_MAP2_INDEX"),
    glsCSTR("GL_MAP2_NORMAL"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_1"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_2"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_3"),
    glsCSTR("GL_MAP2_TEXTURE_COORD_4"),
    glsCSTR("GL_MAP2_VERTEX_3"),
    glsCSTR("GL_MAP2_VERTEX_4"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_MAP1_GRID_DOMAIN"),
    glsCSTR("GL_MAP1_GRID_SEGMENTS"),
    glsCSTR("GL_MAP2_GRID_DOMAIN"),
    glsCSTR("GL_MAP2_GRID_SEGMENTS"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_TEXTURE_1D"),
    glsCSTR("GL_TEXTURE_2D"),
};
static const GLubyte *const __glEnumString16[6] = {
    glsCSTR("GL_TEXTURE_WIDTH"),
    glsCSTR("GL_TEXTURE_HEIGHT"),
    GLS_NONE,
    glsCSTR("GL_TEXTURE_COMPONENTS"),
    glsCSTR("GL_TEXTURE_BORDER_COLOR"),
    glsCSTR("GL_TEXTURE_BORDER"),
};
static const GLubyte *const __glEnumString17[3] = {
    glsCSTR("GL_DONT_CARE"),
    glsCSTR("GL_FASTEST"),
    glsCSTR("GL_NICEST"),
};
static const GLubyte *const __glEnumString18[10] = {
    glsCSTR("GL_AMBIENT"),
    glsCSTR("GL_DIFFUSE"),
    glsCSTR("GL_SPECULAR"),
    glsCSTR("GL_POSITION"),
    glsCSTR("GL_SPOT_DIRECTION"),
    glsCSTR("GL_SPOT_EXPONENT"),
    glsCSTR("GL_SPOT_CUTOFF"),
    glsCSTR("GL_CONSTANT_ATTENUATION"),
    glsCSTR("GL_LINEAR_ATTENUATION"),
    glsCSTR("GL_QUADRATIC_ATTENUATION"),
};
static const GLubyte *const __glEnumString19[2] = {
    glsCSTR("GL_COMPILE"),
    glsCSTR("GL_COMPILE_AND_EXECUTE"),
};
static const GLubyte *const __glEnumString20[11] = {
    glsCSTR("GL_BYTE"),
    glsCSTR("GL_UNSIGNED_BYTE"),
    glsCSTR("GL_SHORT"),
    glsCSTR("GL_UNSIGNED_SHORT"),
    glsCSTR("GL_INT"),
    glsCSTR("GL_UNSIGNED_INT"),
    glsCSTR("GL_FLOAT"),
    glsCSTR("GL_2_BYTES"),
    glsCSTR("GL_3_BYTES"),
    glsCSTR("GL_4_BYTES"),
    glsCSTR("GL_DOUBLE_EXT"),
};
static const GLubyte *const __glEnumString21[16] = {
    glsCSTR("GL_CLEAR"),
    glsCSTR("GL_AND"),
    glsCSTR("GL_AND_REVERSE"),
    glsCSTR("GL_COPY"),
    glsCSTR("GL_AND_INVERTED"),
    glsCSTR("GL_NOOP"),
    glsCSTR("GL_XOR"),
    glsCSTR("GL_OR"),
    glsCSTR("GL_NOR"),
    glsCSTR("GL_EQUIV"),
    glsCSTR("GL_INVERT"),
    glsCSTR("GL_OR_REVERSE"),
    glsCSTR("GL_COPY_INVERTED"),
    glsCSTR("GL_OR_INVERTED"),
    glsCSTR("GL_NAND"),
    glsCSTR("GL_SET"),
};
static const GLubyte *const __glEnumString22[4] = {
    glsCSTR("GL_EMISSION"),
    glsCSTR("GL_SHININESS"),
    glsCSTR("GL_AMBIENT_AND_DIFFUSE"),
    glsCSTR("GL_COLOR_INDEXES"),
};
static const GLubyte *const __glEnumString23[3] = {
    glsCSTR("GL_MODELVIEW"),
    glsCSTR("GL_PROJECTION"),
    glsCSTR("GL_TEXTURE"),
};
static const GLubyte *const __glEnumString24[3] = {
    glsCSTR("GL_COLOR"),
    glsCSTR("GL_DEPTH"),
    glsCSTR("GL_STENCIL"),
};
static const GLubyte *const __glEnumString25[11] = {
    glsCSTR("GL_COLOR_INDEX"),
    glsCSTR("GL_STENCIL_INDEX"),
    glsCSTR("GL_DEPTH_COMPONENT"),
    glsCSTR("GL_RED"),
    glsCSTR("GL_GREEN"),
    glsCSTR("GL_BLUE"),
    glsCSTR("GL_ALPHA"),
    glsCSTR("GL_RGB"),
    glsCSTR("GL_RGBA"),
    glsCSTR("GL_LUMINANCE"),
    glsCSTR("GL_LUMINANCE_ALPHA"),
};
static const GLubyte *const __glEnumString26[1] = {
    glsCSTR("GL_BITMAP"),
};
static const GLubyte *const __glEnumString27[3] = {
    glsCSTR("GL_POINT"),
    glsCSTR("GL_LINE"),
    glsCSTR("GL_FILL"),
};
static const GLubyte *const __glEnumString28[3] = {
    glsCSTR("GL_RENDER"),
    glsCSTR("GL_FEEDBACK"),
    glsCSTR("GL_SELECT"),
};
static const GLubyte *const __glEnumString29[2] = {
    glsCSTR("GL_FLAT"),
    glsCSTR("GL_SMOOTH"),
};
static const GLubyte *const __glEnumString30[4] = {
    glsCSTR("GL_KEEP"),
    glsCSTR("GL_REPLACE"),
    glsCSTR("GL_INCR"),
    glsCSTR("GL_DECR"),
};
static const GLubyte *const __glEnumString31[4] = {
    glsCSTR("GL_VENDOR"),
    glsCSTR("GL_RENDERER"),
    glsCSTR("GL_VERSION"),
    glsCSTR("GL_EXTENSIONS"),
};
static const GLubyte *const __glEnumString32[4] = {
    glsCSTR("GL_S"),
    glsCSTR("GL_T"),
    glsCSTR("GL_R"),
    glsCSTR("GL_Q"),
};
static const GLubyte *const __glEnumString33[2] = {
    glsCSTR("GL_MODULATE"),
    glsCSTR("GL_DECAL"),
};
static const GLubyte *const __glEnumString34[2] = {
    glsCSTR("GL_TEXTURE_ENV_MODE"),
    glsCSTR("GL_TEXTURE_ENV_COLOR"),
};
static const GLubyte *const __glEnumString35[1] = {
    glsCSTR("GL_TEXTURE_ENV"),
};
static const GLubyte *const __glEnumString36[3] = {
    glsCSTR("GL_EYE_LINEAR"),
    glsCSTR("GL_OBJECT_LINEAR"),
    glsCSTR("GL_SPHERE_MAP"),
};
static const GLubyte *const __glEnumString37[3] = {
    glsCSTR("GL_TEXTURE_GEN_MODE"),
    glsCSTR("GL_OBJECT_PLANE"),
    glsCSTR("GL_EYE_PLANE"),
};
static const GLubyte *const __glEnumString38[2] = {
    glsCSTR("GL_NEAREST"),
    glsCSTR("GL_LINEAR"),
};
static const GLubyte *const __glEnumString39[4] = {
    glsCSTR("GL_NEAREST_MIPMAP_NEAREST"),
    glsCSTR("GL_LINEAR_MIPMAP_NEAREST"),
    glsCSTR("GL_NEAREST_MIPMAP_LINEAR"),
    glsCSTR("GL_LINEAR_MIPMAP_LINEAR"),
};
static const GLubyte *const __glEnumString40[4] = {
    glsCSTR("GL_TEXTURE_MAG_FILTER"),
    glsCSTR("GL_TEXTURE_MIN_FILTER"),
    glsCSTR("GL_TEXTURE_WRAP_S"),
    glsCSTR("GL_TEXTURE_WRAP_T"),
};
static const GLubyte *const __glEnumString41[2] = {
    glsCSTR("GL_CLAMP"),
    glsCSTR("GL_REPEAT"),
};
static const GLubyte *const __glEnumString42[46] = {
    glsCSTR("GL_POLYGON_OFFSET_UNITS"),
    glsCSTR("GL_POLYGON_OFFSET_POINT"),
    glsCSTR("GL_POLYGON_OFFSET_LINE"),
    glsCSTR("GL_POLYGON_OFFSET_FILL"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_COLOR_LOGIC_OP"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_V2F"),
    glsCSTR("GL_V3F"),
    glsCSTR("GL_C4UB_V2F"),
    glsCSTR("GL_C4UB_V3F"),
    glsCSTR("GL_C3F_V3F"),
    glsCSTR("GL_N3F_V3F"),
    glsCSTR("GL_C4F_N3F_V3F"),
    glsCSTR("GL_T2F_V3F"),
    glsCSTR("GL_T4F_V4F"),
    glsCSTR("GL_T2F_C4UB_V3F"),
    glsCSTR("GL_T2F_C3F_V3F"),
    glsCSTR("GL_T2F_N3F_V3F"),
    glsCSTR("GL_T2F_C4F_N3F_V3F"),
    glsCSTR("GL_T4F_C4F_N3F_V4F"),
};
static const GLubyte *const __glEnumString48[6] = {
    glsCSTR("GL_CLIP_PLANE0"),
    glsCSTR("GL_CLIP_PLANE1"),
    glsCSTR("GL_CLIP_PLANE2"),
    glsCSTR("GL_CLIP_PLANE3"),
    glsCSTR("GL_CLIP_PLANE4"),
    glsCSTR("GL_CLIP_PLANE5"),
};
static const GLubyte *const __glEnumString64[8] = {
    glsCSTR("GL_LIGHT0"),
    glsCSTR("GL_LIGHT1"),
    glsCSTR("GL_LIGHT2"),
    glsCSTR("GL_LIGHT3"),
    glsCSTR("GL_LIGHT4"),
    glsCSTR("GL_LIGHT5"),
    glsCSTR("GL_LIGHT6"),
    glsCSTR("GL_LIGHT7"),
};
static const GLubyte *const __glEnumString128[241] = {
    glsCSTR("GL_ABGR_EXT"),
    glsCSTR("GL_CONSTANT_COLOR_EXT"),
    glsCSTR("GL_ONE_MINUS_CONSTANT_COLOR_EXT"),
    glsCSTR("GL_CONSTANT_ALPHA_EXT"),
    glsCSTR("GL_ONE_MINUS_CONSTANT_ALPHA_EXT"),
    glsCSTR("GL_BLEND_COLOR_EXT"),
    glsCSTR("GL_FUNC_ADD_EXT"),
    glsCSTR("GL_MIN_EXT"),
    glsCSTR("GL_MAX_EXT"),
    glsCSTR("GL_BLEND_EQUATION_EXT"),
    glsCSTR("GL_FUNC_SUBTRACT_EXT"),
    glsCSTR("GL_FUNC_REVERSE_SUBTRACT_EXT"),
    glsCSTR("GL_CMYK_EXT"),
    glsCSTR("GL_CMYKA_EXT"),
    glsCSTR("GL_PACK_CMYK_HINT_EXT"),
    glsCSTR("GL_UNPACK_CMYK_HINT_EXT"),
    glsCSTR("GL_CONVOLUTION_1D_EXT"),
    glsCSTR("GL_CONVOLUTION_2D_EXT"),
    glsCSTR("GL_SEPARABLE_2D_EXT"),
    glsCSTR("GL_CONVOLUTION_BORDER_MODE_EXT"),
    glsCSTR("GL_CONVOLUTION_FILTER_SCALE_EXT"),
    glsCSTR("GL_CONVOLUTION_FILTER_BIAS_EXT"),
    glsCSTR("GL_REDUCE_EXT"),
    glsCSTR("GL_CONVOLUTION_FORMAT_EXT"),
    glsCSTR("GL_CONVOLUTION_WIDTH_EXT"),
    glsCSTR("GL_CONVOLUTION_HEIGHT_EXT"),
    glsCSTR("GL_MAX_CONVOLUTION_WIDTH_EXT"),
    glsCSTR("GL_MAX_CONVOLUTION_HEIGHT_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_RED_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_GREEN_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_BLUE_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_ALPHA_SCALE_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_RED_BIAS_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_GREEN_BIAS_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_BLUE_BIAS_EXT"),
    glsCSTR("GL_POST_CONVOLUTION_ALPHA_BIAS_EXT"),
    glsCSTR("GL_HISTOGRAM_EXT"),
    glsCSTR("GL_PROXY_HISTOGRAM_EXT"),
    glsCSTR("GL_HISTOGRAM_WIDTH_EXT"),
    glsCSTR("GL_HISTOGRAM_FORMAT_EXT"),
    glsCSTR("GL_HISTOGRAM_RED_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_GREEN_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_BLUE_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_ALPHA_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_LUMINANCE_SIZE_EXT"),
    glsCSTR("GL_HISTOGRAM_SINK_EXT"),
    glsCSTR("GL_MINMAX_EXT"),
    glsCSTR("GL_MINMAX_FORMAT_EXT"),
    glsCSTR("GL_MINMAX_SINK_EXT"),
    glsCSTR("GL_TABLE_TOO_LARGE_EXT"),
    glsCSTR("GL_UNSIGNED_BYTE_3_3_2_EXT"),
    glsCSTR("GL_UNSIGNED_SHORT_4_4_4_4_EXT"),
    glsCSTR("GL_UNSIGNED_SHORT_5_5_5_1_EXT"),
    glsCSTR("GL_UNSIGNED_INT_8_8_8_8_EXT"),
    glsCSTR("GL_UNSIGNED_INT_10_10_10_2_EXT"),
    glsCSTR("GL_POLYGON_OFFSET"),
    glsCSTR("GL_POLYGON_OFFSET_FACTOR"),
    glsCSTR("GL_POLYGON_OFFSET_BIAS_EXT"),
    glsCSTR("GL_RESCALE_NORMAL_EXT"),
    glsCSTR("GL_ALPHA4"),
    glsCSTR("GL_ALPHA8"),
    glsCSTR("GL_ALPHA12"),
    glsCSTR("GL_ALPHA16"),
    glsCSTR("GL_LUMINANCE4"),
    glsCSTR("GL_LUMINANCE8"),
    glsCSTR("GL_LUMINANCE12"),
    glsCSTR("GL_LUMINANCE16"),
    glsCSTR("GL_LUMINANCE4_ALPHA4"),
    glsCSTR("GL_LUMINANCE6_ALPHA2"),
    glsCSTR("GL_LUMINANCE8_ALPHA8"),
    glsCSTR("GL_LUMINANCE12_ALPHA4"),
    glsCSTR("GL_LUMINANCE12_ALPHA12"),
    glsCSTR("GL_LUMINANCE16_ALPHA16"),
    glsCSTR("GL_INTENSITY"),
    glsCSTR("GL_INTENSITY4"),
    glsCSTR("GL_INTENSITY8"),
    glsCSTR("GL_INTENSITY12"),
    glsCSTR("GL_INTENSITY16"),
    glsCSTR("GL_R3_G3_B2"),
    glsCSTR("GL_RGB4"),
    glsCSTR("GL_RGB5"),
    glsCSTR("GL_RGB8"),
    glsCSTR("GL_RGB10"),
    glsCSTR("GL_RGB12"),
    glsCSTR("GL_RGB16"),
    glsCSTR("GL_RGBA2"),
    glsCSTR("GL_RGBA4"),
    glsCSTR("GL_RGB5_A1"),
    glsCSTR("GL_RGBA8"),
    glsCSTR("GL_RGB10_A2"),
    glsCSTR("GL_RGBA12"),
    glsCSTR("GL_RGBA16"),
    glsCSTR("GL_TEXTURE_RED_SIZE"),
    glsCSTR("GL_TEXTURE_GREEN_SIZE"),
    glsCSTR("GL_TEXTURE_BLUE_SIZE"),
    glsCSTR("GL_TEXTURE_ALPHA_SIZE"),
    glsCSTR("GL_TEXTURE_LUMINANCE_SIZE"),
    glsCSTR("GL_TEXTURE_INTENSITY_SIZE"),
    glsCSTR("GL_REPLACE"),
    glsCSTR("GL_PROXY_TEXTURE_1D"),
    glsCSTR("GL_PROXY_TEXTURE_2D"),
    glsCSTR("GL_TEXTURE_TOO_LARGE"),
    glsCSTR("GL_TEXTURE_PRIORITY"),
    glsCSTR("GL_TEXTURE_RESIDENT"),
    glsCSTR("GL_TEXTURE_1D_BINDING"),
    glsCSTR("GL_TEXTURE_2D_BINDING"),
    glsCSTR("GL_TEXTURE_3D_BINDING_EXT"),
    glsCSTR("GL_PACK_SKIP_IMAGES_EXT"),
    glsCSTR("GL_PACK_IMAGE_HEIGHT_EXT"),
    glsCSTR("GL_UNPACK_SKIP_IMAGES_EXT"),
    glsCSTR("GL_UNPACK_IMAGE_HEIGHT_EXT"),
    glsCSTR("GL_TEXTURE_3D_EXT"),
    glsCSTR("GL_PROXY_TEXTURE_3D_EXT"),
    glsCSTR("GL_TEXTURE_DEPTH_EXT"),
    glsCSTR("GL_TEXTURE_WRAP_R_EXT"),
    glsCSTR("GL_MAX_3D_TEXTURE_SIZE_EXT"),
    glsCSTR("GL_VERTEX_ARRAY"),
    glsCSTR("GL_NORMAL_ARRAY"),
    glsCSTR("GL_COLOR_ARRAY"),
    glsCSTR("GL_INDEX_ARRAY"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY"),
    glsCSTR("GL_EDGE_FLAG_ARRAY"),
    glsCSTR("GL_VERTEX_ARRAY_SIZE"),
    glsCSTR("GL_VERTEX_ARRAY_TYPE"),
    glsCSTR("GL_VERTEX_ARRAY_STRIDE"),
    glsCSTR("GL_VERTEX_ARRAY_COUNT_EXT"),
    glsCSTR("GL_NORMAL_ARRAY_TYPE"),
    glsCSTR("GL_NORMAL_ARRAY_STRIDE"),
    glsCSTR("GL_NORMAL_ARRAY_COUNT_EXT"),
    glsCSTR("GL_COLOR_ARRAY_SIZE"),
    glsCSTR("GL_COLOR_ARRAY_TYPE"),
    glsCSTR("GL_COLOR_ARRAY_STRIDE"),
    glsCSTR("GL_COLOR_ARRAY_COUNT_EXT"),
    glsCSTR("GL_INDEX_ARRAY_TYPE"),
    glsCSTR("GL_INDEX_ARRAY_STRIDE"),
    glsCSTR("GL_INDEX_ARRAY_COUNT_EXT"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_SIZE"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_TYPE"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_STRIDE"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_COUNT_EXT"),
    glsCSTR("GL_EDGE_FLAG_ARRAY_STRIDE"),
    glsCSTR("GL_EDGE_FLAG_ARRAY_COUNT_EXT"),
    glsCSTR("GL_VERTEX_ARRAY_POINTER"),
    glsCSTR("GL_NORMAL_ARRAY_POINTER"),
    glsCSTR("GL_COLOR_ARRAY_POINTER"),
    glsCSTR("GL_INDEX_ARRAY_POINTER"),
    glsCSTR("GL_TEXTURE_COORD_ARRAY_POINTER"),
    glsCSTR("GL_EDGE_FLAG_ARRAY_POINTER"),
    glsCSTR("GL_INTERLACE_SGIX"),
    glsCSTR("GL_DETAIL_TEXTURE_2D_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_2D_BINDING_SGIS"),
    glsCSTR("GL_LINEAR_DETAIL_SGIS"),
    glsCSTR("GL_LINEAR_DETAIL_ALPHA_SGIS"),
    glsCSTR("GL_LINEAR_DETAIL_COLOR_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_LEVEL_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_MODE_SGIS"),
    glsCSTR("GL_DETAIL_TEXTURE_FUNC_POINTS_SGIS"),
    glsCSTR("GL_MULTISAMPLE_SGIS"),
    glsCSTR("GL_SAMPLE_ALPHA_TO_MASK_SGIS"),
    glsCSTR("GL_SAMPLE_ALPHA_TO_ONE_SGIS"),
    glsCSTR("GL_SAMPLE_MASK_SGIS"),
    glsCSTR("GL_1PASS_SGIS"),
    glsCSTR("GL_2PASS_0_SGIS"),
    glsCSTR("GL_2PASS_1_SGIS"),
    glsCSTR("GL_4PASS_0_SGIS"),
    glsCSTR("GL_4PASS_1_SGIS"),
    glsCSTR("GL_4PASS_2_SGIS"),
    glsCSTR("GL_4PASS_3_SGIS"),
    glsCSTR("GL_SAMPLE_BUFFERS_SGIS"),
    glsCSTR("GL_SAMPLES_SGIS"),
    glsCSTR("GL_SAMPLE_MASK_VALUE_SGIS"),
    glsCSTR("GL_SAMPLE_MASK_INVERT_SGIS"),
    glsCSTR("GL_SAMPLE_PATTERN_SGIS"),
    glsCSTR("GL_LINEAR_SHARPEN_SGIS"),
    glsCSTR("GL_LINEAR_SHARPEN_ALPHA_SGIS"),
    glsCSTR("GL_LINEAR_SHARPEN_COLOR_SGIS"),
    glsCSTR("GL_SHARPEN_TEXTURE_FUNC_POINTS_SGIS"),
    glsCSTR("GL_COLOR_MATRIX_SGI"),
    glsCSTR("GL_COLOR_MATRIX_STACK_DEPTH_SGI"),
    glsCSTR("GL_MAX_COLOR_MATRIX_STACK_DEPTH_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_RED_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_GREEN_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_BLUE_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_ALPHA_SCALE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_RED_BIAS_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_GREEN_BIAS_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_BLUE_BIAS_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_ALPHA_BIAS_SGI"),
    glsCSTR("GL_TEXTURE_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_TEXTURE_COLOR_TABLE_SGI"),
    glsCSTR("GL_TEXTURE_COLOR_TABLE_BIAS_SGI"),
    glsCSTR("GL_TEXTURE_COLOR_TABLE_SCALE_SGI"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_COLOR_TABLE_SGI"),
    glsCSTR("GL_POST_CONVOLUTION_COLOR_TABLE_SGI"),
    glsCSTR("GL_POST_COLOR_MATRIX_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_POST_CONVOLUTION_COLOR_TABLE_SGI"),
    glsCSTR("GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE_SGI"),
    glsCSTR("GL_COLOR_TABLE_SCALE_SGI"),
    glsCSTR("GL_COLOR_TABLE_BIAS_SGI"),
    glsCSTR("GL_COLOR_TABLE_FORMAT_EXT"),
    glsCSTR("GL_COLOR_TABLE_WIDTH_EXT"),
    glsCSTR("GL_COLOR_TABLE_RED_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_GREEN_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_BLUE_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_ALPHA_SIZE_EXT"),
    glsCSTR("GL_COLOR_TABLE_LUMINANCE_SIZE_SGI"),
    glsCSTR("GL_COLOR_TABLE_INTENSITY_SIZE_SGI"),
    glsCSTR("GL_BGR_EXT"),
    glsCSTR("GL_BGRA_EXT"),
    glsCSTR("GL_COLOR_INDEX1_EXT"),
    glsCSTR("GL_COLOR_INDEX2_EXT"),
    glsCSTR("GL_COLOR_INDEX4_EXT"),
    glsCSTR("GL_COLOR_INDEX8_EXT"),
    glsCSTR("GL_COLOR_INDEX12_EXT"),
    glsCSTR("GL_COLOR_INDEX16_EXT"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_CLIP_EXT"),
};
static const GLubyte *const __glEnumString129[70] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_SS_SGIS"),
    glsCSTR("GL_SS4_SGIS"),
    glsCSTR("GL_SS8_SGIS"),
    glsCSTR("GL_SS12_SGIS"),
    glsCSTR("GL_SS16_SGIS"),
    glsCSTR("GL_SSSS_SGIS"),
    glsCSTR("GL_SSSS2_SGIS"),
    glsCSTR("GL_SSSS4_SGIS"),
    glsCSTR("GL_SSSS8_SGIS"),
    glsCSTR("GL_SSSS12_SGIS"),
    glsCSTR("GL_SSSS16_SGIS"),
    glsCSTR("GL_TEXTURE_SS_SELECT_SGIS"),
    glsCSTR("GL_TEXTURE_SSSS_SELECT_SGIS"),
    glsCSTR("GL_ALPHA_SELECT0_SGIS"),
    glsCSTR("GL_ALPHA_SELECT1_SGIS"),
    glsCSTR("GL_ALPHA_SELECT2_SGIS"),
    glsCSTR("GL_ALPHA_SELECT3_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT0_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT1_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT2_SGIS"),
    glsCSTR("GL_LUMINANCE_SELECT3_SGIS"),
    glsCSTR("GL_LUMINANCE_ALPHA_SELECT0_SGIS"),
    glsCSTR("GL_LUMINANCE_ALPHA_SELECT2_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT0_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT1_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT2_SGIS"),
    glsCSTR("GL_INTENSITY_SELECT3_SGIS"),
    glsCSTR("GL_RGBA_SELECT0_SGIS"),
    glsCSTR("GL_TEXTURE_COMPONENT_S_SIZE_SGIS"),
    glsCSTR("GL_CLAMP_TO_BORDER_SGIS"),
    glsCSTR("GL_TEXTURE_MULTI_BUFFER_HINT_SGIX"),
    GLS_NONE,
    glsCSTR("GL_PACK_SKIP_VOLUMES_SGIS"),
    glsCSTR("GL_PACK_IMAGE_DEPTH_SGIS"),
    glsCSTR("GL_UNPACK_SKIP_VOLUMES_SGIS"),
    glsCSTR("GL_UNPACK_IMAGE_DEPTH_SGIS"),
    glsCSTR("GL_TEXTURE_4D_SGIS"),
    glsCSTR("GL_PROXY_TEXTURE_4D_SGIS"),
    glsCSTR("GL_TEXTURE_4DSIZE_SGIS"),
    glsCSTR("GL_TEXTURE_WRAP_Q_SGIS"),
    glsCSTR("GL_MAX_4D_TEXTURE_SIZE_SGIS"),
    glsCSTR("GL_PIXEL_TEX_GEN_MODE_SGIX"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("GL_PIXEL_TILE_BEST_ALIGNMENT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_CACHE_INCREMENT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_WIDTH_SGIX"),
    glsCSTR("GL_PIXEL_TILE_HEIGHT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_GRID_WIDTH_SGIX"),
    glsCSTR("GL_PIXEL_TILE_GRID_HEIGHT_SGIX"),
    glsCSTR("GL_PIXEL_TILE_GRID_DEPTH_SGIX"),
    glsCSTR("GL_PIXEL_TILE_CACHE_SIZE_SGIX"),
};

const GLint __glEnumStringCount[130] = {
    10,
    5,
    8,
    9,
    13,
    6,
    5,
    8,
    2,
    2,
    3,
    242,
    246,
    226,
    0,
    0,
    6,
    3,
    10,
    2,
    11,
    16,
    4,
    3,
    3,
    11,
    1,
    3,
    3,
    2,
    4,
    4,
    4,
    2,
    2,
    1,
    3,
    3,
    2,
    4,
    4,
    2,
    46,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    241,
    70,
};

const GLubyte *const *const __glEnumString[130] = {
    __glEnumString0,
    __glEnumString1,
    __glEnumString2,
    __glEnumString3,
    __glEnumString4,
    __glEnumString5,
    __glEnumString6,
    __glEnumString7,
    __glEnumString8,
    __glEnumString9,
    __glEnumString10,
    __glEnumString11,
    __glEnumString12,
    __glEnumString13,
    GLS_NONE,
    GLS_NONE,
    __glEnumString16,
    __glEnumString17,
    __glEnumString18,
    __glEnumString19,
    __glEnumString20,
    __glEnumString21,
    __glEnumString22,
    __glEnumString23,
    __glEnumString24,
    __glEnumString25,
    __glEnumString26,
    __glEnumString27,
    __glEnumString28,
    __glEnumString29,
    __glEnumString30,
    __glEnumString31,
    __glEnumString32,
    __glEnumString33,
    __glEnumString34,
    __glEnumString35,
    __glEnumString36,
    __glEnumString37,
    __glEnumString38,
    __glEnumString39,
    __glEnumString40,
    __glEnumString41,
    __glEnumString42,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glEnumString48,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glEnumString64,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glEnumString128,
    __glEnumString129,
};

static const GLubyte *const __glsEnumString0[1] = {
    glsCSTR("GLS_NONE"),
};
static const GLubyte *const __glsEnumString1[2] = {
    glsCSTR("GLS_ALL"),
    glsCSTR("GLS_LAST"),
};
static const GLubyte *const __glsEnumString2[2] = {
    glsCSTR("GLS_API_GLS"),
    glsCSTR("GLS_API_GL"),
};
static const GLubyte *const __glsEnumString3[4] = {
    glsCSTR("GLS_FRAME"),
    glsCSTR("GLS_HEADER"),
    glsCSTR("GLS_INIT"),
    glsCSTR("GLS_STATIC"),
};
static const GLubyte *const __glsEnumString4[2] = {
    glsCSTR("GLS_CAPTURE_ENTRY_FUNC"),
    glsCSTR("GLS_CAPTURE_EXIT_FUNC"),
};
static const GLubyte *const __glsEnumString5[4] = {
    glsCSTR("GLS_CONTEXT"),
    glsCSTR("GLS_BINARY_LSB_FIRST"),
    glsCSTR("GLS_BINARY_MSB_FIRST"),
    glsCSTR("GLS_TEXT"),
};
static const GLubyte *const __glsEnumString6[2] = {
    glsCSTR("GLS_DEFAULT_READ_CHANNEL"),
    glsCSTR("GLS_DEFAULT_WRITE_CHANNEL"),
};
static const GLubyte *const __glsEnumString7[5] = {
    glsCSTR("GLS_API_COUNT"),
    glsCSTR("GLS_MAX_CALL_NESTING"),
    glsCSTR("GLS_MAX_CAPTURE_NESTING"),
    glsCSTR("GLS_VERSION_MAJOR"),
    glsCSTR("GLS_VERSION_MINOR"),
};
static const GLubyte *const __glsEnumString8[1] = {
    glsCSTR("GLS_ALL_APIS"),
};
static const GLubyte *const __glsEnumString9[4] = {
    glsCSTR("GLS_EXTENSIONS"),
    glsCSTR("GLS_PLATFORM"),
    glsCSTR("GLS_RELEASE"),
    glsCSTR("GLS_VENDOR"),
};
static const GLubyte *const __glsEnumString10[4] = {
    GLS_NONE,
    glsCSTR("GLS_READ_FUNC"),
    glsCSTR("GLS_UNREAD_FUNC"),
    glsCSTR("GLS_WRITE_FUNC"),
};
static const GLubyte *const __glsEnumString11[1] = {
    glsCSTR("GLS_OUT_ARG_LIST"),
};
static const GLubyte *const __glsEnumString12[2] = {
    glsCSTR("GLS_CONTEXT_STREAM_LIST"),
    glsCSTR("GLS_READ_PREFIX_LIST"),
};
static const GLubyte *const __glsEnumString14[11] = {
    glsCSTR("GLS_DATA_POINTER"),
    glsCSTR("GLS_BLOCK_TYPE"),
    glsCSTR("GLS_CALL_NESTING"),
    glsCSTR("GLS_CAPTURE_NESTING"),
    glsCSTR("GLS_CONTEXT_STREAM_COUNT"),
    glsCSTR("GLS_CURRENT_GLRC"),
    glsCSTR("GLS_OUT_ARG_COUNT"),
    glsCSTR("GLS_PIXEL_SETUP_GEN"),
    glsCSTR("GLS_READ_PREFIX_COUNT"),
    glsCSTR("GLS_STREAM_VERSION_MAJOR"),
    glsCSTR("GLS_STREAM_VERSION_MINOR"),
};
static const GLubyte *const __glsEnumString16[1] = {
    glsCSTR("GLS_WRITE_PREFIX"),
};
static const GLubyte *const __glsEnumString17[3] = {
    glsCSTR("GLS_IIII"),
    glsCSTR("GLS_RGBA"),
    glsCSTR("GLS_RRRA"),
};
static const GLubyte *const __glsEnumString18[4] = {
    glsCSTR("GLS_DISPLAY_MAP_I_TO_R"),
    glsCSTR("GLS_DISPLAY_MAP_I_TO_G"),
    glsCSTR("GLS_DISPLAY_MAP_I_TO_B"),
    glsCSTR("GLS_DISPLAY_MAP_I_TO_A"),
};
static const GLubyte *const __glsEnumString19[16] = {
    glsCSTR("GLS_CALL_OVERFLOW"),
    glsCSTR("GLS_DECODE_ERROR"),
    glsCSTR("GLS_ENCODE_ERROR"),
    glsCSTR("GLS_INVALID_ENUM"),
    glsCSTR("GLS_INVALID_OPERATION"),
    glsCSTR("GLS_INVALID_STREAM"),
    glsCSTR("GLS_INVALID_STRING"),
    glsCSTR("GLS_INVALID_VALUE"),
    glsCSTR("GLS_NOT_FOUND"),
    glsCSTR("GLS_OUT_OF_MEMORY"),
    glsCSTR("GLS_STREAM_CLOSE_ERROR"),
    glsCSTR("GLS_STREAM_DELETE_ERROR"),
    glsCSTR("GLS_STREAM_OPEN_ERROR"),
    glsCSTR("GLS_STREAM_READ_ERROR"),
    glsCSTR("GLS_STREAM_WRITE_ERROR"),
    glsCSTR("GLS_UNSUPPORTED_COMMAND"),
};
static const GLubyte *const __glsEnumString20[1] = {
    glsCSTR("GLS_UNSUPPORTED_EXTENSION"),
};
static const GLubyte *const __glsEnumString21[1] = {
    glsCSTR("GLS_UNKNOWN"),
};
static const GLubyte *const __glsEnumString22[3] = {
    glsCSTR("GLS_LAYER"),
    glsCSTR("GLS_READ_LAYER"),
    glsCSTR("GLS_SHARE_GLRC"),
};
static const GLubyte *const __glsEnumString23[4] = {
    glsCSTR("GLS_ASPECT"),
    glsCSTR("GLS_BORDER_WIDTH"),
    glsCSTR("GLS_CONTRAST_RATIO"),
    glsCSTR("GLS_HEIGHT_MM"),
};
static const GLubyte *const __glsEnumString24[9] = {
    glsCSTR("GLS_BORDER_COLOR"),
    glsCSTR("GLS_GAMMA"),
    glsCSTR("GLS_ORIGIN"),
    glsCSTR("GLS_PAGE_COLOR"),
    glsCSTR("GLS_PAGE_SIZE"),
    glsCSTR("GLS_RED_POINT"),
    glsCSTR("GLS_GREEN_POINT"),
    glsCSTR("GLS_BLUE_POINT"),
    glsCSTR("GLS_WHITE_POINT"),
};
static const GLubyte *const __glsEnumString26[5] = {
    glsCSTR("GLS_FRAME_COUNT"),
    glsCSTR("GLS_GLRC_COUNT"),
    glsCSTR("GLS_HEIGHT_PIXELS"),
    glsCSTR("GLS_LAYER_COUNT"),
    glsCSTR("GLS_TILEABLE"),
};
static const GLubyte *const __glsEnumString27[2] = {
    glsCSTR("GLS_CREATE_TIME"),
    glsCSTR("GLS_MODIFY_TIME"),
};
static const GLubyte *const __glsEnumString28[6] = {
    glsCSTR("GLS_AUTHOR"),
    glsCSTR("GLS_DESCRIPTION"),
    glsCSTR("GLS_NOTES"),
    glsCSTR("GLS_TITLE"),
    glsCSTR("GLS_TOOLS"),
    glsCSTR("GLS_VERSION"),
};
static const GLubyte *const __glsEnumString29[1] = {
    glsCSTR("GLS_INVISIBLE_ASPECT"),
};
static const GLubyte *const __glsEnumString30[16] = {
    glsCSTR("GLS_DISPLAY_FORMAT"),
    glsCSTR("GLS_DOUBLEBUFFER"),
    glsCSTR("GLS_INVISIBLE"),
    glsCSTR("GLS_INVISIBLE_HEIGHT_PIXELS"),
    glsCSTR("GLS_LEVEL"),
    glsCSTR("GLS_STEREO"),
    glsCSTR("GLS_TRANSPARENT"),
    glsCSTR("GLS_INDEX_BITS"),
    glsCSTR("GLS_RED_BITS"),
    glsCSTR("GLS_GREEN_BITS"),
    glsCSTR("GLS_BLUE_BITS"),
    glsCSTR("GLS_ALPHA_BITS"),
    glsCSTR("GLS_DEPTH_BITS"),
    glsCSTR("GLS_STENCIL_BITS"),
    glsCSTR("GLS_ACCUM_RED_BITS"),
    glsCSTR("GLS_ACCUM_GREEN_BITS"),
};
static const GLubyte *const __glsEnumString31[3] = {
    glsCSTR("GLS_ACCUM_BLUE_BITS"),
    glsCSTR("GLS_ACCUM_ALPHA_BITS"),
    glsCSTR("GLS_AUX_BUFFERS"),
};
static const GLubyte *const __glsEnumString32[2] = {
    glsCSTR("GLS_APPEND"),
    glsCSTR("GLS_PREPEND"),
};
static const GLubyte *const __glsEnumString64[2] = {
    glsCSTR("GLS_SAMPLE_BUFFERS_SGIS"),
    glsCSTR("GLS_SAMPLES_SGIS"),
};

const GLint __glsEnumStringCount[65] = {
    1,
    2,
    2,
    4,
    2,
    4,
    2,
    5,
    1,
    4,
    4,
    1,
    2,
    0,
    11,
    0,
    1,
    3,
    4,
    16,
    1,
    1,
    3,
    4,
    9,
    0,
    5,
    2,
    6,
    1,
    16,
    3,
    2,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
};

const GLubyte *const *const __glsEnumString[65] = {
    __glsEnumString0,
    __glsEnumString1,
    __glsEnumString2,
    __glsEnumString3,
    __glsEnumString4,
    __glsEnumString5,
    __glsEnumString6,
    __glsEnumString7,
    __glsEnumString8,
    __glsEnumString9,
    __glsEnumString10,
    __glsEnumString11,
    __glsEnumString12,
    GLS_NONE,
    __glsEnumString14,
    GLS_NONE,
    __glsEnumString16,
    __glsEnumString17,
    __glsEnumString18,
    __glsEnumString19,
    __glsEnumString20,
    __glsEnumString21,
    __glsEnumString22,
    __glsEnumString23,
    __glsEnumString24,
    GLS_NONE,
    __glsEnumString26,
    __glsEnumString27,
    __glsEnumString28,
    __glsEnumString29,
    __glsEnumString30,
    __glsEnumString31,
    __glsEnumString32,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __glsEnumString64,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_dspdec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

// DrewB - All functions changed to use passed in context

extern void __gls_decode_bin_glsBeginGLS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBlock(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsError(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsGLRC(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsGLRCLayer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderGLRCi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderLayerf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderLayeri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsHeaderubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsAppRef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsCharubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsDisplayMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumb(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumbv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNuml(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumlv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNums(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumul(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumulv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumus(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsNumusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsSwapBuffers(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginPoints(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginLines(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginLineLoop(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginLineStrip(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginTriangles(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginTriangleStrip(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginTriangleFan(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginQuads(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginQuadStrip(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsBeginPolygon(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNewList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCallList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCallLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDeleteLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGenLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glListBase(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBegin(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBitmap(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor3us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColor4us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEdgeFlag(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexs(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormal3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRasterPos4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRecti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRects(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRectsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord1s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoord4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertex4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorMaterial(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCullFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFogiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFrontFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glHint(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLighti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModelf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModelfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModeli(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLightModeliv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLineStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLineWidth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMaterialf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMateriali(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPointSize(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPolygonMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glScissor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glShadeModel(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameterf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameteri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage1D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage2D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnvf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnvi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGend(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGenf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGeni(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFeedbackBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSelectBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRenderMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLoadName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPassThrough(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPushName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDrawBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClear(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearIndex(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearColor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearStencil(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glClearDepth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glStencilMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDepthMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDisable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEnable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPushAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMap2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMapGrid2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalMesh1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalPoint1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalMesh2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEvalPoint2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glAlphaFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBlendFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glLogicOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glStencilFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glStencilOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDepthFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelZoom(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelTransferf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelTransferi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelStoref(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelStorei(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glReadBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glReadPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDrawPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetBooleanv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetDoublev(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetFloatv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetIntegerv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMapdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMapiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetString(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexImage(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexLevelParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexLevelParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIsEnabled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIsList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDepthRange(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glFrustum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMatrixMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glOrtho(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRotated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glRotatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glScaled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glScalef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTranslated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTranslatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glViewport(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBlendColorEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBlendEquationEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPolygonOffsetEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSampleMaskSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSamplePatternSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameterfEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameteriEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetConvolutionFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetSeparableFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSeparableFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetHistogramParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetHistogramParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMinmaxParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetMinmaxParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glResetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glResetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glArrayElementEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDrawArraysEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glEdgeFlagPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetPointervEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIndexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glNormalPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexCoordPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glVertexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glAreTexturesResidentEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glBindTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glDeleteTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGenTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glIsTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPrioritizeTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyColorTableSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetColorTableParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetColorTableParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glGetTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glCopyTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glTexSubImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPixelTexGenSGIX(__GLScontext *, GLubyte *);
#ifdef __GLS_PLATFORM_WIN32
extern void __gls_decode_bin_glsCallStream(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glsRequireExtension(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glsBeginObj(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glsComment(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3bv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3ubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3uiv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor3usv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4bv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4ubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4uiv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColor4usv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEdgeFlagv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexdv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexfv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexiv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexsv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3bv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormal3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos2sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glRasterPos4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord1sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord2sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoord4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex2sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex3sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4iv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertex4sv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord1dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord1fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord2dv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEvalCoord2fv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glLoadMatrixf(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glLoadMatrixd(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glMultMatrixf(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glMultMatrixd(__GLScontext *ctx, GLubyte *inoutPtr);
#endif

// DrewB - 1.1
extern void __gls_decode_bin_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_glPushClientAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_glPopClientAttrib(__GLScontext *, GLubyte *);

// DrewB
extern void __gls_decode_bin_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr);

extern void __gls_decode_bin_swap_glsBeginGLS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsBlock(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsCallStream(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsEndGLS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsError(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsGLRC(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsGLRCLayer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderGLRCi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderLayerf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderLayeri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsHeaderubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsRequireExtension(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsUnsupportedCommand(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsAppRef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsBeginObj(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsCharubz(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsComment(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsDisplayMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsEndObj(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumb(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumbv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNuml(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumlv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNums(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumul(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumulv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumus(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsNumusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsPad(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glsSwapBuffers(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNewList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEndList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCallList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCallLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDeleteLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGenLists(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glListBase(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBegin(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBitmap(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3bv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3ubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3uiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor3usv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4bv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4ub(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4ubv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4ui(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4uiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4us(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColor4usv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEdgeFlag(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEdgeFlagv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEnd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexs(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3b(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3bv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormal3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos2sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRasterPos4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRecti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRects(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRectsv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord1sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord2sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoord4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex2sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex3sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4i(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4iv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4s(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertex4sv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorMaterial(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCullFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFogiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFrontFace(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glHint(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLighti(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModelf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModelfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModeli(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLightModeliv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLineStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLineWidth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMaterialf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMateriali(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPointSize(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPolygonMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glScissor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glShadeModel(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameterf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameteri(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage1D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage2D(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnvf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnvi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGend(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGenf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGeni(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFeedbackBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSelectBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRenderMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glInitNames(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPassThrough(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPushName(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDrawBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClear(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearIndex(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearColor(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearStencil(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glClearDepth(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glStencilMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDepthMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexMask(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glAccum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDisable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEnable(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFinish(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFlush(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPushAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMap2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMapGrid2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord1fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2d(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2dv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2f(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalCoord2fv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalMesh1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalPoint1(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalMesh2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEvalPoint2(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glAlphaFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBlendFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLogicOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glStencilFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glStencilOp(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDepthFunc(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelZoom(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelTransferf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelTransferi(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelStoref(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelStorei(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glReadBuffer(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glReadPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDrawPixels(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetBooleanv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetClipPlane(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetDoublev(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetError(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetFloatv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetIntegerv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetLightfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetLightiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMapdv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMapiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMaterialfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMaterialiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPixelMapfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPixelMapuiv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPixelMapusv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPolygonStipple(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetString(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexEnvfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexEnviv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexGendv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexGenfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexGeniv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexImage(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexLevelParameterfv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexLevelParameteriv(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIsEnabled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIsList(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDepthRange(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glFrustum(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadIdentity(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadMatrixf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glLoadMatrixd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMatrixMode(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMultMatrixf(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMultMatrixd(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glOrtho(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopMatrix(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPushMatrix(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRotated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glRotatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glScaled(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glScalef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTranslated(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTranslatef(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glViewport(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBlendColorEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBlendEquationEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPolygonOffsetEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSampleMaskSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSamplePatternSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTagSampleBufferSGIX(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameterfEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameteriEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyConvolutionFilter1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyConvolutionFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetConvolutionFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetConvolutionParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetConvolutionParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetSeparableFilterEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSeparableFilter2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetHistogramParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetHistogramParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMinmaxParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetMinmaxParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glResetHistogramEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glResetMinmaxEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetDetailTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetSharpenTexFuncSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glArrayElementEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDrawArraysEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glEdgeFlagPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetPointervEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIndexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glNormalPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexCoordPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glVertexPointerEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glAreTexturesResidentEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glBindTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glDeleteTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGenTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glIsTextureEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPrioritizeTexturesEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyColorTableSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetColorTableEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetColorTableParameterfvEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetColorTableParameterivEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glGetTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexColorTableParameterfvSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexColorTableParameterivSGI(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexSubImage1DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexSubImage2DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glCopyTexSubImage3DEXT(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glTexSubImage4DSGIS(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPixelTexGenSGIX(__GLScontext *, GLubyte *);

// DrewB - 1.1
extern void __gls_decode_bin_swap_glArrayElement(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glBindTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glColorPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDisableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDrawArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDrawElements(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glEdgeFlagPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glEnableClientState(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIndexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIndexub(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIndexubv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glInterleavedArrays(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glNormalPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glPolygonOffset(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glTexCoordPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glVertexPointer(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glAreTexturesResident(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glCopyTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glDeleteTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glGenTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glGetPointerv(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glIsTexture(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glPrioritizeTextures(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glTexSubImage1D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glTexSubImage2D(__GLScontext *ctx, GLubyte *inoutPtr);
extern void __gls_decode_bin_swap_glPushClientAttrib(__GLScontext *, GLubyte *);
extern void __gls_decode_bin_swap_glPopClientAttrib(__GLScontext *, GLubyte *);

// DrewB
extern void __gls_decode_bin_swap_glColorSubTableEXT(__GLScontext *ctx, GLubyte *inoutPtr);

extern void __gls_decode_text_glsBeginGLS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsBlock(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsCallStream(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsEndGLS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsError(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsGLRC(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsGLRCLayer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderGLRCi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderLayerf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderLayeri(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsHeaderubz(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsRequireExtension(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsUnsupportedCommand(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsAppRef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsBeginObj(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsCharubz(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsComment(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsDisplayMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsEndObj(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumb(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumbv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNuml(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumlv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNums(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumsv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumub(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumubv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumui(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumuiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumul(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumulv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumus(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsNumusv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsPad(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glsSwapBuffers(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNewList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEndList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCallList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCallLists(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDeleteLists(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGenLists(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glListBase(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBegin(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBitmap(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3b(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3bv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3ub(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3ubv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3ui(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3uiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3us(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor3usv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4b(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4bv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4ub(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4ubv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4ui(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4uiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4us(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColor4usv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEdgeFlag(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEdgeFlagv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEnd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexs(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexsv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3b(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3bv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormal3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos2sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRasterPos4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRecti(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRects(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRectsv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord1sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord2sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoord4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex2sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex3sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4i(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4iv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4s(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertex4sv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClipPlane(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorMaterial(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCullFace(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFogiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFrontFace(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glHint(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLighti(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModelf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModelfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModeli(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLightModeliv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLineStipple(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLineWidth(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMaterialf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMaterialfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMateriali(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMaterialiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPointSize(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPolygonMode(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPolygonStipple(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glScissor(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glShadeModel(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameterf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameterfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameteri(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexParameteriv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage1D(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage2D(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnvf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnvfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnvi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexEnviv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGend(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGendv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGenf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGenfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGeni(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexGeniv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFeedbackBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSelectBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRenderMode(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glInitNames(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadName(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPassThrough(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopName(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPushName(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDrawBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClear(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearAccum(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearIndex(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearColor(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearStencil(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glClearDepth(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glStencilMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDepthMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexMask(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glAccum(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDisable(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEnable(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFinish(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFlush(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopAttrib(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPushAttrib(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMap2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMapGrid2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord1fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2d(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2dv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2f(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalCoord2fv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalMesh1(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalPoint1(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalMesh2(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEvalPoint2(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glAlphaFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBlendFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLogicOp(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glStencilFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glStencilOp(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDepthFunc(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelZoom(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelTransferf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelTransferi(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelStoref(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelStorei(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelMapuiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelMapusv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glReadBuffer(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyPixels(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glReadPixels(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDrawPixels(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetBooleanv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetClipPlane(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetDoublev(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetError(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetFloatv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetIntegerv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetLightfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetLightiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMapdv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMapiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMaterialfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMaterialiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPixelMapfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPixelMapuiv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPixelMapusv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPolygonStipple(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetString(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexEnvfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexEnviv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexGendv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexGenfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexGeniv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexImage(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexParameterfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexParameteriv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexLevelParameterfv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexLevelParameteriv(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIsEnabled(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIsList(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDepthRange(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glFrustum(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadIdentity(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadMatrixf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glLoadMatrixd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMatrixMode(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMultMatrixf(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMultMatrixd(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glOrtho(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopMatrix(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPushMatrix(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRotated(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glRotatef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glScaled(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glScalef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTranslated(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTranslatef(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glViewport(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBlendColorEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBlendEquationEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPolygonOffsetEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSampleMaskSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSamplePatternSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTagSampleBufferSGIX(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionFilter1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionFilter2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameterfEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameteriEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glConvolutionParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyConvolutionFilter1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyConvolutionFilter2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetConvolutionFilterEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetConvolutionParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetConvolutionParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetSeparableFilterEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSeparableFilter2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetHistogramEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetHistogramParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetHistogramParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMinmaxEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMinmaxParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetMinmaxParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glHistogramEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glMinmaxEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glResetHistogramEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glResetMinmaxEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage3DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage3DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDetailTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetDetailTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glSharpenTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetSharpenTexFuncSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glArrayElementEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDrawArraysEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glEdgeFlagPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetPointervEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIndexPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glNormalPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexCoordPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glVertexPointerEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glAreTexturesResidentEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glBindTextureEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glDeleteTexturesEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGenTexturesEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glIsTextureEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPrioritizeTexturesEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorTableEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorTableParameterfvSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glColorTableParameterivSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyColorTableSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetColorTableEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetColorTableParameterfvEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetColorTableParameterivEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexColorTableParameterfvSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glGetTexColorTableParameterivSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexColorTableParameterfvSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexColorTableParameterivSGI(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage1DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage2DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage3DEXT(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexImage4DSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glTexSubImage4DSGIS(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPixelTexGenSGIX(__GLScontext *, __GLSreader *);

// DrewB - 1.1
extern void __gls_decode_text_glArrayElement(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glBindTexture(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glColorPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDisableClientState(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDrawArrays(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDrawElements(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glEdgeFlagPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glEnableClientState(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIndexPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIndexub(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIndexubv(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glInterleavedArrays(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glNormalPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glPolygonOffset(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glTexCoordPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glVertexPointer(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glAreTexturesResident(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage1D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexImage2D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage1D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glCopyTexSubImage2D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glDeleteTextures(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glGenTextures(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glGetPointerv(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glIsTexture(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glPrioritizeTextures(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glTexSubImage1D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glTexSubImage2D(__GLScontext *ctx, __GLSreader *);
extern void __gls_decode_text_glPushClientAttrib(__GLScontext *, __GLSreader *);
extern void __gls_decode_text_glPopClientAttrib(__GLScontext *, __GLSreader *);

// DrewB
extern void __gls_decode_text_glColorSubTableEXT(__GLScontext *ctx, __GLSreader *);

#ifndef __GLS_PLATFORM_WIN32
// DrewB
#define BIN_SINGLE(fn) GLS_NONE
#else
#define BIN_SINGLE(fn) fn
#endif

__GLSdecodeBinFunc __glsDispatchDecode_bin_default[
    __GLS_OPCODE_COUNT
] = {
    GLS_NONE,
    __gls_decode_bin_glsBeginPoints,
    __gls_decode_bin_glsBeginLines,
    __gls_decode_bin_glsBeginLineLoop,
    __gls_decode_bin_glsBeginLineStrip,
    __gls_decode_bin_glsBeginTriangles,
    __gls_decode_bin_glsBeginTriangleStrip,
    __gls_decode_bin_glsBeginTriangleFan,
    __gls_decode_bin_glsBeginQuads,
    __gls_decode_bin_glsBeginQuadStrip,
    __gls_decode_bin_glsBeginPolygon,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glsBeginGLS,
    __gls_decode_bin_glsBlock,
    BIN_SINGLE(__gls_decode_bin_glsCallStream),
    GLS_NONE,
    __gls_decode_bin_glsError,
    __gls_decode_bin_glsGLRC,
    __gls_decode_bin_glsGLRCLayer,
    __gls_decode_bin_glsHeaderGLRCi,
    __gls_decode_bin_glsHeaderLayerf,
    __gls_decode_bin_glsHeaderLayeri,
    __gls_decode_bin_glsHeaderf,
    __gls_decode_bin_glsHeaderfv,
    __gls_decode_bin_glsHeaderi,
    __gls_decode_bin_glsHeaderiv,
    __gls_decode_bin_glsHeaderubz,
    BIN_SINGLE(__gls_decode_bin_glsRequireExtension),
    GLS_NONE,
    __gls_decode_bin_glsAppRef,
    BIN_SINGLE(__gls_decode_bin_glsBeginObj),
    __gls_decode_bin_glsCharubz,
    BIN_SINGLE(__gls_decode_bin_glsComment),
    __gls_decode_bin_glsDisplayMapfv,
    GLS_NONE,
    __gls_decode_bin_glsNumb,
    __gls_decode_bin_glsNumbv,
    __gls_decode_bin_glsNumd,
    __gls_decode_bin_glsNumdv,
    __gls_decode_bin_glsNumf,
    __gls_decode_bin_glsNumfv,
    __gls_decode_bin_glsNumi,
    __gls_decode_bin_glsNumiv,
    __gls_decode_bin_glsNuml,
    __gls_decode_bin_glsNumlv,
    __gls_decode_bin_glsNums,
    __gls_decode_bin_glsNumsv,
    __gls_decode_bin_glsNumub,
    __gls_decode_bin_glsNumubv,
    __gls_decode_bin_glsNumui,
    __gls_decode_bin_glsNumuiv,
    __gls_decode_bin_glsNumul,
    __gls_decode_bin_glsNumulv,
    __gls_decode_bin_glsNumus,
    __gls_decode_bin_glsNumusv,
    GLS_NONE,
    __gls_decode_bin_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glNewList,
    GLS_NONE,
    __gls_decode_bin_glCallList,
    __gls_decode_bin_glCallLists,
    __gls_decode_bin_glDeleteLists,
    __gls_decode_bin_glGenLists,
    __gls_decode_bin_glListBase,
    __gls_decode_bin_glBegin,
    __gls_decode_bin_glBitmap,
    __gls_decode_bin_glColor3b,
    BIN_SINGLE(__gls_decode_bin_glColor3bv),
    __gls_decode_bin_glColor3d,
    BIN_SINGLE(__gls_decode_bin_glColor3dv),
    __gls_decode_bin_glColor3f,
    BIN_SINGLE(__gls_decode_bin_glColor3fv),
    __gls_decode_bin_glColor3i,
    BIN_SINGLE(__gls_decode_bin_glColor3iv),
    __gls_decode_bin_glColor3s,
    BIN_SINGLE(__gls_decode_bin_glColor3sv),
    __gls_decode_bin_glColor3ub,
    BIN_SINGLE(__gls_decode_bin_glColor3ubv),
    __gls_decode_bin_glColor3ui,
    BIN_SINGLE(__gls_decode_bin_glColor3uiv),
    __gls_decode_bin_glColor3us,
    BIN_SINGLE(__gls_decode_bin_glColor3usv),
    __gls_decode_bin_glColor4b,
    BIN_SINGLE(__gls_decode_bin_glColor4bv),
    __gls_decode_bin_glColor4d,
    BIN_SINGLE(__gls_decode_bin_glColor4dv),
    __gls_decode_bin_glColor4f,
    BIN_SINGLE(__gls_decode_bin_glColor4fv),
    __gls_decode_bin_glColor4i,
    BIN_SINGLE(__gls_decode_bin_glColor4iv),
    __gls_decode_bin_glColor4s,
    BIN_SINGLE(__gls_decode_bin_glColor4sv),
    __gls_decode_bin_glColor4ub,
    BIN_SINGLE(__gls_decode_bin_glColor4ubv),
    __gls_decode_bin_glColor4ui,
    BIN_SINGLE(__gls_decode_bin_glColor4uiv),
    __gls_decode_bin_glColor4us,
    BIN_SINGLE(__gls_decode_bin_glColor4usv),
    __gls_decode_bin_glEdgeFlag,
    BIN_SINGLE(__gls_decode_bin_glEdgeFlagv),
    GLS_NONE,
    __gls_decode_bin_glIndexd,
    BIN_SINGLE(__gls_decode_bin_glIndexdv),
    __gls_decode_bin_glIndexf,
    BIN_SINGLE(__gls_decode_bin_glIndexfv),
    __gls_decode_bin_glIndexi,
    BIN_SINGLE(__gls_decode_bin_glIndexiv),
    __gls_decode_bin_glIndexs,
    BIN_SINGLE(__gls_decode_bin_glIndexsv),
    __gls_decode_bin_glNormal3b,
    BIN_SINGLE(__gls_decode_bin_glNormal3bv),
    __gls_decode_bin_glNormal3d,
    BIN_SINGLE(__gls_decode_bin_glNormal3dv),
    __gls_decode_bin_glNormal3f,
    BIN_SINGLE(__gls_decode_bin_glNormal3fv),
    __gls_decode_bin_glNormal3i,
    BIN_SINGLE(__gls_decode_bin_glNormal3iv),
    __gls_decode_bin_glNormal3s,
    BIN_SINGLE(__gls_decode_bin_glNormal3sv),
    __gls_decode_bin_glRasterPos2d,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2dv),
    __gls_decode_bin_glRasterPos2f,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2fv),
    __gls_decode_bin_glRasterPos2i,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2iv),
    __gls_decode_bin_glRasterPos2s,
    BIN_SINGLE(__gls_decode_bin_glRasterPos2sv),
    __gls_decode_bin_glRasterPos3d,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3dv),
    __gls_decode_bin_glRasterPos3f,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3fv),
    __gls_decode_bin_glRasterPos3i,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3iv),
    __gls_decode_bin_glRasterPos3s,
    BIN_SINGLE(__gls_decode_bin_glRasterPos3sv),
    __gls_decode_bin_glRasterPos4d,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4dv),
    __gls_decode_bin_glRasterPos4f,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4fv),
    __gls_decode_bin_glRasterPos4i,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4iv),
    __gls_decode_bin_glRasterPos4s,
    BIN_SINGLE(__gls_decode_bin_glRasterPos4sv),
    __gls_decode_bin_glRectd,
    __gls_decode_bin_glRectdv,
    __gls_decode_bin_glRectf,
    __gls_decode_bin_glRectfv,
    __gls_decode_bin_glRecti,
    __gls_decode_bin_glRectiv,
    __gls_decode_bin_glRects,
    __gls_decode_bin_glRectsv,
    __gls_decode_bin_glTexCoord1d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1dv),
    __gls_decode_bin_glTexCoord1f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1fv),
    __gls_decode_bin_glTexCoord1i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1iv),
    __gls_decode_bin_glTexCoord1s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord1sv),
    __gls_decode_bin_glTexCoord2d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2dv),
    __gls_decode_bin_glTexCoord2f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2fv),
    __gls_decode_bin_glTexCoord2i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2iv),
    __gls_decode_bin_glTexCoord2s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord2sv),
    __gls_decode_bin_glTexCoord3d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3dv),
    __gls_decode_bin_glTexCoord3f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3fv),
    __gls_decode_bin_glTexCoord3i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3iv),
    __gls_decode_bin_glTexCoord3s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord3sv),
    __gls_decode_bin_glTexCoord4d,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4dv),
    __gls_decode_bin_glTexCoord4f,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4fv),
    __gls_decode_bin_glTexCoord4i,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4iv),
    __gls_decode_bin_glTexCoord4s,
    BIN_SINGLE(__gls_decode_bin_glTexCoord4sv),
    __gls_decode_bin_glVertex2d,
    BIN_SINGLE(__gls_decode_bin_glVertex2dv),
    __gls_decode_bin_glVertex2f,
    BIN_SINGLE(__gls_decode_bin_glVertex2fv),
    __gls_decode_bin_glVertex2i,
    BIN_SINGLE(__gls_decode_bin_glVertex2iv),
    __gls_decode_bin_glVertex2s,
    BIN_SINGLE(__gls_decode_bin_glVertex2sv),
    __gls_decode_bin_glVertex3d,
    BIN_SINGLE(__gls_decode_bin_glVertex3dv),
    __gls_decode_bin_glVertex3f,
    BIN_SINGLE(__gls_decode_bin_glVertex3fv),
    __gls_decode_bin_glVertex3i,
    BIN_SINGLE(__gls_decode_bin_glVertex3iv),
    __gls_decode_bin_glVertex3s,
    BIN_SINGLE(__gls_decode_bin_glVertex3sv),
    __gls_decode_bin_glVertex4d,
    BIN_SINGLE(__gls_decode_bin_glVertex4dv),
    __gls_decode_bin_glVertex4f,
    BIN_SINGLE(__gls_decode_bin_glVertex4fv),
    __gls_decode_bin_glVertex4i,
    BIN_SINGLE(__gls_decode_bin_glVertex4iv),
    __gls_decode_bin_glVertex4s,
    BIN_SINGLE(__gls_decode_bin_glVertex4sv),
    __gls_decode_bin_glClipPlane,
    __gls_decode_bin_glColorMaterial,
    __gls_decode_bin_glCullFace,
    __gls_decode_bin_glFogf,
    __gls_decode_bin_glFogfv,
    __gls_decode_bin_glFogi,
    __gls_decode_bin_glFogiv,
    __gls_decode_bin_glFrontFace,
    __gls_decode_bin_glHint,
    __gls_decode_bin_glLightf,
    __gls_decode_bin_glLightfv,
    __gls_decode_bin_glLighti,
    __gls_decode_bin_glLightiv,
    __gls_decode_bin_glLightModelf,
    __gls_decode_bin_glLightModelfv,
    __gls_decode_bin_glLightModeli,
    __gls_decode_bin_glLightModeliv,
    __gls_decode_bin_glLineStipple,
    __gls_decode_bin_glLineWidth,
    __gls_decode_bin_glMaterialf,
    __gls_decode_bin_glMaterialfv,
    __gls_decode_bin_glMateriali,
    __gls_decode_bin_glMaterialiv,
    __gls_decode_bin_glPointSize,
    __gls_decode_bin_glPolygonMode,
    __gls_decode_bin_glPolygonStipple,
    __gls_decode_bin_glScissor,
    __gls_decode_bin_glShadeModel,
    __gls_decode_bin_glTexParameterf,
    __gls_decode_bin_glTexParameterfv,
    __gls_decode_bin_glTexParameteri,
    __gls_decode_bin_glTexParameteriv,
    __gls_decode_bin_glTexImage1D,
    __gls_decode_bin_glTexImage2D,
    __gls_decode_bin_glTexEnvf,
    __gls_decode_bin_glTexEnvfv,
    __gls_decode_bin_glTexEnvi,
    __gls_decode_bin_glTexEnviv,
    __gls_decode_bin_glTexGend,
    __gls_decode_bin_glTexGendv,
    __gls_decode_bin_glTexGenf,
    __gls_decode_bin_glTexGenfv,
    __gls_decode_bin_glTexGeni,
    __gls_decode_bin_glTexGeniv,
    __gls_decode_bin_glFeedbackBuffer,
    __gls_decode_bin_glSelectBuffer,
    __gls_decode_bin_glRenderMode,
    GLS_NONE,
    __gls_decode_bin_glLoadName,
    __gls_decode_bin_glPassThrough,
    GLS_NONE,
    __gls_decode_bin_glPushName,
    __gls_decode_bin_glDrawBuffer,
    __gls_decode_bin_glClear,
    __gls_decode_bin_glClearAccum,
    __gls_decode_bin_glClearIndex,
    __gls_decode_bin_glClearColor,
    __gls_decode_bin_glClearStencil,
    __gls_decode_bin_glClearDepth,
    __gls_decode_bin_glStencilMask,
    __gls_decode_bin_glColorMask,
    __gls_decode_bin_glDepthMask,
    __gls_decode_bin_glIndexMask,
    __gls_decode_bin_glAccum,
    __gls_decode_bin_glDisable,
    __gls_decode_bin_glEnable,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glPushAttrib,
    __gls_decode_bin_glMap1d,
    __gls_decode_bin_glMap1f,
    __gls_decode_bin_glMap2d,
    __gls_decode_bin_glMap2f,
    __gls_decode_bin_glMapGrid1d,
    __gls_decode_bin_glMapGrid1f,
    __gls_decode_bin_glMapGrid2d,
    __gls_decode_bin_glMapGrid2f,
    __gls_decode_bin_glEvalCoord1d,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord1dv),
    __gls_decode_bin_glEvalCoord1f,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord1fv),
    __gls_decode_bin_glEvalCoord2d,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord2dv),
    __gls_decode_bin_glEvalCoord2f,
    BIN_SINGLE(__gls_decode_bin_glEvalCoord2fv),
    __gls_decode_bin_glEvalMesh1,
    __gls_decode_bin_glEvalPoint1,
    __gls_decode_bin_glEvalMesh2,
    __gls_decode_bin_glEvalPoint2,
    __gls_decode_bin_glAlphaFunc,
    __gls_decode_bin_glBlendFunc,
    __gls_decode_bin_glLogicOp,
    __gls_decode_bin_glStencilFunc,
    __gls_decode_bin_glStencilOp,
    __gls_decode_bin_glDepthFunc,
    __gls_decode_bin_glPixelZoom,
    __gls_decode_bin_glPixelTransferf,
    __gls_decode_bin_glPixelTransferi,
    __gls_decode_bin_glPixelStoref,
    __gls_decode_bin_glPixelStorei,
    __gls_decode_bin_glPixelMapfv,
    __gls_decode_bin_glPixelMapuiv,
    __gls_decode_bin_glPixelMapusv,
    __gls_decode_bin_glReadBuffer,
    __gls_decode_bin_glCopyPixels,
    __gls_decode_bin_glReadPixels,
    __gls_decode_bin_glDrawPixels,
    __gls_decode_bin_glGetBooleanv,
    __gls_decode_bin_glGetClipPlane,
    __gls_decode_bin_glGetDoublev,
    GLS_NONE,
    __gls_decode_bin_glGetFloatv,
    __gls_decode_bin_glGetIntegerv,
    __gls_decode_bin_glGetLightfv,
    __gls_decode_bin_glGetLightiv,
    __gls_decode_bin_glGetMapdv,
    __gls_decode_bin_glGetMapfv,
    __gls_decode_bin_glGetMapiv,
    __gls_decode_bin_glGetMaterialfv,
    __gls_decode_bin_glGetMaterialiv,
    __gls_decode_bin_glGetPixelMapfv,
    __gls_decode_bin_glGetPixelMapuiv,
    __gls_decode_bin_glGetPixelMapusv,
    __gls_decode_bin_glGetPolygonStipple,
    __gls_decode_bin_glGetString,
    __gls_decode_bin_glGetTexEnvfv,
    __gls_decode_bin_glGetTexEnviv,
    __gls_decode_bin_glGetTexGendv,
    __gls_decode_bin_glGetTexGenfv,
    __gls_decode_bin_glGetTexGeniv,
    __gls_decode_bin_glGetTexImage,
    __gls_decode_bin_glGetTexParameterfv,
    __gls_decode_bin_glGetTexParameteriv,
    __gls_decode_bin_glGetTexLevelParameterfv,
    __gls_decode_bin_glGetTexLevelParameteriv,
    __gls_decode_bin_glIsEnabled,
    __gls_decode_bin_glIsList,
    __gls_decode_bin_glDepthRange,
    __gls_decode_bin_glFrustum,
    GLS_NONE,
    BIN_SINGLE(__gls_decode_bin_glLoadMatrixf),
    BIN_SINGLE(__gls_decode_bin_glLoadMatrixd),
    __gls_decode_bin_glMatrixMode,
    BIN_SINGLE(__gls_decode_bin_glMultMatrixf),
    BIN_SINGLE(__gls_decode_bin_glMultMatrixd),
    __gls_decode_bin_glOrtho,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_glRotated,
    __gls_decode_bin_glRotatef,
    __gls_decode_bin_glScaled,
    __gls_decode_bin_glScalef,
    __gls_decode_bin_glTranslated,
    __gls_decode_bin_glTranslatef,
    __gls_decode_bin_glViewport,
    // DrewB - 1.1
    __gls_decode_bin_glArrayElement,
    __gls_decode_bin_glBindTexture,
    __gls_decode_bin_glColorPointer,
    __gls_decode_bin_glDisableClientState,
    __gls_decode_bin_glDrawArrays,
    __gls_decode_bin_glDrawElements,
    __gls_decode_bin_glEdgeFlagPointer,
    __gls_decode_bin_glEnableClientState,
    __gls_decode_bin_glIndexPointer,
    __gls_decode_bin_glIndexub,
    __gls_decode_bin_glIndexubv,
    __gls_decode_bin_glInterleavedArrays,
    __gls_decode_bin_glNormalPointer,
    __gls_decode_bin_glPolygonOffset,
    __gls_decode_bin_glTexCoordPointer,
    __gls_decode_bin_glVertexPointer,
    __gls_decode_bin_glAreTexturesResident,
    __gls_decode_bin_glCopyTexImage1D,
    __gls_decode_bin_glCopyTexImage2D,
    __gls_decode_bin_glCopyTexSubImage1D,
    __gls_decode_bin_glCopyTexSubImage2D,
    __gls_decode_bin_glDeleteTextures,
    __gls_decode_bin_glGenTextures,
    __gls_decode_bin_glGetPointerv,
    __gls_decode_bin_glIsTexture,
    __gls_decode_bin_glPrioritizeTextures,
    __gls_decode_bin_glTexSubImage1D,
    __gls_decode_bin_glTexSubImage2D,
    __gls_decode_bin_glPushClientAttrib,
    GLS_NONE,
    #if __GL_EXT_blend_color
        __gls_decode_bin_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        __gls_decode_bin_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        __gls_decode_bin_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        __gls_decode_bin_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        __gls_decode_bin_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        __gls_decode_bin_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        __gls_decode_bin_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    GLS_NONE,
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        __gls_decode_bin_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        __gls_decode_bin_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        __gls_decode_bin_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        __gls_decode_bin_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    GLS_NONE, // __GL_WIN_draw_range_elements
};

const __GLSdecodeBinFunc __glsDispatchDecode_bin_swap[
    __GLS_OPCODE_COUNT
] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_swap_glsBeginGLS,
    __gls_decode_bin_swap_glsBlock,
    __gls_decode_bin_swap_glsCallStream,
    __gls_decode_bin_swap_glsEndGLS,
    __gls_decode_bin_swap_glsError,
    __gls_decode_bin_swap_glsGLRC,
    __gls_decode_bin_swap_glsGLRCLayer,
    __gls_decode_bin_swap_glsHeaderGLRCi,
    __gls_decode_bin_swap_glsHeaderLayerf,
    __gls_decode_bin_swap_glsHeaderLayeri,
    __gls_decode_bin_swap_glsHeaderf,
    __gls_decode_bin_swap_glsHeaderfv,
    __gls_decode_bin_swap_glsHeaderi,
    __gls_decode_bin_swap_glsHeaderiv,
    __gls_decode_bin_swap_glsHeaderubz,
    __gls_decode_bin_swap_glsRequireExtension,
    __gls_decode_bin_swap_glsUnsupportedCommand,
    __gls_decode_bin_swap_glsAppRef,
    __gls_decode_bin_swap_glsBeginObj,
    __gls_decode_bin_swap_glsCharubz,
    __gls_decode_bin_swap_glsComment,
    __gls_decode_bin_swap_glsDisplayMapfv,
    __gls_decode_bin_swap_glsEndObj,
    __gls_decode_bin_swap_glsNumb,
    __gls_decode_bin_swap_glsNumbv,
    __gls_decode_bin_swap_glsNumd,
    __gls_decode_bin_swap_glsNumdv,
    __gls_decode_bin_swap_glsNumf,
    __gls_decode_bin_swap_glsNumfv,
    __gls_decode_bin_swap_glsNumi,
    __gls_decode_bin_swap_glsNumiv,
    __gls_decode_bin_swap_glsNuml,
    __gls_decode_bin_swap_glsNumlv,
    __gls_decode_bin_swap_glsNums,
    __gls_decode_bin_swap_glsNumsv,
    __gls_decode_bin_swap_glsNumub,
    __gls_decode_bin_swap_glsNumubv,
    __gls_decode_bin_swap_glsNumui,
    __gls_decode_bin_swap_glsNumuiv,
    __gls_decode_bin_swap_glsNumul,
    __gls_decode_bin_swap_glsNumulv,
    __gls_decode_bin_swap_glsNumus,
    __gls_decode_bin_swap_glsNumusv,
    __gls_decode_bin_swap_glsPad,
    __gls_decode_bin_swap_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_bin_swap_glNewList,
    __gls_decode_bin_swap_glEndList,
    __gls_decode_bin_swap_glCallList,
    __gls_decode_bin_swap_glCallLists,
    __gls_decode_bin_swap_glDeleteLists,
    __gls_decode_bin_swap_glGenLists,
    __gls_decode_bin_swap_glListBase,
    __gls_decode_bin_swap_glBegin,
    __gls_decode_bin_swap_glBitmap,
    __gls_decode_bin_swap_glColor3b,
    __gls_decode_bin_swap_glColor3bv,
    __gls_decode_bin_swap_glColor3d,
    __gls_decode_bin_swap_glColor3dv,
    __gls_decode_bin_swap_glColor3f,
    __gls_decode_bin_swap_glColor3fv,
    __gls_decode_bin_swap_glColor3i,
    __gls_decode_bin_swap_glColor3iv,
    __gls_decode_bin_swap_glColor3s,
    __gls_decode_bin_swap_glColor3sv,
    __gls_decode_bin_swap_glColor3ub,
    __gls_decode_bin_swap_glColor3ubv,
    __gls_decode_bin_swap_glColor3ui,
    __gls_decode_bin_swap_glColor3uiv,
    __gls_decode_bin_swap_glColor3us,
    __gls_decode_bin_swap_glColor3usv,
    __gls_decode_bin_swap_glColor4b,
    __gls_decode_bin_swap_glColor4bv,
    __gls_decode_bin_swap_glColor4d,
    __gls_decode_bin_swap_glColor4dv,
    __gls_decode_bin_swap_glColor4f,
    __gls_decode_bin_swap_glColor4fv,
    __gls_decode_bin_swap_glColor4i,
    __gls_decode_bin_swap_glColor4iv,
    __gls_decode_bin_swap_glColor4s,
    __gls_decode_bin_swap_glColor4sv,
    __gls_decode_bin_swap_glColor4ub,
    __gls_decode_bin_swap_glColor4ubv,
    __gls_decode_bin_swap_glColor4ui,
    __gls_decode_bin_swap_glColor4uiv,
    __gls_decode_bin_swap_glColor4us,
    __gls_decode_bin_swap_glColor4usv,
    __gls_decode_bin_swap_glEdgeFlag,
    __gls_decode_bin_swap_glEdgeFlagv,
    __gls_decode_bin_swap_glEnd,
    __gls_decode_bin_swap_glIndexd,
    __gls_decode_bin_swap_glIndexdv,
    __gls_decode_bin_swap_glIndexf,
    __gls_decode_bin_swap_glIndexfv,
    __gls_decode_bin_swap_glIndexi,
    __gls_decode_bin_swap_glIndexiv,
    __gls_decode_bin_swap_glIndexs,
    __gls_decode_bin_swap_glIndexsv,
    __gls_decode_bin_swap_glNormal3b,
    __gls_decode_bin_swap_glNormal3bv,
    __gls_decode_bin_swap_glNormal3d,
    __gls_decode_bin_swap_glNormal3dv,
    __gls_decode_bin_swap_glNormal3f,
    __gls_decode_bin_swap_glNormal3fv,
    __gls_decode_bin_swap_glNormal3i,
    __gls_decode_bin_swap_glNormal3iv,
    __gls_decode_bin_swap_glNormal3s,
    __gls_decode_bin_swap_glNormal3sv,
    __gls_decode_bin_swap_glRasterPos2d,
    __gls_decode_bin_swap_glRasterPos2dv,
    __gls_decode_bin_swap_glRasterPos2f,
    __gls_decode_bin_swap_glRasterPos2fv,
    __gls_decode_bin_swap_glRasterPos2i,
    __gls_decode_bin_swap_glRasterPos2iv,
    __gls_decode_bin_swap_glRasterPos2s,
    __gls_decode_bin_swap_glRasterPos2sv,
    __gls_decode_bin_swap_glRasterPos3d,
    __gls_decode_bin_swap_glRasterPos3dv,
    __gls_decode_bin_swap_glRasterPos3f,
    __gls_decode_bin_swap_glRasterPos3fv,
    __gls_decode_bin_swap_glRasterPos3i,
    __gls_decode_bin_swap_glRasterPos3iv,
    __gls_decode_bin_swap_glRasterPos3s,
    __gls_decode_bin_swap_glRasterPos3sv,
    __gls_decode_bin_swap_glRasterPos4d,
    __gls_decode_bin_swap_glRasterPos4dv,
    __gls_decode_bin_swap_glRasterPos4f,
    __gls_decode_bin_swap_glRasterPos4fv,
    __gls_decode_bin_swap_glRasterPos4i,
    __gls_decode_bin_swap_glRasterPos4iv,
    __gls_decode_bin_swap_glRasterPos4s,
    __gls_decode_bin_swap_glRasterPos4sv,
    __gls_decode_bin_swap_glRectd,
    __gls_decode_bin_swap_glRectdv,
    __gls_decode_bin_swap_glRectf,
    __gls_decode_bin_swap_glRectfv,
    __gls_decode_bin_swap_glRecti,
    __gls_decode_bin_swap_glRectiv,
    __gls_decode_bin_swap_glRects,
    __gls_decode_bin_swap_glRectsv,
    __gls_decode_bin_swap_glTexCoord1d,
    __gls_decode_bin_swap_glTexCoord1dv,
    __gls_decode_bin_swap_glTexCoord1f,
    __gls_decode_bin_swap_glTexCoord1fv,
    __gls_decode_bin_swap_glTexCoord1i,
    __gls_decode_bin_swap_glTexCoord1iv,
    __gls_decode_bin_swap_glTexCoord1s,
    __gls_decode_bin_swap_glTexCoord1sv,
    __gls_decode_bin_swap_glTexCoord2d,
    __gls_decode_bin_swap_glTexCoord2dv,
    __gls_decode_bin_swap_glTexCoord2f,
    __gls_decode_bin_swap_glTexCoord2fv,
    __gls_decode_bin_swap_glTexCoord2i,
    __gls_decode_bin_swap_glTexCoord2iv,
    __gls_decode_bin_swap_glTexCoord2s,
    __gls_decode_bin_swap_glTexCoord2sv,
    __gls_decode_bin_swap_glTexCoord3d,
    __gls_decode_bin_swap_glTexCoord3dv,
    __gls_decode_bin_swap_glTexCoord3f,
    __gls_decode_bin_swap_glTexCoord3fv,
    __gls_decode_bin_swap_glTexCoord3i,
    __gls_decode_bin_swap_glTexCoord3iv,
    __gls_decode_bin_swap_glTexCoord3s,
    __gls_decode_bin_swap_glTexCoord3sv,
    __gls_decode_bin_swap_glTexCoord4d,
    __gls_decode_bin_swap_glTexCoord4dv,
    __gls_decode_bin_swap_glTexCoord4f,
    __gls_decode_bin_swap_glTexCoord4fv,
    __gls_decode_bin_swap_glTexCoord4i,
    __gls_decode_bin_swap_glTexCoord4iv,
    __gls_decode_bin_swap_glTexCoord4s,
    __gls_decode_bin_swap_glTexCoord4sv,
    __gls_decode_bin_swap_glVertex2d,
    __gls_decode_bin_swap_glVertex2dv,
    __gls_decode_bin_swap_glVertex2f,
    __gls_decode_bin_swap_glVertex2fv,
    __gls_decode_bin_swap_glVertex2i,
    __gls_decode_bin_swap_glVertex2iv,
    __gls_decode_bin_swap_glVertex2s,
    __gls_decode_bin_swap_glVertex2sv,
    __gls_decode_bin_swap_glVertex3d,
    __gls_decode_bin_swap_glVertex3dv,
    __gls_decode_bin_swap_glVertex3f,
    __gls_decode_bin_swap_glVertex3fv,
    __gls_decode_bin_swap_glVertex3i,
    __gls_decode_bin_swap_glVertex3iv,
    __gls_decode_bin_swap_glVertex3s,
    __gls_decode_bin_swap_glVertex3sv,
    __gls_decode_bin_swap_glVertex4d,
    __gls_decode_bin_swap_glVertex4dv,
    __gls_decode_bin_swap_glVertex4f,
    __gls_decode_bin_swap_glVertex4fv,
    __gls_decode_bin_swap_glVertex4i,
    __gls_decode_bin_swap_glVertex4iv,
    __gls_decode_bin_swap_glVertex4s,
    __gls_decode_bin_swap_glVertex4sv,
    __gls_decode_bin_swap_glClipPlane,
    __gls_decode_bin_swap_glColorMaterial,
    __gls_decode_bin_swap_glCullFace,
    __gls_decode_bin_swap_glFogf,
    __gls_decode_bin_swap_glFogfv,
    __gls_decode_bin_swap_glFogi,
    __gls_decode_bin_swap_glFogiv,
    __gls_decode_bin_swap_glFrontFace,
    __gls_decode_bin_swap_glHint,
    __gls_decode_bin_swap_glLightf,
    __gls_decode_bin_swap_glLightfv,
    __gls_decode_bin_swap_glLighti,
    __gls_decode_bin_swap_glLightiv,
    __gls_decode_bin_swap_glLightModelf,
    __gls_decode_bin_swap_glLightModelfv,
    __gls_decode_bin_swap_glLightModeli,
    __gls_decode_bin_swap_glLightModeliv,
    __gls_decode_bin_swap_glLineStipple,
    __gls_decode_bin_swap_glLineWidth,
    __gls_decode_bin_swap_glMaterialf,
    __gls_decode_bin_swap_glMaterialfv,
    __gls_decode_bin_swap_glMateriali,
    __gls_decode_bin_swap_glMaterialiv,
    __gls_decode_bin_swap_glPointSize,
    __gls_decode_bin_swap_glPolygonMode,
    __gls_decode_bin_swap_glPolygonStipple,
    __gls_decode_bin_swap_glScissor,
    __gls_decode_bin_swap_glShadeModel,
    __gls_decode_bin_swap_glTexParameterf,
    __gls_decode_bin_swap_glTexParameterfv,
    __gls_decode_bin_swap_glTexParameteri,
    __gls_decode_bin_swap_glTexParameteriv,
    __gls_decode_bin_swap_glTexImage1D,
    __gls_decode_bin_swap_glTexImage2D,
    __gls_decode_bin_swap_glTexEnvf,
    __gls_decode_bin_swap_glTexEnvfv,
    __gls_decode_bin_swap_glTexEnvi,
    __gls_decode_bin_swap_glTexEnviv,
    __gls_decode_bin_swap_glTexGend,
    __gls_decode_bin_swap_glTexGendv,
    __gls_decode_bin_swap_glTexGenf,
    __gls_decode_bin_swap_glTexGenfv,
    __gls_decode_bin_swap_glTexGeni,
    __gls_decode_bin_swap_glTexGeniv,
    __gls_decode_bin_swap_glFeedbackBuffer,
    __gls_decode_bin_swap_glSelectBuffer,
    __gls_decode_bin_swap_glRenderMode,
    __gls_decode_bin_swap_glInitNames,
    __gls_decode_bin_swap_glLoadName,
    __gls_decode_bin_swap_glPassThrough,
    __gls_decode_bin_swap_glPopName,
    __gls_decode_bin_swap_glPushName,
    __gls_decode_bin_swap_glDrawBuffer,
    __gls_decode_bin_swap_glClear,
    __gls_decode_bin_swap_glClearAccum,
    __gls_decode_bin_swap_glClearIndex,
    __gls_decode_bin_swap_glClearColor,
    __gls_decode_bin_swap_glClearStencil,
    __gls_decode_bin_swap_glClearDepth,
    __gls_decode_bin_swap_glStencilMask,
    __gls_decode_bin_swap_glColorMask,
    __gls_decode_bin_swap_glDepthMask,
    __gls_decode_bin_swap_glIndexMask,
    __gls_decode_bin_swap_glAccum,
    __gls_decode_bin_swap_glDisable,
    __gls_decode_bin_swap_glEnable,
    __gls_decode_bin_swap_glFinish,
    __gls_decode_bin_swap_glFlush,
    __gls_decode_bin_swap_glPopAttrib,
    __gls_decode_bin_swap_glPushAttrib,
    __gls_decode_bin_swap_glMap1d,
    __gls_decode_bin_swap_glMap1f,
    __gls_decode_bin_swap_glMap2d,
    __gls_decode_bin_swap_glMap2f,
    __gls_decode_bin_swap_glMapGrid1d,
    __gls_decode_bin_swap_glMapGrid1f,
    __gls_decode_bin_swap_glMapGrid2d,
    __gls_decode_bin_swap_glMapGrid2f,
    __gls_decode_bin_swap_glEvalCoord1d,
    __gls_decode_bin_swap_glEvalCoord1dv,
    __gls_decode_bin_swap_glEvalCoord1f,
    __gls_decode_bin_swap_glEvalCoord1fv,
    __gls_decode_bin_swap_glEvalCoord2d,
    __gls_decode_bin_swap_glEvalCoord2dv,
    __gls_decode_bin_swap_glEvalCoord2f,
    __gls_decode_bin_swap_glEvalCoord2fv,
    __gls_decode_bin_swap_glEvalMesh1,
    __gls_decode_bin_swap_glEvalPoint1,
    __gls_decode_bin_swap_glEvalMesh2,
    __gls_decode_bin_swap_glEvalPoint2,
    __gls_decode_bin_swap_glAlphaFunc,
    __gls_decode_bin_swap_glBlendFunc,
    __gls_decode_bin_swap_glLogicOp,
    __gls_decode_bin_swap_glStencilFunc,
    __gls_decode_bin_swap_glStencilOp,
    __gls_decode_bin_swap_glDepthFunc,
    __gls_decode_bin_swap_glPixelZoom,
    __gls_decode_bin_swap_glPixelTransferf,
    __gls_decode_bin_swap_glPixelTransferi,
    __gls_decode_bin_swap_glPixelStoref,
    __gls_decode_bin_swap_glPixelStorei,
    __gls_decode_bin_swap_glPixelMapfv,
    __gls_decode_bin_swap_glPixelMapuiv,
    __gls_decode_bin_swap_glPixelMapusv,
    __gls_decode_bin_swap_glReadBuffer,
    __gls_decode_bin_swap_glCopyPixels,
    __gls_decode_bin_swap_glReadPixels,
    __gls_decode_bin_swap_glDrawPixels,
    __gls_decode_bin_swap_glGetBooleanv,
    __gls_decode_bin_swap_glGetClipPlane,
    __gls_decode_bin_swap_glGetDoublev,
    __gls_decode_bin_swap_glGetError,
    __gls_decode_bin_swap_glGetFloatv,
    __gls_decode_bin_swap_glGetIntegerv,
    __gls_decode_bin_swap_glGetLightfv,
    __gls_decode_bin_swap_glGetLightiv,
    __gls_decode_bin_swap_glGetMapdv,
    __gls_decode_bin_swap_glGetMapfv,
    __gls_decode_bin_swap_glGetMapiv,
    __gls_decode_bin_swap_glGetMaterialfv,
    __gls_decode_bin_swap_glGetMaterialiv,
    __gls_decode_bin_swap_glGetPixelMapfv,
    __gls_decode_bin_swap_glGetPixelMapuiv,
    __gls_decode_bin_swap_glGetPixelMapusv,
    __gls_decode_bin_swap_glGetPolygonStipple,
    __gls_decode_bin_swap_glGetString,
    __gls_decode_bin_swap_glGetTexEnvfv,
    __gls_decode_bin_swap_glGetTexEnviv,
    __gls_decode_bin_swap_glGetTexGendv,
    __gls_decode_bin_swap_glGetTexGenfv,
    __gls_decode_bin_swap_glGetTexGeniv,
    __gls_decode_bin_swap_glGetTexImage,
    __gls_decode_bin_swap_glGetTexParameterfv,
    __gls_decode_bin_swap_glGetTexParameteriv,
    __gls_decode_bin_swap_glGetTexLevelParameterfv,
    __gls_decode_bin_swap_glGetTexLevelParameteriv,
    __gls_decode_bin_swap_glIsEnabled,
    __gls_decode_bin_swap_glIsList,
    __gls_decode_bin_swap_glDepthRange,
    __gls_decode_bin_swap_glFrustum,
    __gls_decode_bin_swap_glLoadIdentity,
    __gls_decode_bin_swap_glLoadMatrixf,
    __gls_decode_bin_swap_glLoadMatrixd,
    __gls_decode_bin_swap_glMatrixMode,
    __gls_decode_bin_swap_glMultMatrixf,
    __gls_decode_bin_swap_glMultMatrixd,
    __gls_decode_bin_swap_glOrtho,
    __gls_decode_bin_swap_glPopMatrix,
    __gls_decode_bin_swap_glPushMatrix,
    __gls_decode_bin_swap_glRotated,
    __gls_decode_bin_swap_glRotatef,
    __gls_decode_bin_swap_glScaled,
    __gls_decode_bin_swap_glScalef,
    __gls_decode_bin_swap_glTranslated,
    __gls_decode_bin_swap_glTranslatef,
    __gls_decode_bin_swap_glViewport,
    // DrewB - 1.1
    __gls_decode_bin_swap_glArrayElement,
    __gls_decode_bin_swap_glBindTexture,
    __gls_decode_bin_swap_glColorPointer,
    __gls_decode_bin_swap_glDisableClientState,
    __gls_decode_bin_swap_glDrawArrays,
    __gls_decode_bin_swap_glDrawElements,
    __gls_decode_bin_swap_glEdgeFlagPointer,
    __gls_decode_bin_swap_glEnableClientState,
    __gls_decode_bin_swap_glIndexPointer,
    __gls_decode_bin_swap_glIndexub,
    __gls_decode_bin_swap_glIndexubv,
    __gls_decode_bin_swap_glInterleavedArrays,
    __gls_decode_bin_swap_glNormalPointer,
    __gls_decode_bin_swap_glPolygonOffset,
    __gls_decode_bin_swap_glTexCoordPointer,
    __gls_decode_bin_swap_glVertexPointer,
    __gls_decode_bin_swap_glAreTexturesResident,
    __gls_decode_bin_swap_glCopyTexImage1D,
    __gls_decode_bin_swap_glCopyTexImage2D,
    __gls_decode_bin_swap_glCopyTexSubImage1D,
    __gls_decode_bin_swap_glCopyTexSubImage2D,
    __gls_decode_bin_swap_glDeleteTextures,
    __gls_decode_bin_swap_glGenTextures,
    __gls_decode_bin_swap_glGetPointerv,
    __gls_decode_bin_swap_glIsTexture,
    __gls_decode_bin_swap_glPrioritizeTextures,
    __gls_decode_bin_swap_glTexSubImage1D,
    __gls_decode_bin_swap_glTexSubImage2D,
    __gls_decode_bin_swap_glPushClientAttrib,
    __gls_decode_bin_swap_glPopClientAttrib,
    #if __GL_EXT_blend_color
        __gls_decode_bin_swap_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        __gls_decode_bin_swap_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        __gls_decode_bin_swap_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        __gls_decode_bin_swap_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        __gls_decode_bin_swap_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        __gls_decode_bin_swap_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        __gls_decode_bin_swap_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        __gls_decode_bin_swap_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_bin_swap_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_bin_swap_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        __gls_decode_bin_swap_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        __gls_decode_bin_swap_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_swap_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        __gls_decode_bin_swap_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_swap_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_bin_swap_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_bin_swap_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_bin_swap_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        __gls_decode_bin_swap_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_swap_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_bin_swap_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_bin_swap_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_bin_swap_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_swap_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        __gls_decode_bin_swap_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        __gls_decode_bin_swap_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        __gls_decode_bin_swap_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    GLS_NONE, // __GL_WIN_draw_range_elements
};

const __GLSdecodeTextFunc __glsDispatchDecode_text[
    __GLS_OPCODE_COUNT
] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_text_glsBeginGLS,
    __gls_decode_text_glsBlock,
    __gls_decode_text_glsCallStream,
    __gls_decode_text_glsEndGLS,
    __gls_decode_text_glsError,
    __gls_decode_text_glsGLRC,
    __gls_decode_text_glsGLRCLayer,
    __gls_decode_text_glsHeaderGLRCi,
    __gls_decode_text_glsHeaderLayerf,
    __gls_decode_text_glsHeaderLayeri,
    __gls_decode_text_glsHeaderf,
    __gls_decode_text_glsHeaderfv,
    __gls_decode_text_glsHeaderi,
    __gls_decode_text_glsHeaderiv,
    __gls_decode_text_glsHeaderubz,
    __gls_decode_text_glsRequireExtension,
    __gls_decode_text_glsUnsupportedCommand,
    __gls_decode_text_glsAppRef,
    __gls_decode_text_glsBeginObj,
    __gls_decode_text_glsCharubz,
    __gls_decode_text_glsComment,
    __gls_decode_text_glsDisplayMapfv,
    __gls_decode_text_glsEndObj,
    __gls_decode_text_glsNumb,
    __gls_decode_text_glsNumbv,
    __gls_decode_text_glsNumd,
    __gls_decode_text_glsNumdv,
    __gls_decode_text_glsNumf,
    __gls_decode_text_glsNumfv,
    __gls_decode_text_glsNumi,
    __gls_decode_text_glsNumiv,
    __gls_decode_text_glsNuml,
    __gls_decode_text_glsNumlv,
    __gls_decode_text_glsNums,
    __gls_decode_text_glsNumsv,
    __gls_decode_text_glsNumub,
    __gls_decode_text_glsNumubv,
    __gls_decode_text_glsNumui,
    __gls_decode_text_glsNumuiv,
    __gls_decode_text_glsNumul,
    __gls_decode_text_glsNumulv,
    __gls_decode_text_glsNumus,
    __gls_decode_text_glsNumusv,
    __gls_decode_text_glsPad,
    __gls_decode_text_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    __gls_decode_text_glNewList,
    __gls_decode_text_glEndList,
    __gls_decode_text_glCallList,
    __gls_decode_text_glCallLists,
    __gls_decode_text_glDeleteLists,
    __gls_decode_text_glGenLists,
    __gls_decode_text_glListBase,
    __gls_decode_text_glBegin,
    __gls_decode_text_glBitmap,
    __gls_decode_text_glColor3b,
    __gls_decode_text_glColor3bv,
    __gls_decode_text_glColor3d,
    __gls_decode_text_glColor3dv,
    __gls_decode_text_glColor3f,
    __gls_decode_text_glColor3fv,
    __gls_decode_text_glColor3i,
    __gls_decode_text_glColor3iv,
    __gls_decode_text_glColor3s,
    __gls_decode_text_glColor3sv,
    __gls_decode_text_glColor3ub,
    __gls_decode_text_glColor3ubv,
    __gls_decode_text_glColor3ui,
    __gls_decode_text_glColor3uiv,
    __gls_decode_text_glColor3us,
    __gls_decode_text_glColor3usv,
    __gls_decode_text_glColor4b,
    __gls_decode_text_glColor4bv,
    __gls_decode_text_glColor4d,
    __gls_decode_text_glColor4dv,
    __gls_decode_text_glColor4f,
    __gls_decode_text_glColor4fv,
    __gls_decode_text_glColor4i,
    __gls_decode_text_glColor4iv,
    __gls_decode_text_glColor4s,
    __gls_decode_text_glColor4sv,
    __gls_decode_text_glColor4ub,
    __gls_decode_text_glColor4ubv,
    __gls_decode_text_glColor4ui,
    __gls_decode_text_glColor4uiv,
    __gls_decode_text_glColor4us,
    __gls_decode_text_glColor4usv,
    __gls_decode_text_glEdgeFlag,
    __gls_decode_text_glEdgeFlagv,
    __gls_decode_text_glEnd,
    __gls_decode_text_glIndexd,
    __gls_decode_text_glIndexdv,
    __gls_decode_text_glIndexf,
    __gls_decode_text_glIndexfv,
    __gls_decode_text_glIndexi,
    __gls_decode_text_glIndexiv,
    __gls_decode_text_glIndexs,
    __gls_decode_text_glIndexsv,
    __gls_decode_text_glNormal3b,
    __gls_decode_text_glNormal3bv,
    __gls_decode_text_glNormal3d,
    __gls_decode_text_glNormal3dv,
    __gls_decode_text_glNormal3f,
    __gls_decode_text_glNormal3fv,
    __gls_decode_text_glNormal3i,
    __gls_decode_text_glNormal3iv,
    __gls_decode_text_glNormal3s,
    __gls_decode_text_glNormal3sv,
    __gls_decode_text_glRasterPos2d,
    __gls_decode_text_glRasterPos2dv,
    __gls_decode_text_glRasterPos2f,
    __gls_decode_text_glRasterPos2fv,
    __gls_decode_text_glRasterPos2i,
    __gls_decode_text_glRasterPos2iv,
    __gls_decode_text_glRasterPos2s,
    __gls_decode_text_glRasterPos2sv,
    __gls_decode_text_glRasterPos3d,
    __gls_decode_text_glRasterPos3dv,
    __gls_decode_text_glRasterPos3f,
    __gls_decode_text_glRasterPos3fv,
    __gls_decode_text_glRasterPos3i,
    __gls_decode_text_glRasterPos3iv,
    __gls_decode_text_glRasterPos3s,
    __gls_decode_text_glRasterPos3sv,
    __gls_decode_text_glRasterPos4d,
    __gls_decode_text_glRasterPos4dv,
    __gls_decode_text_glRasterPos4f,
    __gls_decode_text_glRasterPos4fv,
    __gls_decode_text_glRasterPos4i,
    __gls_decode_text_glRasterPos4iv,
    __gls_decode_text_glRasterPos4s,
    __gls_decode_text_glRasterPos4sv,
    __gls_decode_text_glRectd,
    __gls_decode_text_glRectdv,
    __gls_decode_text_glRectf,
    __gls_decode_text_glRectfv,
    __gls_decode_text_glRecti,
    __gls_decode_text_glRectiv,
    __gls_decode_text_glRects,
    __gls_decode_text_glRectsv,
    __gls_decode_text_glTexCoord1d,
    __gls_decode_text_glTexCoord1dv,
    __gls_decode_text_glTexCoord1f,
    __gls_decode_text_glTexCoord1fv,
    __gls_decode_text_glTexCoord1i,
    __gls_decode_text_glTexCoord1iv,
    __gls_decode_text_glTexCoord1s,
    __gls_decode_text_glTexCoord1sv,
    __gls_decode_text_glTexCoord2d,
    __gls_decode_text_glTexCoord2dv,
    __gls_decode_text_glTexCoord2f,
    __gls_decode_text_glTexCoord2fv,
    __gls_decode_text_glTexCoord2i,
    __gls_decode_text_glTexCoord2iv,
    __gls_decode_text_glTexCoord2s,
    __gls_decode_text_glTexCoord2sv,
    __gls_decode_text_glTexCoord3d,
    __gls_decode_text_glTexCoord3dv,
    __gls_decode_text_glTexCoord3f,
    __gls_decode_text_glTexCoord3fv,
    __gls_decode_text_glTexCoord3i,
    __gls_decode_text_glTexCoord3iv,
    __gls_decode_text_glTexCoord3s,
    __gls_decode_text_glTexCoord3sv,
    __gls_decode_text_glTexCoord4d,
    __gls_decode_text_glTexCoord4dv,
    __gls_decode_text_glTexCoord4f,
    __gls_decode_text_glTexCoord4fv,
    __gls_decode_text_glTexCoord4i,
    __gls_decode_text_glTexCoord4iv,
    __gls_decode_text_glTexCoord4s,
    __gls_decode_text_glTexCoord4sv,
    __gls_decode_text_glVertex2d,
    __gls_decode_text_glVertex2dv,
    __gls_decode_text_glVertex2f,
    __gls_decode_text_glVertex2fv,
    __gls_decode_text_glVertex2i,
    __gls_decode_text_glVertex2iv,
    __gls_decode_text_glVertex2s,
    __gls_decode_text_glVertex2sv,
    __gls_decode_text_glVertex3d,
    __gls_decode_text_glVertex3dv,
    __gls_decode_text_glVertex3f,
    __gls_decode_text_glVertex3fv,
    __gls_decode_text_glVertex3i,
    __gls_decode_text_glVertex3iv,
    __gls_decode_text_glVertex3s,
    __gls_decode_text_glVertex3sv,
    __gls_decode_text_glVertex4d,
    __gls_decode_text_glVertex4dv,
    __gls_decode_text_glVertex4f,
    __gls_decode_text_glVertex4fv,
    __gls_decode_text_glVertex4i,
    __gls_decode_text_glVertex4iv,
    __gls_decode_text_glVertex4s,
    __gls_decode_text_glVertex4sv,
    __gls_decode_text_glClipPlane,
    __gls_decode_text_glColorMaterial,
    __gls_decode_text_glCullFace,
    __gls_decode_text_glFogf,
    __gls_decode_text_glFogfv,
    __gls_decode_text_glFogi,
    __gls_decode_text_glFogiv,
    __gls_decode_text_glFrontFace,
    __gls_decode_text_glHint,
    __gls_decode_text_glLightf,
    __gls_decode_text_glLightfv,
    __gls_decode_text_glLighti,
    __gls_decode_text_glLightiv,
    __gls_decode_text_glLightModelf,
    __gls_decode_text_glLightModelfv,
    __gls_decode_text_glLightModeli,
    __gls_decode_text_glLightModeliv,
    __gls_decode_text_glLineStipple,
    __gls_decode_text_glLineWidth,
    __gls_decode_text_glMaterialf,
    __gls_decode_text_glMaterialfv,
    __gls_decode_text_glMateriali,
    __gls_decode_text_glMaterialiv,
    __gls_decode_text_glPointSize,
    __gls_decode_text_glPolygonMode,
    __gls_decode_text_glPolygonStipple,
    __gls_decode_text_glScissor,
    __gls_decode_text_glShadeModel,
    __gls_decode_text_glTexParameterf,
    __gls_decode_text_glTexParameterfv,
    __gls_decode_text_glTexParameteri,
    __gls_decode_text_glTexParameteriv,
    __gls_decode_text_glTexImage1D,
    __gls_decode_text_glTexImage2D,
    __gls_decode_text_glTexEnvf,
    __gls_decode_text_glTexEnvfv,
    __gls_decode_text_glTexEnvi,
    __gls_decode_text_glTexEnviv,
    __gls_decode_text_glTexGend,
    __gls_decode_text_glTexGendv,
    __gls_decode_text_glTexGenf,
    __gls_decode_text_glTexGenfv,
    __gls_decode_text_glTexGeni,
    __gls_decode_text_glTexGeniv,
    __gls_decode_text_glFeedbackBuffer,
    __gls_decode_text_glSelectBuffer,
    __gls_decode_text_glRenderMode,
    __gls_decode_text_glInitNames,
    __gls_decode_text_glLoadName,
    __gls_decode_text_glPassThrough,
    __gls_decode_text_glPopName,
    __gls_decode_text_glPushName,
    __gls_decode_text_glDrawBuffer,
    __gls_decode_text_glClear,
    __gls_decode_text_glClearAccum,
    __gls_decode_text_glClearIndex,
    __gls_decode_text_glClearColor,
    __gls_decode_text_glClearStencil,
    __gls_decode_text_glClearDepth,
    __gls_decode_text_glStencilMask,
    __gls_decode_text_glColorMask,
    __gls_decode_text_glDepthMask,
    __gls_decode_text_glIndexMask,
    __gls_decode_text_glAccum,
    __gls_decode_text_glDisable,
    __gls_decode_text_glEnable,
    __gls_decode_text_glFinish,
    __gls_decode_text_glFlush,
    __gls_decode_text_glPopAttrib,
    __gls_decode_text_glPushAttrib,
    __gls_decode_text_glMap1d,
    __gls_decode_text_glMap1f,
    __gls_decode_text_glMap2d,
    __gls_decode_text_glMap2f,
    __gls_decode_text_glMapGrid1d,
    __gls_decode_text_glMapGrid1f,
    __gls_decode_text_glMapGrid2d,
    __gls_decode_text_glMapGrid2f,
    __gls_decode_text_glEvalCoord1d,
    __gls_decode_text_glEvalCoord1dv,
    __gls_decode_text_glEvalCoord1f,
    __gls_decode_text_glEvalCoord1fv,
    __gls_decode_text_glEvalCoord2d,
    __gls_decode_text_glEvalCoord2dv,
    __gls_decode_text_glEvalCoord2f,
    __gls_decode_text_glEvalCoord2fv,
    __gls_decode_text_glEvalMesh1,
    __gls_decode_text_glEvalPoint1,
    __gls_decode_text_glEvalMesh2,
    __gls_decode_text_glEvalPoint2,
    __gls_decode_text_glAlphaFunc,
    __gls_decode_text_glBlendFunc,
    __gls_decode_text_glLogicOp,
    __gls_decode_text_glStencilFunc,
    __gls_decode_text_glStencilOp,
    __gls_decode_text_glDepthFunc,
    __gls_decode_text_glPixelZoom,
    __gls_decode_text_glPixelTransferf,
    __gls_decode_text_glPixelTransferi,
    __gls_decode_text_glPixelStoref,
    __gls_decode_text_glPixelStorei,
    __gls_decode_text_glPixelMapfv,
    __gls_decode_text_glPixelMapuiv,
    __gls_decode_text_glPixelMapusv,
    __gls_decode_text_glReadBuffer,
    __gls_decode_text_glCopyPixels,
    __gls_decode_text_glReadPixels,
    __gls_decode_text_glDrawPixels,
    __gls_decode_text_glGetBooleanv,
    __gls_decode_text_glGetClipPlane,
    __gls_decode_text_glGetDoublev,
    __gls_decode_text_glGetError,
    __gls_decode_text_glGetFloatv,
    __gls_decode_text_glGetIntegerv,
    __gls_decode_text_glGetLightfv,
    __gls_decode_text_glGetLightiv,
    __gls_decode_text_glGetMapdv,
    __gls_decode_text_glGetMapfv,
    __gls_decode_text_glGetMapiv,
    __gls_decode_text_glGetMaterialfv,
    __gls_decode_text_glGetMaterialiv,
    __gls_decode_text_glGetPixelMapfv,
    __gls_decode_text_glGetPixelMapuiv,
    __gls_decode_text_glGetPixelMapusv,
    __gls_decode_text_glGetPolygonStipple,
    __gls_decode_text_glGetString,
    __gls_decode_text_glGetTexEnvfv,
    __gls_decode_text_glGetTexEnviv,
    __gls_decode_text_glGetTexGendv,
    __gls_decode_text_glGetTexGenfv,
    __gls_decode_text_glGetTexGeniv,
    __gls_decode_text_glGetTexImage,
    __gls_decode_text_glGetTexParameterfv,
    __gls_decode_text_glGetTexParameteriv,
    __gls_decode_text_glGetTexLevelParameterfv,
    __gls_decode_text_glGetTexLevelParameteriv,
    __gls_decode_text_glIsEnabled,
    __gls_decode_text_glIsList,
    __gls_decode_text_glDepthRange,
    __gls_decode_text_glFrustum,
    __gls_decode_text_glLoadIdentity,
    __gls_decode_text_glLoadMatrixf,
    __gls_decode_text_glLoadMatrixd,
    __gls_decode_text_glMatrixMode,
    __gls_decode_text_glMultMatrixf,
    __gls_decode_text_glMultMatrixd,
    __gls_decode_text_glOrtho,
    __gls_decode_text_glPopMatrix,
    __gls_decode_text_glPushMatrix,
    __gls_decode_text_glRotated,
    __gls_decode_text_glRotatef,
    __gls_decode_text_glScaled,
    __gls_decode_text_glScalef,
    __gls_decode_text_glTranslated,
    __gls_decode_text_glTranslatef,
    __gls_decode_text_glViewport,
    // DrewB - 1.1
    __gls_decode_text_glArrayElement,
    __gls_decode_text_glBindTexture,
    __gls_decode_text_glColorPointer,
    __gls_decode_text_glDisableClientState,
    __gls_decode_text_glDrawArrays,
    __gls_decode_text_glDrawElements,
    __gls_decode_text_glEdgeFlagPointer,
    __gls_decode_text_glEnableClientState,
    __gls_decode_text_glIndexPointer,
    __gls_decode_text_glIndexub,
    __gls_decode_text_glIndexubv,
    __gls_decode_text_glInterleavedArrays,
    __gls_decode_text_glNormalPointer,
    __gls_decode_text_glPolygonOffset,
    __gls_decode_text_glTexCoordPointer,
    __gls_decode_text_glVertexPointer,
    __gls_decode_text_glAreTexturesResident,
    __gls_decode_text_glCopyTexImage1D,
    __gls_decode_text_glCopyTexImage2D,
    __gls_decode_text_glCopyTexSubImage1D,
    __gls_decode_text_glCopyTexSubImage2D,
    __gls_decode_text_glDeleteTextures,
    __gls_decode_text_glGenTextures,
    __gls_decode_text_glGetPointerv,
    __gls_decode_text_glIsTexture,
    __gls_decode_text_glPrioritizeTextures,
    __gls_decode_text_glTexSubImage1D,
    __gls_decode_text_glTexSubImage2D,
    __gls_decode_text_glPushClientAttrib,
    __gls_decode_text_glPopClientAttrib,
    #if __GL_EXT_blend_color
        __gls_decode_text_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        __gls_decode_text_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        __gls_decode_text_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        __gls_decode_text_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        __gls_decode_text_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        __gls_decode_text_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        __gls_decode_text_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        __gls_decode_text_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        __gls_decode_text_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        __gls_decode_text_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        __gls_decode_text_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        __gls_decode_text_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        __gls_decode_text_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        __gls_decode_text_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_text_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        __gls_decode_text_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        __gls_decode_text_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        __gls_decode_text_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        __gls_decode_text_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        __gls_decode_text_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_text_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        __gls_decode_text_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        __gls_decode_text_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        __gls_decode_text_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        __gls_decode_text_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        __gls_decode_text_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        __gls_decode_text_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        __gls_decode_text_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    GLS_NONE, // __GL_WIN_draw_range_elements
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_dspexe.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

extern void __gls_exec_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor);
extern void __gls_exec_glsBlock(GLSenum inBlockType);
extern GLSenum __gls_exec_glsCallStream(const GLubyte *inName);
extern void __gls_exec_glsEndGLS(void);
extern void __gls_exec_glsError(GLSopcode inOpcode, GLSenum inError);
extern void __gls_exec_glsGLRC(GLuint inGLRC);
extern void __gls_exec_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void __gls_exec_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void __gls_exec_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void __gls_exec_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void __gls_exec_glsHeaderf(GLSenum inAttrib, GLfloat inVal);
extern void __gls_exec_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec);
extern void __gls_exec_glsHeaderi(GLSenum inAttrib, GLint inVal);
extern void __gls_exec_glsHeaderiv(GLSenum inAttrib, const GLint *inVec);
extern void __gls_exec_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString);
extern void __gls_exec_glsRequireExtension(const GLubyte *inExtension);
extern void __gls_exec_glsUnsupportedCommand(void);
extern void __gls_exec_glsAppRef(GLulong inAddress, GLuint inCount);
extern void __gls_exec_glsBeginObj(const GLubyte *inTag);
extern void __gls_exec_glsCharubz(const GLubyte *inTag, const GLubyte *inString);
extern void __gls_exec_glsComment(const GLubyte *inComment);
extern void __gls_exec_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void __gls_exec_glsEndObj(void);
extern void __gls_exec_glsNumb(const GLubyte *inTag, GLbyte inVal);
extern void __gls_exec_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void __gls_exec_glsNumd(const GLubyte *inTag, GLdouble inVal);
extern void __gls_exec_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void __gls_exec_glsNumf(const GLubyte *inTag, GLfloat inVal);
extern void __gls_exec_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void __gls_exec_glsNumi(const GLubyte *inTag, GLint inVal);
extern void __gls_exec_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void __gls_exec_glsNuml(const GLubyte *inTag, GLlong inVal);
extern void __gls_exec_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void __gls_exec_glsNums(const GLubyte *inTag, GLshort inVal);
extern void __gls_exec_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void __gls_exec_glsNumub(const GLubyte *inTag, GLubyte inVal);
extern void __gls_exec_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void __gls_exec_glsNumui(const GLubyte *inTag, GLuint inVal);
extern void __gls_exec_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void __gls_exec_glsNumul(const GLubyte *inTag, GLulong inVal);
extern void __gls_exec_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void __gls_exec_glsNumus(const GLubyte *inTag, GLushort inVal);
extern void __gls_exec_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void __gls_exec_glsPad(void);
extern void __gls_exec_glsSwapBuffers(GLuint inLayer);

#if __GLS_PLATFORM_WIN32
// DrewB - These are filled in by platform.c
#define glColorSubTableEXT NULL
#define glColorTableEXT NULL
#define glGetColorTableEXT NULL
#define glGetColorTableParameterivEXT NULL
#define glGetColorTableParameterfvEXT NULL
#endif

GLSfunc __glsDispatchExec[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_exec_glsBeginGLS,
    (GLSfunc)__gls_exec_glsBlock,
    (GLSfunc)__gls_exec_glsCallStream,
    (GLSfunc)__gls_exec_glsEndGLS,
    (GLSfunc)__gls_exec_glsError,
    (GLSfunc)__gls_exec_glsGLRC,
    (GLSfunc)__gls_exec_glsGLRCLayer,
    (GLSfunc)__gls_exec_glsHeaderGLRCi,
    (GLSfunc)__gls_exec_glsHeaderLayerf,
    (GLSfunc)__gls_exec_glsHeaderLayeri,
    (GLSfunc)__gls_exec_glsHeaderf,
    (GLSfunc)__gls_exec_glsHeaderfv,
    (GLSfunc)__gls_exec_glsHeaderi,
    (GLSfunc)__gls_exec_glsHeaderiv,
    (GLSfunc)__gls_exec_glsHeaderubz,
    (GLSfunc)__gls_exec_glsRequireExtension,
    (GLSfunc)__gls_exec_glsUnsupportedCommand,
    (GLSfunc)__gls_exec_glsAppRef,
    (GLSfunc)__gls_exec_glsBeginObj,
    (GLSfunc)__gls_exec_glsCharubz,
    (GLSfunc)__gls_exec_glsComment,
    (GLSfunc)__gls_exec_glsDisplayMapfv,
    (GLSfunc)__gls_exec_glsEndObj,
    (GLSfunc)__gls_exec_glsNumb,
    (GLSfunc)__gls_exec_glsNumbv,
    (GLSfunc)__gls_exec_glsNumd,
    (GLSfunc)__gls_exec_glsNumdv,
    (GLSfunc)__gls_exec_glsNumf,
    (GLSfunc)__gls_exec_glsNumfv,
    (GLSfunc)__gls_exec_glsNumi,
    (GLSfunc)__gls_exec_glsNumiv,
    (GLSfunc)__gls_exec_glsNuml,
    (GLSfunc)__gls_exec_glsNumlv,
    (GLSfunc)__gls_exec_glsNums,
    (GLSfunc)__gls_exec_glsNumsv,
    (GLSfunc)__gls_exec_glsNumub,
    (GLSfunc)__gls_exec_glsNumubv,
    (GLSfunc)__gls_exec_glsNumui,
    (GLSfunc)__gls_exec_glsNumuiv,
    (GLSfunc)__gls_exec_glsNumul,
    (GLSfunc)__gls_exec_glsNumulv,
    (GLSfunc)__gls_exec_glsNumus,
    (GLSfunc)__gls_exec_glsNumusv,
    (GLSfunc)__gls_exec_glsPad,
    (GLSfunc)__gls_exec_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)glNewList,
    (GLSfunc)glEndList,
    (GLSfunc)glCallList,
    (GLSfunc)glCallLists,
    (GLSfunc)glDeleteLists,
    (GLSfunc)glGenLists,
    (GLSfunc)glListBase,
    (GLSfunc)glBegin,
    (GLSfunc)glBitmap,
    (GLSfunc)glColor3b,
    (GLSfunc)glColor3bv,
    (GLSfunc)glColor3d,
    (GLSfunc)glColor3dv,
    (GLSfunc)glColor3f,
    (GLSfunc)glColor3fv,
    (GLSfunc)glColor3i,
    (GLSfunc)glColor3iv,
    (GLSfunc)glColor3s,
    (GLSfunc)glColor3sv,
    (GLSfunc)glColor3ub,
    (GLSfunc)glColor3ubv,
    (GLSfunc)glColor3ui,
    (GLSfunc)glColor3uiv,
    (GLSfunc)glColor3us,
    (GLSfunc)glColor3usv,
    (GLSfunc)glColor4b,
    (GLSfunc)glColor4bv,
    (GLSfunc)glColor4d,
    (GLSfunc)glColor4dv,
    (GLSfunc)glColor4f,
    (GLSfunc)glColor4fv,
    (GLSfunc)glColor4i,
    (GLSfunc)glColor4iv,
    (GLSfunc)glColor4s,
    (GLSfunc)glColor4sv,
    (GLSfunc)glColor4ub,
    (GLSfunc)glColor4ubv,
    (GLSfunc)glColor4ui,
    (GLSfunc)glColor4uiv,
    (GLSfunc)glColor4us,
    (GLSfunc)glColor4usv,
    (GLSfunc)glEdgeFlag,
    (GLSfunc)glEdgeFlagv,
    (GLSfunc)glEnd,
    (GLSfunc)glIndexd,
    (GLSfunc)glIndexdv,
    (GLSfunc)glIndexf,
    (GLSfunc)glIndexfv,
    (GLSfunc)glIndexi,
    (GLSfunc)glIndexiv,
    (GLSfunc)glIndexs,
    (GLSfunc)glIndexsv,
    (GLSfunc)glNormal3b,
    (GLSfunc)glNormal3bv,
    (GLSfunc)glNormal3d,
    (GLSfunc)glNormal3dv,
    (GLSfunc)glNormal3f,
    (GLSfunc)glNormal3fv,
    (GLSfunc)glNormal3i,
    (GLSfunc)glNormal3iv,
    (GLSfunc)glNormal3s,
    (GLSfunc)glNormal3sv,
    (GLSfunc)glRasterPos2d,
    (GLSfunc)glRasterPos2dv,
    (GLSfunc)glRasterPos2f,
    (GLSfunc)glRasterPos2fv,
    (GLSfunc)glRasterPos2i,
    (GLSfunc)glRasterPos2iv,
    (GLSfunc)glRasterPos2s,
    (GLSfunc)glRasterPos2sv,
    (GLSfunc)glRasterPos3d,
    (GLSfunc)glRasterPos3dv,
    (GLSfunc)glRasterPos3f,
    (GLSfunc)glRasterPos3fv,
    (GLSfunc)glRasterPos3i,
    (GLSfunc)glRasterPos3iv,
    (GLSfunc)glRasterPos3s,
    (GLSfunc)glRasterPos3sv,
    (GLSfunc)glRasterPos4d,
    (GLSfunc)glRasterPos4dv,
    (GLSfunc)glRasterPos4f,
    (GLSfunc)glRasterPos4fv,
    (GLSfunc)glRasterPos4i,
    (GLSfunc)glRasterPos4iv,
    (GLSfunc)glRasterPos4s,
    (GLSfunc)glRasterPos4sv,
    (GLSfunc)glRectd,
    (GLSfunc)glRectdv,
    (GLSfunc)glRectf,
    (GLSfunc)glRectfv,
    (GLSfunc)glRecti,
    (GLSfunc)glRectiv,
    (GLSfunc)glRects,
    (GLSfunc)glRectsv,
    (GLSfunc)glTexCoord1d,
    (GLSfunc)glTexCoord1dv,
    (GLSfunc)glTexCoord1f,
    (GLSfunc)glTexCoord1fv,
    (GLSfunc)glTexCoord1i,
    (GLSfunc)glTexCoord1iv,
    (GLSfunc)glTexCoord1s,
    (GLSfunc)glTexCoord1sv,
    (GLSfunc)glTexCoord2d,
    (GLSfunc)glTexCoord2dv,
    (GLSfunc)glTexCoord2f,
    (GLSfunc)glTexCoord2fv,
    (GLSfunc)glTexCoord2i,
    (GLSfunc)glTexCoord2iv,
    (GLSfunc)glTexCoord2s,
    (GLSfunc)glTexCoord2sv,
    (GLSfunc)glTexCoord3d,
    (GLSfunc)glTexCoord3dv,
    (GLSfunc)glTexCoord3f,
    (GLSfunc)glTexCoord3fv,
    (GLSfunc)glTexCoord3i,
    (GLSfunc)glTexCoord3iv,
    (GLSfunc)glTexCoord3s,
    (GLSfunc)glTexCoord3sv,
    (GLSfunc)glTexCoord4d,
    (GLSfunc)glTexCoord4dv,
    (GLSfunc)glTexCoord4f,
    (GLSfunc)glTexCoord4fv,
    (GLSfunc)glTexCoord4i,
    (GLSfunc)glTexCoord4iv,
    (GLSfunc)glTexCoord4s,
    (GLSfunc)glTexCoord4sv,
    (GLSfunc)glVertex2d,
    (GLSfunc)glVertex2dv,
    (GLSfunc)glVertex2f,
    (GLSfunc)glVertex2fv,
    (GLSfunc)glVertex2i,
    (GLSfunc)glVertex2iv,
    (GLSfunc)glVertex2s,
    (GLSfunc)glVertex2sv,
    (GLSfunc)glVertex3d,
    (GLSfunc)glVertex3dv,
    (GLSfunc)glVertex3f,
    (GLSfunc)glVertex3fv,
    (GLSfunc)glVertex3i,
    (GLSfunc)glVertex3iv,
    (GLSfunc)glVertex3s,
    (GLSfunc)glVertex3sv,
    (GLSfunc)glVertex4d,
    (GLSfunc)glVertex4dv,
    (GLSfunc)glVertex4f,
    (GLSfunc)glVertex4fv,
    (GLSfunc)glVertex4i,
    (GLSfunc)glVertex4iv,
    (GLSfunc)glVertex4s,
    (GLSfunc)glVertex4sv,
    (GLSfunc)glClipPlane,
    (GLSfunc)glColorMaterial,
    (GLSfunc)glCullFace,
    (GLSfunc)glFogf,
    (GLSfunc)glFogfv,
    (GLSfunc)glFogi,
    (GLSfunc)glFogiv,
    (GLSfunc)glFrontFace,
    (GLSfunc)glHint,
    (GLSfunc)glLightf,
    (GLSfunc)glLightfv,
    (GLSfunc)glLighti,
    (GLSfunc)glLightiv,
    (GLSfunc)glLightModelf,
    (GLSfunc)glLightModelfv,
    (GLSfunc)glLightModeli,
    (GLSfunc)glLightModeliv,
    (GLSfunc)glLineStipple,
    (GLSfunc)glLineWidth,
    (GLSfunc)glMaterialf,
    (GLSfunc)glMaterialfv,
    (GLSfunc)glMateriali,
    (GLSfunc)glMaterialiv,
    (GLSfunc)glPointSize,
    (GLSfunc)glPolygonMode,
    (GLSfunc)glPolygonStipple,
    (GLSfunc)glScissor,
    (GLSfunc)glShadeModel,
    (GLSfunc)glTexParameterf,
    (GLSfunc)glTexParameterfv,
    (GLSfunc)glTexParameteri,
    (GLSfunc)glTexParameteriv,
    (GLSfunc)glTexImage1D,
    (GLSfunc)glTexImage2D,
    (GLSfunc)glTexEnvf,
    (GLSfunc)glTexEnvfv,
    (GLSfunc)glTexEnvi,
    (GLSfunc)glTexEnviv,
    (GLSfunc)glTexGend,
    (GLSfunc)glTexGendv,
    (GLSfunc)glTexGenf,
    (GLSfunc)glTexGenfv,
    (GLSfunc)glTexGeni,
    (GLSfunc)glTexGeniv,
    (GLSfunc)glFeedbackBuffer,
    (GLSfunc)glSelectBuffer,
    (GLSfunc)glRenderMode,
    (GLSfunc)glInitNames,
    (GLSfunc)glLoadName,
    (GLSfunc)glPassThrough,
    (GLSfunc)glPopName,
    (GLSfunc)glPushName,
    (GLSfunc)glDrawBuffer,
    (GLSfunc)glClear,
    (GLSfunc)glClearAccum,
    (GLSfunc)glClearIndex,
    (GLSfunc)glClearColor,
    (GLSfunc)glClearStencil,
    (GLSfunc)glClearDepth,
    (GLSfunc)glStencilMask,
    (GLSfunc)glColorMask,
    (GLSfunc)glDepthMask,
    (GLSfunc)glIndexMask,
    (GLSfunc)glAccum,
    (GLSfunc)glDisable,
    (GLSfunc)glEnable,
    (GLSfunc)glFinish,
    (GLSfunc)glFlush,
    (GLSfunc)glPopAttrib,
    (GLSfunc)glPushAttrib,
    (GLSfunc)glMap1d,
    (GLSfunc)glMap1f,
    (GLSfunc)glMap2d,
    (GLSfunc)glMap2f,
    (GLSfunc)glMapGrid1d,
    (GLSfunc)glMapGrid1f,
    (GLSfunc)glMapGrid2d,
    (GLSfunc)glMapGrid2f,
    (GLSfunc)glEvalCoord1d,
    (GLSfunc)glEvalCoord1dv,
    (GLSfunc)glEvalCoord1f,
    (GLSfunc)glEvalCoord1fv,
    (GLSfunc)glEvalCoord2d,
    (GLSfunc)glEvalCoord2dv,
    (GLSfunc)glEvalCoord2f,
    (GLSfunc)glEvalCoord2fv,
    (GLSfunc)glEvalMesh1,
    (GLSfunc)glEvalPoint1,
    (GLSfunc)glEvalMesh2,
    (GLSfunc)glEvalPoint2,
    (GLSfunc)glAlphaFunc,
    (GLSfunc)glBlendFunc,
    (GLSfunc)glLogicOp,
    (GLSfunc)glStencilFunc,
    (GLSfunc)glStencilOp,
    (GLSfunc)glDepthFunc,
    (GLSfunc)glPixelZoom,
    (GLSfunc)glPixelTransferf,
    (GLSfunc)glPixelTransferi,
    (GLSfunc)glPixelStoref,
    (GLSfunc)glPixelStorei,
    (GLSfunc)glPixelMapfv,
    (GLSfunc)glPixelMapuiv,
    (GLSfunc)glPixelMapusv,
    (GLSfunc)glReadBuffer,
    (GLSfunc)glCopyPixels,
    (GLSfunc)glReadPixels,
    (GLSfunc)glDrawPixels,
    (GLSfunc)glGetBooleanv,
    (GLSfunc)glGetClipPlane,
    (GLSfunc)glGetDoublev,
    (GLSfunc)glGetError,
    (GLSfunc)glGetFloatv,
    (GLSfunc)glGetIntegerv,
    (GLSfunc)glGetLightfv,
    (GLSfunc)glGetLightiv,
    (GLSfunc)glGetMapdv,
    (GLSfunc)glGetMapfv,
    (GLSfunc)glGetMapiv,
    (GLSfunc)glGetMaterialfv,
    (GLSfunc)glGetMaterialiv,
    (GLSfunc)glGetPixelMapfv,
    (GLSfunc)glGetPixelMapuiv,
    (GLSfunc)glGetPixelMapusv,
    (GLSfunc)glGetPolygonStipple,
    (GLSfunc)glGetString,
    (GLSfunc)glGetTexEnvfv,
    (GLSfunc)glGetTexEnviv,
    (GLSfunc)glGetTexGendv,
    (GLSfunc)glGetTexGenfv,
    (GLSfunc)glGetTexGeniv,
    (GLSfunc)glGetTexImage,
    (GLSfunc)glGetTexParameterfv,
    (GLSfunc)glGetTexParameteriv,
    (GLSfunc)glGetTexLevelParameterfv,
    (GLSfunc)glGetTexLevelParameteriv,
    (GLSfunc)glIsEnabled,
    (GLSfunc)glIsList,
    (GLSfunc)glDepthRange,
    (GLSfunc)glFrustum,
    (GLSfunc)glLoadIdentity,
    (GLSfunc)glLoadMatrixf,
    (GLSfunc)glLoadMatrixd,
    (GLSfunc)glMatrixMode,
    (GLSfunc)glMultMatrixf,
    (GLSfunc)glMultMatrixd,
    (GLSfunc)glOrtho,
    (GLSfunc)glPopMatrix,
    (GLSfunc)glPushMatrix,
    (GLSfunc)glRotated,
    (GLSfunc)glRotatef,
    (GLSfunc)glScaled,
    (GLSfunc)glScalef,
    (GLSfunc)glTranslated,
    (GLSfunc)glTranslatef,
    (GLSfunc)glViewport,
    // DrewB - 1.1
    (GLSfunc)glArrayElement,
    (GLSfunc)glBindTexture,
    (GLSfunc)glColorPointer,
    (GLSfunc)glDisableClientState,
    (GLSfunc)glDrawArrays,
    (GLSfunc)glDrawElements,
    (GLSfunc)glEdgeFlagPointer,
    (GLSfunc)glEnableClientState,
    (GLSfunc)glIndexPointer,
    (GLSfunc)glIndexub,
    (GLSfunc)glIndexubv,
    (GLSfunc)glInterleavedArrays,
    (GLSfunc)glNormalPointer,
    (GLSfunc)glPolygonOffset,
    (GLSfunc)glTexCoordPointer,
    (GLSfunc)glVertexPointer,
    (GLSfunc)glAreTexturesResident,
    (GLSfunc)glCopyTexImage1D,
    (GLSfunc)glCopyTexImage2D,
    (GLSfunc)glCopyTexSubImage1D,
    (GLSfunc)glCopyTexSubImage2D,
    (GLSfunc)glDeleteTextures,
    (GLSfunc)glGenTextures,
    (GLSfunc)glGetPointerv,
    (GLSfunc)glIsTexture,
    (GLSfunc)glPrioritizeTextures,
    (GLSfunc)glTexSubImage1D,
    (GLSfunc)glTexSubImage2D,
    (GLSfunc)glPushClientAttrib,
    (GLSfunc)glPopClientAttrib,
    #if __GL_EXT_blend_color
        (GLSfunc)glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        (GLSfunc)glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        (GLSfunc)glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        (GLSfunc)glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        (GLSfunc)glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        (GLSfunc)glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        (GLSfunc)glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        (GLSfunc)glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        (GLSfunc)glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        (GLSfunc)glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture && __GL_EXT_texture3D
        (GLSfunc)glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        (GLSfunc)glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        (GLSfunc)glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        (GLSfunc)glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture && __GL_EXT_texture3D
        (GLSfunc)glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        (GLSfunc)glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        (GLSfunc)glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        (GLSfunc)glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        (GLSfunc)glColorSubTableEXT,
    #else
        GLS_NONE,
        GLS_NONE,
    #endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_dspcap.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

extern void __gls_capture_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor);
extern void __gls_capture_glsBlock(GLSenum inBlockType);
extern GLSenum __gls_capture_glsCallStream(const GLubyte *inName);
extern void __gls_capture_glsEndGLS(void);
extern void __gls_capture_glsError(GLSopcode inOpcode, GLSenum inError);
extern void __gls_capture_glsGLRC(GLuint inGLRC);
extern void __gls_capture_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer);
extern void __gls_capture_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal);
extern void __gls_capture_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal);
extern void __gls_capture_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal);
extern void __gls_capture_glsHeaderf(GLSenum inAttrib, GLfloat inVal);
extern void __gls_capture_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec);
extern void __gls_capture_glsHeaderi(GLSenum inAttrib, GLint inVal);
extern void __gls_capture_glsHeaderiv(GLSenum inAttrib, const GLint *inVec);
extern void __gls_capture_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString);
extern void __gls_capture_glsRequireExtension(const GLubyte *inExtension);
extern void __gls_capture_glsUnsupportedCommand(void);
extern void __gls_capture_glsAppRef(GLulong inAddress, GLuint inCount);
extern void __gls_capture_glsBeginObj(const GLubyte *inTag);
extern void __gls_capture_glsCharubz(const GLubyte *inTag, const GLubyte *inString);
extern void __gls_capture_glsComment(const GLubyte *inComment);
extern void __gls_capture_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec);
extern void __gls_capture_glsEndObj(void);
extern void __gls_capture_glsNumb(const GLubyte *inTag, GLbyte inVal);
extern void __gls_capture_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec);
extern void __gls_capture_glsNumd(const GLubyte *inTag, GLdouble inVal);
extern void __gls_capture_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec);
extern void __gls_capture_glsNumf(const GLubyte *inTag, GLfloat inVal);
extern void __gls_capture_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec);
extern void __gls_capture_glsNumi(const GLubyte *inTag, GLint inVal);
extern void __gls_capture_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec);
extern void __gls_capture_glsNuml(const GLubyte *inTag, GLlong inVal);
extern void __gls_capture_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec);
extern void __gls_capture_glsNums(const GLubyte *inTag, GLshort inVal);
extern void __gls_capture_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec);
extern void __gls_capture_glsNumub(const GLubyte *inTag, GLubyte inVal);
extern void __gls_capture_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec);
extern void __gls_capture_glsNumui(const GLubyte *inTag, GLuint inVal);
extern void __gls_capture_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec);
extern void __gls_capture_glsNumul(const GLubyte *inTag, GLulong inVal);
extern void __gls_capture_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec);
extern void __gls_capture_glsNumus(const GLubyte *inTag, GLushort inVal);
extern void __gls_capture_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec);
extern void __gls_capture_glsPad(void);
extern void __gls_capture_glsSwapBuffers(GLuint inLayer);
extern void __gls_capture_glNewList(GLuint list, GLenum mode);
extern void __gls_capture_glEndList(void);
extern void __gls_capture_glCallList(GLuint list);
extern void __gls_capture_glCallLists(GLsizei n, GLenum type, const GLvoid *lists);
extern void __gls_capture_glDeleteLists(GLuint list, GLsizei range);
extern GLuint __gls_capture_glGenLists(GLsizei range);
extern void __gls_capture_glListBase(GLuint base);
extern void __gls_capture_glBegin(GLenum mode);
extern void __gls_capture_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void __gls_capture_glColor3b(GLbyte red, GLbyte green, GLbyte blue);
extern void __gls_capture_glColor3bv(const GLbyte *v);
extern void __gls_capture_glColor3d(GLdouble red, GLdouble green, GLdouble blue);
extern void __gls_capture_glColor3dv(const GLdouble *v);
extern void __gls_capture_glColor3f(GLfloat red, GLfloat green, GLfloat blue);
extern void __gls_capture_glColor3fv(const GLfloat *v);
extern void __gls_capture_glColor3i(GLint red, GLint green, GLint blue);
extern void __gls_capture_glColor3iv(const GLint *v);
extern void __gls_capture_glColor3s(GLshort red, GLshort green, GLshort blue);
extern void __gls_capture_glColor3sv(const GLshort *v);
extern void __gls_capture_glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
extern void __gls_capture_glColor3ubv(const GLubyte *v);
extern void __gls_capture_glColor3ui(GLuint red, GLuint green, GLuint blue);
extern void __gls_capture_glColor3uiv(const GLuint *v);
extern void __gls_capture_glColor3us(GLushort red, GLushort green, GLushort blue);
extern void __gls_capture_glColor3usv(const GLushort *v);
extern void __gls_capture_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void __gls_capture_glColor4bv(const GLbyte *v);
extern void __gls_capture_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void __gls_capture_glColor4dv(const GLdouble *v);
extern void __gls_capture_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glColor4fv(const GLfloat *v);
extern void __gls_capture_glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
extern void __gls_capture_glColor4iv(const GLint *v);
extern void __gls_capture_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void __gls_capture_glColor4sv(const GLshort *v);
extern void __gls_capture_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void __gls_capture_glColor4ubv(const GLubyte *v);
extern void __gls_capture_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void __gls_capture_glColor4uiv(const GLuint *v);
extern void __gls_capture_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void __gls_capture_glColor4usv(const GLushort *v);
extern void __gls_capture_glEdgeFlag(GLboolean flag);
extern void __gls_capture_glEdgeFlagv(const GLboolean *flag);
extern void __gls_capture_glEnd(void);
extern void __gls_capture_glIndexd(GLdouble c);
extern void __gls_capture_glIndexdv(const GLdouble *c);
extern void __gls_capture_glIndexf(GLfloat c);
extern void __gls_capture_glIndexfv(const GLfloat *c);
extern void __gls_capture_glIndexi(GLint c);
extern void __gls_capture_glIndexiv(const GLint *c);
extern void __gls_capture_glIndexs(GLshort c);
extern void __gls_capture_glIndexsv(const GLshort *c);
extern void __gls_capture_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
extern void __gls_capture_glNormal3bv(const GLbyte *v);
extern void __gls_capture_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
extern void __gls_capture_glNormal3dv(const GLdouble *v);
extern void __gls_capture_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
extern void __gls_capture_glNormal3fv(const GLfloat *v);
extern void __gls_capture_glNormal3i(GLint nx, GLint ny, GLint nz);
extern void __gls_capture_glNormal3iv(const GLint *v);
extern void __gls_capture_glNormal3s(GLshort nx, GLshort ny, GLshort nz);
extern void __gls_capture_glNormal3sv(const GLshort *v);
extern void __gls_capture_glRasterPos2d(GLdouble x, GLdouble y);
extern void __gls_capture_glRasterPos2dv(const GLdouble *v);
extern void __gls_capture_glRasterPos2f(GLfloat x, GLfloat y);
extern void __gls_capture_glRasterPos2fv(const GLfloat *v);
extern void __gls_capture_glRasterPos2i(GLint x, GLint y);
extern void __gls_capture_glRasterPos2iv(const GLint *v);
extern void __gls_capture_glRasterPos2s(GLshort x, GLshort y);
extern void __gls_capture_glRasterPos2sv(const GLshort *v);
extern void __gls_capture_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRasterPos3dv(const GLdouble *v);
extern void __gls_capture_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glRasterPos3fv(const GLfloat *v);
extern void __gls_capture_glRasterPos3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glRasterPos3iv(const GLint *v);
extern void __gls_capture_glRasterPos3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glRasterPos3sv(const GLshort *v);
extern void __gls_capture_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glRasterPos4dv(const GLdouble *v);
extern void __gls_capture_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glRasterPos4fv(const GLfloat *v);
extern void __gls_capture_glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glRasterPos4iv(const GLint *v);
extern void __gls_capture_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glRasterPos4sv(const GLshort *v);
extern void __gls_capture_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void __gls_capture_glRectdv(const GLdouble *v1, const GLdouble *v2);
extern void __gls_capture_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void __gls_capture_glRectfv(const GLfloat *v1, const GLfloat *v2);
extern void __gls_capture_glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
extern void __gls_capture_glRectiv(const GLint *v1, const GLint *v2);
extern void __gls_capture_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void __gls_capture_glRectsv(const GLshort *v1, const GLshort *v2);
extern void __gls_capture_glTexCoord1d(GLdouble s);
extern void __gls_capture_glTexCoord1dv(const GLdouble *v);
extern void __gls_capture_glTexCoord1f(GLfloat s);
extern void __gls_capture_glTexCoord1fv(const GLfloat *v);
extern void __gls_capture_glTexCoord1i(GLint s);
extern void __gls_capture_glTexCoord1iv(const GLint *v);
extern void __gls_capture_glTexCoord1s(GLshort s);
extern void __gls_capture_glTexCoord1sv(const GLshort *v);
extern void __gls_capture_glTexCoord2d(GLdouble s, GLdouble t);
extern void __gls_capture_glTexCoord2dv(const GLdouble *v);
extern void __gls_capture_glTexCoord2f(GLfloat s, GLfloat t);
extern void __gls_capture_glTexCoord2fv(const GLfloat *v);
extern void __gls_capture_glTexCoord2i(GLint s, GLint t);
extern void __gls_capture_glTexCoord2iv(const GLint *v);
extern void __gls_capture_glTexCoord2s(GLshort s, GLshort t);
extern void __gls_capture_glTexCoord2sv(const GLshort *v);
extern void __gls_capture_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
extern void __gls_capture_glTexCoord3dv(const GLdouble *v);
extern void __gls_capture_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
extern void __gls_capture_glTexCoord3fv(const GLfloat *v);
extern void __gls_capture_glTexCoord3i(GLint s, GLint t, GLint r);
extern void __gls_capture_glTexCoord3iv(const GLint *v);
extern void __gls_capture_glTexCoord3s(GLshort s, GLshort t, GLshort r);
extern void __gls_capture_glTexCoord3sv(const GLshort *v);
extern void __gls_capture_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void __gls_capture_glTexCoord4dv(const GLdouble *v);
extern void __gls_capture_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void __gls_capture_glTexCoord4fv(const GLfloat *v);
extern void __gls_capture_glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
extern void __gls_capture_glTexCoord4iv(const GLint *v);
extern void __gls_capture_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
extern void __gls_capture_glTexCoord4sv(const GLshort *v);
extern void __gls_capture_glVertex2d(GLdouble x, GLdouble y);
extern void __gls_capture_glVertex2dv(const GLdouble *v);
extern void __gls_capture_glVertex2f(GLfloat x, GLfloat y);
extern void __gls_capture_glVertex2fv(const GLfloat *v);
extern void __gls_capture_glVertex2i(GLint x, GLint y);
extern void __gls_capture_glVertex2iv(const GLint *v);
extern void __gls_capture_glVertex2s(GLshort x, GLshort y);
extern void __gls_capture_glVertex2sv(const GLshort *v);
extern void __gls_capture_glVertex3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glVertex3dv(const GLdouble *v);
extern void __gls_capture_glVertex3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glVertex3fv(const GLfloat *v);
extern void __gls_capture_glVertex3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glVertex3iv(const GLint *v);
extern void __gls_capture_glVertex3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glVertex3sv(const GLshort *v);
extern void __gls_capture_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glVertex4dv(const GLdouble *v);
extern void __gls_capture_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glVertex4fv(const GLfloat *v);
extern void __gls_capture_glVertex4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glVertex4iv(const GLint *v);
extern void __gls_capture_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glVertex4sv(const GLshort *v);
extern void __gls_capture_glClipPlane(GLenum plane, const GLdouble *equation);
extern void __gls_capture_glColorMaterial(GLenum face, GLenum mode);
extern void __gls_capture_glCullFace(GLenum mode);
extern void __gls_capture_glFogf(GLenum pname, GLfloat param);
extern void __gls_capture_glFogfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glFogi(GLenum pname, GLint param);
extern void __gls_capture_glFogiv(GLenum pname, const GLint *params);
extern void __gls_capture_glFrontFace(GLenum mode);
extern void __gls_capture_glHint(GLenum target, GLenum mode);
extern void __gls_capture_glLightf(GLenum light, GLenum pname, GLfloat param);
extern void __gls_capture_glLightfv(GLenum light, GLenum pname, const GLfloat *params);
extern void __gls_capture_glLighti(GLenum light, GLenum pname, GLint param);
extern void __gls_capture_glLightiv(GLenum light, GLenum pname, const GLint *params);
extern void __gls_capture_glLightModelf(GLenum pname, GLfloat param);
extern void __gls_capture_glLightModelfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glLightModeli(GLenum pname, GLint param);
extern void __gls_capture_glLightModeliv(GLenum pname, const GLint *params);
extern void __gls_capture_glLineStipple(GLint factor, GLushort pattern);
extern void __gls_capture_glLineWidth(GLfloat width);
extern void __gls_capture_glMaterialf(GLenum face, GLenum pname, GLfloat param);
extern void __gls_capture_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
extern void __gls_capture_glMateriali(GLenum face, GLenum pname, GLint param);
extern void __gls_capture_glMaterialiv(GLenum face, GLenum pname, const GLint *params);
extern void __gls_capture_glPointSize(GLfloat size);
extern void __gls_capture_glPolygonMode(GLenum face, GLenum mode);
extern void __gls_capture_glPolygonStipple(const GLubyte *mask);
extern void __gls_capture_glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glShadeModel(GLenum mode);
extern void __gls_capture_glTexParameterf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexParameteri(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexEnvf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexEnvi(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexEnviv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexGend(GLenum coord, GLenum pname, GLdouble param);
extern void __gls_capture_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params);
extern void __gls_capture_glTexGenf(GLenum coord, GLenum pname, GLfloat param);
extern void __gls_capture_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexGeni(GLenum coord, GLenum pname, GLint param);
extern void __gls_capture_glTexGeniv(GLenum coord, GLenum pname, const GLint *params);
extern void __gls_capture_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
extern void __gls_capture_glSelectBuffer(GLsizei size, GLuint *buffer);
extern GLint __gls_capture_glRenderMode(GLenum mode);
extern void __gls_capture_glInitNames(void);
extern void __gls_capture_glLoadName(GLuint name);
extern void __gls_capture_glPassThrough(GLfloat token);
extern void __gls_capture_glPopName(void);
extern void __gls_capture_glPushName(GLuint name);
extern void __gls_capture_glDrawBuffer(GLenum mode);
extern void __gls_capture_glClear(GLbitfield mask);
extern void __gls_capture_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glClearIndex(GLfloat c);
extern void __gls_capture_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glClearStencil(GLint s);
extern void __gls_capture_glClearDepth(GLclampd depth);
extern void __gls_capture_glStencilMask(GLuint mask);
extern void __gls_capture_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void __gls_capture_glDepthMask(GLboolean flag);
extern void __gls_capture_glIndexMask(GLuint mask);
extern void __gls_capture_glAccum(GLenum op, GLfloat value);
extern void __gls_capture_glDisable(GLenum cap);
extern void __gls_capture_glEnable(GLenum cap);
extern void __gls_capture_glFinish(void);
extern void __gls_capture_glFlush(void);
extern void __gls_capture_glPopAttrib(void);
extern void __gls_capture_glPushAttrib(GLbitfield mask);
extern void __gls_capture_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void __gls_capture_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void __gls_capture_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void __gls_capture_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void __gls_capture_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
extern void __gls_capture_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
extern void __gls_capture_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void __gls_capture_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void __gls_capture_glEvalCoord1d(GLdouble u);
extern void __gls_capture_glEvalCoord1dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord1f(GLfloat u);
extern void __gls_capture_glEvalCoord1fv(const GLfloat *u);
extern void __gls_capture_glEvalCoord2d(GLdouble u, GLdouble v);
extern void __gls_capture_glEvalCoord2dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord2f(GLfloat u, GLfloat v);
extern void __gls_capture_glEvalCoord2fv(const GLfloat *u);
extern void __gls_capture_glEvalMesh1(GLenum mode, GLint i1, GLint i2);
extern void __gls_capture_glEvalPoint1(GLint i);
extern void __gls_capture_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void __gls_capture_glEvalPoint2(GLint i, GLint j);
extern void __gls_capture_glAlphaFunc(GLenum func, GLclampf ref);
extern void __gls_capture_glBlendFunc(GLenum sfactor, GLenum dfactor);
extern void __gls_capture_glLogicOp(GLenum opcode);
extern void __gls_capture_glStencilFunc(GLenum func, GLint ref, GLuint mask);
extern void __gls_capture_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
extern void __gls_capture_glDepthFunc(GLenum func);
extern void __gls_capture_glPixelZoom(GLfloat xfactor, GLfloat yfactor);
extern void __gls_capture_glPixelTransferf(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelTransferi(GLenum pname, GLint param);
extern void __gls_capture_glPixelStoref(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelStorei(GLenum pname, GLint param);
extern void __gls_capture_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values);
extern void __gls_capture_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values);
extern void __gls_capture_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values);
extern void __gls_capture_glReadBuffer(GLenum mode);
extern void __gls_capture_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void __gls_capture_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glGetBooleanv(GLenum pname, GLboolean *params);
extern void __gls_capture_glGetClipPlane(GLenum plane, GLdouble *equation);
extern void __gls_capture_glGetDoublev(GLenum pname, GLdouble *params);
extern GLenum __gls_capture_glGetError(void);
extern void __gls_capture_glGetFloatv(GLenum pname, GLfloat *params);
extern void __gls_capture_glGetIntegerv(GLenum pname, GLint *params);
extern void __gls_capture_glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetLightiv(GLenum light, GLenum pname, GLint *params);
extern void __gls_capture_glGetMapdv(GLenum target, GLenum query, GLdouble *v);
extern void __gls_capture_glGetMapfv(GLenum target, GLenum query, GLfloat *v);
extern void __gls_capture_glGetMapiv(GLenum target, GLenum query, GLint *v);
extern void __gls_capture_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMaterialiv(GLenum face, GLenum pname, GLint *params);
extern void __gls_capture_glGetPixelMapfv(GLenum map, GLfloat *values);
extern void __gls_capture_glGetPixelMapuiv(GLenum map, GLuint *values);
extern void __gls_capture_glGetPixelMapusv(GLenum map, GLushort *values);
extern void __gls_capture_glGetPolygonStipple(GLubyte *mask);
extern const GLubyte * __gls_capture_glGetString(GLenum name);
extern void __gls_capture_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexEnviv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params);
extern void __gls_capture_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
extern GLboolean __gls_capture_glIsEnabled(GLenum cap);
extern GLboolean __gls_capture_glIsList(GLuint list);
extern void __gls_capture_glDepthRange(GLclampd near, GLclampd far);
extern void __gls_capture_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glLoadIdentity(void);
extern void __gls_capture_glLoadMatrixf(const GLfloat *m);
extern void __gls_capture_glLoadMatrixd(const GLdouble *m);
extern void __gls_capture_glMatrixMode(GLenum mode);
extern void __gls_capture_glMultMatrixf(const GLfloat *m);
extern void __gls_capture_glMultMatrixd(const GLdouble *m);
extern void __gls_capture_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glPopMatrix(void);
extern void __gls_capture_glPushMatrix(void);
extern void __gls_capture_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glScaled(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glScalef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glTranslated(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glTranslatef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glBlendEquationEXT(GLenum mode);
extern void __gls_capture_glPolygonOffsetEXT(GLfloat factor, GLfloat bias);
extern void __gls_capture_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glSampleMaskSGIS(GLclampf value, GLboolean invert);
extern void __gls_capture_glSamplePatternSGIS(GLenum pattern);
extern void __gls_capture_glTagSampleBufferSGIX(void);
extern void __gls_capture_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params);
extern void __gls_capture_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params);
extern void __gls_capture_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void __gls_capture_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern void __gls_capture_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void __gls_capture_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glResetHistogramEXT(GLenum target);
extern void __gls_capture_glResetMinmaxEXT(GLenum target);
extern void __gls_capture_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glArrayElementEXT(GLint i);
extern void __gls_capture_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
extern void __gls_capture_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
extern void __gls_capture_glGetPointervEXT(GLenum pname, GLvoid* *params);
extern void __gls_capture_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern GLboolean __gls_capture_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
extern void __gls_capture_glBindTextureEXT(GLenum target, GLuint texture);
extern void __gls_capture_glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
extern void __gls_capture_glGenTexturesEXT(GLsizei n, GLuint *textures);
extern GLboolean __gls_capture_glIsTextureEXT(GLuint texture);
extern void __gls_capture_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void __gls_capture_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void __gls_capture_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void __gls_capture_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void __gls_capture_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void __gls_capture_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glPixelTexGenSGIX(GLenum mode);

// DrewB - 1.1
extern void __gls_capture_glArrayElement(GLint i);
extern void __gls_capture_glBindTexture(GLenum target, GLuint texture);
extern void __gls_capture_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glDisableClientState(GLenum array);
extern void __gls_capture_glDrawArrays(GLenum mode, GLint first, GLsizei count);
extern void __gls_capture_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void __gls_capture_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glEnableClientState(GLenum array);
extern void __gls_capture_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glIndexub(GLubyte c);
extern void __gls_capture_glIndexubv(const GLubyte *c);
extern void __gls_capture_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glPolygonOffset(GLfloat factor, GLfloat units);
extern void __gls_capture_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void __gls_capture_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences);
extern void __gls_capture_glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
extern void __gls_capture_glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void __gls_capture_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glDeleteTextures(GLsizei n, const GLuint *textures);
extern void __gls_capture_glGenTextures(GLsizei n, GLuint *textures);
extern void __gls_capture_glGetPointerv(GLenum pname, GLvoid* *params);
extern void __gls_capture_glIsTexture(GLuint texture);
extern void __gls_capture_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void __gls_capture_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glPushClientAttrib(GLbitfield mask);
extern void __gls_capture_glPopClientAttrib(void);

// DrewB
extern void __gls_capture_glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
// MarcFo
extern void __gls_capture_glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

const GLSfunc __glsDispatchCapture[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_capture_glsBeginGLS,
    (GLSfunc)__gls_capture_glsBlock,
    (GLSfunc)__gls_capture_glsCallStream,
    (GLSfunc)__gls_capture_glsEndGLS,
    (GLSfunc)__gls_capture_glsError,
    (GLSfunc)__gls_capture_glsGLRC,
    (GLSfunc)__gls_capture_glsGLRCLayer,
    (GLSfunc)__gls_capture_glsHeaderGLRCi,
    (GLSfunc)__gls_capture_glsHeaderLayerf,
    (GLSfunc)__gls_capture_glsHeaderLayeri,
    (GLSfunc)__gls_capture_glsHeaderf,
    (GLSfunc)__gls_capture_glsHeaderfv,
    (GLSfunc)__gls_capture_glsHeaderi,
    (GLSfunc)__gls_capture_glsHeaderiv,
    (GLSfunc)__gls_capture_glsHeaderubz,
    (GLSfunc)__gls_capture_glsRequireExtension,
    (GLSfunc)__gls_capture_glsUnsupportedCommand,
    (GLSfunc)__gls_capture_glsAppRef,
    (GLSfunc)__gls_capture_glsBeginObj,
    (GLSfunc)__gls_capture_glsCharubz,
    (GLSfunc)__gls_capture_glsComment,
    (GLSfunc)__gls_capture_glsDisplayMapfv,
    (GLSfunc)__gls_capture_glsEndObj,
    (GLSfunc)__gls_capture_glsNumb,
    (GLSfunc)__gls_capture_glsNumbv,
    (GLSfunc)__gls_capture_glsNumd,
    (GLSfunc)__gls_capture_glsNumdv,
    (GLSfunc)__gls_capture_glsNumf,
    (GLSfunc)__gls_capture_glsNumfv,
    (GLSfunc)__gls_capture_glsNumi,
    (GLSfunc)__gls_capture_glsNumiv,
    (GLSfunc)__gls_capture_glsNuml,
    (GLSfunc)__gls_capture_glsNumlv,
    (GLSfunc)__gls_capture_glsNums,
    (GLSfunc)__gls_capture_glsNumsv,
    (GLSfunc)__gls_capture_glsNumub,
    (GLSfunc)__gls_capture_glsNumubv,
    (GLSfunc)__gls_capture_glsNumui,
    (GLSfunc)__gls_capture_glsNumuiv,
    (GLSfunc)__gls_capture_glsNumul,
    (GLSfunc)__gls_capture_glsNumulv,
    (GLSfunc)__gls_capture_glsNumus,
    (GLSfunc)__gls_capture_glsNumusv,
    (GLSfunc)__gls_capture_glsPad,
    (GLSfunc)__gls_capture_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_capture_glNewList,
    (GLSfunc)__gls_capture_glEndList,
    (GLSfunc)__gls_capture_glCallList,
    (GLSfunc)__gls_capture_glCallLists,
    (GLSfunc)__gls_capture_glDeleteLists,
    (GLSfunc)__gls_capture_glGenLists,
    (GLSfunc)__gls_capture_glListBase,
    (GLSfunc)__gls_capture_glBegin,
    (GLSfunc)__gls_capture_glBitmap,
    (GLSfunc)__gls_capture_glColor3b,
    (GLSfunc)__gls_capture_glColor3bv,
    (GLSfunc)__gls_capture_glColor3d,
    (GLSfunc)__gls_capture_glColor3dv,
    (GLSfunc)__gls_capture_glColor3f,
    (GLSfunc)__gls_capture_glColor3fv,
    (GLSfunc)__gls_capture_glColor3i,
    (GLSfunc)__gls_capture_glColor3iv,
    (GLSfunc)__gls_capture_glColor3s,
    (GLSfunc)__gls_capture_glColor3sv,
    (GLSfunc)__gls_capture_glColor3ub,
    (GLSfunc)__gls_capture_glColor3ubv,
    (GLSfunc)__gls_capture_glColor3ui,
    (GLSfunc)__gls_capture_glColor3uiv,
    (GLSfunc)__gls_capture_glColor3us,
    (GLSfunc)__gls_capture_glColor3usv,
    (GLSfunc)__gls_capture_glColor4b,
    (GLSfunc)__gls_capture_glColor4bv,
    (GLSfunc)__gls_capture_glColor4d,
    (GLSfunc)__gls_capture_glColor4dv,
    (GLSfunc)__gls_capture_glColor4f,
    (GLSfunc)__gls_capture_glColor4fv,
    (GLSfunc)__gls_capture_glColor4i,
    (GLSfunc)__gls_capture_glColor4iv,
    (GLSfunc)__gls_capture_glColor4s,
    (GLSfunc)__gls_capture_glColor4sv,
    (GLSfunc)__gls_capture_glColor4ub,
    (GLSfunc)__gls_capture_glColor4ubv,
    (GLSfunc)__gls_capture_glColor4ui,
    (GLSfunc)__gls_capture_glColor4uiv,
    (GLSfunc)__gls_capture_glColor4us,
    (GLSfunc)__gls_capture_glColor4usv,
    (GLSfunc)__gls_capture_glEdgeFlag,
    (GLSfunc)__gls_capture_glEdgeFlagv,
    (GLSfunc)__gls_capture_glEnd,
    (GLSfunc)__gls_capture_glIndexd,
    (GLSfunc)__gls_capture_glIndexdv,
    (GLSfunc)__gls_capture_glIndexf,
    (GLSfunc)__gls_capture_glIndexfv,
    (GLSfunc)__gls_capture_glIndexi,
    (GLSfunc)__gls_capture_glIndexiv,
    (GLSfunc)__gls_capture_glIndexs,
    (GLSfunc)__gls_capture_glIndexsv,
    (GLSfunc)__gls_capture_glNormal3b,
    (GLSfunc)__gls_capture_glNormal3bv,
    (GLSfunc)__gls_capture_glNormal3d,
    (GLSfunc)__gls_capture_glNormal3dv,
    (GLSfunc)__gls_capture_glNormal3f,
    (GLSfunc)__gls_capture_glNormal3fv,
    (GLSfunc)__gls_capture_glNormal3i,
    (GLSfunc)__gls_capture_glNormal3iv,
    (GLSfunc)__gls_capture_glNormal3s,
    (GLSfunc)__gls_capture_glNormal3sv,
    (GLSfunc)__gls_capture_glRasterPos2d,
    (GLSfunc)__gls_capture_glRasterPos2dv,
    (GLSfunc)__gls_capture_glRasterPos2f,
    (GLSfunc)__gls_capture_glRasterPos2fv,
    (GLSfunc)__gls_capture_glRasterPos2i,
    (GLSfunc)__gls_capture_glRasterPos2iv,
    (GLSfunc)__gls_capture_glRasterPos2s,
    (GLSfunc)__gls_capture_glRasterPos2sv,
    (GLSfunc)__gls_capture_glRasterPos3d,
    (GLSfunc)__gls_capture_glRasterPos3dv,
    (GLSfunc)__gls_capture_glRasterPos3f,
    (GLSfunc)__gls_capture_glRasterPos3fv,
    (GLSfunc)__gls_capture_glRasterPos3i,
    (GLSfunc)__gls_capture_glRasterPos3iv,
    (GLSfunc)__gls_capture_glRasterPos3s,
    (GLSfunc)__gls_capture_glRasterPos3sv,
    (GLSfunc)__gls_capture_glRasterPos4d,
    (GLSfunc)__gls_capture_glRasterPos4dv,
    (GLSfunc)__gls_capture_glRasterPos4f,
    (GLSfunc)__gls_capture_glRasterPos4fv,
    (GLSfunc)__gls_capture_glRasterPos4i,
    (GLSfunc)__gls_capture_glRasterPos4iv,
    (GLSfunc)__gls_capture_glRasterPos4s,
    (GLSfunc)__gls_capture_glRasterPos4sv,
    (GLSfunc)__gls_capture_glRectd,
    (GLSfunc)__gls_capture_glRectdv,
    (GLSfunc)__gls_capture_glRectf,
    (GLSfunc)__gls_capture_glRectfv,
    (GLSfunc)__gls_capture_glRecti,
    (GLSfunc)__gls_capture_glRectiv,
    (GLSfunc)__gls_capture_glRects,
    (GLSfunc)__gls_capture_glRectsv,
    (GLSfunc)__gls_capture_glTexCoord1d,
    (GLSfunc)__gls_capture_glTexCoord1dv,
    (GLSfunc)__gls_capture_glTexCoord1f,
    (GLSfunc)__gls_capture_glTexCoord1fv,
    (GLSfunc)__gls_capture_glTexCoord1i,
    (GLSfunc)__gls_capture_glTexCoord1iv,
    (GLSfunc)__gls_capture_glTexCoord1s,
    (GLSfunc)__gls_capture_glTexCoord1sv,
    (GLSfunc)__gls_capture_glTexCoord2d,
    (GLSfunc)__gls_capture_glTexCoord2dv,
    (GLSfunc)__gls_capture_glTexCoord2f,
    (GLSfunc)__gls_capture_glTexCoord2fv,
    (GLSfunc)__gls_capture_glTexCoord2i,
    (GLSfunc)__gls_capture_glTexCoord2iv,
    (GLSfunc)__gls_capture_glTexCoord2s,
    (GLSfunc)__gls_capture_glTexCoord2sv,
    (GLSfunc)__gls_capture_glTexCoord3d,
    (GLSfunc)__gls_capture_glTexCoord3dv,
    (GLSfunc)__gls_capture_glTexCoord3f,
    (GLSfunc)__gls_capture_glTexCoord3fv,
    (GLSfunc)__gls_capture_glTexCoord3i,
    (GLSfunc)__gls_capture_glTexCoord3iv,
    (GLSfunc)__gls_capture_glTexCoord3s,
    (GLSfunc)__gls_capture_glTexCoord3sv,
    (GLSfunc)__gls_capture_glTexCoord4d,
    (GLSfunc)__gls_capture_glTexCoord4dv,
    (GLSfunc)__gls_capture_glTexCoord4f,
    (GLSfunc)__gls_capture_glTexCoord4fv,
    (GLSfunc)__gls_capture_glTexCoord4i,
    (GLSfunc)__gls_capture_glTexCoord4iv,
    (GLSfunc)__gls_capture_glTexCoord4s,
    (GLSfunc)__gls_capture_glTexCoord4sv,
    (GLSfunc)__gls_capture_glVertex2d,
    (GLSfunc)__gls_capture_glVertex2dv,
    (GLSfunc)__gls_capture_glVertex2f,
    (GLSfunc)__gls_capture_glVertex2fv,
    (GLSfunc)__gls_capture_glVertex2i,
    (GLSfunc)__gls_capture_glVertex2iv,
    (GLSfunc)__gls_capture_glVertex2s,
    (GLSfunc)__gls_capture_glVertex2sv,
    (GLSfunc)__gls_capture_glVertex3d,
    (GLSfunc)__gls_capture_glVertex3dv,
    (GLSfunc)__gls_capture_glVertex3f,
    (GLSfunc)__gls_capture_glVertex3fv,
    (GLSfunc)__gls_capture_glVertex3i,
    (GLSfunc)__gls_capture_glVertex3iv,
    (GLSfunc)__gls_capture_glVertex3s,
    (GLSfunc)__gls_capture_glVertex3sv,
    (GLSfunc)__gls_capture_glVertex4d,
    (GLSfunc)__gls_capture_glVertex4dv,
    (GLSfunc)__gls_capture_glVertex4f,
    (GLSfunc)__gls_capture_glVertex4fv,
    (GLSfunc)__gls_capture_glVertex4i,
    (GLSfunc)__gls_capture_glVertex4iv,
    (GLSfunc)__gls_capture_glVertex4s,
    (GLSfunc)__gls_capture_glVertex4sv,
    (GLSfunc)__gls_capture_glClipPlane,
    (GLSfunc)__gls_capture_glColorMaterial,
    (GLSfunc)__gls_capture_glCullFace,
    (GLSfunc)__gls_capture_glFogf,
    (GLSfunc)__gls_capture_glFogfv,
    (GLSfunc)__gls_capture_glFogi,
    (GLSfunc)__gls_capture_glFogiv,
    (GLSfunc)__gls_capture_glFrontFace,
    (GLSfunc)__gls_capture_glHint,
    (GLSfunc)__gls_capture_glLightf,
    (GLSfunc)__gls_capture_glLightfv,
    (GLSfunc)__gls_capture_glLighti,
    (GLSfunc)__gls_capture_glLightiv,
    (GLSfunc)__gls_capture_glLightModelf,
    (GLSfunc)__gls_capture_glLightModelfv,
    (GLSfunc)__gls_capture_glLightModeli,
    (GLSfunc)__gls_capture_glLightModeliv,
    (GLSfunc)__gls_capture_glLineStipple,
    (GLSfunc)__gls_capture_glLineWidth,
    (GLSfunc)__gls_capture_glMaterialf,
    (GLSfunc)__gls_capture_glMaterialfv,
    (GLSfunc)__gls_capture_glMateriali,
    (GLSfunc)__gls_capture_glMaterialiv,
    (GLSfunc)__gls_capture_glPointSize,
    (GLSfunc)__gls_capture_glPolygonMode,
    (GLSfunc)__gls_capture_glPolygonStipple,
    (GLSfunc)__gls_capture_glScissor,
    (GLSfunc)__gls_capture_glShadeModel,
    (GLSfunc)__gls_capture_glTexParameterf,
    (GLSfunc)__gls_capture_glTexParameterfv,
    (GLSfunc)__gls_capture_glTexParameteri,
    (GLSfunc)__gls_capture_glTexParameteriv,
    (GLSfunc)__gls_capture_glTexImage1D,
    (GLSfunc)__gls_capture_glTexImage2D,
    (GLSfunc)__gls_capture_glTexEnvf,
    (GLSfunc)__gls_capture_glTexEnvfv,
    (GLSfunc)__gls_capture_glTexEnvi,
    (GLSfunc)__gls_capture_glTexEnviv,
    (GLSfunc)__gls_capture_glTexGend,
    (GLSfunc)__gls_capture_glTexGendv,
    (GLSfunc)__gls_capture_glTexGenf,
    (GLSfunc)__gls_capture_glTexGenfv,
    (GLSfunc)__gls_capture_glTexGeni,
    (GLSfunc)__gls_capture_glTexGeniv,
    (GLSfunc)__gls_capture_glFeedbackBuffer,
    (GLSfunc)__gls_capture_glSelectBuffer,
    (GLSfunc)__gls_capture_glRenderMode,
    (GLSfunc)__gls_capture_glInitNames,
    (GLSfunc)__gls_capture_glLoadName,
    (GLSfunc)__gls_capture_glPassThrough,
    (GLSfunc)__gls_capture_glPopName,
    (GLSfunc)__gls_capture_glPushName,
    (GLSfunc)__gls_capture_glDrawBuffer,
    (GLSfunc)__gls_capture_glClear,
    (GLSfunc)__gls_capture_glClearAccum,
    (GLSfunc)__gls_capture_glClearIndex,
    (GLSfunc)__gls_capture_glClearColor,
    (GLSfunc)__gls_capture_glClearStencil,
    (GLSfunc)__gls_capture_glClearDepth,
    (GLSfunc)__gls_capture_glStencilMask,
    (GLSfunc)__gls_capture_glColorMask,
    (GLSfunc)__gls_capture_glDepthMask,
    (GLSfunc)__gls_capture_glIndexMask,
    (GLSfunc)__gls_capture_glAccum,
    (GLSfunc)__gls_capture_glDisable,
    (GLSfunc)__gls_capture_glEnable,
    (GLSfunc)__gls_capture_glFinish,
    (GLSfunc)__gls_capture_glFlush,
    (GLSfunc)__gls_capture_glPopAttrib,
    (GLSfunc)__gls_capture_glPushAttrib,
    (GLSfunc)__gls_capture_glMap1d,
    (GLSfunc)__gls_capture_glMap1f,
    (GLSfunc)__gls_capture_glMap2d,
    (GLSfunc)__gls_capture_glMap2f,
    (GLSfunc)__gls_capture_glMapGrid1d,
    (GLSfunc)__gls_capture_glMapGrid1f,
    (GLSfunc)__gls_capture_glMapGrid2d,
    (GLSfunc)__gls_capture_glMapGrid2f,
    (GLSfunc)__gls_capture_glEvalCoord1d,
    (GLSfunc)__gls_capture_glEvalCoord1dv,
    (GLSfunc)__gls_capture_glEvalCoord1f,
    (GLSfunc)__gls_capture_glEvalCoord1fv,
    (GLSfunc)__gls_capture_glEvalCoord2d,
    (GLSfunc)__gls_capture_glEvalCoord2dv,
    (GLSfunc)__gls_capture_glEvalCoord2f,
    (GLSfunc)__gls_capture_glEvalCoord2fv,
    (GLSfunc)__gls_capture_glEvalMesh1,
    (GLSfunc)__gls_capture_glEvalPoint1,
    (GLSfunc)__gls_capture_glEvalMesh2,
    (GLSfunc)__gls_capture_glEvalPoint2,
    (GLSfunc)__gls_capture_glAlphaFunc,
    (GLSfunc)__gls_capture_glBlendFunc,
    (GLSfunc)__gls_capture_glLogicOp,
    (GLSfunc)__gls_capture_glStencilFunc,
    (GLSfunc)__gls_capture_glStencilOp,
    (GLSfunc)__gls_capture_glDepthFunc,
    (GLSfunc)__gls_capture_glPixelZoom,
    (GLSfunc)__gls_capture_glPixelTransferf,
    (GLSfunc)__gls_capture_glPixelTransferi,
    (GLSfunc)__gls_capture_glPixelStoref,
    (GLSfunc)__gls_capture_glPixelStorei,
    (GLSfunc)__gls_capture_glPixelMapfv,
    (GLSfunc)__gls_capture_glPixelMapuiv,
    (GLSfunc)__gls_capture_glPixelMapusv,
    (GLSfunc)__gls_capture_glReadBuffer,
    (GLSfunc)__gls_capture_glCopyPixels,
    (GLSfunc)__gls_capture_glReadPixels,
    (GLSfunc)__gls_capture_glDrawPixels,
    (GLSfunc)__gls_capture_glGetBooleanv,
    (GLSfunc)__gls_capture_glGetClipPlane,
    (GLSfunc)__gls_capture_glGetDoublev,
    (GLSfunc)__gls_capture_glGetError,
    (GLSfunc)__gls_capture_glGetFloatv,
    (GLSfunc)__gls_capture_glGetIntegerv,
    (GLSfunc)__gls_capture_glGetLightfv,
    (GLSfunc)__gls_capture_glGetLightiv,
    (GLSfunc)__gls_capture_glGetMapdv,
    (GLSfunc)__gls_capture_glGetMapfv,
    (GLSfunc)__gls_capture_glGetMapiv,
    (GLSfunc)__gls_capture_glGetMaterialfv,
    (GLSfunc)__gls_capture_glGetMaterialiv,
    (GLSfunc)__gls_capture_glGetPixelMapfv,
    (GLSfunc)__gls_capture_glGetPixelMapuiv,
    (GLSfunc)__gls_capture_glGetPixelMapusv,
    (GLSfunc)__gls_capture_glGetPolygonStipple,
    (GLSfunc)__gls_capture_glGetString,
    (GLSfunc)__gls_capture_glGetTexEnvfv,
    (GLSfunc)__gls_capture_glGetTexEnviv,
    (GLSfunc)__gls_capture_glGetTexGendv,
    (GLSfunc)__gls_capture_glGetTexGenfv,
    (GLSfunc)__gls_capture_glGetTexGeniv,
    (GLSfunc)__gls_capture_glGetTexImage,
    (GLSfunc)__gls_capture_glGetTexParameterfv,
    (GLSfunc)__gls_capture_glGetTexParameteriv,
    (GLSfunc)__gls_capture_glGetTexLevelParameterfv,
    (GLSfunc)__gls_capture_glGetTexLevelParameteriv,
    (GLSfunc)__gls_capture_glIsEnabled,
    (GLSfunc)__gls_capture_glIsList,
    (GLSfunc)__gls_capture_glDepthRange,
    (GLSfunc)__gls_capture_glFrustum,
    (GLSfunc)__gls_capture_glLoadIdentity,
    (GLSfunc)__gls_capture_glLoadMatrixf,
    (GLSfunc)__gls_capture_glLoadMatrixd,
    (GLSfunc)__gls_capture_glMatrixMode,
    (GLSfunc)__gls_capture_glMultMatrixf,
    (GLSfunc)__gls_capture_glMultMatrixd,
    (GLSfunc)__gls_capture_glOrtho,
    (GLSfunc)__gls_capture_glPopMatrix,
    (GLSfunc)__gls_capture_glPushMatrix,
    (GLSfunc)__gls_capture_glRotated,
    (GLSfunc)__gls_capture_glRotatef,
    (GLSfunc)__gls_capture_glScaled,
    (GLSfunc)__gls_capture_glScalef,
    (GLSfunc)__gls_capture_glTranslated,
    (GLSfunc)__gls_capture_glTranslatef,
    (GLSfunc)__gls_capture_glViewport,
    // DrewB - 1.1
    (GLSfunc)__gls_capture_glArrayElement,
    (GLSfunc)__gls_capture_glBindTexture,
    (GLSfunc)__gls_capture_glColorPointer,
    (GLSfunc)__gls_capture_glDisableClientState,
    (GLSfunc)__gls_capture_glDrawArrays,
    (GLSfunc)__gls_capture_glDrawElements,
    (GLSfunc)__gls_capture_glEdgeFlagPointer,
    (GLSfunc)__gls_capture_glEnableClientState,
    (GLSfunc)__gls_capture_glIndexPointer,
    (GLSfunc)__gls_capture_glIndexub,
    (GLSfunc)__gls_capture_glIndexubv,
    (GLSfunc)__gls_capture_glInterleavedArrays,
    (GLSfunc)__gls_capture_glNormalPointer,
    (GLSfunc)__gls_capture_glPolygonOffset,
    (GLSfunc)__gls_capture_glTexCoordPointer,
    (GLSfunc)__gls_capture_glVertexPointer,
    (GLSfunc)__gls_capture_glAreTexturesResident,
    (GLSfunc)__gls_capture_glCopyTexImage1D,
    (GLSfunc)__gls_capture_glCopyTexImage2D,
    (GLSfunc)__gls_capture_glCopyTexSubImage1D,
    (GLSfunc)__gls_capture_glCopyTexSubImage2D,
    (GLSfunc)__gls_capture_glDeleteTextures,
    (GLSfunc)__gls_capture_glGenTextures,
    (GLSfunc)__gls_capture_glGetPointerv,
    (GLSfunc)__gls_capture_glIsTexture,
    (GLSfunc)__gls_capture_glPrioritizeTextures,
    (GLSfunc)__gls_capture_glTexSubImage1D,
    (GLSfunc)__gls_capture_glTexSubImage2D,
    (GLSfunc)__gls_capture_glPushClientAttrib,
    (GLSfunc)__gls_capture_glPopClientAttrib,
    #if __GL_EXT_blend_color
        (GLSfunc)__gls_capture_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        (GLSfunc)__gls_capture_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        (GLSfunc)__gls_capture_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_capture_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_capture_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_capture_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_capture_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        (GLSfunc)__gls_capture_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_capture_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_capture_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        (GLSfunc)__gls_capture_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture && __GL_EXT_texture3D
        (GLSfunc)__gls_capture_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_capture_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_capture_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_capture_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_capture_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_capture_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_capture_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_capture_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_capture_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_capture_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_capture_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_capture_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_capture_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture && __GL_EXT_texture3D
        (GLSfunc)__gls_capture_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_capture_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_capture_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        (GLSfunc)__gls_capture_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        // DrewB
        (GLSfunc)__gls_capture_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    #if __GL_WIN_draw_range_elements
        // MarcFo
        (GLSfunc)__gls_capture_glDrawRangeElementsWIN,
    #else
        GLS_NONE,
    #endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_exec.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void __gls_exec_glsAppRef(GLulong inAddress, GLuint inCount) {}

void __gls_exec_glsBeginObj(const GLubyte *inTag) {}

void __gls_exec_glsCharubz(const GLubyte *inTag, const GLubyte *inString) {}

void __gls_exec_glsComment(const GLubyte *inComment) {}

void __gls_exec_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {}

void __gls_exec_glsEndObj(void) {}

void __gls_exec_glsNumb(const GLubyte *inTag, GLbyte inVal) {}

void __gls_exec_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {}

void __gls_exec_glsNumd(const GLubyte *inTag, GLdouble inVal) {}

void __gls_exec_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {}

void __gls_exec_glsNumf(const GLubyte *inTag, GLfloat inVal) {}

void __gls_exec_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {}

void __gls_exec_glsNumi(const GLubyte *inTag, GLint inVal) {}

void __gls_exec_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {}

void __gls_exec_glsNuml(const GLubyte *inTag, GLlong inVal) {}

void __gls_exec_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {}

void __gls_exec_glsNums(const GLubyte *inTag, GLshort inVal) {}

void __gls_exec_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {}

void __gls_exec_glsNumub(const GLubyte *inTag, GLubyte inVal) {}

void __gls_exec_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {}

void __gls_exec_glsNumui(const GLubyte *inTag, GLuint inVal) {}

void __gls_exec_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {}

void __gls_exec_glsNumul(const GLubyte *inTag, GLulong inVal) {}

void __gls_exec_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {}

void __gls_exec_glsNumus(const GLubyte *inTag, GLushort inVal) {}

void __gls_exec_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {}

void __gls_exec_glsPad(void) {}

void __gls_exec_glsSwapBuffers(GLuint inLayer) {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_glstub.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void glNewList(GLuint list, GLenum mode) {
    fprintf(stderr, "stub_glNewList\n");
}

void glEndList(void) {
    fprintf(stderr, "stub_glEndList\n");
}

void glCallList(GLuint list) {
    fprintf(stderr, "stub_glCallList\n");
}

void glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {
    fprintf(stderr, "stub_glCallLists\n");
}

void glDeleteLists(GLuint list, GLsizei range) {
    fprintf(stderr, "stub_glDeleteLists\n");
}

GLuint glGenLists(GLsizei range) {
    fprintf(stderr, "stub_glGenLists\n");
    return 0;
}

void glListBase(GLuint base) {
    fprintf(stderr, "stub_glListBase\n");
}

void glBegin(GLenum mode) {
    fprintf(stderr, "stub_glBegin\n");
}

void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {
    fprintf(stderr, "stub_glBitmap\n");
}

void glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    fprintf(stderr, "stub_glColor3b\n");
}

void glColor3bv(const GLbyte *v) {
    fprintf(stderr, "stub_glColor3bv\n");
}

void glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    fprintf(stderr, "stub_glColor3d\n");
}

void glColor3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glColor3dv\n");
}

void glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    fprintf(stderr, "stub_glColor3f\n");
}

void glColor3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glColor3fv\n");
}

void glColor3i(GLint red, GLint green, GLint blue) {
    fprintf(stderr, "stub_glColor3i\n");
}

void glColor3iv(const GLint *v) {
    fprintf(stderr, "stub_glColor3iv\n");
}

void glColor3s(GLshort red, GLshort green, GLshort blue) {
    fprintf(stderr, "stub_glColor3s\n");
}

void glColor3sv(const GLshort *v) {
    fprintf(stderr, "stub_glColor3sv\n");
}

void glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    fprintf(stderr, "stub_glColor3ub\n");
}

void glColor3ubv(const GLubyte *v) {
    fprintf(stderr, "stub_glColor3ubv\n");
}

void glColor3ui(GLuint red, GLuint green, GLuint blue) {
    fprintf(stderr, "stub_glColor3ui\n");
}

void glColor3uiv(const GLuint *v) {
    fprintf(stderr, "stub_glColor3uiv\n");
}

void glColor3us(GLushort red, GLushort green, GLushort blue) {
    fprintf(stderr, "stub_glColor3us\n");
}

void glColor3usv(const GLushort *v) {
    fprintf(stderr, "stub_glColor3usv\n");
}

void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    fprintf(stderr, "stub_glColor4b\n");
}

void glColor4bv(const GLbyte *v) {
    fprintf(stderr, "stub_glColor4bv\n");
}

void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    fprintf(stderr, "stub_glColor4d\n");
}

void glColor4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glColor4dv\n");
}

void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    fprintf(stderr, "stub_glColor4f\n");
}

void glColor4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glColor4fv\n");
}

void glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    fprintf(stderr, "stub_glColor4i\n");
}

void glColor4iv(const GLint *v) {
    fprintf(stderr, "stub_glColor4iv\n");
}

void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    fprintf(stderr, "stub_glColor4s\n");
}

void glColor4sv(const GLshort *v) {
    fprintf(stderr, "stub_glColor4sv\n");
}

void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    fprintf(stderr, "stub_glColor4ub\n");
}

void glColor4ubv(const GLubyte *v) {
    fprintf(stderr, "stub_glColor4ubv\n");
}

void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    fprintf(stderr, "stub_glColor4ui\n");
}

void glColor4uiv(const GLuint *v) {
    fprintf(stderr, "stub_glColor4uiv\n");
}

void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    fprintf(stderr, "stub_glColor4us\n");
}

void glColor4usv(const GLushort *v) {
    fprintf(stderr, "stub_glColor4usv\n");
}

void glEdgeFlag(GLboolean flag) {
    fprintf(stderr, "stub_glEdgeFlag\n");
}

void glEdgeFlagv(const GLboolean *flag) {
    fprintf(stderr, "stub_glEdgeFlagv\n");
}

void glEnd(void) {
    fprintf(stderr, "stub_glEnd\n");
}

void glIndexd(GLdouble c) {
    fprintf(stderr, "stub_glIndexd\n");
}

void glIndexdv(const GLdouble *c) {
    fprintf(stderr, "stub_glIndexdv\n");
}

void glIndexf(GLfloat c) {
    fprintf(stderr, "stub_glIndexf\n");
}

void glIndexfv(const GLfloat *c) {
    fprintf(stderr, "stub_glIndexfv\n");
}

void glIndexi(GLint c) {
    fprintf(stderr, "stub_glIndexi\n");
}

void glIndexiv(const GLint *c) {
    fprintf(stderr, "stub_glIndexiv\n");
}

void glIndexs(GLshort c) {
    fprintf(stderr, "stub_glIndexs\n");
}

void glIndexsv(const GLshort *c) {
    fprintf(stderr, "stub_glIndexsv\n");
}

void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    fprintf(stderr, "stub_glNormal3b\n");
}

void glNormal3bv(const GLbyte *v) {
    fprintf(stderr, "stub_glNormal3bv\n");
}

void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    fprintf(stderr, "stub_glNormal3d\n");
}

void glNormal3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glNormal3dv\n");
}

void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    fprintf(stderr, "stub_glNormal3f\n");
}

void glNormal3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glNormal3fv\n");
}

void glNormal3i(GLint nx, GLint ny, GLint nz) {
    fprintf(stderr, "stub_glNormal3i\n");
}

void glNormal3iv(const GLint *v) {
    fprintf(stderr, "stub_glNormal3iv\n");
}

void glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    fprintf(stderr, "stub_glNormal3s\n");
}

void glNormal3sv(const GLshort *v) {
    fprintf(stderr, "stub_glNormal3sv\n");
}

void glRasterPos2d(GLdouble x, GLdouble y) {
    fprintf(stderr, "stub_glRasterPos2d\n");
}

void glRasterPos2dv(const GLdouble *v) {
    fprintf(stderr, "stub_glRasterPos2dv\n");
}

void glRasterPos2f(GLfloat x, GLfloat y) {
    fprintf(stderr, "stub_glRasterPos2f\n");
}

void glRasterPos2fv(const GLfloat *v) {
    fprintf(stderr, "stub_glRasterPos2fv\n");
}

void glRasterPos2i(GLint x, GLint y) {
    fprintf(stderr, "stub_glRasterPos2i\n");
}

void glRasterPos2iv(const GLint *v) {
    fprintf(stderr, "stub_glRasterPos2iv\n");
}

void glRasterPos2s(GLshort x, GLshort y) {
    fprintf(stderr, "stub_glRasterPos2s\n");
}

void glRasterPos2sv(const GLshort *v) {
    fprintf(stderr, "stub_glRasterPos2sv\n");
}

void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glRasterPos3d\n");
}

void glRasterPos3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glRasterPos3dv\n");
}

void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glRasterPos3f\n");
}

void glRasterPos3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glRasterPos3fv\n");
}

void glRasterPos3i(GLint x, GLint y, GLint z) {
    fprintf(stderr, "stub_glRasterPos3i\n");
}

void glRasterPos3iv(const GLint *v) {
    fprintf(stderr, "stub_glRasterPos3iv\n");
}

void glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    fprintf(stderr, "stub_glRasterPos3s\n");
}

void glRasterPos3sv(const GLshort *v) {
    fprintf(stderr, "stub_glRasterPos3sv\n");
}

void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    fprintf(stderr, "stub_glRasterPos4d\n");
}

void glRasterPos4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glRasterPos4dv\n");
}

void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    fprintf(stderr, "stub_glRasterPos4f\n");
}

void glRasterPos4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glRasterPos4fv\n");
}

void glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    fprintf(stderr, "stub_glRasterPos4i\n");
}

void glRasterPos4iv(const GLint *v) {
    fprintf(stderr, "stub_glRasterPos4iv\n");
}

void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    fprintf(stderr, "stub_glRasterPos4s\n");
}

void glRasterPos4sv(const GLshort *v) {
    fprintf(stderr, "stub_glRasterPos4sv\n");
}

void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    fprintf(stderr, "stub_glRectd\n");
}

void glRectdv(const GLdouble *v1, const GLdouble *v2) {
    fprintf(stderr, "stub_glRectdv\n");
}

void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    fprintf(stderr, "stub_glRectf\n");
}

void glRectfv(const GLfloat *v1, const GLfloat *v2) {
    fprintf(stderr, "stub_glRectfv\n");
}

void glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    fprintf(stderr, "stub_glRecti\n");
}

void glRectiv(const GLint *v1, const GLint *v2) {
    fprintf(stderr, "stub_glRectiv\n");
}

void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    fprintf(stderr, "stub_glRects\n");
}

void glRectsv(const GLshort *v1, const GLshort *v2) {
    fprintf(stderr, "stub_glRectsv\n");
}

void glTexCoord1d(GLdouble s) {
    fprintf(stderr, "stub_glTexCoord1d\n");
}

void glTexCoord1dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord1dv\n");
}

void glTexCoord1f(GLfloat s) {
    fprintf(stderr, "stub_glTexCoord1f\n");
}

void glTexCoord1fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord1fv\n");
}

void glTexCoord1i(GLint s) {
    fprintf(stderr, "stub_glTexCoord1i\n");
}

void glTexCoord1iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord1iv\n");
}

void glTexCoord1s(GLshort s) {
    fprintf(stderr, "stub_glTexCoord1s\n");
}

void glTexCoord1sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord1sv\n");
}

void glTexCoord2d(GLdouble s, GLdouble t) {
    fprintf(stderr, "stub_glTexCoord2d\n");
}

void glTexCoord2dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord2dv\n");
}

void glTexCoord2f(GLfloat s, GLfloat t) {
    fprintf(stderr, "stub_glTexCoord2f\n");
}

void glTexCoord2fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord2fv\n");
}

void glTexCoord2i(GLint s, GLint t) {
    fprintf(stderr, "stub_glTexCoord2i\n");
}

void glTexCoord2iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord2iv\n");
}

void glTexCoord2s(GLshort s, GLshort t) {
    fprintf(stderr, "stub_glTexCoord2s\n");
}

void glTexCoord2sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord2sv\n");
}

void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    fprintf(stderr, "stub_glTexCoord3d\n");
}

void glTexCoord3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord3dv\n");
}

void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    fprintf(stderr, "stub_glTexCoord3f\n");
}

void glTexCoord3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord3fv\n");
}

void glTexCoord3i(GLint s, GLint t, GLint r) {
    fprintf(stderr, "stub_glTexCoord3i\n");
}

void glTexCoord3iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord3iv\n");
}

void glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    fprintf(stderr, "stub_glTexCoord3s\n");
}

void glTexCoord3sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord3sv\n");
}

void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    fprintf(stderr, "stub_glTexCoord4d\n");
}

void glTexCoord4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glTexCoord4dv\n");
}

void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    fprintf(stderr, "stub_glTexCoord4f\n");
}

void glTexCoord4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glTexCoord4fv\n");
}

void glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    fprintf(stderr, "stub_glTexCoord4i\n");
}

void glTexCoord4iv(const GLint *v) {
    fprintf(stderr, "stub_glTexCoord4iv\n");
}

void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    fprintf(stderr, "stub_glTexCoord4s\n");
}

void glTexCoord4sv(const GLshort *v) {
    fprintf(stderr, "stub_glTexCoord4sv\n");
}

void glVertex2d(GLdouble x, GLdouble y) {
    fprintf(stderr, "stub_glVertex2d\n");
}

void glVertex2dv(const GLdouble *v) {
    fprintf(stderr, "stub_glVertex2dv\n");
}

void glVertex2f(GLfloat x, GLfloat y) {
    fprintf(stderr, "stub_glVertex2f\n");
}

void glVertex2fv(const GLfloat *v) {
    fprintf(stderr, "stub_glVertex2fv\n");
}

void glVertex2i(GLint x, GLint y) {
    fprintf(stderr, "stub_glVertex2i\n");
}

void glVertex2iv(const GLint *v) {
    fprintf(stderr, "stub_glVertex2iv\n");
}

void glVertex2s(GLshort x, GLshort y) {
    fprintf(stderr, "stub_glVertex2s\n");
}

void glVertex2sv(const GLshort *v) {
    fprintf(stderr, "stub_glVertex2sv\n");
}

void glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glVertex3d\n");
}

void glVertex3dv(const GLdouble *v) {
    fprintf(stderr, "stub_glVertex3dv\n");
}

void glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glVertex3f\n");
}

void glVertex3fv(const GLfloat *v) {
    fprintf(stderr, "stub_glVertex3fv\n");
}

void glVertex3i(GLint x, GLint y, GLint z) {
    fprintf(stderr, "stub_glVertex3i\n");
}

void glVertex3iv(const GLint *v) {
    fprintf(stderr, "stub_glVertex3iv\n");
}

void glVertex3s(GLshort x, GLshort y, GLshort z) {
    fprintf(stderr, "stub_glVertex3s\n");
}

void glVertex3sv(const GLshort *v) {
    fprintf(stderr, "stub_glVertex3sv\n");
}

void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    fprintf(stderr, "stub_glVertex4d\n");
}

void glVertex4dv(const GLdouble *v) {
    fprintf(stderr, "stub_glVertex4dv\n");
}

void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    fprintf(stderr, "stub_glVertex4f\n");
}

void glVertex4fv(const GLfloat *v) {
    fprintf(stderr, "stub_glVertex4fv\n");
}

void glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    fprintf(stderr, "stub_glVertex4i\n");
}

void glVertex4iv(const GLint *v) {
    fprintf(stderr, "stub_glVertex4iv\n");
}

void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    fprintf(stderr, "stub_glVertex4s\n");
}

void glVertex4sv(const GLshort *v) {
    fprintf(stderr, "stub_glVertex4sv\n");
}

void glClipPlane(GLenum plane, const GLdouble *equation) {
    fprintf(stderr, "stub_glClipPlane\n");
}

void glColorMaterial(GLenum face, GLenum mode) {
    fprintf(stderr, "stub_glColorMaterial\n");
}

void glCullFace(GLenum mode) {
    fprintf(stderr, "stub_glCullFace\n");
}

void glFogf(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glFogf\n");
}

void glFogfv(GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glFogfv\n");
}

void glFogi(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glFogi\n");
}

void glFogiv(GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glFogiv\n");
}

void glFrontFace(GLenum mode) {
    fprintf(stderr, "stub_glFrontFace\n");
}

void glHint(GLenum target, GLenum mode) {
    fprintf(stderr, "stub_glHint\n");
}

void glLightf(GLenum light, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glLightf\n");
}

void glLightfv(GLenum light, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glLightfv\n");
}

void glLighti(GLenum light, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glLighti\n");
}

void glLightiv(GLenum light, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glLightiv\n");
}

void glLightModelf(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glLightModelf\n");
}

void glLightModelfv(GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glLightModelfv\n");
}

void glLightModeli(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glLightModeli\n");
}

void glLightModeliv(GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glLightModeliv\n");
}

void glLineStipple(GLint factor, GLushort pattern) {
    fprintf(stderr, "stub_glLineStipple\n");
}

void glLineWidth(GLfloat width) {
    fprintf(stderr, "stub_glLineWidth\n");
}

void glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glMaterialf\n");
}

void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glMaterialfv\n");
}

void glMateriali(GLenum face, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glMateriali\n");
}

void glMaterialiv(GLenum face, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glMaterialiv\n");
}

void glPointSize(GLfloat size) {
    fprintf(stderr, "stub_glPointSize\n");
}

void glPolygonMode(GLenum face, GLenum mode) {
    fprintf(stderr, "stub_glPolygonMode\n");
}

void glPolygonStipple(const GLubyte *mask) {
    fprintf(stderr, "stub_glPolygonStipple\n");
}

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glScissor\n");
}

void glShadeModel(GLenum mode) {
    fprintf(stderr, "stub_glShadeModel\n");
}

void glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glTexParameterf\n");
}

void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexParameterfv\n");
}

void glTexParameteri(GLenum target, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glTexParameteri\n");
}

void glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexParameteriv\n");
}

void glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage1D\n");
}

void glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage2D\n");
}

void glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glTexEnvf\n");
}

void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexEnvfv\n");
}

void glTexEnvi(GLenum target, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glTexEnvi\n");
}

void glTexEnviv(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexEnviv\n");
}

void glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    fprintf(stderr, "stub_glTexGend\n");
}

void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {
    fprintf(stderr, "stub_glTexGendv\n");
}

void glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glTexGenf\n");
}

void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexGenfv\n");
}

void glTexGeni(GLenum coord, GLenum pname, GLint param) {
    fprintf(stderr, "stub_glTexGeni\n");
}

void glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexGeniv\n");
}

void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {
    fprintf(stderr, "stub_glFeedbackBuffer\n");
}

void glSelectBuffer(GLsizei size, GLuint *buffer) {
    fprintf(stderr, "stub_glSelectBuffer\n");
}

GLint glRenderMode(GLenum mode) {
    fprintf(stderr, "stub_glRenderMode\n");
    return 0;
}

void glInitNames(void) {
    fprintf(stderr, "stub_glInitNames\n");
}

void glLoadName(GLuint name) {
    fprintf(stderr, "stub_glLoadName\n");
}

void glPassThrough(GLfloat token) {
    fprintf(stderr, "stub_glPassThrough\n");
}

void glPopName(void) {
    fprintf(stderr, "stub_glPopName\n");
}

void glPushName(GLuint name) {
    fprintf(stderr, "stub_glPushName\n");
}

void glDrawBuffer(GLenum mode) {
    fprintf(stderr, "stub_glDrawBuffer\n");
}

void glClear(GLbitfield mask) {
    fprintf(stderr, "stub_glClear\n");
}

void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    fprintf(stderr, "stub_glClearAccum\n");
}

void glClearIndex(GLfloat c) {
    fprintf(stderr, "stub_glClearIndex\n");
}

void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    fprintf(stderr, "stub_glClearColor\n");
}

void glClearStencil(GLint s) {
    fprintf(stderr, "stub_glClearStencil\n");
}

void glClearDepth(GLclampd depth) {
    fprintf(stderr, "stub_glClearDepth\n");
}

void glStencilMask(GLuint mask) {
    fprintf(stderr, "stub_glStencilMask\n");
}

void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    fprintf(stderr, "stub_glColorMask\n");
}

void glDepthMask(GLboolean flag) {
    fprintf(stderr, "stub_glDepthMask\n");
}

void glIndexMask(GLuint mask) {
    fprintf(stderr, "stub_glIndexMask\n");
}

void glAccum(GLenum op, GLfloat value) {
    fprintf(stderr, "stub_glAccum\n");
}

void glDisable(GLenum cap) {
    fprintf(stderr, "stub_glDisable\n");
}

void glEnable(GLenum cap) {
    fprintf(stderr, "stub_glEnable\n");
}

void glFinish(void) {
    fprintf(stderr, "stub_glFinish\n");
}

void glFlush(void) {
    fprintf(stderr, "stub_glFlush\n");
}

void glPopAttrib(void) {
    fprintf(stderr, "stub_glPopAttrib\n");
}

void glPushAttrib(GLbitfield mask) {
    fprintf(stderr, "stub_glPushAttrib\n");
}

void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) {
    fprintf(stderr, "stub_glMap1d\n");
}

void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) {
    fprintf(stderr, "stub_glMap1f\n");
}

void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) {
    fprintf(stderr, "stub_glMap2d\n");
}

void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) {
    fprintf(stderr, "stub_glMap2f\n");
}

void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    fprintf(stderr, "stub_glMapGrid1d\n");
}

void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    fprintf(stderr, "stub_glMapGrid1f\n");
}

void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    fprintf(stderr, "stub_glMapGrid2d\n");
}

void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    fprintf(stderr, "stub_glMapGrid2f\n");
}

void glEvalCoord1d(GLdouble u) {
    fprintf(stderr, "stub_glEvalCoord1d\n");
}

void glEvalCoord1dv(const GLdouble *u) {
    fprintf(stderr, "stub_glEvalCoord1dv\n");
}

void glEvalCoord1f(GLfloat u) {
    fprintf(stderr, "stub_glEvalCoord1f\n");
}

void glEvalCoord1fv(const GLfloat *u) {
    fprintf(stderr, "stub_glEvalCoord1fv\n");
}

void glEvalCoord2d(GLdouble u, GLdouble v) {
    fprintf(stderr, "stub_glEvalCoord2d\n");
}

void glEvalCoord2dv(const GLdouble *u) {
    fprintf(stderr, "stub_glEvalCoord2dv\n");
}

void glEvalCoord2f(GLfloat u, GLfloat v) {
    fprintf(stderr, "stub_glEvalCoord2f\n");
}

void glEvalCoord2fv(const GLfloat *u) {
    fprintf(stderr, "stub_glEvalCoord2fv\n");
}

void glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    fprintf(stderr, "stub_glEvalMesh1\n");
}

void glEvalPoint1(GLint i) {
    fprintf(stderr, "stub_glEvalPoint1\n");
}

void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    fprintf(stderr, "stub_glEvalMesh2\n");
}

void glEvalPoint2(GLint i, GLint j) {
    fprintf(stderr, "stub_glEvalPoint2\n");
}

void glAlphaFunc(GLenum func, GLclampf ref) {
    fprintf(stderr, "stub_glAlphaFunc\n");
}

void glBlendFunc(GLenum sfactor, GLenum dfactor) {
    fprintf(stderr, "stub_glBlendFunc\n");
}

void glLogicOp(GLenum opcode) {
    fprintf(stderr, "stub_glLogicOp\n");
}

void glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    fprintf(stderr, "stub_glStencilFunc\n");
}

void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    fprintf(stderr, "stub_glStencilOp\n");
}

void glDepthFunc(GLenum func) {
    fprintf(stderr, "stub_glDepthFunc\n");
}

void glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    fprintf(stderr, "stub_glPixelZoom\n");
}

void glPixelTransferf(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glPixelTransferf\n");
}

void glPixelTransferi(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glPixelTransferi\n");
}

void glPixelStoref(GLenum pname, GLfloat param) {
    fprintf(stderr, "stub_glPixelStoref\n");
}

void glPixelStorei(GLenum pname, GLint param) {
    fprintf(stderr, "stub_glPixelStorei\n");
}

void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {
    fprintf(stderr, "stub_glPixelMapfv\n");
}

void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {
    fprintf(stderr, "stub_glPixelMapuiv\n");
}

void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {
    fprintf(stderr, "stub_glPixelMapusv\n");
}

void glReadBuffer(GLenum mode) {
    fprintf(stderr, "stub_glReadBuffer\n");
}

void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    fprintf(stderr, "stub_glCopyPixels\n");
}

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
    fprintf(stderr, "stub_glReadPixels\n");
}

void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glDrawPixels\n");
}

void glGetBooleanv(GLenum pname, GLboolean *params) {
    fprintf(stderr, "stub_glGetBooleanv\n");
}

void glGetClipPlane(GLenum plane, GLdouble *equation) {
    fprintf(stderr, "stub_glGetClipPlane\n");
}

void glGetDoublev(GLenum pname, GLdouble *params) {
    fprintf(stderr, "stub_glGetDoublev\n");
}

GLenum glGetError(void) {
    fprintf(stderr, "stub_glGetError\n");
    return 0;
}

void glGetFloatv(GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetFloatv\n");
}

void glGetIntegerv(GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetIntegerv\n");
}

void glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetLightfv\n");
}

void glGetLightiv(GLenum light, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetLightiv\n");
}

void glGetMapdv(GLenum target, GLenum query, GLdouble *v) {
    fprintf(stderr, "stub_glGetMapdv\n");
}

void glGetMapfv(GLenum target, GLenum query, GLfloat *v) {
    fprintf(stderr, "stub_glGetMapfv\n");
}

void glGetMapiv(GLenum target, GLenum query, GLint *v) {
    fprintf(stderr, "stub_glGetMapiv\n");
}

void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetMaterialfv\n");
}

void glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetMaterialiv\n");
}

void glGetPixelMapfv(GLenum map, GLfloat *values) {
    fprintf(stderr, "stub_glGetPixelMapfv\n");
}

void glGetPixelMapuiv(GLenum map, GLuint *values) {
    fprintf(stderr, "stub_glGetPixelMapuiv\n");
}

void glGetPixelMapusv(GLenum map, GLushort *values) {
    fprintf(stderr, "stub_glGetPixelMapusv\n");
}

void glGetPolygonStipple(GLubyte *mask) {
    fprintf(stderr, "stub_glGetPolygonStipple\n");
}

const GLubyte * glGetString(GLenum name) {
    fprintf(stderr, "stub_glGetString\n");
    return 0;
}

void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexEnvfv\n");
}

void glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexEnviv\n");
}

void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {
    fprintf(stderr, "stub_glGetTexGendv\n");
}

void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexGenfv\n");
}

void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexGeniv\n");
}

void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {
    fprintf(stderr, "stub_glGetTexImage\n");
}

void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexParameterfv\n");
}

void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexParameteriv\n");
}

void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexLevelParameterfv\n");
}

void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexLevelParameteriv\n");
}

GLboolean glIsEnabled(GLenum cap) {
    fprintf(stderr, "stub_glIsEnabled\n");
    return 0;
}

GLboolean glIsList(GLuint list) {
    fprintf(stderr, "stub_glIsList\n");
    return 0;
}

void glDepthRange(GLclampd zNear, GLclampd zFar) {
    fprintf(stderr, "stub_glDepthRange\n");
}

void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    fprintf(stderr, "stub_glFrustum\n");
}

void glLoadIdentity(void) {
    fprintf(stderr, "stub_glLoadIdentity\n");
}

void glLoadMatrixf(const GLfloat *m) {
    fprintf(stderr, "stub_glLoadMatrixf\n");
}

void glLoadMatrixd(const GLdouble *m) {
    fprintf(stderr, "stub_glLoadMatrixd\n");
}

void glMatrixMode(GLenum mode) {
    fprintf(stderr, "stub_glMatrixMode\n");
}

void glMultMatrixf(const GLfloat *m) {
    fprintf(stderr, "stub_glMultMatrixf\n");
}

void glMultMatrixd(const GLdouble *m) {
    fprintf(stderr, "stub_glMultMatrixd\n");
}

void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    fprintf(stderr, "stub_glOrtho\n");
}

void glPopMatrix(void) {
    fprintf(stderr, "stub_glPopMatrix\n");
}

void glPushMatrix(void) {
    fprintf(stderr, "stub_glPushMatrix\n");
}

void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glRotated\n");
}

void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glRotatef\n");
}

void glScaled(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glScaled\n");
}

void glScalef(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glScalef\n");
}

void glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    fprintf(stderr, "stub_glTranslated\n");
}

void glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    fprintf(stderr, "stub_glTranslatef\n");
}

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glViewport\n");
}

void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    fprintf(stderr, "stub_glBlendColorEXT\n");
}

void glBlendEquationEXT(GLenum mode) {
    fprintf(stderr, "stub_glBlendEquationEXT\n");
}

void glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
    fprintf(stderr, "stub_glPolygonOffsetEXT\n");
}

void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage1DEXT\n");
}

void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage2DEXT\n");
}

void glSampleMaskSGIS(GLclampf value, GLboolean invert) {
    fprintf(stderr, "stub_glSampleMaskSGIS\n");
}

void glSamplePatternSGIS(GLenum pattern) {
    fprintf(stderr, "stub_glSamplePatternSGIS\n");
}

void glTagSampleBufferSGIX(void) {
    fprintf(stderr, "stub_glTagSampleBufferSGIX\n");
}

void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {
    fprintf(stderr, "stub_glConvolutionFilter1DEXT\n");
}

void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {
    fprintf(stderr, "stub_glConvolutionFilter2DEXT\n");
}

void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
    fprintf(stderr, "stub_glConvolutionParameterfEXT\n");
}

void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glConvolutionParameterfvEXT\n");
}

void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
    fprintf(stderr, "stub_glConvolutionParameteriEXT\n");
}

void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glConvolutionParameterivEXT\n");
}

void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    fprintf(stderr, "stub_glCopyConvolutionFilter1DEXT\n");
}

void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glCopyConvolutionFilter2DEXT\n");
}

void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {
    fprintf(stderr, "stub_glGetConvolutionFilterEXT\n");
}

void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetConvolutionParameterfvEXT\n");
}

void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetConvolutionParameterivEXT\n");
}

void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {
    fprintf(stderr, "stub_glGetSeparableFilterEXT\n");
}

void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {
    fprintf(stderr, "stub_glSeparableFilter2DEXT\n");
}

void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    fprintf(stderr, "stub_glGetHistogramEXT\n");
}

void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetHistogramParameterfvEXT\n");
}

void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetHistogramParameterivEXT\n");
}

void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
    fprintf(stderr, "stub_glGetMinmaxEXT\n");
}

void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetMinmaxParameterfvEXT\n");
}

void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetMinmaxParameterivEXT\n");
}

void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
    fprintf(stderr, "stub_glHistogramEXT\n");
}

void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
    fprintf(stderr, "stub_glMinmaxEXT\n");
}

void glResetHistogramEXT(GLenum target) {
    fprintf(stderr, "stub_glResetHistogramEXT\n");
}

void glResetMinmaxEXT(GLenum target) {
    fprintf(stderr, "stub_glResetMinmaxEXT\n");
}

void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage3DEXT\n");
}

void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage3DEXT\n");
}

void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    fprintf(stderr, "stub_glDetailTexFuncSGIS\n");
}

void glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {
    fprintf(stderr, "stub_glGetDetailTexFuncSGIS\n");
}

void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
    fprintf(stderr, "stub_glSharpenTexFuncSGIS\n");
}

void glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {
    fprintf(stderr, "stub_glGetSharpenTexFuncSGIS\n");
}

void glArrayElementEXT(GLint i) {
    fprintf(stderr, "stub_glArrayElementEXT\n");
}

void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glColorPointerEXT\n");
}

void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
    fprintf(stderr, "stub_glDrawArraysEXT\n");
}

void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {
    fprintf(stderr, "stub_glEdgeFlagPointerEXT\n");
}

void glGetPointervEXT(GLenum pname, GLvoid* *params) {
    fprintf(stderr, "stub_glGetPointervEXT\n");
}

void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glIndexPointerEXT\n");
}

void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glNormalPointerEXT\n");
}

void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glTexCoordPointerEXT\n");
}

void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
    fprintf(stderr, "stub_glVertexPointerEXT\n");
}

GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {
    fprintf(stderr, "stub_glAreTexturesResidentEXT\n");
    return 0;
}

void glBindTextureEXT(GLenum target, GLuint texture) {
    fprintf(stderr, "stub_glBindTextureEXT\n");
}

void glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {
    fprintf(stderr, "stub_glDeleteTexturesEXT\n");
}

void glGenTexturesEXT(GLsizei n, GLuint *textures) {
    fprintf(stderr, "stub_glGenTexturesEXT\n");
}

GLboolean glIsTextureEXT(GLuint texture) {
    fprintf(stderr, "stub_glIsTextureEXT\n");
    return 0;
}

void glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    fprintf(stderr, "stub_glPrioritizeTexturesEXT\n");
}

void glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {
    fprintf(stderr, "stub_glColorTableSGI\n");
}

void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glColorTableParameterfvSGI\n");
}

void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glColorTableParameterivSGI\n");
}

void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
    fprintf(stderr, "stub_glCopyColorTableSGI\n");
}

void glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table) {
    fprintf(stderr, "stub_glGetColorTableSGI\n");
}

void glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetColorTableParameterfvSGI\n");
}

void glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetColorTableParameterivSGI\n");
}

void glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
    fprintf(stderr, "stub_glGetTexColorTableParameterfvSGI\n");
}

void glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
    fprintf(stderr, "stub_glGetTexColorTableParameterivSGI\n");
}

void glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
    fprintf(stderr, "stub_glTexColorTableParameterfvSGI\n");
}

void glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
    fprintf(stderr, "stub_glTexColorTableParameterivSGI\n");
}

void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    fprintf(stderr, "stub_glCopyTexImage1DEXT\n");
}

void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    fprintf(stderr, "stub_glCopyTexImage2DEXT\n");
}

void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    fprintf(stderr, "stub_glCopyTexSubImage1DEXT\n");
}

void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glCopyTexSubImage2DEXT\n");
}

void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    fprintf(stderr, "stub_glCopyTexSubImage3DEXT\n");
}

void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexImage4DSGIS\n");
}

void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {
    fprintf(stderr, "stub_glTexSubImage4DSGIS\n");
}

void glPixelTexGenSGIX(GLenum mode) {
    fprintf(stderr, "stub_glPixelTexGenSGIX\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_glapi.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void glNewList(GLuint list, GLenum mode) {
    typedef void (*__GLSdispatch)(GLuint, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[64])(list, mode);
}

void glEndList(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[65])();
}

void glCallList(GLuint list) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[66])(list);
}

void glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[67])(n, type, lists);
}

void glDeleteLists(GLuint list, GLsizei range) {
    typedef void (*__GLSdispatch)(GLuint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[68])(list, range);
}

GLuint glGenLists(GLsizei range) {
    typedef GLuint (*__GLSdispatch)(GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[69])(range);
}

void glListBase(GLuint base) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[70])(base);
}

void glBegin(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[71])(mode);
}

void glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[72])(width, height, xorig, yorig, xmove, ymove, bitmap);
}

void glColor3b(GLbyte red, GLbyte green, GLbyte blue) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[73])(red, green, blue);
}

void glColor3bv(const GLbyte *v) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[74])(v);
}

void glColor3d(GLdouble red, GLdouble green, GLdouble blue) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[75])(red, green, blue);
}

void glColor3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[76])(v);
}

void glColor3f(GLfloat red, GLfloat green, GLfloat blue) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[77])(red, green, blue);
}

void glColor3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[78])(v);
}

void glColor3i(GLint red, GLint green, GLint blue) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[79])(red, green, blue);
}

void glColor3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[80])(v);
}

void glColor3s(GLshort red, GLshort green, GLshort blue) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[81])(red, green, blue);
}

void glColor3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[82])(v);
}

void glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[83])(red, green, blue);
}

void glColor3ubv(const GLubyte *v) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[84])(v);
}

void glColor3ui(GLuint red, GLuint green, GLuint blue) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[85])(red, green, blue);
}

void glColor3uiv(const GLuint *v) {
    typedef void (*__GLSdispatch)(const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[86])(v);
}

void glColor3us(GLushort red, GLushort green, GLushort blue) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[87])(red, green, blue);
}

void glColor3usv(const GLushort *v) {
    typedef void (*__GLSdispatch)(const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[88])(v);
}

void glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[89])(red, green, blue, alpha);
}

void glColor4bv(const GLbyte *v) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[90])(v);
}

void glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[91])(red, green, blue, alpha);
}

void glColor4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[92])(v);
}

void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[93])(red, green, blue, alpha);
}

void glColor4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[94])(v);
}

void glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[95])(red, green, blue, alpha);
}

void glColor4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[96])(v);
}

void glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[97])(red, green, blue, alpha);
}

void glColor4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[98])(v);
}

void glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
    typedef void (*__GLSdispatch)(GLubyte, GLubyte, GLubyte, GLubyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[99])(red, green, blue, alpha);
}

void glColor4ubv(const GLubyte *v) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[100])(v);
}

void glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[101])(red, green, blue, alpha);
}

void glColor4uiv(const GLuint *v) {
    typedef void (*__GLSdispatch)(const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[102])(v);
}

void glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
    typedef void (*__GLSdispatch)(GLushort, GLushort, GLushort, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[103])(red, green, blue, alpha);
}

void glColor4usv(const GLushort *v) {
    typedef void (*__GLSdispatch)(const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[104])(v);
}

void glEdgeFlag(GLboolean flag) {
    typedef void (*__GLSdispatch)(GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[105])(flag);
}

void glEdgeFlagv(const GLboolean *flag) {
    typedef void (*__GLSdispatch)(const GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[106])(flag);
}

void glEnd(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[107])();
}

void glIndexd(GLdouble c) {
    typedef void (*__GLSdispatch)(GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[108])(c);
}

void glIndexdv(const GLdouble *c) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[109])(c);
}

void glIndexf(GLfloat c) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[110])(c);
}

void glIndexfv(const GLfloat *c) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[111])(c);
}

void glIndexi(GLint c) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[112])(c);
}

void glIndexiv(const GLint *c) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[113])(c);
}

void glIndexs(GLshort c) {
    typedef void (*__GLSdispatch)(GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[114])(c);
}

void glIndexsv(const GLshort *c) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[115])(c);
}

void glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
    typedef void (*__GLSdispatch)(GLbyte, GLbyte, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[116])(nx, ny, nz);
}

void glNormal3bv(const GLbyte *v) {
    typedef void (*__GLSdispatch)(const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[117])(v);
}

void glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[118])(nx, ny, nz);
}

void glNormal3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[119])(v);
}

void glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[120])(nx, ny, nz);
}

void glNormal3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[121])(v);
}

void glNormal3i(GLint nx, GLint ny, GLint nz) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[122])(nx, ny, nz);
}

void glNormal3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[123])(v);
}

void glNormal3s(GLshort nx, GLshort ny, GLshort nz) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[124])(nx, ny, nz);
}

void glNormal3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[125])(v);
}

void glRasterPos2d(GLdouble x, GLdouble y) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[126])(x, y);
}

void glRasterPos2dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[127])(v);
}

void glRasterPos2f(GLfloat x, GLfloat y) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[128])(x, y);
}

void glRasterPos2fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[129])(v);
}

void glRasterPos2i(GLint x, GLint y) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[130])(x, y);
}

void glRasterPos2iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[131])(v);
}

void glRasterPos2s(GLshort x, GLshort y) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[132])(x, y);
}

void glRasterPos2sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[133])(v);
}

void glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[134])(x, y, z);
}

void glRasterPos3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[135])(v);
}

void glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[136])(x, y, z);
}

void glRasterPos3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[137])(v);
}

void glRasterPos3i(GLint x, GLint y, GLint z) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[138])(x, y, z);
}

void glRasterPos3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[139])(v);
}

void glRasterPos3s(GLshort x, GLshort y, GLshort z) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[140])(x, y, z);
}

void glRasterPos3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[141])(v);
}

void glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[142])(x, y, z, w);
}

void glRasterPos4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[143])(v);
}

void glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[144])(x, y, z, w);
}

void glRasterPos4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[145])(v);
}

void glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[146])(x, y, z, w);
}

void glRasterPos4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[147])(v);
}

void glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[148])(x, y, z, w);
}

void glRasterPos4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[149])(v);
}

void glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[150])(x1, y1, x2, y2);
}

void glRectdv(const GLdouble *v1, const GLdouble *v2) {
    typedef void (*__GLSdispatch)(const GLdouble *, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[151])(v1, v2);
}

void glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[152])(x1, y1, x2, y2);
}

void glRectfv(const GLfloat *v1, const GLfloat *v2) {
    typedef void (*__GLSdispatch)(const GLfloat *, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[153])(v1, v2);
}

void glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[154])(x1, y1, x2, y2);
}

void glRectiv(const GLint *v1, const GLint *v2) {
    typedef void (*__GLSdispatch)(const GLint *, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[155])(v1, v2);
}

void glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[156])(x1, y1, x2, y2);
}

void glRectsv(const GLshort *v1, const GLshort *v2) {
    typedef void (*__GLSdispatch)(const GLshort *, const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[157])(v1, v2);
}

void glTexCoord1d(GLdouble s) {
    typedef void (*__GLSdispatch)(GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[158])(s);
}

void glTexCoord1dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[159])(v);
}

void glTexCoord1f(GLfloat s) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[160])(s);
}

void glTexCoord1fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[161])(v);
}

void glTexCoord1i(GLint s) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[162])(s);
}

void glTexCoord1iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[163])(v);
}

void glTexCoord1s(GLshort s) {
    typedef void (*__GLSdispatch)(GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[164])(s);
}

void glTexCoord1sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[165])(v);
}

void glTexCoord2d(GLdouble s, GLdouble t) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[166])(s, t);
}

void glTexCoord2dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[167])(v);
}

void glTexCoord2f(GLfloat s, GLfloat t) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[168])(s, t);
}

void glTexCoord2fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[169])(v);
}

void glTexCoord2i(GLint s, GLint t) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[170])(s, t);
}

void glTexCoord2iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[171])(v);
}

void glTexCoord2s(GLshort s, GLshort t) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[172])(s, t);
}

void glTexCoord2sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[173])(v);
}

void glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[174])(s, t, r);
}

void glTexCoord3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[175])(v);
}

void glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[176])(s, t, r);
}

void glTexCoord3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[177])(v);
}

void glTexCoord3i(GLint s, GLint t, GLint r) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[178])(s, t, r);
}

void glTexCoord3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[179])(v);
}

void glTexCoord3s(GLshort s, GLshort t, GLshort r) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[180])(s, t, r);
}

void glTexCoord3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[181])(v);
}

void glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[182])(s, t, r, q);
}

void glTexCoord4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[183])(v);
}

void glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[184])(s, t, r, q);
}

void glTexCoord4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[185])(v);
}

void glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[186])(s, t, r, q);
}

void glTexCoord4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[187])(v);
}

void glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[188])(s, t, r, q);
}

void glTexCoord4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[189])(v);
}

void glVertex2d(GLdouble x, GLdouble y) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[190])(x, y);
}

void glVertex2dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[191])(v);
}

void glVertex2f(GLfloat x, GLfloat y) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[192])(x, y);
}

void glVertex2fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[193])(v);
}

void glVertex2i(GLint x, GLint y) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[194])(x, y);
}

void glVertex2iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[195])(v);
}

void glVertex2s(GLshort x, GLshort y) {
    typedef void (*__GLSdispatch)(GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[196])(x, y);
}

void glVertex2sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[197])(v);
}

void glVertex3d(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[198])(x, y, z);
}

void glVertex3dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[199])(v);
}

void glVertex3f(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[200])(x, y, z);
}

void glVertex3fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[201])(v);
}

void glVertex3i(GLint x, GLint y, GLint z) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[202])(x, y, z);
}

void glVertex3iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[203])(v);
}

void glVertex3s(GLshort x, GLshort y, GLshort z) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[204])(x, y, z);
}

void glVertex3sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[205])(v);
}

void glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[206])(x, y, z, w);
}

void glVertex4dv(const GLdouble *v) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[207])(v);
}

void glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[208])(x, y, z, w);
}

void glVertex4fv(const GLfloat *v) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[209])(v);
}

void glVertex4i(GLint x, GLint y, GLint z, GLint w) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[210])(x, y, z, w);
}

void glVertex4iv(const GLint *v) {
    typedef void (*__GLSdispatch)(const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[211])(v);
}

void glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
    typedef void (*__GLSdispatch)(GLshort, GLshort, GLshort, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[212])(x, y, z, w);
}

void glVertex4sv(const GLshort *v) {
    typedef void (*__GLSdispatch)(const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[213])(v);
}

void glClipPlane(GLenum plane, const GLdouble *equation) {
    typedef void (*__GLSdispatch)(GLenum, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[214])(plane, equation);
}

void glColorMaterial(GLenum face, GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[215])(face, mode);
}

void glCullFace(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[216])(mode);
}

void glFogf(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[217])(pname, param);
}

void glFogfv(GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[218])(pname, params);
}

void glFogi(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[219])(pname, param);
}

void glFogiv(GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[220])(pname, params);
}

void glFrontFace(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[221])(mode);
}

void glHint(GLenum target, GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[222])(target, mode);
}

void glLightf(GLenum light, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[223])(light, pname, param);
}

void glLightfv(GLenum light, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[224])(light, pname, params);
}

void glLighti(GLenum light, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[225])(light, pname, param);
}

void glLightiv(GLenum light, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[226])(light, pname, params);
}

void glLightModelf(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[227])(pname, param);
}

void glLightModelfv(GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[228])(pname, params);
}

void glLightModeli(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[229])(pname, param);
}

void glLightModeliv(GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[230])(pname, params);
}

void glLineStipple(GLint factor, GLushort pattern) {
    typedef void (*__GLSdispatch)(GLint, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[231])(factor, pattern);
}

void glLineWidth(GLfloat width) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[232])(width);
}

void glMaterialf(GLenum face, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[233])(face, pname, param);
}

void glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[234])(face, pname, params);
}

void glMateriali(GLenum face, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[235])(face, pname, param);
}

void glMaterialiv(GLenum face, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[236])(face, pname, params);
}

void glPointSize(GLfloat size) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[237])(size);
}

void glPolygonMode(GLenum face, GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[238])(face, mode);
}

void glPolygonStipple(const GLubyte *mask) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[239])(mask);
}

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[240])(x, y, width, height);
}

void glShadeModel(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[241])(mode);
}

void glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[242])(target, pname, param);
}

void glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[243])(target, pname, params);
}

void glTexParameteri(GLenum target, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[244])(target, pname, param);
}

void glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[245])(target, pname, params);
}

void glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[246])(target, level, components, width, border, format, type, pixels);
}

void glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[247])(target, level, components, width, height, border, format, type, pixels);
}

void glTexEnvf(GLenum target, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[248])(target, pname, param);
}

void glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[249])(target, pname, params);
}

void glTexEnvi(GLenum target, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[250])(target, pname, param);
}

void glTexEnviv(GLenum target, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[251])(target, pname, params);
}

void glTexGend(GLenum coord, GLenum pname, GLdouble param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[252])(coord, pname, param);
}

void glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[253])(coord, pname, params);
}

void glTexGenf(GLenum coord, GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[254])(coord, pname, param);
}

void glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[255])(coord, pname, params);
}

void glTexGeni(GLenum coord, GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[256])(coord, pname, param);
}

void glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[257])(coord, pname, params);
}

void glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {
    typedef void (*__GLSdispatch)(GLsizei, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[258])(size, type, buffer);
}

void glSelectBuffer(GLsizei size, GLuint *buffer) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[259])(size, buffer);
}

GLint glRenderMode(GLenum mode) {
    typedef GLint (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[260])(mode);
}

void glInitNames(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[261])();
}

void glLoadName(GLuint name) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[262])(name);
}

void glPassThrough(GLfloat token) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[263])(token);
}

void glPopName(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[264])();
}

void glPushName(GLuint name) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[265])(name);
}

void glDrawBuffer(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[266])(mode);
}

void glClear(GLbitfield mask) {
    typedef void (*__GLSdispatch)(GLbitfield);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[267])(mask);
}

void glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[268])(red, green, blue, alpha);
}

void glClearIndex(GLfloat c) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[269])(c);
}

void glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[270])(red, green, blue, alpha);
}

void glClearStencil(GLint s) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[271])(s);
}

void glClearDepth(GLclampd depth) {
    typedef void (*__GLSdispatch)(GLclampd);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[272])(depth);
}

void glStencilMask(GLuint mask) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[273])(mask);
}

void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
    typedef void (*__GLSdispatch)(GLboolean, GLboolean, GLboolean, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[274])(red, green, blue, alpha);
}

void glDepthMask(GLboolean flag) {
    typedef void (*__GLSdispatch)(GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[275])(flag);
}

void glIndexMask(GLuint mask) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[276])(mask);
}

void glAccum(GLenum op, GLfloat value) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[277])(op, value);
}

void glDisable(GLenum cap) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[278])(cap);
}

void glEnable(GLenum cap) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[279])(cap);
}

void glFinish(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[280])();
}

void glFlush(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[281])();
}

void glPopAttrib(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[282])();
}

void glPushAttrib(GLbitfield mask) {
    typedef void (*__GLSdispatch)(GLbitfield);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[283])(mask);
}

void glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[284])(target, u1, u2, stride, order, points);
}

void glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[285])(target, u1, u2, stride, order, points);
}

void glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[286])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

void glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[287])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
}

void glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[288])(un, u1, u2);
}

void glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[289])(un, u1, u2);
}

void glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
    typedef void (*__GLSdispatch)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[290])(un, u1, u2, vn, v1, v2);
}

void glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
    typedef void (*__GLSdispatch)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[291])(un, u1, u2, vn, v1, v2);
}

void glEvalCoord1d(GLdouble u) {
    typedef void (*__GLSdispatch)(GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[292])(u);
}

void glEvalCoord1dv(const GLdouble *u) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[293])(u);
}

void glEvalCoord1f(GLfloat u) {
    typedef void (*__GLSdispatch)(GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[294])(u);
}

void glEvalCoord1fv(const GLfloat *u) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[295])(u);
}

void glEvalCoord2d(GLdouble u, GLdouble v) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[296])(u, v);
}

void glEvalCoord2dv(const GLdouble *u) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[297])(u);
}

void glEvalCoord2f(GLfloat u, GLfloat v) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[298])(u, v);
}

void glEvalCoord2fv(const GLfloat *u) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[299])(u);
}

void glEvalMesh1(GLenum mode, GLint i1, GLint i2) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[300])(mode, i1, i2);
}

void glEvalPoint1(GLint i) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[301])(i);
}

void glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[302])(mode, i1, i2, j1, j2);
}

void glEvalPoint2(GLint i, GLint j) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[303])(i, j);
}

void glAlphaFunc(GLenum func, GLclampf ref) {
    typedef void (*__GLSdispatch)(GLenum, GLclampf);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[304])(func, ref);
}

void glBlendFunc(GLenum sfactor, GLenum dfactor) {
    typedef void (*__GLSdispatch)(GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[305])(sfactor, dfactor);
}

void glLogicOp(GLenum opcode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[306])(opcode);
}

void glStencilFunc(GLenum func, GLint ref, GLuint mask) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[307])(func, ref, mask);
}

void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[308])(fail, zfail, zpass);
}

void glDepthFunc(GLenum func) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[309])(func);
}

void glPixelZoom(GLfloat xfactor, GLfloat yfactor) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[310])(xfactor, yfactor);
}

void glPixelTransferf(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[311])(pname, param);
}

void glPixelTransferi(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[312])(pname, param);
}

void glPixelStoref(GLenum pname, GLfloat param) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[313])(pname, param);
}

void glPixelStorei(GLenum pname, GLint param) {
    typedef void (*__GLSdispatch)(GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[314])(pname, param);
}

void glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[315])(map, mapsize, values);
}

void glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[316])(map, mapsize, values);
}

void glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {
    typedef void (*__GLSdispatch)(GLenum, GLint, const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[317])(map, mapsize, values);
}

void glReadBuffer(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[318])(mode);
}

void glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[319])(x, y, width, height, type);
}

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[320])(x, y, width, height, format, type, pixels);
}

void glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[321])(width, height, format, type, pixels);
}

void glGetBooleanv(GLenum pname, GLboolean *params) {
    typedef void (*__GLSdispatch)(GLenum, GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[322])(pname, params);
}

void glGetClipPlane(GLenum plane, GLdouble *equation) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[323])(plane, equation);
}

void glGetDoublev(GLenum pname, GLdouble *params) {
    typedef void (*__GLSdispatch)(GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[324])(pname, params);
}

GLenum glGetError(void) {
    typedef GLenum (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[325])();
}

void glGetFloatv(GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[326])(pname, params);
}

void glGetIntegerv(GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[327])(pname, params);
}

void glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[328])(light, pname, params);
}

void glGetLightiv(GLenum light, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[329])(light, pname, params);
}

void glGetMapdv(GLenum target, GLenum query, GLdouble *v) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[330])(target, query, v);
}

void glGetMapfv(GLenum target, GLenum query, GLfloat *v) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[331])(target, query, v);
}

void glGetMapiv(GLenum target, GLenum query, GLint *v) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[332])(target, query, v);
}

void glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[333])(face, pname, params);
}

void glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[334])(face, pname, params);
}

void glGetPixelMapfv(GLenum map, GLfloat *values) {
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[335])(map, values);
}

void glGetPixelMapuiv(GLenum map, GLuint *values) {
    typedef void (*__GLSdispatch)(GLenum, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[336])(map, values);
}

void glGetPixelMapusv(GLenum map, GLushort *values) {
    typedef void (*__GLSdispatch)(GLenum, GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[337])(map, values);
}

void glGetPolygonStipple(GLubyte *mask) {
    typedef void (*__GLSdispatch)(GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[338])(mask);
}

const GLubyte * glGetString(GLenum name) {
    typedef const GLubyte * (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[339])(name);
}

void glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[340])(target, pname, params);
}

void glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[341])(target, pname, params);
}

void glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[342])(coord, pname, params);
}

void glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[343])(coord, pname, params);
}

void glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[344])(coord, pname, params);
}

void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[345])(target, level, format, type, pixels);
}

void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[346])(target, pname, params);
}

void glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[347])(target, pname, params);
}

void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[348])(target, level, pname, params);
}

void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[349])(target, level, pname, params);
}

GLboolean glIsEnabled(GLenum cap) {
    typedef GLboolean (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[350])(cap);
}

GLboolean glIsList(GLuint list) {
    typedef GLboolean (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[351])(list);
}

void glDepthRange(GLclampd zNear, GLclampd zFar) {
    typedef void (*__GLSdispatch)(GLclampd, GLclampd);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[352])(zNear, zFar);
}

void glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[353])(left, right, bottom, top, zNear, zFar);
}

void glLoadIdentity(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[354])();
}

void glLoadMatrixf(const GLfloat *m) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[355])(m);
}

void glLoadMatrixd(const GLdouble *m) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[356])(m);
}

void glMatrixMode(GLenum mode) {
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[357])(mode);
}

void glMultMatrixf(const GLfloat *m) {
    typedef void (*__GLSdispatch)(const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[358])(m);
}

void glMultMatrixd(const GLdouble *m) {
    typedef void (*__GLSdispatch)(const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[359])(m);
}

void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[360])(left, right, bottom, top, zNear, zFar);
}

void glPopMatrix(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[361])();
}

void glPushMatrix(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[362])();
}

void glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[363])(angle, x, y, z);
}

void glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[364])(angle, x, y, z);
}

void glScaled(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[365])(x, y, z);
}

void glScalef(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[366])(x, y, z);
}

void glTranslated(GLdouble x, GLdouble y, GLdouble z) {
    typedef void (*__GLSdispatch)(GLdouble, GLdouble, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[367])(x, y, z);
}

void glTranslatef(GLfloat x, GLfloat y, GLfloat z) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[368])(x, y, z);
}

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
    typedef void (*__GLSdispatch)(GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[369])(x, y, width, height);
}

void glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {
#if __GL_EXT_blend_color
    typedef void (*__GLSdispatch)(GLclampf, GLclampf, GLclampf, GLclampf);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[384])(red, green, blue, alpha);
#endif /* __GL_EXT_blend_color */
}

void glBlendEquationEXT(GLenum mode) {
#if __GL_EXT_blend_minmax
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[385])(mode);
#endif /* __GL_EXT_blend_minmax */
}

void glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {
#if __GL_EXT_polygon_offset
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[386])(factor, bias);
#endif /* __GL_EXT_polygon_offset */
}

void glPolygonOffset(GLfloat factor, GLfloat bias) {
    typedef void (*__GLSdispatch)(GLfloat, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[383])(factor, bias);
}

void glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_subtexture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[387])(target, level, xoffset, width, format, type, pixels);
#endif /* __GL_EXT_subtexture */
}

void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[396])(target, level, xoffset, width, format, type, pixels);
}

void glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_subtexture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[388])(target, level, xoffset, yoffset, width, height, format, type, pixels);
#endif /* __GL_EXT_subtexture */
}

void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[397])(target, level, xoffset, yoffset, width, height, format, type, pixels);
}

void glSampleMaskSGIS(GLclampf value, GLboolean invert) {
#if __GL_SGIS_multisample
    typedef void (*__GLSdispatch)(GLclampf, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[389])(value, invert);
#endif /* __GL_SGIS_multisample */
}

void glSamplePatternSGIS(GLenum pattern) {
#if __GL_SGIS_multisample
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[390])(pattern);
#endif /* __GL_SGIS_multisample */
}

void glTagSampleBufferSGIX(void) {
#if __GL_SGIX_multisample
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[391])();
#endif /* __GL_SGIX_multisample */
}

void glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[392])(target, internalformat, width, format, type, image);
#endif /* __GL_EXT_convolution */
}

void glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[393])(target, internalformat, width, height, format, type, image);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[394])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[395])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[396])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[397])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[398])(target, internalformat, x, y, width);
#endif /* __GL_EXT_convolution */
}

void glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[399])(target, internalformat, x, y, width, height);
#endif /* __GL_EXT_convolution */
}

void glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[400])(target, format, type, image);
#endif /* __GL_EXT_convolution */
}

void glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[401])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[402])(target, pname, params);
#endif /* __GL_EXT_convolution */
}

void glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[403])(target, format, type, row, column, span);
#endif /* __GL_EXT_convolution */
}

void glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {
#if __GL_EXT_convolution
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[404])(target, internalformat, width, height, format, type, row, column);
#endif /* __GL_EXT_convolution */
}

void glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[405])(target, reset, format, type, values);
#endif /* __GL_EXT_histogram */
}

void glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[406])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[407])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[408])(target, reset, format, type, values);
#endif /* __GL_EXT_histogram */
}

void glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[409])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[410])(target, pname, params);
#endif /* __GL_EXT_histogram */
}

void glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLenum, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[411])(target, width, internalformat, sink);
#endif /* __GL_EXT_histogram */
}

void glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLboolean);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[412])(target, internalformat, sink);
#endif /* __GL_EXT_histogram */
}

void glResetHistogramEXT(GLenum target) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[413])(target);
#endif /* __GL_EXT_histogram */
}

void glResetMinmaxEXT(GLenum target) {
#if __GL_EXT_histogram
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[414])(target);
#endif /* __GL_EXT_histogram */
}

void glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_texture3D
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[415])(target, level, internalformat, width, height, depth, border, format, type, pixels);
#endif /* __GL_EXT_texture3D */
}

void glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_EXT_subtexture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[416])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif /* __GL_EXT_subtexture */
}

void glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
#if __GL_SGIS_detail_texture
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[417])(target, n, points);
#endif /* __GL_SGIS_detail_texture */
}

void glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {
#if __GL_SGIS_detail_texture
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[418])(target, points);
#endif /* __GL_SGIS_detail_texture */
}

void glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {
#if __GL_SGIS_sharpen_texture
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[419])(target, n, points);
#endif /* __GL_SGIS_sharpen_texture */
}

void glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {
#if __GL_SGIS_sharpen_texture
    typedef void (*__GLSdispatch)(GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[420])(target, points);
#endif /* __GL_SGIS_sharpen_texture */
}

void glArrayElementEXT(GLint i) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[437])(i);
#endif /* __GL_EXT_vertex_array */
}

void glArrayElement(GLint i) {
    typedef void (*__GLSdispatch)(GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[370])(i);
}

void glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[438])(size, type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[372])(size, type, stride, pointer);
}

void glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[439])(mode, first, count);
#endif /* __GL_EXT_vertex_array */
}

void glDrawArrays(GLenum mode, GLint first, GLsizei count) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[374])(mode, first, count);
}

void glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLsizei, GLsizei, const GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[440])(stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glEdgeFlagPointer(GLsizei stride, const GLboolean *pointer) {
    typedef void (*__GLSdispatch)(GLsizei, const GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[376])(stride, pointer);
}

void glGetPointervEXT(GLenum pname, GLvoid* *params) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[441])(pname, params);
#endif /* __GL_EXT_vertex_array */
}

void glGetPointerv(GLenum pname, GLvoid* *params) {
    typedef void (*__GLSdispatch)(GLenum, GLvoid* *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[393])(pname, params);
}

void glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[442])(type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[378])(type, stride, pointer);
}

void glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[443])(type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[382])(type, stride, pointer);
}

void glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[444])(size, type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[384])(size, type, stride, pointer);
}

void glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {
#if __GL_EXT_vertex_array
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[445])(size, type, stride, count, pointer);
#endif /* __GL_EXT_vertex_array */
}

void glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {
    typedef void (*__GLSdispatch)(GLint, GLenum, GLsizei, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[385])(size, type, stride, pointer);
}

GLboolean glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {
#if __GL_EXT_texture_object
    typedef GLboolean (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[430])(n, textures, residences);
#else /* __GL_EXT_texture_object */
    return 0;
#endif /* __GL_EXT_texture_object */
}

GLboolean glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences) {
    typedef GLboolean (*__GLSdispatch)(GLsizei, const GLuint *, GLboolean *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[386])(n, textures, residences);
}

void glBindTextureEXT(GLenum target, GLuint texture) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[431])(target, texture);
#endif /* __GL_EXT_texture_object */
}

void glBindTexture(GLenum target, GLuint texture) {
    typedef void (*__GLSdispatch)(GLenum, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[371])(target, texture);
}

void glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[432])(n, textures);
#endif /* __GL_EXT_texture_object */
}

void glDeleteTextures(GLsizei n, const GLuint *textures) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[391])(n, textures);
}

void glGenTexturesEXT(GLsizei n, GLuint *textures) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[433])(n, textures);
#endif /* __GL_EXT_texture_object */
}

void glGenTextures(GLsizei n, GLuint *textures) {
    typedef void (*__GLSdispatch)(GLsizei, GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[392])(n, textures);
}

GLboolean glIsTextureEXT(GLuint texture) {
#if __GL_EXT_texture_object
    typedef GLboolean (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[434])(texture);
#else /* __GL_EXT_texture_object */
    return 0;
#endif /* __GL_EXT_texture_object */
}

GLboolean glIsTexture(GLuint texture) {
    typedef GLboolean (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    return ((__GLSdispatch)__glsDispTab[394])(texture);
}

void glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
#if __GL_EXT_texture_object
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[435])(n, textures, priorities);
#endif /* __GL_EXT_texture_object */
}

void glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities) {
    typedef void (*__GLSdispatch)(GLsizei, const GLuint *, const GLclampf *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[395])(n, textures, priorities);
}

void glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[452])(target, internalformat, width, format, type, table);
#endif /* __GL_EXT_paletted_texture */
}

void glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
#if __GL_SGI_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[437])(target, pname, params);
#endif /* __GL_SGI_color_table */
}

void glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
#if __GL_SGI_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[438])(target, pname, params);
#endif /* __GL_SGI_color_table */
}

void glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {
#if __GL_SGI_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[439])(target, internalformat, x, y, width);
#endif /* __GL_SGI_color_table */
}

void glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLenum, GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[456])(target, format, type, table);
#endif /* __GL_EXT_paletted_texture */
}

void glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[457])(target, pname, params);
#endif /* __GL_EXT_paletted_texture */
}

void glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params) {
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[458])(target, pname, params);
#endif /* __GL_EXT_paletted_texture */
}

void glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[443])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[444])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[445])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {
#if __GL_SGI_texture_color_table
    typedef void (*__GLSdispatch)(GLenum, GLenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[446])(target, pname, params);
#endif /* __GL_SGI_texture_color_table */
}

void glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[447])(target, level, internalformat, x, y, width, border);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[387])(target, level, internalformat, x, y, width, border);
}

void glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[448])(target, level, internalformat, x, y, width, height, border);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[388])(target, level, internalformat, x, y, width, height, border);
}

void glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[449])(target, level, xoffset, x, y, width);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[389])(target, level, xoffset, x, y, width);
}

void glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[450])(target, level, xoffset, yoffset, x, y, width, height);
#endif /* __GL_EXT_copy_texture */
}

void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[390])(target, level, xoffset, yoffset, x, y, width, height);
}

void glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
#if __GL_EXT_copy_texture
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[451])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif /* __GL_EXT_copy_texture */
}

void glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_SGIS_texture4D
    typedef void (*__GLSdispatch)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[452])(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
#endif /* __GL_SGIS_texture4D */
}

void glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {
#if __GL_SGIS_texture4D
    typedef void (*__GLSdispatch)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[453])(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
#endif /* __GL_SGIS_texture4D */
}

void glPixelTexGenSGIX(GLenum mode) {
#if __GL_SGIX_pixel_texture
    typedef void (*__GLSdispatch)(GLenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[454])(mode);
#endif /* __GL_SGIX_pixel_texture */
}

void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    typedef void (*__GLSdispatch)(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[375])(mode, count, type, indices);
}

void
glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
#if __GL_WIN_draw_range_elements
    glDrawElements( mode, count, type, indices );
#endif  // __GL_EXT_draw_range_elements
}

void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer)
{
    typedef void (*__GLSdispatch)(GLenum format, GLsizei stride, const GLvoid *pointer);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[381])(format, stride, pointer);
}

void glIndexub (GLubyte c)
{
    typedef void (*__GLSdispatch)(GLubyte c);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[379])(c);
}

void glIndexubv (const GLubyte *c)
{
    typedef void (*__GLSdispatch)(const GLubyte *c);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[380])(c);
}

void glEnableClientState (GLenum array)
{
    typedef void (*__GLSdispatch)(GLenum array);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[377])(array);
}

void glDisableClientState (GLenum array)
{
    typedef void (*__GLSdispatch)(GLenum array);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[373])(array);
}

void glColorSubTableEXT(GLenum target, GLuint start, GLsizei count,
                        GLenum format, GLenum type,
                        const GLvoid *data)
{
#if __GL_EXT_paletted_texture
    typedef void (*__GLSdispatch)(GLenum target, GLuint start, GLsizei count,
                                  GLenum format, GLenum type, const GLvoid *data);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
            __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
            );
    ((__GLSdispatch)__glsDispTab[496])(target, start, count, format, type, data);
#endif // __GL_EXT_paletted_texture
}

void glPushClientAttrib(GLbitfield mask) {
    typedef void (*__GLSdispatch)(GLbitfield);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[398])(mask);
}

void glPopClientAttrib(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    GLSfunc *const __glsDispTab = (
        __glsCtx ? __glsCtx->dispatchAPI : __glsDispatchExec
    );
    ((__GLSdispatch)__glsDispTab[399])();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_win32.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void __gls_null_glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor) {}
void __gls_null_glsBlock(GLSenum inBlockType) {}
GLSenum __gls_null_glsCallStream(const GLubyte *inName) {return 0;}
void __gls_null_glsEndGLS(void) {}
void __gls_null_glsError(GLSopcode inOpcode, GLSenum inError) {}
void __gls_null_glsGLRC(GLuint inGLRC) {}
void __gls_null_glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer) {}
void __gls_null_glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {}
void __gls_null_glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal) {}
void __gls_null_glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal) {}
void __gls_null_glsHeaderf(GLSenum inAttrib, GLfloat inVal) {}
void __gls_null_glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {}
void __gls_null_glsHeaderi(GLSenum inAttrib, GLint inVal) {}
void __gls_null_glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {}
void __gls_null_glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {}
void __gls_null_glsRequireExtension(const GLubyte *inExtension) {}
void __gls_null_glsUnsupportedCommand(void) {}
void __gls_null_glsAppRef(GLulong inAddress, GLuint inCount) {}
void __gls_null_glsBeginObj(const GLubyte *inTag) {}
void __gls_null_glsCharubz(const GLubyte *inTag, const GLubyte *inString) {}
void __gls_null_glsComment(const GLubyte *inComment) {}
void __gls_null_glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {}
void __gls_null_glsEndObj(void) {}
void __gls_null_glsNumb(const GLubyte *inTag, GLbyte inVal) {}
void __gls_null_glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {}
void __gls_null_glsNumd(const GLubyte *inTag, GLdouble inVal) {}
void __gls_null_glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {}
void __gls_null_glsNumf(const GLubyte *inTag, GLfloat inVal) {}
void __gls_null_glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {}
void __gls_null_glsNumi(const GLubyte *inTag, GLint inVal) {}
void __gls_null_glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {}
void __gls_null_glsNuml(const GLubyte *inTag, GLlong inVal) {}
void __gls_null_glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {}
void __gls_null_glsNums(const GLubyte *inTag, GLshort inVal) {}
void __gls_null_glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {}
void __gls_null_glsNumub(const GLubyte *inTag, GLubyte inVal) {}
void __gls_null_glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {}
void __gls_null_glsNumui(const GLubyte *inTag, GLuint inVal) {}
void __gls_null_glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {}
void __gls_null_glsNumul(const GLubyte *inTag, GLulong inVal) {}
void __gls_null_glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {}
void __gls_null_glsNumus(const GLubyte *inTag, GLushort inVal) {}
void __gls_null_glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {}
void __gls_null_glsPad(void) {}
void __gls_null_glsSwapBuffers(GLuint inLayer) {}
void __gls_null_glNewList(GLuint list, GLenum mode) {}
void __gls_null_glEndList(void) {}
void __gls_null_glCallList(GLuint list) {}
void __gls_null_glCallLists(GLsizei n, GLenum type, const GLvoid *lists) {}
void __gls_null_glDeleteLists(GLuint list, GLsizei range) {}
GLuint __gls_null_glGenLists(GLsizei range) {return 0;}
void __gls_null_glListBase(GLuint base) {}
void __gls_null_glBegin(GLenum mode) {}
void __gls_null_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap) {}
void __gls_null_glColor3b(GLbyte red, GLbyte green, GLbyte blue) {}
void __gls_null_glColor3bv(const GLbyte *v) {}
void __gls_null_glColor3d(GLdouble red, GLdouble green, GLdouble blue) {}
void __gls_null_glColor3dv(const GLdouble *v) {}
void __gls_null_glColor3f(GLfloat red, GLfloat green, GLfloat blue) {}
void __gls_null_glColor3fv(const GLfloat *v) {}
void __gls_null_glColor3i(GLint red, GLint green, GLint blue) {}
void __gls_null_glColor3iv(const GLint *v) {}
void __gls_null_glColor3s(GLshort red, GLshort green, GLshort blue) {}
void __gls_null_glColor3sv(const GLshort *v) {}
void __gls_null_glColor3ub(GLubyte red, GLubyte green, GLubyte blue) {}
void __gls_null_glColor3ubv(const GLubyte *v) {}
void __gls_null_glColor3ui(GLuint red, GLuint green, GLuint blue) {}
void __gls_null_glColor3uiv(const GLuint *v) {}
void __gls_null_glColor3us(GLushort red, GLushort green, GLushort blue) {}
void __gls_null_glColor3usv(const GLushort *v) {}
void __gls_null_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {}
void __gls_null_glColor4bv(const GLbyte *v) {}
void __gls_null_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {}
void __gls_null_glColor4dv(const GLdouble *v) {}
void __gls_null_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {}
void __gls_null_glColor4fv(const GLfloat *v) {}
void __gls_null_glColor4i(GLint red, GLint green, GLint blue, GLint alpha) {}
void __gls_null_glColor4iv(const GLint *v) {}
void __gls_null_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {}
void __gls_null_glColor4sv(const GLshort *v) {}
void __gls_null_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {}
void __gls_null_glColor4ubv(const GLubyte *v) {}
void __gls_null_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {}
void __gls_null_glColor4uiv(const GLuint *v) {}
void __gls_null_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {}
void __gls_null_glColor4usv(const GLushort *v) {}
void __gls_null_glEdgeFlag(GLboolean flag) {}
void __gls_null_glEdgeFlagv(const GLboolean *flag) {}
void __gls_null_glEnd(void) {}
void __gls_null_glIndexd(GLdouble c) {}
void __gls_null_glIndexdv(const GLdouble *c) {}
void __gls_null_glIndexf(GLfloat c) {}
void __gls_null_glIndexfv(const GLfloat *c) {}
void __gls_null_glIndexi(GLint c) {}
void __gls_null_glIndexiv(const GLint *c) {}
void __gls_null_glIndexs(GLshort c) {}
void __gls_null_glIndexsv(const GLshort *c) {}
void __gls_null_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz) {}
void __gls_null_glNormal3bv(const GLbyte *v) {}
void __gls_null_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz) {}
void __gls_null_glNormal3dv(const GLdouble *v) {}
void __gls_null_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz) {}
void __gls_null_glNormal3fv(const GLfloat *v) {}
void __gls_null_glNormal3i(GLint nx, GLint ny, GLint nz) {}
void __gls_null_glNormal3iv(const GLint *v) {}
void __gls_null_glNormal3s(GLshort nx, GLshort ny, GLshort nz) {}
void __gls_null_glNormal3sv(const GLshort *v) {}
void __gls_null_glRasterPos2d(GLdouble x, GLdouble y) {}
void __gls_null_glRasterPos2dv(const GLdouble *v) {}
void __gls_null_glRasterPos2f(GLfloat x, GLfloat y) {}
void __gls_null_glRasterPos2fv(const GLfloat *v) {}
void __gls_null_glRasterPos2i(GLint x, GLint y) {}
void __gls_null_glRasterPos2iv(const GLint *v) {}
void __gls_null_glRasterPos2s(GLshort x, GLshort y) {}
void __gls_null_glRasterPos2sv(const GLshort *v) {}
void __gls_null_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glRasterPos3dv(const GLdouble *v) {}
void __gls_null_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glRasterPos3fv(const GLfloat *v) {}
void __gls_null_glRasterPos3i(GLint x, GLint y, GLint z) {}
void __gls_null_glRasterPos3iv(const GLint *v) {}
void __gls_null_glRasterPos3s(GLshort x, GLshort y, GLshort z) {}
void __gls_null_glRasterPos3sv(const GLshort *v) {}
void __gls_null_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {}
void __gls_null_glRasterPos4dv(const GLdouble *v) {}
void __gls_null_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {}
void __gls_null_glRasterPos4fv(const GLfloat *v) {}
void __gls_null_glRasterPos4i(GLint x, GLint y, GLint z, GLint w) {}
void __gls_null_glRasterPos4iv(const GLint *v) {}
void __gls_null_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {}
void __gls_null_glRasterPos4sv(const GLshort *v) {}
void __gls_null_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {}
void __gls_null_glRectdv(const GLdouble *v1, const GLdouble *v2) {}
void __gls_null_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {}
void __gls_null_glRectfv(const GLfloat *v1, const GLfloat *v2) {}
void __gls_null_glRecti(GLint x1, GLint y1, GLint x2, GLint y2) {}
void __gls_null_glRectiv(const GLint *v1, const GLint *v2) {}
void __gls_null_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {}
void __gls_null_glRectsv(const GLshort *v1, const GLshort *v2) {}
void __gls_null_glTexCoord1d(GLdouble s) {}
void __gls_null_glTexCoord1dv(const GLdouble *v) {}
void __gls_null_glTexCoord1f(GLfloat s) {}
void __gls_null_glTexCoord1fv(const GLfloat *v) {}
void __gls_null_glTexCoord1i(GLint s) {}
void __gls_null_glTexCoord1iv(const GLint *v) {}
void __gls_null_glTexCoord1s(GLshort s) {}
void __gls_null_glTexCoord1sv(const GLshort *v) {}
void __gls_null_glTexCoord2d(GLdouble s, GLdouble t) {}
void __gls_null_glTexCoord2dv(const GLdouble *v) {}
void __gls_null_glTexCoord2f(GLfloat s, GLfloat t) {}
void __gls_null_glTexCoord2fv(const GLfloat *v) {}
void __gls_null_glTexCoord2i(GLint s, GLint t) {}
void __gls_null_glTexCoord2iv(const GLint *v) {}
void __gls_null_glTexCoord2s(GLshort s, GLshort t) {}
void __gls_null_glTexCoord2sv(const GLshort *v) {}
void __gls_null_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r) {}
void __gls_null_glTexCoord3dv(const GLdouble *v) {}
void __gls_null_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r) {}
void __gls_null_glTexCoord3fv(const GLfloat *v) {}
void __gls_null_glTexCoord3i(GLint s, GLint t, GLint r) {}
void __gls_null_glTexCoord3iv(const GLint *v) {}
void __gls_null_glTexCoord3s(GLshort s, GLshort t, GLshort r) {}
void __gls_null_glTexCoord3sv(const GLshort *v) {}
void __gls_null_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {}
void __gls_null_glTexCoord4dv(const GLdouble *v) {}
void __gls_null_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {}
void __gls_null_glTexCoord4fv(const GLfloat *v) {}
void __gls_null_glTexCoord4i(GLint s, GLint t, GLint r, GLint q) {}
void __gls_null_glTexCoord4iv(const GLint *v) {}
void __gls_null_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {}
void __gls_null_glTexCoord4sv(const GLshort *v) {}
void __gls_null_glVertex2d(GLdouble x, GLdouble y) {}
void __gls_null_glVertex2dv(const GLdouble *v) {}
void __gls_null_glVertex2f(GLfloat x, GLfloat y) {}
void __gls_null_glVertex2fv(const GLfloat *v) {}
void __gls_null_glVertex2i(GLint x, GLint y) {}
void __gls_null_glVertex2iv(const GLint *v) {}
void __gls_null_glVertex2s(GLshort x, GLshort y) {}
void __gls_null_glVertex2sv(const GLshort *v) {}
void __gls_null_glVertex3d(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glVertex3dv(const GLdouble *v) {}
void __gls_null_glVertex3f(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glVertex3fv(const GLfloat *v) {}
void __gls_null_glVertex3i(GLint x, GLint y, GLint z) {}
void __gls_null_glVertex3iv(const GLint *v) {}
void __gls_null_glVertex3s(GLshort x, GLshort y, GLshort z) {}
void __gls_null_glVertex3sv(const GLshort *v) {}
void __gls_null_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {}
void __gls_null_glVertex4dv(const GLdouble *v) {}
void __gls_null_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {}
void __gls_null_glVertex4fv(const GLfloat *v) {}
void __gls_null_glVertex4i(GLint x, GLint y, GLint z, GLint w) {}
void __gls_null_glVertex4iv(const GLint *v) {}
void __gls_null_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {}
void __gls_null_glVertex4sv(const GLshort *v) {}
void __gls_null_glClipPlane(GLenum plane, const GLdouble *equation) {}
void __gls_null_glColorMaterial(GLenum face, GLenum mode) {}
void __gls_null_glCullFace(GLenum mode) {}
void __gls_null_glFogf(GLenum pname, GLfloat param) {}
void __gls_null_glFogfv(GLenum pname, const GLfloat *params) {}
void __gls_null_glFogi(GLenum pname, GLint param) {}
void __gls_null_glFogiv(GLenum pname, const GLint *params) {}
void __gls_null_glFrontFace(GLenum mode) {}
void __gls_null_glHint(GLenum target, GLenum mode) {}
void __gls_null_glLightf(GLenum light, GLenum pname, GLfloat param) {}
void __gls_null_glLightfv(GLenum light, GLenum pname, const GLfloat *params) {}
void __gls_null_glLighti(GLenum light, GLenum pname, GLint param) {}
void __gls_null_glLightiv(GLenum light, GLenum pname, const GLint *params) {}
void __gls_null_glLightModelf(GLenum pname, GLfloat param) {}
void __gls_null_glLightModelfv(GLenum pname, const GLfloat *params) {}
void __gls_null_glLightModeli(GLenum pname, GLint param) {}
void __gls_null_glLightModeliv(GLenum pname, const GLint *params) {}
void __gls_null_glLineStipple(GLint factor, GLushort pattern) {}
void __gls_null_glLineWidth(GLfloat width) {}
void __gls_null_glMaterialf(GLenum face, GLenum pname, GLfloat param) {}
void __gls_null_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params) {}
void __gls_null_glMateriali(GLenum face, GLenum pname, GLint param) {}
void __gls_null_glMaterialiv(GLenum face, GLenum pname, const GLint *params) {}
void __gls_null_glPointSize(GLfloat size) {}
void __gls_null_glPolygonMode(GLenum face, GLenum mode) {}
void __gls_null_glPolygonStipple(const GLubyte *mask) {}
void __gls_null_glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {}
void __gls_null_glShadeModel(GLenum mode) {}
void __gls_null_glTexParameterf(GLenum target, GLenum pname, GLfloat param) {}
void __gls_null_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params) {}
void __gls_null_glTexParameteri(GLenum target, GLenum pname, GLint param) {}
void __gls_null_glTexParameteriv(GLenum target, GLenum pname, const GLint *params) {}
void __gls_null_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glTexEnvf(GLenum target, GLenum pname, GLfloat param) {}
void __gls_null_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params) {}
void __gls_null_glTexEnvi(GLenum target, GLenum pname, GLint param) {}
void __gls_null_glTexEnviv(GLenum target, GLenum pname, const GLint *params) {}
void __gls_null_glTexGend(GLenum coord, GLenum pname, GLdouble param) {}
void __gls_null_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params) {}
void __gls_null_glTexGenf(GLenum coord, GLenum pname, GLfloat param) {}
void __gls_null_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params) {}
void __gls_null_glTexGeni(GLenum coord, GLenum pname, GLint param) {}
void __gls_null_glTexGeniv(GLenum coord, GLenum pname, const GLint *params) {}
void __gls_null_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer) {}
void __gls_null_glSelectBuffer(GLsizei size, GLuint *buffer) {}
GLint __gls_null_glRenderMode(GLenum mode) {return 0;}
void __gls_null_glInitNames(void) {}
void __gls_null_glLoadName(GLuint name) {}
void __gls_null_glPassThrough(GLfloat token) {}
void __gls_null_glPopName(void) {}
void __gls_null_glPushName(GLuint name) {}
void __gls_null_glDrawBuffer(GLenum mode) {}
void __gls_null_glClear(GLbitfield mask) {}
void __gls_null_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {}
void __gls_null_glClearIndex(GLfloat c) {}
void __gls_null_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {}
void __gls_null_glClearStencil(GLint s) {}
void __gls_null_glClearDepth(GLclampd depth) {}
void __gls_null_glStencilMask(GLuint mask) {}
void __gls_null_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {}
void __gls_null_glDepthMask(GLboolean flag) {}
void __gls_null_glIndexMask(GLuint mask) {}
void __gls_null_glAccum(GLenum op, GLfloat value) {}
void __gls_null_glDisable(GLenum cap) {}
void __gls_null_glEnable(GLenum cap) {}
void __gls_null_glFinish(void) {}
void __gls_null_glFlush(void) {}
void __gls_null_glPopAttrib(void) {}
void __gls_null_glPushAttrib(GLbitfield mask) {}
void __gls_null_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points) {}
void __gls_null_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points) {}
void __gls_null_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points) {}
void __gls_null_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points) {}
void __gls_null_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2) {}
void __gls_null_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2) {}
void __gls_null_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {}
void __gls_null_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {}
void __gls_null_glEvalCoord1d(GLdouble u) {}
void __gls_null_glEvalCoord1dv(const GLdouble *u) {}
void __gls_null_glEvalCoord1f(GLfloat u) {}
void __gls_null_glEvalCoord1fv(const GLfloat *u) {}
void __gls_null_glEvalCoord2d(GLdouble u, GLdouble v) {}
void __gls_null_glEvalCoord2dv(const GLdouble *u) {}
void __gls_null_glEvalCoord2f(GLfloat u, GLfloat v) {}
void __gls_null_glEvalCoord2fv(const GLfloat *u) {}
void __gls_null_glEvalMesh1(GLenum mode, GLint i1, GLint i2) {}
void __gls_null_glEvalPoint1(GLint i) {}
void __gls_null_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) {}
void __gls_null_glEvalPoint2(GLint i, GLint j) {}
void __gls_null_glAlphaFunc(GLenum func, GLclampf ref) {}
void __gls_null_glBlendFunc(GLenum sfactor, GLenum dfactor) {}
void __gls_null_glLogicOp(GLenum opcode) {}
void __gls_null_glStencilFunc(GLenum func, GLint ref, GLuint mask) {}
void __gls_null_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {}
void __gls_null_glDepthFunc(GLenum func) {}
void __gls_null_glPixelZoom(GLfloat xfactor, GLfloat yfactor) {}
void __gls_null_glPixelTransferf(GLenum pname, GLfloat param) {}
void __gls_null_glPixelTransferi(GLenum pname, GLint param) {}
void __gls_null_glPixelStoref(GLenum pname, GLfloat param) {}
void __gls_null_glPixelStorei(GLenum pname, GLint param) {}
void __gls_null_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values) {}
void __gls_null_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values) {}
void __gls_null_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values) {}
void __gls_null_glReadBuffer(GLenum mode) {}
void __gls_null_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) {}
void __gls_null_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels) {}
void __gls_null_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glGetBooleanv(GLenum pname, GLboolean *params) {}
void __gls_null_glGetClipPlane(GLenum plane, GLdouble *equation) {}
void __gls_null_glGetDoublev(GLenum pname, GLdouble *params) {}
GLenum __gls_null_glGetError(void) {return 0;}
void __gls_null_glGetFloatv(GLenum pname, GLfloat *params) {}
void __gls_null_glGetIntegerv(GLenum pname, GLint *params) {}
void __gls_null_glGetLightfv(GLenum light, GLenum pname, GLfloat *params) {}
void __gls_null_glGetLightiv(GLenum light, GLenum pname, GLint *params) {}
void __gls_null_glGetMapdv(GLenum target, GLenum query, GLdouble *v) {}
void __gls_null_glGetMapfv(GLenum target, GLenum query, GLfloat *v) {}
void __gls_null_glGetMapiv(GLenum target, GLenum query, GLint *v) {}
void __gls_null_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params) {}
void __gls_null_glGetMaterialiv(GLenum face, GLenum pname, GLint *params) {}
void __gls_null_glGetPixelMapfv(GLenum map, GLfloat *values) {}
void __gls_null_glGetPixelMapuiv(GLenum map, GLuint *values) {}
void __gls_null_glGetPixelMapusv(GLenum map, GLushort *values) {}
void __gls_null_glGetPolygonStipple(GLubyte *mask) {}
const GLubyte * __gls_null_glGetString(GLenum name) {return 0;}
void __gls_null_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexEnviv(GLenum target, GLenum pname, GLint *params) {}
void __gls_null_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params) {}
void __gls_null_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params) {}
void __gls_null_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels) {}
void __gls_null_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params) {}
void __gls_null_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params) {}
void __gls_null_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params) {}
GLboolean __gls_null_glIsEnabled(GLenum cap) {return 0;}
GLboolean __gls_null_glIsList(GLuint list) {return 0;}
void __gls_null_glDepthRange(GLclampd zNear, GLclampd zFar) {}
void __gls_null_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {}
void __gls_null_glLoadIdentity(void) {}
void __gls_null_glLoadMatrixf(const GLfloat *m) {}
void __gls_null_glLoadMatrixd(const GLdouble *m) {}
void __gls_null_glMatrixMode(GLenum mode) {}
void __gls_null_glMultMatrixf(const GLfloat *m) {}
void __gls_null_glMultMatrixd(const GLdouble *m) {}
void __gls_null_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {}
void __gls_null_glPopMatrix(void) {}
void __gls_null_glPushMatrix(void) {}
void __gls_null_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glScaled(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glScalef(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glTranslated(GLdouble x, GLdouble y, GLdouble z) {}
void __gls_null_glTranslatef(GLfloat x, GLfloat y, GLfloat z) {}
void __gls_null_glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {}
#if __GL_EXT_blend_color
    void __gls_null_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) {}
#endif /* __GL_EXT_blend_color */
#if __GL_EXT_blend_minmax
    void __gls_null_glBlendEquationEXT(GLenum mode) {}
#endif /* __GL_EXT_blend_minmax */
#if __GL_EXT_polygon_offset
    void __gls_null_glPolygonOffsetEXT(GLfloat factor, GLfloat bias) {}
#endif /* __GL_EXT_polygon_offset */
#if __GL_EXT_subtexture
    void __gls_null_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_subtexture */
#if __GL_EXT_subtexture
    void __gls_null_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_subtexture */
#if __GL_SGIS_multisample
    void __gls_null_glSampleMaskSGIS(GLclampf value, GLboolean invert) {}
#endif /* __GL_SGIS_multisample */
#if __GL_SGIS_multisample
    void __gls_null_glSamplePatternSGIS(GLenum pattern) {}
#endif /* __GL_SGIS_multisample */
#if __GL_SGIX_multisample
    void __gls_null_glTagSampleBufferSGIX(void) {}
#endif /* __GL_SGIX_multisample */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_convolution
    void __gls_null_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column) {}
#endif /* __GL_EXT_convolution */
#if __GL_EXT_histogram
    void __gls_null_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glResetHistogramEXT(GLenum target) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_histogram
    void __gls_null_glResetMinmaxEXT(GLenum target) {}
#endif /* __GL_EXT_histogram */
#if __GL_EXT_texture3D
    void __gls_null_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_texture3D */
#if __GL_EXT_subtexture
    void __gls_null_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_EXT_subtexture */
#if __GL_SGIS_detail_texture
    void __gls_null_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {}
#endif /* __GL_SGIS_detail_texture */
#if __GL_SGIS_detail_texture
    void __gls_null_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points) {}
#endif /* __GL_SGIS_detail_texture */
#if __GL_SGIS_sharpen_texture
    void __gls_null_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points) {}
#endif /* __GL_SGIS_sharpen_texture */
#if __GL_SGIS_sharpen_texture
    void __gls_null_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points) {}
#endif /* __GL_SGIS_sharpen_texture */
#if __GL_EXT_vertex_array
    void __gls_null_glArrayElementEXT(GLint i) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glGetPointervEXT(GLenum pname, GLvoid* *params) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_vertex_array
    void __gls_null_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer) {}
#endif /* __GL_EXT_vertex_array */
#if __GL_EXT_texture_object
    GLboolean __gls_null_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences) {return 0;}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glBindTextureEXT(GLenum target, GLuint texture) {}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glDeleteTexturesEXT(GLsizei n, const GLuint *textures) {}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glGenTexturesEXT(GLsizei n, GLuint *textures) {}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    GLboolean __gls_null_glIsTextureEXT(GLuint texture) {return 0;}
#endif /* __GL_EXT_texture_object */
#if __GL_EXT_texture_object
    void __gls_null_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities) {}
#endif /* __GL_EXT_texture_object */

#if __GL_WIN_draw_range_elements
void __gls_null_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) {}
#endif // __GL_EXT_draw_range_elements

#if __GL_EXT_paletted_texture
    void __gls_null_glColorTableEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_SGI_color_table
    void __gls_null_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {}
#endif /* __GL_SGI_color_table */
#if __GL_SGI_color_table
    void __gls_null_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {}
#endif /* __GL_SGI_color_table */
#if __GL_SGI_color_table
    void __gls_null_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width) {}
#endif /* __GL_SGI_color_table */
#if __GL_EXT_paletted_texture
    void __gls_null_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *table) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_EXT_paletted_texture
    void __gls_null_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_EXT_paletted_texture
    void __gls_null_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_EXT_paletted_texture */
#if __GL_SGI_texture_color_table
    void __gls_null_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_SGI_texture_color_table
    void __gls_null_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_SGI_texture_color_table
    void __gls_null_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_SGI_texture_color_table
    void __gls_null_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params) {}
#endif /* __GL_SGI_texture_color_table */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_EXT_copy_texture
    void __gls_null_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {}
#endif /* __GL_EXT_copy_texture */
#if __GL_SGIS_texture4D
    void __gls_null_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_SGIS_texture4D */
#if __GL_SGIS_texture4D
    void __gls_null_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels) {}
#endif /* __GL_SGIS_texture4D */
#if __GL_SGIX_pixel_texture
    void __gls_null_glPixelTexGenSGIX(GLenum mode) {}
#endif /* __GL_SGIX_pixel_texture */

// DrewB - 1.1
void __gls_null_glArrayElement(GLint i) {}
void __gls_null_glBindTexture(GLenum target, GLuint texture) {}
void __gls_null_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glDisableClientState(GLenum array) {}
void __gls_null_glDrawArrays(GLenum mode, GLint first, GLsizei count) {}
void __gls_null_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices) {}
void __gls_null_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glEnableClientState(GLenum array) {}
void __gls_null_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glIndexub(GLubyte c) {}
void __gls_null_glIndexubv(const GLubyte *c) {}
void __gls_null_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glPolygonOffset(GLfloat factor, GLfloat units) {}
void __gls_null_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer) {}
void __gls_null_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences) {}
void __gls_null_glCopyTexImage1D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border) {}
void __gls_null_glCopyTexImage2D(GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {}
void __gls_null_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {}
void __gls_null_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {}
void __gls_null_glDeleteTextures(GLsizei n, const GLuint *textures) {}
void __gls_null_glGenTextures(GLsizei n, GLuint *textures) {}
void __gls_null_glGetPointerv(GLenum pname, GLvoid* *params) {}
void __gls_null_glIsTexture(GLuint texture) {}
void __gls_null_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities) {}
void __gls_null_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels) {}
void __gls_null_glPushClientAttrib(GLbitfield mask) {}
void __gls_null_glPopClientAttrib(void) {}

#if __GL_EXT_paletted_texture
// DrewB
void __gls_null_glColorSubTableEXT(GLenum target, GLuint start, GLsizei count, GLenum format, GLenum type, const GLvoid *data) {}
#endif
#if __GL_WIN_draw_range_elements
// MarcFo
void __gls_null_glDrawRangeElementsWIN(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices) {}
#endif

const GLSfunc __glsNullCommandFuncs[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_null_glsBeginGLS,
    (GLSfunc)__gls_null_glsBlock,
    (GLSfunc)__gls_null_glsCallStream,
    (GLSfunc)__gls_null_glsEndGLS,
    (GLSfunc)__gls_null_glsError,
    (GLSfunc)__gls_null_glsGLRC,
    (GLSfunc)__gls_null_glsGLRCLayer,
    (GLSfunc)__gls_null_glsHeaderGLRCi,
    (GLSfunc)__gls_null_glsHeaderLayerf,
    (GLSfunc)__gls_null_glsHeaderLayeri,
    (GLSfunc)__gls_null_glsHeaderf,
    (GLSfunc)__gls_null_glsHeaderfv,
    (GLSfunc)__gls_null_glsHeaderi,
    (GLSfunc)__gls_null_glsHeaderiv,
    (GLSfunc)__gls_null_glsHeaderubz,
    (GLSfunc)__gls_null_glsRequireExtension,
    (GLSfunc)__gls_null_glsUnsupportedCommand,
    (GLSfunc)__gls_null_glsAppRef,
    (GLSfunc)__gls_null_glsBeginObj,
    (GLSfunc)__gls_null_glsCharubz,
    (GLSfunc)__gls_null_glsComment,
    (GLSfunc)__gls_null_glsDisplayMapfv,
    (GLSfunc)__gls_null_glsEndObj,
    (GLSfunc)__gls_null_glsNumb,
    (GLSfunc)__gls_null_glsNumbv,
    (GLSfunc)__gls_null_glsNumd,
    (GLSfunc)__gls_null_glsNumdv,
    (GLSfunc)__gls_null_glsNumf,
    (GLSfunc)__gls_null_glsNumfv,
    (GLSfunc)__gls_null_glsNumi,
    (GLSfunc)__gls_null_glsNumiv,
    (GLSfunc)__gls_null_glsNuml,
    (GLSfunc)__gls_null_glsNumlv,
    (GLSfunc)__gls_null_glsNums,
    (GLSfunc)__gls_null_glsNumsv,
    (GLSfunc)__gls_null_glsNumub,
    (GLSfunc)__gls_null_glsNumubv,
    (GLSfunc)__gls_null_glsNumui,
    (GLSfunc)__gls_null_glsNumuiv,
    (GLSfunc)__gls_null_glsNumul,
    (GLSfunc)__gls_null_glsNumulv,
    (GLSfunc)__gls_null_glsNumus,
    (GLSfunc)__gls_null_glsNumusv,
    (GLSfunc)__gls_null_glsPad,
    (GLSfunc)__gls_null_glsSwapBuffers,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    (GLSfunc)__gls_null_glNewList,
    (GLSfunc)__gls_null_glEndList,
    (GLSfunc)__gls_null_glCallList,
    (GLSfunc)__gls_null_glCallLists,
    (GLSfunc)__gls_null_glDeleteLists,
    (GLSfunc)__gls_null_glGenLists,
    (GLSfunc)__gls_null_glListBase,
    (GLSfunc)__gls_null_glBegin,
    (GLSfunc)__gls_null_glBitmap,
    (GLSfunc)__gls_null_glColor3b,
    (GLSfunc)__gls_null_glColor3bv,
    (GLSfunc)__gls_null_glColor3d,
    (GLSfunc)__gls_null_glColor3dv,
    (GLSfunc)__gls_null_glColor3f,
    (GLSfunc)__gls_null_glColor3fv,
    (GLSfunc)__gls_null_glColor3i,
    (GLSfunc)__gls_null_glColor3iv,
    (GLSfunc)__gls_null_glColor3s,
    (GLSfunc)__gls_null_glColor3sv,
    (GLSfunc)__gls_null_glColor3ub,
    (GLSfunc)__gls_null_glColor3ubv,
    (GLSfunc)__gls_null_glColor3ui,
    (GLSfunc)__gls_null_glColor3uiv,
    (GLSfunc)__gls_null_glColor3us,
    (GLSfunc)__gls_null_glColor3usv,
    (GLSfunc)__gls_null_glColor4b,
    (GLSfunc)__gls_null_glColor4bv,
    (GLSfunc)__gls_null_glColor4d,
    (GLSfunc)__gls_null_glColor4dv,
    (GLSfunc)__gls_null_glColor4f,
    (GLSfunc)__gls_null_glColor4fv,
    (GLSfunc)__gls_null_glColor4i,
    (GLSfunc)__gls_null_glColor4iv,
    (GLSfunc)__gls_null_glColor4s,
    (GLSfunc)__gls_null_glColor4sv,
    (GLSfunc)__gls_null_glColor4ub,
    (GLSfunc)__gls_null_glColor4ubv,
    (GLSfunc)__gls_null_glColor4ui,
    (GLSfunc)__gls_null_glColor4uiv,
    (GLSfunc)__gls_null_glColor4us,
    (GLSfunc)__gls_null_glColor4usv,
    (GLSfunc)__gls_null_glEdgeFlag,
    (GLSfunc)__gls_null_glEdgeFlagv,
    (GLSfunc)__gls_null_glEnd,
    (GLSfunc)__gls_null_glIndexd,
    (GLSfunc)__gls_null_glIndexdv,
    (GLSfunc)__gls_null_glIndexf,
    (GLSfunc)__gls_null_glIndexfv,
    (GLSfunc)__gls_null_glIndexi,
    (GLSfunc)__gls_null_glIndexiv,
    (GLSfunc)__gls_null_glIndexs,
    (GLSfunc)__gls_null_glIndexsv,
    (GLSfunc)__gls_null_glNormal3b,
    (GLSfunc)__gls_null_glNormal3bv,
    (GLSfunc)__gls_null_glNormal3d,
    (GLSfunc)__gls_null_glNormal3dv,
    (GLSfunc)__gls_null_glNormal3f,
    (GLSfunc)__gls_null_glNormal3fv,
    (GLSfunc)__gls_null_glNormal3i,
    (GLSfunc)__gls_null_glNormal3iv,
    (GLSfunc)__gls_null_glNormal3s,
    (GLSfunc)__gls_null_glNormal3sv,
    (GLSfunc)__gls_null_glRasterPos2d,
    (GLSfunc)__gls_null_glRasterPos2dv,
    (GLSfunc)__gls_null_glRasterPos2f,
    (GLSfunc)__gls_null_glRasterPos2fv,
    (GLSfunc)__gls_null_glRasterPos2i,
    (GLSfunc)__gls_null_glRasterPos2iv,
    (GLSfunc)__gls_null_glRasterPos2s,
    (GLSfunc)__gls_null_glRasterPos2sv,
    (GLSfunc)__gls_null_glRasterPos3d,
    (GLSfunc)__gls_null_glRasterPos3dv,
    (GLSfunc)__gls_null_glRasterPos3f,
    (GLSfunc)__gls_null_glRasterPos3fv,
    (GLSfunc)__gls_null_glRasterPos3i,
    (GLSfunc)__gls_null_glRasterPos3iv,
    (GLSfunc)__gls_null_glRasterPos3s,
    (GLSfunc)__gls_null_glRasterPos3sv,
    (GLSfunc)__gls_null_glRasterPos4d,
    (GLSfunc)__gls_null_glRasterPos4dv,
    (GLSfunc)__gls_null_glRasterPos4f,
    (GLSfunc)__gls_null_glRasterPos4fv,
    (GLSfunc)__gls_null_glRasterPos4i,
    (GLSfunc)__gls_null_glRasterPos4iv,
    (GLSfunc)__gls_null_glRasterPos4s,
    (GLSfunc)__gls_null_glRasterPos4sv,
    (GLSfunc)__gls_null_glRectd,
    (GLSfunc)__gls_null_glRectdv,
    (GLSfunc)__gls_null_glRectf,
    (GLSfunc)__gls_null_glRectfv,
    (GLSfunc)__gls_null_glRecti,
    (GLSfunc)__gls_null_glRectiv,
    (GLSfunc)__gls_null_glRects,
    (GLSfunc)__gls_null_glRectsv,
    (GLSfunc)__gls_null_glTexCoord1d,
    (GLSfunc)__gls_null_glTexCoord1dv,
    (GLSfunc)__gls_null_glTexCoord1f,
    (GLSfunc)__gls_null_glTexCoord1fv,
    (GLSfunc)__gls_null_glTexCoord1i,
    (GLSfunc)__gls_null_glTexCoord1iv,
    (GLSfunc)__gls_null_glTexCoord1s,
    (GLSfunc)__gls_null_glTexCoord1sv,
    (GLSfunc)__gls_null_glTexCoord2d,
    (GLSfunc)__gls_null_glTexCoord2dv,
    (GLSfunc)__gls_null_glTexCoord2f,
    (GLSfunc)__gls_null_glTexCoord2fv,
    (GLSfunc)__gls_null_glTexCoord2i,
    (GLSfunc)__gls_null_glTexCoord2iv,
    (GLSfunc)__gls_null_glTexCoord2s,
    (GLSfunc)__gls_null_glTexCoord2sv,
    (GLSfunc)__gls_null_glTexCoord3d,
    (GLSfunc)__gls_null_glTexCoord3dv,
    (GLSfunc)__gls_null_glTexCoord3f,
    (GLSfunc)__gls_null_glTexCoord3fv,
    (GLSfunc)__gls_null_glTexCoord3i,
    (GLSfunc)__gls_null_glTexCoord3iv,
    (GLSfunc)__gls_null_glTexCoord3s,
    (GLSfunc)__gls_null_glTexCoord3sv,
    (GLSfunc)__gls_null_glTexCoord4d,
    (GLSfunc)__gls_null_glTexCoord4dv,
    (GLSfunc)__gls_null_glTexCoord4f,
    (GLSfunc)__gls_null_glTexCoord4fv,
    (GLSfunc)__gls_null_glTexCoord4i,
    (GLSfunc)__gls_null_glTexCoord4iv,
    (GLSfunc)__gls_null_glTexCoord4s,
    (GLSfunc)__gls_null_glTexCoord4sv,
    (GLSfunc)__gls_null_glVertex2d,
    (GLSfunc)__gls_null_glVertex2dv,
    (GLSfunc)__gls_null_glVertex2f,
    (GLSfunc)__gls_null_glVertex2fv,
    (GLSfunc)__gls_null_glVertex2i,
    (GLSfunc)__gls_null_glVertex2iv,
    (GLSfunc)__gls_null_glVertex2s,
    (GLSfunc)__gls_null_glVertex2sv,
    (GLSfunc)__gls_null_glVertex3d,
    (GLSfunc)__gls_null_glVertex3dv,
    (GLSfunc)__gls_null_glVertex3f,
    (GLSfunc)__gls_null_glVertex3fv,
    (GLSfunc)__gls_null_glVertex3i,
    (GLSfunc)__gls_null_glVertex3iv,
    (GLSfunc)__gls_null_glVertex3s,
    (GLSfunc)__gls_null_glVertex3sv,
    (GLSfunc)__gls_null_glVertex4d,
    (GLSfunc)__gls_null_glVertex4dv,
    (GLSfunc)__gls_null_glVertex4f,
    (GLSfunc)__gls_null_glVertex4fv,
    (GLSfunc)__gls_null_glVertex4i,
    (GLSfunc)__gls_null_glVertex4iv,
    (GLSfunc)__gls_null_glVertex4s,
    (GLSfunc)__gls_null_glVertex4sv,
    (GLSfunc)__gls_null_glClipPlane,
    (GLSfunc)__gls_null_glColorMaterial,
    (GLSfunc)__gls_null_glCullFace,
    (GLSfunc)__gls_null_glFogf,
    (GLSfunc)__gls_null_glFogfv,
    (GLSfunc)__gls_null_glFogi,
    (GLSfunc)__gls_null_glFogiv,
    (GLSfunc)__gls_null_glFrontFace,
    (GLSfunc)__gls_null_glHint,
    (GLSfunc)__gls_null_glLightf,
    (GLSfunc)__gls_null_glLightfv,
    (GLSfunc)__gls_null_glLighti,
    (GLSfunc)__gls_null_glLightiv,
    (GLSfunc)__gls_null_glLightModelf,
    (GLSfunc)__gls_null_glLightModelfv,
    (GLSfunc)__gls_null_glLightModeli,
    (GLSfunc)__gls_null_glLightModeliv,
    (GLSfunc)__gls_null_glLineStipple,
    (GLSfunc)__gls_null_glLineWidth,
    (GLSfunc)__gls_null_glMaterialf,
    (GLSfunc)__gls_null_glMaterialfv,
    (GLSfunc)__gls_null_glMateriali,
    (GLSfunc)__gls_null_glMaterialiv,
    (GLSfunc)__gls_null_glPointSize,
    (GLSfunc)__gls_null_glPolygonMode,
    (GLSfunc)__gls_null_glPolygonStipple,
    (GLSfunc)__gls_null_glScissor,
    (GLSfunc)__gls_null_glShadeModel,
    (GLSfunc)__gls_null_glTexParameterf,
    (GLSfunc)__gls_null_glTexParameterfv,
    (GLSfunc)__gls_null_glTexParameteri,
    (GLSfunc)__gls_null_glTexParameteriv,
    (GLSfunc)__gls_null_glTexImage1D,
    (GLSfunc)__gls_null_glTexImage2D,
    (GLSfunc)__gls_null_glTexEnvf,
    (GLSfunc)__gls_null_glTexEnvfv,
    (GLSfunc)__gls_null_glTexEnvi,
    (GLSfunc)__gls_null_glTexEnviv,
    (GLSfunc)__gls_null_glTexGend,
    (GLSfunc)__gls_null_glTexGendv,
    (GLSfunc)__gls_null_glTexGenf,
    (GLSfunc)__gls_null_glTexGenfv,
    (GLSfunc)__gls_null_glTexGeni,
    (GLSfunc)__gls_null_glTexGeniv,
    (GLSfunc)__gls_null_glFeedbackBuffer,
    (GLSfunc)__gls_null_glSelectBuffer,
    (GLSfunc)__gls_null_glRenderMode,
    (GLSfunc)__gls_null_glInitNames,
    (GLSfunc)__gls_null_glLoadName,
    (GLSfunc)__gls_null_glPassThrough,
    (GLSfunc)__gls_null_glPopName,
    (GLSfunc)__gls_null_glPushName,
    (GLSfunc)__gls_null_glDrawBuffer,
    (GLSfunc)__gls_null_glClear,
    (GLSfunc)__gls_null_glClearAccum,
    (GLSfunc)__gls_null_glClearIndex,
    (GLSfunc)__gls_null_glClearColor,
    (GLSfunc)__gls_null_glClearStencil,
    (GLSfunc)__gls_null_glClearDepth,
    (GLSfunc)__gls_null_glStencilMask,
    (GLSfunc)__gls_null_glColorMask,
    (GLSfunc)__gls_null_glDepthMask,
    (GLSfunc)__gls_null_glIndexMask,
    (GLSfunc)__gls_null_glAccum,
    (GLSfunc)__gls_null_glDisable,
    (GLSfunc)__gls_null_glEnable,
    (GLSfunc)__gls_null_glFinish,
    (GLSfunc)__gls_null_glFlush,
    (GLSfunc)__gls_null_glPopAttrib,
    (GLSfunc)__gls_null_glPushAttrib,
    (GLSfunc)__gls_null_glMap1d,
    (GLSfunc)__gls_null_glMap1f,
    (GLSfunc)__gls_null_glMap2d,
    (GLSfunc)__gls_null_glMap2f,
    (GLSfunc)__gls_null_glMapGrid1d,
    (GLSfunc)__gls_null_glMapGrid1f,
    (GLSfunc)__gls_null_glMapGrid2d,
    (GLSfunc)__gls_null_glMapGrid2f,
    (GLSfunc)__gls_null_glEvalCoord1d,
    (GLSfunc)__gls_null_glEvalCoord1dv,
    (GLSfunc)__gls_null_glEvalCoord1f,
    (GLSfunc)__gls_null_glEvalCoord1fv,
    (GLSfunc)__gls_null_glEvalCoord2d,
    (GLSfunc)__gls_null_glEvalCoord2dv,
    (GLSfunc)__gls_null_glEvalCoord2f,
    (GLSfunc)__gls_null_glEvalCoord2fv,
    (GLSfunc)__gls_null_glEvalMesh1,
    (GLSfunc)__gls_null_glEvalPoint1,
    (GLSfunc)__gls_null_glEvalMesh2,
    (GLSfunc)__gls_null_glEvalPoint2,
    (GLSfunc)__gls_null_glAlphaFunc,
    (GLSfunc)__gls_null_glBlendFunc,
    (GLSfunc)__gls_null_glLogicOp,
    (GLSfunc)__gls_null_glStencilFunc,
    (GLSfunc)__gls_null_glStencilOp,
    (GLSfunc)__gls_null_glDepthFunc,
    (GLSfunc)__gls_null_glPixelZoom,
    (GLSfunc)__gls_null_glPixelTransferf,
    (GLSfunc)__gls_null_glPixelTransferi,
    (GLSfunc)__gls_null_glPixelStoref,
    (GLSfunc)__gls_null_glPixelStorei,
    (GLSfunc)__gls_null_glPixelMapfv,
    (GLSfunc)__gls_null_glPixelMapuiv,
    (GLSfunc)__gls_null_glPixelMapusv,
    (GLSfunc)__gls_null_glReadBuffer,
    (GLSfunc)__gls_null_glCopyPixels,
    (GLSfunc)__gls_null_glReadPixels,
    (GLSfunc)__gls_null_glDrawPixels,
    (GLSfunc)__gls_null_glGetBooleanv,
    (GLSfunc)__gls_null_glGetClipPlane,
    (GLSfunc)__gls_null_glGetDoublev,
    (GLSfunc)__gls_null_glGetError,
    (GLSfunc)__gls_null_glGetFloatv,
    (GLSfunc)__gls_null_glGetIntegerv,
    (GLSfunc)__gls_null_glGetLightfv,
    (GLSfunc)__gls_null_glGetLightiv,
    (GLSfunc)__gls_null_glGetMapdv,
    (GLSfunc)__gls_null_glGetMapfv,
    (GLSfunc)__gls_null_glGetMapiv,
    (GLSfunc)__gls_null_glGetMaterialfv,
    (GLSfunc)__gls_null_glGetMaterialiv,
    (GLSfunc)__gls_null_glGetPixelMapfv,
    (GLSfunc)__gls_null_glGetPixelMapuiv,
    (GLSfunc)__gls_null_glGetPixelMapusv,
    (GLSfunc)__gls_null_glGetPolygonStipple,
    (GLSfunc)__gls_null_glGetString,
    (GLSfunc)__gls_null_glGetTexEnvfv,
    (GLSfunc)__gls_null_glGetTexEnviv,
    (GLSfunc)__gls_null_glGetTexGendv,
    (GLSfunc)__gls_null_glGetTexGenfv,
    (GLSfunc)__gls_null_glGetTexGeniv,
    (GLSfunc)__gls_null_glGetTexImage,
    (GLSfunc)__gls_null_glGetTexParameterfv,
    (GLSfunc)__gls_null_glGetTexParameteriv,
    (GLSfunc)__gls_null_glGetTexLevelParameterfv,
    (GLSfunc)__gls_null_glGetTexLevelParameteriv,
    (GLSfunc)__gls_null_glIsEnabled,
    (GLSfunc)__gls_null_glIsList,
    (GLSfunc)__gls_null_glDepthRange,
    (GLSfunc)__gls_null_glFrustum,
    (GLSfunc)__gls_null_glLoadIdentity,
    (GLSfunc)__gls_null_glLoadMatrixf,
    (GLSfunc)__gls_null_glLoadMatrixd,
    (GLSfunc)__gls_null_glMatrixMode,
    (GLSfunc)__gls_null_glMultMatrixf,
    (GLSfunc)__gls_null_glMultMatrixd,
    (GLSfunc)__gls_null_glOrtho,
    (GLSfunc)__gls_null_glPopMatrix,
    (GLSfunc)__gls_null_glPushMatrix,
    (GLSfunc)__gls_null_glRotated,
    (GLSfunc)__gls_null_glRotatef,
    (GLSfunc)__gls_null_glScaled,
    (GLSfunc)__gls_null_glScalef,
    (GLSfunc)__gls_null_glTranslated,
    (GLSfunc)__gls_null_glTranslatef,
    (GLSfunc)__gls_null_glViewport,
    // DrewB - 1.1
    (GLSfunc)__gls_null_glArrayElement,
    (GLSfunc)__gls_null_glBindTexture,
    (GLSfunc)__gls_null_glColorPointer,
    (GLSfunc)__gls_null_glDisableClientState,
    (GLSfunc)__gls_null_glDrawArrays,
    (GLSfunc)__gls_null_glDrawElements,
    (GLSfunc)__gls_null_glEdgeFlagPointer,
    (GLSfunc)__gls_null_glEnableClientState,
    (GLSfunc)__gls_null_glIndexPointer,
    (GLSfunc)__gls_null_glIndexub,
    (GLSfunc)__gls_null_glIndexubv,
    (GLSfunc)__gls_null_glInterleavedArrays,
    (GLSfunc)__gls_null_glNormalPointer,
    (GLSfunc)__gls_null_glPolygonOffset,
    (GLSfunc)__gls_null_glTexCoordPointer,
    (GLSfunc)__gls_null_glVertexPointer,
    (GLSfunc)__gls_null_glAreTexturesResident,
    (GLSfunc)__gls_null_glCopyTexImage1D,
    (GLSfunc)__gls_null_glCopyTexImage2D,
    (GLSfunc)__gls_null_glCopyTexSubImage1D,
    (GLSfunc)__gls_null_glCopyTexSubImage2D,
    (GLSfunc)__gls_null_glDeleteTextures,
    (GLSfunc)__gls_null_glGenTextures,
    (GLSfunc)__gls_null_glGetPointerv,
    (GLSfunc)__gls_null_glIsTexture,
    (GLSfunc)__gls_null_glPrioritizeTextures,
    (GLSfunc)__gls_null_glTexSubImage1D,
    (GLSfunc)__gls_null_glTexSubImage2D,
    (GLSfunc)__gls_null_glPushClientAttrib,
    (GLSfunc)__gls_null_glPopClientAttrib,
    #if __GL_EXT_blend_color
        (GLSfunc)__gls_null_glBlendColorEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        (GLSfunc)__gls_null_glBlendEquationEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        (GLSfunc)__gls_null_glPolygonOffsetEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_null_glTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_null_glTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_null_glSampleMaskSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        (GLSfunc)__gls_null_glSamplePatternSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        (GLSfunc)__gls_null_glTagSampleBufferSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameterfEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameteriEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glCopyConvolutionFilter1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glCopyConvolutionFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetConvolutionFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetConvolutionParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetConvolutionParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glGetSeparableFilterEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        (GLSfunc)__gls_null_glSeparableFilter2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetHistogramParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetHistogramParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetMinmaxParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glGetMinmaxParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glResetHistogramEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        (GLSfunc)__gls_null_glResetMinmaxEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        (GLSfunc)__gls_null_glTexImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        (GLSfunc)__gls_null_glTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_null_glDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        (GLSfunc)__gls_null_glGetDetailTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_null_glSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        (GLSfunc)__gls_null_glGetSharpenTexFuncSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glArrayElementEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glColorPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glDrawArraysEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glEdgeFlagPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glGetPointervEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glIndexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glNormalPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glTexCoordPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        (GLSfunc)__gls_null_glVertexPointerEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glAreTexturesResidentEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glBindTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glDeleteTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glGenTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glIsTextureEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        (GLSfunc)__gls_null_glPrioritizeTexturesEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_null_glColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_null_glColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        (GLSfunc)__gls_null_glCopyColorTableSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glGetColorTableEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glGetColorTableParameterfvEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        (GLSfunc)__gls_null_glGetColorTableParameterivEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glGetTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glGetTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glTexColorTableParameterfvSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        (GLSfunc)__gls_null_glTexColorTableParameterivSGI,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexSubImage1DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexSubImage2DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        (GLSfunc)__gls_null_glCopyTexSubImage3DEXT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_null_glTexImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        (GLSfunc)__gls_null_glTexSubImage4DSGIS,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        (GLSfunc)__gls_null_glPixelTexGenSGIX,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        // DrewB
        (GLSfunc)__gls_null_glColorSubTableEXT,
    #else
        GLS_NONE,
    #endif
    #if __GL_WIN_draw_range_elements
        // MarcFo
        (GLSfunc)__gls_null_glDrawRangeElementsWIN,
    #else
        GLS_NONE,
    #endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_glsapi.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

void glsBeginGLS(GLint inVersionMajor, GLint inVersionMinor) {
    typedef void (*__GLSdispatch)(GLint, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[16])(inVersionMajor, inVersionMinor);
}

void glsBlock(GLSenum inBlockType) {
    typedef void (*__GLSdispatch)(GLSenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[17])(inBlockType);
}

GLSenum glsCallStream(const GLubyte *inName) {
    typedef GLSenum (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return 0;
    return ((__GLSdispatch)__glsCtx->dispatchAPI[18])(inName);
}

void glsEndGLS(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[19])();
}

void glsError(GLSopcode inOpcode, GLSenum inError) {
    typedef void (*__GLSdispatch)(GLSopcode, GLSenum);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[20])(inOpcode, inError);
}

void glsGLRC(GLuint inGLRC) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[21])(inGLRC);
}

void glsGLRCLayer(GLuint inGLRC, GLuint inLayer, GLuint inReadLayer) {
    typedef void (*__GLSdispatch)(GLuint, GLuint, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[22])(inGLRC, inLayer, inReadLayer);
}

void glsHeaderGLRCi(GLuint inGLRC, GLSenum inAttrib, GLint inVal) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[23])(inGLRC, inAttrib, inVal);
}

void glsHeaderLayerf(GLuint inLayer, GLSenum inAttrib, GLfloat inVal) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[24])(inLayer, inAttrib, inVal);
}

void glsHeaderLayeri(GLuint inLayer, GLSenum inAttrib, GLint inVal) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[25])(inLayer, inAttrib, inVal);
}

void glsHeaderf(GLSenum inAttrib, GLfloat inVal) {
    typedef void (*__GLSdispatch)(GLSenum, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[26])(inAttrib, inVal);
}

void glsHeaderfv(GLSenum inAttrib, const GLfloat *inVec) {
    typedef void (*__GLSdispatch)(GLSenum, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[27])(inAttrib, inVec);
}

void glsHeaderi(GLSenum inAttrib, GLint inVal) {
    typedef void (*__GLSdispatch)(GLSenum, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[28])(inAttrib, inVal);
}

void glsHeaderiv(GLSenum inAttrib, const GLint *inVec) {
    typedef void (*__GLSdispatch)(GLSenum, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[29])(inAttrib, inVec);
}

void glsHeaderubz(GLSenum inAttrib, const GLubyte *inString) {
    typedef void (*__GLSdispatch)(GLSenum, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[30])(inAttrib, inString);
}

void glsRequireExtension(const GLubyte *inExtension) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[31])(inExtension);
}

void glsUnsupportedCommand(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[32])();
}

void glsAppRef(GLulong inAddress, GLuint inCount) {
    typedef void (*__GLSdispatch)(GLulong, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[33])(inAddress, inCount);
}

void glsBeginObj(const GLubyte *inTag) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[34])(inTag);
}

void glsCharubz(const GLubyte *inTag, const GLubyte *inString) {
    typedef void (*__GLSdispatch)(const GLubyte *, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[35])(inTag, inString);
}

void glsComment(const GLubyte *inComment) {
    typedef void (*__GLSdispatch)(const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[36])(inComment);
}

void glsDisplayMapfv(GLuint inLayer, GLSenum inMap, GLuint inCount, const GLfloat *inVec) {
    typedef void (*__GLSdispatch)(GLuint, GLSenum, GLuint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[37])(inLayer, inMap, inCount, inVec);
}

void glsEndObj(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[38])();
}

void glsNumb(const GLubyte *inTag, GLbyte inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLbyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[39])(inTag, inVal);
}

void glsNumbv(const GLubyte *inTag, GLuint inCount, const GLbyte *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLbyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[40])(inTag, inCount, inVec);
}

void glsNumd(const GLubyte *inTag, GLdouble inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLdouble);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[41])(inTag, inVal);
}

void glsNumdv(const GLubyte *inTag, GLuint inCount, const GLdouble *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLdouble *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[42])(inTag, inCount, inVec);
}

void glsNumf(const GLubyte *inTag, GLfloat inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLfloat);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[43])(inTag, inVal);
}

void glsNumfv(const GLubyte *inTag, GLuint inCount, const GLfloat *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLfloat *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[44])(inTag, inCount, inVec);
}

void glsNumi(const GLubyte *inTag, GLint inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[45])(inTag, inVal);
}

void glsNumiv(const GLubyte *inTag, GLuint inCount, const GLint *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[46])(inTag, inCount, inVec);
}

void glsNuml(const GLubyte *inTag, GLlong inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLlong);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[47])(inTag, inVal);
}

void glsNumlv(const GLubyte *inTag, GLuint inCount, const GLlong *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLlong *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[48])(inTag, inCount, inVec);
}

void glsNums(const GLubyte *inTag, GLshort inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLshort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[49])(inTag, inVal);
}

void glsNumsv(const GLubyte *inTag, GLuint inCount, const GLshort *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLshort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[50])(inTag, inCount, inVec);
}

void glsNumub(const GLubyte *inTag, GLubyte inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLubyte);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[51])(inTag, inVal);
}

void glsNumubv(const GLubyte *inTag, GLuint inCount, const GLubyte *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLubyte *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[52])(inTag, inCount, inVec);
}

void glsNumui(const GLubyte *inTag, GLuint inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[53])(inTag, inVal);
}

void glsNumuiv(const GLubyte *inTag, GLuint inCount, const GLuint *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLuint *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[54])(inTag, inCount, inVec);
}

void glsNumul(const GLubyte *inTag, GLulong inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLulong);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[55])(inTag, inVal);
}

void glsNumulv(const GLubyte *inTag, GLuint inCount, const GLulong *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLulong *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[56])(inTag, inCount, inVec);
}

void glsNumus(const GLubyte *inTag, GLushort inVal) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLushort);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[57])(inTag, inVal);
}

void glsNumusv(const GLubyte *inTag, GLuint inCount, const GLushort *inVec) {
    typedef void (*__GLSdispatch)(const GLubyte *, GLuint, const GLushort *);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[58])(inTag, inCount, inVec);
}

void glsPad(void) {
    typedef void (*__GLSdispatch)(void);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[59])();
}

void glsSwapBuffers(GLuint inLayer) {
    typedef void (*__GLSdispatch)(GLuint);
    __GLScontext *const __glsCtx = __GLS_CONTEXT;
    if (!__glsCtx) return;
    ((__GLSdispatch)__glsCtx->dispatchAPI[60])(inLayer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\immed.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>
#include <string.h>

static GLboolean __glsRequireContext(void) {
    if (__GLS_CONTEXT) {
        return GL_TRUE;
    } else {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return GL_FALSE;
    }
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
void glsAbortCall(GLSenum inMode) {
    if (!__glsRequireContext()) return;
    switch (inMode) {
        case GLS_NONE:
        case GLS_LAST:
        case GLS_ALL:
            __GLS_CONTEXT->abortMode = inMode;
            __glsContext_updateDispatchDecode_bin(__GLS_CONTEXT);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}
#else
void __glsInternalAbortCall(__GLScontext *ctx, GLSenum inMode) {
    switch (inMode) {
    case GLS_NONE:
    case GLS_LAST:
    case GLS_ALL:
        ctx->abortMode = inMode;
        __glsContext_updateDispatchDecode_bin(ctx);
        break;
    default:
        __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
        break;
    }
}
void glsAbortCall(GLSenum inMode) {
    if (!__glsRequireContext()) return;
    __glsInternalAbortCall(__GLS_CONTEXT, inMode);
}
#endif

GLboolean glsBeginCapture(
    const GLubyte *inStreamName,
    GLSenum inCaptureStreamType,
    GLbitfield inWriteFlags
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriter *writer;

    if (!__glsRequireContext()) return GL_FALSE;
    if (ctx->captureNesting >= __GLS_MAX_CAPTURE_NESTING) {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
        return GL_FALSE;
    }
    if (!__glsValidateString(inStreamName)) return GL_FALSE;
    switch (inCaptureStreamType) {
        case GLS_CONTEXT:
        case GLS_BINARY_LSB_FIRST:
        case GLS_BINARY_MSB_FIRST:
        case GLS_TEXT:
            if (
                writer = __glsWriter_create(
                    inStreamName, inCaptureStreamType, inWriteFlags
                )
            ) {
                if (!ctx->captureNesting++) {
                    __glsContext_updateDispatchTables(ctx);
                }
                ctx->writer = ctx->writers[ctx->captureNesting - 1] = writer;
                return GL_TRUE;
            } else {
                return GL_FALSE;
            }
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GL_FALSE;
    }
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsCallArray_bin(size_t inCount, const GLubyte *inArray) {
    __GLScontext *ctx = __GLS_CONTEXT;
#else
static void __glsCallArray_bin(__GLScontext *ctx,
                               size_t inCount, const GLubyte *inArray) {
#endif
    const GLubyte *const arrayTail = inArray + inCount;
    size_t cmdBytes, headBytes;
    const __GLSbinCommandHead_large *head;
    GLSopcode op;

    for (;;) {
        headBytes = sizeof(__GLSbinCommandHead_small);
        if (inArray + headBytes > arrayTail) return;
        head = (const __GLSbinCommandHead_large *)inArray;
        if (head->countSmall) {
            op = head->opSmall;
            cmdBytes = head->countSmall << 2;
        } else {
            if (ctx->abortMode) return;
            headBytes = sizeof(__GLSbinCommandHead_large);
            if (inArray + headBytes > arrayTail) return;
            op = head->opLarge;
            cmdBytes = head->countLarge << 2;
        }
        if (inArray + cmdBytes > arrayTail) return;
        op = __glsMapOpcode(op);
        if (!__glsOpcodeString[op]) op = GLS_OP_glsUnsupportedCommand;
#ifndef __GLS_PLATFORM_WIN32
        // DrewB
        ctx->dispatchDecode_bin[op]((GLubyte *)inArray + headBytes);
#else
        ctx->dispatchDecode_bin[op](ctx, (GLubyte *)inArray + headBytes);
#endif
        inArray += cmdBytes;
    }
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsCallArray_bin_swap(size_t inCount, const GLubyte *inArray) {
    __GLScontext *ctx = __GLS_CONTEXT;
#else
static void __glsCallArray_bin_swap(__GLScontext *ctx,
                               size_t inCount, const GLubyte *inArray) {
#endif
    const GLubyte *const arrayTail = inArray + inCount;
    GLubyte *buf = GLS_NONE;
    size_t bufSize = 0, cmdBytes, headBytes;
    const __GLSbinCommandHead_large *head;
    GLSopcode mappedOp, op;

    for (;;) {
        if (ctx->abortMode) goto done;
        headBytes = sizeof(__GLSbinCommandHead_small);
        if (inArray + headBytes > arrayTail) goto done;
        head = (const __GLSbinCommandHead_large *)inArray;
        if (head->countSmall) {
            op = __glsSwaps((GLshort)head->opSmall);
            cmdBytes = __glsSwaps((GLshort)head->countSmall) << 2;
        } else {
            headBytes = sizeof(__GLSbinCommandHead_large);
            if (inArray + headBytes > arrayTail) goto done;
            op = __glsSwapi((GLint)head->opLarge);
            cmdBytes = __glsSwapi((GLint)head->countLarge) << 2;
        }
        if (inArray + cmdBytes > arrayTail) goto done;
        if (__glsOpcodeString[mappedOp = __glsMapOpcode(op)]) {
            GLScommandAlignment align;

            glsGetCommandAlignment(op, __GLS_BINARY_SWAP1, &align);
            if (bufSize < cmdBytes + align.value) {
                GLubyte *const newBuf = (GLubyte *)realloc(
                    buf, bufSize = cmdBytes + align.value
                );

                if (!newBuf) {
                    free(buf);
                    bufSize = 0;
                }
                buf = newBuf;
            }
            if (buf) {
                memcpy(buf + align.value, inArray, cmdBytes);
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                __glsDispatchDecode_bin_swap[mappedOp](
                    buf + align.value + headBytes
                );
#else
                __glsDispatchDecode_bin_swap[mappedOp](
                    ctx, buf + align.value + headBytes
                );
#endif
            } else {
                __GLS_CALL_ERROR(ctx, op, GLS_OUT_OF_MEMORY);
            }
        } else {
            __GLS_CALL_UNSUPPORTED_COMMAND(ctx);
        }
        inArray += cmdBytes;
    }
done:
    free(buf);
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
static void __glsCallArray_text(size_t inCount, const GLubyte *inArray) {
    __GLScontext *ctx = __GLS_CONTEXT;
#else
static void __glsCallArray_text(__GLScontext *ctx,
                               size_t inCount, const GLubyte *inArray) {
#endif
    __GLSstring cmd;
    GLSopcode op;
    __GLSreader reader;

    if (!__glsParser) {
        __glsBeginCriticalSection();
        if (!__glsParser) __glsParser = __glsParser_create();
        __glsEndCriticalSection();
        if (!__glsParser) {
            __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
            return;
        }
    }
    __glsString_init(&cmd);
    __glsReader_init_array(&reader, inArray, inCount);
    for (;;) {
        if (ctx->abortMode || !__glsReader_beginCommand_text(&reader, &cmd)) {
            break;
        }
        if (__glsParser_findCommand(__glsParser, cmd.head, &op)) {
#ifndef __GLS_PLATFORM_WIN32
            // DrewB
            __glsDispatchDecode_text[__glsMapOpcode(op)](&reader);
#else
            __glsDispatchDecode_text[__glsMapOpcode(op)](ctx, &reader);
#endif
            __glsReader_endCommand_text(&reader);
            if (reader.error) {
                __GLS_CALL_ERROR(ctx, op, reader.error);
                __glsReader_abortCommand_text(&reader);
            }
        } else {
            __glsReader_abortCommand_text(&reader);
        }
    }
    __glsString_final(&cmd);
    __glsReader_final(&reader);
}

#ifndef __GLS_PLATFORM_WIN32
// DrewB
void glsCallArray(
    GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray
) {
    GLboolean callSave;
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (ctx->abortMode) return;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        glsAbortCall(GLS_ALL);
        return;
    }
    ++ctx->callNesting;
    callSave = ctx->contextCall;
    ctx->contextCall = GL_TRUE;
    switch (inExternStreamType) {
        case __GLS_BINARY_SWAP0:
            __glsCallArray_bin(inCount, inArray);
            break;
        case __GLS_BINARY_SWAP1:
            __glsCallArray_bin_swap(inCount, inArray);
            break;
        case GLS_TEXT:
            __glsCallArray_text(inCount, inArray);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
    ctx->contextCall = callSave;
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) glsAbortCall(GLS_NONE);
            break;
        case GLS_LAST:
            glsAbortCall(GLS_NONE);
            break;
    }
}
#else
void glsCallArrayInContext(
    GLuint inCtx,
    GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray
) {
    GLboolean callSave;
    __GLScontext *ctx;

    __glsBeginCriticalSection();
    ctx = (__GLScontext *)__glsInt2PtrDict_find(
            __glsContextDict, (GLint)inCtx
            );
    __glsEndCriticalSection();

    if (ctx == NULL) return;
    if (ctx->abortMode) return;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        __glsInternalAbortCall(ctx, GLS_ALL);
        return;
    }
    ++ctx->callNesting;
    callSave = ctx->contextCall;
    ctx->contextCall = GL_TRUE;
    switch (inExternStreamType) {
        case __GLS_BINARY_SWAP0:
            __glsCallArray_bin(ctx, inCount, inArray);
            break;
        case __GLS_BINARY_SWAP1:
            __glsCallArray_bin_swap(ctx, inCount, inArray);
            break;
        case GLS_TEXT:
            __glsCallArray_text(ctx, inCount, inArray);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
    ctx->contextCall = callSave;
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) __glsInternalAbortCall(ctx, GLS_NONE);
            break;
        case GLS_LAST:
            __glsInternalAbortCall(ctx, GLS_NONE);
            break;
    }
}
void glsCallArray(
    GLSenum inExternStreamType, size_t inCount, const GLubyte *inArray
) {
    glsCallArrayInContext(__GLS_CONTEXT->name, inExternStreamType, inCount,
                          inArray);
}
#endif

void glsCaptureFlags(GLSopcode inOpcode, GLbitfield inFlags) {
    if (!__glsRequireContext()) return;
    if (!__glsValidateOpcode(inOpcode)) return;
    switch (inOpcode) {
        case GLS_OP_glsBeginGLS:
        case GLS_OP_glsEndGLS:
        case GLS_OP_glsPad:
            return;
    }
    inOpcode = __glsMapOpcode(inOpcode);
    __GLS_CONTEXT->captureFlags[inOpcode] = (GLubyte)inFlags;
}

void glsCaptureFunc(GLSenum inTarget, GLScaptureFunc inFunc) {
    if (!__glsRequireContext()) return;
    switch (inTarget) {
        case GLS_CAPTURE_ENTRY_FUNC:
            __GLS_CONTEXT->captureEntryFunc = inFunc;
            break;
        case GLS_CAPTURE_EXIT_FUNC:
            __GLS_CONTEXT->captureExitFunc = inFunc;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void glsChannel(GLSenum inTarget, FILE *inChannel) {
    if (!__glsRequireContext()) return;
    switch (inTarget) {
        case GLS_DEFAULT_READ_CHANNEL:
            __GLS_CONTEXT->defaultReadChannel = inChannel;
            break;
        case GLS_DEFAULT_WRITE_CHANNEL:
            __GLS_CONTEXT->defaultWriteChannel = inChannel;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
    }
}

void glsCommandFunc(GLSopcode inOpcode, GLSfunc inFunc) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (!__glsValidateOpcode(inOpcode)) return;
    inOpcode = __glsMapOpcode(inOpcode);
    ctx->commandFuncs[inOpcode] = inFunc;
    ctx->dispatchCall[inOpcode] = inFunc ? inFunc : ctx->dispatchAPI[inOpcode];
    if (!ctx->abortMode && !__glsDispatchDecode_bin_default[inOpcode]) {
        ctx->dispatchDecode_bin[inOpcode] = (
            (__GLSdecodeBinFunc)ctx->dispatchCall[inOpcode]
        );
    }
}

GLSenum glsCopyStream(
    const GLubyte *inSource,
    const GLubyte *inDest,
    GLSenum inDestType,
    GLbitfield inWriteFlags
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;
    GLSenum outType = GLS_NONE;
    __GLSversion versionSave;

    if (!__glsRequireContext()) return outType;
    if (!__glsValidateString(inSource)) return outType;
    if (!__glsValidateString(inDest)) return outType;
    switch (inDestType) {
        case GLS_NONE:
        case GLS_CONTEXT:
        case GLS_BINARY_LSB_FIRST:
        case GLS_BINARY_MSB_FIRST:
        case GLS_TEXT:
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return outType;
    }
    if (ctx->abortMode) return outType;
    if (ctx->callNesting >= __GLS_MAX_CALL_NESTING) {
        __GLS_RAISE_ERROR(GLS_CALL_OVERFLOW);
        glsAbortCall(GLS_ALL);
        return outType;
    }
    ++ctx->callNesting;
    versionSave = ctx->streamVersion;
    ctx->streamVersion.major = ctx->streamVersion.minor = 0;
    if (
        contextStream = __glsStr2PtrDict_find(ctx->contextStreamDict, inSource)
    ) {
        GLint i;

        if (inDestType == GLS_NONE) inDestType = GLS_CONTEXT;
        for (i = 0 ; i < ctx->captureNesting ; ++i) {
            if (ctx->writers[i]->contextStream == contextStream) {
                __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                inDestType = GLS_NONE;
                break;
            }
        }
        if (
            inDestType == GLS_CONTEXT &&
            !strcmp(
                (const char *)inDest, (const char *)contextStream->name.head
            )
        ) {
            __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
            inDestType = GLS_NONE;
        }
        if (inDestType) {
            if (glsBeginCapture(inDest, inDestType, inWriteFlags)) {
                outType = GLS_CONTEXT;
                __glsContextStream_call(contextStream);
                glsEndCapture();
            }
        }
    } else if (readStream = __glsReadStream_create(inSource)) {
        __GLSreader reader;

        if (__glsReader_init_stream(
            &reader, readStream, __GLS_READER_BUF_BYTES
        )) {
            if (inDestType == GLS_NONE) inDestType = reader.type;
            if (glsBeginCapture(inDest, inDestType, inWriteFlags)) {
                outType = reader.type;
                __glsReader_call(&reader);
                glsEndCapture();
            }
            __glsReader_final(&reader);
        } else {
            __GLS_RAISE_ERROR(GLS_INVALID_STREAM);
        }
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
    }
    --ctx->callNesting;
    switch (ctx->abortMode) {
        case GLS_ALL:
            if (!ctx->callNesting) glsAbortCall(GLS_NONE);
            break;
        case GLS_LAST:
            glsAbortCall(GLS_NONE);
            break;
    }
    ctx->streamVersion = versionSave;
    return outType;
}

void glsDataPointer(GLvoid *inPointer) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->dataPointer = inPointer;
}

void glsDeleteReadPrefix(GLuint inIndex) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (inIndex >= ctx->readPrefixList.count) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return;
    }
    __GLS_ITERLIST_SEEK(&ctx->readPrefixList, inIndex);
    __GLS_ITERLIST_REMOVE_DESTROY(
        &ctx->readPrefixList,
        ctx->readPrefixList.iterElem,
        __glsListString_destroy
    );
}

void glsDeleteStream(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return;
    if (!__glsValidateString(inName)) return;
    if (
        contextStream = __glsStr2PtrDict_find(ctx->contextStreamDict, inName)
    ) {
        __glsStrDict_remove(ctx->contextStreamDict, contextStream->name.head);
        __GLS_ITERLIST_REMOVE(&ctx->contextStreamList, contextStream);
        if (contextStream->callCount) {
            contextStream->deleted = GL_TRUE;
        } else {
            __glsContextStream_destroy(contextStream);
        }
    } else if (readStream = __glsReadStream_create(inName)) {
        if (remove((const char *)readStream->name.head)) {
            __GLS_RAISE_ERROR(GLS_STREAM_DELETE_ERROR);
        }
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
    }
}

void glsEndCapture(void) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return;
    if (ctx->captureNesting > 0) {
        const GLint n = --ctx->captureNesting;

        __glsWriter_destroy(ctx->writer);
        ctx->writer = n ? ctx->writers[n - 1] : GLS_NONE;
        if (!n) __glsContext_updateDispatchTables(ctx);
    } else {
        __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
    }
}

void glsFlush(GLSenum inFlushType) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLint i;

    if (!__glsRequireContext()) return;
    switch (inFlushType) {
        case GLS_ALL:
            for (i = 0 ; i < ctx->captureNesting ; ++i) {
                __glsWriter_flush(ctx->writers[i]);
            }
            break;
        case GLS_LAST:
            if (ctx->writer) __glsWriter_flush(ctx->writer);
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

GLbitfield glsGetCaptureFlags(GLSopcode inOpcode) {
    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;

    return __GLS_CONTEXT->captureFlags[__glsMapOpcode(inOpcode)];
}

GLSfunc glsGetCommandFunc(GLSopcode inOpcode) {
    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;

    return __GLS_CONTEXT->commandFuncs[__glsMapOpcode(inOpcode)];
}

GLSfunc glsGetContextFunc(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_CAPTURE_ENTRY_FUNC:
            return (GLSfunc)ctx->captureEntryFunc;
        case GLS_CAPTURE_EXIT_FUNC:
            return (GLSfunc)ctx->captureExitFunc;
        case GLS_READ_FUNC:
            return (GLSfunc)ctx->readFunc;
        case GLS_UNREAD_FUNC:
            return (GLSfunc)ctx->unreadFunc;
        case GLS_WRITE_FUNC:
            return (GLSfunc)ctx->writeFunc;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

GLlong glsGetContextListl(GLSenum inAttrib, GLuint inIndex) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return __glsSizeToLong(0);
    switch (inAttrib) {
        case GLS_OUT_ARG_LIST:
            if (inIndex >= (GLuint)ctx->outArgs.count) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
                return __glsSizeToLong(0);
            }
            return *(GLlong *)(ctx->outArgs.vals + inIndex);
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return __glsSizeToLong(0);
    }
}

const GLubyte* glsGetContextListubz(GLSenum inAttrib, GLuint inIndex) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLubyte *outStr;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_CONTEXT_STREAM_LIST:
            if (inIndex >= ctx->contextStreamList.count) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
                return 0;
            }
            __GLS_ITERLIST_SEEK(&ctx->contextStreamList, inIndex);
            outStr = ctx->contextStreamList.iterElem->name.head;
            break;
        case GLS_READ_PREFIX_LIST:
            if (inIndex >= ctx->readPrefixList.count) {
                __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
                return 0;
            }
            __GLS_ITERLIST_SEEK(&ctx->readPrefixList, inIndex);
            outStr = ctx->readPrefixList.iterElem->val.head;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return (
        __glsString_assign(&ctx->returnString, outStr) ?
        ctx->returnString.head :
        GLS_NONE
    );
}

GLvoid* glsGetContextPointer(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_DEFAULT_READ_CHANNEL:
            return ctx->defaultReadChannel;
        case GLS_DEFAULT_WRITE_CHANNEL:
            return ctx->defaultWriteChannel;
        case GLS_DATA_POINTER:
            return ctx->dataPointer;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

GLint glsGetContexti(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return 0;
    switch (inAttrib) {
        case GLS_ABORT_MODE:
            return (GLint)ctx->abortMode;
        case GLS_BLOCK_TYPE:
            return (GLint)ctx->blockType;
        case GLS_CALL_NESTING:
            return ctx->callNesting;
        case GLS_CAPTURE_NESTING:
            return ctx->captureNesting;
        case GLS_CONTEXT_STREAM_COUNT:
            return (GLint)ctx->contextStreamList.count;
        case GLS_CURRENT_GLRC:
            return (GLint)ctx->currentGLRC;
        case GLS_OUT_ARG_COUNT:
            return ctx->outArgs.count;
        case GLS_PIXEL_SETUP_GEN:
            return ctx->pixelSetupGen;
        case GLS_READ_PREFIX_COUNT:
            return (GLint)ctx->readPrefixList.count;
        case GLS_STREAM_VERSION_MAJOR:
            return ctx->streamVersion.major;
        case GLS_STREAM_VERSION_MINOR:
            return ctx->streamVersion.minor;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

const GLubyte* glsGetContextubz(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLubyte *outStr;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_WRITE_PREFIX:
            outStr = ctx->writePrefix->val.head;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return (
        __glsString_assign(&ctx->returnString, outStr) ?
        ctx->returnString.head :
        GLS_NONE
    );
}

GLint glsGetGLRCi(GLuint inGLRC, GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSglrc *glrc;

    if (!__glsRequireContext()) return 0;
    if (!inGLRC || inGLRC > (GLuint)ctx->header.glrcCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return 0;
    }
    glrc = ctx->header.glrcs + inGLRC - 1;
    switch (inAttrib) {
        case GLS_LAYER:
            return (GLint)glrc->layer;
        case GLS_READ_LAYER:
            return (GLint)glrc->readLayer;
        case GLS_SHARE_GLRC:
            return (GLint)glrc->shareGLRC;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

GLfloat glsGetHeaderf(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return (GLfloat)0;
    switch (inAttrib) {
        case GLS_ASPECT:
            return ctx->header.aspect;
        case GLS_BORDER_WIDTH:
            return ctx->header.borderWidth;
        case GLS_CONTRAST_RATIO:
            return ctx->header.contrastRatio;
        case GLS_HEIGHT_MM:
            return ctx->header.heightMM;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return (GLfloat)0;
    }
}

GLfloat* glsGetHeaderfv(GLSenum inAttrib, GLfloat *outVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLint i;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_BORDER_COLOR:
            for (i = 0 ; i < 4 ; ++i) outVec[i] = ctx->header.borderColor[i];
            return outVec;
        case GLS_GAMMA:
            for (i = 0 ; i < 4 ; ++i) outVec[i] = ctx->header.gamma[i];
            return outVec;
        case GLS_ORIGIN:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.origin[i];
            return outVec;
        case GLS_PAGE_COLOR:
            for (i = 0 ; i < 4 ; ++i) outVec[i] = ctx->header.pageColor[i];
            return outVec;
        case GLS_PAGE_SIZE:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.pageSize[i];
            return outVec;
        case GLS_RED_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.redPoint[i];
            return outVec;
        case GLS_GREEN_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.greenPoint[i];
            return outVec;
        case GLS_BLUE_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.bluePoint[i];
            return outVec;
        case GLS_WHITE_POINT:
            for (i = 0 ; i < 2 ; ++i) outVec[i] = ctx->header.whitePoint[i];
            return outVec;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

GLint glsGetHeaderi(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;

    if (!__glsRequireContext()) return 0;
    switch (inAttrib) {
        case GLS_FRAME_COUNT:
            return ctx->header.frameCount;
        case GLS_GLRC_COUNT:
            return ctx->header.glrcCount;
        case GLS_HEIGHT_PIXELS:
            return ctx->header.heightPixels;
        case GLS_LAYER_COUNT:
            return ctx->header.layerCount;
        case GLS_TILEABLE:
            return ctx->header.tileable;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

GLint* glsGetHeaderiv(GLSenum inAttrib, GLint *outVec) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLint i;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_CREATE_TIME:
            for (i = 0 ; i < 6 ; ++i) outVec[i] = ctx->header.createTime[i];
            return outVec;
        case GLS_MODIFY_TIME:
            for (i = 0 ; i < 6 ; ++i) outVec[i] = ctx->header.modifyTime[i];
            return outVec;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
}

const GLubyte* glsGetHeaderubz(GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    GLubyte *outStr;

    if (!__glsRequireContext()) return GLS_NONE;
    switch (inAttrib) {
        case GLS_EXTENSIONS:
            outStr = ctx->header.extensions.head;
            break;
        case GLS_AUTHOR:
            outStr = ctx->header.author.head;
            break;
        case GLS_DESCRIPTION:
            outStr = ctx->header.description.head;
            break;
        case GLS_NOTES:
            outStr = ctx->header.notes.head;
            break;
        case GLS_TITLE:
            outStr = ctx->header.title.head;
            break;
        case GLS_TOOLS:
            outStr = ctx->header.tools.head;
            break;
        case GLS_VERSION:
            outStr = ctx->header.version.head;
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return GLS_NONE;
    }
    return (
        __glsString_assign(&ctx->returnString, outStr) ?
        ctx->returnString.head :
        GLS_NONE
    );
}

GLfloat glsGetLayerf(GLuint inLayer, GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (!__glsRequireContext()) return (GLfloat)0;
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return (GLfloat)0;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_INVISIBLE_ASPECT:
            return layer->invisibleAspect;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return (GLfloat)0;
    }
}

GLint glsGetLayeri(GLuint inLayer, GLSenum inAttrib) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlayer *layer;

    if (!__glsRequireContext()) return 0;
    if (!inLayer || inLayer > (GLuint)ctx->header.layerCount) {
        __GLS_RAISE_ERROR(GLS_INVALID_VALUE);
        return 0;
    }
    layer = ctx->header.layers + inLayer - 1;
    switch (inAttrib) {
        case GLS_DISPLAY_FORMAT:
            return (GLint)layer->displayFormat;
        case GLS_DOUBLEBUFFER:
            return layer->doubleBuffer;
        case GLS_INVISIBLE:
            return layer->invisible;
        case GLS_INVISIBLE_HEIGHT_PIXELS:
            return layer->invisibleHeightPixels;
        case GLS_LEVEL:
            return layer->level;
        case GLS_STEREO:
            return layer->stereo;
        case GLS_TRANSPARENT:
            return layer->transparent;
        case GLS_INDEX_BITS:
            return layer->indexBits;
        case GLS_RED_BITS:
            return layer->redBits;
        case GLS_GREEN_BITS:
            return layer->greenBits;
        case GLS_BLUE_BITS:
            return layer->blueBits;
        case GLS_ALPHA_BITS:
            return layer->alphaBits;
        case GLS_DEPTH_BITS:
            return layer->depthBits;
        case GLS_STENCIL_BITS:
            return layer->stencilBits;
        case GLS_ACCUM_RED_BITS:
            return layer->accumRedBits;
        case GLS_ACCUM_GREEN_BITS:
            return layer->accumGreenBits;
        case GLS_ACCUM_BLUE_BITS:
            return layer->accumBlueBits;
        case GLS_ACCUM_ALPHA_BITS:
            return layer->accumAlphaBits;
        case GLS_AUX_BUFFERS:
            return layer->auxBuffers;
        #if __GL_SGIS_multisample
            case GLS_SAMPLE_BUFFERS_SGIS:
                return layer->sampleBuffers;
            case GLS_SAMPLES_SGIS:
                return layer->samples;
        #endif /* __GL_SGIS_multisample */
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            return 0;
    }
}

GLbitfield glsGetStreamAttrib(const GLubyte *inName) {
    if (!__glsRequireContext()) return GL_FALSE;
    if (!__glsValidateString(inName)) return GL_FALSE;
    if (__glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)) {
        return (
            GLS_STREAM_CONTEXT_BIT |
            GLS_STREAM_NAMED_BIT |
            GLS_STREAM_READABLE_BIT |
            GLS_STREAM_WRITABLE_BIT |
            GLS_STREAM_SEEKABLE_BIT
        );
    } else {
        GLbitfield outVal = GLS_NONE;
        __GLSreadStream *const readStream = __glsReadStream_create(inName);

        if (readStream) {
            outVal = __glsReadStream_getAttrib(readStream);
            __glsReadStream_destroy(readStream);
        }
        return outVal;
    }
}

GLuint glsGetStreamCRC32(const GLubyte *inName) {
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return 0;
    if (!__glsValidateString(inName)) return 0;
    glsFlush(GLS_ALL);
    if (
        contextStream =
        __glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)
    ) {
        return __glsContextStream_getCRC32(contextStream);
    } else if (readStream = __glsReadStream_create(inName)) {
        const GLuint outVal = __glsReadStream_getCRC32(readStream);

        __glsReadStream_destroy(readStream);
        return outVal;
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return 0;
    }
}

const GLubyte* glsGetStreamReadName(const GLubyte *inName) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;
    GLboolean ok;

    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateString(inName)) return GLS_NONE;
    if (
        contextStream =
        __glsStr2PtrDict_find(ctx->contextStreamDict, inName)
    ) {
        ok = __glsString_assign(&ctx->returnString, contextStream->name.head);
    } else if (readStream = __glsReadStream_create(inName)) {
        ok = __glsString_assign(&ctx->returnString, readStream->name.head);
        __glsReadStream_destroy(readStream);
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return GLS_NONE;
    }
    return ok ? ctx->returnString.head : GLS_NONE;
}

size_t glsGetStreamSize(const GLubyte *inName) {
    __GLScontextStream *contextStream;
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return 0;
    if (!__glsValidateString(inName)) return 0;
    glsFlush(GLS_ALL);
    if (
        contextStream =
        __glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)
    ) {
        return __glsContextStream_getByteCount(contextStream);
    } else if (readStream = __glsReadStream_create(inName)) {
        const size_t outVal = __glsReadStream_getByteCount(readStream);
        __glsReadStream_destroy(readStream);
        return outVal;
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return 0;
    }
}

GLSenum glsGetStreamType(const GLubyte *inName) {
    __GLSreadStream *readStream;

    if (!__glsRequireContext()) return GLS_NONE;
    if (!__glsValidateString(inName)) return GLS_NONE;
    if (__glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName)) {
        return GLS_CONTEXT;
    } else if (readStream = __glsReadStream_create(inName)) {
        const GLSenum outVal = __glsReadStream_getType(readStream);

        __glsReadStream_destroy(readStream);
        return outVal;
    } else {
        __GLS_RAISE_ERROR(GLS_NOT_FOUND);
        return GLS_NONE;
    }
}

GLboolean glsIsContextStream(const GLubyte *inName) {
    if (!__glsRequireContext()) return GL_FALSE;
    if (!__glsValidateString(inName)) return GL_FALSE;
    return (GLboolean)(
        __glsStr2PtrDict_find(__GLS_CONTEXT->contextStreamDict, inName) !=
        GLS_NONE
    );
}

void glsPixelSetupGen(GLboolean inEnabled) {
    __GLS_CONTEXT->pixelSetupGen = (GLboolean)(inEnabled ? GL_TRUE : GL_FALSE);
}

void glsReadFunc(GLSreadFunc inFunc) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->readFunc = inFunc;
}

void glsReadPrefix(GLSenum inListOp, const GLubyte *inPrefix) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSlistString *prefix;

    if (!__glsRequireContext()) return;
    if (!__glsValidateString(inPrefix)) return;
    switch (inListOp) {
        case GLS_APPEND:
            if (prefix = __glsListString_create(inPrefix)) {
                __GLS_ITERLIST_APPEND(&ctx->readPrefixList, prefix);
            }
            break;
        case GLS_PREPEND:
            if (prefix = __glsListString_create(inPrefix)) {
                __GLS_ITERLIST_PREPEND(&ctx->readPrefixList, prefix);
            }
            break;
        default:
            __GLS_RAISE_ERROR(GLS_INVALID_ENUM);
            break;
    }
}

void glsUnreadFunc(GLSwriteFunc inFunc) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->unreadFunc = inFunc;
}

void glsWriteFunc(GLSwriteFunc inFunc) {
    if (!__glsRequireContext()) return;
    __GLS_CONTEXT->writeFunc = inFunc;
}

void glsWritePrefix(const GLubyte *inPrefix) {
    if (!__glsRequireContext()) return;
    if (!__glsValidateString(inPrefix)) return;
    __glsString_assign(&__GLS_CONTEXT->writePrefix->val, inPrefix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_irix.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "types.h"
#include "g_dispatch.h"

extern void __gls_capture_glNewList(GLuint list, GLenum mode);
extern void __gls_capture_glEndList(void);
extern void __gls_capture_glCallList(GLuint list);
extern void __gls_capture_glCallLists(GLsizei n, GLenum type, const GLvoid *lists);
extern void __gls_capture_glDeleteLists(GLuint list, GLsizei range);
extern GLuint __gls_capture_glGenLists(GLsizei range);
extern void __gls_capture_glListBase(GLuint base);
extern void __gls_capture_glBegin(GLenum mode);
extern void __gls_capture_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void __gls_capture_glColor3b(GLbyte red, GLbyte green, GLbyte blue);
extern void __gls_capture_glColor3bv(const GLbyte *v);
extern void __gls_capture_glColor3d(GLdouble red, GLdouble green, GLdouble blue);
extern void __gls_capture_glColor3dv(const GLdouble *v);
extern void __gls_capture_glColor3f(GLfloat red, GLfloat green, GLfloat blue);
extern void __gls_capture_glColor3fv(const GLfloat *v);
extern void __gls_capture_glColor3i(GLint red, GLint green, GLint blue);
extern void __gls_capture_glColor3iv(const GLint *v);
extern void __gls_capture_glColor3s(GLshort red, GLshort green, GLshort blue);
extern void __gls_capture_glColor3sv(const GLshort *v);
extern void __gls_capture_glColor3ub(GLubyte red, GLubyte green, GLubyte blue);
extern void __gls_capture_glColor3ubv(const GLubyte *v);
extern void __gls_capture_glColor3ui(GLuint red, GLuint green, GLuint blue);
extern void __gls_capture_glColor3uiv(const GLuint *v);
extern void __gls_capture_glColor3us(GLushort red, GLushort green, GLushort blue);
extern void __gls_capture_glColor3usv(const GLushort *v);
extern void __gls_capture_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void __gls_capture_glColor4bv(const GLbyte *v);
extern void __gls_capture_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void __gls_capture_glColor4dv(const GLdouble *v);
extern void __gls_capture_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glColor4fv(const GLfloat *v);
extern void __gls_capture_glColor4i(GLint red, GLint green, GLint blue, GLint alpha);
extern void __gls_capture_glColor4iv(const GLint *v);
extern void __gls_capture_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void __gls_capture_glColor4sv(const GLshort *v);
extern void __gls_capture_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void __gls_capture_glColor4ubv(const GLubyte *v);
extern void __gls_capture_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void __gls_capture_glColor4uiv(const GLuint *v);
extern void __gls_capture_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void __gls_capture_glColor4usv(const GLushort *v);
extern void __gls_capture_glEdgeFlag(GLboolean flag);
extern void __gls_capture_glEdgeFlagv(const GLboolean *flag);
extern void __gls_capture_glEnd(void);
extern void __gls_capture_glIndexd(GLdouble c);
extern void __gls_capture_glIndexdv(const GLdouble *c);
extern void __gls_capture_glIndexf(GLfloat c);
extern void __gls_capture_glIndexfv(const GLfloat *c);
extern void __gls_capture_glIndexi(GLint c);
extern void __gls_capture_glIndexiv(const GLint *c);
extern void __gls_capture_glIndexs(GLshort c);
extern void __gls_capture_glIndexsv(const GLshort *c);
extern void __gls_capture_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz);
extern void __gls_capture_glNormal3bv(const GLbyte *v);
extern void __gls_capture_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz);
extern void __gls_capture_glNormal3dv(const GLdouble *v);
extern void __gls_capture_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz);
extern void __gls_capture_glNormal3fv(const GLfloat *v);
extern void __gls_capture_glNormal3i(GLint nx, GLint ny, GLint nz);
extern void __gls_capture_glNormal3iv(const GLint *v);
extern void __gls_capture_glNormal3s(GLshort nx, GLshort ny, GLshort nz);
extern void __gls_capture_glNormal3sv(const GLshort *v);
extern void __gls_capture_glRasterPos2d(GLdouble x, GLdouble y);
extern void __gls_capture_glRasterPos2dv(const GLdouble *v);
extern void __gls_capture_glRasterPos2f(GLfloat x, GLfloat y);
extern void __gls_capture_glRasterPos2fv(const GLfloat *v);
extern void __gls_capture_glRasterPos2i(GLint x, GLint y);
extern void __gls_capture_glRasterPos2iv(const GLint *v);
extern void __gls_capture_glRasterPos2s(GLshort x, GLshort y);
extern void __gls_capture_glRasterPos2sv(const GLshort *v);
extern void __gls_capture_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRasterPos3dv(const GLdouble *v);
extern void __gls_capture_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glRasterPos3fv(const GLfloat *v);
extern void __gls_capture_glRasterPos3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glRasterPos3iv(const GLint *v);
extern void __gls_capture_glRasterPos3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glRasterPos3sv(const GLshort *v);
extern void __gls_capture_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glRasterPos4dv(const GLdouble *v);
extern void __gls_capture_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glRasterPos4fv(const GLfloat *v);
extern void __gls_capture_glRasterPos4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glRasterPos4iv(const GLint *v);
extern void __gls_capture_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glRasterPos4sv(const GLshort *v);
extern void __gls_capture_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void __gls_capture_glRectdv(const GLdouble *v1, const GLdouble *v2);
extern void __gls_capture_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void __gls_capture_glRectfv(const GLfloat *v1, const GLfloat *v2);
extern void __gls_capture_glRecti(GLint x1, GLint y1, GLint x2, GLint y2);
extern void __gls_capture_glRectiv(const GLint *v1, const GLint *v2);
extern void __gls_capture_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void __gls_capture_glRectsv(const GLshort *v1, const GLshort *v2);
extern void __gls_capture_glTexCoord1d(GLdouble s);
extern void __gls_capture_glTexCoord1dv(const GLdouble *v);
extern void __gls_capture_glTexCoord1f(GLfloat s);
extern void __gls_capture_glTexCoord1fv(const GLfloat *v);
extern void __gls_capture_glTexCoord1i(GLint s);
extern void __gls_capture_glTexCoord1iv(const GLint *v);
extern void __gls_capture_glTexCoord1s(GLshort s);
extern void __gls_capture_glTexCoord1sv(const GLshort *v);
extern void __gls_capture_glTexCoord2d(GLdouble s, GLdouble t);
extern void __gls_capture_glTexCoord2dv(const GLdouble *v);
extern void __gls_capture_glTexCoord2f(GLfloat s, GLfloat t);
extern void __gls_capture_glTexCoord2fv(const GLfloat *v);
extern void __gls_capture_glTexCoord2i(GLint s, GLint t);
extern void __gls_capture_glTexCoord2iv(const GLint *v);
extern void __gls_capture_glTexCoord2s(GLshort s, GLshort t);
extern void __gls_capture_glTexCoord2sv(const GLshort *v);
extern void __gls_capture_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r);
extern void __gls_capture_glTexCoord3dv(const GLdouble *v);
extern void __gls_capture_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r);
extern void __gls_capture_glTexCoord3fv(const GLfloat *v);
extern void __gls_capture_glTexCoord3i(GLint s, GLint t, GLint r);
extern void __gls_capture_glTexCoord3iv(const GLint *v);
extern void __gls_capture_glTexCoord3s(GLshort s, GLshort t, GLshort r);
extern void __gls_capture_glTexCoord3sv(const GLshort *v);
extern void __gls_capture_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void __gls_capture_glTexCoord4dv(const GLdouble *v);
extern void __gls_capture_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void __gls_capture_glTexCoord4fv(const GLfloat *v);
extern void __gls_capture_glTexCoord4i(GLint s, GLint t, GLint r, GLint q);
extern void __gls_capture_glTexCoord4iv(const GLint *v);
extern void __gls_capture_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q);
extern void __gls_capture_glTexCoord4sv(const GLshort *v);
extern void __gls_capture_glVertex2d(GLdouble x, GLdouble y);
extern void __gls_capture_glVertex2dv(const GLdouble *v);
extern void __gls_capture_glVertex2f(GLfloat x, GLfloat y);
extern void __gls_capture_glVertex2fv(const GLfloat *v);
extern void __gls_capture_glVertex2i(GLint x, GLint y);
extern void __gls_capture_glVertex2iv(const GLint *v);
extern void __gls_capture_glVertex2s(GLshort x, GLshort y);
extern void __gls_capture_glVertex2sv(const GLshort *v);
extern void __gls_capture_glVertex3d(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glVertex3dv(const GLdouble *v);
extern void __gls_capture_glVertex3f(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glVertex3fv(const GLfloat *v);
extern void __gls_capture_glVertex3i(GLint x, GLint y, GLint z);
extern void __gls_capture_glVertex3iv(const GLint *v);
extern void __gls_capture_glVertex3s(GLshort x, GLshort y, GLshort z);
extern void __gls_capture_glVertex3sv(const GLshort *v);
extern void __gls_capture_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void __gls_capture_glVertex4dv(const GLdouble *v);
extern void __gls_capture_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void __gls_capture_glVertex4fv(const GLfloat *v);
extern void __gls_capture_glVertex4i(GLint x, GLint y, GLint z, GLint w);
extern void __gls_capture_glVertex4iv(const GLint *v);
extern void __gls_capture_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w);
extern void __gls_capture_glVertex4sv(const GLshort *v);
extern void __gls_capture_glClipPlane(GLenum plane, const GLdouble *equation);
extern void __gls_capture_glColorMaterial(GLenum face, GLenum mode);
extern void __gls_capture_glCullFace(GLenum mode);
extern void __gls_capture_glFogf(GLenum pname, GLfloat param);
extern void __gls_capture_glFogfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glFogi(GLenum pname, GLint param);
extern void __gls_capture_glFogiv(GLenum pname, const GLint *params);
extern void __gls_capture_glFrontFace(GLenum mode);
extern void __gls_capture_glHint(GLenum target, GLenum mode);
extern void __gls_capture_glLightf(GLenum light, GLenum pname, GLfloat param);
extern void __gls_capture_glLightfv(GLenum light, GLenum pname, const GLfloat *params);
extern void __gls_capture_glLighti(GLenum light, GLenum pname, GLint param);
extern void __gls_capture_glLightiv(GLenum light, GLenum pname, const GLint *params);
extern void __gls_capture_glLightModelf(GLenum pname, GLfloat param);
extern void __gls_capture_glLightModelfv(GLenum pname, const GLfloat *params);
extern void __gls_capture_glLightModeli(GLenum pname, GLint param);
extern void __gls_capture_glLightModeliv(GLenum pname, const GLint *params);
extern void __gls_capture_glLineStipple(GLint factor, GLushort pattern);
extern void __gls_capture_glLineWidth(GLfloat width);
extern void __gls_capture_glMaterialf(GLenum face, GLenum pname, GLfloat param);
extern void __gls_capture_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params);
extern void __gls_capture_glMateriali(GLenum face, GLenum pname, GLint param);
extern void __gls_capture_glMaterialiv(GLenum face, GLenum pname, const GLint *params);
extern void __gls_capture_glPointSize(GLfloat size);
extern void __gls_capture_glPolygonMode(GLenum face, GLenum mode);
extern void __gls_capture_glPolygonStipple(const GLubyte *mask);
extern void __gls_capture_glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glShadeModel(GLenum mode);
extern void __gls_capture_glTexParameterf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexParameteri(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexParameteriv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexImage1D(GLenum target, GLint level, GLint components, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexImage2D(GLenum target, GLint level, GLint components, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexEnvf(GLenum target, GLenum pname, GLfloat param);
extern void __gls_capture_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexEnvi(GLenum target, GLenum pname, GLint param);
extern void __gls_capture_glTexEnviv(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glTexGend(GLenum coord, GLenum pname, GLdouble param);
extern void __gls_capture_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params);
extern void __gls_capture_glTexGenf(GLenum coord, GLenum pname, GLfloat param);
extern void __gls_capture_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexGeni(GLenum coord, GLenum pname, GLint param);
extern void __gls_capture_glTexGeniv(GLenum coord, GLenum pname, const GLint *params);
extern void __gls_capture_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer);
extern void __gls_capture_glSelectBuffer(GLsizei size, GLuint *buffer);
extern GLint __gls_capture_glRenderMode(GLenum mode);
extern void __gls_capture_glInitNames(void);
extern void __gls_capture_glLoadName(GLuint name);
extern void __gls_capture_glPassThrough(GLfloat token);
extern void __gls_capture_glPopName(void);
extern void __gls_capture_glPushName(GLuint name);
extern void __gls_capture_glDrawBuffer(GLenum mode);
extern void __gls_capture_glClear(GLbitfield mask);
extern void __gls_capture_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void __gls_capture_glClearIndex(GLfloat c);
extern void __gls_capture_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glClearStencil(GLint s);
extern void __gls_capture_glClearDepth(GLclampd depth);
extern void __gls_capture_glStencilMask(GLuint mask);
extern void __gls_capture_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void __gls_capture_glDepthMask(GLboolean flag);
extern void __gls_capture_glIndexMask(GLuint mask);
extern void __gls_capture_glAccum(GLenum op, GLfloat value);
extern void __gls_capture_glDisable(GLenum cap);
extern void __gls_capture_glEnable(GLenum cap);
extern void __gls_capture_glFinish(void);
extern void __gls_capture_glFlush(void);
extern void __gls_capture_glPopAttrib(void);
extern void __gls_capture_glPushAttrib(GLbitfield mask);
extern void __gls_capture_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void __gls_capture_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void __gls_capture_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void __gls_capture_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void __gls_capture_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2);
extern void __gls_capture_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2);
extern void __gls_capture_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void __gls_capture_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void __gls_capture_glEvalCoord1d(GLdouble u);
extern void __gls_capture_glEvalCoord1dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord1f(GLfloat u);
extern void __gls_capture_glEvalCoord1fv(const GLfloat *u);
extern void __gls_capture_glEvalCoord2d(GLdouble u, GLdouble v);
extern void __gls_capture_glEvalCoord2dv(const GLdouble *u);
extern void __gls_capture_glEvalCoord2f(GLfloat u, GLfloat v);
extern void __gls_capture_glEvalCoord2fv(const GLfloat *u);
extern void __gls_capture_glEvalMesh1(GLenum mode, GLint i1, GLint i2);
extern void __gls_capture_glEvalPoint1(GLint i);
extern void __gls_capture_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void __gls_capture_glEvalPoint2(GLint i, GLint j);
extern void __gls_capture_glAlphaFunc(GLenum func, GLclampf ref);
extern void __gls_capture_glBlendFunc(GLenum sfactor, GLenum dfactor);
extern void __gls_capture_glLogicOp(GLenum opcode);
extern void __gls_capture_glStencilFunc(GLenum func, GLint ref, GLuint mask);
extern void __gls_capture_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass);
extern void __gls_capture_glDepthFunc(GLenum func);
extern void __gls_capture_glPixelZoom(GLfloat xfactor, GLfloat yfactor);
extern void __gls_capture_glPixelTransferf(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelTransferi(GLenum pname, GLint param);
extern void __gls_capture_glPixelStoref(GLenum pname, GLfloat param);
extern void __gls_capture_glPixelStorei(GLenum pname, GLint param);
extern void __gls_capture_glPixelMapfv(GLenum map, GLint mapsize, const GLfloat *values);
extern void __gls_capture_glPixelMapuiv(GLenum map, GLint mapsize, const GLuint *values);
extern void __gls_capture_glPixelMapusv(GLenum map, GLint mapsize, const GLushort *values);
extern void __gls_capture_glReadBuffer(GLenum mode);
extern void __gls_capture_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void __gls_capture_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glGetBooleanv(GLenum pname, GLboolean *params);
extern void __gls_capture_glGetClipPlane(GLenum plane, GLdouble *equation);
extern void __gls_capture_glGetDoublev(GLenum pname, GLdouble *params);
extern GLenum __gls_capture_glGetError(void);
extern void __gls_capture_glGetFloatv(GLenum pname, GLfloat *params);
extern void __gls_capture_glGetIntegerv(GLenum pname, GLint *params);
extern void __gls_capture_glGetLightfv(GLenum light, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetLightiv(GLenum light, GLenum pname, GLint *params);
extern void __gls_capture_glGetMapdv(GLenum target, GLenum query, GLdouble *v);
extern void __gls_capture_glGetMapfv(GLenum target, GLenum query, GLfloat *v);
extern void __gls_capture_glGetMapiv(GLenum target, GLenum query, GLint *v);
extern void __gls_capture_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMaterialiv(GLenum face, GLenum pname, GLint *params);
extern void __gls_capture_glGetPixelMapfv(GLenum map, GLfloat *values);
extern void __gls_capture_glGetPixelMapuiv(GLenum map, GLuint *values);
extern void __gls_capture_glGetPixelMapusv(GLenum map, GLushort *values);
extern void __gls_capture_glGetPolygonStipple(GLubyte *mask);
extern const GLubyte * __gls_capture_glGetString(GLenum name);
extern void __gls_capture_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexEnviv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params);
extern void __gls_capture_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void __gls_capture_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params);
extern GLboolean __gls_capture_glIsEnabled(GLenum cap);
extern GLboolean __gls_capture_glIsList(GLuint list);
extern void __gls_capture_glDepthRange(GLclampd near, GLclampd far);
extern void __gls_capture_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glLoadIdentity(void);
extern void __gls_capture_glLoadMatrixf(const GLfloat *m);
extern void __gls_capture_glLoadMatrixd(const GLdouble *m);
extern void __gls_capture_glMatrixMode(GLenum mode);
extern void __gls_capture_glMultMatrixf(const GLfloat *m);
extern void __gls_capture_glMultMatrixd(const GLdouble *m);
extern void __gls_capture_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);
extern void __gls_capture_glPopMatrix(void);
extern void __gls_capture_glPushMatrix(void);
extern void __gls_capture_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glScaled(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glScalef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glTranslated(GLdouble x, GLdouble y, GLdouble z);
extern void __gls_capture_glTranslatef(GLfloat x, GLfloat y, GLfloat z);
extern void __gls_capture_glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void __gls_capture_glBlendEquationEXT(GLenum mode);
extern void __gls_capture_glPolygonOffsetEXT(GLfloat factor, GLfloat bias);
extern void __gls_capture_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glSampleMaskSGIS(GLclampf value, GLboolean invert);
extern void __gls_capture_glSamplePatternSGIS(GLenum pattern);
extern void __gls_capture_glTagSampleBufferSGIX(void);
extern void __gls_capture_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
extern void __gls_capture_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat params);
extern void __gls_capture_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint params);
extern void __gls_capture_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image);
extern void __gls_capture_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
extern void __gls_capture_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
extern void __gls_capture_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
extern void __gls_capture_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink);
extern void __gls_capture_glResetHistogramEXT(GLenum target);
extern void __gls_capture_glResetMinmaxEXT(GLenum target);
extern void __gls_capture_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points);
extern void __gls_capture_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points);
extern void __gls_capture_glArrayElementEXT(GLint i);
extern void __gls_capture_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count);
extern void __gls_capture_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer);
extern void __gls_capture_glGetPointervEXT(GLenum pname, GLvoid* *params);
extern void __gls_capture_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern void __gls_capture_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
extern GLboolean __gls_capture_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences);
extern void __gls_capture_glBindTextureEXT(GLenum target, GLuint texture);
extern void __gls_capture_glDeleteTexturesEXT(GLsizei n, const GLuint *textures);
extern void __gls_capture_glGenTexturesEXT(GLsizei n, GLuint *textures);
extern GLboolean __gls_capture_glIsTextureEXT(GLuint texture);
extern void __gls_capture_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void __gls_capture_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
extern void __gls_capture_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table);
extern void __gls_capture_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glGetTexColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params);
extern void __gls_capture_glGetTexColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params);
extern void __gls_capture_glTexColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params);
extern void __gls_capture_glTexColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params);
extern void __gls_capture_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
extern void __gls_capture_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void __gls_capture_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void __gls_capture_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void __gls_capture_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
extern void __gls_capture_glPixelTexGenSGIX(GLenum mode);

__GLdispatchState __glDispatchCapture = {
    {
        __gls_capture_glNewList,
        __gls_capture_glEndList,
        __gls_capture_glCallList,
        __gls_capture_glCallLists,
        __gls_capture_glDeleteLists,
        __gls_capture_glGenLists,
        __gls_capture_glListBase,
        __gls_capture_glBegin,
        __gls_capture_glBitmap,
        __gls_capture_glEdgeFlag,
        __gls_capture_glEdgeFlagv,
        __gls_capture_glEnd,
        __gls_capture_glClipPlane,
        __gls_capture_glColorMaterial,
        __gls_capture_glCullFace,
        __gls_capture_glFogf,
        __gls_capture_glFogfv,
        __gls_capture_glFogi,
        __gls_capture_glFogiv,
        __gls_capture_glFrontFace,
        __gls_capture_glHint,
        __gls_capture_glLightf,
        __gls_capture_glLightfv,
        __gls_capture_glLighti,
        __gls_capture_glLightiv,
        __gls_capture_glLightModelf,
        __gls_capture_glLightModelfv,
        __gls_capture_glLightModeli,
        __gls_capture_glLightModeliv,
        __gls_capture_glLineStipple,
        __gls_capture_glLineWidth,
        __gls_capture_glMaterialf,
        __gls_capture_glMaterialfv,
        __gls_capture_glMateriali,
        __gls_capture_glMaterialiv,
        __gls_capture_glPointSize,
        __gls_capture_glPolygonMode,
        __gls_capture_glPolygonStipple,
        __gls_capture_glScissor,
        __gls_capture_glShadeModel,
        __gls_capture_glTexParameterf,
        __gls_capture_glTexParameterfv,
        __gls_capture_glTexParameteri,
        __gls_capture_glTexParameteriv,
        __gls_capture_glTexImage1D,
        __gls_capture_glTexImage2D,
        __gls_capture_glTexEnvf,
        __gls_capture_glTexEnvfv,
        __gls_capture_glTexEnvi,
        __gls_capture_glTexEnviv,
        __gls_capture_glTexGend,
        __gls_capture_glTexGendv,
        __gls_capture_glTexGenf,
        __gls_capture_glTexGenfv,
        __gls_capture_glTexGeni,
        __gls_capture_glTexGeniv,
        __gls_capture_glFeedbackBuffer,
        __gls_capture_glSelectBuffer,
        __gls_capture_glRenderMode,
        __gls_capture_glInitNames,
        __gls_capture_glLoadName,
        __gls_capture_glPassThrough,
        __gls_capture_glPopName,
        __gls_capture_glPushName,
        __gls_capture_glDrawBuffer,
        __gls_capture_glClear,
        __gls_capture_glClearAccum,
        __gls_capture_glClearIndex,
        __gls_capture_glClearColor,
        __gls_capture_glClearStencil,
        __gls_capture_glClearDepth,
        __gls_capture_glStencilMask,
        __gls_capture_glColorMask,
        __gls_capture_glDepthMask,
        __gls_capture_glIndexMask,
        __gls_capture_glAccum,
        __gls_capture_glDisable,
        __gls_capture_glEnable,
        __gls_capture_glFinish,
        __gls_capture_glFlush,
        __gls_capture_glPopAttrib,
        __gls_capture_glPushAttrib,
        __gls_capture_glMap1d,
        __gls_capture_glMap1f,
        __gls_capture_glMap2d,
        __gls_capture_glMap2f,
        __gls_capture_glMapGrid1d,
        __gls_capture_glMapGrid1f,
        __gls_capture_glMapGrid2d,
        __gls_capture_glMapGrid2f,
        __gls_capture_glEvalCoord1d,
        __gls_capture_glEvalCoord1dv,
        __gls_capture_glEvalCoord1f,
        __gls_capture_glEvalCoord1fv,
        __gls_capture_glEvalCoord2d,
        __gls_capture_glEvalCoord2dv,
        __gls_capture_glEvalCoord2f,
        __gls_capture_glEvalCoord2fv,
        __gls_capture_glEvalMesh1,
        __gls_capture_glEvalPoint1,
        __gls_capture_glEvalMesh2,
        __gls_capture_glEvalPoint2,
        __gls_capture_glAlphaFunc,
        __gls_capture_glBlendFunc,
        __gls_capture_glLogicOp,
        __gls_capture_glStencilFunc,
        __gls_capture_glStencilOp,
        __gls_capture_glDepthFunc,
        __gls_capture_glPixelZoom,
        __gls_capture_glPixelTransferf,
        __gls_capture_glPixelTransferi,
        __gls_capture_glPixelStoref,
        __gls_capture_glPixelStorei,
        __gls_capture_glPixelMapfv,
        __gls_capture_glPixelMapuiv,
        __gls_capture_glPixelMapusv,
        __gls_capture_glReadBuffer,
        __gls_capture_glCopyPixels,
        __gls_capture_glReadPixels,
        __gls_capture_glDrawPixels,
        __gls_capture_glGetBooleanv,
        __gls_capture_glGetClipPlane,
        __gls_capture_glGetDoublev,
        __gls_capture_glGetError,
        __gls_capture_glGetFloatv,
        __gls_capture_glGetIntegerv,
        __gls_capture_glGetLightfv,
        __gls_capture_glGetLightiv,
        __gls_capture_glGetMapdv,
        __gls_capture_glGetMapfv,
        __gls_capture_glGetMapiv,
        __gls_capture_glGetMaterialfv,
        __gls_capture_glGetMaterialiv,
        __gls_capture_glGetPixelMapfv,
        __gls_capture_glGetPixelMapuiv,
        __gls_capture_glGetPixelMapusv,
        __gls_capture_glGetPolygonStipple,
        __gls_capture_glGetString,
        __gls_capture_glGetTexEnvfv,
        __gls_capture_glGetTexEnviv,
        __gls_capture_glGetTexGendv,
        __gls_capture_glGetTexGenfv,
        __gls_capture_glGetTexGeniv,
        __gls_capture_glGetTexImage,
        __gls_capture_glGetTexParameterfv,
        __gls_capture_glGetTexParameteriv,
        __gls_capture_glGetTexLevelParameterfv,
        __gls_capture_glGetTexLevelParameteriv,
        __gls_capture_glIsEnabled,
        __gls_capture_glIsList,
        __gls_capture_glDepthRange,
        __gls_capture_glFrustum,
        __gls_capture_glLoadIdentity,
        __gls_capture_glLoadMatrixf,
        __gls_capture_glLoadMatrixd,
        __gls_capture_glMatrixMode,
        __gls_capture_glMultMatrixf,
        __gls_capture_glMultMatrixd,
        __gls_capture_glOrtho,
        __gls_capture_glPopMatrix,
        __gls_capture_glPushMatrix,
        __gls_capture_glRotated,
        __gls_capture_glRotatef,
        __gls_capture_glScaled,
        __gls_capture_glScalef,
        __gls_capture_glTranslated,
        __gls_capture_glTranslatef,
        __gls_capture_glViewport,
        __gls_capture_glBlendColorEXT,
        __gls_capture_glBlendEquationEXT,
        __gls_capture_glPolygonOffsetEXT,
        __gls_capture_glTexSubImage1DEXT,
        __gls_capture_glTexSubImage2DEXT,
        __gls_capture_glSampleMaskSGIS,
        __gls_capture_glSamplePatternSGIS,
        __gls_capture_glTagSampleBufferSGIX,
        __gls_capture_glConvolutionFilter1DEXT,
        __gls_capture_glConvolutionFilter2DEXT,
        __gls_capture_glConvolutionParameterfEXT,
        __gls_capture_glConvolutionParameterfvEXT,
        __gls_capture_glConvolutionParameteriEXT,
        __gls_capture_glConvolutionParameterivEXT,
        __gls_capture_glCopyConvolutionFilter1DEXT,
        __gls_capture_glCopyConvolutionFilter2DEXT,
        __gls_capture_glGetConvolutionFilterEXT,
        __gls_capture_glGetConvolutionParameterfvEXT,
        __gls_capture_glGetConvolutionParameterivEXT,
        __gls_capture_glGetSeparableFilterEXT,
        __gls_capture_glSeparableFilter2DEXT,
        __gls_capture_glGetHistogramEXT,
        __gls_capture_glGetHistogramParameterfvEXT,
        __gls_capture_glGetHistogramParameterivEXT,
        __gls_capture_glGetMinmaxEXT,
        __gls_capture_glGetMinmaxParameterfvEXT,
        __gls_capture_glGetMinmaxParameterivEXT,
        __gls_capture_glHistogramEXT,
        __gls_capture_glMinmaxEXT,
        __gls_capture_glResetHistogramEXT,
        __gls_capture_glResetMinmaxEXT,
        __gls_capture_glTexImage3DEXT,
        __gls_capture_glTexSubImage3DEXT,
        __gls_capture_glDetailTexFuncSGIS,
        __gls_capture_glGetDetailTexFuncSGIS,
        __gls_capture_glSharpenTexFuncSGIS,
        __gls_capture_glGetSharpenTexFuncSGIS,
        __gls_capture_glArrayElementEXT,
        __gls_capture_glColorPointerEXT,
        __gls_capture_glDrawArraysEXT,
        __gls_capture_glEdgeFlagPointerEXT,
        __gls_capture_glGetPointervEXT,
        __gls_capture_glIndexPointerEXT,
        __gls_capture_glNormalPointerEXT,
        __gls_capture_glTexCoordPointerEXT,
        __gls_capture_glVertexPointerEXT,
        __gls_capture_glAreTexturesResidentEXT,
        __gls_capture_glBindTextureEXT,
        __gls_capture_glDeleteTexturesEXT,
        __gls_capture_glGenTexturesEXT,
        __gls_capture_glIsTextureEXT,
        __gls_capture_glPrioritizeTexturesEXT,
        __gls_capture_glColorTableSGI,
        __gls_capture_glColorTableParameterfvSGI,
        __gls_capture_glColorTableParameterivSGI,
        __gls_capture_glCopyColorTableSGI,
        __gls_capture_glGetColorTableSGI,
        __gls_capture_glGetColorTableParameterfvSGI,
        __gls_capture_glGetColorTableParameterivSGI,
        __gls_capture_glGetTexColorTableParameterfvSGI,
        __gls_capture_glGetTexColorTableParameterivSGI,
        __gls_capture_glTexColorTableParameterfvSGI,
        __gls_capture_glTexColorTableParameterivSGI,
        __gls_capture_glCopyTexImage1DEXT,
        __gls_capture_glCopyTexImage2DEXT,
        __gls_capture_glCopyTexSubImage1DEXT,
        __gls_capture_glCopyTexSubImage2DEXT,
        __gls_capture_glCopyTexSubImage3DEXT,
        __gls_capture_glTexImage4DSGIS,
        __gls_capture_glTexSubImage4DSGIS,
        __gls_capture_glPixelTexGenSGIX,
        glSpriteParameterfSGIX,
        glSpriteParameterfvSGIX,
        glSpriteParameteriSGIX,
        glSpriteParameterivSGIX,
    },
    {
        __gls_capture_glVertex2d,
        __gls_capture_glVertex2dv,
        __gls_capture_glVertex2f,
        __gls_capture_glVertex2fv,
        __gls_capture_glVertex2i,
        __gls_capture_glVertex2iv,
        __gls_capture_glVertex2s,
        __gls_capture_glVertex2sv,
        __gls_capture_glVertex3d,
        __gls_capture_glVertex3dv,
        __gls_capture_glVertex3f,
        __gls_capture_glVertex3fv,
        __gls_capture_glVertex3i,
        __gls_capture_glVertex3iv,
        __gls_capture_glVertex3s,
        __gls_capture_glVertex3sv,
        __gls_capture_glVertex4d,
        __gls_capture_glVertex4dv,
        __gls_capture_glVertex4f,
        __gls_capture_glVertex4fv,
        __gls_capture_glVertex4i,
        __gls_capture_glVertex4iv,
        __gls_capture_glVertex4s,
        __gls_capture_glVertex4sv,
    },
    {
        __gls_capture_glColor3b,
        __gls_capture_glColor3bv,
        __gls_capture_glColor3d,
        __gls_capture_glColor3dv,
        __gls_capture_glColor3f,
        __gls_capture_glColor3fv,
        __gls_capture_glColor3i,
        __gls_capture_glColor3iv,
        __gls_capture_glColor3s,
        __gls_capture_glColor3sv,
        __gls_capture_glColor3ub,
        __gls_capture_glColor3ubv,
        __gls_capture_glColor3ui,
        __gls_capture_glColor3uiv,
        __gls_capture_glColor3us,
        __gls_capture_glColor3usv,
        __gls_capture_glColor4b,
        __gls_capture_glColor4bv,
        __gls_capture_glColor4d,
        __gls_capture_glColor4dv,
        __gls_capture_glColor4f,
        __gls_capture_glColor4fv,
        __gls_capture_glColor4i,
        __gls_capture_glColor4iv,
        __gls_capture_glColor4s,
        __gls_capture_glColor4sv,
        __gls_capture_glColor4ub,
        __gls_capture_glColor4ubv,
        __gls_capture_glColor4ui,
        __gls_capture_glColor4uiv,
        __gls_capture_glColor4us,
        __gls_capture_glColor4usv,
        __gls_capture_glIndexd,
        __gls_capture_glIndexdv,
        __gls_capture_glIndexf,
        __gls_capture_glIndexfv,
        __gls_capture_glIndexi,
        __gls_capture_glIndexiv,
        __gls_capture_glIndexs,
        __gls_capture_glIndexsv,
    },
    {
        __gls_capture_glNormal3b,
        __gls_capture_glNormal3bv,
        __gls_capture_glNormal3d,
        __gls_capture_glNormal3dv,
        __gls_capture_glNormal3f,
        __gls_capture_glNormal3fv,
        __gls_capture_glNormal3i,
        __gls_capture_glNormal3iv,
        __gls_capture_glNormal3s,
        __gls_capture_glNormal3sv,
    },
    {
        __gls_capture_glTexCoord1d,
        __gls_capture_glTexCoord1dv,
        __gls_capture_glTexCoord1f,
        __gls_capture_glTexCoord1fv,
        __gls_capture_glTexCoord1i,
        __gls_capture_glTexCoord1iv,
        __gls_capture_glTexCoord1s,
        __gls_capture_glTexCoord1sv,
        __gls_capture_glTexCoord2d,
        __gls_capture_glTexCoord2dv,
        __gls_capture_glTexCoord2f,
        __gls_capture_glTexCoord2fv,
        __gls_capture_glTexCoord2i,
        __gls_capture_glTexCoord2iv,
        __gls_capture_glTexCoord2s,
        __gls_capture_glTexCoord2sv,
        __gls_capture_glTexCoord3d,
        __gls_capture_glTexCoord3dv,
        __gls_capture_glTexCoord3f,
        __gls_capture_glTexCoord3fv,
        __gls_capture_glTexCoord3i,
        __gls_capture_glTexCoord3iv,
        __gls_capture_glTexCoord3s,
        __gls_capture_glTexCoord3sv,
        __gls_capture_glTexCoord4d,
        __gls_capture_glTexCoord4dv,
        __gls_capture_glTexCoord4f,
        __gls_capture_glTexCoord4fv,
        __gls_capture_glTexCoord4i,
        __gls_capture_glTexCoord4iv,
        __gls_capture_glTexCoord4s,
        __gls_capture_glTexCoord4sv,
    },
    {
        __gls_capture_glRasterPos2d,
        __gls_capture_glRasterPos2dv,
        __gls_capture_glRasterPos2f,
        __gls_capture_glRasterPos2fv,
        __gls_capture_glRasterPos2i,
        __gls_capture_glRasterPos2iv,
        __gls_capture_glRasterPos2s,
        __gls_capture_glRasterPos2sv,
        __gls_capture_glRasterPos3d,
        __gls_capture_glRasterPos3dv,
        __gls_capture_glRasterPos3f,
        __gls_capture_glRasterPos3fv,
        __gls_capture_glRasterPos3i,
        __gls_capture_glRasterPos3iv,
        __gls_capture_glRasterPos3s,
        __gls_capture_glRasterPos3sv,
        __gls_capture_glRasterPos4d,
        __gls_capture_glRasterPos4dv,
        __gls_capture_glRasterPos4f,
        __gls_capture_glRasterPos4fv,
        __gls_capture_glRasterPos4i,
        __gls_capture_glRasterPos4iv,
        __gls_capture_glRasterPos4s,
        __gls_capture_glRasterPos4sv,
    },
    {
        __gls_capture_glRectd,
        __gls_capture_glRectdv,
        __gls_capture_glRectf,
        __gls_capture_glRectfv,
        __gls_capture_glRecti,
        __gls_capture_glRectiv,
        __gls_capture_glRects,
        __gls_capture_glRectsv,
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\opcode.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

GLSopcode __glsMapOpcode(GLSopcode inOpcode) {
    GLint i;
    const GLint page = __GLS_OPCODE_PAGE(inOpcode);

    if (page < __GLS_OPCODE_PAGE_MAPPED0) return inOpcode;
    #if __GLS_MAPPED_OPCODE_PAGE_COUNT
        for (i = 0 ; i < __GLS_MAPPED_OPCODE_PAGE_COUNT ; ++i) {
            if (page == __glsOpPageMap[i]) return (
                __GLS_OPCODE(
                    __GLS_OPCODE_PAGE_MAPPED0 + i,
                    __GLS_OPCODE_OFFSET(inOpcode)
                )
            );
        }
    #endif /* __GLS_MAPPED_OPCODE_PAGE_COUNT */
    return GLS_NONE;
}

GLSenum __glsOpcodeAPI(GLSopcode inOpcode) {
    switch (__GLS_OPCODE_PAGE(inOpcode)) {
        case __GLS_OPCODE_PAGE_GLS0:
        case __GLS_OPCODE_PAGE_GLS1:
        case __GLS_OPCODE_PAGE_GLS2:
            return (
                __glsOpcodeString[__glsMapOpcode(inOpcode)] ?
                GLS_API_GLS :
                GLS_NONE
            );
        case __GLS_OPCODE_PAGE_GL0:
        case __GLS_OPCODE_PAGE_GL1:
        case __GLS_OPCODE_PAGE_GL2:
        case __GLS_OPCODE_PAGE_GL3:
        case __GLS_OPCODE_PAGE_GL4:
        case __GLS_OPCODE_PAGE_GL5:
        case __GLS_OPCODE_PAGE_GL6:
        case __GLS_OPCODE_PAGE_GL7:
        case __GLS_OPCODE_PAGE_GL8:
        case __GLS_OPCODE_PAGE_GL9:
        case __GLS_OPCODE_PAGE_GL10:
        case __GLS_OPCODE_PAGE_GL11:
        case __GLS_OPCODE_PAGE_GL12:
        case __GLS_OPCODE_PAGE_GL13:
        case __GLS_OPCODE_PAGE_GL14:
        case __GLS_OPCODE_PAGE_GL15:
        case __GLS_OPCODE_PAGE_GL16:
        case __GLS_OPCODE_PAGE_GL17:
        case __GLS_OPCODE_PAGE_GL18:
        case __GLS_OPCODE_PAGE_GL19:
        // DrewB - 1.1
        case __GLS_OPCODE_PAGE_GL20:
        case __GLS_OPCODE_PAGE_GL_SGI0:
        case __GLS_OPCODE_PAGE_GL_SGI1:
        case __GLS_OPCODE_PAGE_GL_SGI2:
        case __GLS_OPCODE_PAGE_GL_SGI3:
        case __GLS_OPCODE_PAGE_GL_SGI4:
        // DrewB - ColorSubTable
        case __GLS_OPCODE_PAGE_GL_MSFT0:
            return (
                __glsOpcodeString[__glsMapOpcode(inOpcode)] ?
                GLS_API_GL :
                GLS_NONE
            );
    }
    return GLS_NONE;
}

GLSopcode __glsUnmapOpcode(GLSopcode inOpcode) {
    GLint i;
    const GLint page = __GLS_OPCODE_PAGE(inOpcode);

    if (page < __GLS_OPCODE_PAGE_MAPPED0) return inOpcode;
    #if __GLS_MAPPED_OPCODE_PAGE_COUNT
        for (i = 0 ; i < __GLS_MAPPED_OPCODE_PAGE_COUNT ; ++i) {
            if (page == __GLS_OPCODE_PAGE_MAPPED0 + i) return (
                __GLS_OPCODE(__glsOpPageMap[i], __GLS_OPCODE_OFFSET(inOpcode))
            );
        }
    #endif /* __GLS_MAPPED_OPCODE_PAGE_COUNT */
    return GLS_NONE;
}

GLboolean __glsValidateOpcode(GLSopcode inOpcode) {
    if (!__glsOpcodeAPI(inOpcode)) {
        __GLS_RAISE_ERROR(GLS_UNSUPPORTED_COMMAND);
        return GL_FALSE;
    }
    return GL_TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\g_op.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/* GENERATED FILE: DO NOT EDIT */

#include "glslib.h"

const GLbitfield __glsOpcodeAttrib[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GEN_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_REPLY_BIT | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE,
    GLS_NONE,
    // DrewB - 1.1
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | GLS_COMMAND_GEN_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    #if __GL_EXT_blend_color
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        GLS_NONE | __GLS_COMMAND_0_PARAMS_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE | __GLS_COMMAND_ALIGN_ODD32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE | GLS_COMMAND_GEN_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE | GLS_COMMAND_GET_BIT | GLS_COMMAND_REPLY_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        GLS_NONE,
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    #if __GL_EXT_paletted_texture
        // DrewB
        GLS_NONE | GLS_COMMAND_GET_BIT | __GLS_COMMAND_ALIGN_EVEN32_BIT,
        GLS_NONE,
    #else
        GLS_NONE,
        GLS_NONE,
    #endif
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
};

const GLubyte *const __glsOpcodeString[__GLS_OPCODE_COUNT] = {
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("glsBeginGLS"),
    glsCSTR("glsBlock"),
    glsCSTR("glsCallStream"),
    glsCSTR("glsEndGLS"),
    glsCSTR("glsError"),
    glsCSTR("glsGLRC"),
    glsCSTR("glsGLRCLayer"),
    glsCSTR("glsHeaderGLRCi"),
    glsCSTR("glsHeaderLayerf"),
    glsCSTR("glsHeaderLayeri"),
    glsCSTR("glsHeaderf"),
    glsCSTR("glsHeaderfv"),
    glsCSTR("glsHeaderi"),
    glsCSTR("glsHeaderiv"),
    glsCSTR("glsHeaderubz"),
    glsCSTR("glsRequireExtension"),
    glsCSTR("glsUnsupportedCommand"),
    glsCSTR("glsAppRef"),
    glsCSTR("glsBeginObj"),
    glsCSTR("glsCharubz"),
    glsCSTR("glsComment"),
    glsCSTR("glsDisplayMapfv"),
    glsCSTR("glsEndObj"),
    glsCSTR("glsNumb"),
    glsCSTR("glsNumbv"),
    glsCSTR("glsNumd"),
    glsCSTR("glsNumdv"),
    glsCSTR("glsNumf"),
    glsCSTR("glsNumfv"),
    glsCSTR("glsNumi"),
    glsCSTR("glsNumiv"),
    glsCSTR("glsNuml"),
    glsCSTR("glsNumlv"),
    glsCSTR("glsNums"),
    glsCSTR("glsNumsv"),
    glsCSTR("glsNumub"),
    glsCSTR("glsNumubv"),
    glsCSTR("glsNumui"),
    glsCSTR("glsNumuiv"),
    glsCSTR("glsNumul"),
    glsCSTR("glsNumulv"),
    glsCSTR("glsNumus"),
    glsCSTR("glsNumusv"),
    glsCSTR("glsPad"),
    glsCSTR("glsSwapBuffers"),
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    glsCSTR("glNewList"),
    glsCSTR("glEndList"),
    glsCSTR("glCallList"),
    glsCSTR("glCallLists"),
    glsCSTR("glDeleteLists"),
    glsCSTR("glGenLists"),
    glsCSTR("glListBase"),
    glsCSTR("glBegin"),
    glsCSTR("glBitmap"),
    glsCSTR("glColor3b"),
    glsCSTR("glColor3bv"),
    glsCSTR("glColor3d"),
    glsCSTR("glColor3dv"),
    glsCSTR("glColor3f"),
    glsCSTR("glColor3fv"),
    glsCSTR("glColor3i"),
    glsCSTR("glColor3iv"),
    glsCSTR("glColor3s"),
    glsCSTR("glColor3sv"),
    glsCSTR("glColor3ub"),
    glsCSTR("glColor3ubv"),
    glsCSTR("glColor3ui"),
    glsCSTR("glColor3uiv"),
    glsCSTR("glColor3us"),
    glsCSTR("glColor3usv"),
    glsCSTR("glColor4b"),
    glsCSTR("glColor4bv"),
    glsCSTR("glColor4d"),
    glsCSTR("glColor4dv"),
    glsCSTR("glColor4f"),
    glsCSTR("glColor4fv"),
    glsCSTR("glColor4i"),
    glsCSTR("glColor4iv"),
    glsCSTR("glColor4s"),
    glsCSTR("glColor4sv"),
    glsCSTR("glColor4ub"),
    glsCSTR("glColor4ubv"),
    glsCSTR("glColor4ui"),
    glsCSTR("glColor4uiv"),
    glsCSTR("glColor4us"),
    glsCSTR("glColor4usv"),
    glsCSTR("glEdgeFlag"),
    glsCSTR("glEdgeFlagv"),
    glsCSTR("glEnd"),
    glsCSTR("glIndexd"),
    glsCSTR("glIndexdv"),
    glsCSTR("glIndexf"),
    glsCSTR("glIndexfv"),
    glsCSTR("glIndexi"),
    glsCSTR("glIndexiv"),
    glsCSTR("glIndexs"),
    glsCSTR("glIndexsv"),
    glsCSTR("glNormal3b"),
    glsCSTR("glNormal3bv"),
    glsCSTR("glNormal3d"),
    glsCSTR("glNormal3dv"),
    glsCSTR("glNormal3f"),
    glsCSTR("glNormal3fv"),
    glsCSTR("glNormal3i"),
    glsCSTR("glNormal3iv"),
    glsCSTR("glNormal3s"),
    glsCSTR("glNormal3sv"),
    glsCSTR("glRasterPos2d"),
    glsCSTR("glRasterPos2dv"),
    glsCSTR("glRasterPos2f"),
    glsCSTR("glRasterPos2fv"),
    glsCSTR("glRasterPos2i"),
    glsCSTR("glRasterPos2iv"),
    glsCSTR("glRasterPos2s"),
    glsCSTR("glRasterPos2sv"),
    glsCSTR("glRasterPos3d"),
    glsCSTR("glRasterPos3dv"),
    glsCSTR("glRasterPos3f"),
    glsCSTR("glRasterPos3fv"),
    glsCSTR("glRasterPos3i"),
    glsCSTR("glRasterPos3iv"),
    glsCSTR("glRasterPos3s"),
    glsCSTR("glRasterPos3sv"),
    glsCSTR("glRasterPos4d"),
    glsCSTR("glRasterPos4dv"),
    glsCSTR("glRasterPos4f"),
    glsCSTR("glRasterPos4fv"),
    glsCSTR("glRasterPos4i"),
    glsCSTR("glRasterPos4iv"),
    glsCSTR("glRasterPos4s"),
    glsCSTR("glRasterPos4sv"),
    glsCSTR("glRectd"),
    glsCSTR("glRectdv"),
    glsCSTR("glRectf"),
    glsCSTR("glRectfv"),
    glsCSTR("glRecti"),
    glsCSTR("glRectiv"),
    glsCSTR("glRects"),
    glsCSTR("glRectsv"),
    glsCSTR("glTexCoord1d"),
    glsCSTR("glTexCoord1dv"),
    glsCSTR("glTexCoord1f"),
    glsCSTR("glTexCoord1fv"),
    glsCSTR("glTexCoord1i"),
    glsCSTR("glTexCoord1iv"),
    glsCSTR("glTexCoord1s"),
    glsCSTR("glTexCoord1sv"),
    glsCSTR("glTexCoord2d"),
    glsCSTR("glTexCoord2dv"),
    glsCSTR("glTexCoord2f"),
    glsCSTR("glTexCoord2fv"),
    glsCSTR("glTexCoord2i"),
    glsCSTR("glTexCoord2iv"),
    glsCSTR("glTexCoord2s"),
    glsCSTR("glTexCoord2sv"),
    glsCSTR("glTexCoord3d"),
    glsCSTR("glTexCoord3dv"),
    glsCSTR("glTexCoord3f"),
    glsCSTR("glTexCoord3fv"),
    glsCSTR("glTexCoord3i"),
    glsCSTR("glTexCoord3iv"),
    glsCSTR("glTexCoord3s"),
    glsCSTR("glTexCoord3sv"),
    glsCSTR("glTexCoord4d"),
    glsCSTR("glTexCoord4dv"),
    glsCSTR("glTexCoord4f"),
    glsCSTR("glTexCoord4fv"),
    glsCSTR("glTexCoord4i"),
    glsCSTR("glTexCoord4iv"),
    glsCSTR("glTexCoord4s"),
    glsCSTR("glTexCoord4sv"),
    glsCSTR("glVertex2d"),
    glsCSTR("glVertex2dv"),
    glsCSTR("glVertex2f"),
    glsCSTR("glVertex2fv"),
    glsCSTR("glVertex2i"),
    glsCSTR("glVertex2iv"),
    glsCSTR("glVertex2s"),
    glsCSTR("glVertex2sv"),
    glsCSTR("glVertex3d"),
    glsCSTR("glVertex3dv"),
    glsCSTR("glVertex3f"),
    glsCSTR("glVertex3fv"),
    glsCSTR("glVertex3i"),
    glsCSTR("glVertex3iv"),
    glsCSTR("glVertex3s"),
    glsCSTR("glVertex3sv"),
    glsCSTR("glVertex4d"),
    glsCSTR("glVertex4dv"),
    glsCSTR("glVertex4f"),
    glsCSTR("glVertex4fv"),
    glsCSTR("glVertex4i"),
    glsCSTR("glVertex4iv"),
    glsCSTR("glVertex4s"),
    glsCSTR("glVertex4sv"),
    glsCSTR("glClipPlane"),
    glsCSTR("glColorMaterial"),
    glsCSTR("glCullFace"),
    glsCSTR("glFogf"),
    glsCSTR("glFogfv"),
    glsCSTR("glFogi"),
    glsCSTR("glFogiv"),
    glsCSTR("glFrontFace"),
    glsCSTR("glHint"),
    glsCSTR("glLightf"),
    glsCSTR("glLightfv"),
    glsCSTR("glLighti"),
    glsCSTR("glLightiv"),
    glsCSTR("glLightModelf"),
    glsCSTR("glLightModelfv"),
    glsCSTR("glLightModeli"),
    glsCSTR("glLightModeliv"),
    glsCSTR("glLineStipple"),
    glsCSTR("glLineWidth"),
    glsCSTR("glMaterialf"),
    glsCSTR("glMaterialfv"),
    glsCSTR("glMateriali"),
    glsCSTR("glMaterialiv"),
    glsCSTR("glPointSize"),
    glsCSTR("glPolygonMode"),
    glsCSTR("glPolygonStipple"),
    glsCSTR("glScissor"),
    glsCSTR("glShadeModel"),
    glsCSTR("glTexParameterf"),
    glsCSTR("glTexParameterfv"),
    glsCSTR("glTexParameteri"),
    glsCSTR("glTexParameteriv"),
    glsCSTR("glTexImage1D"),
    glsCSTR("glTexImage2D"),
    glsCSTR("glTexEnvf"),
    glsCSTR("glTexEnvfv"),
    glsCSTR("glTexEnvi"),
    glsCSTR("glTexEnviv"),
    glsCSTR("glTexGend"),
    glsCSTR("glTexGendv"),
    glsCSTR("glTexGenf"),
    glsCSTR("glTexGenfv"),
    glsCSTR("glTexGeni"),
    glsCSTR("glTexGeniv"),
    glsCSTR("glFeedbackBuffer"),
    glsCSTR("glSelectBuffer"),
    glsCSTR("glRenderMode"),
    glsCSTR("glInitNames"),
    glsCSTR("glLoadName"),
    glsCSTR("glPassThrough"),
    glsCSTR("glPopName"),
    glsCSTR("glPushName"),
    glsCSTR("glDrawBuffer"),
    glsCSTR("glClear"),
    glsCSTR("glClearAccum"),
    glsCSTR("glClearIndex"),
    glsCSTR("glClearColor"),
    glsCSTR("glClearStencil"),
    glsCSTR("glClearDepth"),
    glsCSTR("glStencilMask"),
    glsCSTR("glColorMask"),
    glsCSTR("glDepthMask"),
    glsCSTR("glIndexMask"),
    glsCSTR("glAccum"),
    glsCSTR("glDisable"),
    glsCSTR("glEnable"),
    glsCSTR("glFinish"),
    glsCSTR("glFlush"),
    glsCSTR("glPopAttrib"),
    glsCSTR("glPushAttrib"),
    glsCSTR("glMap1d"),
    glsCSTR("glMap1f"),
    glsCSTR("glMap2d"),
    glsCSTR("glMap2f"),
    glsCSTR("glMapGrid1d"),
    glsCSTR("glMapGrid1f"),
    glsCSTR("glMapGrid2d"),
    glsCSTR("glMapGrid2f"),
    glsCSTR("glEvalCoord1d"),
    glsCSTR("glEvalCoord1dv"),
    glsCSTR("glEvalCoord1f"),
    glsCSTR("glEvalCoord1fv"),
    glsCSTR("glEvalCoord2d"),
    glsCSTR("glEvalCoord2dv"),
    glsCSTR("glEvalCoord2f"),
    glsCSTR("glEvalCoord2fv"),
    glsCSTR("glEvalMesh1"),
    glsCSTR("glEvalPoint1"),
    glsCSTR("glEvalMesh2"),
    glsCSTR("glEvalPoint2"),
    glsCSTR("glAlphaFunc"),
    glsCSTR("glBlendFunc"),
    glsCSTR("glLogicOp"),
    glsCSTR("glStencilFunc"),
    glsCSTR("glStencilOp"),
    glsCSTR("glDepthFunc"),
    glsCSTR("glPixelZoom"),
    glsCSTR("glPixelTransferf"),
    glsCSTR("glPixelTransferi"),
    glsCSTR("glPixelStoref"),
    glsCSTR("glPixelStorei"),
    glsCSTR("glPixelMapfv"),
    glsCSTR("glPixelMapuiv"),
    glsCSTR("glPixelMapusv"),
    glsCSTR("glReadBuffer"),
    glsCSTR("glCopyPixels"),
    glsCSTR("glReadPixels"),
    glsCSTR("glDrawPixels"),
    glsCSTR("glGetBooleanv"),
    glsCSTR("glGetClipPlane"),
    glsCSTR("glGetDoublev"),
    glsCSTR("glGetError"),
    glsCSTR("glGetFloatv"),
    glsCSTR("glGetIntegerv"),
    glsCSTR("glGetLightfv"),
    glsCSTR("glGetLightiv"),
    glsCSTR("glGetMapdv"),
    glsCSTR("glGetMapfv"),
    glsCSTR("glGetMapiv"),
    glsCSTR("glGetMaterialfv"),
    glsCSTR("glGetMaterialiv"),
    glsCSTR("glGetPixelMapfv"),
    glsCSTR("glGetPixelMapuiv"),
    glsCSTR("glGetPixelMapusv"),
    glsCSTR("glGetPolygonStipple"),
    glsCSTR("glGetString"),
    glsCSTR("glGetTexEnvfv"),
    glsCSTR("glGetTexEnviv"),
    glsCSTR("glGetTexGendv"),
    glsCSTR("glGetTexGenfv"),
    glsCSTR("glGetTexGeniv"),
    glsCSTR("glGetTexImage"),
    glsCSTR("glGetTexParameterfv"),
    glsCSTR("glGetTexParameteriv"),
    glsCSTR("glGetTexLevelParameterfv"),
    glsCSTR("glGetTexLevelParameteriv"),
    glsCSTR("glIsEnabled"),
    glsCSTR("glIsList"),
    glsCSTR("glDepthRange"),
    glsCSTR("glFrustum"),
    glsCSTR("glLoadIdentity"),
    glsCSTR("glLoadMatrixf"),
    glsCSTR("glLoadMatrixd"),
    glsCSTR("glMatrixMode"),
    glsCSTR("glMultMatrixf"),
    glsCSTR("glMultMatrixd"),
    glsCSTR("glOrtho"),
    glsCSTR("glPopMatrix"),
    glsCSTR("glPushMatrix"),
    glsCSTR("glRotated"),
    glsCSTR("glRotatef"),
    glsCSTR("glScaled"),
    glsCSTR("glScalef"),
    glsCSTR("glTranslated"),
    glsCSTR("glTranslatef"),
    glsCSTR("glViewport"),
    glsCSTR("glArrayElement"),
    glsCSTR("glBindTexture"),
    glsCSTR("glColorPointer"),
    glsCSTR("glDisableClientState"),
    glsCSTR("glDrawArrays"),
    glsCSTR("glDrawElements"),
    glsCSTR("glEdgeFlagPointer"),
    glsCSTR("glEnableClientState"),
    glsCSTR("glIndexPointer"),
    glsCSTR("glIndexub"),
    glsCSTR("glIndexubv"),
    glsCSTR("glInterleavedArrays"),
    glsCSTR("glNormalPointer"),
    glsCSTR("glPolygonOffset"),
    glsCSTR("glTexCoordPointer"),
    glsCSTR("glVertexPointer"),
    glsCSTR("glAreTexturesResident"),
    glsCSTR("glCopyTexImage1D"),
    glsCSTR("glCopyTexImage2D"),
    glsCSTR("glCopyTexSubImage1D"),
    glsCSTR("glCopyTexSubImage2D"),
    glsCSTR("glDeleteTextures"),
    glsCSTR("glGenTextures"),
    glsCSTR("glGetPointerv"),
    glsCSTR("glIsTexture"),
    glsCSTR("glPrioritizeTextures"),
    glsCSTR("glTexSubImage1D"),
    glsCSTR("glTexSubImage2D"),
    glsCSTR("glPushClientAttrib"),
    glsCSTR("glPopClientAttrib"),
    #if __GL_EXT_blend_color
        glsCSTR("glBlendColorEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        glsCSTR("glBlendEquationEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        glsCSTR("glPolygonOffsetEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        glsCSTR("glTexSubImage1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        glsCSTR("glTexSubImage2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        glsCSTR("glSampleMaskSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        glsCSTR("glSamplePatternSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        glsCSTR("glTagSampleBufferSGIX"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionFilter1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionFilter2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameterfEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameteriEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glConvolutionParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glCopyConvolutionFilter1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glCopyConvolutionFilter2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetConvolutionFilterEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetConvolutionParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetConvolutionParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glGetSeparableFilterEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        glsCSTR("glSeparableFilter2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        glsCSTR("glGetHistogramEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetHistogramParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetHistogramParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetMinmaxEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetMinmaxParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glGetMinmaxParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glHistogramEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glMinmaxEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glResetHistogramEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        glsCSTR("glResetMinmaxEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        glsCSTR("glTexImage3DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        glsCSTR("glTexSubImage3DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        glsCSTR("glDetailTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        glsCSTR("glGetDetailTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        glsCSTR("glSharpenTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        glsCSTR("glGetSharpenTexFuncSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        glsCSTR("glArrayElementEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glColorPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glDrawArraysEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glEdgeFlagPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glGetPointervEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glIndexPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glNormalPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glTexCoordPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        glsCSTR("glVertexPointerEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        glsCSTR("glAreTexturesResidentEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glBindTextureEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glDeleteTexturesEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glGenTexturesEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glIsTextureEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        glsCSTR("glPrioritizeTexturesEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        glsCSTR("glColorTableEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        glsCSTR("glColorTableParameterfvSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        glsCSTR("glColorTableParameterivSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        glsCSTR("glCopyColorTableSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        glsCSTR("glGetColorTableEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        glsCSTR("glGetColorTableParameterfvEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        glsCSTR("glGetColorTableParameterivEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        glsCSTR("glGetTexColorTableParameterfvSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        glsCSTR("glGetTexColorTableParameterivSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        glsCSTR("glTexColorTableParameterfvSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        glsCSTR("glTexColorTableParameterivSGI"),
    #else
        GLS_NONE,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexImage1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexImage2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexSubImage1DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexSubImage2DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        glsCSTR("glCopyTexSubImage3DEXT"),
    #else
        GLS_NONE,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        glsCSTR("glTexImage4DSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        glsCSTR("glTexSubImage4DSGIS"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        glsCSTR("glPixelTexGenSGIX"),
    #else
        GLS_NONE,
    #endif /* __GL_SGIX_pixel_texture */
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    GLS_NONE,
    #if __GL_EXT_paletted_texture
        // DrewB
        glsCSTR("glColorSubTableEXT"),
    #else
        GLS_NONE,
        GLS_NONE,
    #endif
};

const GLSopcode __glsOpcodesGLS[] = {
    GLS_OP_glsBeginGLS,
    GLS_OP_glsBlock,
    GLS_OP_glsCallStream,
    GLS_OP_glsEndGLS,
    GLS_OP_glsError,
    GLS_OP_glsGLRC,
    GLS_OP_glsGLRCLayer,
    GLS_OP_glsHeaderGLRCi,
    GLS_OP_glsHeaderLayerf,
    GLS_OP_glsHeaderLayeri,
    GLS_OP_glsHeaderf,
    GLS_OP_glsHeaderfv,
    GLS_OP_glsHeaderi,
    GLS_OP_glsHeaderiv,
    GLS_OP_glsHeaderubz,
    GLS_OP_glsRequireExtension,
    GLS_OP_glsUnsupportedCommand,
    GLS_OP_glsAppRef,
    GLS_OP_glsBeginObj,
    GLS_OP_glsCharubz,
    GLS_OP_glsComment,
    GLS_OP_glsDisplayMapfv,
    GLS_OP_glsEndObj,
    GLS_OP_glsNumb,
    GLS_OP_glsNumbv,
    GLS_OP_glsNumd,
    GLS_OP_glsNumdv,
    GLS_OP_glsNumf,
    GLS_OP_glsNumfv,
    GLS_OP_glsNumi,
    GLS_OP_glsNumiv,
    GLS_OP_glsNuml,
    GLS_OP_glsNumlv,
    GLS_OP_glsNums,
    GLS_OP_glsNumsv,
    GLS_OP_glsNumub,
    GLS_OP_glsNumubv,
    GLS_OP_glsNumui,
    GLS_OP_glsNumuiv,
    GLS_OP_glsNumul,
    GLS_OP_glsNumulv,
    GLS_OP_glsNumus,
    GLS_OP_glsNumusv,
    GLS_OP_glsPad,
    GLS_OP_glsSwapBuffers,
    GLS_NONE
};

const GLSopcode __glsOpcodesGL[] = {
    GLS_OP_glNewList,
    GLS_OP_glEndList,
    GLS_OP_glCallList,
    GLS_OP_glCallLists,
    GLS_OP_glDeleteLists,
    GLS_OP_glGenLists,
    GLS_OP_glListBase,
    GLS_OP_glBegin,
    GLS_OP_glBitmap,
    GLS_OP_glColor3b,
    GLS_OP_glColor3bv,
    GLS_OP_glColor3d,
    GLS_OP_glColor3dv,
    GLS_OP_glColor3f,
    GLS_OP_glColor3fv,
    GLS_OP_glColor3i,
    GLS_OP_glColor3iv,
    GLS_OP_glColor3s,
    GLS_OP_glColor3sv,
    GLS_OP_glColor3ub,
    GLS_OP_glColor3ubv,
    GLS_OP_glColor3ui,
    GLS_OP_glColor3uiv,
    GLS_OP_glColor3us,
    GLS_OP_glColor3usv,
    GLS_OP_glColor4b,
    GLS_OP_glColor4bv,
    GLS_OP_glColor4d,
    GLS_OP_glColor4dv,
    GLS_OP_glColor4f,
    GLS_OP_glColor4fv,
    GLS_OP_glColor4i,
    GLS_OP_glColor4iv,
    GLS_OP_glColor4s,
    GLS_OP_glColor4sv,
    GLS_OP_glColor4ub,
    GLS_OP_glColor4ubv,
    GLS_OP_glColor4ui,
    GLS_OP_glColor4uiv,
    GLS_OP_glColor4us,
    GLS_OP_glColor4usv,
    GLS_OP_glEdgeFlag,
    GLS_OP_glEdgeFlagv,
    GLS_OP_glEnd,
    GLS_OP_glIndexd,
    GLS_OP_glIndexdv,
    GLS_OP_glIndexf,
    GLS_OP_glIndexfv,
    GLS_OP_glIndexi,
    GLS_OP_glIndexiv,
    GLS_OP_glIndexs,
    GLS_OP_glIndexsv,
    GLS_OP_glNormal3b,
    GLS_OP_glNormal3bv,
    GLS_OP_glNormal3d,
    GLS_OP_glNormal3dv,
    GLS_OP_glNormal3f,
    GLS_OP_glNormal3fv,
    GLS_OP_glNormal3i,
    GLS_OP_glNormal3iv,
    GLS_OP_glNormal3s,
    GLS_OP_glNormal3sv,
    GLS_OP_glRasterPos2d,
    GLS_OP_glRasterPos2dv,
    GLS_OP_glRasterPos2f,
    GLS_OP_glRasterPos2fv,
    GLS_OP_glRasterPos2i,
    GLS_OP_glRasterPos2iv,
    GLS_OP_glRasterPos2s,
    GLS_OP_glRasterPos2sv,
    GLS_OP_glRasterPos3d,
    GLS_OP_glRasterPos3dv,
    GLS_OP_glRasterPos3f,
    GLS_OP_glRasterPos3fv,
    GLS_OP_glRasterPos3i,
    GLS_OP_glRasterPos3iv,
    GLS_OP_glRasterPos3s,
    GLS_OP_glRasterPos3sv,
    GLS_OP_glRasterPos4d,
    GLS_OP_glRasterPos4dv,
    GLS_OP_glRasterPos4f,
    GLS_OP_glRasterPos4fv,
    GLS_OP_glRasterPos4i,
    GLS_OP_glRasterPos4iv,
    GLS_OP_glRasterPos4s,
    GLS_OP_glRasterPos4sv,
    GLS_OP_glRectd,
    GLS_OP_glRectdv,
    GLS_OP_glRectf,
    GLS_OP_glRectfv,
    GLS_OP_glRecti,
    GLS_OP_glRectiv,
    GLS_OP_glRects,
    GLS_OP_glRectsv,
    GLS_OP_glTexCoord1d,
    GLS_OP_glTexCoord1dv,
    GLS_OP_glTexCoord1f,
    GLS_OP_glTexCoord1fv,
    GLS_OP_glTexCoord1i,
    GLS_OP_glTexCoord1iv,
    GLS_OP_glTexCoord1s,
    GLS_OP_glTexCoord1sv,
    GLS_OP_glTexCoord2d,
    GLS_OP_glTexCoord2dv,
    GLS_OP_glTexCoord2f,
    GLS_OP_glTexCoord2fv,
    GLS_OP_glTexCoord2i,
    GLS_OP_glTexCoord2iv,
    GLS_OP_glTexCoord2s,
    GLS_OP_glTexCoord2sv,
    GLS_OP_glTexCoord3d,
    GLS_OP_glTexCoord3dv,
    GLS_OP_glTexCoord3f,
    GLS_OP_glTexCoord3fv,
    GLS_OP_glTexCoord3i,
    GLS_OP_glTexCoord3iv,
    GLS_OP_glTexCoord3s,
    GLS_OP_glTexCoord3sv,
    GLS_OP_glTexCoord4d,
    GLS_OP_glTexCoord4dv,
    GLS_OP_glTexCoord4f,
    GLS_OP_glTexCoord4fv,
    GLS_OP_glTexCoord4i,
    GLS_OP_glTexCoord4iv,
    GLS_OP_glTexCoord4s,
    GLS_OP_glTexCoord4sv,
    GLS_OP_glVertex2d,
    GLS_OP_glVertex2dv,
    GLS_OP_glVertex2f,
    GLS_OP_glVertex2fv,
    GLS_OP_glVertex2i,
    GLS_OP_glVertex2iv,
    GLS_OP_glVertex2s,
    GLS_OP_glVertex2sv,
    GLS_OP_glVertex3d,
    GLS_OP_glVertex3dv,
    GLS_OP_glVertex3f,
    GLS_OP_glVertex3fv,
    GLS_OP_glVertex3i,
    GLS_OP_glVertex3iv,
    GLS_OP_glVertex3s,
    GLS_OP_glVertex3sv,
    GLS_OP_glVertex4d,
    GLS_OP_glVertex4dv,
    GLS_OP_glVertex4f,
    GLS_OP_glVertex4fv,
    GLS_OP_glVertex4i,
    GLS_OP_glVertex4iv,
    GLS_OP_glVertex4s,
    GLS_OP_glVertex4sv,
    GLS_OP_glClipPlane,
    GLS_OP_glColorMaterial,
    GLS_OP_glCullFace,
    GLS_OP_glFogf,
    GLS_OP_glFogfv,
    GLS_OP_glFogi,
    GLS_OP_glFogiv,
    GLS_OP_glFrontFace,
    GLS_OP_glHint,
    GLS_OP_glLightf,
    GLS_OP_glLightfv,
    GLS_OP_glLighti,
    GLS_OP_glLightiv,
    GLS_OP_glLightModelf,
    GLS_OP_glLightModelfv,
    GLS_OP_glLightModeli,
    GLS_OP_glLightModeliv,
    GLS_OP_glLineStipple,
    GLS_OP_glLineWidth,
    GLS_OP_glMaterialf,
    GLS_OP_glMaterialfv,
    GLS_OP_glMateriali,
    GLS_OP_glMaterialiv,
    GLS_OP_glPointSize,
    GLS_OP_glPolygonMode,
    GLS_OP_glPolygonStipple,
    GLS_OP_glScissor,
    GLS_OP_glShadeModel,
    GLS_OP_glTexParameterf,
    GLS_OP_glTexParameterfv,
    GLS_OP_glTexParameteri,
    GLS_OP_glTexParameteriv,
    GLS_OP_glTexImage1D,
    GLS_OP_glTexImage2D,
    GLS_OP_glTexEnvf,
    GLS_OP_glTexEnvfv,
    GLS_OP_glTexEnvi,
    GLS_OP_glTexEnviv,
    GLS_OP_glTexGend,
    GLS_OP_glTexGendv,
    GLS_OP_glTexGenf,
    GLS_OP_glTexGenfv,
    GLS_OP_glTexGeni,
    GLS_OP_glTexGeniv,
    GLS_OP_glFeedbackBuffer,
    GLS_OP_glSelectBuffer,
    GLS_OP_glRenderMode,
    GLS_OP_glInitNames,
    GLS_OP_glLoadName,
    GLS_OP_glPassThrough,
    GLS_OP_glPopName,
    GLS_OP_glPushName,
    GLS_OP_glDrawBuffer,
    GLS_OP_glClear,
    GLS_OP_glClearAccum,
    GLS_OP_glClearIndex,
    GLS_OP_glClearColor,
    GLS_OP_glClearStencil,
    GLS_OP_glClearDepth,
    GLS_OP_glStencilMask,
    GLS_OP_glColorMask,
    GLS_OP_glDepthMask,
    GLS_OP_glIndexMask,
    GLS_OP_glAccum,
    GLS_OP_glDisable,
    GLS_OP_glEnable,
    GLS_OP_glFinish,
    GLS_OP_glFlush,
    GLS_OP_glPopAttrib,
    GLS_OP_glPushAttrib,
    GLS_OP_glMap1d,
    GLS_OP_glMap1f,
    GLS_OP_glMap2d,
    GLS_OP_glMap2f,
    GLS_OP_glMapGrid1d,
    GLS_OP_glMapGrid1f,
    GLS_OP_glMapGrid2d,
    GLS_OP_glMapGrid2f,
    GLS_OP_glEvalCoord1d,
    GLS_OP_glEvalCoord1dv,
    GLS_OP_glEvalCoord1f,
    GLS_OP_glEvalCoord1fv,
    GLS_OP_glEvalCoord2d,
    GLS_OP_glEvalCoord2dv,
    GLS_OP_glEvalCoord2f,
    GLS_OP_glEvalCoord2fv,
    GLS_OP_glEvalMesh1,
    GLS_OP_glEvalPoint1,
    GLS_OP_glEvalMesh2,
    GLS_OP_glEvalPoint2,
    GLS_OP_glAlphaFunc,
    GLS_OP_glBlendFunc,
    GLS_OP_glLogicOp,
    GLS_OP_glStencilFunc,
    GLS_OP_glStencilOp,
    GLS_OP_glDepthFunc,
    GLS_OP_glPixelZoom,
    GLS_OP_glPixelTransferf,
    GLS_OP_glPixelTransferi,
    GLS_OP_glPixelStoref,
    GLS_OP_glPixelStorei,
    GLS_OP_glPixelMapfv,
    GLS_OP_glPixelMapuiv,
    GLS_OP_glPixelMapusv,
    GLS_OP_glReadBuffer,
    GLS_OP_glCopyPixels,
    GLS_OP_glReadPixels,
    GLS_OP_glDrawPixels,
    GLS_OP_glGetBooleanv,
    GLS_OP_glGetClipPlane,
    GLS_OP_glGetDoublev,
    GLS_OP_glGetError,
    GLS_OP_glGetFloatv,
    GLS_OP_glGetIntegerv,
    GLS_OP_glGetLightfv,
    GLS_OP_glGetLightiv,
    GLS_OP_glGetMapdv,
    GLS_OP_glGetMapfv,
    GLS_OP_glGetMapiv,
    GLS_OP_glGetMaterialfv,
    GLS_OP_glGetMaterialiv,
    GLS_OP_glGetPixelMapfv,
    GLS_OP_glGetPixelMapuiv,
    GLS_OP_glGetPixelMapusv,
    GLS_OP_glGetPolygonStipple,
    GLS_OP_glGetString,
    GLS_OP_glGetTexEnvfv,
    GLS_OP_glGetTexEnviv,
    GLS_OP_glGetTexGendv,
    GLS_OP_glGetTexGenfv,
    GLS_OP_glGetTexGeniv,
    GLS_OP_glGetTexImage,
    GLS_OP_glGetTexParameterfv,
    GLS_OP_glGetTexParameteriv,
    GLS_OP_glGetTexLevelParameterfv,
    GLS_OP_glGetTexLevelParameteriv,
    GLS_OP_glIsEnabled,
    GLS_OP_glIsList,
    GLS_OP_glDepthRange,
    GLS_OP_glFrustum,
    GLS_OP_glLoadIdentity,
    GLS_OP_glLoadMatrixf,
    GLS_OP_glLoadMatrixd,
    GLS_OP_glMatrixMode,
    GLS_OP_glMultMatrixf,
    GLS_OP_glMultMatrixd,
    GLS_OP_glOrtho,
    GLS_OP_glPopMatrix,
    GLS_OP_glPushMatrix,
    GLS_OP_glRotated,
    GLS_OP_glRotatef,
    GLS_OP_glScaled,
    GLS_OP_glScalef,
    GLS_OP_glTranslated,
    GLS_OP_glTranslatef,
    GLS_OP_glViewport,
    GLS_OP_glArrayElement,
    GLS_OP_glBindTexture,
    GLS_OP_glColorPointer,
    GLS_OP_glDisableClientState,
    GLS_OP_glDrawArrays,
    GLS_OP_glDrawElements,
    GLS_OP_glEdgeFlagPointer,
    GLS_OP_glEnableClientState,
    GLS_OP_glIndexPointer,
    GLS_OP_glIndexub,
    GLS_OP_glIndexubv,
    GLS_OP_glInterleavedArrays,
    GLS_OP_glNormalPointer,
    GLS_OP_glPolygonOffset,
    GLS_OP_glTexCoordPointer,
    GLS_OP_glVertexPointer,
    GLS_OP_glAreTexturesResident,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDeleteTextures,
    GLS_OP_glGenTextures,
    GLS_OP_glGetPointerv,
    GLS_OP_glIsTexture,
    GLS_OP_glPrioritizeTextures,
    GLS_OP_glTexSubImage1D,
    GLS_OP_glTexSubImage2D,
    GLS_OP_glPushClientAttrib,
    GLS_OP_glPopClientAttrib,
    #if __GL_EXT_blend_color
        GLS_OP_glBlendColorEXT,
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        GLS_OP_glBlendEquationEXT,
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        GLS_OP_glPolygonOffsetEXT,
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        GLS_OP_glTexSubImage1DEXT,
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        GLS_OP_glTexSubImage2DEXT,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        GLS_OP_glSampleMaskSGIS,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        GLS_OP_glSamplePatternSGIS,
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        GLS_OP_glTagSampleBufferSGIX,
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionFilter1DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionFilter2DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameterfEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameterfvEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameteriEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glConvolutionParameterivEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glCopyConvolutionFilter1DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glCopyConvolutionFilter2DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetConvolutionFilterEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetConvolutionParameterfvEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetConvolutionParameterivEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glGetSeparableFilterEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        GLS_OP_glSeparableFilter2DEXT,
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        GLS_OP_glGetHistogramEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetHistogramParameterfvEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetHistogramParameterivEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetMinmaxEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetMinmaxParameterfvEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glGetMinmaxParameterivEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glHistogramEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glMinmaxEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glResetHistogramEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        GLS_OP_glResetMinmaxEXT,
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        GLS_OP_glTexImage3DEXT,
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        GLS_OP_glTexSubImage3DEXT,
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        GLS_OP_glDetailTexFuncSGIS,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        GLS_OP_glGetDetailTexFuncSGIS,
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_OP_glSharpenTexFuncSGIS,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        GLS_OP_glGetSharpenTexFuncSGIS,
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        GLS_OP_glArrayElementEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glColorPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glDrawArraysEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glEdgeFlagPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glGetPointervEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glIndexPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glNormalPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glTexCoordPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        GLS_OP_glVertexPointerEXT,
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        GLS_OP_glAreTexturesResidentEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glBindTextureEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glDeleteTexturesEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glGenTexturesEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glIsTextureEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        GLS_OP_glPrioritizeTexturesEXT,
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        GLS_OP_glColorTableEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        GLS_OP_glColorTableParameterfvSGI,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_OP_glColorTableParameterivSGI,
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        GLS_OP_glCopyColorTableSGI,
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        GLS_OP_glGetColorTableEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        GLS_OP_glGetColorTableParameterfvEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        GLS_OP_glGetColorTableParameterivEXT,
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        GLS_OP_glGetTexColorTableParameterfvSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_OP_glGetTexColorTableParameterivSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_OP_glTexColorTableParameterfvSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        GLS_OP_glTexColorTableParameterivSGI,
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexImage1DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexImage2DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexSubImage1DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexSubImage2DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        GLS_OP_glCopyTexSubImage3DEXT,
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        GLS_OP_glTexImage4DSGIS,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        GLS_OP_glTexSubImage4DSGIS,
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        GLS_OP_glPixelTexGenSGIX,
    #endif /* __GL_SGIX_pixel_texture */
    #if __GL_EXT_paletted_texture
        // DrewB
        GLS_OP_glColorSubTableEXT,
    #endif
    GLS_NONE
};

const GLint __glsOpcodesGLSCount = (
    45
);

const GLint __glsOpcodesGLCount = (
    #if __GL_EXT_blend_color
        1 +
    #endif /* __GL_EXT_blend_color */
    #if __GL_EXT_blend_minmax
        1 +
    #endif /* __GL_EXT_blend_minmax */
    #if __GL_EXT_polygon_offset
        1 +
    #endif /* __GL_EXT_polygon_offset */
    #if __GL_EXT_subtexture
        1 +
    #endif /* __GL_EXT_subtexture */
    #if __GL_EXT_subtexture
        1 +
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_multisample
        1 +
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIS_multisample
        1 +
    #endif /* __GL_SGIS_multisample */
    #if __GL_SGIX_multisample
        1 +
    #endif /* __GL_SGIX_multisample */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_convolution
        1 +
    #endif /* __GL_EXT_convolution */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_histogram
        1 +
    #endif /* __GL_EXT_histogram */
    #if __GL_EXT_texture3D
        1 +
    #endif /* __GL_EXT_texture3D */
    #if __GL_EXT_subtexture
        1 +
    #endif /* __GL_EXT_subtexture */
    #if __GL_SGIS_detail_texture
        1 +
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_detail_texture
        1 +
    #endif /* __GL_SGIS_detail_texture */
    #if __GL_SGIS_sharpen_texture
        1 +
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_SGIS_sharpen_texture
        1 +
    #endif /* __GL_SGIS_sharpen_texture */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_vertex_array
        1 +
    #endif /* __GL_EXT_vertex_array */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_texture_object
        1 +
    #endif /* __GL_EXT_texture_object */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_color_table
        1 +
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        1 +
    #endif /* __GL_SGI_color_table */
    #if __GL_SGI_color_table
        1 +
    #endif /* __GL_SGI_color_table */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_EXT_paletted_texture
        1 +
    #endif /* __GL_EXT_paletted_texture */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_SGI_texture_color_table
        1 +
    #endif /* __GL_SGI_texture_color_table */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_EXT_copy_texture
        1 +
    #endif /* __GL_EXT_copy_texture */
    #if __GL_SGIS_texture4D
        1 +
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIS_texture4D
        1 +
    #endif /* __GL_SGIS_texture4D */
    #if __GL_SGIX_pixel_texture
        1 +
    #endif /* __GL_SGIX_pixel_texture */
    #if __GL_EXT_paletted_texture
        // DrewB
        1 +
    #endif
    // DrewB - 1.1
    336
);

const GLint __glsOpPageMap[__GLS_MAPPED_OPCODE_PAGE_COUNT] = {
    4095,
    4094,
    4093,
    4092,
    4091,
    4090,
    4089,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\parser.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>

__GLSparser* __glsParser_create(void) {
    __GLSparser *const outParser = __glsCalloc(1, sizeof(__GLSparser));
    GLint count, i, j;

    if (!outParser) return GLS_NONE;
    outParser->glAttribMaskDict = __glsStrDict_create(
        __GL_ATTRIB_MASK_COUNT, GL_TRUE
    );
    if (!outParser->glAttribMaskDict) return __glsParser_destroy(outParser);
    for (i = 0 ; i < __GL_ATTRIB_MASK_COUNT ; ++i) {
        if (!__glsStr2IntDict_add(
            outParser->glAttribMaskDict,
            __glAttribMaskString[i],
            (GLint)__glAttribMaskVal[i]
        )) {
            return __glsParser_destroy(outParser);
        }
    }
    /* GL_ZERO GL_ONE GL_FALSE GL_TRUE GL_NONE GL_NO_ERROR */
    count = 6;
    for (i = 0 ; i < __GL_ENUM_PAGE_COUNT ; ++i) {
        count += __glEnumStringCount[i];
    }
    outParser->glEnumDict = __glsStrDict_create(count, GL_TRUE);
    if (!outParser->glEnumDict) return __glsParser_destroy(outParser);
    if (
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_ZERO"), 0) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_ONE"), 1) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_FALSE"), 0) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_TRUE"), 1) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_NONE"), 0) ||
        !__glsStr2IntDict_add(outParser->glEnumDict, glsCSTR("GL_NO_ERROR"), 0)
    ) {
        return __glsParser_destroy(outParser);
    }
    for (i = 0 ; i < __GL_ENUM_PAGE_COUNT ; ++i) {
        for (j = 0 ; j < __glEnumStringCount[i] ; ++j) {
            if (__glEnumString[i][j] && !__glsStr2IntDict_add(
                outParser->glEnumDict,
                __glEnumString[i][j],
                __GL_ENUM(i, j)
            )) {
                return __glsParser_destroy(outParser);
            }
        }
    }
    /* GL_FALSE GL_TRUE */
    count = 2;
    for (i = 0 ; i < __GLS_ENUM_PAGE_COUNT ; ++i) {
        count += __glsEnumStringCount[i];
    }
    outParser->glsEnumDict = __glsStrDict_create(count, GL_TRUE);
    if (!outParser->glsEnumDict) return __glsParser_destroy(outParser);
    if (
        !__glsStr2IntDict_add(
            outParser->glsEnumDict, glsCSTR("GL_FALSE"), 0
        ) ||
        !__glsStr2IntDict_add(
            outParser->glsEnumDict, glsCSTR("GL_TRUE"), 1
        )
    ) {
        return __glsParser_destroy(outParser);
    }
    for (i = 0 ; i < __GLS_ENUM_PAGE_COUNT ; ++i) {
        for (j = 0 ; j < __glsEnumStringCount[i] ; ++j) {
            if (__glsEnumString[i][j] && !__glsStr2IntDict_add(
                outParser->glsEnumDict,
                __glsEnumString[i][j],
                __GLS_ENUM(i, j)
            )) {
                return __glsParser_destroy(outParser);
            }
        }
    }
    outParser->glsImageFlagsDict = __glsStrDict_create(
        __GLS_IMAGE_FLAGS_COUNT, GL_TRUE
    );
    if (!outParser->glsImageFlagsDict) return __glsParser_destroy(outParser);
    for (i = 0 ; i < __GLS_IMAGE_FLAGS_COUNT ; ++i) {
        if (!__glsStr2IntDict_add(
            outParser->glsImageFlagsDict,
            __glsImageFlagsString[i],
            (GLint)__glsImageFlagsVal[i]
        )) {
            return __glsParser_destroy(outParser);
        }
    }
    for (
        count = 0, i = __GLS_OPCODES_PER_PAGE ; i < __GLS_OPCODE_COUNT ; ++i
    ) {
        if (__glsOpcodeString[i]) ++count;
    }
    outParser->glsOpDict = __glsStrDict_create(count, GL_TRUE);
    if (!outParser->glsOpDict) return __glsParser_destroy(outParser);

    for (i = __GLS_OPCODES_PER_PAGE ; i < __GLS_OPCODE_COUNT ; ++i) {
        if (__glsOpcodeString[i] && !__glsStr2IntDict_add(
            outParser->glsOpDict,
            __glsOpcodeString[i],
            (GLint)__glsUnmapOpcode(i)
        )) {
            return __glsParser_destroy(outParser);
        }
    }
    return outParser;
}

__GLSparser* __glsParser_destroy(__GLSparser *inParser) {
    if (!inParser) return GLS_NONE;
    __glsStrDict_destroy(inParser->glAttribMaskDict);
    __glsStrDict_destroy(inParser->glEnumDict);
    __glsStrDict_destroy(inParser->glsEnumDict);
    __glsStrDict_destroy(inParser->glsImageFlagsDict);
    __glsStrDict_destroy(inParser->glsOpDict);
    free(inParser);
    return GLS_NONE;
}

GLboolean __glsParser_findCommand(
    const __GLSparser *inParser, const GLubyte *inCommand, GLSopcode *outOpcode
) {
    if (
        __glsStr2IntDict_find(inParser->glsOpDict, inCommand, (GLint*)outOpcode
    )) {
        return GL_TRUE;
    } else {
        __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
        *outOpcode = GLS_OP_glsUnsupportedCommand;
        return GL_FALSE;
    }
}

void __glsParser_print(const __GLSparser *inParser) {
    __glsStrDict_print(
        inParser->glAttribMaskDict, glsCSTR("glAttribMaskDict")
    );
    __glsStrDict_print(
        inParser->glEnumDict, glsCSTR("glEnumDict")
    );
    __glsStrDict_print(
        inParser->glsEnumDict, glsCSTR("glsEnumDict")
    );
    __glsStrDict_print(
        inParser->glsImageFlagsDict, glsCSTR("glsImageFlagsDict")
    );
    __glsStrDict_print(
        inParser->glsOpDict, glsCSTR("glsOpDict")
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\pixel.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

void __glsGenPixelSetup_pack(__GLScontext *ctx) {
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
    __glsPixelSetup_pack();
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
}

void __glsGenPixelSetup_unpack(__GLScontext *ctx) {
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
    __glsPixelSetup_unpack();
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glPixelStorei);
}

void __glsPixelSetup_pack(void) {
    glPixelStorei(GL_PACK_ALIGNMENT, 1);
    glPixelStorei(GL_PACK_LSB_FIRST, GL_FALSE);
    glPixelStorei(GL_PACK_ROW_LENGTH, 0);
    glPixelStorei(GL_PACK_SKIP_ROWS, 0);
    glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
    glPixelStorei(GL_PACK_SWAP_BYTES, GL_FALSE);
    #if __GL_EXT_texture3D
        glPixelStorei(GL_PACK_IMAGE_HEIGHT_EXT, 0);
        glPixelStorei(GL_PACK_SKIP_IMAGES_EXT, 0);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glPixelStorei(GL_PACK_IMAGE_DEPTH_SGIS, 0);
        glPixelStorei(GL_PACK_SKIP_VOLUMES_SGIS, 0);
    #endif /* __GL_SGIS_texture4D */
}

void __glsPixelSetup_unpack(void) {
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_FALSE);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    #if __GL_EXT_texture3D
        glPixelStorei(GL_UNPACK_IMAGE_HEIGHT_EXT, 0);
        glPixelStorei(GL_UNPACK_SKIP_IMAGES_EXT, 0);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glPixelStorei(GL_UNPACK_IMAGE_DEPTH_SGIS, 0);
        glPixelStorei(GL_UNPACK_SKIP_VOLUMES_SGIS, 0);
    #endif /* __GL_SGIS_texture4D */
}

static void __glsPixelStoreConfig_init(__GLSpixelStoreConfig *outConfig) {
    outConfig->alignment = 1;
    outConfig->lsbFirst = GL_FALSE;
    outConfig->rowLength = 0;
    outConfig->skipRows = 0;
    outConfig->skipPixels = 0;
    outConfig->swapBytes = GL_FALSE;
    #if __GL_EXT_texture3D
        outConfig->imageHeight = 0;
        outConfig->skipImages = 0;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        outConfig->imageDepth = 0;
        outConfig->skipVolumes = 0;
    #endif /* __GL_SGIS_texture4D */
}

void __glsPixelStoreConfig_get_pack(__GLSpixelStoreConfig *outConfig) {
    __glsPixelStoreConfig_init(outConfig);
    __GLS_BEGIN_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
    glGetIntegerv(GL_PACK_ALIGNMENT, &outConfig->alignment);
    glGetIntegerv(GL_PACK_LSB_FIRST, &outConfig->lsbFirst);
    glGetIntegerv(GL_PACK_ROW_LENGTH, &outConfig->rowLength);
    glGetIntegerv(GL_PACK_SKIP_ROWS, &outConfig->skipRows);
    glGetIntegerv(GL_PACK_SKIP_PIXELS, &outConfig->skipPixels);
    glGetIntegerv(GL_PACK_SWAP_BYTES, &outConfig->swapBytes);
    #if __GL_EXT_texture3D
        glGetIntegerv(GL_PACK_IMAGE_HEIGHT_EXT, &outConfig->imageHeight);
        glGetIntegerv(GL_PACK_SKIP_IMAGES_EXT, &outConfig->skipImages);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glGetIntegerv(GL_PACK_IMAGE_DEPTH_SGIS, &outConfig->imageDepth);
        glGetIntegerv(GL_PACK_SKIP_VOLUMES_SGIS, &outConfig->skipVolumes);
    #endif /* __GL_SGIS_texture4D */
    __GLS_END_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
}

void __glsPixelStoreConfig_get_unpack(__GLSpixelStoreConfig *outConfig) {
    __glsPixelStoreConfig_init(outConfig);
    __GLS_BEGIN_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &outConfig->alignment);
    glGetIntegerv(GL_UNPACK_LSB_FIRST, &outConfig->lsbFirst);
    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &outConfig->rowLength);
    glGetIntegerv(GL_UNPACK_SKIP_ROWS, &outConfig->skipRows);
    glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &outConfig->skipPixels);
    glGetIntegerv(GL_UNPACK_SWAP_BYTES, &outConfig->swapBytes);
    #if __GL_EXT_texture3D
        glGetIntegerv(GL_UNPACK_IMAGE_HEIGHT_EXT, &outConfig->imageHeight);
        glGetIntegerv(GL_UNPACK_SKIP_IMAGES_EXT, &outConfig->skipImages);
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        glGetIntegerv(GL_UNPACK_IMAGE_DEPTH_SGIS, &outConfig->imageDepth);
        glGetIntegerv(GL_UNPACK_SKIP_VOLUMES_SGIS, &outConfig->skipVolumes);
    #endif /* __GL_SGIS_texture4D */
    __GLS_END_CAPTURE_EXEC(__GLS_CONTEXT, GLS_OP_glGetIntegerv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\platform.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <ctype.h>
#include <errno.h>
#include <stdlib.h>

/******************************************************************************
POSIX threads
******************************************************************************/

#if __GLS_POSIX_THREADS

#if !__GLS_FAKE_MUTEX

static pthread_mutex_t __gls_lock;

static const pthread_mutexattr_t __gls_lockInit = {
    MUTEX_TYPE_FAST,
    MUTEX_FLAGS_INITED,
};

void __glsBeginCriticalSection(void) {
    if (pthread_mutex_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

void __glsEndCriticalSection(void) {
    if (pthread_mutex_unlock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_unlock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE

pthread_key_t __gls_contextTLS;
pthread_key_t __gls_errorTLS;

__GLScontext* __glsGetContext(void) {
    return (__GLScontext *)pthread_getspecific(__gls_contextTLS);
}

GLSenum __glsGetError(void) {
    return (GLSenum)pthread_getspecific(__gls_errorTLS);
}

#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

static void __glsFinalPthreads(void) {
    #if !__GLS_FAKE_MUTEX
        pthread_mutex_destroy(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        pthread_key_delete(__gls_contextTLS);
        pthread_key_delete(__gls_errorTLS);
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
}

static void __glsInitPthreads(void) {
    #if !__GLS_FAKE_MUTEX
        if (pthread_mutex_init(&__gls_lock, &__gls_lockInit)) {
            fprintf(stderr, "GLS fatal: pthread_mutex_init failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        if (
            pthread_key_create(&__gls_contextTLS, GLS_NONE) ||
            pthread_key_create(&__gls_errorTLS, GLS_NONE)
        ) {
            fprintf(stderr, "GLS fatal: pthread_key_create failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
}

#endif /* __GLS_POSIX_THREADS */

/******************************************************************************
These routines must be called during library loading/unloading
******************************************************************************/

static GLboolean __glsInitContextDict(void) {
    __glsContextDict = __glsIntDict_create(1);
    return (GLboolean)(__glsContextDict != GLS_NONE);
}

static void __glsFinalContextDict(void) {
    __GLScontext *ctx;
    __GLS_LIST_ITER(__GLScontext) iter;

    __GLS_LIST_FIRST(&__glsContextList, &iter);
    while (ctx = iter.elem) {
        __GLS_LIST_NEXT(&__glsContextList, &iter);
        __glsContext_destroy(ctx);
    }
    __glsIntDict_destroy(__glsContextDict);
}

/******************************************************************************
Fake lltostr
******************************************************************************/

#if __GLS_FAKE_LLTOSTR

char *ulltostr(GLulong inVal, char *outBuf) {
    char buf[24];
    char *p1 = buf;
    char *p2 = outBuf;

    do {
        *p1++ = '0' + (char)(inVal % 10);
        inVal /= 10;
    } while (inVal);
    while (--p1 >= buf) *p2++ = *p1;
    *p2 = 0;
    return outBuf;
}

char *lltostr(GLlong inVal, char *outBuf) {
    char *p = outBuf;

    if (inVal < 0) {
        *p++ = '-';
        inVal = -inVal;
    }
    ulltostr(inVal, p);
    return outBuf;
}

#endif /* __GLS_FAKE_LLTOSTR */

/******************************************************************************
Fake mutex
******************************************************************************/

#if __GLS_FAKE_MUTEX

void __glsBeginCriticalSection(void) {
}

void __glsEndCriticalSection(void) {
}

#endif /* __GLS_FAKE_MUTEX */

/******************************************************************************
Fake strtoll
******************************************************************************/

#if __GLS_FAKE_STRTOLL

#define __GLS_DIGIT(c) ( \
    isdigit(c) ? c - '0' : islower(c) ? c - 'a' + 10 : c - 'A' + 10 \
)

#define __GLS_LL_MIN    (-9223372036854775807LL-1LL)
#define __GLS_LL_MAX    9223372036854775807LL
#define __GLS_ULL_MAX   18446744073709551615LLU

static GLboolean __gls_strtoull(
    const char *inStr, char **outPtr, GLboolean *outNeg, GLulong *outVal
) {
    GLint base, c, d;
    GLulong multMax, val;
    const char **ptr = (const char **)outPtr;

    if (ptr) *ptr = inStr;
    *outNeg = GL_FALSE;
    if (!isalnum(c = *inStr)) {
        while (isspace(c)) c = *++inStr;
        switch (c) {
            case '-':
                *outNeg = GL_TRUE;
                c = *++inStr;
                break;
            case '+':
                c = *++inStr;
                break;
        }
    }
    if (c != '0') {
        base = 10;
    } else if (inStr[1] == 'x' || inStr[1] == 'X') {
        base = 16;
    } else {
        base = 8;
    }
    if (!isalnum(c) || __GLS_DIGIT(c) >= base) {
        *outVal = 0;
        return GL_TRUE;
    }
    if (base == 16 && isxdigit(inStr[2])) c = *(inStr += 2);
    multMax = __GLS_ULL_MAX / base;
    val = __GLS_DIGIT(c);
    for (c = *++inStr; isalnum(c) && (d = __GLS_DIGIT(c)) < base; ) {
        if (val > multMax) goto overflow;
        val *= base;
        if (__GLS_ULL_MAX - val < d) goto overflow;
        val += d;
        c = *++inStr;
    }
    if (ptr) *ptr = inStr;
    *outVal = val;
    return GL_TRUE;
overflow:
    for (c = *++inStr; isalnum(c) && __GLS_DIGIT(c) < base; c = *++inStr);
    if (ptr) *ptr = inStr;
    return GL_FALSE;
}

extern GLlong strtoll(const char *inStr, char **outPtr, int inBase) {
    GLboolean neg;
    GLulong outVal;

    if (
        !__gls_strtoull(inStr, outPtr, &neg, &outVal) ||
        outVal > (GLulong)__GLS_LL_MAX + (GLulong)neg
    ) {
        __GLS_PUT_ERRNO(ERANGE);
        return neg ? __GLS_LL_MIN : __GLS_LL_MAX;
    } else {
        return neg ? -outVal : outVal;
    }
}

extern GLulong strtoull(const char *inStr, char **outPtr, int inBase) {
    GLboolean neg;
    GLulong outVal;

    if (!__gls_strtoull(inStr, outPtr, &neg, &outVal)) {
        __GLS_PUT_ERRNO(ERANGE);
        return __GLS_ULL_MAX;
    } else {
        return neg ? -outVal : outVal;
    }
}

#endif /* __GLS_FAKE_STRTOLL */

/******************************************************************************
Fake thread-local storage
******************************************************************************/

#if __GLS_FAKE_THREAD_LOCAL_STORAGE
    __GLScontext *__gls_context;
    GLSenum __gls_error;
#endif /* __GLS_FAKE_THREAD_LOCAL_STORAGE */

/******************************************************************************
2-level GL dispatch with GLS library defining all GL entry points
******************************************************************************/

#if __GLS_GL_DISPATCH

#if __GLS_PLATFORM_WIN32

#include <gldrv.h>
#include <exttable.h>
    
// Version 1.1 table mapping
static GLSopcode opGl11Procs[] =
{
    GLS_OP_glArrayElement,
    GLS_OP_glBindTexture,
    GLS_OP_glColorPointer,
    GLS_OP_glDisableClientState,
    GLS_OP_glDrawArrays,
    GLS_OP_glDrawElements,
    GLS_OP_glEdgeFlagPointer,
    GLS_OP_glEnableClientState,
    GLS_OP_glIndexPointer,
    GLS_OP_glIndexub,
    GLS_OP_glIndexubv,
    GLS_OP_glInterleavedArrays,
    GLS_OP_glNormalPointer,
    GLS_OP_glPolygonOffset,
    GLS_OP_glTexCoordPointer,
    GLS_OP_glVertexPointer,
    GLS_OP_glAreTexturesResident,
    GLS_OP_glCopyTexImage1D,
    GLS_OP_glCopyTexImage2D,
    GLS_OP_glCopyTexSubImage1D,
    GLS_OP_glCopyTexSubImage2D,
    GLS_OP_glDeleteTextures,
    GLS_OP_glGenTextures,
    GLS_OP_glGetPointerv,
    GLS_OP_glIsTexture,
    GLS_OP_glPrioritizeTextures,
    GLS_OP_glTexSubImage1D,
    GLS_OP_glTexSubImage2D,
    GLS_OP_glPopClientAttrib,
    GLS_OP_glPushClientAttrib,
};
#define GL11_PROCS (sizeof(opGl11Procs)/sizeof(opGl11Procs[0]))

// Extension function mapping
static GLSopcode opExtProcs[] =
{
    GLS_OP_glDrawRangeElementsWIN,
    GLS_OP_glColorTableEXT,
    GLS_OP_glColorSubTableEXT,
    GLS_OP_glGetColorTableEXT,
    GLS_OP_glGetColorTableParameterivEXT,
    GLS_OP_glGetColorTableParameterfvEXT
};
#define EXT_PROCS (sizeof(opExtProcs)/sizeof(opExtProcs[0]))

// DrewB
void glsUpdateCaptureExecTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    GLint i;
    GLSopcode op;
    __GLScontext *ctx = __GLS_CONTEXT;
    GLSfunc *pgfn;

    if (ctx == NULL)
    {
#if DBG
        OutputDebugString(TEXT("glsUpdateCaptureExecTable call ignored\n"));
#endif
        return;
    }
    
    ctx->captureExecOverride = GL_TRUE;

    // Copy over standard 1.0 entries
    // The ordering is the same between OpenGL and GLS so straight copy works
    memcpy(&ctx->captureExec[GLS_OP_glNewList], &pgcpt->glDispatchTable,
           OPENGL_VERSION_100_ENTRIES*sizeof(GLSfunc));

    // If the dispatch table contains 1.1 entries, map them in
    pgfn = (GLSfunc *)&pgcpt->glDispatchTable.glArrayElement;
    if (pgcpt->cEntries == OPENGL_VERSION_110_ENTRIES)
    {
        for (i = 0; i < GL11_PROCS; i++)
        {
            op = __glsMapOpcode(opGl11Procs[i]);
            ctx->captureExec[op] = *pgfn++;
        }
    }
#if DBG
    else if (pgcpt->cEntries != OPENGL_VERSION_100_ENTRIES)
    {
        OutputDebugString("glsUpdateCaptureExecTable clt table size wrong\n");
    }
#endif

    // Map in extension functions
#if DBG
    if (pgept->cEntries != EXT_PROCS)
    {
        OutputDebugString("glsUpdateCaptureExecTable ext table size wrong\n");
    }
#endif
    pgfn = (GLSfunc *)&pgept->glDispatchTable;
    for (i = 0; i < EXT_PROCS; i++)
    {
        op = __glsMapOpcode(opExtProcs[i]);
        ctx->captureExec[op] = *pgfn++;
    }
}

void __glsMapGlsTableToGl(const GLSfunc *pgfnGlsTable,
                          GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    GLint i;
    GLSopcode op;
    GLSfunc *pgfn;

#if DBG
    if (sizeof(GLDISPATCHTABLE)/sizeof(PROC) < OPENGL_VERSION_110_ENTRIES)
    {
        OutputDebugString("__glsMapGlsTableToGl GLDISPATCHTABLE too small\n");
    }
#endif
    
    // GLS supports all 1.1 functions so set a 1.1 entry count
    pgcpt->cEntries = OPENGL_VERSION_110_ENTRIES;
    pgept->cEntries = EXT_PROCS;
    
    // Copy over standard 1.0 entries
    // The ordering is the same between OpenGL and GLS so straight copy works
    memcpy(&pgcpt->glDispatchTable, &pgfnGlsTable[GLS_OP_glNewList],
           OPENGL_VERSION_100_ENTRIES*sizeof(GLSfunc));

    // Map in 1.1 entries
    pgfn = (GLSfunc *)&pgcpt->glDispatchTable.glArrayElement;
    for (i = 0; i < GL11_PROCS; i++)
    {
        op = __glsMapOpcode(opGl11Procs[i]);
        *pgfn++ = pgfnGlsTable[op];
    }

    // Map in extension functions
    pgfn = (GLSfunc *)&pgept->glDispatchTable;
    for (i = 0; i < EXT_PROCS; i++)
    {
        op = __glsMapOpcode(opExtProcs[i]);
        *pgfn++ = pgfnGlsTable[op];
    }
}
void glsGetCaptureExecTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    __GLScontext *ctx = __GLS_CONTEXT;

    if (ctx == NULL ||
        !ctx->captureExecOverride)
    {
#if DBG
        OutputDebugString(TEXT("glsGetCaptureExecTable call ignored\n"));
#endif
        return;
    }

    __glsMapGlsTableToGl(ctx->captureExec, pgcpt, pgept);
}

void glsGetCaptureDispatchTable(GLCLTPROCTABLE *pgcpt, GLEXTPROCTABLE *pgept)
{
    __glsMapGlsTableToGl(__glsDispatchCapture, pgcpt, pgept);
}

void __glsBeginCaptureExec(__GLScontext *ctx, GLSopcode inOpcode) {
    if (!ctx->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    if (ctx->captureExecOverride)
    {
        ctx->dispatchAPI[inOpcode] = ctx->captureExec[inOpcode];
    }
    else
    {
        ctx->dispatchAPI[inOpcode] = __glsDispatchExec[inOpcode];
    }
}

void __glsEndCaptureExec(__GLScontext *ctx, GLSopcode inOpcode) {
    if (!ctx->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    ctx->dispatchAPI[inOpcode] = (
        (GLSfunc)__glsDispatchCapture[inOpcode]
    );
}
#else
void __glsBeginCaptureExec(GLSopcode inOpcode) {
    if (!__GLS_CONTEXT->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    __GLS_CONTEXT->dispatchAPI[inOpcode] = __glsDispatchExec[inOpcode];
}

void __glsEndCaptureExec(GLSopcode inOpcode) {
    if (!__GLS_CONTEXT->captureNesting) return;
    inOpcode = __glsMapOpcode(inOpcode);
    __GLS_CONTEXT->dispatchAPI[inOpcode] = (
        (GLSfunc)__glsDispatchCapture[inOpcode]
    );
}
#endif

void __glsUpdateDispatchTables(void) {
}

#include "g_glapi.c"

#endif /* __GLS_GL_DISPATCH */

/******************************************************************************
If using DSOs for the 2-level dispatch, use this DSO init function as well
******************************************************************************/

#if __GLS_GL_DISPATCH_DSO

#include <dlfcn.h>

static void __glsInitGLDispatch_DSO(void) {
    GLvoid *const dso = dlopen(__GL_LIB_NAME, RTLD_LAZY);
    GLint i;
    GLSopcode op;

    if (!dso) {
        fprintf(stderr, "GLS fatal: dlopen failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        const GLSfunc func = (
            (GLSfunc) dlsym(dso, (const char *)__glsOpcodeString[op])
        );

        __glsDispatchExec[op] = func ? func : __glsNop;
    }
}

#endif /* __GLS_GL_DISPATCH_DSO */

/******************************************************************************
Null command func
******************************************************************************/

#if __GLS_SINGLE_NULL_COMMAND_FUNC

GLSfunc glsNullCommandFunc(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return (GLSfunc)__glsNop;
}

#endif /* __GLS_SINGLE_NULL_COMMAND_FUNC */

/******************************************************************************
AIX
******************************************************************************/

#if __GLS_PLATFORM_AIX

#include <a.out.h>
#include <ldfcn.h>
#include <string.h>
#include <sys/ldr.h>

static void __glsInitSA(void) {
    GLint i;
    LDFILE *ldFile = GLS_NONE;
    LDHDR *ldHdr;
    struct ld_info *ldInfo;
    GLvoid *ldInfoBuf = GLS_NONE;
    GLint ldInfoBufSize = 4096;
    LDSYM *ldSym;
    GLSopcode op;
    GLubyte *scnBuf;
    SCNHDR scnHdr;

    if (0) __gls_glRef();
    for (;;) {
        ldInfoBuf = realloc(ldInfoBuf, ldInfoBufSize);
        if (!ldInfoBuf) {
            fprintf(stderr, "GLS fatal: realloc for loadquery failed\n");
            exit(EXIT_FAILURE);
        }
        if (loadquery(L_GETINFO, ldInfoBuf, ldInfoBufSize) != -1) break;
        if (__GLS_ERRNO != ENOMEM) {
            fprintf(stderr, "GLS fatal: loadquery failed\n");
            exit(EXIT_FAILURE);
        }
        ldInfoBufSize <<= 1;
    }
    ldInfo = (struct ld_info *)ldInfoBuf;
    for (;;) {
        if (strstr(ldInfo->ldinfo_filename, __GL_LIB_NAME)) break;
        if (!ldInfo->ldinfo_next) {
            fprintf(stderr, "GLS fatal: %s not loaded\n", __GL_LIB_NAME);
            exit(EXIT_FAILURE);
        }
        ldInfo = (struct ld_info *)((GLubyte *)ldInfo + ldInfo->ldinfo_next);
    }
    ldFile = ldopen(ldInfo->ldinfo_filename, ldFile);
    if (!ldFile) {
        fprintf(
            stderr,
            "GLS fatal: ldopen failed on %s\n",
            ldInfo->ldinfo_filename
        );
        exit(EXIT_FAILURE);
    }
    if (ldnshread(ldFile, _LOADER, &scnHdr) != SUCCESS) {
        fprintf(stderr, "GLS fatal: ldnshread failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    scnBuf = (GLubyte *)malloc(scnHdr.s_size);
    if (!scnBuf) {
        fprintf(stderr, "GLS fatal: malloc for scnBuf failed\n");
        exit(EXIT_FAILURE);
    }
    if (FSEEK(ldFile, scnHdr.s_scnptr, BEGINNING) != OKFSEEK) {
        fprintf(stderr, "GLS fatal: FSEEK failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    if (FREAD((char *)scnBuf, scnHdr.s_size, 1, ldFile) != 1) {
        fprintf(stderr, "GLS fatal: FREAD failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        __glsDispatchExec[op] = __glsNop;
    }
    __glsParser = __glsParser_create();
    ldHdr = (LDHDR *)scnBuf;
    ldSym = (LDSYM *)(scnBuf + LDHDRSZ);
    for (i = 0 ; i < ldHdr->l_nsyms ; ++i, ++ldSym) {
        GLubyte *sym;

	if (!LDR_EXPORT(*ldSym)) continue;
        if (ldSym->l_zeroes) {
            sym = (GLubyte *)ldSym->l_name;
        } else {
            sym = scnBuf + ldHdr->l_stoff + ldSym->l_offset;
        }
        if (__glsStr2IntDict_find(__glsParser->glsOpDict, sym, (GLint*)&op)) {
            __glsDispatchExec[__glsMapOpcode(op)] = (GLSfunc)(
                (GLubyte *)ldInfo->ldinfo_dataorg + ldSym->l_value
            );
        }
    }
    free(ldInfoBuf);
    free(scnBuf);
    while(ldclose(ldFile) == FAILURE);
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

static GLboolean __glsInitDone;

void __glsBeginCriticalSection(void) {
    if (!__glsInitDone) {
        __glsInitSA();
        __glsInitDone = GL_TRUE;
    }
}

void __glsEndCriticalSection(void) {
}

#endif /* __GLS_PLATFORM_AIX */

/******************************************************************************
DECUNIX
******************************************************************************/

#if __GLS_PLATFORM_DECUNIX


#if !__GLS_FAKE_MUTEX

static pthread_mutex_t __gls_lock;

void __glsBeginCriticalSection(void) {
    if (pthread_mutex_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

void __glsEndCriticalSection(void) {
    if (pthread_mutex_unlock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: pthread_mutex_unlock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE

pthread_key_t __gls_contextTLS;
pthread_key_t __gls_errorTLS;

__GLScontext* __glsGetContext(void) {
    __GLScontext *outContext;

    pthread_getspecific(__gls_contextTLS, (pthread_addr_t *)&outContext);
    return outContext;
}

GLSenum __glsGetError(void) {
    GLvoid *outError;

    pthread_getspecific(__gls_errorTLS, (pthread_addr_t *)&outError);
    return (GLSenum)outError;
}

#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if !__GLS_FAKE_MUTEX
        pthread_mutex_destroy(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if !__GLS_FAKE_MUTEX
        if (pthread_mutex_init(&__gls_lock, pthread_mutexattr_default)) {
            fprintf(stderr, "GLS fatal: pthread_mutex_init failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        if (
            pthread_keycreate(&__gls_contextTLS, GLS_NONE) ||
            pthread_keycreate(&__gls_errorTLS, GLS_NONE)
        ) {
            fprintf(stderr, "GLS fatal: pthread_keycreate failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_DECUNIX */

/******************************************************************************
HPUX
******************************************************************************/

#if __GLS_PLATFORM_HPUX

#include <dl.h>

void __glsInitSL(void) {
    GLint i;
    GLSopcode op;
    shl_t sl = shl_load(__GL_LIB_NAME, BIND_DEFERRED | DYNAMIC_PATH, 0);

    if (!sl) {
        fprintf(stderr, "GLS fatal: shl_load failed on %s\n", __GL_LIB_NAME);
        exit(EXIT_FAILURE);
    }
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        GLSfunc func;

        if (
            !shl_findsym(
                &sl,
                (const char *)__glsOpcodeString[op],
                TYPE_PROCEDURE,
                &func
            )
        ) {
            __glsDispatchExec[op] = func;
        } else {
            __glsDispatchExec[op] = __glsNop;
        }
    }
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_HPUX */

/******************************************************************************
IRIX
******************************************************************************/

#if __GLS_PLATFORM_IRIX

#if !__GLS_FAKE_MUTEX

#include <abi_mutex.h>

static abilock_t __gls_lock;

void __glsBeginCriticalSection(void) {
    spin_lock(&__gls_lock);
}

void __glsEndCriticalSection(void) {
    if (release_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: release_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if !__GLS_FAKE_MUTEX
        if (init_lock(&__gls_lock)) {
            fprintf(stderr, "GLS fatal: init_lock failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#if !__GLS_GL_DISPATCH

#include "glxclient.h"

extern __GLdispatchState __glDispatchCapture;

void __glsBeginCaptureExec(GLSopcode inOpcode) {
    if (!__gl_dispatchOverride) return;
    __gl_dispatch = *__glXDispatchExec();
}

void __glsEndCaptureExec(GLSopcode inOpcode) {
    if (!__gl_dispatchOverride) return;
    __gl_dispatch = __glDispatchCapture;
}

void __glsUpdateDispatchTables(void) {
    if (__GLS_CONTEXT && __GLS_CONTEXT->captureNesting) {
        __glXBeginDispatchOverride(&__glDispatchCapture);
    } else if (!__GLS_CONTEXT || !__GLS_CONTEXT->captureNesting) {
        __glXEndDispatchOverride();
    }
}

#include "g_irix.c"

#endif /* !__GLS_GL_DISPATCH */

#endif /* __GLS_PLATFORM_IRIX */

/******************************************************************************
LINUX
******************************************************************************/

#if __GLS_PLATFORM_LINUX

void __glsFinalDSO(void) __attribute__ ((destructor));
void __glsInitDSO(void) __attribute__ ((constructor));

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if __GLS_POSIX_THREADS
        __glsFinalPthreads();
    #endif /* __GLS_POSIX_THREADS */
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if __GLS_POSIX_THREADS
        __glsInitPthreads();
    #endif /* __GLS_POSIX_THREADS */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_LINUX */

/******************************************************************************
SOLARIS
******************************************************************************/

#if __GLS_PLATFORM_SOLARIS

#if !__GLS_FAKE_MUTEX

#include <synch.h>

static mutex_t __gls_lock;

void __glsBeginCriticalSection(void) {
    if (mutex_lock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: mutex_lock failed\n");
        exit(EXIT_FAILURE);
    }
}

void __glsEndCriticalSection(void) {
    if (mutex_unlock(&__gls_lock)) {
        fprintf(stderr, "GLS fatal: mutex_unlock failed\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE

#include <thread.h>

thread_key_t __gls_contextTLS;
thread_key_t __gls_errorTLS;

__GLScontext* __glsGetContext(void) {
    __GLScontext *outContext;

    thr_getspecific(__gls_contextTLS, (GLvoid **)&outContext);
    return outContext;
}

GLSenum __glsGetError(void) {
    GLvoid *outError;

    thr_getspecific(__gls_errorTLS, &outError);
    return (GLSenum)outError;
}

#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

#pragma fini(__glsFinalDSO)
#pragma init(__glsInitDSO)

void __glsFinalDSO(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if !__GLS_FAKE_MUTEX
        mutex_destroy(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
}

void __glsInitDSO(void) {
    #if __GLS_GL_DISPATCH_DSO
        __glsInitGLDispatch_DSO();
    #endif /* __GLS_GL_DISPATCH_DSO */
    #if !__GLS_FAKE_MUTEX
        if (mutex_init(&__gls_lock, USYNC_THREAD, GLS_NONE)) {
            fprintf(stderr, "GLS fatal: mutex_init failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        if (
            thr_keycreate(&__gls_contextTLS, GLS_NONE) ||
            thr_keycreate(&__gls_errorTLS, GLS_NONE)
        ) {
            fprintf(stderr, "GLS fatal: thr_keycreate failed\n");
            exit(EXIT_FAILURE);
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        exit(EXIT_FAILURE);
    }
}

#endif /* __GLS_PLATFORM_SOLARIS */

/******************************************************************************
WIN32
******************************************************************************/

#if __GLS_PLATFORM_WIN32

#include <string.h>
#include "g_win32.c"

#if !__GLS_FAKE_MUTEX

static CRITICAL_SECTION __gls_lock;

void __glsBeginCriticalSection(void) {
    EnterCriticalSection(&__gls_lock);
}

void __glsEndCriticalSection(void) {
    LeaveCriticalSection(&__gls_lock);
}

#endif /* !__GLS_FAKE_MUTEX */

#if !__GLS_FAKE_THREAD_LOCAL_STORAGE
    GLint __gls_contextTLS;
    GLint __gls_errorTLS;
#endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */

// DrewB
typedef PROC (APIENTRY *wglGetDefaultProcAddressFunc)(LPCSTR);

BOOL __glsDLLProcessAttach(void) {
    GLvoid *const dll = LoadLibrary(__GL_LIB_NAME);
    GLint i;
    GLSopcode op;
    // DrewB
    wglGetDefaultProcAddressFunc pfnGetDefaultProcAddress;

    if (!dll) {
        fprintf(
            stderr, "GLS fatal: LoadLibrary failed on %s\n", __GL_LIB_NAME
        );
        return GL_FALSE;
    }
    
    // DrewB
    pfnGetDefaultProcAddress = (wglGetDefaultProcAddressFunc)
        GetProcAddress(dll, "wglGetDefaultProcAddress");
    
    for (i = 0 ; op = __glsMapOpcode(__glsOpcodesGL[i]) ; ++i) {
        GLSfunc func;

        func = (GLSfunc) GetProcAddress(dll, __glsOpcodeString[op]);
        if (func == NULL)
        {
            func = (GLSfunc) pfnGetDefaultProcAddress(__glsOpcodeString[op]);
        }

        __glsDispatchExec[op] = func ? func : __glsNullCommandFuncs[op];
    }

    for (i = 0 ; i < __GLS_OPCODE_COUNT ; ++i) {
        if (__glsOpcodeAttrib[i] & __GLS_COMMAND_0_PARAMS_BIT) {
            __glsDispatchDecode_bin_default[i] =
                __glsDispatchDecode_bin_swap[i];
        }
    }
    
    #if !__GLS_FAKE_MUTEX
        __try 
        {
            InitializeCriticalSection(&__gls_lock);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return GL_FALSE;
        }
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        __gls_contextTLS = TlsAlloc();
        __gls_errorTLS = TlsAlloc();
        if (__gls_contextTLS == -1 || __gls_errorTLS == -1) {
            fprintf(stderr, "GLS fatal: TlsAlloc failed\n");
            return GL_FALSE;
        }
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    if (!__glsInitContextDict()) {
        fprintf(stderr, "GLS fatal: couldn't create __glsContextDict\n");
        return GL_FALSE;
    }
    return GL_TRUE;
}

BOOL __glsDLLProcessDetach(void) {
    __glsFinalContextDict();
    __glsParser_destroy(__glsParser);
    #if !__GLS_FAKE_MUTEX
        DeleteCriticalSection(&__gls_lock);
    #endif /* !__GLS_FAKE_MUTEX */
    #if !__GLS_FAKE_THREAD_LOCAL_STORAGE
        TlsFree(__gls_contextTLS);
        TlsFree(__gls_errorTLS);
    #endif /* !__GLS_FAKE_THREAD_LOCAL_STORAGE */
    return GL_TRUE;
}

BOOL DllMain(HINSTANCE hModule, DWORD inReason, LPVOID inReserved) {
    inReserved;
    switch (inReason) {
        case DLL_PROCESS_ATTACH:
            return __glsDLLProcessAttach();
        case DLL_PROCESS_DETACH:
            return __glsDLLProcessDetach();
    }
    return GL_TRUE;
}

GLlong __gls_strtoi64(const char *inStr, char **outPtr, int inBase) {
    GLlong outVal;

    inBase;
    if (sscanf(inStr, "%I64i", &outVal) == 1) {
        if (outPtr) *outPtr = (char *)inStr + strlen(inStr);
        return outVal;
    } else {
        if (outPtr) *outPtr = (char *)inStr;
        return 0;
    }
}

GLulong __gls_strtoui64(const char *inStr, char **outPtr, int inBase) {
    GLulong outVal;

    inBase;
    if (sscanf(inStr, "%I64i", &outVal) ==1) {
        if (outPtr) *outPtr = (char *)inStr + strlen(inStr);
        return outVal;
    } else {
        if (outPtr) *outPtr = (char *)inStr;
        return 0;
    }
}

GLSfunc glsNullCommandFunc(GLSopcode inOpcode) {
    if (!__glsValidateOpcode(inOpcode)) return GLS_NONE;
    return __glsNullCommandFuncs[__glsMapOpcode(inOpcode)];
}

#endif /* __GLS_PLATFORM_WIN32 */

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\readbin.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

#define __GLS_HEAD_LARGE_BYTES sizeof(__GLSbinCommandHead_large)

GLboolean __glsReader_call_bin(__GLSreader *inoutReader) {
    GLubyte *pc;
    GLubyte *pcNext;
    GLuint word;
    __GLSdecodeBinFunc *const dispatchDecode = (
        __GLS_CONTEXT->dispatchDecode_bin
    );
    GLubyte *pcLimit;

    if (
        inoutReader->readPtr + __GLS_HEAD_LARGE_BYTES > inoutReader->readTail &&
        !__glsReader_fillBuf(inoutReader, __GLS_HEAD_LARGE_BYTES, GL_TRUE)
    ) {
        __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
        return GL_FALSE;
    }
    pc = inoutReader->readPtr;
    pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
    for (;;) {
        if (word = *(GLuint *)pc) {
            pcNext = pc + (__GLS_COUNT_SMALL(word) << 2);
            word = __glsMapOpcode(__GLS_OP_SMALL(word));
            if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (__GLS_CONTEXT->abortMode) break;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)(pcNext - pc + __GLS_HEAD_LARGE_BYTES), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 4);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 4);
#endif
                pc = pcNext;
            }
        } else if (word = __GLS_HEAD_LARGE(pc)->opLarge) {
            word = __glsMapOpcode(word);

            pcNext = pc + (__GLS_HEAD_LARGE(pc)->countLarge << 2);
            if (word == GLS_OP_glsEndGLS) {
                inoutReader->readPtr = pcNext;
                return GL_TRUE;
            } else if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (__GLS_CONTEXT->abortMode) break;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)((ULONG_PTR)(pcNext - pc + __GLS_HEAD_LARGE_BYTES)), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 12);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 12);
#endif
                pc = pcNext;
            }
        } else {
            inoutReader->readPtr = pc;
            __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
            break;
        }
    }
    return GL_FALSE;
}

GLboolean __glsReader_call_bin_swap(__GLSreader *inoutReader) {
    GLubyte *pc;
    GLubyte *pcNext;
    GLuint word;
    const __GLSdecodeBinFunc *const dispatchDecode = (
        __glsDispatchDecode_bin_swap
    );
    GLubyte *pcLimit;

    if (
        inoutReader->readPtr + __GLS_HEAD_LARGE_BYTES > inoutReader->readTail &&
        !__glsReader_fillBuf(inoutReader, __GLS_HEAD_LARGE_BYTES, GL_TRUE)
    ) {
        __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
        return GL_FALSE;
    }
    pc = inoutReader->readPtr;
    pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
    for (;;) {
        if (__GLS_CONTEXT->abortMode) {
            inoutReader->readPtr = pc;
            break;
        } else if (*(GLuint *)pc) {
            __glsSwap2(pc);
            __glsSwap2(pc + 2);
            word = *(GLuint*)pc;
            pcNext = pc + (__GLS_COUNT_SMALL(word) << 2);
            word = __glsMapOpcode(__GLS_OP_SMALL(word));
            if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)((ULONG_PTR)(pcNext - pc + __GLS_HEAD_LARGE_BYTES)), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
                __glsSwap2(pc);
                __glsSwap2(pc + 2);
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 4);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 4);
#endif
                pc = pcNext;
            }
        } else if (__GLS_HEAD_LARGE(pc)->opLarge) {
            __glsSwap4(&__GLS_HEAD_LARGE(pc)->opLarge);
            __glsSwap4(&__GLS_HEAD_LARGE(pc)->countLarge);
            word = __glsMapOpcode(__GLS_HEAD_LARGE(pc)->opLarge);
            pcNext = pc + (__GLS_HEAD_LARGE(pc)->countLarge << 2);
            if (word == GLS_OP_glsEndGLS) {
                inoutReader->readPtr = pcNext;
                return GL_TRUE;
            } else if (pcNext > pcLimit) {
                inoutReader->readPtr = pc;
                if (!__glsReader_fillBuf(
                    inoutReader, (size_t)((ULONG_PTR)(pcNext - pc + __GLS_HEAD_LARGE_BYTES)), GL_TRUE
                )) {
                    __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                    break;
                }
                pc = inoutReader->readPtr;
                pcLimit = inoutReader->readTail - __GLS_HEAD_LARGE_BYTES;
                __glsSwap4(&__GLS_HEAD_LARGE(pc)->opLarge);
                __glsSwap4(&__GLS_HEAD_LARGE(pc)->countLarge);
            } else if (pcNext == pc) {
                inoutReader->readPtr = pc;
                __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
                break;
            } else if (!__glsOpcodeString[word]) {
                __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
                pc = pcNext;
            } else {
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                dispatchDecode[word](pc + 12);
#else
                dispatchDecode[word](__GLS_CONTEXT, pc + 12);
#endif
                pc = pcNext;
            }
        } else {
            inoutReader->readPtr = pc;
            __GLS_RAISE_ERROR(GLS_DECODE_ERROR);
            break;
        }
    }
    return GL_FALSE;
}

GLSenum __glsReader_readBeginGLS_bin(
    __GLSreader *inoutReader, __GLSversion *outVersion
) {
    if (__glsReader_fillBuf(
        inoutReader, sizeof(__GLSbinCommand_BeginGLS), GL_FALSE
    )) {
        const GLSenum outType = __glsBinCommand_BeginGLS_getType(
            (__GLSbinCommand_BeginGLS *)inoutReader->readPtr, outVersion
        );

        if (outType != GLS_NONE) {
            inoutReader->readPtr += sizeof(__GLSbinCommand_BeginGLS);
        }
        return outType;
    } else {
        return GLS_NONE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\readtxt.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <limits.h>
#include <locale.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>

/******************************************************************************
Helpers
******************************************************************************/

#define __GLS_BEGIN_PARAM(inoutReader) \
    if ( \
        inoutReader->error || \
        inoutReader->paramCount++ && \
        !__glsReader_getChar_text(inoutReader, ',', GL_TRUE) \
    ) { \
        return GL_FALSE; \
    }

#define __GLS_GET_TEXT(inType, inBase) \
    __GLS_GET_TEXT_VAL(inType, inBase) \
    __GLS_GET_TEXT_VEC(inType, inBase)

#define __GLS_GET_TEXT_VAL(inType, inBase) \
GLboolean __glsReader_get##inType##_text( \
    __GLSreader *inoutReader, inType *outVal \
) { \
    __GLSstring token; \
    __glsString_init(&token); \
    __GLS_BEGIN_PARAM(inoutReader); \
    if ( \
        __glsReader_getToken_text(inoutReader, &token) && \
        __glsTokenTo##inBase(token.head, outVal) \
    ) { \
        __glsString_final(&token); \
        return GL_TRUE; \
    } else { \
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR); \
        __glsString_final(&token); \
        return GL_FALSE; \
    } \
}

#define __GLS_GET_TEXT_VEC(inType, inBase) \
GLboolean __glsReader_get##inType##v_text( \
    __GLSreader *inoutReader, GLuint inCount, inType *outVec \
) { \
    __GLSstring token; \
    __GLS_BEGIN_PARAM(inoutReader); \
    if (!__glsReader_getChar_text(inoutReader, '{', GL_TRUE)) { \
        return GL_FALSE; \
    } \
    __glsString_init(&token); \
    while (inCount-- > 0) if ( \
        !__glsReader_getToken_text(inoutReader, &token) || \
        !__glsTokenTo##inBase(token.head, outVec++) || \
        inCount > 0 && !__glsReader_getChar_text(inoutReader, ',', GL_TRUE) \
    ) { \
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR); \
        __glsString_final(&token); \
        return GL_FALSE; \
    } \
    __glsString_final(&token); \
    __glsReader_getChar_text(inoutReader, ',', GL_FALSE); \
    if (!__glsReader_getChar_text(inoutReader, '}', GL_TRUE)) { \
        return GL_FALSE; \
    } \
    return GL_TRUE; \
}

#define __GLS_READER_APPEND_CHAR(inoutReader, inoutString, inChar) \
    if (!__glsString_appendChar(inoutString, inChar)) { \
        __glsReader_raiseError(inoutReader, GLS_OUT_OF_MEMORY); \
        return GL_FALSE; \
    }

/******************************************************************************
Token converters
******************************************************************************/

__GLS_FORWARD static GLboolean __glsTokenToGLulong(
    const GLubyte *inToken, GLulong *outVal
);
__GLS_FORWARD static GLboolean __glsTokenToGLuint(
    const GLubyte *inToken, GLuint *outVal
);

static GLubyte __glsQuotedChar(const GLubyte *inToken, GLubyte **outPtr) {
    if (
        inToken[0] == '\''&&
        inToken[2] == '\'' &&
        !inToken[3] &&
        __GLS_CHAR_IS_GRAPHIC(inToken[1])
    ) {
        if (outPtr) *outPtr = (GLubyte *)inToken + 3;
        return inToken[1];
    } else {
        if (outPtr) *outPtr = (GLubyte *)inToken;
        return 0;
    }
}

static GLboolean __glsTokenToGLboolean(
    const GLubyte *inToken, GLboolean *outVal
) {
    GLubyte *ptr;
    unsigned long val;
    
    if (!strcmp((const char *)inToken, "GL_FALSE")) {
        *outVal = GL_FALSE;
        return GL_TRUE;
    } else if (!strcmp((const char *)inToken, "GL_TRUE")) {
        *outVal = GL_TRUE;
        return GL_TRUE;
    }
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    *outVal = (GLboolean)val;
    return (GLboolean)(!*ptr && val <= UCHAR_MAX);
}

static GLboolean __glsTokenToGLbyte(const GLubyte *inToken, GLbyte *outVal) {
    GLubyte *ptr;
    long val;
    
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLbyte)val;
    return (GLboolean)(!*ptr && val >= SCHAR_MIN && val <= SCHAR_MAX);
}

static GLboolean __glsTokenToGLdouble(
    const GLubyte *inToken, GLdouble *outVal
) {
    GLubyte *ptr;
    GLdouble sign;
    __GLS_C_LOCALE_DECLARE;

    __GLS_PUT_ERRNO(0);
    __GLS_C_LOCALE_BEGIN;
    *outVal = strtod((const char *)inToken, (char **)&ptr);
    __GLS_C_LOCALE_END;
    if (!*ptr) return (GLboolean)(__GLS_ERRNO != ERANGE);
    if (
        inToken[0] == '0' && __glsTokenToGLulong(inToken, (GLulong *)outVal)
    ) {
        return GL_TRUE;
    }
    if (!strcmp((const char *)inToken, "nan")) {
        *outVal = *(const GLdouble *)__glsQuietNaN;
        return GL_TRUE;
    }
    sign = 1.;
    if (*inToken == '-') {
        sign = -1.;
        ++inToken;
    } else if (*inToken == '+') {
        ++inToken;
    }
    if (!strcmp((const char *)inToken, "inf")) {
        *outVal = sign * HUGE_VAL;
        return GL_TRUE;
    }
    {
        GLint intVal;
        if (
            __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
            __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
        ) {
            *outVal = (GLdouble)intVal;
            return GL_TRUE;
        }
    }
    return GL_FALSE;
}

static GLboolean __glsTokenToGLfloat(
    const GLubyte *inToken, GLfloat *outVal
) {
    GLdouble doubleVal;
    GLubyte *ptr;
    GLdouble sign;
    __GLS_C_LOCALE_DECLARE;

    __GLS_PUT_ERRNO(0);
    __GLS_C_LOCALE_BEGIN;
    doubleVal = strtod((const char *)inToken, (char **)&ptr);
    *outVal = (GLfloat)doubleVal;
    __GLS_C_LOCALE_END;
    if (doubleVal < 0.) doubleVal = -doubleVal;
    if (!*ptr) return (GLboolean)(
        __GLS_ERRNO != ERANGE &&
        (
            !doubleVal ||
            doubleVal >= (GLdouble)FLT_MIN && doubleVal <= (GLdouble)FLT_MAX
        )
    );
    if (
        inToken[0] == '0' && __glsTokenToGLuint(inToken, (GLuint *)outVal)
    ) {
        return GL_TRUE;
    }
    if (!strcmp((const char *)inToken, "nan")) {
        *outVal = *(const GLfloat *)__glsQuietNaN;
        return GL_TRUE;
    }
    sign = 1.;
    if (*inToken == '-') {
        sign = -1.;
        ++inToken;
    } else if (*inToken == '+') {
        ++inToken;
    }
    if (!strcmp((const char *)inToken, "inf")) {
        *outVal = (GLfloat)(sign * HUGE_VAL);
        return GL_TRUE;
    }
    {
        GLint intVal;
        if (
            __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
            __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
        ) {
            *outVal = (GLfloat)intVal;
            return GL_TRUE;
        }
    }
    return GL_FALSE;
}

static GLboolean __glsTokenToGLint(const GLubyte *inToken, GLint *outVal) {
    GLubyte *ptr;
    long val;
    
    __GLS_PUT_ERRNO(0);
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        val = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) {
        *outVal = (GLint)val;
        return (GLboolean)(
            __GLS_ERRNO != ERANGE && val >= INT_MIN && val <= INT_MAX
        );
    }
    return (GLboolean)(
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, outVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, outVal)
    );
}

#if defined(__GLS_STR_TO_INT64)

static GLboolean __glsTokenToGLlong(const GLubyte *inToken, GLlong *outVal) {
    GLint intVal;
    GLubyte *ptr;
    
    __GLS_PUT_ERRNO(0);
    *outVal = __GLS_STR_TO_INT64((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        *outVal = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) return (GLboolean)(__GLS_ERRNO != ERANGE);
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = intVal;
        return GL_TRUE;
    }
    return GL_FALSE;
}

#else /* !defined(__GLS_STR_TO_INT64) */

static GLboolean __glsTokenToGLlong(const GLubyte *inToken, GLlong *outVal) {
    GLubyte *ptr;
    GLint intVal;
    long val;
    
    if (
        inToken[0] == '0' &&
        (inToken[1] == 'x' || inToken[1] == 'X') &&
        strlen((const char *)inToken) == 18
    ) {
        GLint high;
        GLuint low;
        __GLSstringBuf strBuf;

        strcpy((char *)strBuf, (const char *)inToken);
        strBuf[10] = 0;
        high = (GLint)strtol((const char *)strBuf, (char **)&ptr, 0);
        if (*ptr) return GL_FALSE;
        strcpy((char *)(strBuf + 2), (const char *)(inToken + 10));
        low = (GLuint)strtoul((const char *)strBuf, (char **)&ptr, 0);
        *outVal = glsLong(high, low);
        return !*ptr;
    }
    __GLS_PUT_ERRNO(0);
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (!*ptr) {
        *outVal = glsLong((val & 0x80000000) ? -1 : 0, (GLuint)val);
        return __GLS_ERRNO != ERANGE && val >= INT_MIN && val <= INT_MAX;
    }
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = glsLong(0, intVal);
        return GL_TRUE;
    }
    *outVal = glsLong(0, __glsQuotedChar(inToken, &ptr));
    return !*ptr;
}

#endif /* defined(__GLS_STR_TO_INT64) */

static GLboolean __glsTokenToGLshort(const GLubyte *inToken, GLshort *outVal) {
    GLubyte *ptr;
    long val;
    
    val = strtol((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLshort)val;
    return (GLboolean)(!*ptr && val >= SHRT_MIN && val <= SHRT_MAX);
}

static GLboolean __glsTokenToGLubyte(const GLubyte *inToken, GLubyte *outVal) {
    GLubyte *ptr;
    unsigned long val;
    
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLubyte)val;
    return (GLboolean)(!*ptr && val <= UCHAR_MAX);
}

static GLboolean __glsTokenToGLuint(const GLubyte *inToken, GLuint *outVal) {
    GLubyte *ptr;
    unsigned long val;
    
    __GLS_PUT_ERRNO(0);
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        val = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) {
        *outVal = (GLuint)val;
        return (GLboolean)(__GLS_ERRNO != ERANGE && val <= UINT_MAX);
    }
    return (GLboolean)(
        __glsStr2IntDict_find(
            __glsParser->glEnumDict, inToken, (GLint *)outVal
        ) ||
        __glsStr2IntDict_find(
            __glsParser->glsEnumDict, inToken, (GLint *)outVal
        )
    );
}

#if defined(__GLS_STR_TO_INT64U)

static GLboolean __glsTokenToGLulong(
    const GLubyte *inToken, GLulong *outVal
) {
    GLint intVal;
    GLubyte *ptr;
    
    __GLS_PUT_ERRNO(0);
    *outVal = __GLS_STR_TO_INT64U((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) {
        __GLS_PUT_ERRNO(0);
        *outVal = __glsQuotedChar(inToken, &ptr);
    }
    if (!*ptr) return (GLboolean)(__GLS_ERRNO != ERANGE);
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = intVal;
        return GL_TRUE;
    }
    return GL_FALSE;
}

#else /* !defined(__GLS_STR_TO_INT64U) */

static GLboolean __glsTokenToGLulong(const GLubyte *inToken, GLulong *outVal) {
    GLubyte *ptr;
    GLint intVal;
    unsigned long val;
    
    if (
        inToken[0] == '0' &&
        (inToken[1] == 'x' || inToken[1] == 'X') &&
        strlen((const char *)inToken) == 18
    ) {
        GLuint high, low;
        __GLSstringBuf strBuf;

        strcpy((char *)strBuf, (const char *)inToken);
        strBuf[10] = 0;
        high = (GLuint)strtoul((const char *)strBuf, (char **)&ptr, 0);
        if (*ptr) return GL_FALSE;
        strcpy((char *)(strBuf + 2), (const char *)(inToken + 10));
        low = (GLuint)strtoul((const char *)strBuf, (char **)&ptr, 0);
        *outVal = glsULong(high, low);
        return !*ptr;
    }
    __GLS_PUT_ERRNO(0);
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (!*ptr) {
        *outVal = glsULong(0, (GLuint)val);
        return __GLS_ERRNO != ERANGE && val <= UINT_MAX;
    }
    if (
        __glsStr2IntDict_find(__glsParser->glEnumDict, inToken, &intVal) ||
        __glsStr2IntDict_find(__glsParser->glsEnumDict, inToken, &intVal)
    ) {
        *outVal = glsULong(0, intVal);
        return GL_TRUE;
    }
    *outVal = glsULong(0, __glsQuotedChar(inToken, &ptr));
    return !*ptr;
}

#endif /* defined(__GLS_STR_TO_INT64U) */

static GLboolean __glsTokenToGLushort(
    const GLubyte *inToken, GLushort *outVal
) {
    GLubyte *ptr;
    unsigned long val;
    
    val = strtoul((const char *)inToken, (char **)&ptr, 0);
    if (*ptr) val = __glsQuotedChar(inToken, &ptr);
    *outVal = (GLushort)val;
    return (GLboolean)(!*ptr && val <= USHRT_MAX);
}

/******************************************************************************
Private readers
******************************************************************************/

__GLS_FORWARD static GLboolean __glsReader_getChar_text(
    __GLSreader *inoutReader, GLubyte inChar, GLboolean inRequired
);

__GLS_FORWARD static GLboolean __glsReader_getToken_text(
    __GLSreader *inoutReader, __GLSstring *outToken
);

static GLboolean __glsReader_getBitfield_text(
    __GLSreader *inoutReader, const __GLSdict *inDict, GLbitfield *outBits
) {
    __GLSstring token;
    GLbitfield val = 0;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    *outBits = GLS_NONE;
    while (__glsReader_getToken_text(inoutReader, &token)) {
        if (
            __glsStr2IntDict_find(inDict, token.head, (GLint *)&val) ||
            __glsTokenToGLuint(token.head, &val)
        ) {
            *outBits |= val;
        } else {
            __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
            __glsString_final(&token);
            return GL_FALSE;
        }
        if (!__glsReader_getChar_text(inoutReader, '|', GL_FALSE)) {
            __glsString_final(&token);
            return GL_TRUE;
        }
    }
    __glsString_final(&token);
    return GL_FALSE;
}

static GLboolean __glsReader_getChar_text(
    __GLSreader *inoutReader, GLubyte inChar, GLboolean inRequired
) {
    GLubyte readChar;

    __GLS_GET_SPACE(inoutReader);
    __GLS_READ_CHAR(inoutReader, readChar);
    if (readChar != inChar) {
        __GLS_UNREAD_CHAR(inoutReader);
        if (inRequired) __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
    }
    return (GLboolean)(readChar == inChar);
}

static GLboolean __glsReader_getEnum_text(
    __GLSreader *inoutReader, const __GLSdict *inDict, GLuint *outVal
) {
    __GLSstring token;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    if (
        __glsReader_getToken_text(inoutReader, &token) &&
        (
            __glsStr2IntDict_find(inDict, token.head, (GLint *)outVal) ||
            __glsTokenToGLuint(token.head, outVal)
        )
    ) {
        __glsString_final(&token);
        return GL_TRUE;
    } else {
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
        __glsString_final(&token);
        return GL_FALSE;
    }
}

static GLboolean __glsReader_getIntOrEnum_text(
    __GLSreader *inoutReader, const __GLSdict *inDict, GLint *outVal
) {
    __GLSstring token;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    if (
        __glsReader_getToken_text(inoutReader, &token) &&
        (
            __glsTokenToGLint(token.head, outVal) ||
            __glsStr2IntDict_find(inDict, token.head, outVal)
        )
    ) {
        __glsString_final(&token);
        return GL_TRUE;
    } else {
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
        __glsString_final(&token);
        return GL_FALSE;
    }
}

static GLboolean __glsReader_getToken_text(
    __GLSreader *inoutReader, __GLSstring *outToken
) {
    GLint count = 0;
    GLubyte readChar;

    __GLS_GET_SPACE(inoutReader);
    __glsString_reset(outToken);
    for (;;) {
        __GLS_READ_CHAR(inoutReader, readChar);
        if (__GLS_CHAR_IS_TOKEN(readChar)) {
            __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
            ++count;
        } else if (!count && readChar == '\'') {
            __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
            __GLS_READ_CHAR(inoutReader, readChar);
            if (__GLS_CHAR_IS_GRAPHIC(readChar)) {
                __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
            } else {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                break;
            }
            __GLS_READ_CHAR(inoutReader, readChar);
            if (readChar == '\'') {
                __GLS_READER_APPEND_CHAR(inoutReader, outToken, readChar);
                return GL_TRUE;
            } else {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                break;
            }
        } else {
            __GLS_UNREAD_CHAR(inoutReader);
            if (count && count < __GLS_STRING_BUF_BYTES - 1) {
                return GL_TRUE;
            } else {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                break;
            }
        }
    }
    return GL_FALSE;
}

/******************************************************************************
Public functions
******************************************************************************/

GLboolean __glsReader_abortCommand_text(__GLSreader *inoutReader) {
    GLubyte prevChar = 0;
    GLubyte readChar;
    GLboolean string = GL_FALSE;

    for (;;) {
        if (
            inoutReader->readPtr >= inoutReader->readTail &&
            !__glsReader_fillBuf(inoutReader, 1, GL_FALSE)
        ) {
            break;
        }
        readChar = *inoutReader->readPtr++;
        if (readChar == '"') {
            if (string) {
                if (prevChar != '\\') string = GL_FALSE;
            } else {
                string = GL_TRUE;
            }
        }
        if (readChar == ';' && !string) return GL_TRUE;
        prevChar = readChar;
    }
    return GL_FALSE;
}

GLboolean __glsReader_beginCommand_text(
    __GLSreader *inoutReader, __GLSstring *outCommand
) {
    inoutReader->error = GLS_NONE;
    inoutReader->paramCount = 0;
    return (GLboolean)(
        __glsReader_getToken_text(inoutReader, outCommand) &&
        __glsReader_getChar_text(inoutReader, '(', GL_TRUE)
    );
}

GLboolean __glsReader_call_text(__GLSreader *inoutReader) {
    __GLSstring command;
    GLSopcode opcode;

    if (!__glsParser) {
        __glsBeginCriticalSection();
        if (!__glsParser) __glsParser = __glsParser_create();
        __glsEndCriticalSection();
        if (!__glsParser) {
            __GLS_RAISE_ERROR(GLS_OUT_OF_MEMORY);
            return GL_FALSE;
        }
    }
    __glsString_init(&command);
    for (;;) {
        if (__GLS_CONTEXT->abortMode) {
            __glsString_final(&command);
            break;
        }
        if (__glsReader_beginCommand_text(inoutReader, &command)) {
            if (__glsParser_findCommand(__glsParser, command.head, &opcode)) {
                if (opcode == GLS_OP_glsEndGLS) {
                    if (__glsReader_endCommand_text(inoutReader)) {
                        __glsString_final(&command);
                        return GL_TRUE;
                    } else {
                        __GLS_CALL_ERROR(__GLS_CONTEXT, opcode, GLS_DECODE_ERROR);
                        __glsString_final(&command);
                        return __glsReader_abortCommand_text(inoutReader);
                    }
                }
#ifndef __GLS_PLATFORM_WIN32
                // DrewB
                __glsDispatchDecode_text[__glsMapOpcode(opcode)](inoutReader);
#else
                __glsDispatchDecode_text[__glsMapOpcode(opcode)](__GLS_CONTEXT,
                                                                 inoutReader);
#endif
                __glsReader_endCommand_text(inoutReader);
                if (inoutReader->error) {
                    __GLS_CALL_ERROR(__GLS_CONTEXT, opcode, inoutReader->error);
                    if (!__glsReader_abortCommand_text(inoutReader)) {
                        __glsString_final(&command);
                        break;
                    }
                }
            } else {
                if (!__glsReader_abortCommand_text(inoutReader)) {
                    __glsString_final(&command);
                    break;
                }
            }
        } else {
            __GLS_CALL_UNSUPPORTED_COMMAND(__GLS_CONTEXT);
            if (!__glsReader_abortCommand_text(inoutReader)) {
                __glsString_final(&command);
                break;
            }
        }
    }
    return GL_FALSE;
}

GLboolean __glsReader_endCommand_text(__GLSreader *inoutReader) {
    return (GLboolean)(
        !inoutReader->error &&
        __glsReader_getChar_text(inoutReader, ')', GL_TRUE) &&
        __glsReader_getChar_text(inoutReader, ';', GL_TRUE)
    );
}

GLboolean __glsReader_getGLSenum_text(
    __GLSreader *inoutReader, GLSenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glsEnumDict, outVal
    );
}

GLboolean __glsReader_getGLSimageFlags_text(
    __GLSreader *inoutReader, GLbitfield *outVal
) {
    return __glsReader_getBitfield_text(
        inoutReader, __glsParser->glsImageFlagsDict, outVal
    );
}

GLboolean __glsReader_getGLSopcode_text(
    __GLSreader *inoutReader, GLSopcode *outVal
) {
    __GLSstring token;

    __glsString_init(&token);
    __GLS_BEGIN_PARAM(inoutReader);
    if (
        __glsReader_getToken_text(inoutReader, &token) &&
        (
            !strncmp((const char *)token.head, "GLS_OP_", 7) &&
            __glsStr2IntDict_find(
                __glsParser->glsOpDict,
                token.head + 7,
                (GLint *)outVal
            ) ||
            __glsTokenToGLuint(token.head, outVal)
        )
    ) {
        __glsString_final(&token);
        return GL_TRUE;
    } else {
        __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
        __glsString_final(&token);
        return GL_FALSE;
    }
}

GLboolean __glsReader_getGLattribMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
) {
    return __glsReader_getBitfield_text(
        inoutReader, __glsParser->glAttribMaskDict, outVal
    );
}

GLboolean __glsReader_getGLblendingFactor_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

__GLS_GET_TEXT(GLboolean, GLboolean)
__GLS_GET_TEXT(GLbyte, GLbyte)

GLboolean __glsReader_getGLcharv_text(
    __GLSreader *inoutReader, __GLSstring *outString
) {
    GLint hexCount = -1;
    GLboolean outVal = GL_TRUE;
    GLubyte prevChar = 0;
    GLubyte readChar;

    __GLS_BEGIN_PARAM(inoutReader);
    if (!__glsReader_getChar_text(inoutReader, '"', GL_TRUE)) return GL_FALSE;
    __glsString_reset(outString);
    for (;;) {
        __GLS_READ_CHAR(inoutReader, readChar);
        if (!readChar) {
            __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
            break;
        } else if (hexCount >= 0) {
            if (!isxdigit(readChar)) {
                __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                outVal = GL_FALSE;
                hexCount = -1;
            } else if (++hexCount == 2) {
                GLubyte buf[3];

                buf[0] = prevChar;
                buf[1] = readChar;
                buf[2] = 0;
                readChar = (GLubyte)strtoul((const char *)buf, GLS_NONE, 16);
                __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
                hexCount = -1;
            }
        } else if (readChar == '\\') {
            if (prevChar == '\\') {
                __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
                readChar = 0;
            }
        } else if (readChar == '"') {
            if (prevChar == '\\') {
                __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
            } else if (__glsReader_getChar_text(inoutReader, '"', GL_FALSE)) {
                continue;
            } else {
                if (outVal && !glsIsUTF8String(outString->head)) {
                    __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
                    outVal = GL_FALSE;
                }
                return outVal;
            }
        } else if (readChar == 'x' && prevChar == '\\') {
            hexCount = 0;
        } else if (!__GLS_CHAR_IS_GRAPHIC(readChar) || prevChar == '\\') {
            __glsReader_raiseError(inoutReader, GLS_DECODE_ERROR);
            outVal = GL_FALSE;
        } else {
            __GLS_READER_APPEND_CHAR(inoutReader, outString, readChar);
        }
        prevChar = readChar;
    }
    return GL_FALSE;
}

GLboolean __glsReader_getGLclearBufferMask_text(
    __GLSreader *inoutReader, GLbitfield *outVal
) {
    return __glsReader_getBitfield_text(
        inoutReader, __glsParser->glAttribMaskDict, outVal
    );
}

GLboolean __glsReader_getGLcompv_text(
    __GLSreader *inoutReader, GLenum inType, GLuint inBytes, GLvoid *outVec
) {
    switch (inType) {
        case __GLS_BOOLEAN:
            return __glsReader_getGLbooleanv_text(
                inoutReader, inBytes, (GLboolean *)outVec
            );
        case GL_BITMAP:
            return __glsReader_getGLubytev_text(
                inoutReader, (inBytes + 7) / 8, (GLubyte *)outVec
            );
        case GL_BYTE:
            return __glsReader_getGLbytev_text(
                inoutReader, inBytes, (GLbyte *)outVec
            );
        case GL_FLOAT:
            return __glsReader_getGLfloatv_text(
                inoutReader, inBytes / 4, (GLfloat *)outVec
            );
        case GL_INT:
            return __glsReader_getGLintv_text(
                inoutReader, inBytes / 4, (GLint *)outVec
            );
        case GL_SHORT:
            return __glsReader_getGLshortv_text(
                inoutReader, inBytes / 2, (GLshort *)outVec
            );
        case GL_2_BYTES:
        case GL_3_BYTES:
        case GL_4_BYTES:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return __glsReader_getGLubytev_text(
                inoutReader, inBytes, (GLubyte *)outVec
            );
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return __glsReader_getGLuintv_text(
                inoutReader, inBytes / 4, (GLuint *)outVec
            );
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return __glsReader_getGLushortv_text(
                inoutReader, inBytes / 2, (GLushort *)outVec
            );
        #if __GL_EXT_vertex_array
            case GL_DOUBLE_EXT:
                return __glsReader_getGLdoublev_text(
                    inoutReader, inBytes / 8, (GLdouble *)outVec
                );
        #endif /* __GL_EXT_vertex_array */
        default:
            return __glsReader_getGLbytev_text(inoutReader, 0, GLS_NONE);
    }
}

__GLS_GET_TEXT(GLdouble, GLdouble)

GLboolean __glsReader_getGLdrawBufferMode_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

GLboolean __glsReader_getGLenum_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

__GLS_GET_TEXT(GLfloat, GLfloat)
__GLS_GET_TEXT(GLint, GLint)
__GLS_GET_TEXT(GLlong, GLlong)
__GLS_GET_TEXT(GLshort, GLshort)

GLboolean __glsReader_getGLstencilOp_text(
    __GLSreader *inoutReader, GLenum *outVal
) {
    return __glsReader_getEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

GLboolean __glsReader_getGLtextureComponentCount_text(
    __GLSreader *inoutReader, GLint *outVal
) {
    return __glsReader_getIntOrEnum_text(
        inoutReader, __glsParser->glEnumDict, outVal
    );
}

__GLS_GET_TEXT(GLubyte, GLubyte)
__GLS_GET_TEXT(GLuint, GLuint)
__GLS_GET_TEXT(GLulong, GLulong)
__GLS_GET_TEXT(GLushort, GLushort)

GLboolean __glsReader_nextList_text(__GLSreader *inoutReader) {
    inoutReader->paramCount = 0;
    return (GLboolean)(
        !inoutReader->error &&
        __glsReader_getChar_text(inoutReader, ')', GL_TRUE) &&
        __glsReader_getChar_text(inoutReader, '(', GL_TRUE)
    );
}

GLSenum __glsReader_readBeginGLS_text(
    __GLSreader *inoutReader, __GLSversion *outVersion
) {
    __GLSstring beginGLS;
    __GLSversion version;

    __glsString_init(&beginGLS);
    if (
        __glsReader_beginCommand_text(inoutReader, &beginGLS) &&
        !strcmp((const char *)beginGLS.head, "glsBeginGLS") &&
        __glsReader_getGLint_text(inoutReader, &version.major) &&
        __glsReader_getGLint_text(inoutReader, &version.minor) &&
        __glsReader_endCommand_text(inoutReader) &&
        (!version.major || version.major == __GLS_VERSION_MAJOR)
    ) {
        __glsString_final(&beginGLS);
        *outVersion = version;
        return GLS_TEXT;
    } else {
        __glsString_final(&beginGLS);
        return GLS_NONE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\write.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"
#include <stdlib.h>

/******************************************************************************
__GLSwriteStream
******************************************************************************/

__GLSwriteStream* __glsWriteStream_create(
    const GLubyte *inName, GLboolean inAppend
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLSwriteStream *const outStream = __glsCalloc(
        1, sizeof(__GLSwriteStream)
    );

    if (!outStream) return GLS_NONE;
    __glsString_init(&outStream->name);
    if (inName[0]) {
        const GLubyte *openName;

        if (
            !__glsListString_prefix(
                ctx->writePrefix, inName, &outStream->name
            ) ||
            !(openName = __glsUCS1String(outStream->name.head))
        ) {
            return __glsWriteStream_destroy(outStream);
        }
        if (outStream->channel = fopen((const char *)openName, "rb")) {
            fclose(outStream->channel);
        } else {
            outStream->created = GL_TRUE;
        }
        outStream->channel = fopen(
            (const char *)openName, inAppend ? "ab" : "wb"
        );
        if (openName != outStream->name.head) free((GLvoid *)openName);
        if (outStream->channel) {
            setbuf(outStream->channel, GLS_NONE);
            outStream->opened = GL_TRUE;
            return outStream;
        }
        __GLS_RAISE_ERROR(GLS_STREAM_OPEN_ERROR);
        return __glsWriteStream_destroy(outStream);
    } else {
        outStream->writeFunc = ctx->writeFunc;
        if (!outStream->writeFunc) {
            outStream->channel = ctx->defaultWriteChannel;
        }
        return outStream;
    }
}

__GLSwriteStream* __glsWriteStream_destroy(__GLSwriteStream *inStream) {
    if (!inStream) return GLS_NONE;

    if (inStream->opened && fclose(inStream->channel)) {
        __GLS_RAISE_ERROR(GLS_STREAM_CLOSE_ERROR);
    }
    __glsString_final(&inStream->name);
    free(inStream);
    return GLS_NONE;
}

size_t __glsWriteStream_getByteCount(const __GLSwriteStream *inStream) {
    fpos_t pos;

    if (!inStream->channel) return 0;
    if (
        !fgetpos(inStream->channel, &pos) &&
        !fseek(inStream->channel, 0, SEEK_END)
    ) {
        const long outVal = ftell(inStream->channel);

        fsetpos(inStream->channel, &pos);
        return outVal >= 0 ? (size_t)outVal : 0;
    } else {
        return 0;
    }
}

/******************************************************************************
__GLSwriter
******************************************************************************/

static const GLvoid* __glsPixelBase(
    GLenum inType,
    GLint inGroupElems,
    GLint inStrideElems,
    const __GLSpixelStoreConfig *inConfig,
    const GLvoid *inPixels
) {
    GLint skipRows = inConfig->skipRows;

    #if __GL_EXT_texture3D
        skipRows += inConfig->skipImages * inConfig->imageHeight;
    #endif /* __GL_EXT_texture3D */
    #if __GL_SGIS_texture4D
        skipRows += (
            inConfig->skipVolumes *
            inConfig->imageDepth *
            inConfig->imageHeight
        );
    #endif /* __GL_SGIS_texture4D */
    switch (inType) {
        case GL_BITMAP:
            return (
                (const GLubyte *)inPixels +
                skipRows * inStrideElems / 8 +
                inConfig->skipPixels * inGroupElems / 8
            );
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return (
                (const GLbyte *)inPixels +
                skipRows * inStrideElems +
                inConfig->skipPixels * inGroupElems
            );
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return (
                (const GLshort *)inPixels +
                skipRows * inStrideElems +
                inConfig->skipPixels * inGroupElems
            );
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            return (
                (const GLint *)inPixels +
                skipRows * inStrideElems +
                inConfig->skipPixels * inGroupElems
            );
        default:
            return inPixels;
    }
}

static GLint __glsPixelStrideElems(
    GLenum inType,
    GLint inGroupElems,
    GLint inWidth,
    const __GLSpixelStoreConfig *inConfig
) {
    const GLint align = inConfig->alignment;
    GLint elemLog, padBytes, strideBytes;
    const GLint strideElems = (
        inGroupElems * (inConfig->rowLength ? inConfig->rowLength : inWidth)
    );

    switch (inType) {
        case GL_BITMAP:
            strideBytes = (strideElems + 7) >> 3;
            if (padBytes = strideBytes & align - 1) {
                strideBytes += align - padBytes;
            }
            return strideBytes << 3;
        case GL_BYTE:
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            elemLog = 0;
            break;
        case GL_SHORT:
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            elemLog = 1;
            break;
        case GL_FLOAT:
        case GL_INT:
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            elemLog = 2;
            break;
        default:
            return 0;
    }
    strideBytes = strideElems << elemLog;
    if (padBytes = strideBytes & align - 1) {
        return (strideBytes + align - padBytes) >> elemLog;
    } else {
        return strideElems;
    }
}

static __GLSwriter* __glsWriter_create_context(
    const GLubyte *inStreamName, GLbitfield inWriteFlags
) {
    __GLScontext *const ctx = __GLS_CONTEXT;
    __GLScontextStreamBlock *block;
    __GLSwriter *outWriter = GLS_NONE;
    __GLScontextStream *stream = GLS_NONE;

    if (stream = __glsStr2PtrDict_find(ctx->contextStreamDict, inStreamName)) {
        GLint i;

        for (i = 0 ; i < ctx->captureNesting ; ++i) {
            if (ctx->writers[i]->contextStream == stream) {
                __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
                return GLS_NONE;
            }
        }
        if (stream->callCount) {
            __GLS_RAISE_ERROR(GLS_INVALID_OPERATION);
            return GLS_NONE;
        }
        outWriter = __glsCalloc(1, sizeof(__GLSwriter));
        if (!outWriter) return GLS_NONE;

        if (!(inWriteFlags & GLS_WRITE_APPEND_BIT)) {
            __glsContextStream_truncate(
                stream, __glsContextStream_firstBlock(stream), 0
            );
        }
    } else {
        if (
            !(outWriter = __glsCalloc(1, sizeof(__GLSwriter))) ||
            !(stream = __glsContextStream_create(inStreamName)) ||
            !__glsStr2PtrDict_add(ctx->contextStreamDict, inStreamName, stream)
        ) {
            __glsContextStream_destroy(stream);
            return __glsWriter_destroy(outWriter);
        }
        __GLS_ITERLIST_APPEND(&ctx->contextStreamList, stream);
        outWriter->contextCreated = GL_TRUE;
    }
    block = __glsContextStream_lastBlock(stream);
    __glsContextStreamBlock_removeJump(block);
    outWriter->bufPtr = block->writeTail;
    outWriter->bufTail = block->bufTail - __GLS_JUMP_ALLOC;
    outWriter->startBlock = block;
    outWriter->startOffset = (size_t)((ULONG_PTR)(block->writeTail - block->buf));
    outWriter->contextStream = stream;
    __glsWriter_initDispatch_bin(outWriter, GLS_CONTEXT);
    outWriter->type = GLS_CONTEXT;
    return outWriter;
}

static __GLSwriter* __glsWriter_create_extern(
    const GLubyte *inStreamName, GLSenum inStreamType, GLbitfield inWriteFlags
) {
    __GLSwriter *outWriter;

    outWriter = __glsCalloc(1, sizeof(__GLSwriter));
    if (!outWriter) return GLS_NONE;
    outWriter->externStream = __glsWriteStream_create(
        inStreamName,
        (GLboolean)(inWriteFlags & GLS_WRITE_APPEND_BIT ? GL_TRUE : GL_FALSE)
    );
    if (!outWriter->externStream) return __glsWriter_destroy(outWriter);
    outWriter->startOffset = __glsWriteStream_getByteCount(
        outWriter->externStream
    );
    outWriter->externBuf = outWriter->externBufHead = __glsMalloc(
        __GLS_WRITER_EXTERN_BUF_BYTES
    );
    if (!outWriter->externBuf) return __glsWriter_destroy(outWriter);
    outWriter->bufPtr = outWriter->externBufHead;
    /*
    ** bufTail is moved back from actual buffer tail to streamline ALLOC
    ** check for GLS_TEXT parameter writing.
    */
    outWriter->bufTail = (
        outWriter->externBufHead +
        __GLS_WRITER_EXTERN_BUF_BYTES -
        __GLS_WRITER_EXTERN_BUF_SLOP
    );
    if (inStreamType == GLS_TEXT) {
        __glsWriter_initDispatch_text(outWriter);
    } else {
        __glsWriter_initDispatch_bin(outWriter, inStreamType);
    }
    outWriter->type = inStreamType;
    return outWriter;
}

__GLSwriter* __glsWriter_create(
    const GLubyte *inStreamName, GLSenum inStreamType, GLbitfield inWriteFlags
) {
    __GLSwriter *outWriter;

    if (inStreamType == GLS_CONTEXT) {
        outWriter = __glsWriter_create_context(inStreamName, inWriteFlags);
    } else {
        outWriter = __glsWriter_create_extern(
            inStreamName, inStreamType, inWriteFlags
        );
    }
    if (outWriter) {
        outWriter->beginCommand(outWriter, GLS_OP_glsBeginGLS, 8);
        outWriter->putGLint(outWriter, __GLS_VERSION_MAJOR);
        outWriter->putGLint(outWriter, __GLS_VERSION_MINOR);
        outWriter->endCommand(outWriter);
        __glsWriter_flush(outWriter);
    }
    return outWriter;
}

__GLSwriter* __glsWriter_destroy(__GLSwriter *inWriter) {
    if (!inWriter) return GLS_NONE;
    if (inWriter->type != GLS_NONE) {
        if (inWriter->beginCommand(inWriter, GLS_OP_glsEndGLS, 0)) {
            inWriter->endCommand(inWriter);
        }
        __glsWriter_flush(inWriter);
        if (inWriter->type == GLS_CONTEXT) {
            __GLScontextStreamBlock *endBlock;
            if (inWriter->error && inWriter->contextCreated) {
                __glsStrDict_remove(
                    __GLS_CONTEXT->contextStreamDict,
                    inWriter->contextStream->name.head
                );
                __GLS_ITERLIST_REMOVE_DESTROY(
                    &__GLS_CONTEXT->contextStreamList,
                    inWriter->contextStream,
                    __glsContextStream_destroy
                );
            } else if (inWriter->error) {
                endBlock = inWriter->startBlock;
                endBlock->writeTail = endBlock->buf + inWriter->startOffset;
                __glsContextStream_truncate(
                    inWriter->contextStream,
                    endBlock,
                    (size_t)((ULONG_PTR)(endBlock->writeTail - endBlock->buf))
                );
            } else {
                endBlock = __glsContextStream_lastBlock(
                    inWriter->contextStream
                );
                endBlock->writeTail = inWriter->bufPtr;
                __glsContextStream_truncate(
                    inWriter->contextStream,
                    endBlock,
                    (size_t)((ULONG_PTR)(endBlock->writeTail - endBlock->buf))
                );
            }
        } else {
            if (inWriter->error && inWriter->externStream->opened) {
                if (inWriter->externStream->created) {
                    if (
                        remove((const char *)inWriter->externStream->name.head)
                    ) {
                        __GLS_RAISE_ERROR(GLS_STREAM_DELETE_ERROR);
                    }
                } else if (inWriter->externStream->channel) {
                    __GLS_TRUNCATE_EXTERN(
                        inWriter->externStream->channel, inWriter->startOffset
                    );
                }
            }
        }
    }
    free(inWriter->externBuf);
    __glsWriteStream_destroy(inWriter->externStream);
    free(inWriter);
    return GLS_NONE;
}

GLboolean __glsWriter_flush(__GLSwriter *inoutWriter) {
    if (inoutWriter->error) return GL_FALSE;
    inoutWriter->prevCommand = GLS_NONE;
    if (inoutWriter->type == GLS_CONTEXT) {
        return GL_TRUE;
    } else {
        FILE *channel;

        const size_t n = (size_t)((ULONG_PTR)(inoutWriter->bufPtr - inoutWriter->externBufHead));
        if (!n) return GL_TRUE;
        if (channel = inoutWriter->externStream->channel) {
            if (
                fwrite(inoutWriter->externBufHead, 1, n, channel) == n &&
                !fflush(channel)
            ) {
                inoutWriter->externBufHead = (
                    (inoutWriter->wordCount & 1) ?
                    inoutWriter->externBuf + 4 :
                    inoutWriter->externBuf
                );
                inoutWriter->bufPtr = inoutWriter->externBufHead;
                return GL_TRUE;
            } else {
                __GLS_RAISE_ERROR(GLS_STREAM_WRITE_ERROR);
                clearerr(channel);
                inoutWriter->error = GL_TRUE;
                return GL_FALSE;
            }
        } else {
            if (
                inoutWriter->externStream->writeFunc(
                    n, inoutWriter->externBufHead
                )
                == n
            ) {
                inoutWriter->externBufHead = (
                    (inoutWriter->wordCount & 1) ?
                    inoutWriter->externBuf + 4 :
                    inoutWriter->externBuf
                );
                inoutWriter->bufPtr = inoutWriter->externBufHead;
                return GL_TRUE;
            } else {
                __GLS_RAISE_ERROR(GLS_STREAM_WRITE_ERROR);
                inoutWriter->error = GL_TRUE;
                return GL_FALSE;
            }
        }
    }
}

void __glsWriter_putListv(
    __GLSwriter *inoutWriter,
    GLenum inType,
    GLint inCount,
    const GLvoid *inVec
) {
    switch (inType) {
        case GL_2_BYTES:
            inoutWriter->putGLubytev(
                inoutWriter, 2 * inCount, (const GLubyte *)inVec
            );
            break;
        case GL_3_BYTES:
            inoutWriter->putGLubytev(
                inoutWriter, 3 * inCount, (const GLubyte *)inVec
            );
            break;
        case GL_4_BYTES:
            inoutWriter->putGLubytev(
                inoutWriter, 4 * inCount, (const GLubyte *)inVec
            );
            break;
        case GL_BYTE:
            inoutWriter->putGLbytev(
                inoutWriter, inCount, (const GLbyte *)inVec
            );
            break;
        case GL_FLOAT:
            inoutWriter->putGLfloatv(
                inoutWriter, inCount, (const GLfloat *)inVec
            );
            break;
        case GL_INT:
            inoutWriter->putGLintv(
                inoutWriter, inCount, (const GLint *)inVec
            );
            break;
        case GL_SHORT:
            inoutWriter->putGLshortv(
                inoutWriter, inCount, (const GLshort *)inVec
            );
            break;
        case GL_UNSIGNED_BYTE:
            inoutWriter->putGLubytev(
                inoutWriter, inCount, (const GLubyte *)inVec
            );
            break;
        case GL_UNSIGNED_INT:
            inoutWriter->putGLuintv(
                inoutWriter, inCount, (const GLuint *)inVec
            );
            break;
        case GL_UNSIGNED_SHORT:
            inoutWriter->putGLushortv(
                inoutWriter, inCount, (const GLushort *)inVec
            );
            break;
        default:
            inoutWriter->putGLbytev(inoutWriter, 0, GLS_NONE);
            break;
    }
}

void __glsWriter_putPixelv(
    __GLSwriter *inoutWriter,
    GLenum inFormat,
    GLenum inType,
    GLint inWidth,
    GLint inHeight,
    const GLvoid *inVec
) {
    GLint groupElems;
    GLint rowElems;
    GLint strideElems;
    __GLSpixelStoreConfig pixelStore;

    if (!inVec) inType = GLS_NONE;
    __glsPixelStoreConfig_get_unpack(&pixelStore);
    switch (inFormat) {
        case GL_ALPHA:
        case GL_BLUE:
        case GL_COLOR_INDEX:
        case GL_DEPTH_COMPONENT:
        case GL_GREEN:
        case GL_LUMINANCE:
        case GL_RED:
        case GL_STENCIL_INDEX:
            groupElems = 1;
            break;
        case GL_LUMINANCE_ALPHA:
            groupElems = 2;
            break;
        case GL_RGB:
#if __GL_EXT_bgra
        case GL_BGR_EXT:
#endif
            groupElems = 3;
            break;
        case GL_RGBA:
#if __GL_EXT_bgra
        case GL_BGRA_EXT:
#endif
            groupElems = 4;
            break;
        #if __GL_EXT_abgr
            case GL_ABGR_EXT:
                groupElems = 4;
                break;
        #endif /* __GL_EXT_abgr */
        #if __GL_EXT_cmyka
            case GL_CMYK_EXT:
                groupElems = 4;
                break;
            case GL_CMYKA_EXT:
                groupElems = 5;
                break;
        #endif /* __GL_EXT_cmyka */
        default:
            groupElems = 0;
            inType = GLS_NONE;
    }
    #if __GL_EXT_packed_pixels
        switch (inType) {
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
                if (groupElems != 3) inType = GLS_NONE;
                break;
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
                if (groupElems != 4) inType = GLS_NONE;
                break;
        }
    #endif /* __GL_EXT_packed_pixels */
    rowElems = groupElems * inWidth;
    strideElems = __glsPixelStrideElems(
        inType, groupElems, inWidth, &pixelStore
    );
    switch (inType) {
        case GL_BITMAP:
            inoutWriter->putGLbitvs(
                inoutWriter,
                (GLboolean)pixelStore.lsbFirst,
                pixelStore.skipPixels * groupElems & 7,
                rowElems,
                strideElems - rowElems,
                inHeight,
                (const GLubyte *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_BYTE:
            inoutWriter->putGLbytevs(
                inoutWriter,
                GL_FALSE,
                rowElems,
                strideElems - rowElems,
                inHeight,
                0,
                1,
                (const GLbyte *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_FLOAT:
            inoutWriter->putGLfloatvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 4,
                inHeight,
                0,
                1,
                (const GLfloat *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_INT:
            inoutWriter->putGLintvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 4,
                inHeight,
                0,
                1,
                (const GLint *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_SHORT:
            inoutWriter->putGLshortvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 2,
                inHeight,
                0,
                1,
                (const GLshort *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_UNSIGNED_BYTE:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_BYTE_3_3_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            inoutWriter->putGLubytevs(
                inoutWriter,
                GL_FALSE,
                rowElems,
                strideElems - rowElems,
                inHeight,
                0,
                1,
                (const GLubyte *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_UNSIGNED_INT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_INT_8_8_8_8_EXT:
            case GL_UNSIGNED_INT_10_10_10_2_EXT:
        #endif /* __GL_EXT_packed_pixels */
            inoutWriter->putGLuintvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 4,
                inHeight,
                0,
                1,
                (const GLuint *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        case GL_UNSIGNED_SHORT:
        #if __GL_EXT_packed_pixels
            case GL_UNSIGNED_SHORT_4_4_4_4_EXT:
            case GL_UNSIGNED_SHORT_5_5_5_1_EXT:
        #endif /* __GL_EXT_packed_pixels */
            inoutWriter->putGLushortvs(
                inoutWriter,
                (GLboolean)pixelStore.swapBytes,
                rowElems,
                (strideElems - rowElems) * 2,
                inHeight,
                0,
                1,
                (const GLushort *)__glsPixelBase(
                    inType, groupElems, strideElems, &pixelStore, inVec
                )
            );
            break;
        default:
            inoutWriter->putGLbytev(inoutWriter, 0, GLS_NONE);
            break;
    }
}

// DrewB - Always enabled for 1.1 support
void __glsWriter_putVertexv(
    __GLSwriter *inoutWriter,
    GLint inSize,
    GLenum inType,
    GLint inStride,
    GLint inCount,
    const GLvoid *inVec
) {
    if (!inVec) inType = GLS_NONE;
    switch (inType) {
        case __GLS_BOOLEAN:
            inoutWriter->putGLbooleanvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize : 0,
                inCount,
                0,
                1,
                (const GLboolean *)inVec
            );
            break;
        case GL_BYTE:
            inoutWriter->putGLbytevs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize : 0,
                inCount,
                0,
                1,
                (const GLbyte *)inVec
            );
            break;
        case GL_DOUBLE_EXT:
            inoutWriter->putGLdoublevs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 8 : 0,
                inCount,
                0,
                1,
                (const GLdouble *)inVec
            );
            break;
        case GL_FLOAT:
            inoutWriter->putGLfloatvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 4 : 0,
                inCount,
                0,
                1,
                (const GLfloat *)inVec
            );
            break;
        case GL_INT:
            inoutWriter->putGLintvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 4 : 0,
                inCount,
                0,
                1,
                (const GLint *)inVec
            );
            break;
        case GL_SHORT:
            inoutWriter->putGLshortvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 2 : 0,
                inCount,
                0,
                1,
                (const GLshort *)inVec
            );
            break;
        case GL_UNSIGNED_BYTE:
            inoutWriter->putGLubytevs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize : 0,
                inCount,
                0,
                1,
                (const GLubyte *)inVec
            );
            break;
        case GL_UNSIGNED_INT:
            inoutWriter->putGLuintvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 4 : 0,
                inCount,
                0,
                1,
                (const GLuint *)inVec
            );
            break;
        case GL_UNSIGNED_SHORT:
            inoutWriter->putGLushortvs(
                inoutWriter,
                GL_FALSE,
                inSize,
                inStride ? inStride - inSize * 2 : 0,
                inCount,
                0,
                1,
                (const GLushort *)inVec
            );
            break;
        default:
            inoutWriter->putGLbytev(inoutWriter, 0, GLS_NONE);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\opengl\gls\lib\size.c ===
/*
** Copyright 1995-2095, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "glslib.h"

// DrewB - Changed size functions to take contexts

// DrewB
GLint __glsTypeSize(GLenum type)
{
    switch(type)
    {
    case __GLS_BOOLEAN:
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
        return 1;
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
        return 2;
    case GL_INT:
    case GL_UNSIGNED_INT:
    case GL_FLOAT:
        return 4;
    case GL_DOUBLE_EXT:
        return 8;
        
    default:
        return 0;
    }
}

GLint __glsEvalComputeK(GLenum inTarget) {
    switch(inTarget) {
        case GL_MAP1_INDEX:
        case GL_MAP1_TEXTURE_COORD_1:
        case GL_MAP2_INDEX:
        case GL_MAP2_TEXTURE_COORD_1:
            return 1;
        case GL_MAP1_TEXTURE_COORD_2:
        case GL_MAP2_TEXTURE_COORD_2:
            return 2;
        case GL_MAP1_NORMAL:
        case GL_MAP1_TEXTURE_COORD_3:
        case GL_MAP1_VERTEX_3:
        case GL_MAP2_NORMAL:
        case GL_MAP2_TEXTURE_COORD_3:
        case GL_MAP2_VERTEX_3:
            return 3;
        case GL_MAP1_COLOR_4:
        case GL_MAP1_TEXTURE_COORD_4:
        case GL_MAP1_VERTEX_4:
        case GL_MAP2_COLOR_4:
        case GL_MAP2_TEXTURE_COORD_4:
        case GL_MAP2_VERTEX_4:
            return 4;
    }
    return 0;
}
  
static GLint __glsGetMapSize(__GLScontext *ctx, GLenum inTarget, GLenum inQuery) {
    GLint order[2];

    order[0] = order[1] = 0;
    __GLS_BEGIN_CAPTURE_EXEC(ctx, GLS_OP_glGetMapiv);
    glGetMapiv(inTarget, GL_ORDER, order);
    __GLS_END_CAPTURE_EXEC(ctx, GLS_OP_glGetMapiv);
    if (order[0] < 0 || order[1] < 0) return 0;
    switch (inTarget) {
        case GL_MAP1_COLOR_4:
        case GL_MAP1_INDEX:
        case GL_MAP1_NORMAL:
        case GL_MAP1_TEXTURE_COORD_1:
        case GL_MAP1_TEXTURE_COORD_2:
        case GL_MAP1_TEXTURE_COORD_3:
        case GL_MAP1_TEXTURE_COORD_4:
        case GL_MAP1_VERTEX_3:
        case GL_MAP1_VERTEX_4:
            switch (inQuery) {
                case GL_COEFF:
                    return __glsEvalComputeK(inTarget) * order[0];
                case GL_DOMAIN:
                    return 2;
                case GL_ORDER:
                    return 1;
            }
            break;
        case GL_MAP2_COLOR_4:
        case GL_MAP2_INDEX:
        case GL_MAP2_NORMAL:
        case GL_MAP2_TEXTURE_COORD_1:
        case GL_MAP2_TEXTURE_COORD_2:
        case GL_MAP2_TEXTURE_COORD_3:
        case GL_MAP2_TEXTURE_COORD_4:
        case GL_MAP2_VERTEX_3:
        case GL_MAP2_VERTEX_4:
            switch (inQuery) {
                case GL_COEFF:
                    return (
                        __glsEvalComputeK(inTarget) * order[0] * order[1]
                    );
                case GL_DOMAIN:
                    return 4;
                case GL_ORDER:
                    return 2;
            }
            break;
    }
    return 0;
}

static GLint __glsGetPixelMapSize(__GLScontext *ctx, GLenum inMap) {
    GLint size = 0;
    GLenum query;
    
    switch (inMap) {
        case GL_PIXEL_MAP_I_TO_I:
            query = GL_PIXEL_MAP_I_TO_I_SIZE;
            break;
        case GL_PIXEL_MAP_S_TO_S:
            query = GL_PIXEL_MAP_S_TO_S_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_R:
            query = GL_PIXEL_MAP_I_TO_R_SIZE;
            break;
        case GL_PIXEL_MAP_I_TO_G:
            query = GL_PIXEL_MAP_I_TO_G_SIZE;
            break;
        case GL_PIXEL_MAP_I