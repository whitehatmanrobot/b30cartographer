 _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sysprep\sysprep.c ===
/*++

File Description:

    This file contains all the functions required to add a registry entry
    to force execution of the system clone worker upon reboot.

--*/

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpoapi.h>
#include <ntdddisk.h>
#include <windows.h>
#include <shlwapi.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <regstr.h>
#include "sysprep.h"
#include "msg.h"
#include "resource.h"
#include <tchar.h>
#include <opklib.h>
#include <ntverp.h>
#include <spsyslib.h>
#include <sysprep_.c>
#include <winbom.h>
#include <initguid.h>
#include <ntddpar.h>



// External functions
//
extern void uiDialogTopRight(HWND hwndDlg);
extern HWND ghwndOemResetDlg;


                            //
                            // Does the user want a new SID?
                            //
BOOL    NoSidGen = FALSE;
BOOL    SetupClPresent = TRUE;

                            //
                            // Does the user want confirmation?
                            //
BOOL    QuietMode = FALSE;

                            //
                            // Do PnP re-enumeration?
                            //
BOOL    PnP = FALSE;

                            //
                            // Do we shutdown when we're done?
                            //
BOOL    NoReboot = FALSE;

                            //
                            // Instead of shutting down, do we reboot?
                            //
BOOL    Reboot = FALSE;

                            //
                            // Clean out the critical devices database?
                            //
BOOL    Clean = FALSE;

                            //
                            // Force the shutdown instead of trying to poweroff?
                            //
BOOL    ForceShutdown = FALSE;

                            //
                            // Generating an Image for Factory Preinstallation.
                            //
BOOL    Factory = FALSE;

                            //
                            // Reseal a machine after running FACTORY.EXE
                            //
BOOL    Reseal = FALSE;
                            // Per/Pro SKUs defaults to OOBE, Server SKUs always use MiniSetup.
                            // Pro SKU can override OOBE with -mini to use MiniSetup also 
                            // via sysprep.inf
BOOL    bMiniSetup = FALSE;

                            //
                            // Just do an audit boot if this switch is passed in. ( '-audit' )
                            //

BOOL    Audit = FALSE;
                            // 
                            // Rollback 
                            // 
BOOL    bActivated = FALSE;   

                            //
                            // Build list of pnpids in [sysprepmassstorage] section in sysprep.inf
                            //
BOOL    BuildMSD = FALSE;

                            //
                            // If we're running on a domain controler this should be set.
                            //
BOOL    bDC = FALSE;



//
// Internal Define(s):
//
#define SYSPREP_LOG                 _T("SYSPREP.LOG")   // Sysprep log file
#define SYSPREP_MUTEX               _T("SYSPREP-APP-5c9fbbd0-ee0e-11d2-9a21-0000f81edacc")    // GUID used to determine if sysprep is currently running
#define SYSPREP_LOCK_SLEEP          100 // Number of miliseconds to sleep in LockApplication function
#define SYSPREP_LOCK_SLEEP_COUNT    10 // Number of times to sleep during LockApplication function

// Path to the sysprep directory.
//
TCHAR       g_szSysprepDir[MAX_PATH]    = NULLSTR;

// Path to the SYSPREP.EXE.
//
TCHAR       g_szSysprepPath[MAX_PATH]    = NULLSTR;

// Path to the Sysprep log file.
//
TCHAR       g_szLogFile[MAX_PATH]       = NULLSTR;

// Path to the Winbom file.
//
TCHAR       g_szWinBOMPath[MAX_PATH]    = NULLSTR;

// Public functions
//
BOOL FProcessSwitches();

// Local functions
static BOOL RenameWinbom();
static INT  CleanupPhantomDevices();
static VOID CleanUpDevices();
static VOID CleanupParallelDevices();

#if !defined(_WIN64)
static BOOL SaveDiskSignature();
#endif // !defined(_WIN64)


//
// UI stuff...
//
HINSTANCE   ghInstance;
UINT        AppTitleStringId = IDS_APPTITLE;
HANDLE      ghWaitEvent = NULL, ghWaitThread = NULL;
BOOL        gbScreenSaver = FALSE;

void StartWaitThread();
void EndWaitThread();
void DisableScreenSaver(BOOL *pScreenSaver);
void EnableScreenSaver(BOOL *pScreenSaver);

int
MessageBoxFromMessageV(
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR   Caption[512];
    TCHAR   Buffer[5000];
    
    if(!LoadString(ghInstance,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    if( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                        ghInstance,
                        MessageId,
                        0,
                        Buffer,
                        sizeof(Buffer) / sizeof(TCHAR),
                        Args ) ) {
        return GetLastError();
    } else {
        return(MessageBox(NULL,Buffer,Caption,Style));
    }
}


int
MessageBoxFromMessage(
    IN DWORD MessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    int i = IDOK;  // Default return value of "OK".

    // If we're in the middle of a Wait thread kill it
    //
    EndWaitThread();

    if ( !QuietMode )
    {
        va_start(arglist,Style);

        i = MessageBoxFromMessageV(MessageId,CaptionStringId,Style,&arglist);

        va_end(arglist);
    }

    return(i);
}

/*++
===============================================================================
Routine Description:

    This routine will attempt to disjoin a user from a domain, if he
    is already in a domain

Arguments:

    none

Return Value:

    TRUE - Everything is okay.

    FALSE - Something bad happened.

===============================================================================
--*/
BOOL UnjoinNetworkDomain
(
    void
)
{
    if (IsDomainMember())
    {
        // He's a member of some domain.  Let's try and remove him
        // from the domain.
        if (NO_ERROR != NetUnjoinDomain( NULL, NULL, NULL, 0 ))
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*++
===============================================================================
Routine Description:

    This routine will setup the setup for operation on the "factory floor"
    The purpose here is to run a process which will facilitate the installation
    of updated drivers for new devices, and to boot quickly into full GUI mode
    for application pre-install/config, as well as to customize the system.

Arguments:

    none

Return Value:

    TRUE if no errors, FALSE otherise

===============================================================================
--*/
BOOL SetupForFactoryFloor
(
    void
)
{
    TCHAR   szFactory[MAX_PATH] = NULLSTR,
            szSysprep[MAX_PATH] = NULLSTR,
            szSystem[MAX_PATH]  = NULLSTR;
    LPTSTR  lpFilePart          = NULLSTR;

    // Make sure we have the right privileges
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    // We need the path to sysprep.exe and factory.exe.
    //
    if ( !( GetModuleFileName(NULL, szSysprep, AS(szSysprep)) && szSysprep[0] &&
            GetFullPathName(szSysprep, AS(szFactory), szFactory, &lpFilePart) && szFactory[0] && lpFilePart ) )
    {
        return FALSE;
    }

    // Replace the sysprep.exe filename with factory.exe.
    //
    StringCchCopy ( lpFilePart, AS ( szFactory ) - ( lpFilePart - szFactory ), TEXT( "factory.exe" ) );
    
    // Make sure that sysprep.exe and factory.exe are on the system drive.
    //
    if ( ( ExpandEnvironmentStrings(TEXT("%SystemDrive%"), szSystem, AS(szSystem)) ) &&
         ( szSystem[0] ) &&
         ( szSystem[0] != szSysprep[0] ) )
    {
        // Well that sucks, we should try and copy the files over to the %SystemDrive%\sysprep folder.
        //
        AddPath(szSystem, TEXT("sysprep"));
        lpFilePart = szSystem + lstrlen(szSystem);
        CreateDirectory(szSystem, NULL);

        // First copy factory locally.
        //
        AddPath(szSystem, TEXT("factory.exe"));
        CopyFile(szFactory, szSystem, FALSE);
        StringCchCopy ( szFactory, AS ( szFactory ), szSystem );

        // Now try to copy sysprep.exe.
        //
        *lpFilePart = TEXT('\0');
        AddPath(szSystem, TEXT("sysprep.exe"));
        CopyFile(szSysprep, szSystem, FALSE);
        //lstrcpy(szSysprep, szSystem);
    }

    if (!SetFactoryStartup(szFactory))
        return FALSE;

    // Clear out any previous Factory.exe state settings
    RegDeleteKey(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Factory\\State");

    // Remove any setting before Factory
    //
    NukeMruList();  

    // Rearm 
    //
    if (!IsIA64() && !bActivated && (ERROR_SUCCESS != ReArm())) {
        // Display warning that grace period limit has reached and cannot
        // re-active grace period, and we continue thru.
        //
        MessageBoxFromMessage( MSG_REARM_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );        
    }

    return TRUE;
}

INT_PTR CALLBACK WaitDlgProc
(
    IN HWND   hwndDlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
{
    switch (msg) 
    { 
        case WM_INITDIALOG: 
            {
                // Centers the wait dialog in parent or screen
                //
                HWND hwndParent = GetParent(hwndDlg);
                CenterDialogEx(hwndParent, hwndDlg);

                // If no parent then make sure this is visible
                //
                if (hwndParent == NULL)
                    SetForegroundWindow(hwndDlg);

                // Play the animation 
                //
                Animate_Open(GetDlgItem(hwndDlg,IDC_ANIMATE),MAKEINTRESOURCE(IDA_CLOCK_AVI));
                Animate_Play(GetDlgItem(hwndDlg,IDC_ANIMATE),0,-1,-1);
            }
            break;
             
    } 
    return (BOOL) FALSE; 
}

DWORD WaitThread(LPVOID lpVoid)
{
    HWND hwnd;

    if ( hwnd = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_WAIT), ghwndOemResetDlg, WaitDlgProc) )
    {
        MSG     msg;
        HANDLE  hEvent = (HANDLE) lpVoid;

        ShowWindow(hwnd, SW_SHOWNORMAL);
        while ( MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT) == (WAIT_OBJECT_0 + 1) )
        {
            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        DestroyWindow(hwnd);
    }
    else 
        GetLastError();

    return 0;
}

void StartWaitThread()
{
    // Create a dialog to show progress is being made.
    //
    DWORD dwThread;

    // Disable the toplevel Oemreset dialog
    //
    if (ghwndOemResetDlg)
        EnableWindow(ghwndOemResetDlg, FALSE);

    if ( ghWaitEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("SYSPREP_EVENT_WAIT")))
        ghWaitThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) WaitThread, (LPVOID) ghWaitEvent, 0, &dwThread);
}

void EndWaitThread()
{
    // Kill the Status Dialog.
    //
    if ( ghWaitEvent )
        SetEvent(ghWaitEvent);

    // Try and let the thread terminate nicely.
    //
    if ( ghWaitThread )
        WaitForSingleObject(ghWaitThread, 2000);

    // Clear the handles
    //
    ghWaitEvent = NULL;
    ghWaitThread = NULL;

    // Enable the toplevel OemReset dialog
    //
    if (ghwndOemResetDlg)
        EnableWindow(ghwndOemResetDlg, TRUE);
}

/*++
===============================================================================
Routine Description:

    This is the error callback handler for SetDefaultOEMApps()

===============================================================================
--*/

void ReportSetDefaultOEMAppsError(LPCTSTR pszAppName, LPCTSTR pszIniVar)
{
    MessageBoxFromMessage( MSG_SETDEFAULTS_NOTFOUND,
                           AppTitleStringId,
                           MB_OK | MB_ICONERROR | MB_TASKMODAL,
                           pszAppName, pszIniVar);
}

/*++
===============================================================================
Routine Description:

    This routine will perform the tasks necessary to reseal the machine,
    readying it to be shipped to the end user.

Arguments:

    BOOL fIgnoreFactory - ignores if factory floor was run

Return Value:

    TRUE if no errors, FALSE otherwise

===============================================================================
--*/
BOOL ResealMachine
(
    void
)
{
    // Make sure privileges have been set
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);
   
    // Prepare the machine to be hardware independent.
    //
    if (!FPrepareMachine()) {
        MessageBoxFromMessage( MSG_REGISTRY_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
        return FALSE;
    }


    //
    // Cleanup registry no matter what since factorymode=yes can set this
    // and winbom.ini can set this and sysprep -factory can set this, or else
    // PnP will hang on FactoryPreInstallInProgress being set.
    //
    CleanupRegistry();

    // Clean up the factory mess.
    //
    RegDelete(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"AutoAdminLogon");
    SHDeleteKey(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Factory");

    // Rearm 
    //
    if (!IsIA64() && !bActivated && (ERROR_SUCCESS != ReArm())) {
        // Display warning that grace period limit has reached and cannot
        // re-active grace period, and we continue thru.
        //
        MessageBoxFromMessage( MSG_REARM_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );        
    }

#if defined(_WIN64)

    //
    // For EFI machines set the boot timeout to 5 seconds so that developers get a chance to see
    // the boot menu and have the option to boot to the EFI shell, CD, or other menu options,
    // for development purposes.
    //
    ChangeBootTimeout(5);

#else

    ChangeBootTimeout(0);           // reset the timeout to 0 secs   

#endif // !defined(_WIN64)

    
    // 
    // First part of reseal.
    //
    AdjustFiles();

    //
    // Second part of reseal.
    //
    // This is common reseal code used by both Riprep and Sysprep.
    // These happen whether or not factory floor was run before.
    //
    if (!FCommonReseal()) {
        MessageBoxFromMessage( MSG_COMMON_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
        return FALSE;
    }
    
    // ISSUE-2000/06/06-DONALDM
    // We need to handle the network configuration problem for factory more cleanly
    // We need to define what the network state is when factory first comes up, and
    // what the network state is for final customer delivery. Simply disjoining from
    // a domain during reseal is probably not enough...
    //
    
//    if( !UnjoinNetworkDomain()) 
//    {
//        //  We failed to disjoin.  Our only option is to
//        // inform the user and bail.
//        MessageBoxFromMessage( MSG_DOMAIN_INCOMPATIBILITY,
//                               AppTitleStringId,
//                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );
//        return FALSE;                               
//    }

    //
    //  Set default middleware applications.
    //
    if (!SetDefaultOEMApps(g_szWinBOMPath))
    {
        // SetDefaultApplications will do its own MessageBoxFromMessage
        // with more detailed information
        return FALSE;
    }

    // Call functions in published SYSPREP_.C file that we skiped when the
    // FACTORY option was selected
  
    // ISSUE-2000/06/05-DONALDM - We need to really decide about how to handle network settings for
    // the factory case. I think we don't need this call, becase we should have 
    // already dealt with networking settings when FACTORY.EXE ran.
    // 
      
//    RemoveNetworkSettings(NULL);

    return TRUE;
}

// Macro for processing command line options.
// Setting bVar to 1 (not to 'TRUE') because we need it for mutually exclusive option checks below.
//
#define CHECK_PARAM(lpCmdLine, lpOption, bVar)     if ( LSTRCMPI(lpCmdLine, lpOption) == 0 ) bVar = 1

//
// Parse command line parameters
//
static BOOL ParseCmdLine()
{
    DWORD   dwArgs;
    LPTSTR  *lpArgs;
    BOOL    bError = FALSE;
    BOOL    bHelp = FALSE;

    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        LPTSTR  lpArg;
        DWORD   dwArg;

        // We want to skip over the first argument (it is the path
        // to the command being executed.
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
            lpArg = NULL;

        // Loop through all the arguments.
        //
        while ( lpArg && !bError )
        {
            // Now we check to see if the first char is a dash or forward slash.
            //
            if ( *lpArg == _T('-') || *lpArg == _T('/'))
            {
                LPTSTR lpOption = CharNext(lpArg);

                // This is where you add command line options that start with a dash (-).
                //
                CHECK_PARAM( lpOption, _T("quiet"), QuietMode);
                CHECK_PARAM( lpOption, _T("nosidgen"), NoSidGen);
                CHECK_PARAM( lpOption, _T("pnp"), PnP);
                CHECK_PARAM( lpOption, _T("noreboot"), NoReboot);
                CHECK_PARAM( lpOption, _T("reboot"), Reboot);
                CHECK_PARAM( lpOption, _T("clean"), Clean);
                CHECK_PARAM( lpOption, _T("forceshutdown"), ForceShutdown);
                CHECK_PARAM( lpOption, _T("factory"), Factory);
                CHECK_PARAM( lpOption, _T("reseal"), Reseal);
                CHECK_PARAM( lpOption, _T("mini"), bMiniSetup);
                CHECK_PARAM( lpOption, _T("audit"), Audit);
                CHECK_PARAM( lpOption, _T("activated"), bActivated);
                CHECK_PARAM( lpOption, _T("bmsd"), BuildMSD);
                CHECK_PARAM( lpOption, _T("dc"), bDC);
                CHECK_PARAM( lpOption, _T("?"), bHelp);
            }
            else if ( *lpArg )
            {
                bError = TRUE;
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
                lpArg = *(lpArgs + dwArg);
            else
                lpArg = NULL;
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }
     
    if (bError || bHelp)
    {
        // Set the quiet switch in this case so we display the error.
        // Note that we return FALSE and exit the application following this.
        //
        QuietMode = FALSE;
        MessageBoxFromMessage( MSG_USAGE,
                               AppTitleStringId,
                               MB_OK | MB_TASKMODAL );
        return FALSE;
    }    

    //
    // Now look at the switches passed in and make sure that they are consistent.
    // If they are not, display an error message and quit, unless we're in quiet 
    // mode where we do not display any error messages.
    //

    //
    // Check that the shutdown options are not conflicting with each other.
    if ( (NoReboot + Reboot + ForceShutdown) > 1 )
    {
        bError = TRUE;
    }
    // These top-level options are exclusive: -bmsd, -clean, -audit, -factory, -reseal.
    //
    else if ( (BuildMSD + Clean + Audit + Factory + Reseal) > 1 )
    {
        bError = TRUE;
    }
    // For Clean or BuildMSD none of the options except -quiet are valid.
    //
    else if ( Clean || BuildMSD )
    {
        if ( NoSidGen || PnP || NoReboot || Reboot || ForceShutdown || bMiniSetup || bActivated ) 
        {
            bError = TRUE;
        }
    }
    else if ( Audit )
    {
        if ( NoSidGen || PnP || bMiniSetup || bActivated )
        {
            bError = TRUE;
        }
    }
    else if ( Factory )
    {
        if ( PnP || bMiniSetup )
        {
            bError = TRUE;
        }
    }
    else if ( Reseal )
    {
        // If -pnp is specified -mini must have been specified unless we're running on server or ia64 (because
        // later we force bMiniSetup to be true on server and ia64.
        // 
        if ( PnP && !bMiniSetup && !(IsServerSKU() || IsIA64()) )
        {
            bError = TRUE;
        }
    }

    // If there was some inconsistency in the switches specified put up 
    // an error message.
    if ( bError )
    {
        // Reset the quiet switch in this case so we display the error.
        // Note that we return FALSE and exit the application following this.
        //
        QuietMode = FALSE;
        MessageBoxFromMessage( MSG_USAGE_COMBINATIONS,
                               AppTitleStringId,
                               MB_OK | MB_TASKMODAL | MB_ICONERROR);
        return FALSE;
    }
    // Force MiniSetup on IA64 and Servers.
    //
    if (IsIA64() || IsServerSKU())
    {
        bMiniSetup = TRUE;
    }
    else if ( IsPersonalSKU() )
    {
        if ( bMiniSetup )
        {
            // Can't specify mini-setup for personal sku
            //
            MessageBoxFromMessage( MSG_NO_MINISETUP,
                                   AppTitleStringId,
                                   MB_OK | MB_ICONERROR | MB_TASKMODAL );
            
            bMiniSetup = FALSE;
        }

        if ( PnP )
        {
            // Can't specify -pnp because we're not running mini-setup on personal sku.
            //
            MessageBoxFromMessage( MSG_NO_PNP,
                                   AppTitleStringId,
                                   MB_OK | MB_ICONERROR | MB_TASKMODAL );
            PnP = FALSE;
        }        
    }
    
    //
    // If we're cleaning up the critical device database,
    // then we'll be wanting to set some additional flags.
    //
    if (Clean || BuildMSD)
    {
        QuietMode = TRUE;
        NoReboot = TRUE;
    }
    return !bError;
}


BOOL
IsFactoryPresent(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine tests to see if FACTORY.EXE is present on the machine.
    FACTORY.EXE will be required to run on reboot, so if it's not here,
    we need to know.

Arguments:

    None.

Return Value:

    TRUE - FACTORY.EXE is present.

    FALSE - FACTORY.EXE is not present.

===============================================================================
--*/

{
WCHAR               FileName[MAX_PATH];

    // Attempt to locate FACTORY.EXE
    //
    if (GetModuleFileName(NULL, FileName, MAX_PATH)) {
        if (PathRemoveFileSpec(FileName)) {
            OPKAddPathN(FileName, TEXT("FACTORY.EXE"), AS ( FileName ));
            if (FileExists(FileName))
                return TRUE;
        }
    }
    return FALSE;
}

void PowerOff(BOOL fForceShutdown)
{
    SYSTEM_POWER_CAPABILITIES   spc;
    ULONG                       uiFlags = EWX_POWEROFF;

    ZeroMemory(&spc, sizeof(spc));

    // Make sure we have privilege to shutdown
    //
    pSetupEnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

    //
    // Use flag else query system for power capabilities
    //
    if (fForceShutdown)
        uiFlags = EWX_SHUTDOWN;
    else if (NT_SUCCESS(NtPowerInformation(SystemPowerCapabilities,
                                     NULL,
                                     0,
                                     &spc,
                                     sizeof(spc))))
    {
        //
        // spc.SystemS1 == sleep 1
        // spc.SystemS2 == sleep 2
        // spc.SystemS3 == sleep 3 
        // spc.SystemS4 == hibernate support
        // spc.SystemS5 == poweroff support
        //
        if (spc.SystemS5)
        {
            // ACPI capable
            uiFlags = EWX_POWEROFF;
        }
        else
        {
            // Non-ACPI 
            uiFlags = EWX_SHUTDOWN;
        }   
    }

    ExitWindowsEx(uiFlags|EWX_FORCE, SYSPREP_SHUTDOWN_FLAGS);
}

int APIENTRY WinMain( HINSTANCE hInstance,
                      HINSTANCE hPrevInstance,
                      LPSTR lpCmdLine,
                      int nCmdShow )
/*++
===============================================================================
Routine Description:

    This routine is the main entry point for the program.

    We do a bit of error checking, then, if all goes well, we update the
    registry to enable execution of our second half.

===============================================================================
--*/

{
    DWORD   dwVal;
    HKEY    hKey;
    LPTSTR  lpFilePart  = NULL;
    INITCOMMONCONTROLSEX icex;
    LPTSTR  lpAppName = NULL;

    ghInstance = hInstance;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    memset(&icex, 0, sizeof(icex));
    icex.dwSize = sizeof(icex);
    icex.dwICC = ICC_PROGRESS_CLASS|ICC_ANIMATE_CLASS;
    InitCommonControlsEx(&icex);
    
    // We need the path to sysprep.exe and where it is located.
    //
    GetModuleFileName(NULL, g_szSysprepPath, AS(g_szSysprepPath));
    if ( GetFullPathName(g_szSysprepPath, AS(g_szSysprepDir), g_szSysprepDir, &lpFilePart) && g_szSysprepDir[0] && lpFilePart )
    {
        // Chop off the file name.
        //
        *lpFilePart = NULLCHR;
    }

    // If either of those file, we must quit (can't imagine that every happening).
    //
    if ( ( g_szSysprepPath[0] == NULLCHR ) || ( g_szSysprepDir[0] == NULLCHR ) )
    {
        // TODO:  Log this failure.
        //
        // LogFile(WINBOM_LOGFILE, _T("\n"));
        return 0;
    }

    // Need the full path to the log file.
    //    
    StringCchCopy ( g_szLogFile, AS ( g_szLogFile ), g_szSysprepDir);
    AddPath(g_szLogFile, SYSPREP_LOG);

    // Attempt to aquire a lock on the application
    //
    if ( !LockApplication(TRUE) )
    {
        // Let the user know that we are busy
        //

        MessageBoxFromMessage( MSG_ALREADY_RUNNING,
                               AppTitleStringId,
                               MB_OK | MB_ICONINFORMATION | MB_SYSTEMMODAL );
        return 0;

    }

    //
    // Check to see if we are allowed to run on this build of the OS
    //
    if ( !OpklibCheckVersion( VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE ) )
    {
        MessageBoxFromMessage( MSG_NOT_ALLOWED,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_SYSTEMMODAL );
        return 0;
    }
        
    // Ensure that the user has privilege/access to run this app.
    if(!pSetupIsUserAdmin()
        || !pSetupDoesUserHavePrivilege(SE_SHUTDOWN_NAME)
        || !pSetupDoesUserHavePrivilege(SE_BACKUP_NAME)
        || !pSetupDoesUserHavePrivilege(SE_RESTORE_NAME)
        || !pSetupDoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME))
    {

        MessageBoxFromMessage( MSG_NOT_AN_ADMINISTRATOR,
                               AppTitleStringId,
                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );

        LockApplication(FALSE);
        return 0;
    }

    // Check the command line
    if( !ParseCmdLine() )
    {
        LockApplication(FALSE);
        return 0;
    }

    // Determines whether we can run SidGen. If not quit the application
    // 
    // Make sure setupcl.exe is present in the system32 directory, if we need
    // to use it.
    if( !(SetupClPresent = IsSetupClPresent()) && !NoSidGen )
    {
        MessageBoxFromMessage( MSG_NO_SUPPORT,
                               AppTitleStringId,
                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );

        LockApplication(FALSE);
        return 1;
    }

    // Put up a dialog to identify ourselves and make sure the user
    // really wants to do this.
    
    if ( IDCANCEL == MessageBoxFromMessage( MSG_IDENTIFY_SYSPREP,
                                           AppTitleStringId,
                                           MB_OKCANCEL| MB_ICONEXCLAMATION | MB_SYSTEMMODAL )
       )
    {
        LockApplication(FALSE);
        return 0;
    }

    // Allocate memory for window
    //    
    if ( (lpAppName = AllocateString(NULL, IDS_APPNAME)) && *lpAppName )
    {
        ghwndOemResetDlg = FindWindow(NULL, lpAppName);

        // Free up the allocated memory
        //
        FREE(lpAppName);
    }

    DisableScreenSaver(&gbScreenSaver);

    //
    // Call RenameWinbom() once to initialize it.  First time it is called it will check the factory 
    // state registry key for the current winbom.ini that we are using.  The second time it gets called it 
    // will actually perform the rename if necessary. Make sure that the first time this gets called 
    // for intialization it is before LocateWinBom() because LocateWinBom() populates the registry with 
    // the winbom it finds.
    //
    RenameWinbom();
    
    // Need full path to winbom too.  It is not an error if the file is
    // not found.  (It is optional.)
    //
    LocateWinBom(g_szWinBOMPath, AS(g_szWinBOMPath), g_szSysprepDir, INI_VAL_WBOM_TYPE_FACTORY, LOCATE_NORMAL);
    
    // Process switches
    //
    if ( !FProcessSwitches() && !ghwndOemResetDlg)
    {
        ShowOemresetDialog(hInstance); 
    }

    EnableScreenSaver(&gbScreenSaver);

    // Unlock application and free up memory
    //
    LockApplication(FALSE);

    return 0;
}

// Factory Preinstall now also prepares the machine 
//
BOOL FDoFactoryPreinstall()
{
    HKEY  hKey;
    DWORD dwVal;

    if (!IsFactoryPresent()) {
        MessageBoxFromMessage( MSG_NO_FACTORYEXE,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );

        return FALSE;
    }

    // Setup factory.exe for factory floor
    //
    if (!SetupForFactoryFloor())
    {
        MessageBoxFromMessage( MSG_SETUPFACTORYFLOOR_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );

        return FALSE;
    }

    // Prepare machine to be hardware independent for factory floor 
    //
    if (!FPrepareMachine()) {
        MessageBoxFromMessage( MSG_REGISTRY_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
        return FALSE;
    }

    // Set the boot timeout for boot on factory floor
    if (!ChangeBootTimeout( 1 ))
        return FALSE;

    return TRUE;
}

// Prepares the machine to be hardware independent
// 
BOOL FPrepareMachine()
{
    TCHAR szSysprepInf[MAX_PATH] = TEXT("");

    //
    // Make sure we've got the required privileges to update the registry.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    // Build path to sysprep.inf from where sysprep.exe is located
    //
    if (GetModuleFileName(NULL, szSysprepInf, MAX_PATH)) 
    {
        PathRemoveFileSpec(szSysprepInf);
        OPKAddPathN(szSysprepInf, TEXT("sysprep.inf"), AS ( szSysprepInf ) );
    }

    // Disable System Restore
    //
    DisableSR();

    // Make sure we're not a member of a domain.  If we are, then try and
    // force the unjoin.
    //
    if( !bDC && !UnjoinNetworkDomain())
    {
        //  We failed to disjoin.  Our only option is to
        // inform the user and bail.
        MessageBoxFromMessage( MSG_DOMAIN_INCOMPATIBILITY,
                               AppTitleStringId,
                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );
        return FALSE;
    }

#if !defined(_WIN64)
    // Set the boot disk signature in the registry.  The mount manager uses this
    // to avoid a PNP pop-up after imaging.
    //
    if ( !SaveDiskSignature() )
    {
        return FALSE;
    }
#endif // !defined(_WIN64)
    
    // Determine if we should set the BigLba support in registry
    //
    if ( !SetBigLbaSupport(szSysprepInf) )
    {
        return FALSE;
    }

    // Determine if we should remove the tapi settings
    //
    if ( !RemoveTapiSettings(szSysprepInf) )
    {
        return FALSE;
    }

    // Set OEMDuplicatorString
    if (!SetOEMDuplicatorString(szSysprepInf))
        return FALSE;


    // If we want to regenerate the SID's on the next boot do it.
    //
    if ( NoSidGen )
    {
        // Remember that we didn't generate SIDs
        //
        RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGEN, 0);
    }
    else
    {
        if ( PrepForSidGen() )
        {
            // Write out registry value so that we know that we've regenerated SIDs.
            //
            RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGEN, 1);

            // Set this registry key, only UpdateSecurityKeys can remove this key
            //
            RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGENHISTORY, 1);
            
        }
        else
        {
            return FALSE;
        }
    }

    // If Mass Storage Devices were installed, clean up the ones not being used.
    // Note: We only want to CleanUpDevices() if we are resealing. This is the equivalent of
    // automatically running "sysprep -clean" on reseal if we know that we need to do it.
    //
    if ( RegCheck(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE))
    {
        if ( Reseal )
        {
            // Clean the critical device database, since we might have put some
            // HDC and network drivers in there during factory floor from PopulateDeviceDatabase()
            CleanUpDevices();

            // Remove this key because we just ran CleanUpDevices().
            //
            RegDelete(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE);
        }
    }
    else 
    {   
        BOOL fPopulated = FALSE;

        // Set up Hardware independence for mass storage controllers.
        //
        BuildMassStorageSection(FALSE);
     
        if (!PopulateDeviceDatabase(&fPopulated))
            return FALSE;
    
        // Write out signature value to know that we have built the mass-storage section.
        //
        if ( fPopulated && !RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE, 1) ) 
                return FALSE;
    }

    // Cleaning up the Parallel Port
    //
    CleanupParallelDevices();

    // Remember the mount manager settings
    //
    if ( !RememberAndClearMountMgrSettings() )
        return FALSE;
    
    // Remove network settings/card last so any errors during Device Database won't loose
    // networking.
    //
    if (!RemoveNetworkSettings(szSysprepInf))
        return FALSE;

    return TRUE;
}

// Reseal and Factory should behave the same according to the shutdown path.
// 
void DoShutdownTypes()
{
    pSetupEnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

    if (Reboot) 
        ExitWindowsEx(EWX_REBOOT|EWX_FORCE, SYSPREP_SHUTDOWN_FLAGS);
    else if (NoReboot)
        PostQuitMessage(0);
    else 
        PowerOff(ForceShutdown); // Default
}

// Process action switches return TRUE if processed
//
BOOL FProcessSwitches()
{
    // There are currently 4 basic operating modes for SYSPREP:

    // 1) Factory floor mode. This mode is new for Whistler and will not completly
    // clone the system, but will prep the system for OEM factory floor installation
    // 2) Clean mode. In this mode, sysprep will clean up the critical device database
    // 3) Reseal mode. This is the complement to factory mode which will "complete" the
    // cloning process after factory floor mode has been used.
    // 4) "Audit" mode.  The system just executes an audit boot.  Used to restart the system
    // at the end of factory.exe processing.

    // These are just flags for reseal
    //
    if (Reseal)
    {
        StartWaitThread();
        // Ensure that we're running on the right OS.
        //
        if( !CheckOSVersion() )
        {
            MessageBoxFromMessage( MSG_OS_INCOMPATIBILITY,
                                   AppTitleStringId,
                                   MB_OK | MB_ICONSTOP | MB_TASKMODAL );
            return TRUE;
        }

        // Reseal the machine
        //
        if (!ResealMachine()) {
            MessageBoxFromMessage( MSG_RESEAL_ERROR,
                       AppTitleStringId,
                       MB_OK | MB_ICONSTOP | MB_TASKMODAL );

            return TRUE;

        }

        // Rename the current winbom so we don't use it again.
        //
        RenameWinbom();

        // Shutdown or reboot?
        DoShutdownTypes();

        EndWaitThread();
        return TRUE;
    }
    else if (Factory) 
    {
        StartWaitThread();

        // Set Factory to start on next boot and prepare for imaging
        //
        if (!FDoFactoryPreinstall()) 
            return TRUE;

        // Rename the current winbom so we don't use it again.
        //
        RenameWinbom();

        // Shutdown or reboot?
        DoShutdownTypes();

        EndWaitThread();

        return TRUE;
    }
    else if (Clean) 
    {
        CleanUpDevices();

        // Remove this key because we just ran CleanUpDevices().
        //
        RegDelete(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE);
        return TRUE;
    }
    else if (Audit)
    {
        // Prepare for pseudo factory but get back to audit.
        //
       if ( RegCheck(HKLM, REGSTR_PATH_SYSTEM_SETUP, REGSTR_VALUE_AUDIT) )
       {
            TCHAR szFactoryPath[MAX_PATH] = NULLSTR;            
            // Going into Audit mode requires Factory.exe and winbom.ini
            // to exist.
            //
            if (FGetFactoryPath(szFactoryPath)) {
                SetFactoryStartup(szFactoryPath);
                DoShutdownTypes();
            }
            else {
                 LogFile(g_szLogFile, MSG_NO_FACTORYEXE);

                 MessageBoxFromMessage( MSG_NO_FACTORYEXE,
                                        IDS_APPTITLE,
                                        MB_OK | MB_ICONERROR | MB_TASKMODAL );
            }
       }
       else
       {
           LogFile(g_szLogFile, IDS_ERR_FACTORYMODE);
       }
       return TRUE;
    }
    else if (BuildMSD)
    {
        StartWaitThread();
        BuildMassStorageSection(TRUE /* Force build */);
        EndWaitThread();
        return TRUE;
    }
       
    // Return False to show the UI
    //
    Reseal = Factory = Clean = Audit = 0;
    return FALSE;
}


BOOL LockApplication(BOOL bState)
{
    static HANDLE hMutex;
    BOOL bReturn    = FALSE,
         bBail      = FALSE;
    DWORD dwSleepCount = 0;

    // We want to lock the application
    //
    if ( bState )
    {
        // Check to see if we can create the mutex and that the mutex did not
        // already exist
        //
        while ( !bReturn && (dwSleepCount < SYSPREP_LOCK_SLEEP_COUNT) && !bBail)
        {
            SetLastError(ERROR_SUCCESS);

            if ( hMutex = CreateMutex(NULL, FALSE, SYSPREP_MUTEX) )
            {
                if ( GetLastError() == ERROR_ALREADY_EXISTS )
                {
                    CloseHandle(hMutex);
                    hMutex = NULL;

                    dwSleepCount++;
                    Sleep(SYSPREP_LOCK_SLEEP);
                }
                else
                {
                    // Application successfully created lock
                    //
                    bReturn = TRUE;
                }
            }
            else
            {
                bBail = TRUE;
            }
        }
    }
    else if ( hMutex )
    {
        CloseHandle(hMutex);
        hMutex = NULL;
        bReturn = TRUE;
    }

    // Return whether or not the lock/unlock was successful
    //
    return bReturn;
}

//
// Shutdown or Reboot the machine
//
VOID ShutdownOrReboot(UINT uFlags, DWORD dwReserved)
{
    // Enable privileges for shutdown
    //
    EnablePrivilege(SE_SHUTDOWN_NAME, TRUE);

    // Shutdown or Reboot the machine
    //
    ExitWindowsEx(uFlags|EWX_FORCE, dwReserved);
}

// Remember the Screen Saver state and to disable it during Sysprep
//
void DisableScreenSaver(BOOL *pScreenSaver)
{
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, (PVOID)pScreenSaver, 0);
    if (*pScreenSaver == TRUE)
    {
        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, 0, SPIF_SENDWININICHANGE); 
    }
}

// Remember the Screen Saver state and to re-enable it after Sysprep
//
void EnableScreenSaver(BOOL *pScreenSaver)
{
    if (*pScreenSaver == TRUE)
    {
        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, TRUE, 0, SPIF_SENDWININICHANGE); 
    }
}

// Rename the old winbom when going into factory or reseal so that we don't use it again by mistake.
static BOOL RenameWinbom()
{
    BOOL           bRet         = TRUE;
    static LPTSTR  lpszWinbom   = NULL;
    static BOOL    bInitialized = FALSE;

    if ( !bInitialized )
    {
        // Only bother to try if we are in audit mode and there
        // is a winbom in use.
        //
        if ( RegCheck(HKLM, _T("SYSTEM\\Setup"), _T("AuditInProgress")) )
        {
            lpszWinbom = RegGetExpand(HKLM, _T("SOFTWARE\\Microsoft\\Factory\\State"), _T("Winbom"));
        }
        
        bInitialized = TRUE;
    }
    else if ( lpszWinbom )
    {
        // Make sure the winbom in the registry exists.
        //
        if ( *lpszWinbom && FileExists(lpszWinbom) )
        {
            LPTSTR  lpszExtension;
            TCHAR   szBackup[MAX_PATH];
            DWORD   dwExtra;

            // At this point, if we don't rename the file then it
            // means there was an error.
            //
            bRet = FALSE;

            // Copy the full path to the winbom into our own buffer.
            //
            lstrcpyn(szBackup, lpszWinbom, AS(szBackup));

            // Get a pointer to the extension of the file name.
            //
            if ( lpszExtension = StrRChr(szBackup, NULL, _T('.')) )
            {
                // Set the extension pointer to after the '.' character.
                //
                lpszExtension = CharNext(lpszExtension);

                // See how many characters are in the current extension.
                //
                if ( (dwExtra = lstrlen(lpszExtension)) < 3 )
                {
                    // There is less then a 3 character extension, so
                    // we need some extra space for our 3 digit one.
                    //
                    dwExtra = 3 - dwExtra;
                }
                else
                {
                    // If there are already at least 3 characters in
                    // the exension, then no more space is required.
                    //
                    dwExtra = 0;
                }
            }
            else
            {
                // No extension, so we need 4 characters extra for
                // the '.' and the 3 digit extension.
                //
                dwExtra = 4;
            }

            // Make sure there is enough room for our extension to be
            // added to our buffer.
            //
            if ( ( lstrlen(lpszWinbom) < AS(szBackup) ) &&
                 ( lstrlen(szBackup) + dwExtra < AS(szBackup) ) )
            {
                DWORD dwNum = 0;

                // If there is no extension, add the dot.
                //
                if ( NULL == lpszExtension )
                {
                    // Add our '.' to the end of the string, and set the
                    // extension pointer past it.
                    //
                    lpszExtension = szBackup + lstrlen(szBackup);
                    *lpszExtension = _T('.');
                    lpszExtension = CharNext(lpszExtension);
                }

                // Try to find out new file name.  Keep increasing our
                // number from 000 until we find a name that doesn't exist.
                //
                do
                {
                    StringCchPrintf ( lpszExtension, AS ( szBackup ) - ( szBackup - lpszExtension), _T("%3.3d"), dwNum);
                }
                while ( ( FileExists(szBackup) ) &&
                        ( ++dwNum < 1000 ) );

                // If we found a name that doesn't exist, rename
                // the winbom.
                //
                if ( dwNum < 1000 )
                {
                    // If the move works, then return success.
                    //
                    bRet = MoveFile(lpszWinbom, szBackup);
                }
            }
        }

        // Free the buffer allocated.
        //
        FREE(lpszWinbom);
    }

    // Return TRUE if we didn't need to rename the winbom,
    // or we were able to do so successfully.
    //
    return bRet;
}

#if !defined(_WIN64)
  
static BOOL SaveDiskSignature()
{
    BOOL                bRet                = FALSE;
    WCHAR               szBuf[MAX_PATH]     = NULLSTR;
    HANDLE              hDisk;
    DWORD               dwBytesReturned     = 0;
    TCHAR               cDriveLetter;

    szBuf[0] = NULLCHR;
    if ( GetWindowsDirectory(szBuf, AS(szBuf)) && szBuf[0] )
    {
        // We only need the drive letter from this.
        cDriveLetter = szBuf[0];
        StringCchPrintf ( szBuf, AS ( szBuf ), _T("\\\\.\\%c:"), cDriveLetter);
    }
    else
    {
        return FALSE;
    }

    // Attempt to open the file
    //
    hDisk = CreateFile( szBuf,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    // Check to see if we were able to open the disk
    //
    if ( INVALID_HANDLE_VALUE == hDisk )
    {
        bRet = FALSE;
        DbgPrint("SaveDiskSignature(): Unable to open file on %ws. Error (%lx)\n", szBuf, GetLastError());
    }
    else
    {
        PDRIVE_LAYOUT_INFORMATION_EX    pLayoutInfoEx   = NULL;
        ULONG                           lengthLayoutEx  = 0;
        
        DbgPrint("SaveDiskSignature(): Successfully opened file on %ws\n", szBuf);

        lengthLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * 128);
        pLayoutInfoEx = (PDRIVE_LAYOUT_INFORMATION_EX) MALLOC( lengthLayoutEx );
        
        if ( pLayoutInfoEx )
        {
            // Attempt to get the drive layout
            //
            bRet = DeviceIoControl( hDisk, 
                                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX, 
                                    NULL, 
                                    0, 
                                    pLayoutInfoEx, 
                                    lengthLayoutEx, 
                                    &dwBytesReturned, 
                                    NULL
                                    );

            // Check the status of the drive layout
            //
            if ( bRet )
            {   // Only do this on MBR disks
                //
                if ( PARTITION_STYLE_MBR == pLayoutInfoEx->PartitionStyle )
                {
                    // Only set this value on MBR disks.
                    //
                    if ( !RegSetDword(HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSTEM_SETUP, REGSTR_VAL_DISKSIG, pLayoutInfoEx->Mbr.Signature) )
                    {
                        DbgPrint("SaveDiskSignature(): Cannot write disk signature to registry\n.");
                        bRet = FALSE;
                    }
                }
                else
                {   // bRet = TRUE at this point.
                    DbgPrint("SaveDiskSignature(): Not supported on GPT disks.\n");
                }
            }
            else
            {
                DbgPrint("SaveDiskSignature(): Unable to open IOCTL on %ws. Error (%lx)\n", szBuf, GetLastError());
            }
            
            // Clean up. Macro checks for NULL;
            //
            FREE( pLayoutInfoEx );
        }
        else 
        {
            bRet = FALSE;
        }
    
        CloseHandle( hDisk );
    }
    return bRet;
}

#endif // !defined(_WIN64)


//
// Helper function for CleanupPhantomDevices.  Decides whether it is ok to remove 
// certain PNP devices.
//
BOOL
CanDeviceBeRemoved(
    HDEVINFO DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData,
    PTSTR DeviceInstanceId
    )
{
    BOOL bCanBeRemoved = TRUE;

    if (_tcsicmp(DeviceInstanceId, TEXT("HTREE\\ROOT\\0")) == 0) {
        //
        // The device has the DeviceInstanceId of HTREE\ROOT\0 then it is the
        // root of the device tree and can NOT be removed!
        //
        bCanBeRemoved = FALSE;
    } else if (_tcsnicmp(DeviceInstanceId, TEXT("SW\\"), lstrlen(TEXT("SW\\"))) == 0) {
        //
        // If the DeviceInstanceId starts with SW\\ then it is a swenum (software
        // enumerated) device and should not be removed.
        //
        bCanBeRemoved = FALSE;
    } else if (IsEqualGUID(&(DeviceInfoData->ClassGuid), &GUID_DEVCLASS_LEGACYDRIVER)) {
        //
        // If the device is of class GUID_DEVCLASS_LEGACYDRIVER then do not 
        // uninstall it.
        //
        bCanBeRemoved = FALSE;
    }

    return bCanBeRemoved;
}


//
// Cleans up phantom PNP devices.  This is useful for cleaning up devices that existed
// on the machine that was imaged but do not exist on the target machine.
//
static INT
CleanupPhantomDevices(
    VOID
    )
{
    HDEVINFO DeviceInfoSet;
    HDEVINFO InterfaceDeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    INT DevicesRemoved = 0;
    INT MemberIndex, InterfaceMemberIndex;
    DWORD Status, Problem;
    CONFIGRET cr;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

    //
    // Get a list of all the devices on this machine, including present (live)
    // and not present (phantom) devices.
    //
    DeviceInfoSet = SetupDiGetClassDevs(NULL,
                                        NULL,
                                        NULL,
                                        DIGCF_ALLCLASSES
                                        );

    if (DeviceInfoSet != INVALID_HANDLE_VALUE) {

        DeviceInfoData.cbSize = sizeof(DeviceInfoData);
        MemberIndex = 0;

        //
        // Enumerate through the list of devices.
        //
        while (SetupDiEnumDeviceInfo(DeviceInfoSet,
                                     MemberIndex++,
                                     &DeviceInfoData
                                     )) {

            //
            // Check if this device is a Phantom
            //
            cr = CM_Get_DevNode_Status(&Status,
                                       &Problem,
                                       DeviceInfoData.DevInst,
                                       0
                                       );

            if ((cr == CR_NO_SUCH_DEVINST) ||
                (cr == CR_NO_SUCH_VALUE)) {

                //
                // This is a phantom.  Now get the DeviceInstanceId so we
                // can display/log this as output.
                //
                if (SetupDiGetDeviceInstanceId(DeviceInfoSet,
                                               &DeviceInfoData,
                                               DeviceInstanceId,
                                               sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                               NULL)) {

                    if (CanDeviceBeRemoved(DeviceInfoSet,
                                           &DeviceInfoData,
                                           DeviceInstanceId)) {


#ifdef DEBUG_LOGLOG
                        LOG_Write(L"CLEANUP: %s will be removed.\n", DeviceInstanceId);
#endif
                        //
                        // Call DIF_REMOVE to remove the device's hardware
                        // and software registry keys.
                        //
                        if (SetupDiCallClassInstaller(DIF_REMOVE,
                                                      DeviceInfoSet,
                                                      &DeviceInfoData
                                                      )) {
                            DevicesRemoved++;
    
                        } else {
#ifdef DEBUG_LOGLOG
                            LOG_Write(L"CLEANUP: Error 0x%X removing phantom\n", GetLastError());
#endif
                        }
                    }
                }
            }
        }

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }
    
    return DevicesRemoved;
}

#define REGSTR_PATH_PARVDM  REGSTR_PATH_SERVICES _T("\\ParVdm")
#define REGSTR_VAL_START    _T("Start")

//
// This code special cases the legacy parallel devices on a machine that is being resealed.  We must disable the
// PARVDM service and enumerate through all system parallel devices, setting them to reinstall on the next boot.
//
static VOID
CleanupParallelDevices( VOID )
{
    HDEVINFO                    DeviceInfoSet       = NULL;
    SP_DEVICE_INTERFACE_DATA    DevInterfaceData;
    SP_DEVINFO_DATA             DevInfoData;
    GUID                        Guid                = GUID_PARALLEL_DEVICE;     // GUID for all Parallel devices on the system
    DWORD                       dwConfigFlags       = 0,
                                dwIndex             = 0;

    //
    // Disable the PARVDM service
    //
    RegSetDword(HKLM, REGSTR_PATH_PARVDM, REGSTR_VAL_START, 4);

    //
    // Mark all Parallel devices for reinstall
    //

    // Get the class of devices
    //
    DeviceInfoSet = SetupDiGetClassDevs(&Guid, NULL, NULL, DIGCF_INTERFACEDEVICE);

    // Did we successfully get device list
    //
    if (DeviceInfoSet != INVALID_HANDLE_VALUE) 
    {
        // Zero out the structure and set the size
        //
        ZeroMemory( &DevInterfaceData, sizeof(DevInterfaceData) );
        DevInterfaceData.cbSize = sizeof(DevInterfaceData);
        
        // Enumerate through each device
        //
        while (DevInfoData.cbSize = sizeof(DevInfoData),
               SetupDiEnumDeviceInfo(DeviceInfoSet, dwIndex, &DevInfoData))
        {
            // Increment our indexer
            //
            dwIndex++;

            // Attempt to get the device's current config flags property
            //
            if ( SetupDiGetDeviceRegistryProperty(DeviceInfoSet, &DevInfoData, SPDRP_CONFIGFLAGS, NULL, (PVOID) &dwConfigFlags, sizeof(dwConfigFlags), NULL ) )
            {
                // OR in the reinstall flag for the property
                //
                dwConfigFlags |= CONFIGFLAG_REINSTALL;

                // Attempt to set the flag in the registry
                //
                if( !SetupDiSetDeviceRegistryProperty( DeviceInfoSet, &DevInfoData, SPDRP_CONFIGFLAGS, (PVOID)&dwConfigFlags, sizeof( dwConfigFlags ) ) )
                {
#ifdef DEBUG_LOGLOG
                    LOG_Write(L"CLEANUP: Failed to mark parallel port for reinstall.\n");
#endif
                }
                else
                {
#ifdef DEBUG_LOGLOG
                    LOG_Write(L"CLEANUP: Successfully marked parallel port for reinstall.\n");
#endif
                }
            }
        }

        // Clean up the set list
        //
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }
    
    return;
}


// Cleans unused services and phantom PNP devices.
//
static VOID CleanUpDevices()
{
    // Cleanup the services that we installed in the [SysprepMassStorage] section.
    //
    CleanDeviceDatabase();
    
    // Cleanup phantom devices.
    //
    CleanupPhantomDevices();
}



BOOL
CheckOSVersion(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine returns TRUE if the OS that we're running on
    meets the specified criteria.

Arguments:

    NONE

Return Value:

    TRUE - OS meets all criteria.

    FALSE - Failed to meet some criteria.

===============================================================================
--*/

{
    OSVERSIONINFOEX     OsVersionEx = {0};
    BOOL                bRet        = FALSE;
    
    //
    // Get the OS version.  We need to make sure we're on NT5. We need to make sure we are not a DC,
    // except if the user specified that he wants to sysprep a DC on the command line and we're running on SBS.
    //
    OsVersionEx.dwOSVersionInfoSize = sizeof(OsVersionEx);
    
    if ( ( GetVersionEx( (LPOSVERSIONINFO) &OsVersionEx) ) &&
         ( OsVersionEx.dwMajorVersion >= 5 ) )
    {
         if ( bDC && ( OsVersionEx.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED ) )
         {
             bRet = TRUE;
         }
         else
         {
             PSERVER_INFO_101 pSI = NULL;

            //
            // Make sure we're not a Domain Controller (either primary or backup)
            //
            if ( ( NERR_Success == NetServerGetInfo( NULL, 101, (LPBYTE *) &pSI ) ) &&
                 ( pSI ) &&
                 !( pSI->sv101_type & SV_TYPE_DOMAIN_CTRL ) &&
                 !( pSI->sv101_type & SV_TYPE_DOMAIN_BAKCTRL ) )
            {
                // He's not a DC. Succeed.
                //
                bRet = TRUE;
            }
            
            // Free up the buffer allocated by NetServerGetInfo.
            //
            if ( pSI )
            {
                NetApiBufferFree( pSI );
            }
        }
    }

    return bRet;
}

BOOL RememberAndClearMountMgrSettings(
    VOID
    )
    /*++
===============================================================================
Routine Description:

   Saves the current MountMgr noautomount setting to the sysprep keys and clears 
   it from the MountMgr service key.

Arguments:

    NONE

Return Value:

    TRUE - Operations succeeded.

    FALSE - Operations failed.

===============================================================================
--*/
{
    BOOL  bRet = TRUE;
    DWORD dwNoAutoMount = 0;
    
    if ( RegExists( HKLM,  REGSTR_PATH_SERVICES_MOUNTMGR, REGSTR_VAL_NOAUTOMOUNT ) )
    {
        dwNoAutoMount = RegGetDword( HKLM, REGSTR_PATH_SERVICES_MOUNTMGR, REGSTR_VAL_NOAUTOMOUNT );

        if ( !( RegDelete  ( HKLM, REGSTR_PATH_SERVICES_MOUNTMGR, REGSTR_VAL_NOAUTOMOUNT ) &&
                RegSetDword( HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_NOAUTOMOUNT, dwNoAutoMount ) ) )
        {
            bRet = FALSE;
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\opktools\sysprep\sysprep.h ===
// Registry constants
//
#define REGSTR_PATH_CURRENTVERSION          _T("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_CURRENTVERSION_SETUP    REGSTR_PATH_CURRENTVERSION _T("\\Setup")
#define REGSTR_PATH_SYSTEM_SETUP            _T("System\\Setup")
#define REGSTR_VALUE_AUDIT                  _T("AuditInProgress")
#define REGSTR_VAL_OEMRESET                 _T("OEMReset")
#define REGSTR_VAL_OEMCLEANUP               _T("OEMCLEANUP")
#define REGSTR_VAL_OEMRESETSWITCH           _T("OEMReset_Switch")
#define REGSTR_VAL_MASS_STORAGE             _T("CriticalDevicesInstalled")
#define REGSTR_PATH_SYSPREP                 _T("Software\\Microsoft\\Sysprep")
#define REGSTR_VAL_SIDGEN                   _T("SidsGenerated")
#define REGSTR_VAL_SIDGENHISTORY            _T("SidsGeneratedHistory")
#define REGSTR_VAL_DISKSIG                  _T("BootDiskSig")
#define REGSTR_PATH_SERVICES_MOUNTMGR       _T("System\\CurrentControlSet\\Services\\MountMgr")
#define REGSTR_VAL_NOAUTOMOUNT              _T("NoAutoMount")



// INF constants
//
#define INF_SEC_AUDITING            _T("Auditing")          // Section in oemaudit.inf
#define INF_SEC_SYSTEM_RESTORE      _T("System_restore")    // Section processed in oemaudit.inf
#define INF_SEC_OEMRESET            _T("OEMRESET")          // Section in oemaudit.inf



// Global defines
//
#define SYSPREP_SHUTDOWN_FLAGS    SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_INSTALLATION


// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

BOOL
CheckParams(
    LPSTR lpCmdLine
    );

extern BOOL
NukeMruList(
    VOID
    );

extern BOOL
IsSetupClPresent(
    VOID
    );

extern BOOL
IsUserAdmin(
    VOID
    );

extern BOOL
CheckOSVersion(
    VOID
    );

extern BOOL
IsDomainMember(
    VOID
    );

extern BOOL
DoesUserHavePrivilege(
    PCTSTR
    );

extern BOOL
EnablePrivilege(
    IN PCTSTR,
    IN BOOL
    );

extern BOOL
FDoFactoryPreinstall(
    VOID
    );

extern VOID
ShowOemresetDialog(
    HINSTANCE
    );

BOOL 
ResealMachine(
    VOID
    );

BOOL 
FPrepareMachine(
    VOID
    );


BOOL LockApplication(
    BOOL
    );

VOID
ShutdownOrReboot(
    UINT uFlags,
    DWORD dwReserved
    );

VOID 
SysprepShutdown(
    VOID
    );

BOOL
CheckOSVersion(
    VOID
    );

BOOL
RememberAndClearMountMgrSettings(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\debug.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    debug.c

Abstract:

    Debug infrastructure for this component.

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "debug.h"


//
// debug infrastructure
//

#if DBG

VOID
pSifDebugPrintEx(
    DWORD  Level,
    PCTSTR Format,
    ...              OPTIONAL
    )

/*++

Routine Description:

    Send a formatted string to the debugger.
    Note that this is expected to work cross-platform, but use preferred debugger

Arguments:

    Format - standard printf format string.

Return Value:

    NONE.

--*/

{
    typedef ULONG (__cdecl *PFNDbgPrintEx)(IN ULONG ComponentId,IN ULONG Level,IN PCH Format, ...);

    static PFNDbgPrintEx pfnDbgPrintEx = NULL;
    static BOOL fInitDebug = FALSE;

    TCHAR buf[1026];    // bigger than max size
    va_list arglist;

    if (!fInitDebug) {
        pfnDbgPrintEx = (PFNDbgPrintEx)GetProcAddress(GetModuleHandle(TEXT("NTDLL")), "DbgPrintEx");
        fInitDebug = TRUE;
    }

    va_start(arglist, Format);

    if (FAILED(StringCchVPrintf(buf, 1026, Format, arglist))) {
        return;
    }

    if (pfnDbgPrintEx) {
#ifdef UNICODE
        (*pfnDbgPrintEx)(DPFLTR_SETUP_ID, Level, "%ls",buf);
#else
        (*pfnDbgPrintEx)(DPFLTR_SETUP_ID, Level, "%s",buf);
#endif
    } else {
        OutputDebugString(buf);
    }

    return;
}


ULONG
DebugPrint(
    IN ULONG    Level,
    IN PCHAR    Format,
    ...
    )
{
    va_list ap;

    va_start(ap, Format);

    KdPrintEx((DPFLTR_PNPMGR_ID, Level, Format, ap));

    va_end(ap);

    return Level;
}

#else

NOTHING;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\migrate.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    migrate.c

Abstract:

    This module contains the code necessary for Plug and Play to prepare the
    necessary state during a winnt32.exe upgrade or an ASR (Automated System
    Recovery) backup operation.  Typically, these aspects of the Plug and Play
    registry are saved in a sif for later use, during the text-mode setup
    portion of an upgrade or ASR recovery operation.

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "debug.h"
#include "util.h"

#include <aclapi.h>
#include <regstr.h>
#include <pnpmgr.h>
#include <cfgmgr32.h>


//
// definitions
//

// do the lock/unlock Enum security thing? (as taken from PNPREG)
#define DO_LOCK_UNLOCK 0


//
// memory allocation macros
// (always use LocalAlloc/LocalReAlloc so that the caller can LocalFree the
// returned buffer.)
//

#define MyMalloc(size)         LocalAlloc(0, size);
#define MyFree(entry)          LocalFree(entry);
#define MyRealloc(entry,size)  LocalReAlloc(entry, size, LMEM_MOVEABLE | LMEM_ZEROINIT);


//
// globals for the Enum branch lock/unlock and security routines - taken from PNPREG
// (we only need these if we're doing the Enum lock/unlock thing)
//

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

PSID     g_pAdminSid;
PSID     g_pSystemSid;
PSID     g_pWorldSid;

SECURITY_DESCRIPTOR g_DeviceParametersSD;
PACL     g_pDeviceParametersDacl;

SECURITY_DESCRIPTOR g_LockedPrivateKeysSD;
PACL     g_pLockedPrivateKeysDacl;

#if 0 //#if DBG // DBG
TCHAR   g_szCurrentKeyName[4096];
DWORD   g_dwCurrentKeyNameLength = 0;
#endif  // DBG

#endif  // DO_LOCK_UNLOCK


//
// public prototypes
//

BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );


//
// private prototypes
//

BOOL
EnumerateDeviceKeys(
    IN     HKEY     CCSEnumKey,
    IN     LPTSTR   Enumerator,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    );

BOOL
EnumerateInstanceKeys(
    IN     HKEY     EnumeratorKey,
    IN     LPTSTR   Enumerator,
    IN     LPTSTR   Device,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    );

BOOL
EnumerateClassSubkeys(
    IN     HKEY     ClassKey,
    IN     LPTSTR   ClassKeyName,
    IN OUT LPTSTR  *pszClassKeySection,
    IN OUT LPTSTR  *pszClassKeyCurrent,
    IN OUT DWORD   *dwClassKeySectionLength,
    IN OUT DWORD   *dwClassKeySectionRemaining
    );

BOOL
CanStringBeMigrated(
    IN LPTSTR       pszBuffer
    );


// we only need these if we're doing the Enum lock/unlock thing
#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

VOID
LockUnlockEnumTree(
    IN  BOOL     bLock
    );

VOID
EnumKeysAndApplyDacls(
    IN HKEY      hParentKey,
    IN LPTSTR    pszKeyName,
    IN DWORD     dwLevel,
    IN BOOL      bInDeviceParameters,
    IN BOOL      bApplyTopDown,
    IN PSECURITY_DESCRIPTOR pPrivateKeySD,
    IN PSECURITY_DESCRIPTOR pDeviceParametersSD
    );

BOOL
CreateSecurityDescriptors(
    VOID
    );

VOID
FreeSecurityDescriptors(
    VOID
    );

#endif // DO_LOCK_UNLOCK


//
// Device instance enumeration routines
//


BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    )
/*++

Routine Description:

    This routine walks the Plug and Play Enum tree in the registry, and collects
    the data that is relevant to restoring this state during textmode setup.

    Specifically, a multi-sz string will be returned to the caller that contains
    migration data for the UniqueParentID, ParentIdPrefix, and Driver registry
    values for all device instances in the Enum tree.

Arguments:

    Buffer - Supplies the address of a character pointer, that on success will
             contain a multi-sz list of device instances and relevant values to
             migrate.

             The caller is responsible for freeing the memory via LocalFree.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hEnumKey = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, i;
    LPTSTR pszEnumerator = NULL;

    LPTSTR pszDeviceInstanceSection = NULL;
    LPTSTR pszDeviceInstanceCurrent = NULL;

    DWORD  dwDeviceInstanceSectionLength = 0;
    DWORD  dwDeviceInstanceSectionRemaining = 0;


    //
    // Initialize the output parameter.
    //
    *Buffer = NULL;

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Unlock the Enum key.
    //
    LockUnlockEnumTree(FALSE);

#endif // DO_LOCK_UNLOCK

    //
    // Allocate storage and initialize variables for the device instance
    // migration section.
    //
    if (pszDeviceInstanceSection == NULL) {

        dwDeviceInstanceSectionLength = dwDeviceInstanceSectionRemaining = 256;
        pszDeviceInstanceSection = MyMalloc(dwDeviceInstanceSectionLength * sizeof(TCHAR));

        if (!pszDeviceInstanceSection) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("MigrateDeviceInstanceData: initial ALLOC for ClassKeySection failed!!\n")));
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pszDeviceInstanceCurrent = pszDeviceInstanceSection;
    }

    //
    // Open a handle to the HKLM\SYSTEM\CCS\Enum key.
    //
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_SYSTEMENUM,
                          0,
                          KEY_READ,
                          &hEnumKey);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateDeviceInstanceData: failed to open %s, ")
                  TEXT("error=0x%08lx\n"),
                  REGSTR_PATH_SYSTEMENUM, result));
        hEnumKey = NULL;
        goto Clean0;
    }

    //
    // Query the Enum key for enumerator subkey information.
    //
    result = RegQueryInfoKey(hEnumKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateDeviceInstanceData: failed to query %s key, ")
                  TEXT("error=0x%08lx\n"),
                  REGSTR_PATH_SYSTEMENUM, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest enumerator key name.
    //
    dwMaxSubKeyLength++;
    pszEnumerator = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszEnumerator) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateDeviceInstanceData: failed to allocate buffer for Enum subkeys\n")));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate the enumerator subkeys.
    //
    for (i = 0; i < dwSubkeyCount; i++) {
        DWORD dwEnumeratorLength = dwMaxSubKeyLength;

        result = RegEnumKeyEx(hEnumKey,
                              i,
                              pszEnumerator,
                              &dwEnumeratorLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE((DBGF_WARNINGS,
                      TEXT("MigrateDeviceInstanceData: failed to enumerate an enumerator subkey, ")
                      TEXT("error=0x%08lx\n"),
                      result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Enumerate the devices and device instances for this enumerator, and
        // append the migration data for each to the section buffer.
        //
        if (!EnumerateDeviceKeys(hEnumKey,
                                 pszEnumerator,
                                 &pszDeviceInstanceSection,
                                 &pszDeviceInstanceCurrent,
                                 &dwDeviceInstanceSectionLength,
                                 &dwDeviceInstanceSectionRemaining)) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("MigrateDeviceInstanceData: EnumerateDeviceKeys failed, error=0x%08lx\n"),
                      GetLastError()));
        }

    }

    //
    // Once we've enumerated all device instances, add the final NULL terminator
    // to the multi-sz buffer.  There must be enough space for the final NULL
    // terminator because the buffer is always reallocated unless there is room.
    //
    MYASSERT(dwDeviceInstanceSectionRemaining > 0);

    MYASSERT(pszDeviceInstanceCurrent);
    *pszDeviceInstanceCurrent = TEXT('\0');

    dwDeviceInstanceSectionRemaining -= 1;

 Clean0:

    //
    // Do some cleanup.
    //
    if (pszEnumerator) {
        MyFree(pszEnumerator);
    }

    if (hEnumKey) {
        RegCloseKey(hEnumKey);
    }

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Lock the Enum tree.
    //
    LockUnlockEnumTree(TRUE);

#endif // DO_LOCK_UNLOCK

    //
    // Return the buffer to the caller only if successful.
    //
    if (result == ERROR_SUCCESS) {
        *Buffer = pszDeviceInstanceSection;
    } else {
        SetLastError(result);
        if (pszDeviceInstanceSection) {
            MyFree(pszDeviceInstanceSection);
        }
    }
    return (result == ERROR_SUCCESS);

} // MigrateDeviceInstanceData()



BOOL
EnumerateDeviceKeys(
    IN     HKEY     CCSEnumKey,
    IN     LPTSTR   Enumerator,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    )
/*++

Routine Description:

    Enumerates device keys of an enumerator.
    Worker routine for MigrateDeviceInstanceData.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result;
    HKEY   hEnumeratorKey = NULL;
    LPTSTR pszDeviceName = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, dwDeviceLength, i;


    //
    // Open the enumerator key, under HKLM\SYSTEM\CCS\Enum.
    //
    result = RegOpenKeyEx(CCSEnumKey,
                          Enumerator,
                          0,
                          KEY_READ,
                          &hEnumeratorKey);

    if (result != ERROR_SUCCESS) {
        //
        // If we failed to open the Enumerator key, there's nothing we can do.
        //
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateDeviceKeys: failed to open '%s' enumerator key, error=0x%08lx\n"),
                  Enumerator, result));
        hEnumeratorKey = NULL;
        goto Clean0;
    }

    //
    // Query the enumerator key for device subkey information.
    //
    result = RegQueryInfoKey(hEnumeratorKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateDeviceKeys: failed to query '%s' enumerator key, ")
                  TEXT("error=0x%08lx\n"),
                  Enumerator, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest device subkey name.
    //
    dwMaxSubKeyLength++;
    pszDeviceName = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszDeviceName) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateDeviceKeys: failed to allocate buffer for device subkeys of '%s'\n"),
                  Enumerator));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate the enumerator's devices.
    //
    for (i = 0; i < dwSubkeyCount; i++) {
        dwDeviceLength = dwMaxSubKeyLength;
        result = RegEnumKeyEx(hEnumeratorKey,
                              i,
                              pszDeviceName,
                              &dwDeviceLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this device key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE((DBGF_WARNINGS,
                      TEXT("EnumerateDeviceKeys: failed to enumerate device subkey for '%s', ")
                      TEXT("error=0x%08lx\n"),
                      Enumerator, result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Enumerate the device instances, and append the migration data for
        // each to the section buffer.
        //
        if (!EnumerateInstanceKeys(hEnumeratorKey,
                                   Enumerator,
                                   pszDeviceName,
                                   pszDeviceInstanceSection,
                                   pszDeviceInstanceCurrent,
                                   dwDeviceInstanceSectionLength,
                                   dwDeviceInstanceSectionRemaining)) {

            DBGTRACE((DBGF_ERRORS,
                      TEXT("EnumerateDeviceKeys: EnumerateInstanceKeys failed for %s\\%s, ")
                      TEXT("error=0x%08lx\n"),
                      Enumerator, pszDeviceName,
                      GetLastError()));
        }
    }

 Clean0:

    //
    // Do some cleanup
    //
    if (pszDeviceName) {
        MyFree(pszDeviceName);
    }

    if (hEnumeratorKey) {
        RegCloseKey(hEnumeratorKey);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }

    return (result == ERROR_SUCCESS);

} // EnumerateDeviceKeys()



BOOL
EnumerateInstanceKeys(
    IN     HKEY     EnumeratorKey,
    IN     LPTSTR   Enumerator,
    IN     LPTSTR   Device,
    IN OUT LPTSTR  *pszDeviceInstanceSection,
    IN OUT LPTSTR  *pszDeviceInstanceCurrent,
    IN OUT DWORD   *dwDeviceInstanceSectionLength,
    IN OUT DWORD   *dwDeviceInstanceSectionRemaining
    )
/*++

Routine Description:

    Enumerates instance keys of a device.
    Worker routine for EnumerateDeviceKeys,MigrateDeviceInstanceData.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hDeviceKey = NULL;
    LPTSTR pszDeviceInstanceId = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, dwSpaceNeeded, dwSpaceConsumed, i;
    BOOL   bIsDeviceRootEnumerated;

    //
    // Keep track of whether this is a ROOT enumerated device.
    // Note, both strings are NULL terminated.
    //
    if (CompareString(LOCALE_INVARIANT,
                      NORM_IGNORECASE,
                      Enumerator,
                      -1,
                      REGSTR_KEY_ROOTENUM,
                      -1) == CSTR_EQUAL) {
        bIsDeviceRootEnumerated = TRUE;
    } else {
        bIsDeviceRootEnumerated = FALSE;
    }

    //
    // If this is a LEGACY_ ROOT enumerated device, don't bother migrating it
    // for textmode setup to see.
    //
    if (bIsDeviceRootEnumerated) {

        int x,y,len;

        //
        // Perform a locale-invariant, case-insensitive comparison of the device
        // id with the prefix "LEGACY_", up to either the full length of the
        // device id, or the number of characters in the "LEGACY_" prefix
        // string.
        //
        x = lstrlen(Device);
        y = lstrlen(TEXT("LEGACY_"));
        len = min(x,y);

        if (CompareString(LOCALE_INVARIANT,
                          NORM_IGNORECASE,
                          Device,
                          len,
                          TEXT("LEGACY_"),
                          -1) == CSTR_EQUAL) {
            return TRUE;
        }
    }

    //
    // Open the device key, under the enumerator key.
    //
    result = RegOpenKeyEx(EnumeratorKey,
                          Device,
                          0,
                          KEY_READ,
                          &hDeviceKey);

    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateInstanceKeys: failed to open '%s\\%s' device key, ")
                  TEXT("error=0x%08lx\n"),
                  Enumerator, Device, result));
        hDeviceKey = NULL;
        goto Clean0;
    }

    //
    // Query the device key for instance subkey information.
    //
    result = RegQueryInfoKey(hDeviceKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateInstanceKeys: failed to query '%s\\%s' device key, ")
                  TEXT("error=0x%08lx\n"),
                  Enumerator, Device, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest device instance subkey name.
    //
    dwMaxSubKeyLength++;
    pszDeviceInstanceId = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszDeviceInstanceId) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateInstanceKeys: failed to allocate buffer ")
                  TEXT("for instance subkeys of '%s\\%s'\n"),
                  Enumerator, Device));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate the device's instances.
    //
    for (i = 0; i < dwSubkeyCount; i++) {

        DWORD  dwInstanceLength, dwType, dwBufferSize;
        DWORD  dwUniqueParentID, dwFirmwareIdentified;
        TCHAR  szParentIdPrefix[MAX_PATH];
        TCHAR  szUniqueParentID[11], szFirmwareIdentified[11];
        TCHAR  szDriver[2*MAX_PATH + 1];
        GUID   classGuid;
        DWORD  dwDrvInst;
        HKEY   hInstanceKey = NULL, hLogConfKey = NULL;
        TCHAR  szService[MAX_PATH];
        PBYTE  pBootConfig = NULL;
        LPTSTR pszBootConfig = NULL;
        DWORD  dwBootConfigSize = 0;

        dwInstanceLength = dwMaxSubKeyLength;
        result = RegEnumKeyEx(hDeviceKey,
                              i,
                              pszDeviceInstanceId,
                              &dwInstanceLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE((DBGF_WARNINGS,
                      TEXT("EnumerateInstanceKeys: failed to enumerate instance subkey of '%s\\%s', ")
                      TEXT("error=0x&08lx\n"),
                      Enumerator, Device,
                      result));
            result = ERROR_SUCCESS;
            continue;
        }

        result = RegOpenKeyEx(hDeviceKey,
                              pszDeviceInstanceId,
                              0,
                              KEY_READ,
                              &hInstanceKey);
        if (result != ERROR_SUCCESS) {
            //
            // In unable to open the enumerated key, skip it.
            //
            DBGTRACE((DBGF_WARNINGS,
                      TEXT("EnumerateInstanceKeys: failed to open '%s\\%s\\%s', ")
                      TEXT("error=0x%08lx\n"),
                      Enumerator, Device, pszDeviceInstanceId,
                      result));
            hInstanceKey = NULL;
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Check for the "UniqueParentID" value
        //
        dwBufferSize = sizeof(dwUniqueParentID);
        result = RegQueryValueEx(hInstanceKey,
                                 REGSTR_VALUE_UNIQUE_PARENT_ID,
                                 0,
                                 &dwType,
                                 (LPBYTE)&dwUniqueParentID,
                                 &dwBufferSize);
        if ((result == ERROR_SUCCESS) &&
            (dwType == REG_DWORD)){
            //
            // Write the UniqueParentID value to the sif as a base 16 value.
            // (see base\ntsetup\textmode\kernel\spsetup.c)
            //
            if (FAILED(StringCchPrintfEx(
                           szUniqueParentID,
                           SIZECHARS(szUniqueParentID),
                           NULL, NULL,
                           STRSAFE_NULL_ON_FAILURE,
                           TEXT("%X"), // base 16
                           dwUniqueParentID))) {
                //
                // String set to NULL on failure.
                //
                NOTHING;
            }
        } else {
            //
            // No "UniqueParentID" value to migrate.
            //
            *szUniqueParentID = TEXT('\0');
            result = ERROR_SUCCESS;
        }

        //
        // Check for the "ParentIdPrefix" value
        //
        dwBufferSize = sizeof(szParentIdPrefix);
        result = RegQueryValueEx(hInstanceKey,
                                 REGSTR_VALUE_PARENT_ID_PREFIX,
                                 0,
                                 &dwType,
                                 (LPBYTE)szParentIdPrefix,
                                 &dwBufferSize);
        if ((result != ERROR_SUCCESS) ||
            (dwType != REG_SZ)) {
            //
            // No "ParentIdPrefix" value to migrate.
            //
            *szParentIdPrefix = TEXT('\0');
            result = ERROR_SUCCESS;
        }

        //
        // Build the device's Driver key name by checking for the GUID and
        // DrvInst values.
        //
        *szDriver = TEXT('\0');
        dwBufferSize = sizeof(classGuid);
        result = RegQueryValueEx(hInstanceKey,
                                 TEXT("GUID"),
                                 0,
                                 &dwType,
                                 (LPBYTE)&classGuid,
                                 &dwBufferSize);

        if ((result == ERROR_SUCCESS) &&
            (dwType == REG_BINARY)) {
            //
            // Get the DrvInst value for the driver key
            //
            dwBufferSize = sizeof(dwDrvInst);
            result = RegQueryValueEx(hInstanceKey,
                                     TEXT("DrvInst"),
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwDrvInst,
                                     &dwBufferSize);
            if ((result == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)) {
                if (pSifUtilStringFromGuid(&classGuid,
                                           szDriver,
                                           SIZECHARS(szDriver))) {
                    //
                    // Build the driver key
                    //
                    if (FAILED(StringCchPrintfEx(
                                   szDriver,
                                   SIZECHARS(szDriver),
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   TEXT("%s\\%04u"),
                                   szDriver,
                                   dwDrvInst))) {
                        //
                        // String set to NULL on failure.
                        //
                        NOTHING;
                    }
                } else {
                    result = GetLastError();
                }
            } else {
                //
                // Generic error value so we try to find the driver value using
                // the old scheme.
                //
                result = ERROR_INVALID_PARAMETER;
            }
        } else {
            //
            // Generic error value so we try to find the driver value using
            // the old scheme.
            //
            result = ERROR_INVALID_PARAMETER;
        }

        //
        // If this device instance key is not using the new GUID\DrvInst
        // scheme, check for the "Driver" value
        //
        if (result != ERROR_SUCCESS) {
            dwBufferSize = sizeof(szDriver);
            result = RegQueryValueEx(hInstanceKey,
                                     REGSTR_VAL_DRIVER,
                                     0,
                                     &dwType,
                                     (LPBYTE)szDriver,
                                     &dwBufferSize);

            if ((result != ERROR_SUCCESS) ||
                (dwType != REG_SZ)) {
                //
                // No "Driver" value to migrate.
                //
                *szDriver = TEXT('\0');
                result = ERROR_SUCCESS;
            }
        }

        //
        // If this is a ROOT enumerated device, check for Service, BootConfig
        // and FirmwareIdentified values.
        //
        if (bIsDeviceRootEnumerated) {
            //
            // Check for the "Service" value.
            //
            dwBufferSize = sizeof(szService);
            result = RegQueryValueEx(hInstanceKey,
                                     REGSTR_VAL_SERVICE,
                                     0,
                                     &dwType,
                                     (LPBYTE)szService,
                                     &dwBufferSize);
            if ((result != ERROR_SUCCESS) ||
                (dwType != REG_SZ)) {
                //
                // No "Service" value to migrate.
                //
                *szService = TEXT('\0');
                result = ERROR_SUCCESS;
            }

            //
            // Check for the "LogConf\BootConfig" value.
            //
            result = RegOpenKeyEx(hInstanceKey,
                                  REGSTR_KEY_LOGCONF,
                                  0,
                                  KEY_READ,
                                  &hLogConfKey);
            if (result == ERROR_SUCCESS) {
                result = RegQueryValueEx(hLogConfKey,
                                         REGSTR_VAL_BOOTCONFIG,
                                         0,
                                         &dwType,
                                         (LPBYTE)NULL,
                                         &dwBootConfigSize);
                if ((result == ERROR_SUCCESS) &&
                    (dwType == REG_RESOURCE_LIST)) {

                    pBootConfig = MyMalloc(dwBootConfigSize);
                    if (pBootConfig) {
                        result = RegQueryValueEx(hLogConfKey,
                                                 REGSTR_VAL_BOOTCONFIG,
                                                 0,
                                                 &dwType,
                                                 (LPBYTE)pBootConfig,
                                                 &dwBootConfigSize);
                        if ((result == ERROR_SUCCESS) &&
                            (dwType == REG_RESOURCE_LIST)) {
                            //
                            // Allocate a string buffer large enough to store
                            // each nibble of the BootConfig data as a separate
                            // character.
                            //
                            pszBootConfig = MyMalloc(((2*dwBootConfigSize) + 1)*sizeof(TCHAR));

                            if (pszBootConfig) {
                                DWORD b;

                                //
                                // Convert the binary BootConfig data to a string
                                // format that we can throw into the sif.
                                //
                                for (b = 0; b < dwBootConfigSize; b++) {
                                    // first write the high-order nibble,
                                    if (FAILED(StringCchPrintf(
                                                   (PTCHAR)&pszBootConfig[2*b],
                                                   ((2 * dwBootConfigSize) + 1) - (2 * b),
                                                   TEXT("%01X"),
                                                   pBootConfig[b] / (0x10)))) {
                                        //
                                        // Char set to NULL on failure.
                                        //
                                        NOTHING;
                                    }
                                    // then the low order nibble.
                                    if (FAILED(StringCchPrintf(
                                                   (PTCHAR)&pszBootConfig[2*b + 1],
                                                   ((2 * dwBootConfigSize) + 1) - ((2 * b) + 1),
                                                   TEXT("%01X"),
                                                   pBootConfig[b] % (0x10)))) {
                                        //
                                        // Char set to NULL on failure.
                                        //
                                        NOTHING;
                                    }
                                }
                            }

                        } else {
                            //
                            // We won't be able to migrate BootConfig data, but
                            // we'll still try to migrate any other settings for the
                            // device instance that we can.
                            //
                            pszBootConfig = NULL;
                            result = ERROR_SUCCESS;
                        }

                        MyFree(pBootConfig);
                        pBootConfig = NULL;

                    } else {
                        //
                        // We won't be able to migrate BootConfig data, but
                        // we'll still try to migrate any other settings for the
                        // device instance that we can.
                        //
                        NOTHING;
                    }

                } else {
                    //
                    // No "LogConf\BootConfig" value to migrate.
                    //
                    pszBootConfig = NULL;
                    result = ERROR_SUCCESS;
                }

                RegCloseKey(hLogConfKey);
                hLogConfKey = NULL;

            } else {
                //
                // No "LogConf" key, or unable to open it.  Just continue on
                // with the other values.
                //
                hLogConfKey = NULL;
                result = ERROR_SUCCESS;
            }

            //
            // Check for the "FirmwareIdentified" value
            //
            dwBufferSize = sizeof(dwFirmwareIdentified);
            result = RegQueryValueEx(hInstanceKey,
                                     REGSTR_VAL_FIRMWAREIDENTIFIED,
                                     0,
                                     &dwType,
                                     (LPBYTE)&dwFirmwareIdentified,
                                     &dwBufferSize);
            if ((result == ERROR_SUCCESS) &&
                (dwType == REG_DWORD)){
                //
                // Write the FirmwareIdentified value to the sif as a base 16 value.
                // (see base\ntsetup\textmode\kernel\spsetup.c)
                //
                if (FAILED(StringCchPrintfEx(
                               szFirmwareIdentified,
                               SIZECHARS(szFirmwareIdentified),
                               NULL, NULL,
                               STRSAFE_NULL_ON_FAILURE,
                               TEXT("%X"), // base 16
                               dwFirmwareIdentified))) {
                    //
                    // String set to NULL on failure.
                    //
                    NOTHING;
                }
            } else {
                //
                // No "FirmwareIdentified" value to migrate.
                //
                *szFirmwareIdentified = TEXT('\0');
                result = ERROR_SUCCESS;
            }

        } else {
            //
            // We only migrate Service, BootConfig, and FirmwareIdentified
            // values for Root enumerated devices.
            //
            *szService = TEXT('\0');
            pszBootConfig = NULL;
            *szFirmwareIdentified = TEXT('\0');
        }


        //
        // If there are no values to migrate for this device instance, skip it.
        //
        if (!*szUniqueParentID &&
            !*szDriver &&
            !*szParentIdPrefix &&
            !*szService &&
            !pszBootConfig &&
            !*szFirmwareIdentified) {
            continue;
        }

        //
        // If any of the strings cannot be migrated, skip it.
        //
        if ((!CanStringBeMigrated(szDriver))   ||
            (!CanStringBeMigrated(szService))  ||
            (!CanStringBeMigrated(Enumerator)) ||
            (!CanStringBeMigrated(Device))     ||
            (!CanStringBeMigrated(pszDeviceInstanceId))) {
            continue;
        }

        //
        // This block appends the class key data we want to migrate to a
        // multi-sz style string that will be written to the sif file.
        //

        //
        // Need space in the section buffer for a string of the form:
        //     Enumerator\Device\Instance,UniqueParentID,ParentIdPrefix,DriverKey,Service,BootConfig
        //

        //
        // First, determine the space required by the common parts.
        //
        dwSpaceNeeded = 1 +  // TEXT('\"')
                        lstrlen(Enumerator) +
                        1 +  // TEXT('\\')
                        lstrlen(Device) +
                        1 +  // TEXT('\\')
                        lstrlen(pszDeviceInstanceId) +
                        1 +  // TEXT('\"')
                        1;   // TEXT(',')

        //
        // Next, determine the space required, based on the data we have.
        //
        if (*szFirmwareIdentified) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver) +
                1 +  // TEXT(',')
                1 +  // TEXT('"')
                lstrlen(szService) +
                1 +  // TEXT('"')
                1 +  // TEXT(',')
                (pszBootConfig ? lstrlen(pszBootConfig) : 0) +
                1 +  // TEXT(',')
                lstrlen(szFirmwareIdentified);
        } else if (pszBootConfig) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver) +
                1 +  // TEXT(',')
                1 +  // TEXT('"')
                lstrlen(szService) +
                1 +  // TEXT('"')
                1 +  // TEXT(',')
                lstrlen(pszBootConfig);
        } else if (*szService) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver) +
                1 +  // TEXT(',')
                1 +  // TEXT('"')
                lstrlen(szService) +
                1;   // TEXT('"')
        } else if (*szDriver) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix) +
                1 +  // TEXT(',')
                lstrlen(szDriver);
        } else if (*szParentIdPrefix) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID) +
                1 +  // TEXT(',')
                lstrlen(szParentIdPrefix);
        } else if (*szUniqueParentID) {
            dwSpaceNeeded +=
                lstrlen(szUniqueParentID);
        }

        //
        // Account for the NULL terminator.
        //
        dwSpaceNeeded += 1;

        if (*dwDeviceInstanceSectionRemaining <= dwSpaceNeeded) {
            //
            // ReAllocate the section block.
            //
            LPTSTR p;
            DWORD  dwTempSectionLength, dwTempSectionRemaining;

            dwTempSectionRemaining = *dwDeviceInstanceSectionRemaining + *dwDeviceInstanceSectionLength;
            dwTempSectionLength = *dwDeviceInstanceSectionLength * 2;

            p = MyRealloc(*pszDeviceInstanceSection,
                          dwTempSectionLength*sizeof(TCHAR));

            if (!p) {
                DBGTRACE((DBGF_ERRORS,
                          TEXT("EnumerateInstanceKeys: REALLOC failed!!!\n")));
                result = ERROR_NOT_ENOUGH_MEMORY;
                RegCloseKey(hInstanceKey);
                hInstanceKey = NULL;
                goto Clean0;
            }

            *pszDeviceInstanceSection = p;
            *dwDeviceInstanceSectionRemaining = dwTempSectionRemaining;
            *dwDeviceInstanceSectionLength = dwTempSectionLength;

            *pszDeviceInstanceCurrent = *pszDeviceInstanceSection +
                (*dwDeviceInstanceSectionLength -
                 *dwDeviceInstanceSectionRemaining);
        }

        MYASSERT(*dwDeviceInstanceSectionRemaining > dwSpaceNeeded);

        //
        // Have not consumed any space in the string yet.
        //
        *pszDeviceInstanceCurrent[0] = TEXT('\0');
        dwSpaceConsumed = 0;

        //
        // Write the current line to the section block.
        //
        if (*szFirmwareIdentified) {

            if (SUCCEEDED(
                    StringCchPrintfEx(
                        *pszDeviceInstanceCurrent,
                        *dwDeviceInstanceSectionRemaining,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE,
                        TEXT("\"%s\\%s\\%s\",%s,%s,%s,\"%s\",%s,%s"),
                        Enumerator, Device, pszDeviceInstanceId,
                        szUniqueParentID,
                        szParentIdPrefix,
                        szDriver,
                        szService,
                        (pszBootConfig ? pszBootConfig : TEXT("\0")),
                        szFirmwareIdentified))) {
                dwSpaceConsumed =
                    lstrlen(*pszDeviceInstanceCurrent);
            }

        } else if (pszBootConfig) {

            if (SUCCEEDED(
                    StringCchPrintfEx(
                        *pszDeviceInstanceCurrent,
                        *dwDeviceInstanceSectionRemaining,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE,
                        TEXT("\"%s\\%s\\%s\",%s,%s,%s,\"%s\",%s"),
                        Enumerator, Device, pszDeviceInstanceId,
                        szUniqueParentID,
                        szParentIdPrefix,
                        szDriver,
                        szService,
                        pszBootConfig))) {
                dwSpaceConsumed =
                    lstrlen(*pszDeviceInstanceCurrent);
            }

        } else if (*szService) {

            if (SUCCEEDED(
                    StringCchPrintfEx(
                        *pszDeviceInstanceCurrent,
                        *dwDeviceInstanceSectionRemaining,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE,
                        TEXT("\"%s\\%s\\%s\",%s,%s,%s,\"%s\""),
                        Enumerator, Device, pszDeviceInstanceId,
                        szUniqueParentID,
                        szParentIdPrefix,
                        szDriver,
                        szService))) {
                dwSpaceConsumed =
                    lstrlen(*pszDeviceInstanceCurrent);
            }

        } else if (*szDriver) {

            if (SUCCEEDED(
                    StringCchPrintfEx(
                        *pszDeviceInstanceCurrent,
                        *dwDeviceInstanceSectionRemaining,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE,
                        TEXT("\"%s\\%s\\%s\",%s,%s,%s"),
                        Enumerator, Device, pszDeviceInstanceId,
                        szUniqueParentID,
                        szParentIdPrefix,
                        szDriver))) {
                dwSpaceConsumed =
                    lstrlen(*pszDeviceInstanceCurrent);
            }

        } else if (*szParentIdPrefix) {

            if (SUCCEEDED(
                    StringCchPrintfEx(
                        *pszDeviceInstanceCurrent,
                        *dwDeviceInstanceSectionRemaining,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE,
                        TEXT("\"%s\\%s\\%s\",%s,%s"),
                        Enumerator, Device, pszDeviceInstanceId,
                        szUniqueParentID,
                        szParentIdPrefix))) {
                dwSpaceConsumed =
                    lstrlen(*pszDeviceInstanceCurrent);
            }

        } else if (*szUniqueParentID) {

            if (SUCCEEDED(
                    StringCchPrintfEx(
                        *pszDeviceInstanceCurrent,
                        *dwDeviceInstanceSectionRemaining,
                        NULL, NULL,
                        STRSAFE_NULL_ON_FAILURE,
                        TEXT("\"%s\\%s\\%s\",%s"),
                        Enumerator, Device, pszDeviceInstanceId,
                        szUniqueParentID))) {
                dwSpaceConsumed =
                    lstrlen(*pszDeviceInstanceCurrent);
            }

        }

        //
        // Free the allocated BootConfig string buffer.
        //
        if (pszBootConfig) {
            MyFree(pszBootConfig);
            pszBootConfig = NULL;
        }

        //
        // Only advance the current string location pointer if data was actually
        // written on this pass.
        //
        if (dwSpaceConsumed > 0) {
            //
            // Account for the NULL terminator
            //
            dwSpaceConsumed += 1;

            MYASSERT(dwSpaceConsumed <= *dwDeviceInstanceSectionRemaining);

            *pszDeviceInstanceCurrent += dwSpaceConsumed;
            *dwDeviceInstanceSectionRemaining -= dwSpaceConsumed;
        }

        //
        // Close the device instance key
        //
        RegCloseKey(hInstanceKey);
        hInstanceKey = NULL;
    }

 Clean0:

    //
    // Do some cleanup
    //
    if (pszDeviceInstanceId) {
        MyFree(pszDeviceInstanceId);
    }

    if (hDeviceKey != NULL) {
        RegCloseKey(hDeviceKey);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }

    return (result == ERROR_SUCCESS);

} // EnumerateInstanceKeys()



BOOL
CanStringBeMigrated(
    IN LPTSTR       pszBuffer
    )
{
    LPTSTR p;
    BOOL bStatus;

    try {
        //
        // An empty string can be migrated.
        //
        if (!ARGUMENT_PRESENT(pszBuffer)) {
            bStatus = TRUE;
            goto Clean0;
        }

        for (p = pszBuffer; *p; p++) {
            //
            // Check for the presence of non-migratable characters.
            //
            if ((*p == TEXT('='))  || (*p == TEXT('"'))) {
                bStatus = FALSE;
                goto Clean0;
            }
        }

        //
        // Found no problems with the string.
        //
        bStatus = TRUE;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

    return bStatus;

} // CanStringBeMigrated


//
// Class key enumeration routines
//


BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    )
/*++

Routine Description:

    This routine walks the Plug and Play setup class branch of the registry, and
    collects the data about what keys currently exist.  This information is
    relevant to maintaining plug and play state during textmode setup, such that
    the names of existing keys are not reassigned before they have been migrated
    to the registry at the end of textmode setup.

    Specifically, a multi-sz string will be returned to the caller that contains
    each subkey of the class branch.

Arguments:

    Buffer - Supplies the address of a character pointer, that on success will
             contain a multi-sz list of setup class subkeys to migrate.

             The caller is responsible for freeing the memory via LocalFree.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hClassKey = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, i;
    LPTSTR pszClassKeyName = NULL;

    LPTSTR pszClassKeySection = NULL;
    LPTSTR pszClassKeyCurrent = NULL;
    DWORD  dwClassKeySectionLength = 0;
    DWORD  dwClassKeySectionRemaining = 0;


    //
    // Initialize the output parameter.
    //
    *Buffer = NULL;

    //
    // Allocate storage and initialize variables for the class Key migration
    // section.
    //
    if (pszClassKeySection == NULL) {

        dwClassKeySectionLength = dwClassKeySectionRemaining = 256;
        pszClassKeySection = MyMalloc(dwClassKeySectionLength * sizeof(TCHAR));

        if (!pszClassKeySection) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("MigrateClassKeys: initial ALLOC for ClassKeySection failed!!\n")));
            result = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pszClassKeyCurrent = pszClassKeySection;
    }

    //
    // Open a handle to the HKLM\SYSTEM\CCS\Control\Class key.
    //
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_CLASS_NT,
                          0,
                          KEY_READ,
                          &hClassKey);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateClassKeys: failed to open %s, error=0x%08lx\n"),
                  REGSTR_PATH_CLASS_NT, result));
        hClassKey = NULL;
        goto Clean0;
    }

    //
    // Query the Class key for class GUID subkey information.
    //
    result = RegQueryInfoKey(hClassKey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateClassKeys: failed to query %s key, error=0x%08lx\n"),
                  REGSTR_PATH_CLASS_NT, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest setup class GUID subkey name.
    //
    dwMaxSubKeyLength++;
    MYASSERT(dwMaxSubKeyLength == MAX_GUID_STRING_LEN);
    pszClassKeyName = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszClassKeyName) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateClassKeys: ALLOC for Class GUID key names failed!!\n")));
        goto Clean0;
    }

    //
    // Enumerate the setup class GUIDs.
    //
    for (i = 0; i < dwSubkeyCount; i++) {
        DWORD dwClassKeyLength;

        dwClassKeyLength = dwMaxSubKeyLength;

        result = RegEnumKeyEx(hClassKey,
                              i,
                              pszClassKeyName,
                              &dwClassKeyLength,
                              0,
                              NULL,
                              NULL,
                              NULL);
        if (result != ERROR_SUCCESS) {
            //
            // If there was some error enumerating this key, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE((DBGF_WARNINGS,
                      TEXT("MigrateClassKeys: failed to enumerate a class subkey, error=0x%08lx\n"),
                      result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Enumerate all subkeys for a given setup class key, and append them to
        // the section buffer.
        //
        if (!EnumerateClassSubkeys(hClassKey,
                                   pszClassKeyName,
                                   &pszClassKeySection,
                                   &pszClassKeyCurrent,
                                   &dwClassKeySectionLength,
                                   &dwClassKeySectionRemaining)) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("EnumerateClassSubkeys failed, error=0x%08lx\n"),
                      GetLastError()));
        }
    }

    //
    // Once we've enumerated all class subkeys, add the final NULL terminator to
    // the multi-sz buffer.  There must be enough space for the final NULL
    // terminator because the buffer is always reallocated unless there is room.
    //
    MYASSERT(dwClassKeySectionRemaining > 0);

    MYASSERT(pszClassKeyCurrent);
    *pszClassKeyCurrent = TEXT('\0');

    dwClassKeySectionRemaining -= 1;

 Clean0:

    //
    // Do some cleanup.
    //
    if (pszClassKeyName) {
        MyFree(pszClassKeyName);
    }

    if (hClassKey) {
        RegCloseKey(hClassKey);
    }

    //
    // Return the buffer to the caller only if successful.
    //
    if (result == ERROR_SUCCESS) {
        *Buffer = pszClassKeySection;
    } else {
        SetLastError(result);
        if (pszClassKeySection) {
            MyFree(pszClassKeySection);
        }
    }

    return (result == ERROR_SUCCESS);

} // MigrateClassKeys()



BOOL
EnumerateClassSubkeys(
    IN     HKEY     ClassKey,
    IN     LPTSTR   ClassKeyName,
    IN OUT LPTSTR  *pszClassKeySection,
    IN OUT LPTSTR  *pszClassKeyCurrent,
    IN OUT DWORD   *dwClassKeySectionLength,
    IN OUT DWORD   *dwClassKeySectionRemaining
    )
/*++

Routine Description:

    Enumerates subkeys of a setup class key.
    Worker routine for MigrateClassKeys.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hClassSubkey = NULL;
    LPTSTR pszClassSubkey = NULL;
    DWORD  dwSubkeyCount, dwMaxSubKeyLength, dwSpaceNeeded, dwSpaceConsumed, i;


    //
    // Open the class subkey.
    //
    result = RegOpenKeyEx(ClassKey,
                          ClassKeyName,
                          0,
                          KEY_READ,
                          &hClassSubkey);

    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateClassSubkeys: failed to open '%s' class key, ")
                  TEXT("error=0x%08lx\n"),
                  ClassKeyName, result));
        hClassSubkey = NULL;
        goto Clean0;
    }

    //
    // Query the class GUID key for setup class subkey information.
    //
    result = RegQueryInfoKey(hClassSubkey,
                             NULL,
                             NULL,
                             NULL,
                             &dwSubkeyCount,
                             &dwMaxSubKeyLength,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL);

    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateClassSubkeys: failed to query '%s' class key, ")
                  TEXT("error=0x%08lx\n"),
                  ClassKeyName, result));
        goto Clean0;
    }

    //
    // Allocate a buffer to hold the largest setup class subkey name.
    //
    dwMaxSubKeyLength++;
    pszClassSubkey = MyMalloc(dwMaxSubKeyLength * sizeof(TCHAR));
    if (!pszClassSubkey) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumerateClassSubkeys: ALLOC for Class GUID subkey names failed!!\n")));
        goto Clean0;
    }

    //
    // Enumerate the setup class's "software" subkeys.
    //
    for (i = 0; i < dwSubkeyCount; i++) {

        DWORD  dwClassSubkeyLength;

        dwClassSubkeyLength = dwMaxSubKeyLength;
        result = RegEnumKeyEx(hClassSubkey,
                              i,
                              pszClassSubkey,
                              &dwClassSubkeyLength,
                              0,
                              NULL,
                              NULL,
                              NULL);

        if ((result != ERROR_SUCCESS) ||
            (dwClassSubkeyLength != 4)) {
            //
            // if there was some error, or this is not an actual "software" key
            // (in the form "XXXX"), skip this key and move on.
            //
            if (result != ERROR_SUCCESS) {
                MYASSERT(result != ERROR_NO_MORE_ITEMS);
                DBGTRACE((DBGF_WARNINGS,
                          TEXT("EnumerateClassSubkeys: failed to enumerate a '%s' subkey, ")
                          TEXT("error=0x%08lx\n"),
                          ClassKeyName, result));
            }
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // This block appends the class key data we want to migrate to a
        // multi-sz style string that will be written to the sif file.
        //

        //
        // Need space in the section buffer for a string of the form:
        //     ClassKeyName\pszClassSubkey
        //
        dwSpaceNeeded = lstrlen(ClassKeyName) +
                        1 +  // TEXT('\\')
                        lstrlen(pszClassSubkey);

        //
        // Account for the NULL terminator.
        //
        dwSpaceNeeded += 1;

        if (*dwClassKeySectionRemaining <= dwSpaceNeeded) {
            //
            // ReAllocate the section block.
            //
            LPTSTR p;
            DWORD  dwTempSectionLength, dwTempSectionRemaining;

            dwTempSectionRemaining = *dwClassKeySectionRemaining + *dwClassKeySectionLength;
            dwTempSectionLength = *dwClassKeySectionLength * 2;

            p = MyRealloc(*pszClassKeySection,
                          dwTempSectionLength*sizeof(TCHAR));

            if (!p) {
                DBGTRACE((DBGF_ERRORS,
                          TEXT("EnumerateClassSubkeys: REALLOC failed!!!\n")));
                result = ERROR_NOT_ENOUGH_MEMORY;
                goto Clean0;
            }

            *pszClassKeySection = p;
            *dwClassKeySectionRemaining = dwTempSectionRemaining;
            *dwClassKeySectionLength = dwTempSectionLength;

            *pszClassKeyCurrent = *pszClassKeySection +
                (*dwClassKeySectionLength -
                 *dwClassKeySectionRemaining);
        }

        MYASSERT(*dwClassKeySectionRemaining > dwSpaceNeeded);

        //
        // Have not consumed any space in the string yet.
        //
        *pszClassKeyCurrent[0] = TEXT('\0');
        dwSpaceConsumed = 0;

        //
        // Write the current line to the section block.
        //
        if (SUCCEEDED(
                StringCchPrintfEx(
                    *pszClassKeyCurrent,
                    *dwClassKeySectionRemaining,
                    NULL, NULL,
                    STRSAFE_NULL_ON_FAILURE,
                    TEXT("%s\\%s"),
                    ClassKeyName,
                    pszClassSubkey))) {
            dwSpaceConsumed =
                lstrlen(*pszClassKeyCurrent);
        }

        //
        // Only advance the current string location pointer if data was actually
        // written on this pass.
        //
        if (dwSpaceConsumed > 0) {
            //
            // Account for the NULL terminator.
            //
            dwSpaceConsumed += 1;

            MYASSERT(dwSpaceConsumed <= *dwClassKeySectionRemaining);

            *pszClassKeyCurrent += dwSpaceConsumed;
            *dwClassKeySectionRemaining -= dwSpaceConsumed;
        }

    }

 Clean0:

    //
    // Do some cleanup.
    //
    if (hClassSubkey != NULL) {
        RegCloseKey(hClassSubkey);
    }

    if (pszClassSubkey) {
        MyFree(pszClassSubkey);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }

    return (result == ERROR_SUCCESS);

} // EnumerateClassSubkeys()


//
// Hash value migration routines
//


BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    )
/*++

Routine Description:

    This routine searches the Plug and Play Enum key of the registry, and
    collects the data about what hash value entries currently exist.  This
    information is relevant to maintaining plug and play state during textmode
    setup, such that the names of existing device instances are not reassigned
    before they have been migrated to the registry at the end of textmode setup.

    Specifically, a multi-sz string will be returned to the caller that contains
    the name of the hash value, and its count.

Arguments:

    Buffer - Supplies the address of a character pointer, that on success will
             contain a multi-sz list of hash values to migrate.

             The caller is responsible for freeing the memory via LocalFree.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    LONG   result = ERROR_SUCCESS;
    HKEY   hEnumKey = NULL;
    DWORD  dwValueCount, dwMaxValueNameLength, dwSpaceNeeded, dwSpaceConsumed, i;
    LPTSTR pszHashValueName = NULL;

    LPTSTR pszHashValueSection = NULL;
    LPTSTR pszHashValueCurrent = NULL;

    DWORD  dwHashValueSectionLength = 0;
    DWORD  dwHashValueSectionRemaining = 0;


    //
    // Initialize the output parameter.
    //
    *Buffer = NULL;

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Unlock the Enum key
    //
    LockUnlockEnumTree(FALSE);

#endif // DO_LOCK_UNLOCK

    //
    // Allocate storage and initialize variables for the hash value migration
    // section.
    //
    if (pszHashValueSection == NULL) {

        dwHashValueSectionLength = dwHashValueSectionRemaining = 256;
        pszHashValueSection = MyMalloc(dwHashValueSectionLength * sizeof(TCHAR));

        if (!pszHashValueSection) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE((DBGF_ERRORS,
                      TEXT("MigrateHashValues: initial ALLOC for HashValueSection failed!!\n")));
            goto Clean0;
        }

        pszHashValueCurrent = pszHashValueSection;
    }

    //
    // Open a handle to the HKLM\SYSTEM\CCS\Enum key.
    //
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_SYSTEMENUM,
                          0,
                          KEY_READ,
                          &hEnumKey);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateHashValues: failed to open %s, error=0x%08lx\n"),
                  REGSTR_PATH_SYSTEMENUM, result));
        hEnumKey = NULL;
        goto Clean0;
    }

    //
    // Query the Enum key for hash value information.
    //
    result = RegQueryInfoKey(hEnumKey,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             &dwValueCount,
                             &dwMaxValueNameLength,
                             NULL,
                             NULL,
                             NULL);
    if (result != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateHashValues: failed to query %s key, error=0x%08lx\n"),
                  REGSTR_PATH_SYSTEMENUM, result));
        goto Clean0;
    }

    //
    // Allocate a variable to hold the largest hash value key name.
    //
    dwMaxValueNameLength++;
    pszHashValueName = MyMalloc(dwMaxValueNameLength * sizeof(TCHAR));
    if (!pszHashValueName) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("MigrateHashValues: failed to allocate buffer for Enum key hash values\n")));
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    //
    // Enumerate all values and append them to the supplied buffer.
    //
    for (i = 0; i < dwValueCount; i++) {
        DWORD dwHashValueLength, dwType, dwData, dwSize;
        TCHAR szHashValueData[11];


        dwHashValueLength = dwMaxValueNameLength;
        dwType = REG_DWORD;
        dwData = 0;
        dwSize = sizeof(DWORD);

        result = RegEnumValue(hEnumKey,
                              i,
                              pszHashValueName,
                              &dwHashValueLength,
                              0,
                              &dwType,
                              (LPBYTE)&dwData,
                              &dwSize);

        if ((result != ERROR_SUCCESS) ||
            (dwType != REG_DWORD)     ||
            (dwSize != sizeof(DWORD))) {
            //
            // If there was some error enumerating this value, or the value
            // return was not expected, skip it.
            //
            MYASSERT(result != ERROR_NO_MORE_ITEMS);
            DBGTRACE((DBGF_WARNINGS,
                      TEXT("MigrateHashValues: failed to enumerate Enum values, ")
                      TEXT("error=0x%08lx\n"),
                      result));
            result = ERROR_SUCCESS;
            continue;
        }

        //
        // Write the hash value data to the sif as a base 10 value.
        // (see base\ntsetup\textmode\kernel\spsetup.c)
        //
        if (FAILED(StringCchPrintf(szHashValueData,
                                   SIZECHARS(szHashValueData),
                                   TEXT("%d"), // base 10
                                   dwData))) {
            //
            // If there was an error adding this entry to the buffer, just go on
            // to the next.
            //
            continue;
        }

        //
        // This block appends the class key data we want to migrate to a
        // multi-sz style string that will be written to the sif file.
        //

        //
        // Need space in the section buffer for a string of the form:
        //     HashValueName=HashValueData
        //
        dwSpaceNeeded = lstrlen(pszHashValueName) +
                        1 +  // TEXT('=')
                        lstrlen(szHashValueData);

        //
        // Account for the NULL terminator.
        //
        dwSpaceNeeded += 1;

        if (dwHashValueSectionRemaining <= dwSpaceNeeded) {
            //
            // ReAllocate the section block.
            //
            LPTSTR p;
            DWORD  dwTempSectionLength, dwTempSectionRemaining;

            dwTempSectionRemaining = dwHashValueSectionRemaining + dwHashValueSectionLength;
            dwTempSectionLength = dwHashValueSectionLength * 2;

            p = MyRealloc(pszHashValueSection,
                          dwTempSectionLength*sizeof(TCHAR));

            if (!p) {
                DBGTRACE((DBGF_ERRORS,
                          TEXT("MigrateHashValues: REALLOC failed!!!\n")));
                result = ERROR_NOT_ENOUGH_MEMORY;
                goto Clean0;
            }

            pszHashValueSection = p;
            dwHashValueSectionRemaining = dwTempSectionRemaining;
            dwHashValueSectionLength = dwTempSectionLength;

            pszHashValueCurrent = pszHashValueSection +
                (dwHashValueSectionLength -
                 dwHashValueSectionRemaining);
        }

        MYASSERT(dwHashValueSectionRemaining > dwSpaceNeeded);

        //
        // Have not consumed any space in the string yet.
        //
        pszHashValueCurrent[0] = TEXT('\0');
        dwSpaceConsumed = 0;

        //
        // Write the current line to the section block.
        //
        if (SUCCEEDED(
                StringCchPrintfEx(
                    pszHashValueCurrent,
                    dwHashValueSectionRemaining,
                    NULL, NULL,
                    STRSAFE_NULL_ON_FAILURE,
                    TEXT("%s=%s"),
                    pszHashValueName,
                    szHashValueData))) {
            dwSpaceConsumed =
                lstrlen(pszHashValueCurrent);
        }

        //
        // Only advance the current string location pointer if data was actually
        // written on this pass.
        //
        if (dwSpaceConsumed > 0) {
            //
            // Account for the NULL terminator.
            //
            dwSpaceConsumed += 1;

            MYASSERT(dwSpaceConsumed <= dwHashValueSectionRemaining);

            pszHashValueCurrent += dwSpaceConsumed;
            dwHashValueSectionRemaining -= dwSpaceConsumed;
        }
    }

    //
    // Once we've enumerated all hash values, add the final NULL terminator to
    // the multi-sz buffer.  There must be enough space for the final NULL
    // terminator because the buffer is always reallocated unless there is room.
    //
    MYASSERT(dwHashValueSectionRemaining > 0);

    MYASSERT(pszHashValueCurrent);
    *pszHashValueCurrent = TEXT('\0');

    dwHashValueSectionRemaining -= 1;

 Clean0:

    //
    // Do some cleanup
    //
    if (pszHashValueName) {
        MyFree(pszHashValueName);
    }

    if (hEnumKey) {
        RegCloseKey(hEnumKey);
    }

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK

    //
    // Lock the Enum tree
    //
    LockUnlockEnumTree(TRUE);

#endif // DO_LOCK_UNLOCK

    //
    // Return the buffer to the caller only if successful.
    //
    if (result == ERROR_SUCCESS) {
        *Buffer = pszHashValueSection;
    } else {
        SetLastError(result);
        if (pszHashValueSection) {
            MyFree(pszHashValueSection);
        }
    }

    return (result == ERROR_SUCCESS);

} // MigrateHashValues()



//
// Enum branch lock/unlock and security routines - taken from PNPREG.
// (we only need these if we're doing the Enum lock/unlock thing)
//

#if DO_LOCK_UNLOCK // DO_LOCK_UNLOCK


VOID
LockUnlockEnumTree(
    IN  BOOL     bLock
    )
/*++

Routine Description:

    This function "locks" or "unlocks" the Plug and Play Enum tree in the
    registry.

Arguments:

    bLock         - If TRUE, specifies that the Enum tree should be "locked".
                    Otherwise, specifies that the Enum tree should be "unlocked".

Return Value:

    None.

--*/
{
    PSECURITY_DESCRIPTOR    pSD;
    HKEY                    hParentKey;
    LONG                    RegStatus;

    if (CreateSecurityDescriptors()) {

        EnumKeysAndApplyDacls(HKEY_LOCAL_MACHINE,
                              REGSTR_PATH_SYSTEMENUM,
                              0,
                              FALSE,
                              !bLock,
                              bLock ? &g_LockedPrivateKeysSD : &g_DeviceParametersSD,
                              &g_DeviceParametersSD);

        FreeSecurityDescriptors();
    }

    return;

} // LockUnlockEnumTree()



VOID
EnumKeysAndApplyDacls(
    IN HKEY      hParentKey,
    IN LPTSTR    pszKeyName,
    IN DWORD     dwLevel,
    IN BOOL      bInDeviceParameters,
    IN BOOL      bApplyTopDown,
    IN PSECURITY_DESCRIPTOR pPrivateKeySD,
    IN PSECURITY_DESCRIPTOR pDeviceParametersSD
    )
/*++

Routine Description:

    This function applies the DACL in pSD to all the keys rooted at hKey
    including hKey itself.

Arguments:

    hParentKey    - Handle to a registry key.

    pszKeyName    - Name of the key.

    dwLevel       - Number of levels remaining to recurse.

    pSD           - Pointer to a security descriptor containing a DACL.

Return Value:

    None.

--*/
{
    LONG        regStatus;
    DWORD       dwMaxSubKeySize;
    LPTSTR      pszSubKey;
    DWORD       index;
    HKEY        hKey;
    BOOL        bNewInDeviceParameters;

#if 0 //#if DBG // DBG
    DWORD       dwStartKeyNameLength = g_dwCurrentKeyNameLength;

    if (g_dwCurrentKeyNameLength != 0)  {
        g_szCurrentKeyName[ g_dwCurrentKeyNameLength++ ] = TEXT('\\');
    }

    _tcscpy(&g_szCurrentKeyName[g_dwCurrentKeyNameLength], pszKeyName);
    g_dwCurrentKeyNameLength += _tcslen(pszKeyName);

#endif  // DBG

    DBGTRACE((DBGF_REGISTRY,
              TEXT("EnumKeysAndApplyDacls(0x%08X, \"%s\", %d, %s, %s, 0x%08X, 0x%08X)\n"),
              hParentKey,
              g_szCurrentKeyName,
              dwLevel,
              bInDeviceParameters ? TEXT("TRUE") : TEXT("FALSE"),
              bApplyTopDown ? TEXT("TRUE") : TEXT("FALSE"),
              pPrivateKeySD,
              pDeviceParametersSD));

    if (bApplyTopDown) {

        regStatus = RegOpenKeyEx( hParentKey,
                                  pszKeyName,
                                  0,
                                  WRITE_DAC,
                                  &hKey
                                  );

        if (regStatus != ERROR_SUCCESS) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, ")
                      TEXT("error = %d\n"),
                      g_szCurrentKeyName, regStatus));

            return;
        }

        DBGTRACE((DBGF_REGISTRY,
                  TEXT("Setting security on %s on the way down\n"),
                  g_szCurrentKeyName));

        //
        // apply the new security to the registry key
        //
        regStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (regStatus != ERROR_SUCCESS) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, ")
                      TEXT("error = %d\n"),
                      g_szCurrentKeyName, regStatus));
        }

        //
        // Close the key and reopen it later for read (which hopefully was just
        // granted in the DACL we just wrote
        //
        RegCloseKey( hKey );
        hKey = NULL;
    }

    regStatus = RegOpenKeyEx( hParentKey,
                              pszKeyName,
                              0,
                              KEY_READ | WRITE_DAC,
                              &hKey
                              );

    if (regStatus != ERROR_SUCCESS) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, ")
                  TEXT("error = %d\n"),
                  g_szCurrentKeyName, regStatus));
        hKey = NULL;
        return;
    }

    //
    // Determine length of longest subkey
    //
    regStatus = RegQueryInfoKey( hKey,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwMaxSubKeySize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

    if (regStatus == ERROR_SUCCESS) {

        //
        // Allocate a buffer to hold the subkey names. RegQueryInfoKey returns the
        // size in characters and doesn't include the NUL terminator.
        //
        pszSubKey = LocalAlloc(0, ++dwMaxSubKeySize * sizeof(TCHAR));

        if (pszSubKey != NULL) {

            //
            // Enumerate all the subkeys and then call ourselves recursively for each
            // until dwLevel reaches 0.
            //

            for (index = 0; ; index++) {

                regStatus = RegEnumKey( hKey,
                                        index,
                                        pszSubKey,
                                        dwMaxSubKeySize
                                        );

                if (regStatus != ERROR_SUCCESS) {

                    if (regStatus != ERROR_NO_MORE_ITEMS) {

                        DBGTRACE((DBGF_ERRORS,
                                  TEXT("EnumKeysAndApplyDacls(\"%s\") RegEnumKeyEx() failed, ")
                                  TEXT("error = %d\n"),
                                  g_szCurrentKeyName,
                                  regStatus));
                    }

                    break;
                }

                bNewInDeviceParameters = bInDeviceParameters ||
                                         (dwLevel == 3 &&
                                            _tcsicmp( pszSubKey,
                                                      REGSTR_KEY_DEVICEPARAMETERS ) == 0);

                EnumKeysAndApplyDacls( hKey,
                                       pszSubKey,
                                       dwLevel + 1,
                                       bNewInDeviceParameters,
                                       bApplyTopDown,
                                       pPrivateKeySD,
                                       pDeviceParametersSD
                                       );
            }

            LocalFree( pszSubKey );
        }
    }
    else
    {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("EnumKeysAndApplyDacls(\"%s\") RegQueryInfoKey() failed, ")
                  TEXT("error = %d\n"),
                  g_szCurrentKeyName, regStatus));
    }

    if (!bApplyTopDown) {

        DBGTRACE((DBGF_REGISTRY,
                  TEXT("Setting security on %s on the way back up\n"),
                  g_szCurrentKeyName));

        //
        // apply the new security to the registry key
        //
        regStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (regStatus != ERROR_SUCCESS) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, ")
                      TEXT("error = %d\n"),
                      g_szCurrentKeyName, regStatus));
        }
    }

    RegCloseKey( hKey );

#if 0 //#if DBG // DBG
    g_dwCurrentKeyNameLength = dwStartKeyNameLength;
    g_szCurrentKeyName[g_dwCurrentKeyNameLength] = TEXT('\0');
#endif  // DBG

    return;

} // EnumKeysAndApplyDacls()



BOOL
CreateSecurityDescriptors(
    VOID
    )
/*++

Routine Description:

    This function creates a properly initialized Security Descriptor for the
    Device Parameters key and its subkeys.  The SIDs and DACL created by this
    routine must be freed by calling FreeSecurityDescriptors.

Arguments:

    None.

Return Value:

    Pointer to the initialized Security Descriptor.  NULL is returned if an
    error occurs.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    EXPLICIT_ACCESS             ExplicitAccess[3];

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    FARPROC                     pSetEntriesInAcl;
    HMODULE                     pAdvApi32;

    pAdvApi32 = LoadLibrary( TEXT("advapi32.dll"));
    if (!pAdvApi32) {
        return(FALSE);
    }

#ifdef UNICODE
    pSetEntriesInAcl = GetProcAddress( pAdvApi32, "SetEntriesInAclW" );
#else
    pSetEntriesInAcl = GetProcAddress( pAdvApi32, "SetEntriesInAclA" );
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }

    //
    // Create SIDs - Admins and System
    //

    bSuccess =             AllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &g_pAdminSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pSystemSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &WorldAuthority,
                                                     1,
                                                     SECURITY_WORLD_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pWorldSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 3; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = CONTAINER_INHERIT_ACE;
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }

        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)g_pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)g_pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_READ;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)g_pWorldSid;

        //
        // Create the DACL with the both the above ACEs for the DeviceParameters
        //
        dwError = (DWORD)pSetEntriesInAcl( 3,
                                           ExplicitAccess,
                                           NULL,
                                           &g_pDeviceParametersDacl );

        if (dwError == ERROR_SUCCESS) {
            //
            // Create the DACL with just the system ACE for the locked private
            // keys.
            //
            dwError = (DWORD)pSetEntriesInAcl( 2,
                                               ExplicitAccess + 1,
                                               NULL,
                                               &g_pLockedPrivateKeysDacl );
        }

        bSuccess = dwError == ERROR_SUCCESS;

    }

    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_DeviceParametersSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_DeviceParametersSD,
                                                      TRUE,
                                                      g_pDeviceParametersDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_DeviceParametersSD );


    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_LockedPrivateKeysSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_LockedPrivateKeysSD,
                                                      TRUE,
                                                      g_pLockedPrivateKeysDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_LockedPrivateKeysSD );


    if (!bSuccess) {

        FreeSecurityDescriptors();
    }

    FreeLibrary( pAdvApi32 );

    return bSuccess;

} // CreateSecurityDescriptors()



VOID
FreeSecurityDescriptors(
    VOID
    )
/*++

Routine Description:

    This function deallocates the data structures allocated and initialized by
    CreateSecurityDescriptors.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_pDeviceParametersDacl) {
        LocalFree(g_pDeviceParametersDacl);
        g_pDeviceParametersDacl = NULL;
    }

    if (g_pLockedPrivateKeysDacl) {
        LocalFree(g_pLockedPrivateKeysDacl);
        g_pLockedPrivateKeysDacl = NULL;
    }

    if (g_pAdminSid != NULL) {
        FreeSid(g_pAdminSid);
        g_pAdminSid = NULL;
    }

    if (g_pSystemSid != NULL) {
        FreeSid(g_pSystemSid);
        g_pSystemSid = NULL;
    }

    if (g_pWorldSid != NULL) {
        FreeSid(g_pWorldSid);
        g_pWorldSid = NULL;
    }

    return;

} // FreeSecurityDescriptors()

#endif // DO_LOCK_UNLOCK



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\debug.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    debug.h

Abstract:

    Debug infrastructure for this component.
    (currently inactive)

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// debug infrastructure
//

#if DBG

#define DBGF_ERRORS                 DPFLTR_ERROR_LEVEL
#define DBGF_WARNINGS               DPFLTR_WARNING_LEVEL
#define DBGF_TRACE                  DPFLTR_TRACE_LEVEL
#define DBGF_INFO                   DPFLTR_INFO_LEVEL
#define DBGF_REGISTRY               DPFLTR_INFO_LEVEL

VOID
pSifDebugPrintEx(
    DWORD  Level,
    PCTSTR Format,
    ...              OPTIONAL
    );

ULONG
DebugPrint(
    IN ULONG    Level,
    IN PCHAR    Format,
    ...
    );

#define DBGTRACE(x)     pSifDebugPrintEx x
#define MYASSERT(x)     ASSERT(x)

#else   // !DBG

#define DBGTRACE(x)
#define MYASSERT(x)

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\precomp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file.

Author:

    Jim Cavalaris (jamesca) 3-07-1999

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Win32 Public Header Files
//
#include <windows.h>
#include <strsafe.h>


//
// CRT Header Files
//
#include <stdio.h>
#include <stdlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\restore.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    restore.c

Abstract:

    This module contains the following Plug and Play registry merge-restore
    routines:

        AsrRestorePlugPlayRegistryData

Author:

    Jim Cavalaris (jamesca) 3-07-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//

#include "precomp.h"
#include "util.h"
#include "debug.h"
#include <regstr.h>
#include <cfgmgr32.h>


//
// private memory allocation definitions
//

#define MyMalloc(size)         LocalAlloc(0, size);
#define MyFree(entry)          LocalFree(entry);
#define MyRealloc(entry,size)  LocalReAlloc(entry, size, 0);

//
// global variables to store the root keys we're working on.
//
// (we really shouldn't have to do this, but it's the easiest way for us to
// reach into one set of keys while recursing through the other set.)
//
HKEY    PnpSifRestoreSourceEnumKeyHandle  = NULL;
HKEY    PnpSifRestoreTargetEnumKeyHandle  = NULL;

HKEY    PnpSifRestoreSourceClassKeyHandle = NULL;
HKEY    PnpSifRestoreTargetClassKeyHandle = NULL;

//
// private definitions
//

// INVALID_FLAGS macro from pnp\inc\cfgmgrp.h
#define INVALID_FLAGS(ulFlags, ulAllowed) ((ulFlags) & ~(ulAllowed))

// private flags for internal RestoreSpecialRegistryData routine
#define PNPSIF_RESTORE_TYPE_DEFAULT                        (0x00000000)
#define PNPSIF_RESTORE_TYPE_ENUM                           (0x00000001)
#define PNPSIF_RESTORE_TYPE_CLASS                          (0x00000002)
#define PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION  (0x00000010)
#define PNPSIF_RESTORE_BITS                                (0x00000013)

// Enum level definitions describing the subkey types for the specified handles.
#define ENUM_LEVEL_ENUMERATORS  (0x0000003)
#define ENUM_LEVEL_DEVICES      (0x0000002)
#define ENUM_LEVEL_INSTANCES    (0x0000001)

// Class level definitions describing the subkey types for the specified handles.
#define CLASS_LEVEL_CLASSGUIDS  (0x0000002)
#define CLASS_LEVEL_DRVINSTS    (0x0000001)

//
// private prototypes
//

BOOL
RestoreEnumKey(
    IN  HKEY  hSourceEnumKey,
    IN  HKEY  hTargetEnumKey
    );

BOOL
RestoreClassKey(
    IN  HKEY  hSourceClassKey,
    IN  HKEY  hTargetClassKey
    );

BOOL
RestoreSpecialRegistryData(
    IN     HKEY   hSourceKey,
    IN     HKEY   hTargetKey,
    IN     ULONG  ulLevel,
    IN OUT PVOID  pContext,
    IN     ULONG  ulFlags
    );

BOOL
MyReplaceKey(
    IN  HKEY  hSourceKey,
    IN  HKEY  hTargetKey
    );

BOOL
IsString4DigitOrdinal(
    IN  LPTSTR  pszSubkeyName
    );

BOOL
IsDeviceConfigured(
    IN  HKEY  hInstanceKey
    );

BOOL
ReplaceClassKeyForInstance(
    IN  HKEY  hSourceInstanceKey,
    IN  HKEY  hSourceRootClassKey,
    IN  HKEY  hTargetRootClassKey
    );

//
// routines
//


BOOL
AsrRestorePlugPlayRegistryData(
    IN  HKEY    SourceSystemKey,
    IN  HKEY    TargetSystemKey,
    IN  DWORD   Flags,
    IN  PVOID   Reserved
    )
/*++

Routine Description:

    This routine restores plug and play data from the the specified source
    SYSTEM key to the specified target SYSTEM key, merging intermediate subkeys
    and values as appropriate.

Arguments:

    SourceSystemKey - Handle to the HKLM\SYSTEM key within the "source"
                      registry, whose data is to be "merged" into the
                      corresponding SYSTEM key of the "target" registry, as
                      specified by TargetSystemKey.

    TargetSystemKey - Handle to the HKLM\SYSTEM key within the "target"
                      registry, that is to receive additional data from the
                      corresponding SYSTEM key of the "source" registry, as
                      specified by SourceSystemKey.

    Flags           - Not used, must be zero.

    Reserved        - Reserved for future use, must be NULL.


Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

Notes:

    This routine was written specifically to assist in the restoration of the
    Plug-and-Play specific registry keys that cannot simply be restored from
    backup.  It is intended to be called within the context of a
    backup-and-restore application's "restore" phase.

    During a backup-and-restore application's "restore" phase, the registry that
    has been backed-up onto backup medium is to become the new system registry.
    Certain Plug and Play values and registry keys, are actually copied into the
    backed-up registry from the current registry.  Rather than using the backup
    registry, or the current registry exclusively, Plug and Play data contained
    in these keys should be merged from the current registry into the backup
    registry in a way that is appropriate for each key.  The backup registry can
    then safely replace the current registry as the system registry.

    In the context of a backup-and-restore application's "restore" phase, the
    "Source" registry key is the one contained in the current running system
    registry.  The "Target" registry is that which has been backed-up, and will
    become the system registry, upon reboot.

    The calling thread/process must have both the SE_BACKUP_NAME and
    SE_RESTORE_NAME privileges.

--*/
{
    LONG   result = ERROR_SUCCESS;
    HRESULT hr;
    HKEY   hSystemSelectKey = NULL;
    TCHAR  pszRegKeySelect[] = TEXT("Select");
    TCHAR  pszRegValueCurrent[] = TEXT("Current");
    TCHAR  szBuffer[128];
    DWORD  dwType, dwSize;
    DWORD  dwSourceCCS, dwTargetCCS;


    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if (Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure that the user supplied us with valid flags.
    //
    if(INVALID_FLAGS(Flags, 0x0)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // Determine the CurrentControlSet for the source.
    //
    result = RegOpenKeyEx(SourceSystemKey,
                          pszRegKeySelect,
                          0,
                          KEY_READ,
                          &hSystemSelectKey);

    if (result != ERROR_SUCCESS) {
        hSystemSelectKey = NULL;
        goto Clean0;
    }

    dwSize = sizeof(DWORD);
    result = RegQueryValueEx(hSystemSelectKey,
                             pszRegValueCurrent,
                             0,
                             &dwType,
                             (LPBYTE)&dwSourceCCS,
                             &dwSize);

    RegCloseKey(hSystemSelectKey);
    hSystemSelectKey = NULL;

    if ((result != ERROR_SUCCESS) ||
        (dwType != REG_DWORD)) {
        goto Clean0;
    }

    //
    // Determine the CurrentControlSet for the target.
    //
    result = RegOpenKeyEx(TargetSystemKey,
                          pszRegKeySelect,
                          0,
                          KEY_READ,
                          &hSystemSelectKey);

    if (result != ERROR_SUCCESS) {
        hSystemSelectKey = NULL;
        goto Clean0;
    }

    dwSize = sizeof(DWORD);
    result = RegQueryValueEx(hSystemSelectKey,
                             pszRegValueCurrent,
                             0,
                             &dwType,
                             (LPBYTE)&dwTargetCCS,
                             &dwSize);

    RegCloseKey(hSystemSelectKey);
    hSystemSelectKey = NULL;

    if ((result != ERROR_SUCCESS) ||
        (dwType != REG_DWORD)) {
        goto Clean0;
    }

    //
    // Open the source CurrentControlSet\Enum key.
    //
    hr = StringCchPrintf(szBuffer,
                         SIZECHARS(szBuffer),
                         TEXT("ControlSet%03d\\Enum"),
                         dwSourceCCS);
    if (FAILED(hr)) {
        result = HRESULT_CODE(hr);
        goto Clean0;
    }

    result = RegOpenKeyEx(SourceSystemKey,
                          szBuffer,
                          0,
                          KEY_READ, // only need to read from the source
                          &PnpSifRestoreSourceEnumKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Open the target CurrentControlSet\Enum key.
    //
    hr = StringCchPrintf(szBuffer,
                         SIZECHARS(szBuffer),
                         TEXT("ControlSet%03d\\Enum"),
                         dwTargetCCS);
    if (FAILED(hr)) {
        result = HRESULT_CODE(hr);
        goto Clean0;
    }

    result = RegOpenKeyEx(TargetSystemKey,
                          szBuffer,
                          0,
                          KEY_ALL_ACCESS, // need full access to the target
                          &PnpSifRestoreTargetEnumKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Open the source CurrentControlSet\Control\Class key.
    //
    hr = StringCchPrintf(szBuffer,
                         SIZECHARS(szBuffer),
                         TEXT("ControlSet%03d\\Control\\Class"),
                         dwSourceCCS);
    if (FAILED(hr)) {
        result = HRESULT_CODE(hr);
        goto Clean0;
    }

    result = RegOpenKeyEx(SourceSystemKey,
                          szBuffer,
                          0,
                          KEY_READ, // only need to read from the source
                          &PnpSifRestoreSourceClassKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Open the target CurrentControlSet\Control\Class key.
    //
    hr = StringCchPrintf(szBuffer,
                         SIZECHARS(szBuffer),
                         TEXT("ControlSet%03d\\Control\\Class"),
                         dwTargetCCS);
    if (FAILED(hr)) {
        result = HRESULT_CODE(hr);
        goto Clean0;
    }

    result = RegOpenKeyEx(TargetSystemKey,
                          szBuffer,
                          0,
                          KEY_ALL_ACCESS, // need full access to the target
                          &PnpSifRestoreTargetClassKeyHandle);

    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // NOTE: We restore the Enum branch first, then restore the Class branch.
    // The code that restores these keys depends on it, so do not change this!!
    //
    // This order makes sense, because relevant Class keys correspond to exactly
    // one Enum instance key (but an Enum key may or may not have a Class key),
    // so Class keys are only really meaningful in the context of the instance
    // key they belong to.  This behavior should NOT need to change.
    //

    //
    // Do the merge-restore for the Enum keys, ignore any errors.
    //
    if (!RestoreEnumKey(PnpSifRestoreSourceEnumKeyHandle,
                        PnpSifRestoreTargetEnumKeyHandle)) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("PNPSIF: RestoreEnumKey failed, ")
                  TEXT("error == 0x%08lx\n"),
                  GetLastError()));
    }

    //
    // Do the merge-restore for the Class keys, ignore any errors.
    //
    if (!RestoreClassKey(PnpSifRestoreSourceClassKeyHandle,
                         PnpSifRestoreTargetClassKeyHandle)) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("PNPSIF: RestoreClassKey failed, ")
                  TEXT("error == 0x%08lx\n"),
                  GetLastError()));
    }

 Clean0:
    //
    // Close the open handles.
    //
    if (PnpSifRestoreSourceEnumKeyHandle) {
        RegCloseKey(PnpSifRestoreSourceEnumKeyHandle);
        PnpSifRestoreSourceEnumKeyHandle = NULL;
    }
    if (PnpSifRestoreTargetEnumKeyHandle) {
        RegCloseKey(PnpSifRestoreTargetEnumKeyHandle);
        PnpSifRestoreTargetEnumKeyHandle = NULL;
    }

    if (PnpSifRestoreSourceClassKeyHandle) {
        RegCloseKey(PnpSifRestoreSourceClassKeyHandle);
        PnpSifRestoreSourceClassKeyHandle = NULL;
    }
    if (PnpSifRestoreTargetClassKeyHandle) {
        RegCloseKey(PnpSifRestoreTargetClassKeyHandle);
        PnpSifRestoreTargetClassKeyHandle = NULL;
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // AsrRestorePlugPlayRegistryData()



//
// private worker routines for AsrRestorePlugPlayRegistryData
//


BOOL
RestoreEnumKey(
    IN  HKEY  hSourceEnumKey,
    IN  HKEY  hTargetEnumKey
    )
/*++

Routine Description:

    Restores new device instances in the source (current) Enum key to the target
    Enum key, located in the backup registry to be restored.  By doing this, the
    Enum key from the backup set can safely replace the current Enum key.

    All intermediate values from the source (current) registry are restored to
    the target (backup), to account for the device instance hash values located
    at the root of the Enum key, that have been updated during setup.

    During an ASR backup and restore operation, the hash values in the source
    (current) registry are propogated to the current registry during textmode
    setup, as they are stored the asrpnp.sif file.  Since hash values may be
    modified by setup, the values in the source (current) registry will be more
    relevant than those in the target (backup), so source values should always
    be preseverd.

Arguments:

    hSourceEnumKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Enum key within
                     the "source" registry, whose data is to be "merged" into
                     the corresponding SYSTEM key of the "target" registry, as
                     specified by hTargetEnumKey.

    hTargetEnumKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Enum key within
                     the "target" registry, that is to receive additional data
                     from the corresponding SYSTEM key of the "source" registry,
                     as specified by hSourceEnumKey.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    BOOL bIsRootEnumerated = FALSE;

    return RestoreSpecialRegistryData(hSourceEnumKey,
                                      hTargetEnumKey,
                                      ENUM_LEVEL_ENUMERATORS, // (0x0000003)
                                      (PVOID)&bIsRootEnumerated,
                                      PNPSIF_RESTORE_TYPE_ENUM |
                                      PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION
                                      );

} // RestoreEnumKey



BOOL
RestoreClassKey(
    IN  HKEY  hSourceClassKey,
    IN  HKEY  hTargetClassKey
    )
/*++

Routine Description:

    Restores new elements of the source Class key to the target Class key,
    located in the backup registry to be restored.

    Intermediate values from the source registry are coied to the the target
    registry only when they do not already exist in the target.  Otherwise, the
    target values are preseved.

Arguments:

    hSourceClassKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Control\Class
                      key within the "source" registry, whose data is to be
                      "merged" into the corresponding SYSTEM key of the "target"
                      registry, as specified by hTargetClassKey.

    hTargetClassKey - Handle to the HKLM\SYSTEM\CurrentControlSet\Control\Class
                      key within the "target" registry, that is to receive
                      additional data from the corresponding SYSTEM key of the
                      "source" registry, as specified by hSourceClassKey.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    return RestoreSpecialRegistryData(hSourceClassKey,
                                      hTargetClassKey,
                                      CLASS_LEVEL_CLASSGUIDS, // (0x00000002)
                                      (PVOID)NULL,
                                      PNPSIF_RESTORE_TYPE_CLASS
                                      );

} // RestoreClassKey



BOOL
RestoreSpecialRegistryData(
    IN     HKEY   hSourceKey,
    IN     HKEY   hTargetKey,
    IN     ULONG  ulLevel,
    IN OUT PVOID  pContext,
    IN     ULONG  ulFlags
    )
/*++

Routine Description:

    This routine restores the specified source key to the specified target key,
    merging intermediate subkeys and values.  Values in the subkeys located
    above the specified depth level are merged from the source into the target
    (with collisions handled according to the specified flags).  Subkeys and
    values at and below the level specified are merged from the source key to
    the target key, with subkeys from the sources replacing any corresponding
    subkeys in the target.


Arguments:

    hSourceKey - Handle to a key within the source registry, whose data is to be
                 "merged" into the corresponding key of the target registry, as
                 specified by hTargetKey.

    hTargetKey - Handle to a key within the target registry, that is to receive
                 data from the corresponding key of the source registry, as
                 specified by hSourceKey.

    ulLevel    - Specifies the subkey depth at which "replacement" will
                 take place.  For subkeys above that depth, data in the target
                 registry will be preserved if present, and copied otherwise.
                 For keys at the specified level, data from the specified target
                 key will be replaced by the source key.

    pContext   - Specifies caller-supplied context for the operation that is
                 specific to the type of subkeys being restored (see ulFlags
                 below), and the specified ulLevel parameter.

    ulFlags    - Supplies flags specifying options for the restoration of the
                 registry keys.  May be one of the following values:

                 PNPSIF_RESTORE_TYPE_ENUM:

                     Specifies that the subkeys being restored are subkeys of
                     the SYSTEM\CurrentControlSet\Enum branch.  Device hardware
                     settings can be inspected at the appropriate ulLevel.

                     For Enum branch subkeys, the ulLevel parameter describes
                     also the type of the subkeys contained under the hSourceKey
                     and hTargetKey keys.  May be one of:

                       ENUM_LEVEL_ENUMERATORS
                       ENUM_LEVEL_DEVICES
                       ENUM_LEVEL_INSTANCES

                 PNPSIF_RESTORE_TYPE_CLASS:

                     Specifies that the subkeys being restored are subkeys of
                     the SYSTEM\CurrentControlSet\Control\Class branch.  Setup
                     class or device software settings can be inspected at the
                     appropriate ulLevel.

                     For Class branch subkeys, the ulLevel parameter also
                     describes the type of the subkeys contained under the
                     hSourceKey and hTargetKey keys.  May be one of:

                       CLASS_LEVEL_CLASSGUIDS
                       CLASS_LEVEL_DRVINSTS

                 PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION:

                     When a collision occurs while merging values between the
                     source and target at intermediate levels, replace the
                     target value with that from the source (the default
                     behavior is to preserve existing target values above
                     'ulLevel' in depth from the supplied keys; below 'ulLevel',
                     only source key values will be present.)

                 NOTE: it's probably worth noting that a corresponding flag for
                 replace-target-keys-on-collision is not at all necessary, since
                 such a behavior can already be implemented with the ulLevel
                 parameter. (i.e. the ulLevel parameter actually specifies the
                 level at which all source keys will replace target keys; to
                 specify that this should ALWAYS be done is the same as
                 specifying ulLevel == 0)


Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

Notes:

    This routine was written specifically to assist in the restoration of the
    Plug-and-Play specific registry keys that cannot simply be restored from
    backup.  It is intended to be called within the context of a
    backup-and-restore application's "restore" phase.

    During a backup-and-restore application's "restore" phase, the registry that
    has been backed-up onto backup medium is to become the new system registry.
    Certain Plug and Play values and registry keys, are actually copied into the
    backed-up registry from the current registry.  Rather than using the backup
    registry, or the current registry exclusively, Plug and Play data contained
    in these keys should be merged from the current registry into the backup
    registry in a way that is appropriate for each key.  The backup registry can
    then safely replace the current registry as the system registry.

    In the context of a backup-and-restore application's "restore" phase, the
    "Source" registry key is the one contained in the current running system
    registry.  The "Target" registry is that which has been backed-up, and will
    become the system registry, upon reboot.

    The different restore behaviors required for each of the different sets of
    keys can be specified with the appropriate ulLevel, and ulFlags.

--*/
{
    LONG   result = ERROR_SUCCESS;
    DWORD  dwIndex = 0;
    DWORD  dwSubkeyCount, dwMaxSubkeyNameLength;
    DWORD  dwValueCount, dwMaxValueNameLength, dwMaxValueDataLength;
    DWORD  dwDisposition;
    LPTSTR pszSubkeyName = NULL, pszValueName = NULL;
    LPBYTE pValueData = NULL;
    BOOL   bPossibleRedundantInstanceKeys = FALSE;


    //
    // Validate parameters
    //
    if (INVALID_FLAGS(ulFlags, PNPSIF_RESTORE_BITS)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if ((hTargetKey == NULL) ||
        (hTargetKey == INVALID_HANDLE_VALUE) ||
        (hSourceKey == NULL) ||
        (hSourceKey == INVALID_HANDLE_VALUE)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (ulLevel == 0) {
        //
        // This is the level at which we should stop merging, so just replace
        // hTargetKey with hSourceKey, and we're done.
        //
        return MyReplaceKey(hSourceKey, hTargetKey);


    } else {
        //
        // At levels above the replacement level, perform a non-destructive
        // merge of intermediate subkeys and values; that is, only copy keys and
        // values from the source to the target if they do not already exist at
        // the target.  Otherwise, leave the target keys and values alone, and
        // keep traversing subkeys as necessary.
        //

        //
        // Find out information about the hSourceKey values and subkeys.
        //
        result = RegQueryInfoKey(hSourceKey,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwSubkeyCount,
                                 &dwMaxSubkeyNameLength,
                                 NULL,
                                 &dwValueCount,
                                 &dwMaxValueNameLength,
                                 &dwMaxValueDataLength,
                                 NULL,
                                 NULL);
        if (result != ERROR_SUCCESS) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("PNPSIF: RegQueryInfoKey failed, ")
                      TEXT("error == 0x%08lx\n"),
                     result));
            goto Clean0;
        }

        //
        // Allocate space to fold the largest hSourceKey subkey, value and data.
        //
        dwMaxSubkeyNameLength++;
        pszSubkeyName = MyMalloc(dwMaxSubkeyNameLength * sizeof(TCHAR));
        if (pszSubkeyName == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE((DBGF_ERRORS,
                      TEXT("PNPSIF: MyMalloc failed allocating subkey name string, ")
                      TEXT("error == 0x%08lx\n"),
                      result));
            goto Clean0;
        }

        dwMaxValueNameLength++;
        pszValueName = MyMalloc(dwMaxValueNameLength * sizeof(TCHAR));
        if (pszValueName == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE((DBGF_ERRORS,
                      TEXT("PNPSIF: MyMalloc failed allocating value name string, ")
                      TEXT("error == 0x%08lx\n"),
                     result));
            goto Clean0;
        }

        pValueData = MyMalloc(dwMaxValueDataLength * sizeof(TCHAR));
        if (pValueData == NULL) {
            result = ERROR_NOT_ENOUGH_MEMORY;
            DBGTRACE((DBGF_ERRORS,
                      TEXT("PNPSIF: MyMalloc failed allocating value data buffer, ")
                      TEXT("error == 0x%08lx\n"),
                      result));
            goto Clean0;
        }


        //
        // Enumerate all hSourceKey values.
        //
        for (dwIndex = 0; dwIndex < dwValueCount; dwIndex++) {

            DWORD dwValueNameLength = dwMaxValueNameLength;
            DWORD dwValueDataLength = dwMaxValueDataLength;
            DWORD dwType;

            result = RegEnumValue(hSourceKey,
                                  dwIndex,
                                  pszValueName,
                                  &dwValueNameLength,
                                  0,
                                  &dwType,
                                  pValueData,
                                  &dwValueDataLength);

            if (result != ERROR_SUCCESS) {
                //
                // Error enumerating values - whatchya gonna do?
                // Just move on and try to merge subkeys the best we can?
                //
                DBGTRACE((DBGF_ERRORS,
                          TEXT("PNPSIF: RegEnumValue returned error == 0x%08lx\n"),
                          result));
                goto EnumSubkeys;
            }

            DBGTRACE((DBGF_INFO,
                      TEXT("PNPSIF: Enumerated value %d == '%s' on hSourceKey.\n"),
                      dwIndex, pszValueName));

            //
            // Query to see if this value exists in the hTargetKey
            //
            result = RegQueryValueEx(hTargetKey,
                                     pszValueName,
                                     0,
                                     NULL,
                                     NULL,
                                     NULL);

            if ((result == ERROR_SUCCESS) &&
                !(ulFlags & PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION)) {
                //
                // The enumerated value already exists under the target key, and
                // we are NOT supposed to replace it.
                //
                DBGTRACE((DBGF_INFO,
                          TEXT("PNPSIF: Value '%s' already exists on hTargetKey.\n"),
                          pszValueName));

            } else if ((result == ERROR_FILE_NOT_FOUND) ||
                       (ulFlags & PNPSIF_RESTORE_REPLACE_TARGET_VALUES_ON_COLLISION)){
                //
                // The enumerated value doesn't exist under the target key, or
                // it does and we're supposed to replace it.
                //
                result = RegSetValueEx(hTargetKey,
                                       pszValueName,
                                       0,
                                       dwType,
                                       pValueData,
                                       dwValueDataLength);
                if (result != ERROR_SUCCESS) {
                    //
                    // Error setting value - whatchya gonna do?
                    // Just move on to the next enumerated value.
                    //
                    DBGTRACE((DBGF_ERRORS,
                              TEXT("PNPSIF: RegSetValueEx failed setting value '%s', ")
                              TEXT("error == 0x%08lx\n"),
                              pszValueName, result));
                }
            } else {
                //
                // RegQueryValueEx returned some other error - weird?
                //
                DBGTRACE((DBGF_ERRORS,
                          TEXT("PNPSIF: RegQueryValueEx failed for value '%s', ")
                          TEXT("error == 0x%08lx\n"),
                          pszValueName, result));
            }

        }


    EnumSubkeys:

        //
        // Perform special processing of the device instance subkeys.
        //
        if ((ulFlags & PNPSIF_RESTORE_TYPE_ENUM) &&
            (ARGUMENT_PRESENT(pContext)) &&
            (ulLevel == ENUM_LEVEL_INSTANCES)) {

            if (*((PBOOL)pContext)) {
                //
                // For root enumerated devices, check for the possibility that
                // redundant instance keys of a device might have been created
                // in the current registry, in which case we should ignore them
                // when migrating to the target registry.
                //

                //
                // The possibility of redundant root-enumerated device
                // instance keys exists when:
                //
                // - the device is root-enumerated
                //
                // - instances of this device already exist in the target hive
                //
                // a particular device instance is redundant if it is a newly
                // created instance in the target registry for a device where
                // other instances already exist.
                //
                DWORD dwTargetSubkeyCount = 0;
                if (RegQueryInfoKey(hTargetKey,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &dwTargetSubkeyCount,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL) != ERROR_SUCCESS) {
                    dwTargetSubkeyCount = 0;
                }
                bPossibleRedundantInstanceKeys = (dwTargetSubkeyCount > 0);
            }
        }

        //
        // Enumerate all hSourceKey subkeys.
        //
        for (dwIndex = 0; dwIndex < dwSubkeyCount; dwIndex++) {

            HKEY  hTargetSubkey = NULL, hSourceSubkey = NULL;
            DWORD dwSubkeyNameLength = dwMaxSubkeyNameLength;

            result = RegEnumKeyEx(hSourceKey,
                                  dwIndex,
                                  pszSubkeyName,
                                  &dwSubkeyNameLength,
                                  0,
                                  NULL,
                                  NULL,
                                  NULL);
            if (result != ERROR_SUCCESS) {
                //
                // Error enumerating subkeys - whatchya gonna do?
                // There is nothing left to do, so just exit.
                //
                DBGTRACE((DBGF_ERRORS,
                          TEXT("PNPSIF: RegEnumKeyEx returned error == 0x%08lx\n"),
                          result));
                goto Clean0;
            }

            DBGTRACE((DBGF_INFO,
                      TEXT("PNPSIF: enumerated subkey %d == '%s' on hSourceKey.\n"),
                      dwIndex, pszSubkeyName));

            //
            // Perform special processing of the Enum subkeys.
            //
            if ((ulFlags & PNPSIF_RESTORE_TYPE_ENUM) &&
                (ARGUMENT_PRESENT(pContext)) &&
                (ulLevel == ENUM_LEVEL_ENUMERATORS)) {
                //
                // At the start of the recursive enumeration for each
                // enumerator subkey, reset our (global) BOOL context
                // variable to keep track of whether subsequent device
                // subkeys represent "ROOT" enumerated devices.
                //
                PBOOL pbIsRootEnumerated = (PBOOL)pContext;

                if (CompareString(LOCALE_INVARIANT,
                                  NORM_IGNORECASE,
                                  (LPTSTR)pszSubkeyName,
                                  -1,
                                  REGSTR_KEY_ROOTENUM,
                                  -1) == CSTR_EQUAL) {
                    *pbIsRootEnumerated = TRUE;
                } else {
                    *pbIsRootEnumerated = FALSE;
                }
            }

            //
            // Open this subkey in hSourceKey
            //
            result = RegOpenKeyEx(hSourceKey,
                                  pszSubkeyName,
                                  0,
                                  KEY_READ,
                                  &hSourceSubkey);

            if (result == ERROR_SUCCESS) {
                //
                // Attempt to open this subkey in the hTargetKey
                //
                result = RegOpenKeyEx(hTargetKey,
                                      pszSubkeyName,
                                      0,
                                      KEY_READ,
                                      &hTargetSubkey);

                if ((result != ERROR_SUCCESS) &&
                    (bPossibleRedundantInstanceKeys)  &&
                    (IsString4DigitOrdinal(pszSubkeyName))) {
                    //
                    // The subkey is a root-enumerated instance key with a
                    // 4-digit ordinal name (most-likely autogenerated), where
                    // we may have redundant keys.
                    //
                    // If this key doesn't exist in the target registry, it was
                    // likely a redundant, autogenerated instance created during
                    // setup because a previous autogenerated key (i.e. one we
                    // just migrated) already existed, we just won't migrate it.
                    //
                    ASSERT(ulFlags & PNPSIF_RESTORE_TYPE_ENUM);
                    ASSERT(ulLevel == ENUM_LEVEL_INSTANCES);
                    ASSERT((ARGUMENT_PRESENT(pContext)) && (*((PBOOL)pContext)));

                } else {

                    if (result == ERROR_SUCCESS) {
                        //
                        // We successfully opened the target subkey above (we
                        // just weren't supposed to delete it) so we should have
                        // a valid handle.
                        //
                        ASSERT(hTargetSubkey != NULL);
                        dwDisposition = REG_OPENED_EXISTING_KEY;

                    } else {
                        //
                        // Create the target subkey.
                        //
                        ASSERT(hTargetSubkey == NULL);

                        result = RegCreateKeyEx(hTargetKey,
                                                pszSubkeyName,
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_ALL_ACCESS,
                                                NULL,
                                                &hTargetSubkey,
                                                &dwDisposition);

                        if (result == ERROR_SUCCESS) {
                            ASSERT(dwDisposition == REG_CREATED_NEW_KEY);
                        }
                    }

                    if (result == ERROR_SUCCESS) {

                        //
                        // Check if the key had already existed.
                        //

                        if (dwDisposition == REG_CREATED_NEW_KEY) {
                            //
                            // We just created this key in the target to replace it
                            // with the corresponding key in the source.
                            //
                            if (!MyReplaceKey(hSourceSubkey, hTargetSubkey)) {
                                DBGTRACE((DBGF_ERRORS,
                                          TEXT("PNPSIF: MyReplaceKey failed with error == 0x%08lx\n"),
                                          GetLastError()));
                            }

                        } else if ((ulFlags & PNPSIF_RESTORE_TYPE_ENUM) &&
                                   (ulLevel == ENUM_LEVEL_INSTANCES) &&
                                   (!IsDeviceConfigured(hTargetSubkey)) &&
                                   (IsDeviceConfigured(hSourceSubkey))) {
                            //
                            // If we are enumerating instances, check if the
                            // instance keys in the target and source are
                            // properly configured.
                            //

                            //
                            // If it is not configured in the target, but is
                            // configured in the source - then we DO want to
                            // replace the target instance key, because it might
                            // be some sort of critical device - like a boot
                            // device.  Even if it's not critical, if the device
                            // has not been seen since before the last upgrade
                            // *prior* to backup, we can't really have much
                            // confidence in those settings anyways.  If neither
                            // the target or source are configured, we may as
                            // well just keep the target, like we do for
                            // everything else.
                            //
                            if (MyReplaceKey(hSourceSubkey, hTargetSubkey)) {
                                //
                                // If we successfully replaced the target instance
                                // key for this device with the source, then also
                                // replace the corresponding Class key for this
                                // instance from the target with the Class key from
                                // the source.
                                //
                                // NOTE: this works because we always restore the
                                // Enum branch before retoring the Class branch, so
                                // the Class keys haven't been touched yet.
                                //

                                if (!ReplaceClassKeyForInstance(hSourceSubkey,
                                                                PnpSifRestoreSourceClassKeyHandle,
                                                                PnpSifRestoreTargetClassKeyHandle)) {
                                    DBGTRACE((DBGF_ERRORS,
                                              TEXT("PNPSIF: ReplaceClassKeyForInstance failed, ")
                                              TEXT("error == 0x%08lx\n"),
                                              GetLastError()));
                                }

                            } else {
                                DBGTRACE((DBGF_ERRORS,
                                          TEXT("PNPSIF: MyReplaceKey failed, error == 0x%08lx\n"),
                                          GetLastError()));
                            }

                        } else if ((ulLevel-1) != 0) {
                            //
                            // We're still above the replacement level, and the key
                            // previously existed in the target, so we're not
                            // supposed to replace it.  Since the next level is NOT
                            // the replacement level, just follow the keys down
                            // recursively.
                            //
                            ASSERT(dwDisposition == REG_OPENED_EXISTING_KEY);

                            if (!RestoreSpecialRegistryData(hSourceSubkey,
                                                            hTargetSubkey,
                                                            ulLevel-1,
                                                            (PVOID)pContext,
                                                            ulFlags)) {
                                //
                                // Error handling the subkeys - whatcha gonna do?
                                //
                                DBGTRACE((DBGF_ERRORS,
                                          TEXT("PNPSIF: RestoreSpecialRegistryData failed ")
                                          TEXT("for subkey %s at level %d, error == 0x%08lx\n"),
                                          pszSubkeyName, ulLevel-1,
                                          GetLastError()));
                            }
                        } else {
                            //
                            // The key already exists, so don't replace it.  Also,
                            // the next level is the replacement level, so don't
                            // recurse either (else we'd replace it).  Basically,
                            // just do nothing here.
                            //
                            ASSERT(ulLevel == 1);
                            ASSERT(dwDisposition == REG_OPENED_EXISTING_KEY);
                        }

                        //
                        // Close the open target subkey.
                        //
                        RegCloseKey(hTargetSubkey);

                    } else {
                        //
                        // could not open/create subkey in taget registry.
                        //
                        DBGTRACE((DBGF_ERRORS,
                                  TEXT("PNPSIF: RegCreateKey failed to create target subkey %s ")
                                  TEXT("with error == 0x%08lx\n"),
                                  pszSubkeyName, result));
                    }
                }

                //
                // Close the enumerated hSourceKey subkey.
                //
                RegCloseKey(hSourceSubkey);

            } else {
                //
                // Could not open the enumerated hSourceKey subkey.
                //
                DBGTRACE((DBGF_ERRORS,
                          TEXT("PNPSIF: RegOpenKey failed to open existing subkey %s, ")
                          TEXT("error == 0x%08lx\n"),
                          pszSubkeyName, result));
            }

        } // for (dwIndex = 0; dwIndex < dwSubkeyCount; dwIndex++)

    } // (ulLevel != 0)


 Clean0:
    //
    // Free any allocated buffers
    //
    if (pszSubkeyName != NULL) {
        MyFree(pszSubkeyName);
    }
    if (pszValueName != NULL) {
        MyFree(pszValueName);
    }
    if (pValueData != NULL) {
        MyFree(pValueData);
    }

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // RestoreSpecialRegistryData



BOOL
MyReplaceKey(
    IN  HKEY  hSourceKey,
    IN  HKEY  hTargetKey
    )
/*++

Routine Description:

    This routine replaces the target registry key with the source registry key.
    This is done by performing a RegSaveKey on the source registry key to a
    temporary file, and restoring that file to the target registry key.  All
    data contained below the target registry key is lost.  The source registry
    key is not modified by this routine.

Arguments:

    hSourceKey   - Handle to the key that is the source of the restore operation.
                   All values and subkeys of the source key will be restored on
                   top of the target key.

    hTargetKey   - Handle to the key that is the target of the restore operation.
                   All values and subkeys of the source key will be restored on
                   top of this key, and all existing values and data underneath
                   this key will be lost.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

Notes:

    Since this routine uses the RegSaveKey and RegRestoreKey registry APIs, it
    is expected that the calling thread/process have both the SE_BACKUP_NAME and
    SE_RESTORE_NAME privileges.

--*/
{
    LONG  result = ERROR_SUCCESS;
    HRESULT hr;
    TCHAR szTempFilePath[MAX_PATH];
    TCHAR szTempFileName[MAX_PATH];
    DWORD dwTemp;


    //
    // Use the temporary directory to store the saved registry key.
    //
    dwTemp = GetTempPath(MAX_PATH, szTempFilePath);
    if ((dwTemp == 0) || (dwTemp > MAX_PATH)) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("PNPSIF: GetTempPath failed, ")
                  TEXT("current directory will be specified.\n")));
        // current path specified with trailing '\', as GetTempPath would have.
        hr = StringCchCopy(szTempFileName,
                           SIZECHARS(szTempFileName),
                           TEXT(".\\"));
        if (FAILED(hr)) {
            result = HRESULT_CODE(hr);
            goto Clean0;
        }
    }

    //
    // Assign the saved registry key a temporary, unique filename.
    //
    if (!GetTempFileName(szTempFilePath,
                         TEXT("PNP"),
                         0, // make sure it's unique
                         szTempFileName)) {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("PNPSIF: GetTempFileName failed with error == 0x%08lx, ")
                  TEXT("using hardcoded temp file name!\n"),
                  GetLastError()));
        hr = StringCchCopy(szTempFileName,
                           SIZECHARS(szTempFileName),
                           szTempFilePath);
        if (FAILED(hr)) {
            result = HRESULT_CODE(hr);
            goto Clean0;
        }
        hr = StringCchCat(szTempFileName,
                          SIZECHARS(szTempFileName),
                          TEXT("~pnpreg.tmp"));
        if (FAILED(hr)) {
            result = HRESULT_CODE(hr);
            goto Clean0;
        }
    }

    DBGTRACE((DBGF_INFO,
              TEXT("PNPSIF: Using temporary filename: %s\n"),
              szTempFileName));

    //
    // A side effect of requesting a "unique" filename from GetTempFileName is
    // that it automatically creates the file.  Unfortunately, RegSaveKey will
    // fail if the specified file already exists, so delete the file now.
    //
    if(pSifUtilFileExists(szTempFileName,NULL)) {
        DBGTRACE((DBGF_INFO,
                  TEXT("PNPSIF: Temporary file %s exists, deleting.\n"),
                  szTempFileName));
        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileName);
    }

    //
    // Save the source key to a file using the temporary file name.
    // (calling thread/process must have the SE_BACKUP_NAME privilege)
    //
    result = RegSaveKey(hSourceKey,
                        szTempFileName,
                        NULL);
    if (result == ERROR_SUCCESS) {
        //
        // Restore the file to the target key.
        // (calling thread/process must have the SE_RESTORE_NAME privilege)
        //
        result = RegRestoreKey(hTargetKey,
                               szTempFileName,
                               REG_FORCE_RESTORE);
        if (result != ERROR_SUCCESS) {
            //
            // Failed to restore the file to the target key!
            //
            DBGTRACE((DBGF_ERRORS,
                      TEXT("PNPSIF: RegRestoreKey from %s failed, ")
                      TEXT("error == 0x%08lx\n"),
                      szTempFileName, result));
        } else {
            DBGTRACE((DBGF_INFO,
                      TEXT("PNPSIF: Key replacement successful.\n")));
        }

        //
        // Delete the temporary file we created, now that we're done with it.
        //
        DBGTRACE((DBGF_INFO,
                  TEXT("PNPSIF: Deleting temporary file %s.\n"),
                  szTempFileName));
        ASSERT(pSifUtilFileExists(szTempFileName,NULL));
        SetFileAttributes(szTempFileName, FILE_ATTRIBUTE_NORMAL);
        DeleteFile(szTempFileName);

    } else {
        //
        // Failed to save the source key.
        //
        DBGTRACE((DBGF_ERRORS,
                  TEXT("PNPSIF: RegSaveKey to %s failed with error == 0x%08lx\n"),
                  szTempFileName, result));
    }

  Clean0:

    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // MyReplaceKey



BOOL
IsString4DigitOrdinal(
    IN  LPTSTR  pszSubkeyName
    )
/*++

Routine Description:

    This routine checks if a subkey name has the form of a 4-digit decimal
    ordinal (e.g. "0000", "0001", ... , "9999"), that are typically given to
    auto-generated root-enumerated device instance ids - i.e. TEXT("%04u").

Arguments:

    pszSubkeyName - Subkey name to check.

Return Value:

    TRUE if the string has the form of a 4-digit ordinal string, FALSE
    otherwise.

--*/
{
    LPTSTR  p;
    ULONG   ulTotalLength = 0;

    if ((!ARGUMENT_PRESENT(pszSubkeyName)) ||
        (pszSubkeyName[0] == TEXT('\0'))) {
        return FALSE;
    }

    for (p = pszSubkeyName; *p; p++) {
        //
        // Count the caharcters in the string, and make sure its not longer than
        // 4 characters.
        //
        ulTotalLength++;
        if (ulTotalLength > 4) {
            return FALSE;
        }

        //
        // Check if the character is non-numeric, non-decimal.
        //
        if ((*p < TEXT('0'))  || (*p > TEXT('9'))) {
            return FALSE;
        }
    }

    if (ulTotalLength != 4) {
        return FALSE;
    }

    return TRUE;

} // IsString4DigitOrdinal



BOOL
IsDeviceConfigured(
    IN  HKEY  hInstanceKey
    )
/*++

Routine Description:

    This routine determines whether the device instance specified by the
    supplied registry key is configured or not. If a device has configflags, and
    CONFIGFLAG_REINSTALL or CONFIGFLAG_FAILEDINSTALL are not set then the
    device is considered configured.

Arguments:

    hInstanceKey  - Handle to a device instance registry key.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    BOOL  bDeviceConfigured = FALSE;
    DWORD dwSize, dwType, dwConfigFlags;

    if ((hInstanceKey == NULL) ||
        (hInstanceKey == INVALID_HANDLE_VALUE)) {
        return FALSE;
    }

    dwSize = sizeof(dwConfigFlags);

    if ((RegQueryValueEx(hInstanceKey,
                         REGSTR_VAL_CONFIGFLAGS,
                         0,
                         &dwType,
                         (LPBYTE)&dwConfigFlags,
                         &dwSize) == ERROR_SUCCESS) &&
        (dwType == REG_DWORD) &&
        !(dwConfigFlags & CONFIGFLAG_REINSTALL) &&
        !(dwConfigFlags & CONFIGFLAG_FAILEDINSTALL)) {

        bDeviceConfigured = TRUE;
    }

    return bDeviceConfigured;

} // IsDeviceConfigured



BOOL
ReplaceClassKeyForInstance(
    IN  HKEY  hSourceInstanceKey,
    IN  HKEY  hSourceRootClassKey,
    IN  HKEY  hTargetRootClassKey
    )
/*++

Routine Description:

    This routine replaces the class key corresponding to the specified device
    instance key (as specified by the "Driver" value in the instance key) in the
    target hive with the class key from the source.

Arguments:

    hSourceInstanceKey  - Handle to a device instance registry key in the source
                          hive.

    hSourceRootClassKey - Handle to the root of the Class branch in the source
                          hive - the same hive as the specified instance key.

    hTargetRootClassKey - Handle to the root of the Class branch in the target
                          hive.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    LONG  result = ERROR_SUCCESS;
    TCHAR szDriverKeyName[MAX_GUID_STRING_LEN + 5]; // "{ClassGUID}\XXXX"
    DWORD dwSize, dwType, dwDisposition;
    HKEY  hSourceClassSubkey = NULL, hTargetClassSubkey = NULL;

    if ((hSourceInstanceKey  == NULL) ||
        (hSourceInstanceKey  == INVALID_HANDLE_VALUE) ||
        (hSourceRootClassKey == NULL) ||
        (hSourceRootClassKey == INVALID_HANDLE_VALUE) ||
        (hTargetRootClassKey == NULL) ||
        (hTargetRootClassKey == INVALID_HANDLE_VALUE)) {
        return FALSE;
    }

    //
    // Read the REGSTR_VAL_DRIVER REG_SZ "Driver" value from the instance key.
    //
    szDriverKeyName[0] = TEXT('\0');
    dwSize = sizeof(szDriverKeyName);

    result = RegQueryValueEx(hSourceInstanceKey,
                             REGSTR_VAL_DRIVER,
                             0,
                             &dwType,
                             (LPBYTE)szDriverKeyName,
                             &dwSize);
    if (result == ERROR_FILE_NOT_FOUND) {
        //
        // No "Driver" value, so there's no class key to migrate, which is fine.
        //
        result = ERROR_SUCCESS;
        goto Clean0;

    } else if ((result != ERROR_SUCCESS) ||
               (dwType != REG_SZ)) {
        //
        // Any other error is a failure to read the value.
        //
        goto Clean0;
    }

    //
    // Open the "Driver" key in the source Class branch.
    //
    result = RegOpenKeyEx(hSourceRootClassKey,
                          szDriverKeyName,
                          0,
                          KEY_READ,
                          &hSourceClassSubkey);
    if (result != ERROR_SUCCESS) {
        //
        // The instance key had a "Driver" value, so a corresponding key
        // *should* exist.  If we couldn't open it, it's from some failure
        // besides that.
        //
        return FALSE;
    }

    //
    // Open / create the corresponding key in the target Class branch.
    //
    result = RegCreateKeyEx(hTargetRootClassKey,
                            szDriverKeyName,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hTargetClassSubkey,
                            &dwDisposition);
    if (result != ERROR_SUCCESS) {
        goto Clean0;
    }

    //
    // Replace the target class subkey with the source.
    //
    if (!MyReplaceKey(hSourceClassSubkey, hTargetClassSubkey)) {
        result = GetLastError();
        DBGTRACE((DBGF_ERRORS,
                  TEXT("PNPSIF: MyReplaceKey failed with error == 0x%08lx\n"),
                  result));
    }

 Clean0:

    if (hTargetClassSubkey) {
        RegCloseKey(hTargetClassSubkey);
    }
    if (hSourceClassSubkey) {
        RegCloseKey(hSourceClassSubkey);
    }
    if (result != ERROR_SUCCESS) {
        SetLastError(result);
    }
    return (result == ERROR_SUCCESS);

} // ReplaceClassKeyForInstance



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pencrypt\pencrypt.c ===
#include <windows.h>
#include <malloc.h>
#include <string.h>
#include <wchar.h>
#include <WINSOCK2.H>
#include <Ws2tcpip.h>
#include <Wincrypt.h>
#include <setupbat.h>

// 40 bit key length
//#define KEYLENGTH	0x00280000
// 128 bit key length
//#define KEYLENGTH	0x00800000
// 56 bit key length needed to use DES.
//#define KEYLENGTH	0x00380000
// 168 bit key length needed to use 3DES.
#define KEYLENGTH	0x00A80000
#define CRYPT_PROV  MS_ENHANCED_PROV_A
#define ENCRYPT_ALGORITHM CALG_3DES
//CALG_RC4
#define IsSpace(c)  ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
// 32 bytes of random password data, generated once using CryptGenRandom
BYTE iPassword[] =  {0xc7, 0x1e, 0x6a, 0xab, 0xe3, 0x8f, 0x76, 0x5b, 0x0d, 0x7b, 0xe0, 0xcb, 0xbf, 0x1c, 0xee, 0x54,
                     0x9d, 0x62, 0xbd, 0xb6, 0x6a, 0x38, 0x69, 0x4b, 0xe1, 0x44, 0x9b, 0x76, 0x4a, 0xe4, 0x79, 0xce};

//=================================================================================================
//
// copied from msdev\crt\src\atox.c
//
// long MyAtoL(char *nptr) - Convert string to long
//
// Purpose:
//       Converts ASCII string pointed to by nptr to binary.
//       Overflow is not detected. So that this lib does not need CRT
//
// Entry:
//       nptr = ptr to string to convert
//
// Exit:
//       return long int value of the string
//
// Exceptions:
//       None - overflow is not detected.
//
//=================================================================================================
long MyAtoL(const char *nptr)
{
    int c;                  /* current char */
    long total;             /* current total */
    int sign;               /* if '-', then negative, otherwise positive */

    // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
    // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
    // DBCS Trailing bytes -- pritvi

    /* skip whitespace */
    while ( IsSpace((int)(unsigned char)*nptr) )
        ++nptr;

    c = (int)(unsigned char)*nptr++;
    sign = c;               /* save sign indication */
    if (c == '-' || c == '+')
        c = (int)(unsigned char)*nptr++;        /* skip sign */

    total = 0;

    while (IsDigit(c)) {
        total = 10 * total + (c - '0');         /* accumulate digit */
        c = (int)(unsigned char)*nptr++;        /* get next char */
    }

    if (sign == '-')
        return -total;
    else
        return total;   /* return result, negated if necessary */
}

// Check that the time/date field has only digits, as a validation that no one manipulated the data
BOOL OnlyDigits(LPSTR szValue)
{
    BOOL bRet = TRUE;
    LPSTR pTemp = szValue;
    while (*pTemp)
    {
        if (!IsDigit(*pTemp))
        {
            bRet = FALSE;
        }
        pTemp++;
    }
    return bRet;
}

// To decode and encode the binary buffer we get from the encyption function
unsigned char * base64decode (unsigned char * bufcoded, DWORD * plDecodedSize)
{
    int pr2six[256];
    int i;
    int j=0;
    unsigned char * cCurr = bufcoded;
    int bDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    unsigned char * bufin;
    unsigned char * bufout;
    unsigned char * temp = NULL;    
    unsigned char * pBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=lstrlenA((char *)cCurr)-1+4;
    *plDecodedSize = lBufSize;

    pBufDecoded = GlobalAlloc(GPTR, lBufSize);
    if(!pBufDecoded) 
    {
	    //_tprintf(_T("Out of memory."));
	    return NULL;
    }
    ZeroMemory(pBufDecoded, lBufSize);
        
    lCount = lstrlenA((char *)cCurr);

    // Do the decoding to new buffer
    bufin = cCurr;
    bufout = pBufDecoded;

    while(lCount > 0) {
        *(bufout++) = (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) = (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) = (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(bufout++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(bufout-pBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (bufin[-1]=='=') lop_off++;
    if (bufin[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    temp = GlobalAlloc(GPTR, (*plDecodedSize) + 2);
    if (temp==NULL) 
    {
	    //_tprintf(_T("Out of memory."));
	    return NULL;
    }
    ZeroMemory(temp, *plDecodedSize);
    memcpy(temp, pBufDecoded, *plDecodedSize);

    temp[(*plDecodedSize)+0] = 0;
    temp[(*plDecodedSize)+1] = 0;

    if (pBufDecoded) {
        GlobalFree(pBufDecoded);
    }
    return temp; 
}

//
// the map for the encoder, according to RFC 1521
//
char _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


unsigned char * base64encode(unsigned char * bufin, int nbytes)
{
    unsigned char *outptr;
    unsigned char *to_return;
    long i;
    long OutBufSize;
    char *six2pr = _six2pr64;


    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nbytes + ((nbytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nbytes
    //
    outptr = GlobalAlloc(GPTR,OutBufSize + 1);
    if(outptr==NULL) {
	//_tprintf(_T("Out of memory."));
	return NULL;
    }
    ZeroMemory(outptr, OutBufSize + 1);
    to_return = outptr;

    nbytes = nbytes - 3;
    //
    // Encode everything
    //  
    for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; // c2
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];// c3
      *(outptr++) = six2pr[bufin[2] & 077];                                  // c4 
      bufin += 3;
    }

    //
    // If nbytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if(i == nbytes) {
	// There are 3 bytes in the last group
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; // c2
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];// c3
      *(outptr++) = six2pr[bufin[2] & 077];                                  // c4 
    } else if(i == nbytes+1) {
      // There are only 2 bytes in the last group 
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; // c2
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((0 >> 6) & 03)];	     // c3
      *(outptr++) = '=';
    } else if(i == nbytes+2) {
      // There are only 1 byte in the last group 
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((0 >> 4) & 017)];	     // c2
      *(outptr++) = '=';
      *(outptr++) = '=';
    }

    *outptr = '\0';

    return to_return;
}


// Unicode Ansi conversion function
LPSTR _PEConvertW2A (
    IN      LPCWSTR Unicode,
    IN      UINT CodePage
    )
{
    LPSTR ansi = NULL;
    DWORD rc;

    if (Unicode)
    {
        rc = WideCharToMultiByte (
                CodePage,
                0,
                Unicode,
                -1,
                NULL,
                0,
                NULL,
                NULL
                );

        if (rc || *Unicode == L'\0') {

            ansi = (LPSTR)GlobalAlloc(GPTR, (rc + 1) * sizeof (CHAR));
            if (ansi) {
                rc = WideCharToMultiByte (
                        CodePage,
                        0,
                        Unicode,
                        -1,
                        ansi,
                        rc + 1,
                        NULL,
                        NULL
                        );

                if (!(rc || *Unicode == L'\0')) {
                    rc = GetLastError ();
                    GlobalFree((PVOID)ansi);
                    ansi = NULL;
                    SetLastError (rc);
                }
            }
        }
    }
    return ansi;
}

// Ansi Unicode conversion function
LPWSTR _PEConvertA2W (
    IN      LPCSTR Ansi,
    IN      UINT CodePage
    )
{
    PWSTR unicode = NULL;
    DWORD rc;

    if (Ansi)
    {
        rc = MultiByteToWideChar (
                CodePage,
                MB_ERR_INVALID_CHARS,
                Ansi,
                -1,
                NULL,
                0
                );

        if (rc || *Ansi == '\0') {

            unicode = (LPWSTR) GlobalAlloc (GPTR, (rc + 1) * sizeof (WCHAR));
            if (unicode) {
                rc = MultiByteToWideChar (
                        CodePage,
                        MB_ERR_INVALID_CHARS,
                        Ansi,
                        -1,
                        unicode,
                        rc + 1
                        );

                if (!(rc || *Ansi == '\0')) {
                    rc = GetLastError ();
                    GlobalFree ((PVOID)unicode);
                    unicode = NULL;
                    SetLastError (rc);
                }
            }
        }
    }
    return unicode;
}

// Ansi version to Encypt the input data.
// The encrypted and base 64 encoded buffer is allocated and returned to the caller.
// The caller needs to GloblaFree the buffer.
HRESULT EncryptDataA(LPSTR szInData, DWORD chSizeIn, LPSTR *szOutData)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    HCRYPTPROV hCryptProv; 
    HCRYPTKEY hKey; 
    HCRYPTHASH hHash; 
    LPSTR pw;
    PBYTE pbData = NULL;

    *szOutData = NULL;
    pw = GlobalAlloc(GPTR, sizeof(iPassword)+1);
    if (pw == NULL)
    {
        return hr;
    }
    memcpy(pw, iPassword, sizeof(iPassword));
    // Get handle to the default provider. 
    if(CryptAcquireContextA(
        &hCryptProv, 
        NULL, 
        CRYPT_PROV,
        PROV_RSA_FULL, 
        CRYPT_VERIFYCONTEXT))
    {
        hr = E_FAIL;
        if(CryptCreateHash(
                        hCryptProv, 
                        CALG_MD5, 
                        0, 
                        0, 
                        &hHash))
        {
            if(CryptHashData(hHash, 
                                (BYTE *)pw, 
                                lstrlenA(pw), 
                                0))
            {
                if(CryptDeriveKey(
                    hCryptProv, 
                    ENCRYPT_ALGORITHM, 
                    hHash, 
                    KEYLENGTH,
                    &hKey))
                {
                    DWORD dwCryptDataLen = chSizeIn;
                    DWORD dwDataLen  = dwCryptDataLen;
                    CryptEncrypt(
                        hKey, 
                        0, 
                        TRUE, 
                        0, 
                        NULL, 
                        &dwCryptDataLen, 
                        dwDataLen);

                    pbData = GlobalAlloc(GPTR, dwCryptDataLen+1);
                    if (pbData != NULL)
                    {
                        memcpy(pbData, szInData, chSizeIn);
                        // size of the buffer
                        dwDataLen  = dwCryptDataLen;
                        // number of bytes to be encrypted
                        dwCryptDataLen = chSizeIn;

                        if(CryptEncrypt(
                            hKey, 
                            0, 
                            TRUE, 
                            0, 
                            pbData, 
                            &dwCryptDataLen, 
                            dwDataLen))
                        {
                            *szOutData = base64encode(pbData, (int)dwCryptDataLen);
                            if (*szOutData)
                            {
                                hr = S_OK;
                            }
                        }
					    else
					    {
						    hr = GetLastError();
					    }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    CryptDestroyKey(hKey);
                }
				else
				{
					hr = GetLastError();
				}
            }
			else
			{
				hr = GetLastError();
			}
            CryptDestroyHash(hHash);
        }
		else
		{
			hr = GetLastError();
		}
        CryptReleaseContext(hCryptProv, 0);
    }
	else
	{
		hr = GetLastError();
	}

    if (pbData)
    {
        GlobalFree(pbData);
    }
    GlobalFree(pw);
    return hr;
}

// Unicode version to Encypt the input data.
// Converts the in data to Ansi and calls the Ansi version and converts the out data to unicode
// and returns the buffer to the caller.
HRESULT EncryptDataW(LPWSTR szInData, DWORD chSizeIn, LPWSTR *szOutData)
{
    HRESULT hr = E_FAIL;
    LPBYTE pBuffer = NULL;
    LPSTR  szData = NULL;

    *szOutData = NULL;
    pBuffer = (LPBYTE)_PEConvertW2A (szInData, CP_ACP);
    if (pBuffer == NULL)
    {
        return hr;
    }

    if ((hr = EncryptDataA(pBuffer, lstrlenA(pBuffer)+1, &szData)) == S_OK)
    {
        *szOutData = _PEConvertA2W (szData, CP_ACP);
        if ((*szOutData) == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        GlobalFree(szData);
    }
    GlobalFree(pBuffer);

    return hr;
}

HRESULT DecryptDataA(LPSTR szInData, LPSTR *szOutData)
{
    HRESULT hr = E_FAIL;
    HCRYPTPROV hCryptProv;
    HCRYPTKEY hKey; 
    HCRYPTHASH hHash; 
    DWORD dwErr;
    DWORD dwCipherTextLen = lstrlenA(szInData);
    char *pw;
    DWORD dwCount;
    char *pBuffer;

    *szOutData = NULL;

    pw = GlobalAlloc(GPTR, sizeof(iPassword)+1);
    if (pw == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        return hr;
    }
    memcpy(pw, iPassword, sizeof(iPassword));

	pBuffer = (char *) (base64decode((unsigned char *)szInData, &dwCount));
    if (pBuffer == NULL)
    {
        GlobalFree(pw);
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        return hr;
    }

    // Get a handle to the default provider. 
    if(CryptAcquireContextA(
        &hCryptProv, 
        NULL, 
        CRYPT_PROV,
        PROV_RSA_FULL, 
        CRYPT_VERIFYCONTEXT))
    {
        hr = E_FAIL;
        // Create a hash object. 
        if(CryptCreateHash(
            hCryptProv, 
            CALG_MD5, 
            0, 
            0, 
            &hHash))
        {
            if(CryptHashData(hHash, 
                                (BYTE *)pw, 
                                lstrlenA(pw), 
                                0))
            {
                if(CryptDeriveKey(
                    hCryptProv, 
                    ENCRYPT_ALGORITHM, 
                    hHash, 
                    KEYLENGTH,
                    &hKey))
                {
                    // pBuffer is bigger when the data is encrypted.
                    // The decrypted data (on output) is smaller, because we are using
                    // a block cyoher at encryption.
                    if(CryptDecrypt(
                        hKey, 
                        0, 
                        TRUE, 
                        0, 
                        pBuffer, 
                        &dwCount))
                    {
                        *szOutData = GlobalAlloc(GPTR, dwCount+1);
                        if (*szOutData)
                        {
                            // lstrcpyn includes the NULL in the count and makes sure there is one.
                            lstrcpynA(*szOutData, pBuffer, dwCount+1);
                            hr = S_OK;
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                    else
                    {
                        hr = GetLastError();
                    }
                    CryptDestroyKey(hKey); 
                }
                else
                {
                    hr = GetLastError();
                }

            }
            else
            {
                hr = GetLastError();
            }
            CryptDestroyHash(hHash); 
            hHash = 0; 

        }
        else
        {
            hr = GetLastError();
        }
        CryptReleaseContext(hCryptProv, 0); 
    }
    else
    {
        hr = GetLastError();
    }
    GlobalFree(pBuffer);
    GlobalFree(pw);
    return hr;

}

HRESULT DecryptDataW(LPWSTR szInData, LPWSTR *szOutData)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    LPBYTE pBuffer = NULL;
    LPSTR  szData = NULL;

    *szOutData = NULL;
    pBuffer = (LPBYTE)_PEConvertW2A (szInData, CP_ACP);
    if (pBuffer == NULL)
    {
        return hr;
    }
    if ((hr = DecryptDataA(pBuffer, &szData)) == S_OK)
    {
        *szOutData = _PEConvertA2W (szData, CP_ACP);
        if ((*szOutData) == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        GlobalFree(szData);
    }
    GlobalFree(pBuffer);

    return hr;
}


#define _SECOND             ((__int64) 10000000)
#define _MINUTE             (60 * _SECOND)
#define _HOUR               (60 * _MINUTE)
#define _DAY                (24 * _HOUR)

// encode the position of the PID character. 0 is for the dashes
int iPID[] = {3  ,251,43 ,89 ,75,0,
              123,35 ,23 ,97 ,77,0,
              5  ,135,189,213,13,0,
              245,111,91 ,71 ,65,0,
              25 ,49 ,81 ,129,239};
int iTime1[] = {253, 247, 233, 221, 211, 191, 181, 171, 161, 151, 141, 131, 121, 112, 101, 93, 80, 70, 61, 51};
int iTime2[] = {250, 242, 237, 225, 215, 195, 185, 175, 165, 155, 145, 137, 125, 115, 105, 95, 85, 73, 67, 55};

HRESULT PrepareEncryptedPIDA(LPSTR szPID, UINT uiDays, LPSTR *szOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    HCRYPTPROV   hCryptProv;
    FILETIME ft1, ft2;
    LONGLONG ll;
    LONGLONG ll2;
    char szLine[256];

    GetSystemTimeAsFileTime(&ft1);
    ll = ((LONGLONG)ft1.dwHighDateTime << 32) + ft1.dwLowDateTime;
    ll2 = ll - (_HOUR*12); // Substract 12 hours
    ll += (uiDays*_DAY) + (_HOUR*24); // Add 24 hours

    ft1.dwLowDateTime = (DWORD)ll2;
    ft1.dwHighDateTime = (DWORD)(ll2 >> 32);

    ft2.dwLowDateTime = (DWORD)ll;
    ft2.dwHighDateTime = (DWORD)(ll >> 32);

    // Build a 256 character string that we encode. In the 256 character strign we hide
    // the PID and the time/date info for the interval the encypted data is valid.
    // We need 20 characters each for the start and end of the time interval
    // and we need 25 characters for the PID. 20+20+25 = 65 characters. All other characters
    // are random.
    // 1. fill the string with random characters
    // 2. replace some with the PID charactes
    // 3. replace some with the time/date info
    if(CryptAcquireContextA(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) 
    {
        int i;
        hr = S_OK;
        if(!CryptGenRandom(hCryptProv, sizeof(szLine), (PBYTE)szLine)) 
        {
            hr = GetLastError();
        }
        CryptReleaseContext(hCryptProv, 0);
        // in the case the random generator create 0x0 we want to replace it with 
        // some value, otherwise we cannot use it as a character string,
        // the string would be terminated.
        for (i = 0; i < sizeof(szLine); i++)
        {
            if (szLine[i] == '\0')
            {
                szLine[i] = 0x01;
            }
        }
        szLine[i-1] = '\0';   // Make sure we have a terminated string.
    }
    if (hr == S_OK)
    {
        char szTime[21];    // 10 digits for dwHighDateTime and 10 for dwLowDateTime + termination
        // The buffer is filled with random characters
        // Now insert the PID characters
        int i = 0;
        while (szPID[i])
        {
            if (szPID[i] != '-')
            {
                szLine[iPID[i]] = szPID[i];
            }
            i++;
        }
        // Now fill in the time-date info
        wsprintf(szTime, "%010lu%010lu", ft1.dwHighDateTime, ft1.dwLowDateTime);
        i = 0;
        while (szTime[i])
        {
            szLine[iTime1[i]] = szTime[i];
            i++;
        }
        wsprintf(szTime, "%010lu%010lu", ft2.dwHighDateTime, ft2.dwLowDateTime);
        i = 0;
        while (szTime[i])
        {
            szLine[iTime2[i]] = szTime[i];
            i++;
        }
        // szLine has the mengled data in it. Pass it to the encryption.
        hr = EncryptDataA(szLine, sizeof(szLine), szOut);
    }
    return hr;
}

HRESULT PrepareEncryptedPIDW(LPWSTR szPID, UINT uiDays, LPWSTR *szOutData)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    LPSTR  pPID = NULL;
    LPSTR  szOut = NULL;

    *szOutData = NULL;
    pPID = _PEConvertW2A (szPID, CP_ACP);
    if (pPID != NULL)
    {
        hr = PrepareEncryptedPIDA(pPID, uiDays, &szOut);
        if (hr == S_OK)
        {
            *szOutData = _PEConvertA2W (szOut, CP_ACP);
            if (*szOutData)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            GlobalFree(szOut);
        }
        GlobalFree(pPID);
    }
    return hr;
}

HRESULT ValidateEncryptedPIDA(LPSTR PID, LPSTR *szOutData)
{
    HRESULT hr = E_FAIL;
	LPSTR szDecrypt = NULL;
    FILETIME ft, ftCurrent;
    LONGLONG ll1, ll2, llCurrent;
    int   iCount = 0;
    char  szPID[(5*5)+5]; // 5 characters 5 times + '-' inbetween + termimation
    char  szTime[11];       // each part of hte time is 10 digits + termination

    GetSystemTimeAsFileTime(&ftCurrent);
    hr = DecryptDataA(PID, &szDecrypt);
    if (hr == S_OK)
    {
        int i = 0;
        hr = 0x01;
        // Extract the time values first.
        while (i < 10)
        {
            szTime[i] = szDecrypt[iTime1[i]];
            i++;
        }
        szTime[10] = '\0';
        if (OnlyDigits(szTime))       // 1. time
        {
            ft.dwHighDateTime = MyAtoL(szTime);
            while (i < 20)
            {
                szTime[i-10] = szDecrypt[iTime1[i]];
                i++;
            }
            szTime[10] = '\0';
            if (OnlyDigits(szTime))
            {
                ft.dwLowDateTime = MyAtoL(szTime);
                ll1 = ((LONGLONG)ft.dwHighDateTime << 32) + ft.dwLowDateTime;
                ll1 = ll1 /_HOUR; // FileTime in hours;
                hr = S_OK;
            }
        }
        if (hr == S_OK)
        {
            hr = 0x02;
            i = 0;
            while (i < 10)
            {
                szTime[i] = szDecrypt[iTime2[i]];
                i++;
            }
            szTime[10] = '\0';
            if (OnlyDigits(szTime))       // 1. time
            {
                ft.dwHighDateTime = MyAtoL(szTime);
                while (i < 20)
                {
                    szTime[i-10] = szDecrypt[iTime2[i]];
                    i++;
                }
                szTime[10] = '\0';
                if (OnlyDigits(szTime))
                {
                    ft.dwLowDateTime = MyAtoL(szTime);
                    ll2 = ((LONGLONG)ft.dwHighDateTime << 32) + ft.dwLowDateTime;
                    ll2 = ll2 /_HOUR; // FileTime in hours;
                    hr = S_OK;
                }
            }
        }
        if (hr == S_OK)
        {
            // Now that we have the time values, compare them and make sure that the current
            // time falls inside the time interval.
            hr = 0x03;
            llCurrent = ((LONGLONG)ftCurrent.dwHighDateTime << 32) + ftCurrent.dwLowDateTime;
            llCurrent = llCurrent /_HOUR; // FileTime in hours;

            if ((ll1 <= llCurrent) && ( llCurrent <= ll2))
            {
                i = 0;
                // Time is OK.
                // Extract the PID
                while (i < sizeof(iPID)/sizeof(iPID[0]))
                {
                    if (iPID[i] != 0)
                    {
                        szPID[i] = szDecrypt[iPID[i]];
                    }
                    else
                    {
                        szPID[i] = '-';
                    }
                    i++;
                }
                szPID[i] = '\0';
                *szOutData = (LPSTR)GlobalAlloc(GPTR, lstrlen(szPID)+1);
                if (*szOutData) 
                {
                    lstrcpy(*szOutData, szPID);
                    hr = S_OK;
                }
            }
        }
    }
    if (szDecrypt)
    {
        GlobalFree(szDecrypt);
    }
    return hr;
}

HRESULT ValidateEncryptedPIDW(LPWSTR szPID, LPWSTR *szOutData)
{
    HRESULT hr = E_FAIL;
    LPSTR  szData = NULL;
    LPSTR  pPid = NULL;

    pPid = (LPBYTE)_PEConvertW2A (szPID, CP_ACP);
    if (pPid != NULL)
    {
        if ((hr = ValidateEncryptedPIDA(pPid, &szData)) == S_OK)
        {
            *szOutData = _PEConvertA2W (szData, CP_ACP);
            if (*szOutData)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            GlobalFree(szData);
        }
        GlobalFree(pPid);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hr;
}

#if 0
void
_stdcall
ModuleEntry(
    VOID
    )
{

    CHAR szInData[256];
    CHAR szPID[] = "Ctpdw-6q4d3-wrgdy-796g2-9vrmq";
	LPSTR szOutData = NULL;
	CHAR *szDecrypt = NULL;
#if 0
    SYSTEMTIME  CurrentTime;
    SYSTEMTIME  UniversalTime;

    GetLocalTime(&UniversalTime);

    wsprintf( szInData, "%s$%02d-%02d-%04d %02d:%02d:%02d",
        szPID,
        UniversalTime.wMonth,
        UniversalTime.wDay,
        UniversalTime.wYear,
        UniversalTime.wHour,
        UniversalTime.wMinute,
        UniversalTime.wSecond);

    WritePrivateProfileStringA("UserData","ProductID", szInData, "f:\\test.ini");
	EncryptDataA((LPSTR)szInData, sizeof(szInData), &szOutData);
    if (szOutData)
    {
        WritePrivateProfileStringA("UserData","ProductIDEncryped", szOutData, "f:\\test.ini");
	    DecryptDataA(szOutData, &szDecrypt);
        if (lstrcmpA(szInData, szDecrypt) == 0)
        {
            WritePrivateProfileStringA("UserData","Compare", "Same", "f:\\test.ini");
        }
        else
        {
            WritePrivateProfileStringA("UserData","Compare", "Different", "f:\\test.ini");
        }
        GlobalFree ((PVOID)szOutData);
        if (szDecrypt)
        {
            WritePrivateProfileStringA("UserData","ProductIDDecypted", szDecrypt, "f:\\test.ini");
            GlobalFree ((PVOID)szDecrypt);
        }
    }
#else
    WritePrivateProfileStringA("UserData","ProductID", szPID, "f:\\test.ini");
    if (PrepareEncryptedPIDA(szPID, 5, &szOutData) == S_OK)
    {
        WritePrivateProfileStringA("UserData","ProductIDEncryped", szOutData, "f:\\test.ini");
        if (ValidateEncryptedPIDA(szOutData, &szDecrypt) == S_OK)
        {
            WritePrivateProfileStringA("UserData","ProductIDDecypted", szDecrypt, "f:\\test.ini");
        }
    }
#endif
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\pnpsif.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    pnpsif.h

Abstract:

    This module contains the public prototypes for this module.

    (This header file is not actually included anywhere, it serves to reference
    the routines in this library that are called externally.)

Author:

    Jim Cavalaris (jamesca) 3-07-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// public prototypes for Plug and Play registry migration routines.
// (prototyped in ntsetup\syssetup\asr.c,
// called by syssetup.dll!AsrCreateStateFileW)
//

BOOL
AsrCreatePnpStateFileW(
    IN  PCWSTR    FilePath
    );

//
// public prototypes for Plug and Play registry migration routines.
// (prototyped in ntsetup\winnt32\dll\winnt32.h,
// called by winnt32u.dll!DoWriteParametersFile)
//

BOOL
MigrateDeviceInstanceData(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateClassKeys(
    OUT LPTSTR *Buffer
    );

BOOL
MigrateHashValues(
    OUT LPTSTR  *Buffer
    );

//
// public prototypes for Plug and Play registry merge-restore routines.
// (prototype - TBD, called by - TBD)
//

BOOL
AsrRestorePlugPlayRegistryData(
    IN  HKEY    SourceSystemKey,
    IN  HKEY    TargetSystemKey,
    IN  DWORD   Flags,
    IN  PVOID   Reserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\sif.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    sif.c

Abstract:

    This module contains the following routines for manipulating the sif file in
    which Plug and Play migration data will be stored:

        AsrCreatePnpStateFileW
        AsrCreatePnpStateFileA

Author:

    Jim Cavalaris (jamesca) 07-Mar-2000

Environment:

    User-mode only.

Revision History:

    07-March-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "debug.h"
#include "pnpsif.h"

#include <pnpmgr.h>
#include <setupbat.h>


//
// definitions
//

// Maximum length of a line in the sif file
#define MAX_SIF_LINE 4096


//
// private prototypes
//

BOOL
CreateSifFileW(
    IN  PCWSTR        FilePath,
    IN  BOOL          CreateNew,
    OUT LPHANDLE      SifHandle
    );

BOOL
WriteSifSection(
    IN  CONST HANDLE  SifHandle,
    IN  PCTSTR        SectionName,
    IN  PCTSTR        SectionData,
    IN  BOOL          Ansi
    );


//
// routines
//


BOOL
AsrCreatePnpStateFileW(
    IN  PCWSTR    lpFilePath
    )
/*++

Routine Description:

    Creates the ASR PNP state file (asrpnp.sif) at the specified file-path
    during an ASR backup operation.  This sif file is retrieved from the ASR
    floppy disk during the setupldr phase of a clean install, and in used during
    text mode setup.

Arguments:

    lpFilePath - Specifies the path to the file where the state file is to be
                 created.

Return Value:

    TRUE if successful, FALSE otherwise.  Upon failure, additional information
    can be retrieved by calling GetLastError().

--*/
{
    BOOL    result = TRUE;
    BOOL    bAnsiSif = TRUE;  // always write ANSI sif files.
    LPTSTR  buffer = NULL;
    HANDLE  sifHandle = NULL;

    //
    // Create an empty sif file using the supplied path name.
    //
    result = CreateSifFileW(lpFilePath,
                            TRUE,  // create a new asrpnp.sif file
                            &sifHandle);
    if (!result) {
        //
        // LastError already set by CreateSifFile.
        //
        DBGTRACE((DBGF_ERRORS,
                  TEXT("AsrCreatePnpStateFile: CreateSifFileW failed for file %s, ")
                  TEXT("error=0x%08lx\n"),
                  lpFilePath, GetLastError()));
        return FALSE;
    }

    //
    // Do the device instance migration stuff...
    //
    if (MigrateDeviceInstanceData(&buffer)) {

        //
        // Write the device instance section to the sif file.
        //
        result = WriteSifSection(sifHandle,
                                 WINNT_DEVICEINSTANCES,
                                 buffer,
                                 bAnsiSif);   // Write sif section as ANSI
        if (!result) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("AsrCreatePnpStateFile: WriteSifSection failed for [%s], ")
                      TEXT("error=0x%08lx\n"),
                      WINNT_DEVICEINSTANCES, GetLastError()));
        }

        //
        // Free the allocated buffer.
        //
        LocalFree(buffer);
        buffer = NULL;

    } else {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("AsrCreatePnpStateFile: MigrateDeviceInstanceData failed, ")
                  TEXT("error=0x%08lx\n"),
                  GetLastError()));
    }

    //
    // Do the class key migration stuff...
    //
    if (MigrateClassKeys(&buffer)) {

        //
        // Write the class key section to the sif file.
        //
        result = WriteSifSection(sifHandle,
                                 WINNT_CLASSKEYS,
                                 buffer,
                                 bAnsiSif);   // Write sif section as ANSI

        if (!result) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("AsrCreatePnpStateFile: WriteSifSection failed for [%s], ")
                      TEXT("error=0x%08lx\n"),
                      WINNT_CLASSKEYS, GetLastError()));
        }

        //
        // Free the allocated buffer.
        //
        LocalFree(buffer);
        buffer = NULL;
    } else {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("AsrCreatePnpStateFile: MigrateClassKeys failed, ")
                  TEXT("error=0x%08lx\n"),
                  GetLastError()));
    }


    //
    // Do the hash value migration stuff...
    //
    if (MigrateHashValues(&buffer)) {

        //
        // Write the hash value section to the sif file.
        //
        result = WriteSifSection(sifHandle,
                                 WINNT_DEVICEHASHVALUES,
                                 buffer,
                                 bAnsiSif);   // Write sif section as ANSI?
        if (!result) {
            DBGTRACE((DBGF_ERRORS,
                      TEXT("AsrCreatePnpStateFile: WriteSifSection failed for [%s], ")
                      TEXT("error=0x%08lx\n"),
                      WINNT_DEVICEHASHVALUES, GetLastError()));
        }

        //
        // Free the allocated buffer.
        //
        LocalFree(buffer);
        buffer = NULL;
    } else {
        DBGTRACE((DBGF_ERRORS,
                  TEXT("AsrCreatePnpStateFile: MigrateHashValues failed, ")
                  TEXT("error=0x%08lx\n"),
                  GetLastError()));
    }

    //
    // Close the sif file.
    //
    if (sifHandle) {
        CloseHandle(sifHandle);
    }

    //
    // Reset the last error as successful in case we encountered a non-fatal
    // error along the way.
    //
    SetLastError(ERROR_SUCCESS);
    return TRUE;

} // AsrCreatePnpStateFile()



BOOL
AsrCreatePnpStateFileA(
    IN  PCSTR    lpFilePath
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.


--*/
{
    WCHAR wszFilePath[MAX_PATH + 1];


    //
    // Validate arguments.
    //
    if (!ARGUMENT_PRESENT(lpFilePath) ||
        strlen(lpFilePath) > MAX_PATH) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Convert the file path to a wide string.
    //
    memset(wszFilePath, 0, MAX_PATH + 1);

    if (!(MultiByteToWideChar(CP_ACP,
                              0,
                              lpFilePath,
                              -1,
                              wszFilePath,
                              MAX_PATH + 1))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Return the result of calling the wide char version
    //
    return AsrCreatePnpStateFileW(wszFilePath);

} // AsrCreatePnpStateFileA()



BOOL
CreateSifFileW(
    IN  PCWSTR    lpFilePath,
    IN  BOOL      bCreateNew,
    OUT LPHANDLE  lpSifHandle
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.


--*/
{
    DWORD Err = NO_ERROR;
    SID_IDENTIFIER_AUTHORITY sidNtAuthority = SECURITY_NT_AUTHORITY;
    PSID  psidAdministrators = NULL;
    PSID  psidBackupOperators = NULL;
    PSID  psidLocalSystem = NULL;
    PACL  pDacl = NULL;
    ULONG ulAclSize;
    SECURITY_ATTRIBUTES sa;
    SECURITY_DESCRIPTOR sd;
    HANDLE sifhandle = NULL;


    //
    // Validate arguments.
    //
    if (!ARGUMENT_PRESENT(lpFilePath) ||
        (wcslen(lpFilePath) > MAX_PATH) ||
        !ARGUMENT_PRESENT(lpSifHandle)) {
        Err = ERROR_INVALID_PARAMETER;
        goto Clean0;
    }

    //
    // Initialize output paramaters.
    //
    *lpSifHandle = NULL;

    //
    // Construct the security attributes for the sif file.
    // Allow access for Administrators, BackupOperators, and LocalSystem.
    //
    if (!AllocateAndInitializeSid(
            &sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(psidAdministrators));

    if (!AllocateAndInitializeSid(
            &sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_BACKUP_OPS,
            0, 0, 0, 0, 0, 0,
            &psidBackupOperators)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(psidBackupOperators));

    if (!AllocateAndInitializeSid(
            &sidNtAuthority,
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(psidLocalSystem));

    //
    // Determine the size required for the DACL
    //
    ulAclSize  = sizeof(ACL);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidAdministrators) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidBackupOperators) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(psidLocalSystem) - sizeof(DWORD);

    //
    // Allocate and initialize the DACL
    //
    pDacl =(PACL)LocalAlloc(0, ulAclSize);

    if (pDacl == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    if (!InitializeAcl(pDacl, ulAclSize, ACL_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for Administrators FILE_ALL_ACCESS
    //
    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            FILE_ALL_ACCESS,
            psidAdministrators)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for BackupOperators FILE_ALL_ACCESS
    //
    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            FILE_ALL_ACCESS,
            psidBackupOperators)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for LocalSystem FILE_ALL_ACCESS
    //
    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            FILE_ALL_ACCESS,
            psidLocalSystem)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidAcl(pDacl));

    //
    // Initialize the security descriptor
    //
    if (!InitializeSecurityDescriptor(
            &sd, SECURITY_DESCRIPTOR_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Set the new DACL in the security descriptor
    //
    if (!SetSecurityDescriptorDacl(
            &sd, TRUE, pDacl, FALSE)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSecurityDescriptor(&sd));

    //
    // Add the security descriptor to the security attributes
    //
    ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = TRUE;

    //
    // Create the file. The handle will be closed by the caller, once they are
    // finished with it.
    //
    sifhandle = CreateFileW(lpFilePath,
                            GENERIC_WRITE | GENERIC_READ,
                            FILE_SHARE_READ,
                            &sa,
                            bCreateNew ? CREATE_ALWAYS : OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);

    if (sifhandle == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(sifhandle != NULL);

    //
    // Return the sif handle to the caller only if successful.
    //
    *lpSifHandle = sifhandle;

  Clean0:

    if (pDacl != NULL) {
        LocalFree(pDacl);
    }

    if (psidLocalSystem != NULL) {
        FreeSid(psidLocalSystem);
    }

    if (psidBackupOperators != NULL) {
        FreeSid(psidBackupOperators);
    }

    if (psidAdministrators != NULL) {
        FreeSid(psidAdministrators);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

} // CreateSifFileW()



BOOL
WriteSifSection(
    IN  CONST HANDLE  SifHandle,
    IN  PCTSTR        SectionName,
    IN  PCTSTR        SectionData,
    IN  BOOL          Ansi
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.


--*/
{
    BYTE    buffer[(MAX_SIF_LINE+1)*sizeof(WCHAR)];
    DWORD   dwSize, dwTempSize;
    PCTSTR  p;
    HRESULT hr;


    //
    // Validate the arguments
    //
    if (!ARGUMENT_PRESENT(SifHandle)   ||
        !ARGUMENT_PRESENT(SectionName) ||
        !ARGUMENT_PRESENT(SectionData)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Write the section name to the sif file.
    //
    if (Ansi) {
        //
        // Write ANSI strings to the sif file
        //
#if UNICODE
        hr = StringCbPrintfExA((LPSTR)buffer,
                               sizeof(buffer),
                               NULL, NULL,
                               STRSAFE_NULL_ON_FAILURE,
                               (LPCSTR)"[%ls]\r\n",
                               SectionName);
#else   // ANSI
        hr = StringCbPrintfExA((LPSTR)buffer,
                               sizeof(buffer),
                               NULL, NULL,
                               STRSAFE_NULL_ON_FAILURE,
                               (LPCSTR)"[%s]\r\n",
                               SectionName);
#endif  // UNICODE/ANSI

        //
        // If unable to write the section name to the sif file, we can't write
        // the section at all.
        //
        if (FAILED(hr)) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        dwSize = (DWORD)strlen((PSTR)buffer);
    } else {
        //
        // Write Unicode strings to the sif file
        //
#if UNICODE
        hr = StringCbPrintfExW((LPWSTR)buffer,
                               sizeof(buffer),
                               NULL, NULL,
                               STRSAFE_NULL_ON_FAILURE,
                               (LPCWSTR)L"[%ws]\r\n",
                               SectionName);
#else   // ANSI
        hr = StringCbPrintfExW((LPWSTR)buffer,
                               sizeof(buffer),
                               NULL, NULL,
                               STRSAFE_NULL_ON_FAILURE,
                               (LPCWSTR)L"[%S]\r\n",
                               SectionName);
#endif  // UNICODE/ANSI

        //
        // If unable to write the section name to the sif file, we can't write
        // the section at all.
        //
        if (FAILED(hr)) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }

        dwSize = (DWORD)wcslen((PWSTR)buffer) * sizeof(WCHAR);
    }

    if (!WriteFile(SifHandle, buffer, dwSize, &dwTempSize, NULL)) {
        //
        // LastError already set by WriteFile
        //
        return FALSE;
    }

    DBGTRACE((DBGF_INFO, TEXT("[%s]\n"), SectionName));

    //
    // Write the multi-sz section data to the file.
    //
    for (p = SectionData; *p != TEXT('\0'); p += lstrlen(p) + 1) {

        if (Ansi) {
            //
            // Write ANSI strings to the sif file
            //
#if UNICODE
            hr = StringCbPrintfExA((LPSTR)buffer,
                                   sizeof(buffer),
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   (LPCSTR)"%ls\r\n",
                                   p);
#else   // ANSI
            hr = StringCbPrintfExA((LPSTR)buffer,
                                   sizeof(buffer),
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   (LPCSTR)"%s\r\n",
                                   p);
#endif  // UNICODE/ANSI

            //
            // If unable to write this string to the sif file, skip to the next.
            //
            if (FAILED(hr)) {
                continue;
            }

            dwSize = (DWORD)strlen((PSTR)buffer);
        } else {
            //
            // Write Unicode strings to the sif file
            //
#if UNICODE
            hr = StringCbPrintfExW((LPWSTR)buffer,
                                   sizeof(buffer),
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   (LPCWSTR)L"%ws\r\n",
                                   p);
#else   // ANSI
            hr = StringCbPrintfExW((LPWSTR)buffer,
                                   sizeof(buffer),
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE,
                                   (LPCWSTR)L"%S\r\n",
                                   p);
#endif  // UNICODE/ANSI

            //
            // If unable to write this string to the sif file, skip to the next.
            //
            if (FAILED(hr)) {
                continue;
            }

            dwSize = (DWORD)wcslen((PWSTR)buffer) * sizeof(WCHAR);
        }

        if (!WriteFile(SifHandle, buffer, dwSize, &dwTempSize, NULL)) {
            //
            // LastError already set by WriteFile
            //
            return FALSE;
        }

        DBGTRACE((DBGF_INFO, TEXT("%s\n"), p));
    }

    return TRUE;

} // WriteSifSection()



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\util.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    util.h

Abstract:

    This module contains utility routines for the PnP registry merge-restore
    routines.

Author:

    Jim Cavalaris (jamesca) 2-10-2000

Environment:

    User-mode only.

Revision History:

    10-February-2000     jamesca

        Creation and initial implementation.

--*/


#define ARRAY_SIZE(array)                 (sizeof(array)/sizeof(array[0]))
#define SIZECHARS(x)                      (sizeof((x))/sizeof(TCHAR))


BOOL
pSifUtilFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
pSifUtilStringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setexts\crt.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    crt.c

Abstract:

    This file implements certain crt apis that are not present in
    libcntpr.lib. This implementation is NOT multi-thread safe.

Author:

    Wesley Witt (wesw) 6-Feb-1994

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

void * __cdecl
malloc(
    size_t sz
    )
{

    return LocalAlloc( LPTR, sz );

}

void __cdecl
free(
    void * ptr
    )
{

    LocalFree( ptr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setexts\ntsdextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntosp.h>

#define NOEXTAPI
#include <wdbgexts.h>
#undef DECLARE_API

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <winsock2.h>
#include <lmerr.h>
#include "oc.h"
#include "ocmdeb.h"

//#include <ntcsrsrv.h>

#define move(dst, src)\
try {\
    ReadMemory((DWORD_PTR) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((DWORD_PTR) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PWINDBG_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
//#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define ReadMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) ) \
  : ExtensionApis.lpReadProcessMemoryRoutine( (DWORD_PTR)(a), (b), (c), (d) ))

//#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )
#define WriteMemory(a,b,c,d) \
    ((ExtensionApis.nSize == sizeof(WINDBG_OLD_EXTENSION_APIS)) ? \
    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) ) \
  : ExtensionApis.lpWriteProcessMemoryRoutine( (DWORD_PTR)(a), (LPVOID)(b), (c), (d) ))

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;

//
// debuggee typedefs
//
#define HASH_BUCKET_COUNT 509

typedef struct _MY_LOCK {
    HANDLE handles[2];
} MYLOCK, *PMYLOCK;

typedef struct _STRING_TABLE {
    PUCHAR Data;    // First HASH_BUCKET_COUNT DWORDS are StringNodeOffset array.
    DWORD DataSize;
    DWORD BufferSize;
    MYLOCK Lock;
    UINT ExtraDataSize;
} STRING_TABLE, *PSTRING_TABLE;

typedef struct _STRING_NODEA {
    //
    // This is stored as an offset instead of a pointer
    // because the table can move as it's built
    // The offset is from the beginning of the table
    //
    ULONG_PTR NextOffset;
    //
    // This field must be last
    //
    CHAR String[ANYSIZE_ARRAY];
} STRING_NODEA, *PSTRING_NODEA;

typedef struct _STRING_NODEW {
    //
    // This is stored as an offset instead of a pointer
    // because the table can move as it's built
    // The offset is from the beginning of the table
    //
    ULONG_PTR NextOffset;
    //
    // This field must be last
    //
    WCHAR String[ANYSIZE_ARRAY];
} STRING_NODEW, *PSTRING_NODEW;


typedef struct _DISK_SPACE_LIST {

    MYLOCK Lock;

    PVOID DrivesTable;

    UINT Flags;

} DISK_SPACE_LIST, *PDISK_SPACE_LIST;

//
// These structures are stored as data associated with
// paths/filenames in the string table.
//

typedef struct _XFILE {
    //
    // -1 means it doesn't currently exist
    //
    LONGLONG CurrentSize;

    //
    // -1 means it will be deleted.
    //
    LONGLONG NewSize;

} XFILE, *PXFILE;


typedef struct _XDIRECTORY {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the FilesTable after they
    // are put on a file queue and then the queue is committed.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID FilesTable;

} XDIRECTORY, *PXDIRECTORY;


typedef struct _XDRIVE {
    //
    // Value indicating how many bytes will be required
    // to hold all the files in the space list for this drive.
    //
    // This may be a negative number indicating that space will
    // actually be freed!
    //
    LONGLONG SpaceRequired;

    PVOID DirsTable;

    DWORD BytesPerCluster;

    //
    // This is the amount to skew SpaceRequired, based on
    // SetupAdjustDiskSpaceList(). We track this separately
    // for flexibility.
    //
    LONGLONG Slop;

} XDRIVE, *PXDRIVE;

typedef struct _QUEUECONTEXT {
    HWND OwnerWindow;
    DWORD MainThreadId;
    HWND ProgressDialog;
    HWND ProgressBar;
    BOOL Cancelled;
    PTSTR CurrentSourceName;
    BOOL ScreenReader;
    BOOL MessageBoxUp;
    WPARAM  PendingUiType;
    PVOID   PendingUiParameters;
    UINT    CancelReturnCode;
    BOOL DialogKilled;
    //
    // If the SetupInitDefaultQueueCallbackEx is used, the caller can
    // specify an alternate handler for progress. This is useful to
    // get the default behavior for disk prompting, error handling, etc,
    // but to provide a gas gauge embedded, say, in a wizard page.
    //
    // The alternate window is sent ProgressMsg once when the copy queue
    // is started (wParam = 0. lParam = number of files to copy).
    // It is then also sent once per file copied (wParam = 1. lParam = 0).
    //
    // NOTE: a silent installation (i.e., no progress UI) can be accomplished
    // by specifying an AlternateProgressWindow handle of INVALID_HANDLE_VALUE.
    //
    HWND AlternateProgressWindow;
    UINT ProgressMsg;
    UINT NoToAllMask;

    HANDLE UiThreadHandle;

#ifdef NOCANCEL_SUPPORT
    BOOL AllowCancel;
#endif

} QUEUECONTEXT, *PQUEUECONTEXT;

//
// Make absolutely sure that these structures are DWORD aligned
// because we turn alignment off, to make sure sdtructures are
// packed as tightly as possible into memory blocks.
//

//
// Internal representation of a section in an inf file
//
typedef struct _INF_LINE {

    //
    // Number of values on the line
    // This includes the key if Flags has INF_LINE_HASKEY
    // (In that case the first two entries in the Values array
    // contain the key--the first one in case-insensitive form used
    // for lookup, and the second in case-sensitive form for display.
    // INF lines with a single value (no key) are treated the same way.)
    // Otherwise the first entry in the Values array is the first
    // value on the line
    //
    WORD ValueCount;
    WORD Flags;

    //
    // String IDs for the values on the line.
    // The values are stored in the value block,
    // one after another.
    //
    // The value is the offset within the value block as opposed to
    // an actual pointer. We do this because the value block gets
    // reallocated as the inf file is loaded.
    //
    UINT Values;

} INF_LINE, *PINF_LINE;

//
// INF_LINE.Flags
//
#define INF_LINE_HASKEY     0x0000001
#define INF_LINE_SEARCHABLE 0x0000002

#define HASKEY(Line)       ((Line)->Flags & INF_LINE_HASKEY)
#define ISSEARCHABLE(Line) ((Line)->Flags & INF_LINE_SEARCHABLE)

//
// INF section
// This guy is kept separate and has a pointer to the actual data
// to make sorting the sections a little easier
//
typedef struct _INF_SECTION {
    //
    // String Table ID of the name of the section
    //
    LONG  SectionName;

    //
    // Number of lines in this section
    //
    DWORD LineCount;

    //
    // The section's lines. The line structures are stored packed
    // in the line block, one after another.
    //
    // The value is the offset within the line block as opposed to
    // an actual pointer. We do it this way because the line block
    // gets reallocated as the inf file is loaded.
    //
    UINT Lines;

} INF_SECTION, *PINF_SECTION;

//
// Params for section enumeration
//

typedef struct {
    PTSTR       Buffer;
    UINT        Size;
    UINT        SizeNeeded;
    PTSTR       End;
} SECTION_ENUM_PARAMS, *PSECTION_ENUM_PARAMS;


//
// Define structures for user-defined DIRID storage.
//
typedef struct _USERDIRID {
    UINT Id;
    TCHAR Directory[MAX_PATH];
} USERDIRID, *PUSERDIRID;

typedef struct _USERDIRID_LIST {
    PUSERDIRID UserDirIds;  // may be NULL
    UINT UserDirIdCount;
} USERDIRID_LIST, *PUSERDIRID_LIST;

typedef struct _STRINGSUBST_NODE {
    UINT ValueOffset;
    LONG TemplateStringId;
    BOOL CaseSensitive;
} STRINGSUBST_NODE, *PSTRINGSUBST_NODE;


//
// Version block structure that is stored (packed) in the opaque
// VersionData buffer of a caller-supplied SP_INF_INFORMATION structure.
//
typedef struct _INF_VERSION_BLOCK {
    UINT NextOffset;
    FILETIME LastWriteTime;
    WORD DatumCount;
    WORD OffsetToData; // offset (in bytes) from beginning of Filename buffer.
    UINT DataSize;     // DataSize and TotalSize are both byte counts.
    UINT TotalSize;
    TCHAR Filename[ANYSIZE_ARRAY];
    //
    // Data follows Filename in the buffer
    //
} INF_VERSION_BLOCK, *PINF_VERSION_BLOCK;

//
// Internal version block node.
//
typedef struct _INF_VERSION_NODE {
    FILETIME LastWriteTime;
    UINT FilenameSize;
    CONST TCHAR *DataBlock;
    UINT DataSize;
    WORD DatumCount;
    TCHAR Filename[MAX_PATH];
} INF_VERSION_NODE, *PINF_VERSION_NODE;

//
// Internal representation of an inf file.
//
typedef struct _LOADED_INF {
    DWORD Signature;

    //
    // The following 3 fields are used for precompiled INFs (PNF).
    // If FileHandle is not INVALID_HANDLE_VALUE, then this is a PNF,
    // and the MappingHandle and ViewAddress fields are also valid.
    // Otherwise, this is a plain old in-memory INF.
    //
    HANDLE FileHandle;
    HANDLE MappingHandle;
    PVOID  ViewAddress;

    PVOID StringTable;
    DWORD SectionCount;
    PINF_SECTION SectionBlock;
    PINF_LINE LineBlock;
    PLONG ValueBlock;
    INF_VERSION_NODE VersionBlock;
    BOOL HasStrings;

    //
    // If this INF contains any DIRID references to the system partition, then
    // store the OsLoader path that was used when compiling this INF here.  (This
    // value will always be correct when the INF is loaded.  However, if drive letters
    // are subsequently reassigned, then it will be incorrect until the INF is unloaded
    // and re-loaded.)
    //
    PCTSTR OsLoaderPath;    // may be NULL

    //
    // Remember the location where this INF originally came from (may be a directory
    // path or a URL).
    //
    DWORD  InfSourceMediaType;  // SPOST_PATH or SPOST_URL
    PCTSTR InfSourcePath;       // may be NULL

    //
    // Remember the INF's original filename, before it was installed into
    // %windir%\Inf (i.e., automatically via device installation or explicitly
    // via SetupCopyOEMInf).
    //
    PCTSTR OriginalInfName;     // may be NULL

    //
    // Maintain a list of value offsets that require string substitution at
    // run-time.
    //
    PSTRINGSUBST_NODE SubstValueList;   // may be NULL
    WORD SubstValueCount;

    //
    // Place the style WORD here (immediately following another WORD field),
    // to fill a single DWORD.
    //
    WORD Style;                         // INF_STYLE_OLDNT, INF_STYLE_WIN4

    //
    // Sizes in bytes of various buffers
    //
    UINT SectionBlockSizeBytes;
    UINT LineBlockSizeBytes;
    UINT ValueBlockSizeBytes;

    //
    // Track what language was used when loading this INF.
    //
    DWORD LanguageId;

    //
    // Embedded structure containing information about the current user-defined
    // DIRID values.
    //
    USERDIRID_LIST UserDirIdList;

    //
    // Synchronization.
    //
    MYLOCK Lock;

    //
    // INFs are append-loaded via a doubly-linked list of LOADED_INFs.
    // (list is not circular--Prev of head is NULL, Next of tail is NULL)
    //
    struct _LOADED_INF *Prev;
    struct _LOADED_INF *Next;

} LOADED_INF, *PLOADED_INF;

#define LOADED_INF_SIG   0x24666e49      // Inf$


#define DRIVERSIGN_NONE             0x00000000
#define DRIVERSIGN_WARNING          0x00000001
#define DRIVERSIGN_BLOCKING         0x00000002



//
// debugee prototypes
//

BOOL CheckInterupted(
    VOID
    );


VOID
DumpStringTableHeader(
    PSTRING_TABLE pst
    ) ;

PVOID
GetStringTableData(
    PSTRING_TABLE st
    );

PVOID
GetStringNodeExtraData(
    PSTRING_NODEW node
    );

PSTRING_NODEW
GetNextNode(
    PVOID stdata,
    PSTRING_NODEW node,
    PULONG_PTR offset
    );

PSTRING_NODEW
GetFirstNode(
    PVOID stdata,
    ULONG_PTR offset,
    PULONG_PTR poffset
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setexts\ntsdexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"

WINDBG_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;

DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       ) {
        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
            szCurrentType[0] = '\0';
            }
        RegCloseKey(hkey);
        }
        

    if (VersionInformation.szCSDVersion[0]) {
        sprintf(szCSDString, ": %s", VersionInformation.szCSDVersion);
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );
    return;
}

DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("setupexts help:\n\n");
        dprintf("!version                     - Dump system version and build number\n");
        dprintf("!help                        - This message\n");
        dprintf("!ocm [address] [opt. flag]   - Dump the OC_MANAGER structure at address, flag increased verbosity\n");
        dprintf("!space [address] [opt. flag] - Dump the DISK_SPACE_LIST structure at specified address\n");
        dprintf("!st  [address]               - Dump the contents of a STRING_TABLE structure at specified address\n");
        dprintf("!stfind [address] [element]  - Dump the specified string table element\n");
        dprintf("!queue [address] [opt. flag] - Dump the specified file queue\n");
        dprintf("!qcontext [address]          - Dump the specified default queue context \n");
        dprintf("!infdump [addr] [opt. flag]  - Dump the specified hinf \n");
        dprintf("!winntflags                  - Dump some winnt32 global flags \n");
        dprintf("!winntstr                    - Dump some winnt32 global strings\n");

    }
}

BOOL
CheckInterupted(
    VOID
    )
{
    if ( CheckControlC() ) {
        dprintf( "\nInterrupted\n\n" );
        return TRUE;
    }
    return FALSE;
}


//
// Simple routine to convert from hex into a string of characters.
// Used by debugger extensions.
//
// by scottlu
//

char *
HexToString(
    ULONG dw,
    CHAR *pch
    )
{
    if (dw > 0xf) {
        pch = HexToString(dw >> 4, pch);
        dw &= 0xf;
    }

    *pch++ = ((dw >= 0xA) ? ('A' - 0xA) : '0') + (CHAR)dw;
    *pch = 0;

    return pch;
}

VOID
DumpStringTableHeader(
    PSTRING_TABLE st
    )
{
    //
    // dump the string table header
    //
    dprintf("\tBase Data ptr:\t0x%08x\n",  st->Data);
    dprintf("\tDataSize:\t0x%08x\n",       st->DataSize);
    dprintf("\tBufferSize:\t0x%08x\n",     st->BufferSize);
    dprintf("\tExtraDataSize:\t0x%08x\n",  st->ExtraDataSize);

}

VOID
DumpOcComponent(
    ULONG_PTR offset,
    PSTRING_NODEW node,
    deb_POPTIONAL_COMPONENTW pcomp
    )
{
    DWORD i;
    PLONG count;

    dprintf("OC_COMPONENT Data for node %ws : 0x%p\n", node->String, offset );
    dprintf( "\t InfStringId:\t\t0x%08x\n", pcomp->InfStringId );
    dprintf( "\t TopLevelStringId:\t0x%08x\n", pcomp->TopLevelStringId );
    dprintf( "\t ParentStringId:\t0x%08x\n", pcomp->ParentStringId );
    dprintf( "\t FirstChildStringId:\t0x%08x\n", pcomp->FirstChildStringId );
    dprintf( "\t ChildrenCount:\t\t0x%08x\n", pcomp->ChildrenCount );
    dprintf( "\t NextSiblingStringId:\t0x%08x\n", pcomp->NextSiblingStringId );

    dprintf( "\t NeedsCount:\t\t%d\n", pcomp->NeedsCount );
    count = malloc ( pcomp->NeedsCount * sizeof(LONG) );
    if (count) {
        // read and dump needs list
        ReadMemory((DWORD_PTR) pcomp->NeedsStringIds, count, pcomp->NeedsCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->NeedsCount; i++) {
            dprintf("\t NeedsStringIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }


    dprintf( "\t NeededByCount:\t\t%d\n", pcomp->NeededByCount );
    count = malloc ( pcomp->NeededByCount * sizeof(LONG) );
    if (count) {
        // read and dump needs list
        ReadMemory((DWORD_PTR) pcomp->NeededByStringIds, count, pcomp->NeededByCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->NeededByCount; i++) {
            dprintf("\t NeededByStringIds #%d: 0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf( "\t ExcludeCount:\t\t%d\n", pcomp->ExcludeCount );
    count = malloc ( pcomp->ExcludeCount * sizeof(LONG) );
    if (count) {
        // read and dump Excludes list
        ReadMemory((DWORD_PTR) pcomp->ExcludeStringIds, count, pcomp->ExcludeCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->ExcludeCount; i++) {
            dprintf("\t ExcludeStringIds #%d: 0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf( "\t ExcludedByCount:\t%d\n", pcomp->ExcludedByCount );
    count = malloc ( pcomp->ExcludedByCount * sizeof(LONG) );
    if (count) {
        // read and dump Excludes list
        ReadMemory((DWORD_PTR) pcomp->ExcludedByStringIds, count, pcomp->ExcludedByCount*sizeof(LONG), NULL);
        for (i = 0; i < pcomp->ExcludedByCount; i++) {
            dprintf("\t ExcludesStringIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf( "\t InternalFlags:\t\t0x%08x\n", pcomp->InternalFlags );

        
    dprintf( "\t SizeApproximation:\t0x%08x\n", pcomp->SizeApproximation );

    dprintf( "\t IconIndex:\t\t0x%08x\n", pcomp->IconIndex );
    dprintf( "\t IconDll:\t\t%ws\n", pcomp->IconDll);
    dprintf( "\t IconResource:\t\t%ws\n", pcomp->IconResource);
    dprintf( "\t SelectionState:\t0x%08x\n", pcomp->SelectionState );
    dprintf( "\t OriginalSelectionState:0x%08x\n", pcomp->OriginalSelectionState );
    dprintf( "\t InstalledState:\t0x%08x\n", pcomp->InstalledState );
    dprintf( "\t ModeBits:\t\t0x%08x\n", pcomp->ModeBits );
    dprintf( "\t Description:\t\t%ws\n", pcomp->Description );
    dprintf( "\t Tip:\t\t\t%ws\n", pcomp->Tip );

    dprintf( "\t InstallationDllName:\t%ws\n", pcomp->InstallationDllName );
    dprintf( "\t InterfaceFunctionName:\t%s\n", pcomp->InterfaceFunctionName );
    dprintf( "\t InstallationDll:\t0x%08x\n", pcomp->InstallationDll );
    //dprintf( "\t InstallationRoutine:\t%s\n", pcomp->InstallationRoutine );
    dprintf( "\t ExpectedVersion:\t0x%08x\n", pcomp->ExpectedVersion );
    dprintf( "\t Exists:\t\t0x%08x\n", pcomp->Exists );
    dprintf( "\t Flags:\t\t\t0x%08x\n\n\n", pcomp->Flags );

}

PVOID
GetStringTableData(
    PSTRING_TABLE st
    )
{
    LPVOID stdata;

    stdata = (PVOID) malloc( st->DataSize );
    if (!stdata) {
        dprintf("error allocation memory (size 0x%08x\n", (ULONG_PTR) st->DataSize);
        return NULL;
    }

    try {
        ReadMemory((DWORD_PTR) st->Data, stdata, st->DataSize, NULL);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        free( stdata );
        return NULL;
    }

    return stdata;
}

PVOID
GetStringNodeExtraData(
    PSTRING_NODEW node
    )
{
    PVOID extraData;
    extraData = node->String + wcslen(node->String) + 1;

    return extraData;

}

PSTRING_NODEW
GetNextNode(
    PVOID stdata,
    PSTRING_NODEW node,
    PULONG_PTR offset
    )
{
    PVOID next;

    if (node->NextOffset == -1) {
        *offset = 0;
        return NULL;
    }

    next = (PSTRING_NODEW)((LPBYTE)stdata + node->NextOffset);
    *offset = node->NextOffset;

    return next;

}

PSTRING_NODEW
GetFirstNode(
    PVOID stdata,
    ULONG_PTR offset,
    PULONG_PTR poffset
    )
{
    PSTRING_NODEW node;

    if (offset == -1) {
        return NULL;
    }

    node = (PSTRING_NODEW) ((LPBYTE)stdata + offset);
    *poffset = offset;

    return node;

}

LPCSTR
GetWizPage(
    DWORD i
    )
{
    LPCSTR  WizPage[] = {
        "WizPagesWelcome",        // welcome page
        "WizPagesMode",           // setup mode page
        "WizPagesEarly",          // pages that come after the mode page and before prenet pages
        "WizPagesPrenet",         // pages that come before network setup
        "WizPagesPostnet",        // pages that come after network setup
        "WizPagesLate",           // pages that come after postnet pages and before the final page
        "WizPagesFinal",          // final page
        "WizPagesTypeMax"
    };

    return WizPage[i];

}


DECLARE_API( st )
/*++

Routine Description:

    This debugger extension dumps a string table at the address specified.

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    STRING_TABLE st;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    PSTRING_NODEW node;//, prev;


    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pst = (PVOID)GetExpression( lpArgumentString );

    move( st, pst );

    dprintf("Base String Table Address:\t0x%p\n", pst);

    DumpStringTableHeader( &st );

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("Data at hash bucket %d\n", i);
            while (node) {
                dprintf("\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);
                pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%08x\n", pextradata );
                        //((LPBYTE)node->String + wcslen(node->String) + 1));
                node = GetNextNode( stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    free( stdata );

}

DECLARE_API( stfind )
/*++

Routine Description:

    This debugger extension dumps the data for a given string table number

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    STRING_TABLE st;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    PSTRING_NODEW node;//, prev;
    DWORD_PTR element;


    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pst = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        element = GetExpression( lpArgumentString );
    } else {
        dprintf("bogus usage\n");
    }


    move( st, pst );

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }
    //
    // search each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {

        } else {

            while (node) {
                if (element == offset) {
                    dprintf("\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);
                    pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                    dprintf("\tExtra Data:\t0x%08x\n", pextradata );
                    free( stdata );
                    return;
                }

                node = GetNextNode( stdata, node, &offset );

                if (CheckInterupted()) {
                    return;
                }

            }
        }
    }
    free( stdata );

    dprintf("Couldn't find element\n");

}


DECLARE_API( ocm )
/*++

Routine Description:

    This debugger extension dumps an OC_MANAGER (UNICODE!) structure at the specified address

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    deb_OC_MANAGERW ocm;
    PVOID pocm;
    DWORD i;
    DWORD_PTR offset;
    STRING_TABLE inftable,comptable;
    PVOID infdata,compdata;
    PSTRING_NODEW node;
    POC_INF pocinf;
    deb_POPTIONAL_COMPONENTW pcomp;
    DWORD Mask = 0;
    PLONG count;

    INIT_API();


    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pocm = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    move( ocm,(LPVOID)pocm);

    //
    // dump the OCM structure
    //
    dprintf("OC_MANAGER structure at Address:\t0x%08x\n", (ULONG_PTR) pocm);
    dprintf("\tCallbacks :\n");
    dprintf("\t\tFillInSetupDataA:\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.FillInSetupDataA);
    dprintf("\t\tLogError:\t\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.LogError);
    dprintf("\t\tSetReboot:\t\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.SetReboot);
    dprintf("\t\tFillInSetupDataW:\t0x%08x\n", (ULONG_PTR) ocm.Callbacks.FillInSetupDataW);

    dprintf("\tMasterOcInf:\t\t0x%08x\n",    ocm.MasterOcInf);
    dprintf("\tUnattendedInf:\t\t0x%08x\n",  ocm.UnattendedInf);
    dprintf("\tMasterOcInfPath:\t%ws\n",  ocm.MasterOcInfPath);
    dprintf("\tUnattendInfPath:\t%ws\n",  ocm.UnattendedInfPath);
    dprintf("\tSourceDir:\t\t%ws\n",        ocm.SourceDir);
    dprintf("\tSuiteName:\t\t%ws\n",        ocm.SuiteName);
    dprintf("\tSetupPageTitle:\t\t%ws\n",   ocm.SetupPageTitle);
    dprintf("\tWindowTitle:\t%ws\n",      ocm.WindowTitle);
    dprintf("\tInfListStringTable:\t0x%08x\n",      (ULONG_PTR)ocm.InfListStringTable);
    dprintf("\tComponentStringTable:\t0x%08x\n",    (ULONG_PTR)ocm.ComponentStringTable);
    dprintf("\tComponentStringTable:\t0x%08x\n",    (ULONG_PTR)ocm.OcSetupPage);
    dprintf("\tSetupMode:\t\t%d\n",        ocm.SetupMode);
    dprintf("\tTopLevelOcCount:\t%d\n",        ocm.TopLevelOcCount);
    // Issue-vijeshs-09/18/2000: from 1 to count
    count = malloc ( ocm.TopLevelOcCount * sizeof(LONG) );

    if (count) {
        // read and dump needs list
        ReadMemory((LPVOID) ocm.TopLevelOcStringIds, count, ocm.TopLevelOcCount *sizeof(LONG), NULL);
        for (i = 0; i < ocm.TopLevelOcCount; i++) {
            dprintf("\t TopLevelOcStringIds #%d:\t0x%08x\n", i, count[i]);

            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf("\tTopLevelParenOcCount:\t%d\n",        ocm.TopLevelParentOcCount);

    count = malloc ( ocm.TopLevelParentOcCount * sizeof(LONG) );

    if (count) {
        // read and dump needs list
        ReadMemory((LPVOID) ocm.TopLevelParentOcStringIds, count, ocm.TopLevelParentOcCount *sizeof(LONG), NULL);
        for (i = 0; i < ocm.TopLevelParentOcCount; i++) {
            dprintf("\t TopLevelParentOcStringIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf("\tSubComponentsPresent:\t%d\n",        ocm.SubComponentsPresent);

    //
    // Issue-vijeshs-09/18/2000:WizardPagesOrder there's not really any way to tell the exact upper bound of
    // each array, though we know that it's <= TopLevelParentOcCount...since this is the case
    // we just dump the point to each array of pages...
    //
    for (i = 0; i < WizPagesTypeMax; i++) {
        dprintf("\tWizardPagesOrder[%i] (%s)\t: 0x%08x\n",
                i,
                GetWizPage(i),
                ocm.WizardPagesOrder[i] );
        if (CheckInterupted()) {
                return;
            }
    }

    dprintf("\tPrivateDataSubkey:\t%ws\n", ocm.PrivateDataSubkey);
    dprintf("\thKeyPrivateData:\t0x%08x\n", ocm.hKeyPrivateData);
    dprintf("\thKeyPrivateDataRoot:\t0x%08x\n", ocm.hKeyPrivateDataRoot);
    dprintf("\tProgressTextWindow:\t0x%08x\n", ocm.ProgressTextWindow);

    dprintf("\tCurrentComponentStringId:\t0x%08x\n", ocm.CurrentComponentStringId);
    dprintf("\tAbortedCount:\t\t%d\n",        ocm.AbortedCount);

    count = malloc ( ocm.AbortedCount * sizeof(LONG) );

    if (count) {
        // read and dump needs list
        ReadMemory((LPVOID) ocm.AbortedComponentIds, count, ocm.AbortedCount *sizeof(LONG), NULL);
        for (i = 0; i < (DWORD)ocm.AbortedCount; i++) {
            dprintf("\t AbortedComponentIds #%d:\t0x%08x\n", i, count[i]);
            if (CheckInterupted()) {
                return;
            }
        }

        free(count);
    }

    dprintf("\tInternalFlags:\t\t0x%08x\n\n\n",        ocm.InternalFlags);

    dprintf("\tSetupData.SetupMode :\t0x%08x\n", ocm.SetupData.SetupMode );
    dprintf("\tSetupData.ProductType :\t0x%08x\n", ocm.SetupData.ProductType );
    dprintf("\tSetupData.OperationFlags :\t0x%08x\n", ocm.SetupData.OperationFlags );
    dprintf("\tSetupData.SourcePath :\t%ws\n", ocm.SetupData.SourcePath );
    dprintf("\tSetupData.UnattendFile :\t%ws\n", ocm.SetupData.UnattendFile );

    if ((Mask&1) && ocm.InfListStringTable) {
        dprintf("\t\t***InfListStringTable***\n");
        move (inftable, ocm.InfListStringTable);
        infdata = GetStringTableData( &inftable );
        if (!infdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        // now, dump each node with data in the string table
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(infdata, ((PULONG_PTR)infdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    //dprintf("\tNode Name:%ws\n", node->String);
                    pocinf = (POC_INF) GetStringNodeExtraData( node );
                    if (pocinf) {
                        dprintf("\tNode Data for %ws (0x%08x): 0x%08x\n",
                                node->String,
                                offset,
                                pocinf->Handle
                                );
                    } else {
                        dprintf("\tNo Node Data for %ws\n",
                                node->String
                                );
                    }
                    node = GetNextNode( infdata, node, &offset );
                    if (CheckInterupted()) {
                        return;
                    }
                }
            }
        }
        free( infdata );
        dprintf("\n\n");
    }

    if ((Mask&1) && ocm.ComponentStringTable) {
        dprintf("\t\t***ComponentStringTable***\n");
        move (comptable, ocm.ComponentStringTable);
        compdata = GetStringTableData( &comptable );
        if (!compdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // dump each node with data in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(infdata, ((PULONG_PTR)infdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                //dprintf("Data at hash bucket %d\n", i);
                while (node) {
                    //dprintf("\tNode Name:%ws\n", node->String);
                    pcomp = (deb_POPTIONAL_COMPONENTW) GetStringNodeExtraData( node );
                    if (pcomp) {
                        DumpOcComponent( offset , node, pcomp );
                    } else {
                        dprintf("\tNo Node Data for %ws\n",
                                node->String
                                );
                    }

                    if (CheckInterupted()) {
                       return;
                    }

                    node = GetNextNode( infdata, node, &offset );
                }
            }
        }

        free( compdata );
    }



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\pnpsif\util.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    util.c

Abstract:

    This module contains the following private utility routines for the Plug and
    Play registry merge-restore routines:

        FileExists

Author:

    Jim Cavalaris (jamesca) 2-10-2000

Environment:

    User-mode only.

Revision History:

    10-February-2000     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"


//
// definitions
//
#define MAX_GUID_STRING_LEN   39          // 38 chars + terminating NULL

//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//

static const BYTE  GuidMap[]  = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                  8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");


//
// routines
//


BOOL
pSifUtilFileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )
/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL
pSifUtilStringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to avoid linking
    to ole32.dll.  (The RPC version allocates memory, so it was avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (MAX_GUID_STRING_LEN) characters
        long.

Return Value:

    Returns TRUE if successful, FALSE if not.
    GetLastError() returns extended error info.

--*/
{
    CONST BYTE *GuidBytes;
    INT i;

    if(GuidStringSize < MAX_GUID_STRING_LEN) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    GuidBytes = (CONST BYTE *)Guid;

    *GuidString++ = TEXT('{');

    for(i = 0; i < sizeof(GuidMap); i++) {

        if(GuidMap[i] == '-') {
            *GuidString++ = TEXT('-');
        } else {
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *GuidString++ = TEXT('}');
    *GuidString   = TEXT('\0');

    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setexts\ocmdeb.h ===
// This header can go away once the types in oc.h are fixed to support
// ansi and unicode at the same time.



#ifndef UNICODE
    #define POC_FILL_IN_SETUP_DATA_PROC_W ULONG_PTR
#endif    

typedef struct _deb_OCM_CLIENT_CALLBACKSW {
    //
    // Routine to fill in the setup data structure that provides info
    // about the environment in which the OC Manager is running.
    //
    POC_FILL_IN_SETUP_DATA_PROC_A FillInSetupDataA;

    //
    // Routine to log an error.
    //
    POC_LOG_ERROR LogError;

    //
    // Routine to indicate need to reboot
    //
    POC_SET_REBOOT_PROC SetReboot;
    
    POC_FILL_IN_SETUP_DATA_PROC_W FillInSetupDataW;

} deb_OCM_CLIENT_CALLBACKSW, *deb_POCM_CLIENT_CALLBACKSW;


typedef struct _deb_OCM_CLIENT_CALLBACKSA {
    //
    // Routine to fill in the setup data structure that provides info
    // about the environment in which the OC Manager is running.
    //
    POC_FILL_IN_SETUP_DATA_PROC_A FillInSetupDataA;

    //
    // Routine to log an error.
    //
    POC_LOG_ERROR LogError;

    //
    // Routine to indicate need to reboot
    //
    POC_SET_REBOOT_PROC SetReboot;

} deb_OCM_CLIENT_CALLBACKSA, *deb_POCM_CLIENT_CALLBACKSA;

typedef struct _deb_OPTIONAL_COMPONENTA {
    //
    // String id of name of inf file in the OC Manager's
    // InfListStringTable string table. If -1, then
    // the subcomponent does not appear on the OC page.
    //
    LONG InfStringId;

    //
    // Backpointer to top level component
    //
    LONG TopLevelStringId;

    //
    // String id of parent component, -1 if none.
    //
    LONG ParentStringId;

    //
    // String id of first child, -1 if none.
    //
    LONG FirstChildStringId;

    //
    // Count of children.
    //
    UINT ChildrenCount;

    //
    // String id of next sibling, -1 if none.
    //
    LONG NextSiblingStringId;

    //
    // String ids of needs and needed by.
    //
    PLONG NeedsStringIds;
    UINT NeedsCount;
    PLONG NeededByStringIds;
    UINT NeededByCount;

    // String ids of exclude and excluded by

    PLONG ExcludeStringIds;
    UINT ExcludeCount;
    PLONG ExcludedByStringIds;
    UINT ExcludedByCount;

    //
    // Misc flags.
    //
    UINT InternalFlags;

    //
    // Approximation of required disk space.
    //
    LONGLONG SizeApproximation;

    //
    // Icon index of the component.
    // -1 means we're supposed to get it from the component itself.
    // -2 means we're supposed to use IconDll and IconResource
    //
    UINT IconIndex;
    CHAR IconDll[MAX_PATH];
    CHAR IconResource[50];

    //
    // Selection state (SELSTATE_xxx constants).
    //
    UINT SelectionState;
    UINT OriginalSelectionState;

    // Installation Flag as obtained from the inf

    UINT InstalledState;

    //
    // Mode bits.
    //
    UINT ModeBits;

    //
    // Human-readable stuff describing the component.
    //
    CHAR Description[MAXOCDESC];
    CHAR Tip[MAXOCTIP];

    //
    // From here down, stuff is meaningful only for top-level components.
    //

    //
    // Stuff describing the OC's installation DLL and how to call it.
    //
    CHAR InstallationDllName[MAX_PATH];
    CHAR InterfaceFunctionName[MAX_PATH];

    HMODULE InstallationDll;
    POCSETUPPROC InstallationRoutine;

    //
    // Version of the OC Manager to which this component was written.
    //
    UINT ExpectedVersion;

    // this flag indicates whether the subcomponent was intialialized

    BOOL Exists;

    //
    // Flags: ANSI/Unicode, etc.
    //
    UINT Flags;

} deb_OPTIONAL_COMPONENTA, *deb_POPTIONAL_COMPONENTA;

//
// locale info
//
typedef struct _deb_LOCALEA {
    LCID    lcid;
    CHAR   DecimalSeparator[4];
} deb_LOCALEA, *deb_PLOCALEA;
    
//
// Define structure corresponding to an instance of the OC Manager.
// This is actually somewhat broken, in that this actually closely corresponds
// to a master OC INF, and we might want to consider breaking out the string
// tables into another structure, so we can more easily achieve a unified
// namespace if we have multiple master OC INFs at play simultaneously.
//
typedef struct _deb_OC_MANAGERA {
	//
    // Callbacks into OC Manaer client.
    //
    deb_OCM_CLIENT_CALLBACKSA Callbacks;

    //
    // Handle of Master OC INF.
    //
    HINF MasterOcInf;

    //
    // unattended inf handle
    //
    HINF UnattendedInf;

    //
    // Master OC Inf file, and unattended file
    //
    CHAR MasterOcInfPath[MAX_PATH];
    CHAR UnattendedInfPath[MAX_PATH];

    // we run from whatever directory the master inf is in

    CHAR SourceDir[MAX_PATH];

    //
    // Name of "suite" -- in other words, a shortname that
    // is unique to the master OC inf that this structure represents.
    // We base it on the name of the master OC inf itself.
    //
    CHAR SuiteName[MAX_PATH];

    //
    // page titles
    //
    CHAR SetupPageTitle[MAX_PATH];

    // window title

    CHAR WindowTitle[MAX_PATH];
    
    //
    // List of per-component OC INFs currently loaded.
    // Each inf's name is in the string table and the extra data
    // for each is an OC_INF structure.
    //
    PVOID InfListStringTable;

    //
    // String table for names of all components and subcomponents.
    // Extra data for each is an OPTIONAL_COMPONENT structure.
    //
    PVOID ComponentStringTable;

    //
    // pointer to OcSetupPage structure so we can free this data
    // if the user cancels before we get to the wizard page.
    //
    PVOID OcSetupPage;


    //
    // Setup mode (custom, typical, etc)
    //
    UINT SetupMode;

    //
    // List of top-level optional component string IDs.
    // This is necessary because we need to preserve ordering
    // from the master OC Inf.
    //
    UINT TopLevelOcCount;
    PLONG TopLevelOcStringIds;
    UINT TopLevelParentOcCount;
    PLONG TopLevelParentOcStringIds;


    //
    // Are there subcomponents on the details page?
    //
    BOOL SubComponentsPresent;

    //
    // Each element in this array points to an array that
    // gives ordering for querying wizard pages from the optional components.
    //
    PLONG WizardPagesOrder[WizPagesTypeMax];

    //
    // Subkey relative to szPrivateDataRoot where private
    // data for components plugged into the OC will live.
    // 2 8-char DWORD representations plus a separator and nul.
    //
    CHAR PrivateDataSubkey[18];
    HKEY hKeyPrivateData;
    HKEY hKeyPrivateDataRoot;

    //
    // If we are completing installation, this item is the window handle
    // of the progress text control.
    //
    HWND ProgressTextWindow;

    //
    // String id of component currently processing an interface routine.
    // -1 means the OC manager is not currently processing one.
    //
    LONG CurrentComponentStringId;

    // Component Ids of aborted components

    LONG *AbortedComponentIds;
    UINT   AbortedCount;

    //
    // Various flags
    //
    UINT InternalFlags;

    //
    // setup data
    //

    SETUP_DATA SetupData;

} deb_OC_MANAGERA, *deb_POC_MANAGERA;



typedef struct _deb_OPTIONAL_COMPONENTW {
    //
    // String id of name of inf file in the OC Manager's
    // InfListStringTable string table. If -1, then
    // the subcomponent does not appear on the OC page.
    //
    LONG InfStringId;

    //
    // Backpointer to top level component
    //
    LONG TopLevelStringId;

    //
    // String id of parent component, -1 if none.
    //
    LONG ParentStringId;

    //
    // String id of first child, -1 if none.
    //
    LONG FirstChildStringId;

    //
    // Count of children.
    //
    UINT ChildrenCount;

    //
    // String id of next sibling, -1 if none.
    //
    LONG NextSiblingStringId;

    //
    // String ids of needs and needed by.
    //
    PLONG NeedsStringIds;
    UINT NeedsCount;
    PLONG NeededByStringIds;
    UINT NeededByCount;

    // String ids of exclude and excluded by

    PLONG ExcludeStringIds;
    UINT ExcludeCount;
    PLONG ExcludedByStringIds;
    UINT ExcludedByCount;

    //
    // Misc flags.
    //
    UINT InternalFlags;

    //
    // Approximation of required disk space.
    //
    LONGLONG SizeApproximation;

    //
    // Icon index of the component.
    // -1 means we're supposed to get it from the component itself.
    // -2 means we're supposed to use IconDll and IconResource
    //
    UINT IconIndex;
    WCHAR IconDll[MAX_PATH];
    WCHAR IconResource[50];

    //
    // Selection state (SELSTATE_xxx constants).
    //
    UINT SelectionState;
    UINT OriginalSelectionState;

    // Installation Flag as obtained from the inf

    UINT InstalledState;

    //
    // Mode bits.
    //
    UINT ModeBits;

    //
    // Human-readable stuff describing the component.
    //
    WCHAR Description[MAXOCDESC];
    WCHAR Tip[MAXOCTIP];

    //
    // From here down, stuff is meaningful only for top-level components.
    //

    //
    // Stuff describing the OC's installation DLL and how to call it.
    //
    WCHAR InstallationDllName[MAX_PATH];
    CHAR InterfaceFunctionName[MAX_PATH];

    HMODULE InstallationDll;
    POCSETUPPROC InstallationRoutine;

    //
    // Version of the OC Manager to which this component was written.
    //
    UINT ExpectedVersion;

    // this flag indicates whether the subcomponent was intialialized

    BOOL Exists;

    //
    // Flags: ANSI/Unicode, etc.
    //
    UINT Flags;

} deb_OPTIONAL_COMPONENTW, *deb_POPTIONAL_COMPONENTW;

//
// locale info
//
typedef struct _deb_LOCALEW {
    LCID    lcid;
    WCHAR   DecimalSeparator[4];
} deb_LOCALEW, *deb_PLOCALEW;
    
//
// Define structure corresponding to an instance of the OC Manager.
// This is actually somewhat broken, in that this actually closely corresponds
// to a master OC INF, and we might want to consider breaking out the string
// tables into another structure, so we can more easily achieve a unified
// namespace if we have multiple master OC INFs at play simultaneously.
//
typedef struct _deb_OC_MANAGERW {
	//
    // Callbacks into OC Manaer client.
    //
    deb_OCM_CLIENT_CALLBACKSW Callbacks;

    //
    // Handle of Master OC INF.
    //
    HINF MasterOcInf;

    //
    // unattended inf handle
    //
    HINF UnattendedInf;

    //
    // Master OC Inf file, and unattended file
    //
    WCHAR MasterOcInfPath[MAX_PATH];
    WCHAR UnattendedInfPath[MAX_PATH];

    // we run from whatever directory the master inf is in

    WCHAR SourceDir[MAX_PATH];

    //
    // Name of "suite" -- in other words, a shortname that
    // is unique to the master OC inf that this structure represents.
    // We base it on the name of the master OC inf itself.
    //
    WCHAR SuiteName[MAX_PATH];

    //
    // page titles
    //
    WCHAR SetupPageTitle[MAX_PATH];

    // window title

    WCHAR WindowTitle[MAX_PATH];
    
    //
    // List of per-component OC INFs currently loaded.
    // Each inf's name is in the string table and the extra data
    // for each is an OC_INF structure.
    //
    PVOID InfListStringTable;

    //
    // String table for names of all components and subcomponents.
    // Extra data for each is an OPTIONAL_COMPONENT structure.
    //
    PVOID ComponentStringTable;

    //
    // pointer to OcSetupPage structure so we can free this data
    // if the user cancels before we get to the wizard page.
    //
    PVOID OcSetupPage;

    //
    // Setup mode (custom, typical, etc)
    //
    UINT SetupMode;

    //
    // List of top-level optional component string IDs.
    // This is necessary because we need to preserve ordering
    // from the master OC Inf.
    //
    UINT TopLevelOcCount;
    PLONG TopLevelOcStringIds;
    UINT TopLevelParentOcCount;
    PLONG TopLevelParentOcStringIds;


    //
    // Are there subcomponents on the details page?
    //
    BOOL SubComponentsPresent;

    //
    // Each element in this array points to an array that
    // gives ordering for querying wizard pages from the optional components.
    //
    PLONG WizardPagesOrder[WizPagesTypeMax];

    //
    // Subkey relative to szPrivateDataRoot where private
    // data for components plugged into the OC will live.
    // 2 8-char DWORD representations plus a separator and nul.
    //
    WCHAR PrivateDataSubkey[18];
    HKEY hKeyPrivateData;
    HKEY hKeyPrivateDataRoot;

    //
    // If we are completing installation, this item is the window handle
    // of the progress text control.
    //
    HWND ProgressTextWindow;

    //
    // String id of component currently processing an interface routine.
    // -1 means the OC manager is not currently processing one.
    //
    LONG CurrentComponentStringId;

    // Component Ids of aborted components

    LONG *AbortedComponentIds;
    int   AbortedCount;

    //
    // Various flags
    //
    UINT InternalFlags;

    //
    // setup data
    //

    SETUP_DATAW SetupData;

} deb_OC_MANAGERW, *deb_POC_MANAGERW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setexts\winnt32.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ntsdexts.c

Abstract:

    This function contains the default ntsd debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;


VOID
PrintFlagValue(
    LPCTSTR lpString
    )
{

    BOOL retval= FALSE;
    PVOID p;
    TCHAR Argument[100];

    sprintf( Argument, "winnt32u!%s", lpString );

    p = (PVOID) GetExpression( Argument );
    if (!p) {
        sprintf( Argument, "winnt32a!%s", lpString );
        p = (PVOID) GetExpression( Argument );
    }

    if (p) {
        move( retval, p );
        dprintf( "%s : %s (at address 0x%08x)\n", lpString, retval ? "TRUE" : "FALSE", p );
    } else {
        dprintf( "Couldn't find global flag %s\n" , lpString );
    }


}

#define ANSIFORMAT          "%s : %s (at address 0x%08x)\n"
#define UNICODEFORMAT       "%s : %ws (at address 0x%08x)\n"
#define ANSIARRAYFORMAT     "%s[%i] : %s (at address 0x%08x)\n"
#define UNICODEARRAYFORMAT  "%s[%i] : %ws (at address 0x%08x)\n"
#define MAX_OPTIONALDIRS    20
#define MAX_SOURCE_COUNT    8

VOID
PrintStringBufferValue(
    LPCTSTR lpString
    )
{

    WCHAR Data[MAX_PATH];
    PVOID p;
    TCHAR Argument[100];
    BOOL fUnicode = TRUE;

    sprintf( Argument, "winnt32u!%s", lpString );

    p = (PVOID) GetExpression( Argument );
    if (!p) {
        sprintf( Argument, "winnt32a!%s", lpString );
        p = (PVOID) GetExpression( Argument );
        fUnicode = FALSE;
    }

    if (p) {
        move( Data, p );
        dprintf( fUnicode ? UNICODEFORMAT : ANSIFORMAT, lpString, Data, p );
    } else {
        dprintf( "Couldn't find global string buffer %s\n" , lpString );
    }

}

VOID
PrintStringBufferArrayValue(
    LPCTSTR lpString,
    DWORD ElementSize,
    DWORD ArraySize
    )
{

    WCHAR Data[MAX_PATH];
    PVOID p;
    TCHAR Argument[100];
    TCHAR Format[100];
    BOOL fUnicode = TRUE;
    DWORD i;

    sprintf( Argument, "winnt32u!%s", lpString );

    p = (PVOID) GetExpression( Argument );
    if (!p) {
        sprintf( Argument, "winnt32a!%s", lpString );
        p = (PVOID) GetExpression( Argument );
        fUnicode = FALSE;
    }

    if (p) {
        for (i = 0; i< ArraySize; i++) {
            move( Data, ((LPBYTE)p+(i*ElementSize* (fUnicode) ? sizeof(WCHAR) : sizeof(CHAR))) );
            dprintf( fUnicode ? UNICODEARRAYFORMAT : ANSIARRAYFORMAT ,
                     lpString, i, Data, p );
        }
        
    } else {
        dprintf( "Couldn't find global string buffer %s\n" , lpString );
    }

}






DECLARE_API( winntflags )
/*++

Routine Description:

    This debugger extension dumps winnt32 flags

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    
    DWORD i, offset;
    PVOID stdata,pextradata;
    
    //BOOL val;

    INIT_API();

    dprintf("\t\t****winnt32 global flags****\n");
    PrintFlagValue( "Server" );
    PrintFlagValue( "Upgrade" );
    PrintFlagValue( "UnattendedOperation" );
    dprintf("\n");
    
    PrintFlagValue( "CheckUpgradeOnly" );           
    PrintFlagValue( "Aborted" );           
    PrintFlagValue( "Cancelled" );
    PrintFlagValue( "CancelPending" );           
    dprintf("\n");

    PrintFlagValue( "ChoosePartition" );           
    PrintFlagValue( "Floppyless" );           
    PrintFlagValue( "ForceNTFSConversion" );           
    PrintFlagValue( "NTFSConversionChanged" );           
    PrintFlagValue( "HideWinDir" );           
    PrintFlagValue( "MakeBootMedia" );           
    PrintFlagValue( "MakeLocalSource" );           
    PrintFlagValue( "OemPreinstall" );           
    PrintFlagValue( "RunFromCD" );           
    dprintf("\n");

    PrintFlagValue( "BlockOnNotEnoughSpace" );           
    PrintFlagValue( "SkipLocaleCheck" );           
    PrintFlagValue( "AccessibleKeyboard" );           
    PrintFlagValue( "AccessibleMagnifier" );           
    PrintFlagValue( "AccessibleReader" );           
    PrintFlagValue( "AccessibleSetup" );           
    PrintFlagValue( "AccessibleVoice" );           
    PrintFlagValue( "AutomaticallyShutDown" );           
    PrintFlagValue( "AutoSkipMissingFiles" );           
    dprintf("\n");
            
    PrintFlagValue( "GlobalResult" );                              
    dprintf("\n");

}

DECLARE_API( winntstr )
/*++

Routine Description:

    This debugger extension dumps winnt32 string global info

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pst;
    
    DWORD i, offset;
    PVOID stdata,pextradata;
    
    //BOOL val;

    INIT_API();

    dprintf("\t\t****winnt32 global strings****\n");
    PrintStringBufferValue( "AccessibleScriptFile" );
    PrintStringBufferValue( "AlternateSourcePath" );
    PrintStringBufferValue( "FirstFloppyDriveLetter" );
    PrintStringBufferValue( "ForcedSystemPartition" );
    PrintStringBufferValue( "InfName" );
    PrintStringBufferValue( "InstallDir" );
    PrintStringBufferValue( "LocalBackupDirectory" );
    PrintStringBufferValue( "LocalBootDirectory" );
    PrintStringBufferValue( "LocalSourceDirectory" );
    PrintStringBufferValue( "LocalSourceDrive" );
    PrintStringBufferValue( "LocalSourceWithPlatform" );
    PrintStringBufferValue( "ProductId" );
    PrintStringBufferValue( "SystemPartitionDriveLetter" );
    PrintStringBufferValue( "SystemPartitionDriveLetters" );
    PrintStringBufferValue( "UserSpecifiedLocalSourceDrive" );
    PrintStringBufferArrayValue( "OptionalDirectories", MAX_PATH, MAX_OPTIONALDIRS );
    PrintStringBufferArrayValue( "SourcePaths", MAX_PATH, MAX_SOURCE_COUNT );
    
    dprintf("\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setexts\setupapi.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    setupapi.c

Abstract:

    This function contains the setupapi debugger extensions

Author:

    Mark Lucovsky (markl) 09-Apr-1991

Revision History:

--*/

#include "ntsdextp.h"
#include <setupapi.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;


VOID
DumpXFile(
    PXFILE pxf,
    DWORD mask
    )
{
    PVOID pst;
    DWORD i, offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;

    if ((mask & 4) == 0 ) {
        return;
    }

    dprintf( "\t\t     ***XFILE structure***\n" );
    dprintf( "\t\t      CurrentSize : 0x%x", pxf->CurrentSize );
    if (pxf->CurrentSize == -1) {
        dprintf( " (doesn't currently exist)" );
    }
    dprintf( "\n\t\t      NewSize : 0x%x", pxf->NewSize );
    if (pxf->NewSize == -1) {
        dprintf( " (will be deleted)" );
    }
    dprintf("\n");

}


VOID
DumpXDirectory(
    PXDIRECTORY pxd,
    DWORD mask
    )
{
    PVOID pst;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    PXFILE pxf;

    if ((mask & 2) == 0 ) {
        return;
    }

    dprintf( "\t\t   ***XDIRECTORY structure***\n", pxd );
    dprintf( "\t\t    SpaceRequired : 0x%x\n", pxd->SpaceRequired );
    dprintf( "\t\t    FilesTable : 08%08x\n", pxd->FilesTable );

    move ( st, pxd->FilesTable ) ;

    dprintf("\t\t    ***FilesTable***\n");

    dprintf("\t\t    Base Data ptr:\t0x%08x\n",  st.Data);
    dprintf("\t\t    DataSize:\t0x%08x\n",       st.DataSize);
    dprintf("\t\t    BufferSize:\t0x%08x\n",     st.BufferSize);
    dprintf("\t\t    ExtraDataSize:\t0x%08x\n",  st.ExtraDataSize);

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\t    Data at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\t     Entry Name:\t%ws (0x%08x)\n", node->String, offset);

                pxf = (PXFILE) GetStringNodeExtraData( node );
                DumpXFile( pxf, mask );
                free(pxf);

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
            return;
        }

    }

    free( stdata );

}


VOID
DumpXDrive(
    PXDRIVE pxd,
    DWORD mask
    )
{
    PVOID pst;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    PXDIRECTORY pxdir;

    if ((mask & 1) == 0) {
        return;
    }

    dprintf( "\t\t***XDRIVE structure***\n", pxd );
    dprintf( "\t\t SpaceRequired : 0x%x\n", pxd->SpaceRequired );
    dprintf( "\t\t BytesPerCluster : 08%08x\n", pxd->BytesPerCluster );
    dprintf( "\t\t Slop : 08%x\n", pxd->Slop );
    dprintf( "\t\t DirsTable : 08%08x\n", pxd->DirsTable );

    move ( st, pxd->DirsTable ) ;

    dprintf("\t\t ***DirsTable***\n");

    dprintf("\t\t  Base Data ptr:\t0x%08x\n",  st.Data);
    dprintf("\t\t  DataSize:\t0x%08x\n",       st.DataSize);
    dprintf("\t\t  BufferSize:\t0x%08x\n",     st.BufferSize);
    dprintf("\t\t  ExtraDataSize:\t0x%08x\n",  st.ExtraDataSize);

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\t  Data at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\t   Entry Name:\t%ws (0x%08x)\n", node->String, offset);

                pxdir = (PXDIRECTORY) GetStringNodeExtraData( node );
                DumpXDirectory( pxdir, mask );
                free(pxdir);

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }
        if (CheckInterupted()) {
            return;
        }
    }

    free( stdata );

}


DECLARE_API( space )
/*++

Routine Description:

    This debugger extension dumps the data related to a HDSKSPC structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pds,pst;
    DISK_SPACE_LIST dsl;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    PXDRIVE pxd;
    DWORD Mask = 0;


    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pds = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    move( dsl , pds );

    dprintf("DISK_SPACE_LIST at :\t0x%08x\n", (ULONG_PTR) pds);
    dprintf("\tLock[0] : 0x%08x\n", dsl.Lock.handles[0]);
    dprintf("\tLock[1] : 0x%08x\n", dsl.Lock.handles[1]);
    dprintf("\tDrivesTable : 0x%08x\n", dsl.DrivesTable );
    dprintf("\tFlags : 0x%08x\n", dsl.Flags);

    move ( st, dsl.DrivesTable ) ;

    dprintf("\t ***DrivesTable***\n");
    DumpStringTableHeader( &st );

    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\tData at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                pxd = (PXDRIVE) GetStringNodeExtraData( node );
                DumpXDrive( pxd, Mask );
                free(pxd);

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }
    free( stdata );



}

#define TRACK_ARG_DECLARE
#define TRACK_ARG_COMMA

#include "cntxtlog.h"
#include "backup.h"
#include "fileq.h"

VOID DumpAltPlatformInfo( PSP_ALTPLATFORM_INFO api, DWORD mask );
VOID DumpFileQueueNodeList( PSP_FILE_QUEUE_NODE pfqn, DWORD mask, BOOL recursive ) ;
VOID DumpSourceMediaInfoList( PSOURCE_MEDIA_INFO smi, DWORD mask, BOOL recursive );
VOID DumpCatalogInfoList( PSPQ_CATALOG_INFO ci, DWORD mask, BOOL recursive );
VOID DumpUnwindList( PSP_UNWIND_NODE pun, DWORD mask, BOOL recursive );
VOID DumpDelayMoveList( PSP_DELAYMOVE_NODE pdn, DWORD mask, BOOL recursive );

VOID
DumpAltPlatformInfo(
    PSP_ALTPLATFORM_INFO api,
    DWORD mask
    )
{
    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    dprintf( "\t\t***SP_ALT_PLATFORM_INFO structure***\n" );
    dprintf( "\t\t cbSize : 0x%x\n", api->cbSize );
    dprintf( "\t\t Platform : 0x%x\n", api->Platform );
    dprintf( "\t\t MajorVersion : 0x%x\n", api->MajorVersion );
    dprintf( "\t\t MinorVersion : 0x%x\n", api->MinorVersion );
    dprintf( "\t\t ProcessorArchitecture : 0x%x\n", api->ProcessorArchitecture );
    dprintf( "\t\t Reserved : 0x%x\n", api->Reserved );

}

VOID
DumpFileQueueNodeList(
    PSP_FILE_QUEUE_NODE pfqn,
    DWORD mask,
    BOOL recursive
    )
{
    //PVOID pst;
    //DWORD i, offset;
    //PVOID stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;

    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    SP_FILE_QUEUE_NODE next;
    SOURCE_MEDIA_INFO smi;
    SPQ_CATALOG_INFO ci;

    dprintf( "\t\t***SP_FILE_QUEUE_NODE structure***\n" );
    dprintf( "\t\t Next : 0x%x\n", pfqn->Next );
    dprintf( "\t\t Operation : 0x%x ( %s )\n", pfqn->Operation,
             (pfqn->Operation == FILEOP_DELETE) ? "DELETE" :
             (pfqn->Operation == FILEOP_RENAME) ? "RENAME" :
             "COPY" );


    dprintf( "\t\t SourceRootPath : 0x%x\n", pfqn->SourceRootPath );
    dprintf( "\t\t SourcePath : 0x%x\n", pfqn->SourcePath );
    dprintf( "\t\t SourceFilename : 0x%x\n", pfqn->SourceFilename );
    dprintf( "\t\t TargetDirectory : 0x%x\n", pfqn->TargetDirectory );
    dprintf( "\t\t SecurityDesc : 0x%x\n", pfqn->SecurityDesc );

    dprintf( "\t\t SourceMediaInfo : 0x%x\n", pfqn->SourceMediaInfo );
    if (pfqn->SourceMediaInfo  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move( smi, pfqn->SourceMediaInfo );
        DumpSourceMediaInfoList( &smi, mask, FALSE );
    }

    dprintf( "\t\t StyleFlags : 0x%x\n", pfqn->StyleFlags );
    dprintf( "\t\t InternalFlags : 0x%x\n", pfqn->InternalFlags );

    dprintf( "\t\t CatalogInfo : 0x%x\n", pfqn->CatalogInfo );
    if (pfqn->CatalogInfo  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move( ci, pfqn->CatalogInfo);
        DumpCatalogInfoList( &ci, mask, FALSE  );
    }

    if (pfqn->Next && recursive) {
        move( next, pfqn->Next );
        DumpFileQueueNodeList( &next, mask, TRUE );
    }

}

VOID
DumpSourceMediaInfoList(
    PSOURCE_MEDIA_INFO smi,
    DWORD mask,
    BOOL recursive
    )
{
    //PVOID pst;
    //DWORD i, offset;
    //PVOID stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;

    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    SOURCE_MEDIA_INFO next;
    SP_FILE_QUEUE_NODE queue;

    dprintf( "\t\t***SOURCE_MEDIA_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%x\n", smi->Next );
    dprintf( "\t\t Description : 0x%x\n", smi->Description );
    dprintf( "\t\t DescriptionDisplayName : 0x%x\n", smi->DescriptionDisplayName );
    dprintf( "\t\t Tagfile : 0x%x\n", smi->Tagfile );
    dprintf( "\t\t SourceRootPath : 0x%x\n", smi->SourceRootPath );
    dprintf( "\t\t CopyQueue : 0x%x\n", smi->CopyQueue );

    if (smi->CopyQueue && (mask & 8)  && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move ( queue, smi->CopyQueue ) ;
        DumpFileQueueNodeList( &queue, mask, FALSE );
    }

    dprintf( "\t\t CopyNodeCount : 0x%x\n", smi->CopyNodeCount );
    dprintf( "\t\t Flags : 0x%x\n", smi->Flags );

    if (smi->Next && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move ( next, smi->Next ) ;
        DumpSourceMediaInfoList( &next, mask, TRUE );
    }

}

VOID
DumpCatalogInfoList(
    PSPQ_CATALOG_INFO ci,
    DWORD mask,
    BOOL recursive
    )
{
    //PVOID pst;
    //DWORD i, offset;
    //PVOID stdata,pextradata;
    //STRING_TABLE st;
    //PSTRING_NODEW node;//, prev;

    //if ((mask & 4) == 0 ) {
    //    return;
    //}

    SPQ_CATALOG_INFO next;

    dprintf( "\t\t***SPQ_CATALOG_INFO structure***\n" );
    dprintf( "\t\t Next : 0x%x\n", ci->Next );
    dprintf( "\t\t CatalogFileFromInf : 0x%x\n", ci->CatalogFileFromInf );
    dprintf( "\t\t AltCatalogFileFromInf : 0x%x\n", ci->AltCatalogFileFromInf );
    dprintf( "\t\t AltCatalogFileFromInfPending : 0x%x\n", ci->AltCatalogFileFromInfPending );
    dprintf( "\t\t InfFullPath : 0x%x\n", ci->InfFullPath );
    dprintf( "\t\t InfOriginalName : 0x%x\n", ci->InfOriginalName );
    dprintf( "\t\t InfFinalPath : 0x%x\n", ci->InfFinalPath );
    dprintf( "\t\t VerificationFailureError : 0x%x\n", ci->VerificationFailureError );
    dprintf( "\t\t Flags : 0x%x\n", ci->Flags );
    dprintf( "\t\t CatalogFilenameOnSystem : %ws\n", ci->CatalogFilenameOnSystem  );

    if (ci->Next && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move(next, ci->Next );
        DumpCatalogInfoList( &next, mask, TRUE ) ;
    }

}

VOID
DumpUnwindList(
    PSP_UNWIND_NODE pun,
    DWORD mask,
    BOOL recursive
    )
{
    SP_UNWIND_NODE next;

    dprintf( "\t\t***SP_UNWIND_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%x\n", pun->NextNode );
    dprintf( "\t\t TargetID : 0x%x\n", pun->TargetID );
    dprintf( "\t\t SecurityDesc : 0x%x\n", pun->SecurityDesc );
    dprintf( "\t\t CreateTime : 0x%x 0x%x\n",
             pun->CreateTime.dwLowDateTime,
             pun->CreateTime.dwHighDateTime );

    dprintf( "\t\t AccessTime : 0x%x 0x%x\n",
             pun->AccessTime.dwLowDateTime,
             pun->AccessTime.dwHighDateTime );

    dprintf( "\t\t WriteTime : 0x%x 0x%x\n",
             pun->WriteTime.dwLowDateTime,
             pun->WriteTime.dwHighDateTime );

    if (pun->NextNode && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move(next, pun->NextNode);
        DumpUnwindList( &next, mask, TRUE );
    }

}

VOID
DumpTargetEnt(
    PSP_TARGET_ENT pte,
    DWORD mask
    )
{
    dprintf( "\t\t***SP_TARGET_ENT structure***\n" );
    dprintf( "\t\t TargetRoot : 0x%x\n", pte->TargetRoot );
    dprintf( "\t\t TargetSubDir : 0x%x\n", pte->TargetSubDir );
    dprintf( "\t\t TargetFilename : 0x%x\n", pte->TargetFilename );
    dprintf( "\t\t BackupRoot : 0x%x\n", pte->BackupRoot );
    dprintf( "\t\t BackupSubDir : 0x%x\n", pte->BackupSubDir );
    dprintf( "\t\t BackupFilename : 0x%x\n", pte->BackupFilename );
    dprintf( "\t\t NewTargetFilename : 0x%x\n", pte->NewTargetFilename );
    dprintf( "\t\t InternalFlags : 0x%x\n", pte->InternalFlags );
}

VOID
DumpDelayMoveList(
    PSP_DELAYMOVE_NODE pdn,
    DWORD mask,
    BOOL recursive
    )
{
    SP_DELAYMOVE_NODE next;

    dprintf( "\t\t***SP_DELAYMOVE_NODE structure***\n" );
    dprintf( "\t\t NextNode : 0x%x\n", pdn->NextNode );
    dprintf( "\t\t SourceFilename : 0x%x\n", pdn->SourceFilename );
    dprintf( "\t\t TargetFilename : 0x%x\n", pdn->TargetFilename );
    dprintf( "\t\t SecurityDesc (stringtable index) : 0x%x\n", pdn->SecurityDesc );

    if (pdn->NextNode && recursive) {
        if (CheckInterupted()) {
            return;
        }
        move(next,pdn->NextNode);
        DumpDelayMoveList( &next, mask, TRUE );
    }

}

DECLARE_API( queue )
/*++

Routine Description:

    This debugger extension dumps the data related to a HSPFILEQ

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pfq,pst;
    SP_FILE_QUEUE fq;
    PSP_TARGET_ENT pte;
    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;
    DWORD Mask = 0;


    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pfq = (PVOID)GetExpression( lpArgumentString );

    while (*lpArgumentString && (*lpArgumentString != ' ') ) {
        lpArgumentString++;
    }
    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    if (*lpArgumentString) {
        Mask = (DWORD)GetExpression( lpArgumentString );
    }

    move( fq , pfq );

    dprintf("SP_FILE_QUEUE at :\t0x%08x\n", (ULONG_PTR) pfq);
    dprintf("\t BackupQueue : 0x%08x\n", fq.BackupQueue);
    dprintf("\t DeleteQueue : 0x%08x\n", fq.DeleteQueue);
    dprintf("\t RenameQueue : 0x%08x\n", fq.RenameQueue);

    dprintf("\t CopyNodeCount : 0x%08x\n", fq.CopyNodeCount);
    dprintf("\t DeleteNodeCount : 0x%08x\n", fq.DeleteNodeCount);
    dprintf("\t RenameNodeCount : 0x%08x\n", fq.RenameNodeCount);
    dprintf("\t BackupNodeCount : 0x%08x\n", fq.BackupNodeCount);

    dprintf("\t SourceMediaList : 0x%08x\n", fq.SourceMediaList);
    dprintf("\t SourceMediaCount : 0x%08x\n", fq.SourceMediaCount);

    dprintf("\t CatalogList : 0x%08x\n", fq.CatalogList);
    dprintf("\t DriverSigningPolicy : 0x%08x (%s)\n",
            fq.DriverSigningPolicy,
            (fq.DriverSigningPolicy == DRIVERSIGN_BLOCKING) ? "DRIVERSIGN_BLOCKING" :
            (fq.DriverSigningPolicy == DRIVERSIGN_WARNING) ? "DRIVERSIGN_WARNING" :
            "DRIVERSIGN_NONE" );

    dprintf("\t hWndDriverSigningUi : 0x%08x\n", fq.hWndDriverSigningUi);
    dprintf("\t DeviceDescStringId : 0x%08x\n", fq.DeviceDescStringId);
    dprintf("\t AltPlatformInfo : 0x%08x\n", fq.AltPlatformInfo);

    DumpAltPlatformInfo( &fq.AltPlatformInfo, Mask );

    dprintf("\t AltCatalogFile : 0x%08x\n", fq.AltCatalogFile);

    dprintf("\t StringTable : 0x%08x\n", fq.StringTable);

    dprintf("\t LockRefCount : 0x%08x\n", fq.LockRefCount);
    dprintf("\t Flags : 0x%08x\n", fq.Flags);

    dprintf("\t SisSourceHandle : 0x%08x\n", fq.SisSourceHandle);
    dprintf("\t SisSourceDirectory : 0x%08x\n", fq.SisSourceDirectory);

    dprintf("\t BackupInfID : 0x%08x\n", fq.BackupInfID);
    dprintf("\t TargetLookupTable : 0x%08x\n", fq.TargetLookupTable);
    dprintf("\t UnwindQueue : 0x%08x\n", fq.UnwindQueue);
    dprintf("\t DelayMoveQueue : 0x%08x\n", fq.DelayMoveQueue);
    dprintf("\t DelayMoveQueueTail : 0x%08x\n", fq.DelayMoveQueueTail);

    dprintf("\t Signature : 0x%08x (%s)\n",
            fq.Signature,
            (fq.Signature == SP_FILE_QUEUE_SIG) ? "VALID" : "INVALID" );

    //
    // dump the queue nodes
    //

    if (Mask & 1) {
        SP_FILE_QUEUE_NODE qnode;
        SOURCE_MEDIA_INFO smi;

        if (fq.BackupQueue) {
            move(qnode, fq.BackupQueue);
            dprintf("\t ***BackupQueue***\n");
            DumpFileQueueNodeList( &qnode, Mask, TRUE );
        }

        if (fq.DeleteQueue) {
            move(qnode, fq.DeleteQueue);
            dprintf("\t ***DeleteQueue***\n");
            DumpFileQueueNodeList( &qnode, Mask, TRUE );
        }

        if (fq.RenameQueue) {
            move(qnode, fq.RenameQueue);
            dprintf("\t ***RenameQueue***\n");
            DumpFileQueueNodeList( &qnode, Mask, TRUE );
        }

        if (fq.SourceMediaList) {
            move(smi, fq.SourceMediaList);
            dprintf("\t ***source media list***\n");
            DumpSourceMediaInfoList( &smi, Mask, TRUE );
        }
    }

    //
    // dump the catalog info
    //
    if (Mask & 2) {
        SPQ_CATALOG_INFO ci;

        if (fq.CatalogList) {
            move(ci, fq.CatalogList);
            dprintf("\t ***CatalogList***\n");
            DumpCatalogInfoList( &ci, Mask, TRUE );
        }
    }

    //
    // dump the string table
    //
    if (Mask & 4) {
        dprintf("\t ***StringTable***\n");

        move ( st, fq.StringTable ) ;
        DumpStringTableHeader( &st );

        stdata = GetStringTableData( &st );
        if (!stdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // now, dump each node in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                dprintf("\t\tData at hash bucket %d\n", i);
                while (node) {
                    dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                    pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                    dprintf("\tExtra Data:\t0x%p\n", pextradata );

                    node = GetNextNode( stdata, node, &offset );
                    if (CheckInterupted()) {
                        return;
                    }
                }
            }

            if (CheckInterupted()) {
                    return;
            }
        }
        free( stdata );


        dprintf("\t ***TargetLookupTable***\n");

        move ( st, fq.TargetLookupTable ) ;
        DumpStringTableHeader( &st );

        stdata = GetStringTableData( &st );
        if (!stdata) {
            dprintf("error retrieving string table data!\n");
            return;
        }

        //
        // now, dump each node in the string table
        //
        for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
            node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
            if (!node) {
                // dprintf("No data at hash bucket %d\n", i);
            } else {
                dprintf("\t\tData at hash bucket %d\n", i);
                while (node) {
                    dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                    pte = GetStringNodeExtraData( node );
                    DumpTargetEnt( pte, Mask );
                    free( pte );

                    node = GetNextNode( stdata, node, &offset );
                    if (CheckInterupted()) {
                        return;
                    }
                }
            }

            if (CheckInterupted()) {
                    return;
            }
        }
        free( stdata );

    }

    //
    // backup stuff
    //
    if (Mask & 8) {
        SP_UNWIND_NODE un;
        SP_DELAYMOVE_NODE dnode;

        if (fq.UnwindQueue) {
            move(un, fq.UnwindQueue);
            dprintf("\t ***UnwindQueue***\n");
            DumpUnwindList( &un, Mask, TRUE );
        }

        if (fq.DelayMoveQueue) {
            move(dnode, fq.DelayMoveQueue);
            dprintf("\t ***DelayMoveQueue***\n");
            DumpDelayMoveList( &dnode, Mask, TRUE );
        }

        if (fq.DelayMoveQueueTail) {
            move(dnode, fq.DelayMoveQueueTail);
            dprintf("\t ***DelayMoveQueueTail***\n");
            DumpDelayMoveList( &dnode, Mask, TRUE );
        }
    }
}


DECLARE_API( qcontext )
/*++

Routine Description:

    This debugger extension dumps the data related to a queue context structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pqc;
    QUEUECONTEXT qc;

    DWORD i, offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;

    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pqc = (PVOID)GetExpression( lpArgumentString );

    move( qc , pqc );

    dprintf("QUEUECONTEXT at :\t0x%08x\n", (ULONG_PTR) pqc);
    dprintf("\t OwnerWindow : 0x%08x\n", qc.OwnerWindow);
    dprintf("\t MainThreadId : 0x%08x\n", qc.MainThreadId);
    dprintf("\t ProgressDialog : 0x%08x\n", qc.ProgressDialog);
    dprintf("\t ProgressBar : 0x%08x\n", qc.ProgressBar);
    dprintf("\t Cancelled : 0x%08x\n", qc.Cancelled);
    dprintf("\t CurrentSourceName : %ws\n", qc.CurrentSourceName);
    dprintf("\t ScreenReader : 0x%08x\n", qc.ScreenReader);
    dprintf("\t MessageBoxUp : 0x%08x\n", qc.MessageBoxUp);
    dprintf("\t PendingUiType : 0x%08x\n", qc.PendingUiType);
    dprintf("\t PendingUiParameters : 0x%08x\n", qc.PendingUiParameters);
    dprintf("\t CancelReturnCode : 0x%08x\n", qc.CancelReturnCode);
    dprintf("\t DialogKilled : 0x%08x\n", qc.DialogKilled);
    dprintf("\t AlternateProgressWindow : 0x%08x\n", qc.AlternateProgressWindow);
    dprintf("\t ProgressMsg : 0x%08x\n", qc.ProgressMsg);
    dprintf("\t NoToAllMask : 0x%08x\n", qc.NoToAllMask);
    dprintf("\t UiThreadHandle : 0x%08x\n", qc.UiThreadHandle);

}


//#include "inf.h"

VOID
DumpInfLine(
    PINF_LINE line,
    PBYTE valuedata
    )
{
    DWORD i;
    PVOID ptr;
    ULONG_PTR data;

//    dprintf("***INF_LINE***\n");
    dprintf("\t  ValueCount : 0x%x\n", line->ValueCount);
    dprintf("\t  Flags : 0x%x\n", line->Flags);
    dprintf("\t  Values : 0x%x\n", line->Values);

    if (line->Flags > 3) {
        return;
    }

    for (i = 0; i< line->ValueCount; i++) {
        ptr = valuedata + (ULONG_PTR)(line->Values *sizeof(ULONG_PTR)) + (ULONG_PTR)(i*sizeof(ULONG_PTR));
        move ( data, valuedata + (ULONG_PTR)(line->Values *sizeof(ULONG_PTR)) + (ULONG_PTR)(i*sizeof(ULONG_PTR)) );
        dprintf("\t data [%d] : 0x%x [0x%x]\n", i, ptr,data );

        if (CheckInterupted()) {
            return;
        }
    }
}


VOID
DumpInfSection(
    PINF_SECTION section,
    PBYTE linedata,
    PBYTE valuedata
    )
{
    DWORD i;
    INF_LINE line;
    PBYTE data;

    dprintf("***INF_SECTION***\n");
    dprintf("\t  SectionName : 0x%x\n", section->SectionName);
    dprintf("\t  LineCount : 0x%x\n", section->LineCount);
    dprintf("\t  Lines : 0x%x\n", section->Lines);

    for (i = 0; i< section->LineCount; i++) {

        data = linedata + (sizeof(INF_LINE)*section->Lines) + (ULONG_PTR)(sizeof(INF_LINE)*i);
        dprintf("***INF_LINE [%i] at 0x%x***\n",i, data);
        moveBlock ( line, (PBYTE) linedata + (sizeof(INF_LINE)*section->Lines) + (ULONG_PTR)(sizeof(INF_LINE)*i), sizeof(INF_LINE) );
        DumpInfLine(&line, valuedata);

        if (CheckInterupted()) {
            return;
        }

    }

}


VOID
DumpInfVersionNode(
    PINF_VERSION_NODE ver
    )
{

    PWSTR Data;

    dprintf("***INF_VERSION_NODE***\n");
    dprintf("\t  FilenameSize : 0x%x\n", ver->FilenameSize);
    dprintf("\t  DataBlock : 0x%x\n", ver->DataBlock);
    dprintf("\t  DataSize : 0x%x\n", ver->DataSize);
    dprintf("\t  DatumCount : 0x%x\n", ver->DatumCount);
    dprintf("\t  Filename : %ws\n", ver->Filename);

    return;

    Data = malloc(ver->DataSize);
    if (!Data) {
        return;
    }
    moveBlock(Data, ver->DataBlock, ver->DataSize);


    dprintf("\t %ws\n", Data );

    free( Data );


}


VOID
DumpUserDirId(
    PUSERDIRID dirid
    )
{
    dprintf("***USERDIRID***\n");
    dprintf("\t  Id : 0x%x\n", dirid->Id);
    dprintf("\t  Directory : %ws\n", dirid->Directory);

}

VOID
DumpUserDirIdList(
    PUSERDIRID_LIST list
    )
{
    USERDIRID dirid;
    UINT i;

    dprintf("***USERDIRID_LIST***\n");
    dprintf("\t  UserDirIds : 0x%x\n", list->UserDirIds);
    dprintf("\t  UserDirIdCount : 0x%x\n", list->UserDirIdCount);

    for (i = 0; i < list->UserDirIdCount; i++) {
        moveBlock(dirid, ((LPBYTE)list->UserDirIds) + (ULONG_PTR)(sizeof(ULONG_PTR)*i) , sizeof(USERDIRID));
        DumpUserDirId(&dirid);
        if (CheckInterupted()) {
            return;
        }
    }


}

VOID
DumpStringSubstNode(
    PSTRINGSUBST_NODE node
    )
{
    dprintf("***STRINGSUBST_NODE***\n");
    dprintf("\t  ValueOffset : 0x%x\n", node->ValueOffset);
    dprintf("\t  TemplateStringId : 0x%x\n", node->TemplateStringId);
    dprintf("\t  CaseSensitive : 0x%x\n", node->CaseSensitive);


}


DECLARE_API( infdump )
/*++

Routine Description:

    This debugger extension dumps the data related to an HINF  structure

Arguments:


Return Value:

--*/
{
    DWORD ReturnLength;
    PVOID pinf;
    LOADED_INF inf;
    INF_SECTION InfSection;
    INF_LINE InfLine;

    DWORD i;
    DWORD_PTR offset;
    PVOID stdata,pextradata;
    STRING_TABLE st;
    PSTRING_NODEW node;//, prev;

    //BOOL val;

    INIT_API();

    while (*lpArgumentString == ' ') {
        lpArgumentString++;
    }

    pinf = (PVOID)GetExpression( lpArgumentString );

    move( inf , pinf );

    dprintf("LOADED_INF at :\t0x%x\n", (ULONG_PTR) pinf);
    dprintf("\t Signature : 0x%08x ( %s )\n", inf.Signature,
            inf.Signature == LOADED_INF_SIG ? "Valid" : "Invalid");
    if (inf.Signature != LOADED_INF_SIG) {
        return;
    }

    dprintf("\t FileHandle : 0x%x\n", inf.FileHandle);
    dprintf("\t MappingHandle : 0x%x\n", inf.MappingHandle);
    dprintf("\t ViewAddress : 0x%x\n", inf.ViewAddress);

    if (inf.FileHandle == INVALID_HANDLE_VALUE) {
        dprintf(" *** In memory INF ***\n" );
    } else {
        dprintf(" *** PNF ***\n" );
    }

    dprintf("\t StringTable : 0x%x\n", inf.StringTable);
    dprintf("\t SectionCount : 0x%x\n", inf.SectionCount);

    dprintf("\tSectionBlock : 0x%x\n", inf.SectionBlock);
    for (i = 0; i < inf.SectionCount; i++) {

        dprintf("***INF_SECTION [%d] at 0x%x***\n",i, (PBYTE)inf.SectionBlock + (ULONG_PTR)(sizeof(INF_SECTION)*i));
        move (InfSection, (PBYTE)inf.SectionBlock + (ULONG_PTR)(sizeof(INF_SECTION)*i) );
        DumpInfSection( &InfSection, (PBYTE)inf.LineBlock, (PBYTE)inf.ValueBlock );

        if (CheckInterupted()) {
            return;
        }
    }

    dprintf("\tLineBlock : 0x%x\n", inf.LineBlock);
//    move (InfLine, inf.LineBlock );
//    DumpInfLine( &InfLine ) ;

    dprintf("\t ValueBlock : 0x%x\n", inf.ValueBlock);

    DumpInfVersionNode(&inf.VersionBlock);

    dprintf("\t HasStrings : 0x%x\n", inf.HasStrings);
    dprintf("\t OsLoaderPath : %ws\n", inf.OsLoaderPath);

    dprintf("\t InfSourceMediaType : 0x%x ( ", inf.InfSourceMediaType);
    if (inf.InfSourceMediaType) {
        if (inf.InfSourceMediaType & SPOST_PATH ) {
            dprintf("SPOST_PATH ");
        }
        if (inf.InfSourceMediaType & SPOST_URL) {
            dprintf("SPOST_URL ");
        }
    } else {
        dprintf("SPOST_NONE ");
    }

    dprintf(")\n");

    dprintf("\t InfSourcePath : %ws\n", inf.InfSourcePath);
    dprintf("\t OriginalInfName : %ws\n", inf.OriginalInfName);
    dprintf("\t SubstValueList : 0x%x\n", inf.SubstValueList);
    dprintf("\t SubstValueCount : 0x%x\n", inf.SubstValueCount);
    dprintf("\t Style : 0x%x ( ", inf.Style);

    if (inf.Style & INF_STYLE_OLDNT) {
        dprintf("INF_STYLE_OLDNT ");
    }
    if (inf.Style & INF_STYLE_WIN4) {
        dprintf("INF_STYLE_WIN4 ");
    }

    dprintf(")\n");

    dprintf("\t SectionBlockSizeBytes : 0x%x\n", inf.SectionBlockSizeBytes);
    dprintf("\t LineBlockSizeBytes : 0x%x\n", inf.LineBlockSizeBytes);
    dprintf("\t ValueBlockSizeBytes : 0x%x\n", inf.ValueBlockSizeBytes);
    dprintf("\t LanguageId : 0x%x\n", inf.LanguageId);

    dprintf("\t UserDirIdList : 0x%x\n", inf.UserDirIdList);
    dprintf("\tLock[0] : 0x%x\n", inf.Lock.handles[0]);
    dprintf("\tLock[1] : 0x%x\n", inf.Lock.handles[1]);

    dprintf("\tPrev : 0x%x\n", inf.Prev);
    dprintf("\tNext : 0x%x\n", inf.Next);

    move ( st, inf.StringTable ) ;
    DumpStringTableHeader( &st );

    dprintf("***STRING_TABLE***\n");
    stdata = GetStringTableData( &st );
    if (!stdata) {
        dprintf("error retrieving string table data!\n");
        return;
    }

    //
    // now, dump each node in the string table
    //
    for (i = 0; i<HASH_BUCKET_COUNT; i++ ) {
        node = GetFirstNode(stdata, ((PULONG_PTR)stdata)[i], &offset );
        if (!node) {
            // dprintf("No data at hash bucket %d\n", i);
        } else {
            dprintf("\t\tData at hash bucket %d\n", i);
            while (node) {
                dprintf("\t\tEntry Name:\t%ws (0x%08x)\n", node->String, offset);

                pextradata = st.Data + offset + (wcslen(node->String) + 1)*sizeof(WCHAR) + sizeof(DWORD);
                dprintf("\tExtra Data:\t0x%08x\n", pextradata );

                node = GetNextNode( stdata, node, &offset );
                if (CheckInterupted()) {
                    return;
                }
            }
        }

        if (CheckInterupted()) {
                return;
        }
    }

    free( stdata );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupapi\wrapper\setupapi.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    setupapi.hpp

Abstract:

    Wrapper class library for setup api

Author:

    Vijay Jayaseelan (vijayj) 04 Aug 2000

Revision History:

    None

--*/


#include <setupapi.hpp>
#include <queue.hpp>


//
// InfFile<T>'s static data
//
InfFileW::GetInfSectionsRoutine InfFileW::GetInfSections = NULL;
HMODULE InfFileW::SetupApiModuleHandle = NULL;
ULONG InfFileW::SetupApiUseCount = 0;

InfFileA::GetInfSectionsRoutine InfFileA::GetInfSections = NULL;
HMODULE InfFileA::SetupApiModuleHandle = NULL;
ULONG InfFileA::SetupApiUseCount = 0;

//
// Helper methods
//
std::ostream& 
operator<<(std::ostream &os, PCWSTR rhs) {
    return os << std::wstring(rhs);
}    

std::string& 
ToAnsiString(std::string &lhs, const std::wstring &rhs) {
    ULONG Length = rhs.length();

    if (Length){
        DWORD   Size = 0;
        CHAR    *String = new CHAR[Size = ((Length + 1) * 2)];

        if (::WideCharToMultiByte(CP_ACP, 0, rhs.c_str(), Length + 1,
                                String, Size, 0, 0)) {
            lhs = String;
        }

        delete []String;
    }

    return lhs;
}

std::ostream& 
operator<<(std::ostream &os, const std::basic_string<WCHAR> &rhs) {
    std::string AnsiStr;

    ToAnsiString(AnsiStr, rhs);

    return (os << AnsiStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupapi\wrapper\test\testwrap.cpp ===
#include <setupapi.hpp>
#include <queue.hpp>

struct InvalidArguments : BaseException<char>{
    void Dump(std::ostream &os) {
        os << "Invalid Arguments" << std::endl;
    }
};

template<class T>
struct ProgramArguments {
    std::basic_string<T>    FileName;

    ProgramArguments(int Argc, T *Argv[]) {
        if (Argc > 1) {
            FileName = Argv[1];
        } else {
            throw new InvalidArguments();
        }            
    }

    ~ProgramArguments(){}
};

//
// ANSI Arguments
//
typedef ProgramArguments<char>      AnsiArgs;       
typedef ProgramArguments<wchar_t>   UnicodeArgs;


//
//  Prototypes
//
bool 
ReadTest(
    IN InfFileW &TestInfFile
    );

bool
WriteTest(
    IN InfFileW &TestInfFile
    );

bool
AppendTest(
    IN InfFileW &TestInfFile
    );    

//
// main() entry point
//
int 
__cdecl
wmain(int Argc, wchar_t *Argv[]) {
    int Result = 0;

    try{
        UnicodeArgs PrgArgs(Argc, Argv);
        InfFileW    TestInf(PrgArgs.FileName);

        if (!WriteTest(TestInf)) {
            std::cout << "WriteTest failed" << std::endl;
        }

        if (!AppendTest(TestInf)) {
            std::cout << "AppendTest failed" << std::endl;
        }

        if (!ReadTest(TestInf)) {
            std::cout << "ReadTest failed" << std::endl;
        }                
    }
    catch(BaseException<char> *Exp) {
        Exp->Dump(std::cout);
        delete Exp;
    }
    catch(exception *exp) {
        std::cout << exp->what() << std::endl;
        delete exp;
    }

    return Result;
}


bool
ReadTest(
    IN InfFileW &TestInfFile
    )
{
    bool Result = true;
    
    std::cout << TestInfFile.GetName() << " was opened correctly"
              << std::endl;

    std::cout << TestInfFile;                  

    return Result;
}

bool
WriteTest(
    IN InfFileW &TestInfFile
    )
{
    bool Result = false;
    
    Section<wchar_t>  *NewSection = TestInfFile.AddSection(L"Testing", false);    

    if (NewSection) {
        SectionValues<wchar_t> * NewValues = NewSection->AddLine(L"TestValueKey");

        if (NewValues) {
            NewValues->AppendValue(L"Value1");
            NewValues->AppendValue(L"Value2");

            Result = true;
        }
    }

    return Result;
}

bool
AppendTest(
    IN InfFileW &TestInfFile
    )
{
    bool Result = false;
    
    Section<wchar_t>  *AppSection = TestInfFile.GetSection(L"appendtest");    

    if (AppSection) {
        std::cout << *AppSection << std::endl;
        
        SectionValues<wchar_t> &OldValue = AppSection->GetValue(L"Key");

        std::wstring Value = OldValue.GetValue(0);

        OldValue.PutValue(0, L"\"This is new string\"");

        std::cout << *AppSection << std::endl;
        Result = true;
    }

    return Result;
}

/*
bool
QueueTest(
    VOID
    )
{
    FileQueueW   TestQueue();

    return false;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupapi\wrapper\queue.hpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    queue.hpp

Abstract:

    Abstracts setupapi's file queue

Author:

    Vijay Jayaseelan (vijayj) 08 Oct 2000

Revision History:

    None

--*/

#pragma once

//
// Disable the compiler warning for long names
//
#pragma warning( disable : 4786 )

#include <setupapi.hpp>

template <class T>
class FileQueue {
public:
    FileQueue() {
        QueueHandle = SetupOpenFileQueue();

        if (QueueHandle == INVALID_HANDLE_VALUE) {
            throw new W32Exception();
        }
    }        

    void AddForCopy(const std::basic_string<T> &SourceRoot,
                    const std::basic_string<T> &SourcePath,
                    const std::basic_string<T> &SourceFileName,
                    const std::basic_string<T> &DestPath,
                    const std::basic_string<T> &DestFileName,
                    DWORD CopyFlags) {
        BOOL Result = FALSE;

        /*
        if (sizeof(T) == sizeof(WCHAR)) {
            Result = SetupQueueCopyW(QueueHandle,
                        (PCWSTR)SourceRoot.c_str(),
                        (PCWSTR)SourcePath.c_str(),
                        (PCWSTR) // Left editing here ...
        */                        
    }                    
                        
    void AddForCopy(const SectionValues<T> &RecordToCopy,
                    const std::basic_string<T> &DirSectionName,
                    const std::basic_string<T> &SourceRoot,
                    DWORD CopyStyle) {
        BOOL    Result = FALSE;
        InfFile<T>  &File = RecordToCopy.GetContainer().GetContainer();
        Section<T>  *DirSection = File.GetSection(DirSectionName);
        
        if (sizeof(T) == sizeof(WCHAR)) {
            Result = SetupQueueCopyW(QueueHandle,
                        (PCWSTR)SourceRoot.c_str(),
                        (PCWSTR)RecordToCopy.GetValue(1).c_str(),
                        (PCWSTR)RecordToCopy.GetName().c_str(),
                        NULL,
                        NULL,
                        (PCWSTR)DirSection->GetValue(RecordToCopy.GetValue(7).c_str()).GetValue(0).c_str(),
                        (PCWSTR)RecordToCopy.GetValue(10).c_str(),
                        CopyStyle);
        } else {
            Result = SetupQueueCopyA(QueueHandle,
                        (PCSTR)SourceRoot.c_str(),
                        (PCSTR)RecordToCopy.GetValue(1).c_str(),
                        (PCSTR)RecordToCopy.GetName().c_str(),
                        NULL,
                        NULL,
                        (PCSTR)DirSection->GetValue(RecordToCopy.GetValue(7).c_str()).GetValue(0).c_str(),
                        (PCSTR)RecordToCopy.GetValue(10).c_str(),
                        CopyStyle);
        }    

        if (!Result) {
            throw new W32Exception();
        }            
    }

    void AddForCopy(const Section<T> &SectionToCopy,
                    const std::basic_string<T> &DirSectionName,
                    const std::basic_string<T> &SourceRoot,
                    DWORD CopyStyle) {
        CopyWorkerState State(*this, DirSectionName, SourceRoot, CopyStyle);
        SectionToCopy->DoForEach(SectionCopyWorker, &State);
    }
       
    void Commit() {
        if (!SetupCommitFileQueue(NULL,
                QueueHandle,
                SetupDefaultQueueCallback,
                NULL)) {
            throw new W32Exception();                
        }                
    }

    virtual ~FileQueue() {
        if (QueueHandle != INVALID_HANDLE_VALUE) {
            SetupCloseFileQueue(QueueHandle);
        }
    }

protected:
    struct CopyWorkerState {
        FileQueue<T>                &Queue;
        const std::basic_string<T>  &DirSectionName;
        const std::basic_string<T>  &SourceRoot;
        DWORD                       CopyState;

        CopyWorkerState(FileQueue<T> &Que, const std::basic_string<T> &DirSecName,
                        const std::basic_string<T> &SrcRoot, DWORD Copy) : Queue(Que),
                            DirSectionName(DirSecName), SourceRoot(SrcRoot),
                            CopyState(Copy){}                            
    };                            
                        
    static void SectionCopyWorker(SectionValues<T> &Value, void *ContextData) {
        CopyWorkerState *State = (CopyWorkerState  *)ContextData;

        if (Queue) {
            Queue->AddForCopy(State->Queue,
                        State->DirSectionName,
                        State->SourceRoot);
        }
    }        
        
    
    
    //
    // data members
    //
    HSPFILEQ    QueueHandle;    
};


typedef FileQueue<CHAR>     FileQueueA;
typedef FileQueue<WCHAR>    FileQueueW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupapi\wrapper\setupapi.hpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    setupapi.hpp

Abstract:

    Wrapper class library for setup api

Author:

    Vijay Jayaseelan (vijayj) 04 Aug 2000

Revision History:

    None

--*/

#pragma once

//
// Disable the compiler warning for long names
//
#pragma warning( disable : 4786 )

extern "C" {

#include <windows.h>
#include <setupapi.h>
#include <spapip.h>

}

#include <iostream>
#include <vector>
#include <map>
#include <string>

//
// Wide string output routine
//
std::string& 
ToAnsiString(std::string &lhs, const std::wstring &rhs);

std::ostream& 
operator<<(std::ostream &lhs, const std::basic_string<WCHAR> &rhs);

std::ostream& 
operator<<(std::ostream &lhs, PCWSTR rhs);

//
// Exception classes
//

template<class T>
class BaseException { 
public:
    BaseException(){}
    BaseException(const std::basic_string<T> &Info) 
        : ExceptionInfo(Info) {}

    virtual ~BaseException(){}
    
    virtual void Dump(std::ostream &os) = 0;

protected:
    std::basic_string<T> ExceptionInfo;

};

template<class T>
class InvalidValueIndex : public BaseException<T>{
public:
    InvalidValueIndex(unsigned int Idx) : Index(Idx){}

    void Dump(std::ostream &os) {
        os << "Invalid value index : (" << std::dec 
           << Index << ")" << std::endl;
    }           

private:
    unsigned int    Index;
};

template<class T>
class InvalidValueKey : public BaseException<T>{
public:
    InvalidValueKey(const std::basic_string<T> &SecName,
            const std::basic_string<T> &Key) : SectionName(SecName), KeyName(Key){}

    void Dump(std::ostream &os) {
        os << "Invalid value key name (" << KeyName << ")"  
           << " in " << SectionName << " section." << std::endl;
    }           

private:
    std::basic_string<T> SectionName, KeyName;
};

//
// Abstracts a Win32 error
//
template <class T>
class W32Exception : public BaseException<T> {
public:
    W32Exception(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}

    void Dump(std::ostream &os) {
        T   MsgBuffer[4096];

        MsgBuffer[0] = NULL;

        DWORD CharCount;

        if (sizeof(T) == sizeof(WCHAR)) {
            CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PWSTR)MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

            if (CharCount) {
                std::wstring Msg((PWSTR)MsgBuffer);

                os << Msg;
            } else {
                os << std::hex << ErrorCode;
            }
        } else {
            CharCount = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (PSTR)MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(CHAR),
                                NULL);
                                
            if (CharCount) {
                std::string Msg((PCSTR)MsgBuffer);

                os << Msg;
            } else {
                os << std::hex << ErrorCode;
            }
        }
    }

    DWORD GetErrorCode() const { return ErrorCode; }

protected:
    DWORD   ErrorCode;

};


template<class T>
class Section;

template<class T>
class SectionValues {
public:
    SectionValues(Section<T> &Sec, ULONG LineIdx, bool New = false);
    SectionValues(Section<T> &Sec, const std::basic_string<T> &Key,
            ULONG LineIdx, bool New = false);

    void PutValue(ULONG Index, const std::basic_string<T> &Val) {
        Values[Index] = Val;
        GetContainer().GetContainer().SetDirty();
    }
    
    const std::basic_string<T>& GetValue(ULONG Index) const {
        return Values[Index];
    }
    
    void AppendValue(const std::basic_string<T> &Val) {
        Values.push_back(Val);
        GetContainer().GetContainer().SetDirty();
    }

    void ClearValues() {
        Values.clear();
        GetContainer().GetContainer().SetDirty();
    }        

    ULONG Count() const {
        return Values.size();
    }        

    Section<T>& GetContainer() { return Container; }

    const std::basic_string<T>& GetName() const { return Name; }
    ULONG GetIndex() const { return Index; }

    friend std::ostream& operator<<(std::ostream &os, SectionValues<T> &rhs) {
        os << rhs.GetName() << " = ";

        std::vector< std::basic_string<T> >::iterator Iter = rhs.Values.begin();

        while (Iter != rhs.Values.end()) {
            os << *Iter << ", ";
            Iter++;
        }

        os << std::endl;

        return os;
    }
    
protected:    
    //
    // data members
    //
    ULONG                               Index;
    std::basic_string<T>                Name;
    std::vector< std::basic_string<T> > Values;
    Section<T>                          &Container;
};


template<class T>
struct InvalidInfSection : public BaseException<T> {
public:
    InvalidInfSection(const std::basic_string<T> &SecName,
        const std::basic_string<T> &InfName) 
            : Name(SecName), FileName(InfName){}

    std::basic_string<T> Name;
    std::basic_string<T> FileName;
    

    void Dump(std::ostream &os) {
        os << "InvalidInfSection : " << Name << " in "
           << FileName << std::endl;
    }
};

//
// forward declaration
//

template<class T>
class InfFile;

template<class T>
class Section {
public:
    Section(InfFile<T> &file, const std::basic_string<T> &name);

    Section(InfFile<T> &file, const std::basic_string<T> &name, bool NoKey) :
        File(file), Name(name), Keyless(NoKey) {}

    ~Section(){}

    const std::basic_string<T>& GetName() const{
        return Name;
    }

    SectionValues<T>& GetValue(const std::basic_string<T> &Key) {
        std::vector< SectionValues<T> *>::iterator Iter = Lines.begin();
        SectionValues<T> *Values = NULL;

        while (Iter != Lines.end()) {
            Values = (*Iter);
            
            if (sizeof(T) == sizeof(CHAR)) {
                if (!_stricmp((PCSTR)Values->GetName().c_str(), 
                        (PCSTR)Key.c_str())) {
                    break;
                }                    
            } else {
                if (!_wcsicmp((PCWSTR)Values->GetName().c_str(), 
                        (PCWSTR)Key.c_str())) {
                    break;
                }                    
            }

            Iter++;
        }

        if (Iter == Lines.end()) {
            throw new InvalidValueKey<T>(Name, Key);
        }

        return *Values;
    }


    //
    // Note : For the following scenario
    //
    // [Section]
    // a
    // b,c
    //
    // a & b are treated as Keys i.e. for keyless sections
    // the first value is treated as a key
    //
    bool IsKeyPresent(const std::basic_string<T> &Key) const {
        bool Result = false;
        
        if (!IsKeyless()) {
            std::vector< SectionValues<T> *>::const_iterator Iter = Lines.begin();
            SectionValues<T> *Values = NULL;

            while (Iter != Lines.end()) {
                Values = (*Iter);
                
                if (sizeof(T) == sizeof(CHAR)) {
                    if (!_stricmp((PCSTR)Values->GetName().c_str(), 
                            (PCSTR)Key.c_str())) {
                        break;
                    }                    
                } else {
                    if (!_wcsicmp((PCWSTR)Values->GetName().c_str(), 
                            (PCWSTR)Key.c_str())) {
                        break;
                    }                    
                }

                Iter++;
            }

            Result = (Iter != Lines.end());
        } else {
            std::vector< SectionValues<T> *>::const_iterator Iter = KeylessLines.begin();
            SectionValues<T> *Values = NULL;

            while (Iter != KeylessLines.end()) {
                Values = (*Iter);
                
                if (sizeof(T) == sizeof(CHAR)) {
                    if (!_stricmp((PCSTR)Values->GetValue(0).c_str(), 
                            (PCSTR)Key.c_str())) {
                        break;
                    }                    
                } else {
                    if (!_wcsicmp((PCWSTR)Values->GetValue(0).c_str(), 
                            (PCWSTR)Key.c_str())) {
                        break;
                    }                    
                }

                Iter++;
            }

            Result = (Iter != KeylessLines.end());
        }

        return Result;
    }
    
    SectionValues<T>& GetValue(ULONG Index) {
        return *(KeylessLines[Index]);
    }
    
    InfFile<T>& GetContainer() { return File; }

    bool IsKeyless() const { return Keyless; }

    Section<T>& operator+=(Section<T> &rhs) {
        if (IsKeyless() == rhs.IsKeyless()) {
            //
            // add entries with key
            //
            std::vector< SectionValues<T> *>::iterator Iter = rhs.Lines.begin();

            while (Iter != rhs.Lines.end()) {
                Lines.push_back(*Iter);
                Iter++;
            }

            //
            // add entries without key
            //
            std::vector< SectionValues<T> *>::iterator KlIter = rhs.KeylessLines.begin();
                    
            while (KlIter != rhs.KeylessLines.end()) {
                KeylessLines.push_back(*KlIter);
                KlIter++;
            }
        } else {
            throw new InvalidInfSection<T>(File.GetName(), rhs.GetName());
        }

        return *this;
    }

    SectionValues<T>* AddLine(const std::basic_string<T> &Key) {                                
        SectionValues<T> *Value = NULL;
        
        if (Key.length() && !IsKeyless()) { 
            Value = new SectionValues<T>(*this, Key, 0, true);

            if (Value) {
                Lines.push_back(Value);
            }           
        } else {
            Value = new SectionValues<T>(*this, KeylessLines.size(), true);        

            if (Value) {
                KeylessLines.push_back(Value);
            }                    
        }        

        File.SetDirty();

        return Value;
    }                        
   

    friend std::ostream& operator<<(std::ostream &os, Section<T> &rhs) {
        os << "[" << rhs.GetName() << "]" << std::endl;                 

        Section<T>::Iterator Iter = rhs.begin();
        SectionValues<T> *Values;

        while (!Iter.end()) {    
            Values = *Iter;

            if (Values) {
                os << *Values;
            }
            
            Iter++;
        }

        return os;
    }

    //
    // Callback function pointer for
    // working on each section element
    //
    typedef void (*ELEMENT_WORKER)(
        SectionValues<T> &Values,
        void *ContextData
      );

    void DoForEach(ELEMENT_WORKER Worker, void *ContextData);

    //
    // Iterator
    //
    class Iterator{
        public:    
            Iterator(std::vector< SectionValues<T> *> *Collect = NULL) {
                Collection = Collect;

                if (Collection) {
                    Iter = (*Collection).begin();
                }                    
            }

            Iterator& begin() {
                if (Collection) {
                    Iter = Collection->begin();
                }                    

                return *this;
            }

            bool end() {
                return Collection? (Iter == Collection->end()) : true;
            }
            
            Iterator& operator++(int) {
                if (Collection) {
                    Iter++;
                }
                
                return *this;
            }

            friend SectionValues<T> * operator*(Iterator &lhs) {
                return lhs.Collection ? *(lhs.Iter): NULL;
            }       

            friend Section<T>;

        protected:
            void Init(std::vector< SectionValues<T> *> *Collect) {
                Collection = Collect;
                Iter = (*Collection).begin();
            }

        private:
            //
            // data members
            //
            typename std::vector< SectionValues<T> * >::iterator Iter;
            std::vector< SectionValues<T> *> *Collection;            
    };

    Iterator begin(void) {
        Iterator Iter;

        if (IsKeyless()) {
            if (KeylessLines.size()) {
                Iter.Init(&KeylessLines);
            }
        } else {
            if (Lines.size()) {
                Iter.Init(&Lines);
            }
        }

        return Iter;
    }
        
    

protected:
    
    //
    // data members
    //
    InfFile<T>              &File;
    std::basic_string<T>    Name;
    std::vector< SectionValues<T> *> Lines;
    std::vector< SectionValues<T> *> KeylessLines;
    bool    Keyless;
};


template<class T>
class InvalidInfFile : public BaseException<T> {
public:
    InvalidInfFile() : ErrorCode(0){}

    InvalidInfFile(const std::basic_string<T> &Name) : 
        FileName(Name), ErrorCode(0) {}

    InvalidInfFile(const std::basic_string<T> &Name, DWORD ErrCode) : 
        FileName(Name), ErrorCode(ErrCode) {}

    void Dump(std::ostream &os) {
        os << "Invalid INF file " << FileName;

        if (ErrorCode) {
            os << " (" << std::dec << ErrorCode << ") ";
        }            

        os << std::endl;
    }

protected:
    std::basic_string<T>    FileName;
    DWORD                   ErrorCode;
};

template<class T>
class InvalidInfFormat : public InvalidInfFile<T> {
public:
    InvalidInfFormat(const std::basic_string<T> &Name, UINT Line) : 
        InvalidInfFile<T>(Name), ErrorLine(Line) {}

    void Dump(std::ostream &os) {
        os << "Invalid INF format at " << std::dec 
           << ErrorLine << " line of " << FileName << std::endl;
    }

    UINT    ErrorLine;
};

//
// Inf file abstraction
//
template <class T>
class InfFile {
public:
    InfFile(const std::basic_string<T> &name);

    virtual ~InfFile() {
        if (InfHandle && (InfHandle != INVALID_HANDLE_VALUE)) {
            SetupCloseInfFile(InfHandle);
        }

        if (Dirty) {
            //CommitChanges();
        }

        SetupApiUseCount--;

        if (!SetupApiUseCount) {
            FreeLibrary(SetupApiModuleHandle);
            GetInfSections = NULL;
        }            
    }

    const std::basic_string<T>& GetName() const { 
        return Name;
    }

    friend bool operator==(const InfFile<T> &lhs, const InfFile<T> &rhs) {
        return lhs.GetName() == rhs.GetName();
    }

    friend bool operator!=(const InfFile<T> &lhs, const InfFile<T> &rhs) {
        return !(lhs == rhs);
    }

    void GetLines(Section<T> &Sec,
            std::vector< SectionValues<T> *> &Lines,
            std::vector< SectionValues<T> *> &KeylessLines);
            
    void GetValues(Section<T> &Sec, 
                SectionValues<T> &SecValues,
                std::vector< std::basic_string<T> > &Values);


    friend std::ostream& operator<<(std::ostream &os, InfFile<T> &rhs) {
        InfFile<T>::Iterator Iter = rhs.begin();

        while (!Iter.end()) {
            os << **Iter << std::endl;
            Iter++;            
        }

        return os;
    }    

    Section<T>* AddSection(const std::basic_string<T> &SecName, bool Keyless) {
        Section<T> *NewSection = NULL;
        
        try {
            NewSection = GetSection(SecName);
        } catch(...) {
        }

        if (!NewSection) {            
            Sections[SecName] = NewSection = 
                new Section<T>(*this, SecName, Keyless);
            SetDirty();
        }            

        return NewSection;
    }
    
    Section<T>* GetSection(const std::basic_string<T> &SecName) {
        std::map< std::basic_string<T>, Section<T> *>::iterator Iter = Sections.find(SecName);
        Section<T>* Sec = NULL;

        if (Iter != Sections.end()) {
            Sec = (*Iter).second;
        }

        return Sec;
    }

    void GetSections(std::map< std::basic_string<T>, Section<T> *> &Secs) {
        Secs = Sections;
    }

    void SetDirty() { Dirty = true; }

    const HINF GetInfHandle() const { return InfHandle; }

    //
    // Callback function pointer for
    // working on each section 
    //
    typedef void (*ELEMENT_WORKER)(
        Section<T> &Section,
        void *ContextData
      );

    void DoForEach(ELEMENT_WORKER Worker, void *ContextData);          

    //
    // Iterator
    //
    class Iterator{
        public:    
            Iterator(std::map< std::basic_string<T>, Section<T> *> *Collect = NULL) {
                Collection = Collect;

                if (Collection) {
                    Iter = (*Collection).begin();
                }                    
            }

            Iterator& begin() {
                if (Collection) {
                    Iter = Collection->begin();
                }                    

                return *this;
            }

            bool end() {
                return Collection? (Iter == Collection->end()) : true;
            }
            
            Iterator& operator++(int) {
                if (Collection) {
                    Iter++;
                }
                
                return *this;
            }

            friend Section<T> * operator*(Iterator &lhs) {
                return lhs.Collection ? (*(lhs.Iter)).second: NULL;
            }       

            friend Section<T>;

        protected:
            void Init(std::map< std::basic_string<T>, Section<T> *> *Collect) {
                Collection = Collect;
                Iter = (*Collection).begin();
            }

        private:
            //
            // data members
            //
            typename std::map< std::basic_string<T>, Section<T> *>::iterator Iter;
            std::map< std::basic_string<T>, Section<T> *> *Collection;            
    };

    Iterator begin(void) {
        return Iterator(&(this->Sections));
    }
   
protected:

    HINF OpenFile() {
        HINF InfHandle = NULL;
        UINT ErrorLine = 0;

        if (sizeof(T) == sizeof(CHAR)) {            
            InfHandle = SetupOpenInfFileA((const CHAR*)(GetName().c_str()),
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);
        } else {
            InfHandle = SetupOpenInfFileW((const WCHAR*)(GetName().c_str()),
                            NULL,
                            INF_STYLE_WIN4,
                            &ErrorLine);
        }

        if (InfHandle == INVALID_HANDLE_VALUE) {
            DWORD   ErrorCode = ::GetLastError();
            
            if (ErrorLine) {
                throw new InvalidInfFormat<T>(GetName(), ErrorLine);
            } else {            
                throw new InvalidInfFile<T>(GetName(), ErrorCode);
            }
        }

        return InfHandle;
    }

    typedef BOOL (* GetInfSectionsRoutine)(HINF, T*, UINT, UINT *);

    //
    // data members
    //
    std::basic_string<T>    Name;
    HINF                    InfHandle;
    bool                    Dirty;
    static GetInfSectionsRoutine    GetInfSections;
    static HMODULE                  SetupApiModuleHandle;
    static ULONG                    SetupApiUseCount;
    std::map< std::basic_string<T>, Section<T> *> Sections; 
};

template <class T>
SectionValues<T>::SectionValues(Section<T> &Sec, 
    const std::basic_string<T> &Key,  ULONG LineIdx, bool New) 
        : Container(Sec), Name(Key), Index(LineIdx) {        

    if (!New) {        
        GetContainer().GetContainer().GetValues(Sec, *this, Values);
    }        
}

template <class T>
SectionValues<T>::SectionValues(Section<T> &Sec, ULONG LineIdx, bool New) 
        : Container(Sec), Index(LineIdx) {        
    BYTE Buffer[64] = {0};            

    if (sizeof(T) == sizeof(CHAR)) {
        Name = std::basic_string<T>((const T*)_ltoa(Index, (char *)Buffer, 10));
    } else {
        Name = std::basic_string<T>((const T*)_ltow(Index, (wchar_t*)Buffer, 10));
    }


    if (!New) {        
        GetContainer().GetContainer().GetValues(Sec, *this, Values);
    }        
}

template <class T>
Section<T>::Section(InfFile<T> &file, const std::basic_string<T> &name) 
        : Name(name), File(file), Keyless(false) {
    INFCONTEXT  InfContext;
    BOOL        Result;
    const HINF  InfHandle = GetContainer().GetInfHandle();

    if (sizeof(T) == sizeof(CHAR)) {
        Result = SetupFindFirstLineA((HINF)InfHandle,
                        (PCSTR)GetName().c_str(),
                        NULL,
                        &InfContext);                        
    } else {
        Result = SetupFindFirstLineW((HINF)InfHandle,
                        (PCWSTR)GetName().c_str(),
                        NULL,
                        &InfContext);                        
    }

    //std::cout << Name << " is " << Keyless << std::endl;

    if (Result) {
        BYTE  Buffer[4096], Buffer1[4096];    
        bool KeyPresent = false;
                
        //
        // NOTE : singular values in section are treated as keys
        // by setupapi so take care of such cases correctly
        // as keyless entries
        //
        // ISSUE : because of the way we are trying to determine
        // keyless section a sections with first entry a = a will
        // be treated as keyless section wrongly.
        //
        if (sizeof(T) == sizeof(CHAR)) {
            *((PSTR)Buffer) = '\0';
            *((PSTR)Buffer1) = '\0';
            
            if (SetupGetStringFieldA(&InfContext,
                    0,
                    (PSTR)Buffer,
                    sizeof(Buffer) / sizeof(T),
                    NULL) &&
                SetupGetStringFieldA(&InfContext,
                    1,
                    (PSTR)Buffer1,
                    sizeof(Buffer1) / sizeof(T),
                    NULL)) {
                KeyPresent = (_stricmp((PCSTR)Buffer, (PCSTR)Buffer1) != 0);
            }
        } else {
            *((PWSTR)Buffer) = L'\0';
            *((PWSTR)Buffer1) = L'\0';
            
            if (SetupGetStringFieldW(&InfContext,
                    0,
                    (PWSTR)Buffer,
                    sizeof(Buffer) / sizeof(T),
                    NULL) && 
                SetupGetStringFieldW(&InfContext,
                    1,
                    (PWSTR)Buffer1,
                    sizeof(Buffer1) / sizeof(T),
                    NULL)) {
                KeyPresent = (_wcsicmp((PCWSTR)Buffer, (PCWSTR)Buffer1) != 0);
            }
        }   

        // If we cannot read 0th value, then we
        // assume that the whole section is
        // doesnot have entries with key
        //
        Keyless = !KeyPresent;
    }
        
    GetContainer().GetLines(*this, Lines, KeylessLines);

    //std::cout << Name << " is " << Keyless << std::endl;
}

template<class T>
void 
Section<T>::DoForEach(typename Section<T>::ELEMENT_WORKER Worker, 
                void *ContextData) {
    if (IsKeyless()) {
        std::vector< SectionValues<T> * >::iterator Iter = KeylessLines.begin();    
        SectionValues<T> *Value;

        while (Iter != KeylessLines.end()) {
            Value = *Iter;

            if (Value) {
                Worker(*Value, ContextData);
            }
            
            Iter++;
        }
    } else {
        std::vector< SectionValues<T> *>::iterator Iter = Lines.begin();    
        SectionValues<T> *Value;

        while (Iter != Lines.end()) {
            Value = *Iter;

            if (Value) {
                Worker(*Value, ContextData);
            }
            
            Iter++;
        }        
    }
}


template <class T>
InfFile<T>::InfFile(const std::basic_string<T> &name) : Name(name) {
    Dirty = false;
    InfHandle = OpenFile();

    if (!GetInfSections) {
        SetupApiModuleHandle = LoadLibrary(TEXT("setupapi.dll"));

        if (SetupApiModuleHandle) {
            GetInfSections = (GetInfSectionsRoutine)(GetProcAddress(SetupApiModuleHandle,
                                        "pSetupGetInfSections"));

            if (!GetInfSections) {
                GetInfSections = (GetInfSectionsRoutine)(GetProcAddress(SetupApiModuleHandle,
                                            "SetupGetInfSections"));
            }
        }

        if (!GetInfSections) {
            throw new W32Exception<T>();
        }
    }

    SetupApiUseCount++;

    //
    // get hold of all the sections     
    //
    UINT    CurrSize = 4096;
    UINT    SizeNeeded = 0;
    DWORD   LastError = 0;
    WCHAR   *Buffer = new WCHAR[CurrSize];

    memset(Buffer, 0, CurrSize);
    
    BOOL    Result = GetInfSections(InfHandle, Buffer, CurrSize, &SizeNeeded);
    
    if (!Result && (SizeNeeded > CurrSize)) {
        delete []Buffer;
        Buffer = new WCHAR[SizeNeeded];
        memset(Buffer, 0, SizeNeeded);
        CurrSize = SizeNeeded;
        
        Result = GetInfSections(InfHandle, Buffer, CurrSize, &SizeNeeded);
    }

    std::vector<std::basic_string<T> >  SectionNames;
    
    if (Result) {        
        while (Buffer && *Buffer) {        
            std::basic_string<WCHAR> WNextSection((const WCHAR*)Buffer);

            if (sizeof(T) == sizeof(CHAR)) {
                std::basic_string<T> NextSection;

                ToAnsiString((std::basic_string<char> &)NextSection, WNextSection);
                
                SectionNames.push_back(NextSection);
            } else {
                std::basic_string<T> NextSection((const T *)WNextSection.c_str());
                                    
                SectionNames.push_back(NextSection);
            }                    
                                    
            Buffer += (WNextSection.length() + 1);
        }
    } else {
        LastError = ::GetLastError();
    }

    if (Result && SectionNames.size()) {
        std::vector<std::basic_string<T> >::iterator NameIter = SectionNames.begin();

        while (NameIter != SectionNames.end()) {
            // std::cout << *NameIter << std::endl;
            Sections[*NameIter] = new Section<T>(*this, *NameIter);
            NameIter++;
        }
    }
    
    if (!Result) {
        throw new InvalidInfFile<T>(GetName(), LastError);
    }
}

template<class T>
void 
InfFile<T>::DoForEach(
    typename InfFile<T>::ELEMENT_WORKER Worker, 
    void *ContextData
    ) 
{
    std::map< std::basic_string<T>, Section<T> *>::iterator 
            Iter = Sections.begin();
            
    while (Iter != Sections.end()) {
        Worker(*(*Iter).second, ContextData);
        Iter++;
    }        
}


template <class T>
void 
InfFile<T>::GetLines(
    Section<T> &Sec,
    std::vector< SectionValues<T> *> &Values,
    std::vector< SectionValues<T> *> &KeylessValues
    ) 
{
    std::vector< SectionValues<T>* >::iterator MapIter = Values.begin();

    //
    // delete the old values (if any)
    //
    while (MapIter != Values.end()) {
        if (*MapIter) {
            delete (*MapIter);
        }            

        MapIter++;            
    }
        
    Values.clear();

    std::vector< SectionValues<T>* >::iterator KeylessIter = KeylessValues.begin();

    //
    // delete the old values (if any)
    //
    while (KeylessIter != KeylessValues.end()) {
        if (*KeylessIter) {
            delete (*KeylessIter);
        }            

        KeylessIter++;            
    }
        
    KeylessValues.clear();
    
    //
    // locate the first line
    //    
    INFCONTEXT  InfContext;
    BOOL        Result;
    DWORD   LineCount;

    if (sizeof(T) == sizeof(CHAR)) {
        LineCount = SetupGetLineCountA(InfHandle,
                            (PCSTR)Sec.GetName().c_str());
    } else {
        LineCount = SetupGetLineCountW(InfHandle,
                            (PCWSTR)Sec.GetName().c_str());                                
    }

    if (LineCount) {        
        if (sizeof(T) == sizeof(CHAR)) {
            Result = SetupFindFirstLineA(InfHandle,
                            (PCSTR)Sec.GetName().c_str(),
                            NULL,
                            &InfContext);                        
        } else {
            Result = SetupFindFirstLineW(InfHandle,
                            (PCWSTR)Sec.GetName().c_str(),
                            NULL,
                            &InfContext);                        
        }

        if (Result) {
            BYTE  Buffer[4096];        
            bool Read = false;
            BOOL NextLine = TRUE;
            DWORD Index = 0;
            bool Keyless = Sec.IsKeyless();
            
            for (Index=0; (NextLine && (Index < LineCount)); Index++) {
                Buffer[0] = Buffer[1] = 0;
                Read = false;

                if (!Keyless) {
                    if (sizeof(T) == sizeof(CHAR)) {
                        if (SetupGetStringFieldA(&InfContext,
                                0,
                                (PSTR)Buffer,
                                sizeof(Buffer) / sizeof(T),
                                NULL)) {
                            Read = true;                        
                        }
                    } else {
                        if (SetupGetStringFieldW(&InfContext,
                                0,
                                (PWSTR)Buffer,
                                sizeof(Buffer) / sizeof(T),
                                NULL)) {
                            Read = true;                        
                        }
                    }            
                }                

                if (Read) {
                    std::basic_string<T> Key((const T *)Buffer);

                    //std::cout << Key << std::endl;

                    Values.push_back(new SectionValues<T>(Sec, Key, Index));                
                } else { 
                    KeylessValues.push_back(new SectionValues<T>(Sec, Index));
                }            

                NextLine = SetupFindNextLine(&InfContext, &InfContext);
            }

            if (!NextLine && (Index < LineCount)) {
                throw new InvalidInfSection<T>(Sec.GetName(), GetName());
            }        
        } else {
            throw new InvalidInfSection<T>(Sec.GetName(), GetName());
        }
    }
}

template <class T>
void 
InfFile<T>::GetValues(
    Section<T> &Sec, 
    SectionValues<T> &SecValues,
    std::vector<std::basic_string<T> > &Values
    ) 
{
    const std::basic_string<T> &SecName = Sec.GetName();
    const std::basic_string<T> &Key = SecValues.GetName();

    INFCONTEXT  InfContext;
    BOOL        Result = TRUE;
    ULONG       Lines = 0;

    Values.clear();    

    if (sizeof(T) == sizeof(CHAR)) {
        Lines = SetupGetLineCountA(InfHandle,
                    (PCSTR)SecName.c_str());        
    } else {
        Lines = SetupGetLineCountW(InfHandle,
                    (PCWSTR)SecName.c_str());
    }                    

    if (Lines) {        
        if (sizeof(T) == sizeof(CHAR)) {
            Result = SetupGetLineByIndexA(InfHandle,
                            (PCSTR)SecName.c_str(),
                            SecValues.GetIndex(),
                            &InfContext);                        
        } else {
            Result = SetupGetLineByIndexW(InfHandle,
                            (PCWSTR)SecName.c_str(),
                            SecValues.GetIndex(),
                            &InfContext);                        
        }        

        if (Result) {
            DWORD FieldCount = SetupGetFieldCount(&InfContext);
            BYTE  Buffer[2048];

            for (DWORD Index=0; Index < FieldCount; Index++) {
                Buffer[0] = Buffer[1] = 0;

                if (sizeof(T) == sizeof(CHAR)) {
                    if (SetupGetStringFieldA(&InfContext,
                            Index + 1,
                            (PSTR)Buffer,
                            sizeof(Buffer) / sizeof(T),
                            NULL)) {
                        Values.push_back((const T *)Buffer);
                    }
                } else {
                    if (SetupGetStringFieldW(&InfContext,
                            Index + 1,
                            (PWSTR)Buffer,
                            sizeof(Buffer) / sizeof(T),
                            NULL)) {
                        Values.push_back((const T *)Buffer);
                    }
                }
            }
        } else {
            throw new InvalidInfSection<T>(SecName, GetName());
        }
    }        
}


typedef InfFile<CHAR>   InfFileA;
typedef InfFile<WCHAR>  InfFileW;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setuplog\sources.inc ===
MAJORCOMP=setup
MINORCOMP=log

TARGETNAME=setuplog
TARGETPATH=obj
TARGETTYPE=LIBRARY

SOURCES=\
        setuplog.c  \
        setuplog.rc

INCLUDES=..\..\inc

USE_MSVCRT=1

UMRES=$(O)\setuplog.res
OPTIONAL_UMTEST=x
UMTYPE=windows
UMENTRY=winmain
UMLIBS=$(SDK_LIB_PATH)\syssetup.lib     \
       $(SDK_LIB_PATH)\setupapi.lib     \
       $(SDK_LIB_PATH)\comctl32.lib     \
       $(PROJECT_ROOT)\ntsetup\setuplog\$(O)\setuplog.lib

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setuplog\x.c ===
#include "setuplog.h"
#include <wtypes.h>     // to define HRESULT for richedit.h
#include <richedit.h>
#include <malloc.h>
#include <assert.h>
#pragma hdrstop

SETUPLOG_CONTEXT    SetuplogContext;
PSETUPLOG_CONTEXT   Context;

LPCTSTR pszAppName = TEXT("ViewLog");                // class name
HANDLE  hModule;                                // handle of this instance
HANDLE  hRichedDLL;                             // DLL used for rich edit
HANDLE  hWndMain;                               // handle to main window


VOID
ReportError (
    IN LogSeverity Severity,
    ...
    );

static PVOID
pOpenFileCallback(
    IN  LPCTSTR Filename,
    IN  BOOL    WipeLogFile
    )
{
    WCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Form the pathname of the logfile.
    //
    GetWindowsDirectory(CompleteFilename,MAX_PATH);
    ConcatenatePaths(CompleteFilename,Filename,MAX_PATH,NULL);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}


static BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )
{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;

    if(AnsiBuffer = UnicodeToAnsi (Buffer)) {
        Status = WriteFile (
            LogFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    return Status;

}


VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    WipeLogFile - if TRUE, any existing log file is deleted before logging
        begins.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = CloseHandle;
    Context->AllocMem = malloc;
    Context->FreeMem = free;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;

    //
    // Initialize the log severity descriptions.
    //
    Context->SeverityDescriptions[0] = TEXT("Information");
    Context->SeverityDescriptions[1] = TEXT("Warning");
    Context->SeverityDescriptions[2] = TEXT("Error");
    Context->SeverityDescriptions[3] = TEXT("Fatal Error");

    SetuplogInitialize (Context, TRUE);
    SetuplogError(
        LogSevInformation,
        TEXT("This is the beginning of the Setup Log.\r\n"),
        0,0,0);
}

static VOID
CreateLog (
    )
{
#if 0
    InitializeSetupActionLog(TRUE);
    LogItem(LogSevInformation, L"STO test: Information\r\n");
    LogItem(LogSevWarning, L"STO test: Warning\r\n");
    LogItem(LogSevError, L"STO test: Error\r\n");
    LogItem(LogSevFatalError, L"STO test: Fatal Error\r\n");
    LogItem0(LogSevError,MSG_LOG_INF_CORRUPT,L"INF File Name");
    LogItem1(LogSevWarning,MSG_LOG_PRINTUPG_FAILED,MSG_LOG_X_RETURNED_WINERR,
        L"GetPrinterDriverDirectory",(DWORD)123);
    LogItem2(
        LogSevWarning,
        MSG_LOG_CREATESVC_FAIL,
        L"Service Name",
        MSG_LOG_X_RETURNED_WINERR,
        L"OpenSCManager",
        (DWORD) 123
        );
    LogItem3(
        LogSevError,
        MSG_LOG_SAVEHIVE_FAIL,
        L"Subkey",
        L"Filename",
        MSG_LOG_X_RETURNED_WINERR,
        L"RegSaveKey",
        (LONG) 123
        );
    ReportError (LogSevError,MSG_LOG_INF_CORRUPT,L"INF File Name",0,0);
    ReportError (LogSevWarning,MSG_LOG_PRINTUPG_FAILED,0,
        MSG_LOG_X_RETURNED_WINERR,
        L"GetPrinterDriverDirectory",(DWORD)123,0,0);
    ReportError (
        LogSevWarning,
        MSG_LOG_CREATESVC_FAIL,
        L"Service Name",0,
        MSG_LOG_X_RETURNED_WINERR,
        L"OpenSCManager",
        (DWORD) 123,0,0
        );
    ReportError (
        LogSevError,
        MSG_LOG_SAVEHIVE_FAIL,
        L"Subkey",
        L"Filename",0,
        MSG_LOG_X_RETURNED_WINERR,
        L"RegSaveKey",
        (LONG) 123,0,0
        );
    ReportError (LogSevError, MSG_LOG_OPTIONAL_COMPONENT_ERROR, 0,
        ERROR_NOT_ENOUGH_MEMORY, 0,0);
    ReportError (LogSevError, MSG_LOG_CANT_OPEN_INF,
        L"optional.inf", 0,0);
    ReportError (LogSevError, MSG_LOG_BAD_SECTION, L"SectionName",
        L"InfFileName", 0, 5, 0,0);
    ReportError (LogSevError, MSG_LOG_OC_REGISTRY_ERROR, L"RegKeyName", 0,
        5, 0,0);
    TerminateSetupActionLog();
#endif

    Context = &SetuplogContext;
    InitializeSetupLog (Context);
#if 0 // MSG_* not defined
    SetuplogError(
        LogSevError,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_CANT_OPEN_INF,
        L"optional.inf",
        0,0);
    ReportError(
        LogSevError,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_OC_REGISTRY_ERROR,
        L"RegKeyName", 0,
        SETUPLOG_USE_MESSAGEID,
        5, 0,0);
#endif
    SetuplogError(
        LogSevInformation,
        L"This is a string info message.\r\n",
        0,0,0);
    SetuplogError(
        LogSevWarning,
        L"This is a string warning message.\r\n",
        0,0,0);
    ReportError(
        LogSevError,
        L"This is a reported string error message.\r\n", 0,0,0);
    ReportError(
        LogSevError,
        L"This is a reported string error message %1.\r\n", 0,0,
        L"with an embedded message",0,0,0);
    ReportError(
        LogSevError,
        L"This is a reported string error message %1.\r\n", 0,0,
        L"with an embedded message %1", 0,0,
        L"in an embedded message",0,0,0);
    SetuplogTerminate();
}



LONG
MainWndProc (
    IN HWND     hwnd,
    IN UINT     message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rect;

    switch (message) {

    case WM_CREATE:
#if 0
        ViewSetupActionLog (hwnd, NULL, NULL);
        ViewSetupActionLog (hwnd, L"d:\\WinNt40\\SetUpLog.TXT", L"My Heading");
        ViewSetupActionLog (hwnd, L"MyFile", NULL);
#endif
        PostQuitMessage (0);
        break;

    case WM_PAINT:
        hdc = BeginPaint (hwnd, &ps);
        GetClientRect (hwnd, &rect);
        DrawText (hdc, L"Hello, Windows!", -1, &rect,
            DT_SINGLELINE | DT_CENTER | DT_VCENTER);
        EndPaint (hwnd, &ps);
        break;

    case WM_DESTROY:
        PostQuitMessage (0);
        break;

    default:
        return DefWindowProc (hwnd, message, wParam, lParam);
    }

    return 0;
}



static BOOL
InitMainWindow (
    )
{
    WNDCLASS wc;

    //
    // Initialize the window class.
    //

    hModule = GetModuleHandle (NULL);

    if (TRUE || FindWindow (pszAppName, NULL) == NULL) {
        wc.style            = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc      = MainWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = (HINSTANCE) hModule;
        wc.hIcon            = LoadIcon (NULL, IDI_APPLICATION);
        wc.hCursor          = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName     = pszAppName;
        wc.lpszClassName    = pszAppName;

        if (!RegisterClass (&wc)) {
            return FALSE;
        }
    }


    //
    // Create the window and display it.
    //
    hWndMain = CreateWindow (
        pszAppName,
        L"The Hello Program",
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, 0,
        CW_USEDEFAULT, 0,
        NULL, NULL,
        (HINSTANCE) hModule,
        NULL
    );
    if (!hWndMain) {
        return FALSE;
    }

    ShowWindow (hWndMain, SW_SHOWNORMAL);
    UpdateWindow (hWndMain);
    return TRUE;

}


INT WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    INT nCmdShow)

{
    MSG     msg;

    CreateLog ();

    // Initialize everything
    //
    if (!InitMainWindow ()) {
        assert(FALSE);
        return FALSE;
    }

    // Process messages
    //
    while (GetMessage (&msg, NULL, 0, 0)) {
        TranslateMessage (&msg);
        DispatchMessage (&msg);
    }

    return (msg.wParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setuplog\setuplog.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setuplog.c

Abstract:

    Routines for logging actions and errors during setup.

Author:

    Steve Owen (SteveOw) 1-Sep-1996

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "setuplog.h"

#if DBG

VOID
SetupLogAssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    CHAR Msg[4096];

    wsprintfA(
        Msg,
        "SetupLog: Assertion failure at line %u in file %s: %s\r\n",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);
    DebugBreak();
}

#define MYASSERT(x)     if(!(x)) { SetupLogAssertFail(__FILE__,__LINE__,#x); }

#else
#define MYASSERT(x)
#endif


//
// Pointer to structure given to us during initialization that provides all
// the callbacks and global info we need.
//
PSETUPLOG_CONTEXT   Context = NULL;

BOOL
pLogAction (
    IN  LPCTSTR             Message
    )

/*++

Routine Description:

    Writes an entry into the Setup Action Log.  This routine is responsible
    for setting the format of the log file entries.

Arguments:

    Message - Buffer that contains the text to write.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    return Context->Write (Context->hActionLog, Message);
}

BOOL
pLogError (
    IN  LogSeverity         Severity,
    IN  LPCTSTR             Message
    )

/*++

Routine Description:

    Writes an entry into the Setup Error Log.  This routine is responsible
    for setting the format of the log file entries.

Arguments:

    Message - Buffer that contains the text to write.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    BOOL    b;

    Context->Lock(Context->Mutex);

    //
    // Write the severity description.
    //
    if(Context->SeverityDescriptions[Severity]) {
        b = Context->Write (Context->hErrorLog,
            Context->SeverityDescriptions[Severity]);
        b = b && Context->Write (Context->hErrorLog, TEXT(":\r\n"));
    } else {
        b = TRUE;
    }

    //
    // Write the text.
    //
    b = b && Context->Write (Context->hErrorLog, Message);

    //
    // Write a terminating marker.
    //
    b = b && Context->Write (Context->hErrorLog, SETUPLOG_ITEM_TERMINATOR);

    Context->Unlock(Context->Mutex);

    return(b);
}

PTSTR
pFormatMessage (
    IN  PSETUPLOG_CONTEXT   MyContext,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    ...
    )

/*++

Routine Description:

    Wrapper for Context->Format callback routine.  This routine passes its
    variable argument list to Context->Format as a va_list.


Arguments:

    MyContext - provides callback routines.

    MessageId - supplies message-table identifier or win32 error code
        for the message.

Return Value:

    Pointer to a buffer containing the formatted string.

--*/

{
    va_list arglist;
    PTSTR   p;

    va_start(arglist, MessageId);
    p = MyContext->Format (MessageString,MessageId,&arglist);
    va_end(arglist);
    return(p);
}

BOOL
SetuplogInitializeEx(
    IN  PSETUPLOG_CONTEXT   SetuplogContext,
    IN  BOOL                WipeLogFile,
    IN  LPCTSTR             ActionFilename,
    IN  LPCTSTR             ErrorFilename,
    IN  PVOID               Reserved1,
    IN  DWORD               Reserved2
    )

/*++

Routine Description:

    Opens the Setup log files.

Arguments:

    SetuplogContext - pointer to a context that has been filled in with the
        required callback routines by the caller.

    WipeLogFile - Boolean indicating whether any existing log files should be
        deleted (TRUE) or whether we should append onto existing files (FALSE).

    ActionFilename - filename to be used for the Action Log.

    ErrorFilename - filename to be used for the Error Log.

    Reserved1 - Reserved for future use--must be NULL.

    Reserved2 - Reserved for future use--must be 0.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    if(Reserved1 || Reserved2) {
        return FALSE;
    }

    Context = SetuplogContext;
    Context->WorstError = LogSevInformation;

    Context->hActionLog = Context->OpenFile(
        ActionFilename, WipeLogFile);

    Context->hErrorLog = Context->OpenFile(
        ErrorFilename, WipeLogFile);

    return (Context->hActionLog != INVALID_HANDLE_VALUE &&
        Context->hErrorLog != INVALID_HANDLE_VALUE);
}

BOOL
SetuplogInitialize(
    IN  PSETUPLOG_CONTEXT   SetuplogContext,
    IN  BOOL                WipeLogFile
    )

/*++

Routine Description:

    Opens the Setup log files with default file names.

Arguments:

    SetuplogContext - pointer to a context that has been filled in with the
        required callback routines by the caller.

    WipeLogFile - Boolean indicating whether any existing log files should be
        deleted (TRUE) or whether we should append onto existing files (FALSE).

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    return SetuplogInitializeEx(
        SetuplogContext,
        WipeLogFile,
        SETUPLOG_ACTION_FILENAME,
        SETUPLOG_ERROR_FILENAME,
        NULL,
        0
        );
}

PTSTR
SetuplogFormatMessageWithContextV(
    IN  PSETUPLOG_CONTEXT   MyContext,
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    IN  va_list             *ArgumentList
    )

/*++

Routine Description:

    Formats a specified message with caller-supplied arguments.  The message
    can contain any number of imbedded messages.

Arguments:

    MyContext - provides callback routines.  This parameter is provided so that
        messages can be formatted even the global Context has not been
        initialized because we're not in Setup.  This ability is needed by the
        Add/Remove Programs applet.  The only fields that we use in this
        structure are AllocMem, FreeMem, and Format.

    Flags - Optional flags that can modify how the formatting is performed.

    MessageString - pointer to a buffer containing unformatted message text.
        If this value is SETUPLOG_USE_MESSAGEID, then MessageId is used to
        generate the message text.  Otherwise, MessageId is unused.

    MessageID - ID of the outer level message to be formatted

    ArgumentList - list of strings to be substituted into the message.  The
        order of items in the ArgumentList is given by:
        ArgumentList = Arg1,...,ArgN,NULL,{ImbeddedMessage},NULL
        ImbeddedMessage = MessageID,Arg1,...,ArgN,NULL,{ImbeddedMessage}
        where Arg1,...,ArgN are the arguments for MessageID

Return Value:

    Pointer to a buffer containing the formatted string.  If an error prevented
    the routine from completing successfully, NULL is returned.  The caller
    can free the buffer with Context->MyFree().

--*/

{
    va_list     major_ap, minor_ap;
    UINT        NumberOfArguments, i;
    UINT        MinorMessageId;
    PVOID       p, *MajorArgList;
    PTSTR       MajorMessage, MinorMessage, MinorMessageString;


    //
    // Handle a single message first.
    //
    if(Flags & SETUPLOG_SINGLE_MESSAGE) {
        return MyContext->Format (MessageString, MessageId, ArgumentList);
    }

    //
    // Count the number of arguments that go with the major message (MessageID)
    // and get ready to process the minor (imbedded) message if there is one
    //
    minor_ap = *ArgumentList;
    NumberOfArguments = 0;
    major_ap = minor_ap;
    while (p=va_arg(minor_ap, PVOID)) {
        NumberOfArguments++;
    }
    MYASSERT (NumberOfArguments < 7);

    MinorMessageString = va_arg(minor_ap, PTSTR);
    if (MinorMessageString) {

        //
        // We've got a minor message, so process it first
        //
        MinorMessageId = va_arg(minor_ap, UINT);
        MinorMessage = SetuplogFormatMessageWithContextV (
            MyContext,
            Flags,
            MinorMessageString,
            MinorMessageId,
            &minor_ap);

        if (!MinorMessage) {
            return NULL;
        }

        //
        // Now we handle the major message
        // Ugly hack: since we don't know how to bulid a va_list, we've
        // got to let the compiler do it.
        //
        MajorArgList = MyContext->AllocMem ((NumberOfArguments) * sizeof(PVOID));
        if (!MajorArgList) {
            MyContext->FreeMem (MinorMessage);
            return NULL;
        }
        for (i=0; i<NumberOfArguments; i++) {
            MajorArgList[i] = va_arg (major_ap, PVOID);
        }
        switch (NumberOfArguments) {
        case 0:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MinorMessage);
            break;
        case 1:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MinorMessage);
            break;
        case 2:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MinorMessage);
            break;
        case 3:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MinorMessage);
            break;
        case 4:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MajorArgList[3],
                MinorMessage);
            break;
        case 5:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MajorArgList[3],
                MajorArgList[4],
                MinorMessage);
            break;
        case 6:
            MajorMessage = pFormatMessage (
                MyContext,
                MessageString,
                MessageId,
                MajorArgList[0],
                MajorArgList[1],
                MajorArgList[2],
                MajorArgList[3],
                MajorArgList[4],
                MajorArgList[5],
                MinorMessage);
            break;
        default:
            MajorMessage = NULL;
            MYASSERT (0);
        }
        MyContext->FreeMem (MajorArgList);
        MyContext->FreeMem (MinorMessage);
    } else {
        MajorMessage = MyContext->Format (MessageString, MessageId, &major_ap);
    }

    return MajorMessage;
}

PTSTR
SetuplogFormatMessageV(
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    IN  va_list             *ArgumentList
    )

/*++

Routine Description:

    Wrapper for SetuplogFormatMessageWithContextV.

Arguments:

    See FormatMessageWithContextV.

Return Value:

    See FormatMessageWithContextV.

--*/

{
    //
    // Make sure we've been initialized
    //
    if(!Context) {
        return NULL;
    }

    return SetuplogFormatMessageWithContextV(
        Context,
        Flags,
        MessageString,
        MessageId,
        ArgumentList
        );
}

PTSTR
SetuplogFormatMessage(
    IN  DWORD               Flags,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,
    ...
    )

/*++

Routine Description:

    Wrapper for SetuplogFormatMessageWithContextV.  This routine passes its
    variable argument list to SetuplogFormatMessageV as a va_list.


Arguments:

    See FormatMessageWithContextV.

Return Value:

    See FormatMessageWithContextV.

--*/

{
    va_list arglist;
    PTSTR p;

    //
    // Make sure we've been initialized
    //
    if(!Context) {
        return NULL;
    }
    va_start(arglist,MessageId);
    p = SetuplogFormatMessageWithContextV(
        Context,
        Flags,
        MessageString,
        MessageId,
        &arglist);
    va_end(arglist);

    return(p);
}

BOOL
SetuplogErrorV(
    IN  LogSeverity         Severity,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,      OPTIONAL
    IN  va_list             *ArgumentList
    )

/*++

Routine Description:

    Writes an entry to the Setup Error Log.

Arguments:

    Severity - Severity of the error.  The low word contains the actual number
        of the severity.  The high word contains any flags that affect how the
        message is formatted.

    MessageString - pointer to a buffer containing unformatted message text.
        If this value is SETUPLOG_USE_MESSAGEID, then MessageId is used to
        generate the message text.  Otherwise, MessageId is unused.

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    BOOL    Status = FALSE;
    LPCTSTR Message;

    if(Context) {

        if(Message = SetuplogFormatMessageV (
            Severity,
            MessageString,
            MessageId,
            ArgumentList)) {

            //
            // Now validate the Severity.  Note that we don't have to do this
            // for SetuplogFormatMessageV, since it just looks at the flags
            // set in the high word.
            //
            Severity = LOWORD(Severity);
            if(Severity < LogSevMaximum) {
                Status = TRUE;
            } else {
                MYASSERT (Severity < LogSevMaximum);
                Severity = LogSevInformation;
                Status = FALSE;
            }
            Context->WorstError = max (Context->WorstError, Severity);

            //
            // Write the message(s).
            //
            Status = pLogAction (Message) && Status;
            if(Severity != LogSevInformation) {
                Status = pLogError (Severity, Message) && Status;
            }
            Context->FreeMem (Message);
        }
    }

#if DBG
    if(!Status) {
        OutputDebugStringA("SETUPLOG: Unable to log a message.\n");
    }
#endif
    return Status;
}

BOOL
SetuplogError(
    IN  LogSeverity         Severity,
    IN  LPCTSTR             MessageString,
    IN  UINT                MessageId,      OPTIONAL
    ...
    )

/*++

    Wrapper for SetuplogErrorV
    Make sure to pass two NULLs to end the arglist.
    Otherwise SetuplogFormatMessageWithContextV will cause an exception.

--*/

{
    va_list arglist;
    BOOL    Status;

    va_start(arglist, MessageId);
    Status = SetuplogErrorV (Severity, MessageString, MessageId, &arglist);
    va_end(arglist);

    return Status;
}

BOOL
SetuplogTerminate(
    VOID
    )

/*++

Routine Description:

    Closes the Setup log files.

Arguments:

    None.

Return Value:

    Boolean indicating whether the operation was successful.

--*/

{
    BOOL    Status = FALSE;

    if(Context) {
        Context->CloseFile(Context->hActionLog);
        Context->CloseFile(Context->hErrorLog);

        Context = NULL;
        Status = TRUE;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\setupmsi\makefile.inc ===
# THIS BUILDS THE WINNT32.MSI WITH VERSION INFORMATION
#

$(O)\buildno.txt: buildno.txt
          tok_bldnum.cmd $(PROJECT_ROOT)\ntsetup\setupmsi\$(O)\buildno.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\counted_ptr.h ===
/*
 * counted_ptr - simple reference counted pointer.
 *
 * The is a non-intrusive implementation that allocates an additional
 * int and pointer for every counted object.
 */

#ifndef COUNTED_PTR_H
#define COUNTED_PTR_H

/* For ANSI-challenged compilers, you may want to #define
 * NO_MEMBER_TEMPLATES or explicit */
#define NO_MEMBER_TEMPLATES
#include "MemDeleteQueue.h"


template <class X> class counted_ptr
{
public:
    typedef X element_type;

    explicit counted_ptr(X* p=NULL) // allocate a new counter
        : itsCounter(0) {if (p) itsCounter = new counter(p);}

    virtual ~counted_ptr()
        {release();}

    counted_ptr(const counted_ptr& r) /*throw()*/
        {acquire(r.itsCounter);}

    counted_ptr& operator=(const counted_ptr& r)
    {
        if (this != &r) {
            release();
            acquire(r.itsCounter);
        }
        return *this;
    }

#ifndef NO_MEMBER_TEMPLATES
    template <class Y> friend class counted_ptr<Y>;
    template <class Y> counted_ptr(const counted_ptr<Y>& r) throw()
        {acquire(r.itsCounter);}
    template <class Y> counted_ptr& operator=(const counted_ptr<Y>& r)
    {
        if (this != &r) {
            release();
            acquire(r.itsCounter);
        }
        return *this;
    }
#endif // NO_MEMBER_TEMPLATES

    X& operator*()  const/* throw()*/   {return *itsCounter->ptr;}
    X* operator->() const/* throw()*/   {return itsCounter->ptr;}
    X* get()        const/* throw()*/   {return itsCounter ? itsCounter->ptr : 0;}
    bool unique()   const/* throw()*/
        {return (itsCounter ? itsCounter->count == 1 : true);}
	
	bool IsNull()
	{return (get() == NULL);}

protected:

    struct counter {
        counter(X* p = 0, unsigned c = 1) : ptr(p), count(c) {}
        X*          ptr;
        unsigned    count;
    }* itsCounter;

    void acquire(counter* c) /*throw()*/
    { // increment the count
        itsCounter = c;
        if (c) ++c->count;
    }

    void release()
    { // decrement the count, delete if it is 0
        if (itsCounter) {
            if (--itsCounter->count == 0) {
                delete itsCounter->ptr;
			//	g_DelQueue.Delete(itsCounter->ptr);
                delete itsCounter;
			//	g_DelQueue.Delete(itsCounter);
            }
            itsCounter = 0;
        }
    }


};


template <class X> class counted_ptrA
{
public:



    typedef X element_type;

    explicit counted_ptrA(X* p=NULL) // allocate a new counter
        : itsCounter(0) {if (p) itsCounter = new counter(p);}

    virtual ~counted_ptrA()
        {release();}

    counted_ptrA(const counted_ptrA& r) /*throw()*/
        {acquire(r.itsCounter);}

    counted_ptrA& operator=(const counted_ptrA& r)
    {
        if (this != &r) {
            release();
            acquire(r.itsCounter);
        }
        return *this;
    }

#ifndef NO_MEMBER_TEMPLATES
    template <class Y> friend class counted_ptrA<Y>;
    template <class Y> counted_ptrA(const counted_ptrA<Y>& r) throw()
        {acquire(r.itsCounter);}
    template <class Y> counted_ptrA& operator=(const counted_ptrA<Y>& r)
    {
        if (this != &r) {
            release();
            acquire(r.itsCounter);
        }
        return *this;
    }
#endif // NO_MEMBER_TEMPLATES

    X& operator*()  const/* throw()*/   {return *itsCounter->ptr;}
    X* operator->() const/* throw()*/   {return itsCounter->ptr;}
    X* get()        const/* throw()*/   {return itsCounter ? itsCounter->ptr : 0;}
    bool unique()   const/* throw()*/
        {return (itsCounter ? itsCounter->count == 1 : true);}

protected:

    struct counter {
        counter(X* p = 0, unsigned c = 1) : ptr(p), count(c) {}
        X*          ptr;
        unsigned    count;
    }* itsCounter;

    void acquire(counter* c) /*throw()*/
    { // increment the count
        itsCounter = c;
        if (c) ++c->count;
    }

    void release()
    { // decrement the count, delete if it is 0
        if (itsCounter) {
            if (--itsCounter->count == 0) {
            //    delete [] itsCounter->ptr;
				g_DelQueue.DeleteArray(itsCounter->ptr);
                delete itsCounter;
			//	g_DelQueue.Delete(itsCounter);
            }
            itsCounter = 0;
        }
    }
};

#endif // COUNTED_PTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\memdeletequeue.cpp ===
// MemDeleteQueue.cpp: implementation of the CMemDeleteQueue class.
//
//////////////////////////////////////////////////////////////////////

#include "MemDeleteQueue.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMemDeleteQueue::CMemDeleteQueue()
: m_DelQueue(10010), m_DelArrayQueue(100010), m_QueueSize(100000)
{

}

CMemDeleteQueue::~CMemDeleteQueue()
{
	Flush();
}

void CMemDeleteQueue::Delete(void *ptr)
{

//	delete ptr;
	
	m_DelQueue.AddElement(ptr);

	if (m_DelQueue.GetNumElementsStored() >= m_QueueSize)
	{
		FlushDelQueue();
	}
}


void CMemDeleteQueue::FlushDelQueue()
{
	for (int i=0; i<m_DelQueue.GetNumElementsStored(); i++)
	{
		delete m_DelQueue.Access()[i];
	}

	m_DelQueue.SetNumElementsStored(0);
}


void CMemDeleteQueue::DeleteArray(TCHAR* ptr)
{
//	delete[] ptr;
	
	m_DelArrayQueue.AddElement(ptr);

	if (m_DelArrayQueue.GetNumElementsStored() >= m_QueueSize)
	{
		FlushDelArrayQueue();
	}
}


void CMemDeleteQueue::FlushDelArrayQueue()
{
	for (int i=0; i<m_DelArrayQueue.GetNumElementsStored(); i++)
	{
		delete m_DelArrayQueue.Access()[i];
	}

	m_DelArrayQueue.SetNumElementsStored(0);
}



CMemDeleteQueue g_DelQueue;

void CMemDeleteQueue::Flush()
{
	FlushDelQueue();
	FlushDelArrayQueue();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\memdeletequeue.h ===
// MemDeleteQueue.h: interface for the CMemDeleteQueue class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MEMDELETEQUEUE_H__C8412BD8_F58D_4CB6_81F9_FAA4ABD87583__INCLUDED_)
#define AFX_MEMDELETEQUEUE_H__C8412BD8_F58D_4CB6_81F9_FAA4ABD87583__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SmartBuffer.h"

#include <tchar.h>

typedef CSmartBuffer<void*> DelQueue;

class CMemDeleteQueue
{
public:
	void Flush();
	CMemDeleteQueue();
	virtual ~CMemDeleteQueue();

	void Delete(void* ptr);
	void DeleteArray(TCHAR* ptr);

protected:
	void FlushDelQueue();
	void FlushDelArrayQueue();

	int m_QueueSize;
	DelQueue m_DelQueue;
	DelQueue m_DelArrayQueue;
};

extern CMemDeleteQueue g_DelQueue;

#endif // !defined(AFX_MEMDELETEQUEUE_H__C8412BD8_F58D_4CB6_81F9_FAA4ABD87583__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\precomp.h ===
#pragma once

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>
#include <windef.h>
#include <setupapi.h>
#include <winver.h>
#include <tchar.h>
#include <stdio.h>
#include <time.h>

#include "regdiff.h"
#include "top.h"


#define SIZEOF_STRING_W(String)     ((wcslen(String) + 1) * sizeof (WCHAR))

#define ELEMSOFARRAY(a)      (sizeof(a) / sizeof((a)[0]))
#define MAKEULONGLONG(low,high) ((ULONGLONG)(((DWORD)(low)) | ((ULONGLONG)((DWORD)(high))) << 32))
#define HIULONG(_val_)      ((ULONG)(_val_>>32))
#define LOULONG(_val_)      ((ULONG)_val_)

#define UNICODE_TO_ANSI(u,uchars,a,asize)           \
                ::WideCharToMultiByte (             \
                    CP_ACP,                         \
                    0,                              \
                    (u),                            \
                    (uchars),                       \
                    (a),                            \
                    (asize),                        \
                    NULL,                           \
                    NULL                            \
                    )                               \

#define ANSI_TO_UNICODE(a,asize,u,uchars)           \
                ::MultiByteToWideChar (             \
                    CP_ACP,                         \
                    0,                              \
                    (a),                            \
                    (asize),                        \
                    (u),                            \
                    (uchars)                        \
                    )                               \

#define OOM()           SetLastError(ERROR_NOT_ENOUGH_MEMORY)
#define INVALID_PARAM() SetLastError(ERROR_INVALID_PARAMETER)
#define INVALID_FUNC()  SetLastError(ERROR_INVALID_FUNCTION)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\main.cpp ===
#include "precomp.h"
#include "RegAnalyzer.h"
#include "RegDiffFile.h"

#include <process.h>

HREGANL
CreateRegAnalyzer (
    VOID
    )
{
	HREGANL regAnalyzer = (HREGANL) new CRegAnalyzer;
	return regAnalyzer;
}

BOOL
CloseRegAnalyzer (
    IN      HREGANL RegAnalyzer
    )
{
	delete (CRegAnalyzer*) RegAnalyzer;
	return TRUE;
}

BOOL
AddRegistryKey (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR RootKeyName,
    IN      PCTSTR SubKeyName
    )
{
	CRegAnalyzer* pRA = (CRegAnalyzer*)RegAnalyzer;
	return pRA->AddKey(RootKeyName, SubKeyName);
}

BOOL
ExcludeRegistryKey (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR RootKeyName,
    IN      PCTSTR SubKeyName
    )
{
	CRegAnalyzer* pRA = (CRegAnalyzer*)RegAnalyzer;
	return pRA->AddKey(RootKeyName, SubKeyName, true);
}

//////////////////////////////////////////////////////////////////////////////////////

struct TakeSnapshotParams
{
    HREGANL RegAnalyzer;
    PCTSTR SnapshotFile;
    PFNSNAPSHOTPROGRESS ProgressCallback;
    PVOID Context;
    DWORD MaxLevel;
	HANDLE hEvent;
};


void __cdecl TakeSnapshotThread(void* pParams)
{
	TakeSnapshotParams* pp = (TakeSnapshotParams*)pParams;

	if (pp != NULL)
	{
		CRegAnalyzer* pRA = (CRegAnalyzer*)pp->RegAnalyzer;

		pRA->SaveKeysToFile(pp->SnapshotFile, pp->ProgressCallback, pp->Context, pp->MaxLevel);

		SetEvent(pp->hEvent);

		delete pp;
	}

	return;
}


BOOL 
TakeSnapshot (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR SnapshotFile,
    IN      PFNSNAPSHOTPROGRESS ProgressCallback,
    IN      PVOID Context,
    IN      DWORD MaxLevel,
	IN		HANDLE hEvent
    )
{
	CRegAnalyzer* pRA = (CRegAnalyzer*)RegAnalyzer;

	if (hEvent == NULL)
		return pRA->SaveKeysToFile(SnapshotFile, ProgressCallback, Context, MaxLevel);
	else
	{
		TakeSnapshotParams* pParams = new TakeSnapshotParams;
		
		if (pParams != NULL)
		{
			pParams->RegAnalyzer=RegAnalyzer;
			pParams->SnapshotFile=SnapshotFile;
			pParams->ProgressCallback=ProgressCallback;
			pParams->Context=Context;
			pParams->MaxLevel=MaxLevel;
			pParams->hEvent=hEvent;

			_beginthread(TakeSnapshotThread, 0, (void*)pParams);
			return TRUE;
		}
		else 
			return FALSE;
	}
}

//////////////////////////////////////////////////////////////////////////////////////

struct ComputeDifferencesParams
{
    HREGANL RegAnalyzer;
    PCTSTR Snapshot1;
    PCTSTR Snapshot2;
    PCTSTR DiffFile;
	HANDLE hEvent;
};


void __cdecl ComputeDifferencesThread(void* pParams)
{
	ComputeDifferencesParams* pp = (ComputeDifferencesParams*)pParams;

	if (pp != NULL)
	{
		CRegAnalyzer* pRA = (CRegAnalyzer*)pp->RegAnalyzer;

		pRA->ComputeDifferences1(pp->Snapshot1, pp->Snapshot2, pp->DiffFile);

		SetEvent(pp->hEvent);

		delete pp;
	}

	return;
}


BOOL
ComputeDifferences (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR Snapshot1,
    IN      PCTSTR Snapshot2,
    IN      PCTSTR DiffFile,
	IN		HANDLE hEvent
    )
{
	CRegAnalyzer* pRA = (CRegAnalyzer*)RegAnalyzer;
    //
    // BUGBUG - ISSUE - what about security settings associated with each registry key?
    //
	if (hEvent == NULL)
		return pRA->ComputeDifferences1(Snapshot1, Snapshot2, DiffFile);
	else
	{
		ComputeDifferencesParams* pParams = new ComputeDifferencesParams;
		
		if (pParams != NULL)
		{
			pParams->RegAnalyzer=RegAnalyzer;
			pParams->Snapshot1=Snapshot1;
			pParams->Snapshot2=Snapshot2;
			pParams->DiffFile=DiffFile;
			pParams->hEvent=hEvent;

			_beginthread(ComputeDifferencesThread, 0, (void*)pParams);
			return TRUE;
		}
		else 
			return FALSE;
	}
}

//////////////////////////////////////////////////////////////////////////////////////



BOOL
InstallDifferences (
    IN      PCTSTR DiffFile,
    IN      PCTSTR UndoFile
    )
{
	CRegDiffFile diff;
    if (!diff.Init(DiffFile, TRUE)) {
        return FALSE;
    }
	return diff.ApplyToRegistry(UndoFile);
}

BOOL
CountRegSubkeysInternal (
    IN      HKEY RootKey,
    IN      PCTSTR SubKey,
    IN      DWORD MaxLevels,
    OUT     PDWORD Nodes
    )
{
    MYASSERT (MaxLevels > 0);

    HKEY parentKey;
    DWORD rc = RegOpenKeyEx (RootKey, SubKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &parentKey);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG3 (LOG_ERROR, "Failed to open reg subkey (%x,%s) (rc=%u)", RootKey, SubKey, rc);
        return FALSE;
    }

    BOOL b = FALSE;

    PTSTR subKeyBuffer = NULL;

    __try {

        DWORD subKeys;
        DWORD subKeyMaxLen;
        rc = RegQueryInfoKey (parentKey, NULL, NULL, NULL, &subKeys, &subKeyMaxLen, NULL, NULL, NULL, NULL, NULL, NULL);
        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG3 (LOG_ERROR, "Failed to query reg subkey (%x,%s) (rc=%u)", RootKey, SubKey, rc);
            __leave;
        }
        subKeyMaxLen++;
        subKeyBuffer = new TCHAR[subKeyMaxLen];
        if (!subKeyBuffer) {
            OOM();
            __leave;
        }

        if (MaxLevels > 1) {

            for (DWORD index = 0; index < subKeys; index++) {
                DWORD len = subKeyMaxLen;
                rc = RegEnumKeyEx (parentKey, index, subKeyBuffer, &len, NULL, NULL, NULL, NULL);
                if (rc == ERROR_NO_MORE_ITEMS) {
                    break;
                }
                if (rc != ERROR_SUCCESS) {
                    SetLastError (rc);
                    LOG4 (LOG_ERROR, "Failed to enum reg subkey (%x,%s) at index %u (rc=%u)", RootKey, SubKey, index, rc);
                    __leave;
                }
                if (!CountRegSubkeysInternal (parentKey, subKeyBuffer, MaxLevels - 1, Nodes)) {
                    __leave;
                }
            }
        }

        *Nodes += subKeys;

        delete []subKeyBuffer;
        subKeyBuffer = NULL;

        b = TRUE;
    }
    __finally {
        if (!b) {
            rc = GetLastError ();
        }
        if (subKeyBuffer) {
            delete []subKeyBuffer;
        }
        RegCloseKey (parentKey);
        if (!b) {
            SetLastError (rc);
        }
    }

    return b;
}

BOOL
CountRegSubkeys (
    IN      PCTSTR Root,
    IN      PCTSTR SubKey,
    IN      DWORD MaxLevels,
    OUT     PDWORD Nodes
    )
{
    HKEY rootKey = GetRootKey (Root);
    if (!rootKey) {
        LOG1 (LOG_ERROR, "Invalid root key (%s)", Root);
        return FALSE;
    }
    HKEY parentKey;
    DWORD rc = RegOpenKeyEx (rootKey, SubKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &parentKey);
    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG3 (LOG_ERROR, "Failed to open reg key (%s\\%s) (rc=%u)", Root, SubKey, rc);
        return FALSE;
    }
    RegCloseKey (parentKey);

    *Nodes = 1;         // the root itself
    return MaxLevels ? CountRegSubkeysInternal (rootKey, SubKey, MaxLevels, Nodes) : TRUE;
}

HKEY
GetRootKey (
    IN      PCTSTR RootStr
    )
{
    static struct {
        PCTSTR RootStr;
        HKEY RootKey;
    } map[] = {
        { TEXT("HKLM"), HKEY_LOCAL_MACHINE },
        { TEXT("HKCU"), HKEY_CURRENT_USER },
        { TEXT("HKCR"), HKEY_CLASSES_ROOT },
	    { TEXT("HKU"), HKEY_USERS },
	    { TEXT("HKCC"), HKEY_CURRENT_CONFIG },
        { NULL, 0 }
    }, *entry;

    for (entry = map; entry->RootStr; entry++) {
        if (_tcsicmp (RootStr, entry->RootStr) == 0) {
            return entry->RootKey;
        }
    }
    SetLastError (ERROR_INVALID_PARAMETER);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\reganalyzer.cpp ===
// RegAnalyzer.cpp: implementation of the RegAnalyzer class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "RegAnalyzer.h"
#include "RegDiffFile.h"
#include "RegInfFile.h"

#define BUFSIZE 1024

//#include "MemDeleteQueue.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegAnalyzer::CRegAnalyzer() 
:m_SA(500,200), m_pData(9000), m_pOutputLine(500), m_KeysToSave(3), m_KeysToExclude(3)
{

}

CRegAnalyzer::~CRegAnalyzer()
{

}

bool CRegAnalyzer::SaveKeyToFile(
    IN      HKEY hKey,
    IN      LPCTSTR KeyName,
    IN      CRegFile* RegFile,
    IN      SectionType section,
    IN OUT  PDWORD NodesSoFar,          OPTIONAL
    IN      PFNSNAPSHOTPROGRESS ProgressCallback,
    IN      PVOID Context,
    IN      INT MaxLevels
    )
{
    DWORD rc;

    if (m_KeysToExclude.FindElement(KeyName))
	{
		if (NodesSoFar && ProgressCallback && MaxLevels > 0) 
		{
			++(*NodesSoFar);
			rc = ProgressCallback (Context, *NodesSoFar);
			if (rc) {
				SetLastError (rc);
				return false;
			}
		}
		return true;
    }


	DWORD SubKeyNameSize = MAX_PATH+1;

	DWORD NumSubKeys;

	TCHAR newPath[BUFSIZE];

///added
	CRegDataItemPtr key(new CRegDataItem);
	key->m_KeyName = KeyName;
	key->m_bIsEmpty = false;
	RegFile->WriteDataItem(section, key);
///


//**
	SaveValuesToFile(hKey, KeyName, RegFile, section);
//**

//////
	if (RegQueryInfoKey(hKey, 0,0,0,&NumSubKeys,0,0,0,0,0,0,0) == ERROR_SUCCESS)
	{
		if (NumSubKeys > 0)
		{
			CRegStringBuffer SA(NumSubKeys, SubKeyNameSize);

			TCHAR** nameArray = SA.Access(NumSubKeys, SubKeyNameSize);

			if (nameArray == NULL)
				return false;

			DWORD i=0;

			while (i < NumSubKeys && RegEnumKey(hKey, i, nameArray[i], SubKeyNameSize) == ERROR_SUCCESS)
			{
				i++;
			}

			SA.Sort(NumSubKeys);

			for (i=0; i<NumSubKeys; i++)
			{
				_stprintf(newPath, TEXT("%s\\%s"), KeyName, nameArray[i]);

				HKEY hSubKey;

				if (RegOpenKeyEx(hKey,nameArray[i],0,KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,&hSubKey) == ERROR_SUCCESS) 
				{
                    if (!SaveKeyToFile(hSubKey, newPath, RegFile, section, NodesSoFar, ProgressCallback, Context, MaxLevels - 1)) {
                        return false;
                    }

					RegCloseKey(hSubKey);
				}
			}
		}
	}

    if (NodesSoFar && ProgressCallback && MaxLevels > 0) 
	{
		++(*NodesSoFar);
        rc = ProgressCallback (Context, *NodesSoFar);
        if (rc) {
            SetLastError (rc);
            return false;
        }
    }

	return true;
}


bool CRegAnalyzer::SaveValuesToFile(HKEY hKey, LPCTSTR KeyName, CRegFile* RegFile, SectionType section)
{
	BYTE* valueData;

	TCHAR** nameArray;

	DWORD valueNameLen, maxValueNameLen=1000;
	DWORD valueDataLen, maxValueDataLen=4000;
	DWORD numValues=4;

	DWORD status;

	DWORD valueType;

	if (RegQueryInfoKey(hKey, 0,0,0,0,0,0,&numValues,&maxValueNameLen,&maxValueDataLen,0,0) == ERROR_SUCCESS)
	{
		maxValueNameLen += 1;  //must be at least 1 to include null terminator

		valueData = m_pData.Allocate(maxValueDataLen);//new BYTE[maxValueLen];

		if (numValues >0)
		{
			nameArray = m_SA.Access(numValues,maxValueNameLen);

			if (nameArray == NULL)
			{
				LOG0(LOG_ERROR, "Could not access string array in CRegAnalyzer::SaveValuesToFile");
				return false;

			}


			valueNameLen = maxValueNameLen;


			DWORD i=0;
			
			while (((status = RegEnumValue(hKey, i, nameArray[i], &valueNameLen,0,0,0,0)) == ERROR_SUCCESS)
				|| (status == ERROR_MORE_DATA))
			{
				i++;
				valueNameLen = maxValueNameLen;
			}

			m_SA.Sort(numValues);


			for (i=0; i<numValues; i++)
			{
				valueDataLen = maxValueDataLen;
				int code = RegQueryValueEx(hKey, nameArray[i], 0, &valueType, valueData, &valueDataLen);


				CRegDataItemPtr temp(new CRegDataItem);

				temp->m_bIsEmpty = false;
				temp->m_Name = nameArray[i];
				temp->m_NameLen = _tcsclen(nameArray[i]);
				temp->m_Type = valueType;
				
				temp->m_DataLen = valueDataLen;
				
				if (RegFile->NeedStorageOfValueData())
				{
					temp->m_pDataBuf = new BYTE[temp->m_DataLen];
					memcpy(temp->m_pDataBuf, valueData, temp->m_DataLen);
					temp->m_bDontDeleteData = false;
				}
				else
				{
					temp->m_pDataBuf = valueData; 
					temp->m_bDontDeleteData = true;
				}

				temp->m_KeyName = KeyName;

				///added
				RegFile->WriteDataItem(section,temp);
			}
		}

	}

	return true;
}


bool IsKeyName(LPCTSTR str)
{
	return ((str != NULL) && (str[0] == TEXT('H')));
}


bool CRegAnalyzer::ComputeDifferences1(LPCTSTR RegFile1, LPCTSTR RegFile2, LPCTSTR OutputFile)
{
	CRegFile f1,f2;
	CRegDiffFile out;

	f1.Init(RegFile1, TRUE);
	f2.Init(RegFile2, TRUE);

	out.Init(OutputFile, FALSE);
	
	while (true)
	{
		LPCTSTR Key1 = f1.GetNextLine();
		LPCTSTR Key2 = f2.GetNextLine();

		if (IsKeyName(Key1) && IsKeyName(Key2))
		{
			CompareRegKeys(Key1, Key2, f1, f2, out);

			//delete[] Key1;
			//delete[] Key2;
			g_DelQueue.DeleteArray((TCHAR*)Key1);
			g_DelQueue.DeleteArray((TCHAR*)Key2);
		}
		else
		{
			//delete[] Key1;
			//delete[] Key2;
			g_DelQueue.DeleteArray((TCHAR*)Key1);
			g_DelQueue.DeleteArray((TCHAR*)Key2);
			break;
		}
	}

	out.WriteStoredSectionsToFile();

	g_DelQueue.Flush();
	return true;
}


int MyStrCmp(LPCTSTR s1, LPCTSTR s2)
{
	if (s1 == s2) 
		return 0;
	else if ((s1 == NULL) && (s2 != NULL))
		return 1;
	else if ((s1 != NULL) && (s2 == NULL))
		return -1;
	else
		return _tcscmp(s1, s2);

}


void CRegAnalyzer::CompareDataItems(LPCTSTR KeyName, CRegFile &f1, CRegFile &f2, CRegDiffFile &out)
{
	CRegDataItemPtr r1 = f1.GetNextDataItem();
	CRegDataItemPtr r2 = f2.GetNextDataItem();

	while ((!r1->m_bIsEmpty) || (!r2->m_bIsEmpty))
	{
		int code = r1->CompareTo(*r2);

		if (code < 0) //r1.name < r2.name
		{
			CRegDataItemPtr temp(new CRegDataItem);

			temp->m_bIsEmpty = false;
			temp->m_KeyName = KeyName;
			temp->m_Name = r1->m_Name;
			temp->m_NameLen = r1->m_NameLen;

			out.WriteDataItem(SECTION_DELREG, temp);

			r1 = f1.GetNextDataItem();
		}
		else if (code == 0) //r1 == r2
		{
			r1 = f1.GetNextDataItem();
			r2 = f2.GetNextDataItem();
		}
		else if (code == 1) //r1.name == r2.name, but other changes in item's data
		{			
			r2->m_KeyName = KeyName;
			out.WriteDataItem(SECTION_ADDREG, r2);
		

			r1 = f1.GetNextDataItem();
			r2 = f2.GetNextDataItem();
		}
		else //r1.name > r2.name
		{
			r2->m_KeyName = KeyName;
			out.WriteDataItem(SECTION_ADDREG, r2);

			r2 = f2.GetNextDataItem();
		}

	}
}


int CRegAnalyzer::CompareRegKeys(LPCTSTR Key1, LPCTSTR Key2, CRegFile& f1, CRegFile& f2, CRegDiffFile& out)
{
	CRegFile blank1;
	CRegDiffFile blank2;
	CRegDataItemPtr r;

	if ((Key1 == NULL) && (Key2 == NULL))
		return 0;

	int code = MyStrCmp(Key1, Key2);

	if (code < 0) //Key1 < Key2
	{
		r= CRegDataItemPtr(new CRegDataItem);
		r->m_KeyName = Key1;
		r->m_bIsEmpty = false;
		out.WriteDataItem(SECTION_DELREG, r);

		CompareDataItems(Key1, f1, blank1, blank2);
		CompareSubKeys(Key1, f1, blank1, blank2);
	}
	else if (code == 0) //Key1 == Key2
	{
		CompareDataItems(Key1, f1, f2, out);
		CompareSubKeys(Key1,  f1, f2, out);
	}
	else //Key1 > Key2
	{
		r= CRegDataItemPtr(new CRegDataItem);
		r->m_KeyName = Key2;
		r->m_bIsEmpty = false;
		out.WriteDataItem(SECTION_ADDREG, r);

		CompareDataItems(Key2, blank1, f2, out);
		CompareSubKeys(Key2,  blank1, f2, out);
	}
	
	return code;

}


void CRegAnalyzer::CompareSubKeys(LPCTSTR Key, CRegFile& f1, CRegFile& f2, CRegDiffFile& out)
{
	LPCTSTR SubKey1=NULL, SubKey2=NULL;

	int result = 0;
	while (true)
	{
		if (result == 0)
		{
		//	g_DelQueue.DeleteArray((TCHAR*)SubKey1);
		//	g_DelQueue.DeleteArray((TCHAR*)SubKey2);
			delete[] SubKey1;
			delete[] SubKey2;

			SubKey1 = f1.GetNextSubKey(Key);
			SubKey2 = f2.GetNextSubKey(Key);
		}
		else if (result < 0)
		{
			delete[] SubKey1;
		//	g_DelQueue.DeleteArray((TCHAR*)SubKey1);

			SubKey1 = f1.GetNextSubKey(Key);
		}
		else
		{
			delete[] SubKey2;
			//g_DelQueue.DeleteArray((TCHAR*)SubKey2);

			SubKey2 = f2.GetNextSubKey(Key);
		}

		if ((SubKey1 != NULL) || (SubKey2 != NULL))
		{
			result = CompareRegKeys(SubKey1, SubKey2, f1, f2, out);		
		}
		else
			break;
	}
}


BOOL CRegAnalyzer::AddKey(LPCTSTR RootKey, LPCTSTR SubKey, bool bExclude)
{
	CRegKey k;

	k.m_hKey = GetRootKey (RootKey);
    if (!k.m_hKey) {
        return FALSE;
    }
	
//	CStr root(RootKey);
	CStr subkey(SubKey);

	k.m_KeyName += RootKey;


	if (!(subkey == TEXT("")))
	{
		HKEY res;
		RegOpenKey(k.m_hKey, subkey, &res);

		k.m_hKey = res;	
		k.m_KeyName += TEXT("\\");
		k.m_KeyName += SubKey;
	}

	if (bExclude)
	{
		RegCloseKey(k.m_hKey);
		m_KeysToExclude.AddElement(k.m_KeyName);
	}
	else
		m_KeysToSave.AddElement(k);

    return TRUE;
}

BOOL CRegAnalyzer::SaveKeysToFile(
    IN      LPCTSTR FileName,
    IN      PFNSNAPSHOTPROGRESS ProgressCallback,
    IN      PVOID Context,
    IN      DWORD MaxLevels
    )
{
	CRegFile file;
    BOOL b = FALSE;

	if (file.Init(FileName))
	{
        DWORD nodesSoFar = 0;
		for (int i=0; i<m_KeysToSave.GetNumElementsStored(); i++)
		{
			if (!SaveKeyToFile(m_KeysToSave.Access()[i].m_hKey, 
						  m_KeysToSave.Access()[i].m_KeyName, 
                          &file, SECTION_NONE, &nodesSoFar, ProgressCallback, Context, MaxLevels)) {
                break;
            }
		}
        if (i == m_KeysToSave.GetNumElementsStored()) {
            b = TRUE;
        }
	}
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regdataitem.cpp ===
// RegDataItem.cpp: implementation of the CRegDataItem class.
//
//////////////////////////////////////////////////////////////////////

#include "RegDataItem.h"
#include "RegFile.h"
#include <tchar.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegDataItem::CRegDataItem()
: m_DataLen(0), m_NameLen(0), m_pDataBuf(NULL), m_Type(0),m_bIsEmpty(true),
m_bDontDeleteData(false)
{

}

CRegDataItem::~CRegDataItem()
{
	if (!m_bDontDeleteData)
		delete m_pDataBuf;

//	delete m_pName;
}

int CRegDataItem::CompareTo(const CRegDataItem &r)
{
	if ((m_bIsEmpty) && (r.m_bIsEmpty))
		return 0;
	else if ((m_bIsEmpty) && (!r.m_bIsEmpty))
		return 2;
	else if ((!m_bIsEmpty) && (r.m_bIsEmpty))
		return -1;
	else
	{
		int code = _tcscmp(m_Name, r.m_Name);

		if (code == 0) //names are the same, so compare item's data
		{
			if ((m_Type == r.m_Type) 
				&& (m_DataLen == r.m_DataLen)
				&& (memcmp(m_pDataBuf, r.m_pDataBuf, m_DataLen) == 0))
				return 0;
			else
				return 1;
				
		}
		else if (code > 0)
			return 2;
		else 
			return -1;
	}

}


LPTSTR GetCopy(LPCTSTR str)
{
	if (str == NULL)
		return NULL;

	int len = _tcsclen(str) + 1;
	LPTSTR temp = new TCHAR[len];
	
	if (temp == NULL)
	{
		LOG0(LOG_ERROR,"Couldn't allocate buffer in GetCopy(LPCTSTR)");
		return NULL;
	}	
	else
	{
		_tcscpy(temp, str);
		return temp;
	}

}

void CRegDataItem::WriteToInfFile(CRegFile &file, bool bWriteValueData)
{
	LPTSTR RootKeyName;
	LPTSTR SubKeyName;

	SplitString(m_KeyName, RootKeyName, SubKeyName, TEXT('\\'));
	
	file.WriteString(RootKeyName);

	file.WriteString(TEXT(","));
	file.WriteString(SubKeyName);

	delete[] RootKeyName;
	delete[] SubKeyName;


	if (m_Name != NULL)
	{	
		LPTSTR Name = GetQuotedString(m_Name);
		file.WriteString(TEXT(","));
		file.WriteString(Name);
		delete[] Name;

		if (bWriteValueData)
		{
			file.WriteString(TEXT(","));
			
			WriteDataString(file);
		}
	}
	
	file.WriteNewLine();
}	


LPTSTR CRegDataItem::GetQuotedString(LPCTSTR str)
{
	int i=0, specialchars=0;

	TCHAR quote = TEXT('\"');

	if (str == NULL)
		return NULL;

	while (str[i] != 0)
	{
		if (str[i] == quote)
			specialchars++;

		i++;		
	}

	LPTSTR temp = new TCHAR[i+specialchars+3];
	//include the chars of original string,
	//		  the escape characters needed for each specialchar
	//		  1 char for the NULL
	//		  2 chars for the quotes (") at the beginning and end of string
	
	int k=1;

	for (int j=0; j<i; j++)
	{
		if (str[j] == quote)
		{
			temp[k] = quote;
			k++;
		}

		temp[k] = str[j];
		k++;
	}

	temp[0] = quote;
	temp[k] = quote;
	temp[k+1] = NULL;

	return temp;
}

void CRegDataItem::SplitString(LPCTSTR source, LPTSTR& first, LPTSTR& last, TCHAR separator)
{
	LPTSTR str=GetCopy(source);

	if (str == NULL)
	{
		LOG0(LOG_ERROR, "Could not get copy of string in CRegDataItem::SplitString");
		return;
	}


	for (int i=0; str[i] != NULL; i++)
	{
		if (str[i] == separator)
			break;
	}

	if (str[i] == separator)
	{
		last = GetQuotedString(str+i+1);
		str[i]=NULL;
	}	
	else
	{
		str[i]=NULL;
		last = GetQuotedString(str+i);
	}
	

	first = GetQuotedString(str);

	delete[] str;
}



void CRegDataItem::WriteDataString(CRegFile& file)
{
	//10 chars - hex type string
	//1 char - comma
	//x chars - data string
	// case String - 

	DWORD InfCode = 1;
	LPTSTR DataString = NULL;
	TCHAR TypeStr[20];

	switch (m_Type)
	{
		case REG_BINARY:				InfCode = 0x00000001; 
										DataString=GetBinaryString(); break;

		case REG_DWORD:					InfCode = 0x00010001; 
										DataString = GetDwordString(); break;
	
	//	case REG_DWORD_BIG_ENDIAN:		break;

		case REG_EXPAND_SZ:				InfCode = 0x00020000;
										DataString=GetQuotedString((LPCTSTR)m_pDataBuf); break;

		case REG_MULTI_SZ:				WriteInfCode(file,0x00010000); 
										WriteMultiString(file); return;
		
		case REG_SZ:					InfCode = 0x00000000; 
										DataString=GetQuotedString((LPCTSTR)m_pDataBuf); break;

	//	case REG_LINK:					break;
	
		case REG_NONE:					InfCode = 0x00020001; 
										DataString = GetBinaryString(); break;

	//	case REG_QWORD:					break;
	//	case REG_RESOURCE_LIST:			break;

		default: 
			{
				//The code will contain the bits of m_Type in its highword, and
				//0x0001 in its low word.  This is how we specify a custom type
				//for an inf file.
				InfCode = m_Type;
				InfCode = InfCode << 16;
				InfCode +=1;

				DataString = GetBinaryString(); 
			}
			break;		
	};

	LPTSTR result;

	if (m_DataLen > 0)
	{
		int len = _tcsclen(DataString);

		result = new TCHAR[len + 20];

		_stprintf(result,TEXT("0x%08X,%s"), InfCode, DataString);
	}
	else
	{
		result = new TCHAR[20];		

		_stprintf(result,TEXT("0x%08X"), InfCode);
	}

	delete[] DataString;

	file.WriteString(result);

	delete[] result;
}

LPTSTR CRegDataItem::GetBinaryString()
{
	if (m_DataLen == 0)
		return NULL;

	int len = m_DataLen*3+1;

	LPTSTR result = new TCHAR[len];
	LPTSTR temp = result;

	for (DWORD i=0; i<m_DataLen; i++)
	{
		DWORD val = (DWORD)m_pDataBuf[i];
		_stprintf(temp,TEXT("%02X,"), val);
		temp+=3;
	}
	result[len-2]=NULL;

	return result;
	//return GetCopy("Binary String Data");
}

LPTSTR CRegDataItem::GetDwordString()
{
	LPTSTR result = new TCHAR[20];

	_stprintf(result,TEXT("0x%08X"), *((DWORD*)m_pDataBuf));

	return result;

}


void CRegDataItem::WriteMultiString(CRegFile& file)
{
	
/*	for (DWORD i=0; i <m_DataLen; i++)
	{
		if (m_pData[i] == NULL)
			NumBlanks++;
	}
*/
	if (m_DataLen == 1) //no multistrings - only one NULL character
		return file.WriteString(TEXT(",\"\""));
	else
	{

		LPTSTR buf = (LPTSTR)m_pDataBuf;

		while (true)
		{
			file.WriteString(TEXT(","));
			LPTSTR temp = GetQuotedString(buf);

			if (temp == NULL)
			{
				LOG0(LOG_ERROR, "Couldn't allocate quoted string in 'WriteMultiString'");
				return;
			}

			file.WriteString(temp);
			delete[] temp;

			while(*buf != NULL)
				buf++;

			if (*(buf+1) == NULL)
				break;
			else
				buf++;
		}
	}

/*	DWORD NumBlanks=0;

	for (DWORD i=0; i <m_DataLen; i++)
	{
		if (m_pData[i] == NULL)
			NumBlanks++;
	}

	if (NumBlanks == 1) //no multistrings - only one NULL character
		return GetQuotedString((LPCTSTR)m_pData);
	else
	{
		CSmartBuffer<LPTSTR> multi;

		LPCTSTR temp = (LPCTSTR)m_pData;
		multi.AddElement(GetQuotedString(temp));

		int memneeded=0;

		for (DWORD i=0; i <m_DataLen; i++)
		{
			if ((m_pData[i] == NULL) && (i < (m_DataLen-2)))
			{
				multi.AddElement(GetQuotedString((LPCTSTR)m_pData+i+1);
				memneeded += multi.
					
			}
		}
	}*/


}



void CRegDataItem::WriteInfCode(CRegFile &file, DWORD InfCode)
{
		TCHAR result[20];		

		_stprintf(result,TEXT("0x%08X"), InfCode);

		file.WriteString(result);
}


void CRegDataItem::WriteToFile(CRegFile &file)
{
	if (!m_bIsEmpty)
	{
		if (m_KeyName != NULL)
		{
			file.WriteString(m_KeyName);
			file.WriteNewLine();
		}

		if (m_Name != NULL) //this data item contains a registry data value
		{
			TCHAR t;

			switch(m_Type)
			{
			case REG_BINARY:				t=L'B'; break;

			case REG_DWORD:					t=L'd'; break;
			case REG_DWORD_BIG_ENDIAN:		t=L'D'; break;

			case REG_EXPAND_SZ:				t=L'E'; break;
			case REG_MULTI_SZ:				t=L'M'; break;
			case REG_SZ:					t=L'S'; break;

			case REG_LINK:					t=L'L'; break;
			case REG_NONE:					t=L'N'; break;
			case REG_QWORD:					t=L'Q'; break;
			case REG_RESOURCE_LIST:			t=L'R'; break;

			default: t=L'Z'; break; //unknown type! it does occur in the registry! HKLM
			};


			int NameLen = _tcsclen(m_Name);
			TCHAR* temp = new TCHAR[NameLen+100];

			_stprintf(temp, TEXT("S%u:%s = %c(%u)%u:"), NameLen, (LPCTSTR)m_Name, t, m_Type, m_DataLen);

			file.WriteString(temp);

			delete [] temp;

//unicode	***********************************			
			if ((m_DataLen %2) != 0)
			{
				BYTE nullByte=0;
				file.WriteData(&nullByte, 1);
			}
//			***********************************
			
			file.WriteData(m_pDataBuf, m_DataLen);
			file.WriteNewLine();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regfile.h ===
// RegFile.h: interface for the CRegFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGFILE_H__1D242B07_3CC1_43C4_9D23_A070EB6C286E__INCLUDED_)
#define AFX_REGFILE_H__1D242B07_3CC1_43C4_9D23_A070EB6C286E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SmartBuffer.h"
#include "RegDataItem.h"	// Added by ClassView

enum SectionType
{
	SECTION_ADDREG,
	SECTION_DELREG,
	SECTION_NONE
};

class CRegFile  
{
public:
	virtual bool NeedStorageOfValueData();

	CRegFile();
	virtual ~CRegFile();

	bool Init(LPCTSTR FileName, BOOL ForReading=FALSE);
	
	TCHAR PeekNextChar();
	LPCTSTR GetNextLine();
	LPCTSTR GetNextSubKey(LPCTSTR KeyName);
	virtual CRegDataItemPtr GetNextDataItem();

	void WriteString(LPCTSTR str);
	void WriteData(LPBYTE pData, DWORD NumBytes);
	void WriteNewLine();

	virtual void WriteDataItem(enum SectionType t, CRegDataItemPtr r);

protected:
	FILE* m_pFile;
	LPCTSTR m_pTempLine;

	CSmartBuffer<TCHAR*> m_TempNameBuf;
};

#endif // !defined(AFX_REGFILE_H__1D242B07_3CC1_43C4_9D23_A070EB6C286E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\reganalyzer.h ===
// RegAnalyzer.h: interface for the RegAnalyzer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGANALYZER_H__655EE78C_3742_4D24_BB60_C92B55676851__INCLUDED_)
#define AFX_REGANALYZER_H__655EE78C_3742_4D24_BB60_C92B55676851__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"

#include "RegStringBuffer.h"
#include "RegFile.h"
#include "SmartBuffer.h"
#include "Str.h"

class CRegDiffFile;

class CRegAnalyzer  
{
public:

	CRegAnalyzer();
	virtual ~CRegAnalyzer();

	bool ComputeDifferences1(LPCTSTR RegFile1, LPCTSTR RegFile2, LPCTSTR OutputFile);


	//Saving Registry Hives
	BOOL AddKey(LPCTSTR RootKey, LPCTSTR SubKey, bool bExclude = false);
	BOOL SaveKeysToFile(LPCTSTR FileName, PFNSNAPSHOTPROGRESS ProgressCallback, PVOID Context, DWORD MaxLevels);

protected:

	//Computing Differences
	void CompareSubKeys(LPCTSTR Key, CRegFile& f1, CRegFile& f2, CRegDiffFile& out);
	int CompareRegKeys(LPCTSTR Key1, LPCTSTR Key2, CRegFile& f1, CRegFile& f2, CRegDiffFile& out);
	void CompareDataItems(LPCTSTR KeyName, CRegFile& f1, CRegFile& f2, CRegDiffFile& out);

	//Saving Registry Hives
	bool SaveKeyToFile(HKEY hKey, LPCTSTR KeyName, CRegFile* RegFile, SectionType section,
            IN OUT  PDWORD NodesSoFar = NULL,          OPTIONAL
            IN      PFNSNAPSHOTPROGRESS ProgressCallback = NULL,
            IN      PVOID Context = NULL,
            IN      INT MaxLevels = 0
            );
	bool SaveValuesToFile(HKEY hKey, LPCTSTR KeyName, CRegFile* RegFile, SectionType section);

	CRegStringBuffer m_SA;
	CSmartBuffer<BYTE> m_pData;
	CSmartBuffer<TCHAR> m_pOutputLine;

	struct CRegKey
	{
		CStr m_KeyName;
		HKEY m_hKey;
	};

	friend class CRegistry;
	
	CSmartBuffer<CRegKey> m_KeysToSave;
	CSmartBuffer<CStr> m_KeysToExclude;
};

#endif // !defined(AFX_REGANALYZER_H__655EE78C_3742_4D24_BB60_C92B55676851__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regdataitem.h ===
// RegDataItem.h: interface for the CRegDataItem class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGDATAITEM_H__741AB6DD_2F0A_4B35_9E1C_CF035916ABFC__INCLUDED_)
#define AFX_REGDATAITEM_H__741AB6DD_2F0A_4B35_9E1C_CF035916ABFC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "counted_ptr.h"
#include "str.h"

class CRegFile;

class CRegDataItem  
{
public:
	void WriteToFile(CRegFile& file);
	void WriteInfCode(CRegFile& file, DWORD InfCode);
	void WriteMultiString(CRegFile& file);
	LPTSTR GetDwordString();
	LPTSTR GetBinaryString();
	void WriteDataString(CRegFile& file);
	void SplitString(LPCTSTR str, LPTSTR& first, LPTSTR& last, TCHAR separator);

	void WriteToInfFile(CRegFile& file, bool bWriteValueData);
	int CompareTo(const CRegDataItem& r);
	LPTSTR GetQuotedString(LPCTSTR str);
	CRegDataItem();
	virtual ~CRegDataItem();

	CStr m_KeyName;
	CStr m_Name;
	LPBYTE m_pDataBuf;
	DWORD m_DataLen, m_NameLen;
	DWORD m_Type;
	bool m_bIsEmpty, m_bDontDeleteData;
};


class CRegDataItemPtr : public counted_ptr<CRegDataItem>
{
public:
	CRegDataItemPtr(CRegDataItem* X=NULL)
	: counted_ptr<CRegDataItem>(X)
	{}

}; 


LPTSTR GetCopy(LPCTSTR str);


#endif // !defined(AFX_REGDATAITEM_H__741AB6DD_2F0A_4B35_9E1C_CF035916ABFC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\reginfentry.cpp ===
// RegInfEntry.cpp: implementation of the CRegInfEntry class.
//
//////////////////////////////////////////////////////////////////////

#include "RegInfEntry.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegInfEntry::CRegInfEntry()
{

}

CRegInfEntry::~CRegInfEntry()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regdifffile.cpp ===
// RegDiffFile.cpp: implementation of the CRegDiffFile class.
//
//////////////////////////////////////////////////////////////////////

#include "RegDiffFile.h"
#include "Registry.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegDiffFile::CRegDiffFile()
: m_AddSection(1), m_DelSection(1)
{

}

CRegDiffFile::~CRegDiffFile()
{

}

void CRegDiffFile::WriteDataItem(enum SectionType t, CRegDataItemPtr r)
{
	switch (t)
	{
	case SECTION_ADDREG: m_AddSection.AddElement(r); break;
	case SECTION_DELREG: m_DelSection.AddElement(r); break;
	}
}


#define DIFF_VERSION_STR  TEXT("[RegDiff 1.0]")
#define DIFF_ADD_STR TEXT("[AddReg]")
#define DIFF_DEL_STR TEXT("[DelReg]")

void CRegDiffFile::WriteStoredSectionsToFile()
{
	WriteString(DIFF_VERSION_STR);
	WriteNewLine();

	WriteString(DIFF_ADD_STR);
	WriteNewLine();

	for (int i=0; i<m_AddSection.GetNumElementsStored(); i++)
	{
		(m_AddSection.Access()[i])->WriteToFile(*this);
	}

	WriteString(DIFF_DEL_STR);
	WriteNewLine();

	CStr DelKey=L"NO WAY", CurrentKey;

	for (i=0; i<m_DelSection.GetNumElementsStored(); i++)
	{
		CurrentKey = (m_DelSection.Access()[i])->m_KeyName;
		
		if (!CurrentKey.IsPrefix(DelKey))
		{
			(m_DelSection.Access()[i])->WriteToFile(*this);
			DelKey = CurrentKey;
		}
	}
}


//BUGBUG memory leaks here
BOOL CRegDiffFile::ApplyToRegistry(LPCTSTR UndoFileName)
{
	CRegDiffFile UndoFile;

	if (UndoFileName != NULL)
	{
		UndoFile.Init(UndoFileName);
	}

	LPCTSTR VersionStr = GetNextLine();
	if (_tcscmp(VersionStr, DIFF_VERSION_STR) != 0)
	{
		delete[] VersionStr;
		return FALSE;//error - version string does not match!
	}

	LPCTSTR AddStr = GetNextLine();
	if (_tcscmp(AddStr, DIFF_ADD_STR) != 0)
	{
		delete[] AddStr;
		return FALSE;//error - version string does not match!
	}

	//Currently in the Add Section
	while (PeekNextChar() != TEXT('['))
	{
		LPCTSTR KeyName = GetNextLine();

		CRegDataItemPtr pDataItem = GetNextDataItem();

		pDataItem->m_KeyName = KeyName;

		AddToRegistry(pDataItem, UndoFile);
	}


	LPCTSTR DelStr = GetNextLine();
	if (_tcscmp(DelStr, DIFF_DEL_STR) != 0)
	{
		delete[] DelStr;
		return FALSE;//error - version string does not match!
	}


	TCHAR c;

	//Currently in the Delete Section
	while (((c = PeekNextChar()) != EOF)
		&& (c != WEOF))
	{
		LPCTSTR KeyName = GetNextLine();

		CRegDataItemPtr pDataItem = GetNextDataItem();

		pDataItem->m_KeyName = KeyName;

		DeleteFromRegistry(pDataItem, UndoFile);
	}

	UndoFile.WriteStoredSectionsToFile();
	delete[] VersionStr; delete[] AddStr; delete[] DelStr;
    return TRUE;
}



void CRegDiffFile::AddToRegistry(CRegDataItemPtr pDataItem, CRegDiffFile &UndoFile)
{

	CRegistry reg;


	if (pDataItem->m_KeyName != NULL)
	{
		pDataItem->m_bIsEmpty = false;

		if (pDataItem->m_Name == NULL)
		{
			//Adding just a registry key
			if (reg.KeyExists(pDataItem))
			{
				//no action
			}
			else
			{
				//key doesn't exist, so we will delete it on undo
				UndoFile.WriteDataItem(SECTION_DELREG, pDataItem);

				reg.AddKey(pDataItem);
			}
		}
		else
		{
			//Adding a data item

			int code = reg.ValueExists(pDataItem);

			if (code == 2) //value name exists, and data,type are the same			
			{
				//no action
			}
			else if (code == 1) //value name exists, but data or type are different
			{
				CRegDataItemPtr oldval = reg.GetValue(pDataItem);
				
				UndoFile.WriteDataItem(SECTION_ADDREG, oldval);

				reg.AddValue(pDataItem);								
			}
			else //code ==0, value name doesn't exist
			{
				UndoFile.WriteDataItem(SECTION_DELREG, pDataItem);

				reg.AddValue(pDataItem);
			}
		}
	}
}


void CRegDiffFile::DeleteFromRegistry(CRegDataItemPtr pDataItem, CRegDiffFile &UndoFile)
{
	CRegistry reg;


	if (pDataItem->m_KeyName != NULL)
	{
		if (pDataItem->m_Name == NULL)
		{
			//Deleting a registry key
			if (reg.KeyExists(pDataItem))
			{
				reg.SaveKey(pDataItem, UndoFile, SECTION_ADDREG);  //better def needed

				reg.DeleteKey(pDataItem);
			}
			else
			{
				//no action
			}
		}
		else
		{
			//Deleting a data item

			if(reg.ValueExists(pDataItem))
			{
				CRegDataItemPtr oldval = reg.GetValue(pDataItem);
				
				UndoFile.WriteDataItem(SECTION_ADDREG, oldval);

				reg.DeleteValue(pDataItem);
			}
			else //code ==0, value name doesn't exist
			{
				//no action
			}
		}
	}
}

bool CRegDiffFile::NeedStorageOfValueData()
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regfile.cpp ===
// RegFile.cpp: implementation of the CRegFile class.
//
//////////////////////////////////////////////////////////////////////

#include "RegFile.h"
#include <tchar.h>
#include <stdio.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegFile::CRegFile()
: m_pFile(NULL), m_pTempLine(NULL), m_TempNameBuf(256)
{

}

CRegFile::~CRegFile()
{
	if (m_pFile != NULL)
		fclose(m_pFile);

	for (int i=0; i < m_TempNameBuf.GetNumElementsStored(); i++)
	{
		delete m_TempNameBuf.Access()[i];
	}

//	m_TempName.OverideBuffer(NULL);
}


void CRegFile::WriteString(LPCTSTR str)
{
//	DWORD bw;
//	WriteFile(m_hFile, str, _tcsclen(str)*sizeof(TCHAR), &bw, NULL);

	if (m_pFile == NULL)
		return;

	fwrite(str,sizeof(TCHAR),_tcsclen(str),m_pFile);
}

void CRegFile::WriteData(LPBYTE pData, DWORD NumBytes)
{
//	DWORD bw;
//	WriteFile(m_hFile, pData, NumBytes, &bw, NULL);

	if (m_pFile == NULL)
		return;

	fwrite(pData,sizeof(BYTE),NumBytes,m_pFile);
}

void CRegFile::WriteNewLine()
{
	//TCHAR nl[] = {13,10,0};
	
	WriteString(TEXT("\r\n"));
}

bool CRegFile::Init(LPCTSTR FileName, BOOL bForReading)
{
/*	m_hFile = CreateFile(FileName, 
						GENERIC_WRITE, 0, NULL, 
						CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);

	return (m_hFile != INVALID_HANDLE_VALUE);*/


    CHAR signature[4] = "\xFF\xFE";
    CHAR buffer[4];
    DWORD rc;

	if(bForReading)
	{
		m_pFile = _tfopen(FileName, TEXT("rb"));
        if (m_pFile) {
            if (fread (buffer, 1, 2, m_pFile) < 2) {
                rc = GetLastError ();
                fclose (m_pFile);
                m_pFile = NULL;
            }
        }
	}
	else
	{
		m_pFile = _tfopen(FileName, TEXT("wb"));
        if (m_pFile) {
            if (fwrite (signature, 1, 2, m_pFile) < 2) {
                rc = GetLastError ();
                fclose (m_pFile);
                m_pFile = NULL;
            }
        }
	}

    if (m_pFile == NULL) {
        SetLastError (rc);
    }

	return (m_pFile != NULL);
}


LPCTSTR CRegFile::GetNextLine()
{
	if (m_pFile == NULL)
		return NULL;


	LPTSTR result;
	
	if (m_pTempLine != NULL)
	{
		result = (LPTSTR)m_pTempLine;
		m_pTempLine = NULL;

		return (LPCTSTR)result;
	}


	result = new TCHAR[1024];

	if (result == NULL)
	{
		LOG0(LOG_ERROR, "Could not allocate array in CRegFile::GetNextLine()");
		//ASSERT(0);
		return NULL;
	}


	LPTSTR code = _fgetts(result, 1024, m_pFile);

	if (code == NULL)
	{
		delete[] result;
		return NULL;
	}
	else
	{
		//UNICODE HERE???
		int pos = _tcsclen(result);
		result[pos-2] = NULL;
		return result;
	}
}



LPCTSTR CRegFile::GetNextSubKey(LPCTSTR KeyName)
{
	if (m_pFile == NULL)
		return NULL;
	
	
	LPCTSTR SubKey;
	int keyLen = _tcsclen(KeyName);

//	long oldPos;
//	oldPos = GetPos();

	if (m_pTempLine == NULL)
	{
		SubKey = GetNextLine();
	}
	else
	{
		SubKey = m_pTempLine;
		m_pTempLine = NULL;
	}

	if (SubKey != NULL)
	{
		if (_tcsncmp(KeyName, SubKey, keyLen) != 0)
		{
			//delete SubKey;
			//SeekToPos(oldPos);
			m_pTempLine = SubKey;

			//put SubKey back on the stream, since it
			//is no longer a sub key of Key.
		}
		else
		{
			return SubKey;
		}
	}

	return NULL;
}

//for unicode
#define ERR_VALUE WEOF


CRegDataItemPtr CRegFile::GetNextDataItem()
{
	if (m_pFile == NULL)
		return new CRegDataItem();


	TCHAR c = (TCHAR)_fgettc(m_pFile);

	if ((c == EOF) || (c == WEOF))
		return new CRegDataItem();

	if (c != TEXT('S'))
	{
		_ungettc(c, m_pFile);
		return new CRegDataItem(); //no data item - only reg key on the current line
	}


	CRegDataItem* result = new CRegDataItem;

	if (!result)
	{
		LOG0(LOG_ERROR,"Could not allocate CRegDataItem");
		return NULL;
	}
		
	TCHAR type;

	//Scan in the length of the variable name
	if (_ftscanf(m_pFile, TEXT("%u:"), &result->m_NameLen) == ERR_VALUE)
	{
		delete result;
		LOG0(LOG_ERROR,"CRegDataItem - could not read result->m_NameLen");
		return new CRegDataItem();
	}

	result->m_NameLen++;  //names of variables always forget the blank at end
	
	//may be introducing memory leak here!
	//***********************************

/*	//Scan in the variable name
	CStr name(new TCHAR[result->m_NameLen+1]);

	_fgetts(name.get(), result->m_NameLen, m_pFile);

	result->m_Name = name;
	//************************************
*/

	//Scan in the variable name


	TCHAR* temp = new TCHAR[result->m_NameLen+1];

	if(_fgetts(temp, result->m_NameLen, m_pFile) == NULL)
	{
		delete result;
		LOG0(LOG_ERROR,"CRegDataItem - could not read result->m_Name");
		return new CRegDataItem();
	}

	result->m_Name = temp;

	m_TempNameBuf.AddElement(temp);

	//delete[] temp;


	//************************************
/*	m_TempNameBuf.Allocate(result->m_NameLen+1);

	_fgetts(m_TempNameBuf.Access(), result->m_NameLen, m_pFile);

	m_TempName.OverideBuffer(m_TempNameBuf.Access());

	result->m_Name = m_TempName;
*/
	


	//Scan in the type of variable and the length of its data
	if (_ftscanf(m_pFile, TEXT(" = %c(%u)%u:"), &type, &result->m_Type, &result->m_DataLen)
		== ERR_VALUE)
	{
		delete result;
		LOG0(LOG_ERROR,"CRegDataItem - could not scan in other data values");
		return new CRegDataItem();
	}

	//read in the null byte (for unicode compatibility, can't have odd # of bytes)
	if ((result->m_DataLen % 2) != 0)
	{
		BYTE nullByte;
		if (fread(&nullByte,1,1,m_pFile)==0)
		{
			delete result;
			LOG0(LOG_ERROR,"CRegDataItem - could not read null byte");
			return new CRegDataItem();
		}
	}

	result->m_bIsEmpty = false;

	if (result->m_DataLen > 0)
	{
		result->m_pDataBuf = new BYTE[result->m_DataLen];
		if (fread(result->m_pDataBuf,result->m_DataLen,1,m_pFile) ==0)
		{
			delete result;
			LOG0(LOG_ERROR,"CRegDataItem - could not read null byte");
			return new CRegDataItem();
		}
	}
	else
	{
		result->m_pDataBuf =NULL;
	}

	//read in cr/lf
	c = (TCHAR)_fgettc(m_pFile);

	if (c != 13)
	{LOG0(LOG_ERROR,"CRegDataItem - could not read char 13");}

	c = (TCHAR)_fgettc(m_pFile);

	if (c != 10)
	{LOG0(LOG_ERROR,"CRegDataItem - could not read char 10");}
	
	return result;
}




TCHAR CRegFile::PeekNextChar()
{
	TCHAR c = (TCHAR)_fgettc(m_pFile);
	_ungettc(c, m_pFile);

	return c;
}

void CRegFile::WriteDataItem(enum SectionType t, CRegDataItemPtr r)
{
	//ignore section type

	if (!r->m_Name.IsEmpty())
		r->m_KeyName = NULL;

	r->WriteToFile(*this);
}

bool CRegFile::NeedStorageOfValueData()
{
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regdifffile.h ===
// RegDiffFile.h: interface for the CRegDiffFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGDIFFFILE_H__898750DA_897E_4F8A_BD51_899EC068C300__INCLUDED_)
#define AFX_REGDIFFFILE_H__898750DA_897E_4F8A_BD51_899EC068C300__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "RegFile.h"

class CRegDiffFile : public CRegFile  
{
public:
	virtual bool NeedStorageOfValueData();
	void DeleteFromRegistry(CRegDataItemPtr pDataItem, CRegDiffFile& UndoFile);
	void AddToRegistry(CRegDataItemPtr pDataItem, CRegDiffFile& UndoFile);
	BOOL ApplyToRegistry(LPCTSTR UndoFileName = NULL);
	CRegDiffFile();
	virtual ~CRegDiffFile();

	virtual void WriteDataItem(enum SectionType t, CRegDataItemPtr r);

	virtual void WriteStoredSectionsToFile();


protected:
	CSmartBuffer<CRegDataItemPtr> m_AddSection;
	CSmartBuffer<CRegDataItemPtr> m_DelSection;
};

#endif // !defined(AFX_REGDIFFFILE_H__898750DA_897E_4F8A_BD51_899EC068C300__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\reginffile.h ===
// RegInfFile.h: interface for the CRegInfFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGINFFILE_H__DB5A2390_991F_4D9F_800A_5B93CC9B5135__INCLUDED_)
#define AFX_REGINFFILE_H__DB5A2390_991F_4D9F_800A_5B93CC9B5135__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "RegDiffFile.h"

class CRegInfFile : public CRegDiffFile  
{
public:
	CRegInfFile();
	virtual ~CRegInfFile();

	virtual void WriteStoredSectionsToFile();

};

#endif // !defined(AFX_REGINFFILE_H__DB5A2390_991F_4D9F_800A_5B93CC9B5135__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regstringbuffer.h ===
// RegStringArray.h: interface for the CRegStringArray class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGSTRINGARRAY_H__BBA3E398_DEFE_49DE_9674_D25E0687BCB8__INCLUDED_)
#define AFX_REGSTRINGARRAY_H__BBA3E398_DEFE_49DE_9674_D25E0687BCB8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <tchar.h>
#include "RegFile.h"	// Added by ClassView

class CRegStringBuffer  
{
public:
	void Sort(int NumElements);
	TCHAR** Access(int NumElements, int ElementSize);
	CRegStringBuffer(int arraySize, int elementSize);
	virtual ~CRegStringBuffer();

	TCHAR** GetDirect() {return m_Array;}


protected:
	TCHAR** m_Array;
	int m_arraySize, m_elementSize;
	int m_cellsUsed;
};

#endif // !defined(AFX_REGSTRINGARRAY_H__BBA3E398_DEFE_49DE_9674_D25E0687BCB8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\reginffile.cpp ===
// RegInfFile.cpp: implementation of the CRegInfFile class.
//
//////////////////////////////////////////////////////////////////////

#include "RegInfFile.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegInfFile::CRegInfFile()
{

}

CRegInfFile::~CRegInfFile()
{

}

void CRegInfFile::WriteStoredSectionsToFile()
{
	WriteString(TEXT("[Version]\r\n") 
				TEXT("Signature = \"$Windows NT$\"\r\n\r\n")
				TEXT("[DefaultInstall]\r\n")
				TEXT("AddReg=AddReg1\r\n")
				TEXT("DelReg=DelReg1\r\n\r\n"));

	WriteString(TEXT("[AddReg1]\r\n"));

	for (int i=0; i<m_AddSection.GetNumElementsStored(); i++)
	{
		(m_AddSection.Access()[i])->WriteToInfFile(*this, true);
	}

	WriteString(TEXT("\r\n[DelReg1]\r\n"));

	for (i=0; i<m_DelSection.GetNumElementsStored(); i++)
	{
		(m_DelSection.Access()[i])->WriteToInfFile(*this, false);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\registry.h ===
// Registry.h: interface for the CRegistry class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGISTRY_H__09E5ED27_DD94_4287_9B5B_5DBF9D182B06__INCLUDED_)
#define AFX_REGISTRY_H__09E5ED27_DD94_4287_9B5B_5DBF9D182B06__INCLUDED_

#include "RegDataItem.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "RegAnalyzer.h"

class CRegDiffFile;
enum SectionType;

enum ValueExistsCode
{
	VALUE_DOESNT_EXIST=0,
	VALUE_EXISTS_DIFF_DATA,
	VALUE_EXISTS_SAME_DATA
};

class CRegistry  
{
public:
	static bool DecodeRootKeyStr(LPCTSTR RootKeyName, PHKEY pRootKey);
	CRegDataItemPtr GetValue(CRegDataItemPtr pItem);
	bool DeleteValue(CRegDataItemPtr pItem);
	bool DeleteKey(CRegDataItemPtr pItem);
	bool SaveKey(CRegDataItemPtr pItem, CRegDiffFile& file, SectionType section);
	bool AddValue(CRegDataItemPtr pItem);
	ValueExistsCode ValueExists(CRegDataItemPtr pItem);
	bool AddKey(CRegDataItemPtr pItem);
	bool KeyExists(CRegDataItemPtr pItem);
	CRegistry();
	virtual ~CRegistry();

protected:
	bool OpenKey(CRegDataItemPtr pItem, PHKEY pKey);
	CRegAnalyzer m_RegAnalyzer;
};

#endif // !defined(AFX_REGISTRY_H__09E5ED27_DD94_4287_9B5B_5DBF9D182B06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\reginfentry.h ===
// RegInfEntry.h: interface for the CRegInfEntry class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_REGINFENTRY_H__0FD129AE_0503_4265_B3F6_BCD2C4F738FE__INCLUDED_)
#define AFX_REGINFENTRY_H__0FD129AE_0503_4265_B3F6_BCD2C4F738FE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CRegInfEntry  
{
public:
	CRegInfEntry();
	virtual ~CRegInfEntry();

	TCHAR m_RootName[4];
	LPCTSTR m_SubKeyName;
	LPCTSTR m_ValueName;
	DWORD m_ValueType;


	


};

#endif // !defined(AFX_REGINFENTRY_H__0FD129AE_0503_4265_B3F6_BCD2C4F738FE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\registry.cpp ===
// Registry.cpp: implementation of the CRegistry class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#include "Registry.h"
#include "Shlwapi.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegistry::CRegistry()
{

}

CRegistry::~CRegistry()
{

}



bool CRegistry::KeyExists(CRegDataItemPtr pItem)
{
	HKEY temp;

	if (OpenKey(pItem, &temp))
	{
		RegCloseKey(temp);
		return true;		
	}
	else
		return false;
}

bool CRegistry::AddKey(CRegDataItemPtr pItem)
{
	CStr root, subkey;

	pItem->m_KeyName.SplitString(root, subkey, L'\\');
	//don't need to worry about creating multiple nested subkeys,
	//since RegCreateKeyEx handles this for us.

	HKEY rootKey, result;

	if (DecodeRootKeyStr(root, &rootKey))
	{
		if (ERROR_SUCCESS == 
			RegCreateKeyEx(rootKey, subkey, 0, 0, REG_OPTION_NON_VOLATILE,0,0,&result,0))
		{
			RegCloseKey(result);
			return true;		
		}
	}

	return false;
}


ValueExistsCode CRegistry::ValueExists(CRegDataItemPtr pItem)
{
	CRegDataItemPtr temp = GetValue(pItem);

	if (!temp.IsNull()) //value does exist
	{
		if ((temp->m_Type == pItem->m_Type)
			&& (temp->m_DataLen == pItem->m_DataLen)
			&& (memcmp(temp->m_pDataBuf, pItem->m_pDataBuf, temp->m_DataLen) == 0))
		{
			//value has the same data
			return VALUE_EXISTS_SAME_DATA;
		}

		//value exists, but with different data
		return VALUE_EXISTS_DIFF_DATA;
	}

	//value doesn't exist
	return VALUE_DOESNT_EXIST;
}


bool CRegistry::AddValue(CRegDataItemPtr pItem)
{
	HKEY temp = 0;
	bool result = false;

	if (OpenKey(pItem, &temp))
	{
		if (RegSetValueEx(temp, pItem->m_Name,0,pItem->m_Type,pItem->m_pDataBuf,pItem->m_DataLen)
			== ERROR_SUCCESS)
			result = true;

		RegCloseKey(temp);
	}

	return result;
}

bool CRegistry::SaveKey(CRegDataItemPtr pItem, CRegDiffFile &file, SectionType section)
{
	bool result = false;
	HKEY temp;

	if (OpenKey(pItem, &temp))
	{
		m_RegAnalyzer.SaveKeyToFile(temp, pItem->m_KeyName, (CRegFile*)&file, section);
		return true;
	}

	return false;
}

bool CRegistry::DeleteKey(CRegDataItemPtr pItem)
{
	//recursively delete the key

	CStr RootKeyName;
	CStr SubKeyName;

	pItem->m_KeyName.SplitString(RootKeyName, SubKeyName, TEXT('\\'));
	
	HKEY rootKey;
	DecodeRootKeyStr(RootKeyName, &rootKey);

	if (ERROR_SUCCESS == SHDeleteKey(rootKey,SubKeyName))
	{
		return true;
	}

	return false;
}

bool CRegistry::DeleteValue(CRegDataItemPtr pItem)
{	
	HKEY temp = 0;
	bool result = false;

	if (OpenKey(pItem, &temp))
	{
		if (RegDeleteValue(temp, pItem->m_Name)
			== ERROR_SUCCESS)
			result = true;

		RegCloseKey(temp);
	}
	
	return result;
}

CRegDataItemPtr CRegistry::GetValue(CRegDataItemPtr pItem)
{
	HKEY temp = 0;

	if (OpenKey(pItem, &temp))
	{
		DWORD nameLen, valueLen;
		CRegDataItemPtr result(new CRegDataItem);

		if (RegQueryInfoKey(temp,0,0,0,0,0,0,0,&nameLen,&valueLen,0,0) == ERROR_SUCCESS)
		{
			result->m_KeyName = pItem->m_KeyName;
			result->m_Name = pItem->m_Name;
			result->m_NameLen = pItem->m_NameLen;
			
			BYTE*  pValue = new BYTE[valueLen];
			TCHAR* pName = new TCHAR[nameLen];

			if (RegQueryValueEx(temp, result->m_Name,0,&result->m_Type,pValue,&valueLen)
				== ERROR_SUCCESS)
			{
				result->m_pDataBuf = pValue;
				result->m_DataLen = valueLen;
				result->m_bIsEmpty = false;

				RegCloseKey(temp);
				return result;
			}
		}
		
		RegCloseKey(temp);
	}
	
	return CRegDataItemPtr();
}

bool CRegistry::OpenKey(CRegDataItemPtr pItem, PHKEY pKey)
{
	CStr RootKeyName;
	CStr SubKeyName;

	pItem->m_KeyName.SplitString(RootKeyName, SubKeyName, TEXT('\\'));
	
	HKEY rootKey;
	DecodeRootKeyStr(RootKeyName, &rootKey);

	if (ERROR_SUCCESS == RegOpenKeyEx(rootKey, SubKeyName, 0, KEY_ALL_ACCESS, pKey))
	{	
		return true;
	}
	else
	{
		return false;
	}
}

bool CRegistry::DecodeRootKeyStr(LPCTSTR RootKeyName, PHKEY pRootKey)
{
	*pRootKey = GetRootKey (RootKeyName);
    return *pRootKey != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\smartbuffer.cpp ===
// SmartBuffer.cpp: implementation of the CSmartBuffer class.
//
//////////////////////////////////////////////////////////////////////

#include "SmartBuffer.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\regstringbuffer.cpp ===
// RegStringArray.cpp: implementation of the CRegStringBuffer class.
//
//////////////////////////////////////////////////////////////////////

#include "RegStringBuffer.h"

#include <stdlib.h>


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegStringBuffer::CRegStringBuffer(int arraySize, int elementSize)
: m_arraySize(arraySize), m_elementSize(elementSize), m_cellsUsed(0)
{
	m_Array = new TCHAR*[arraySize];

	if (m_Array == NULL)
	{
		LOG0(LOG_ERROR, "Couldn't allocate CRegStringBuffer");
	}
	else
	{
		for (int i=0; i<arraySize; i++)
		{
			m_Array[i] = new TCHAR[elementSize];
		
			if (m_Array[i] == NULL)
			{
				LOG0(LOG_ERROR, "Couldn't allocate CRegStringBuffer");
				break;
			}
		}
	}
}

CRegStringBuffer::~CRegStringBuffer()
{
	for (int i=0; i<m_arraySize; i++)
	{
		delete[] m_Array[i];
	}

	delete[] m_Array;
}


int mMax(int a, int b)
{
	if (a > b)
		return a;
	else
		return b;
}


TCHAR** CRegStringBuffer::Access(int NumElements, int ElementSize)
{
	if ((NumElements > m_arraySize)
		|| (ElementSize > m_elementSize))
	{
		//delete the data structure
		for (int i=0; i<m_arraySize; i++)
		{
			delete[] m_Array[i];
		}

		delete[] m_Array;

		//assign new larger dimensions
		m_arraySize = mMax(m_arraySize, NumElements);
		m_elementSize = mMax(m_elementSize, ElementSize);

		//reallocate the array
		/*m_Array = new TCHAR*[m_arraySize];

		for (int i=0; i<m_arraySize; i++)
		{
			m_Array[i] = new TCHAR[m_elementSize];
		}*/

		m_Array = new TCHAR*[m_arraySize];

		if (m_Array == NULL)
		{
			LOG0(LOG_ERROR, "Couldn't allocate CRegStringBuffer");
		}
		else
		{
			for (int i=0; i<m_arraySize; i++)
			{
				m_Array[i] = new TCHAR[m_elementSize];
			
				if (m_Array[i] == NULL)
				{
					LOG0(LOG_ERROR, "Couldn't allocate CRegStringBuffer");
					break;
				}
			}
		}
	}

	return m_Array;
}



int __cdecl compare( const void *arg1, const void *arg2 )
{
   /* Compare all of both strings: */
   return _tcscmp( * ( TCHAR** ) arg1, * ( TCHAR** ) arg2 );
}

void CRegStringBuffer::Sort(int NumElements)
{
	qsort( (void *)m_Array, NumElements, sizeof(TCHAR*), compare );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\smartbuffer.h ===
// SmartBuffer.h: interface for the CSmartBuffer class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SMARTBUFFER_H__47C64F5D_8388_452B_864B_1F55D6AE6F17__INCLUDED_)
#define AFX_SMARTBUFFER_H__47C64F5D_8388_452B_864B_1F55D6AE6F17__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template<class T> class CSmartBuffer 
{
public:
	CSmartBuffer(int NumElements);
	virtual ~CSmartBuffer();

	T* Allocate(int SizeNeeded);
	T* Access()
	{return m_Array;}

	void AddElement(T elem);
	int GetNumElementsStored()
	{return m_NumElementsUsed;}

	void SetNumElementsStored(int x)
	{m_NumElementsUsed = x;}

	bool FindElement(T elem);

protected:
	T* m_Array;
	int m_NumElements;
	int m_NumElementsUsed;

};

template <class T>
CSmartBuffer<T>::CSmartBuffer(int NumElements)
:m_NumElements(NumElements), m_NumElementsUsed(0)
{
	if (NumElements > 0)
		m_Array = new T[NumElements];
	else
		m_Array = 0;
}

template <class T>
CSmartBuffer<T>::~CSmartBuffer()
{
	delete[] m_Array;
}


template <class T>
T* CSmartBuffer<T>::Allocate(int SizeNeeded)
{
	if (SizeNeeded > m_NumElements)
	{
		m_NumElements = SizeNeeded;

		delete[] m_Array;

		m_Array = new T[m_NumElements];
	}

	return m_Array;
}


template <class T>
void CSmartBuffer<T>::AddElement(T elem)
{
	m_NumElementsUsed++;

	if (m_NumElementsUsed > m_NumElements)
	{
		T* temp = new T[m_NumElements*2];

		for (int i=0; i<m_NumElements; i++)
		{
			temp[i] = m_Array[i];
		}

		delete[] m_Array;
		m_Array = temp;
		m_NumElements = m_NumElements*2;
	}

	m_Array[m_NumElementsUsed-1] = elem;
}


template <class T>
bool CSmartBuffer<T>::FindElement(T elem)
{
	for (int i=0; i < m_NumElementsUsed; i++)
	{
		if (m_Array[i] == elem)
			return true;
	}

	return false;
}

#endif // !defined(AFX_SMARTBUFFER_H__47C64F5D_8388_452B_864B_1F55D6AE6F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\commonp.h ===
//
// top.h is required and must be first
//
#include "top.h"

//
// Now list all H files for code implemented here in runtime\common.
// Each header should be independent and order below should not matter.
//

#include "growbuf.h"
#include "growlist.h"
#include "hash.h"
#include "strmap.h"
#include "strmem.h"
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\str.cpp ===
// Str.cpp: implementation of the CStr class.
//
//////////////////////////////////////////////////////////////////////
#include "Str.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

bool operator==(const CStr& s1, const CStr& s2)
{
	if ((s1.IsEmpty() == true) && (s2.IsEmpty() == true))
		return true;

	if (s1.IsEmpty() != s2.IsEmpty())
		return false;

	return (MYSTRCMP(s1, s2) == 0);
}

bool operator==(const CStr& s1, LPCTSTR s2) {return s1 == CStr(s2);}
bool operator==(LPCTSTR s1, const CStr& s2) {return CStr(s1) == s2;}


void CStr::SplitString(CStr &first, CStr &last, TCHAR separator)
{
	for (int i=0; get()[i] != NULL; i++)
	{
		if (get()[i] == separator)
			break;
	}

	if (get()[i] == separator)
	{
		last = (LPCTSTR)(get()+i+1);
	}	
	else
	{
		last = CStr(); //a null string, since there is no
						//separator char
	}
	
	first = GetCopy();
	first.get()[i] = NULL;
}

CStr CStr::GetCopy()
{
	CStr temp((LPCTSTR)*this);

	return temp;
}

void CStr::UseBuffer(TCHAR *buf)
{
	release();

	itsCounter = new counter(buf);
}

bool CStr::IsPrefix(LPCTSTR str)
{
	TCHAR* p1 = get();
	TCHAR* p2 = (TCHAR*)str;

	while ((*p1 == *p2) && (*p1 != NULL))
	{
		p1++;
		p2++;
	}

	return (*p2 == NULL);

}

void CStr::OverideBuffer(TCHAR *buf)
{
   if (itsCounter) {
            if (--itsCounter->count == 0) {
            //    delete [] itsCounter->ptr;
                delete itsCounter;
            }
            itsCounter = 0;
        }

   itsCounter = new counter(buf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\growlist.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growlist.c

Abstract:

    Simple buffer management functions that maintenence of a list of binary
    objects.

Author:

    08-Aug-1997   jimschm     Created

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"
#include "commonp.h"

#define INSERT_LAST     0xffffffff

PBYTE
pGlAdd (
    IN OUT  PGROWLIST GrowList,
    IN      UINT InsertBefore,
    IN      PBYTE DataToAdd,            OPTIONAL
    IN      UINT SizeOfData,
    IN      UINT NulBytesToAdd
    )

/*++

Routine Description:

  pGlAdd allocates memory for a binary block by using a pool, and then expands
  an array of pointers, maintaining a quick-access list.

Arguments:

  GrowList - Specifies the list to add the entry to

  InsertBefore - Specifies the index of the array element to insert
                 before, or INSERT_LIST to append.

  DataToAdd - Specifies the binary block of data to add.

  SizeOfData - Specifies the size of data.

  NulBytesToAdd - Specifies the number of nul bytes to add to the buffer

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    PBYTE *Item;
    PBYTE *InsertAt;
    PBYTE Data;
    UINT OldEnd;
    UINT Size;
    UINT TotalSize;

    TotalSize = SizeOfData + NulBytesToAdd;

    MYASSERT (TotalSize || !DataToAdd);

    //
    // Expand list array
    //

    OldEnd = GrowList->ListArray.End;
    Item = (PBYTE *) GbGrow (&GrowList->ListArray, sizeof (PBYTE));
    if (!Item) {
        DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate array item"));
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToAdd || NulBytesToAdd) {
        Data = FAST_MALLOC (TotalSize);
        if (!Data) {
            GrowList->ListArray.End = OldEnd;
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block"));
            return NULL;
        }

        if (DataToAdd) {
            CopyMemory (Data, DataToAdd, SizeOfData);
        }
        if (NulBytesToAdd) {
            ZeroMemory (Data + SizeOfData, NulBytesToAdd);
        }
    } else {
        Data = NULL;
    }

    //
    // Adjust array
    //

    Size = GlGetSize (GrowList);

    if (InsertBefore >= Size) {
        //
        // Append mode
        //

        *Item = Data;

    } else {
        //
        // Insert mode
        //

        InsertAt = (PBYTE *) (GrowList->ListArray.Buf) + InsertBefore;
        MoveMemory (&InsertAt[1], InsertAt, (Size - InsertBefore) * sizeof (PBYTE));
        *InsertAt = Data;
    }

    return Data ? Data : (PBYTE) 1;
}


VOID
GlFree (
    IN  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlFree frees the resources allocated by a GROWLIST.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    if (!GrowList) {
        return;
    }

    GlReset (GrowList);
    GbFree (&GrowList->ListArray);

    ZeroMemory (GrowList, sizeof (GROWLIST));
}


VOID
GlReset (
    IN OUT  PGROWLIST GrowList
    )

/*++

Routine Description:

  GlReset empties the grow list but does not destroy the index buffer or pool.
  It is used to efficiently reuse a list.

Arguments:

  GrowList - Specifies the list to clean up

Return Value:

  none

--*/

{
    UINT u;
    UINT count;
    PBYTE *dataPtr;

    if (!GrowList) {
        MYASSERT (FALSE);
        return;
    }

    count = GlGetSize (GrowList);
    dataPtr = (PBYTE *) (GrowList->ListArray.Buf);

    for (u = 0 ; u < count ; u++) {
        FAST_FREE (dataPtr[u]);
    }

    GrowList->ListArray.End = 0;
}


PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlGetItem returns a pointer to the block of data for item specified by
  Index.

Arguments:

  GrowList - Specifies the list to access

  Index - Specifies zero-based index of item in list to access

Return Value:

  A pointer to the item's data, or NULL if the Index does not
  represent an actual item.

--*/

{
    PBYTE *ItemPtr;
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index >= Size) {
        return NULL;
    }

    ItemPtr = (PBYTE *) (GrowList->ListArray.Buf);
    MYASSERT(ItemPtr);

    return ItemPtr[Index];
}


UINT
GlGetSize (
    IN      PGROWLIST GrowList
    )

/*++

Routine Description:

  GlGetSize calculates the number of items in the list.

Arguments:

  GrowList - Specifies the list to calculate the size of

Return Value:

  The number of items in the list, or zero if the list is empty.

--*/

{
    return GrowList->ListArray.End / sizeof (PBYTE);
}


PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item.

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 0);
}


PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend appends a black of data as a new list item and appends two zero
  bytes (used for string termination).

Arguments:

  GrowList - Specifies the list to modify

  DataToAppend - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToAppend

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    return pGlAdd (GrowList, INSERT_LAST, DataToAppend, SizeOfData, 2);
}


PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a black of data as a new list item, before the specified
  Index.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index > Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 0);
}


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToInsert,         OPTIONAL
    IN      UINT SizeOfData
    )

/*++

Routine Description:

  GlAppend inserts a block of data as a new list item, before the specified
  Index.  Two zero bytes are appended to the block of data (used for string
  termination).

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of item to insert ahead of.

  DataToInsert - Specifies a block of data to be copied

  SizeOfData - Specifies the number of bytes in DataToInsert

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;

    Size = GlGetSize (GrowList);
    if (Index > Size) {
        return NULL;
    }

    return pGlAdd (GrowList, Index, DataToInsert, SizeOfData, 2);
}


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlDeleteItem removes an item from the list.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

Return Value:

  TRUE if the data block was removed from the list, or FALSE if
  Index is invalid.

--*/

{
    UINT Size;
    PBYTE *DeleteAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    DeleteAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*DeleteAt) {
        FAST_FREE (*DeleteAt);
    }

    Size--;
    if (Size > Index) {
        MoveMemory (DeleteAt, &DeleteAt[1], (Size - Index) * sizeof (PBYTE));
    }

    GrowList->ListArray.End = Size * sizeof (PBYTE);

    return TRUE;
}


BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    )

/*++

Routine Description:

  GlResetItem sets the list pointer of the specified item to NULL, freeing the
  memory associated with the item's data.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to reset.

Return Value:

  TRUE if the data block was freed and the list element was nulled,
  or FALSE if Index is invalid.

--*/

{
    UINT Size;
    PBYTE *ResetAt;

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return FALSE;
    }

    ResetAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ResetAt) {
        FAST_FREE (*ResetAt);
    }

    *ResetAt = NULL;

    return TRUE;
}


PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToCopy,
    IN      UINT DataSize
    )

/*++

Routine Description:

  GlSetItem replaces the data associated with a list item.

Arguments:

  GrowList - Specifies the list to modify

  Index - Specifies the zero-based index of the item to remove.

  DataToCopy - Specifies data to associate with the list item

  DataSize - Specifies the size of Data

Return Value:

  A pointer to the binary block if data was copied into the list, 1 if a list
  item was created but no data was set for the item, or NULL if an error
  occurred.

--*/

{
    UINT Size;
    PBYTE *ReplaceAt;
    PBYTE Data;

    MYASSERT (DataSize || !DataToCopy);

    Size = GlGetSize (GrowList);
    if (Size <= Index) {
        return NULL;
    }

    //
    // Copy data
    //

    if (DataToCopy) {
        Data = FAST_MALLOC (DataSize);
        if (!Data) {
            DEBUGMSG ((DBG_WARNING, "GrowList: Could not allocate data block (2)"));
            return NULL;
        }

        CopyMemory (Data, DataToCopy, DataSize);
    } else {
        Data = NULL;
    }

    //
    // Update list pointer
    //

    ReplaceAt = (PBYTE *) (GrowList->ListArray.Buf) + Index;
    if (*ReplaceAt) {
        FAST_FREE (*ReplaceAt);
    }
    *ReplaceAt = Data;

    return Data ? Data : (PBYTE) 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\growbuf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    growbuf.c

Abstract:

    Simple buffer management functions that allow variable blocks to
    be added as an array.  (Initially used to build a SID array, where
    each SID can be a different size.)

Author:

    Jim Schmidt (jimschm)   05-Feb-1997

Revision History:

    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    jimschm     11-Aug-1998 Added GrowBufAppendString
    calinn      15-Jan-1998 modified MultiSzAppend


--*/

#include "pch.h"
#include "commonp.h"

//
// Includes
//

// None

#define DBG_GROWBUF     "GrowBuffer"

//
// Strings
//

// None

//
// Constants
//

#define DEFAULT_GROW_SIZE 8192

//
// Macros
//

// None

//
// Types
//

// None

//
// Globals
//

#ifdef DEBUG

DWORD g_GbCurrActiveAlloc = 0;
DWORD g_GbCurrUsedAlloc = 0;
DWORD g_GbMaxActiveAlloc = 0;
DWORD g_GbMaxUsedAlloc = 0;

#endif

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  GrowBuffer makes sure there is enough bytes in the buffer
  to accomodate SpaceNeeded.  It allocates an initial buffer
  when no buffer is allocated, and it reallocates the buffer
  in increments of GrowBuf->Size (or DEFAULT_GROW_SIZE) when
  needed.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE NewBuffer;
    DWORD TotalSpaceNeeded;
    DWORD GrowTo;

    MYASSERT(SpaceNeeded);

    if (!GrowBuf->Buf) {
        GrowBuf->Size = 0;
        GrowBuf->End = 0;
#ifdef DEBUG
        GrowBuf->StatEnd = 0;
#endif
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = DEFAULT_GROW_SIZE;
    }

#ifdef DEBUG
    g_GbCurrActiveAlloc -= GrowBuf->Size;
    g_GbCurrUsedAlloc -= GrowBuf->StatEnd;
#endif

    TotalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (TotalSpaceNeeded > GrowBuf->Size) {
        GrowTo = (TotalSpaceNeeded + GrowBuf->GrowSize) - (TotalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        GrowTo = 0;
    }

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAlloc (g_hHeap, 0, GrowTo);
        if (!GrowBuf->Buf) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Initial alloc failed"));
            return NULL;
        }

        GrowBuf->Size = GrowTo;
    } else if (GrowTo) {
        NewBuffer = MemReAlloc (g_hHeap, 0, GrowBuf->Buf, GrowTo);
        if (!NewBuffer) {
            DEBUGMSG ((DBG_ERROR, "GbGrow: Realloc failed"));
            return NULL;
        }

#ifdef DEBUG
        if (GrowBuf->Buf != NewBuffer) {
            DEBUGMSG ((
                DBG_WARNING,
                "GbGrow: Realloc caused growbuffer to move %u bytes to new location; "
                    "any pointers inside old buffer are now invalid",
                GrowBuf->Size
                ));

            if (GrowBuf->Size > 32767) {
                DBGTRACKDUMP();
            }
        }
#endif

        GrowBuf->Size = GrowTo;
        GrowBuf->Buf = NewBuffer;
    }

    NewBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

#ifdef DEBUG
    GrowBuf->StatEnd = GrowBuf->End;
    g_GbCurrActiveAlloc += GrowBuf->Size;
    if (g_GbMaxActiveAlloc < g_GbCurrActiveAlloc) {
        g_GbMaxActiveAlloc = g_GbCurrActiveAlloc;
    }
    g_GbCurrUsedAlloc += GrowBuf->StatEnd;
    if (g_GbMaxUsedAlloc < g_GbCurrUsedAlloc) {
        g_GbMaxUsedAlloc = g_GbCurrUsedAlloc;
    }
#endif

    return NewBuffer;
}


VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  FreeGrowBuffer frees a buffer allocated by GrowBuffer.

Arguments:

  GrowBuf  - A pointer to the same structure passed to GrowBuffer

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

#ifdef DEBUG
    g_GbCurrActiveAlloc -= GrowBuf->Size;
    g_GbCurrUsedAlloc -= GrowBuf->StatEnd;
#endif

    if (GrowBuf->Buf) {
        MemFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


/*++

Routine Descriptions:

  MultiSzAppend
    This function is a general-purpose function to append a string
    to a grow buffer.

  MultiSzAppendVal
    This function adds a key=decimal_val string, where key is a
    specified string, and decimal_val is a specified DWORD.

  MultiSzAppendString
    This function adds key=string to the grow buffer, where key
    is a specified string, and string is a specified string value.

Arguments:

  GrowBuf  - The buffer to append the string or key/value pair
  Key      - The key part of the key=val pair
  Val      - The val part of the key=val pair

Return Value:

  TRUE if the function succeeded, or FALSE if a memory allocation
  failure occurred.

--*/


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    )
{
    PSTR p;

    p = (PSTR) GbGrow (GrowBuf, SzSizeA (String) + sizeof(CHAR));
    if (!p) {
        return FALSE;
    }

    SzCopyA (p, String);
    GrowBuf->End -= sizeof (CHAR);
    GrowBuf->Buf[GrowBuf->End] = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    )
{
    CHAR KeyValPair[256];

    wsprintfA (KeyValPair, "%s=%u", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    )
{
    CHAR KeyValPair[1024];

    wsprintfA (KeyValPair, "%s=%s", Key, Val);
    return GbMultiSzAppendA (GrowBuf, KeyValPair);
}


BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    )
{
    PWSTR p;

    p = (PWSTR) GbGrow (GrowBuf, SzSizeW (String) + sizeof(WCHAR));
    if (!p) {
        return FALSE;
    }

    SzCopyW (p, String);
    GrowBuf->End -= sizeof (WCHAR);
    *((PWCHAR) (GrowBuf->Buf + GrowBuf->End)) = 0;

    return TRUE;
}

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    )
{
    WCHAR KeyValPair[256];

    wsprintfW (KeyValPair, L"%s=%u", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    )
{
    WCHAR KeyValPair[1024];

    wsprintfW (KeyValPair, L"%s=%s", Key, Val);
    return GbMultiSzAppendW (GrowBuf, KeyValPair);
}


BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    )
{
    PDWORD p;

    p = (PDWORD) GbGrow (GrowBuf, sizeof (DWORD));
    if (!p) {
        return FALSE;
    }

    *p = d;

    return TRUE;
}


BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID Ptr
    )
{
    PCVOID *p;

    p = (PVOID *) GbGrow (GrowBuf, sizeof (PVOID));
    if (!p) {
        return FALSE;
    }

    *p = Ptr;

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendString copies the specified string to the end of the grow
  buffer.  This is the equivalent of strcat.  The grow buffer is
  automatically expanded as necessary.

Arguments:

  GrowBuf - Specifies the destination grow buffer
  String  - Specifies the string to append

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SzSizeA (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        SzCopyA (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


BOOL
RealGbAppendStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (String) {
        Bytes = SzSizeW (String);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes);

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        SzCopyW (p, String);
        GrowBuf->End = OldEnd + Bytes;
    }

    return TRUE;
}


/*++

Routine Description:

  GrowBufAppendStringAB copies the specified string range to the
  end of the grow buffer.  This concatenates the string to the
  existing buffer contents, and keeps the buffer terminated.

Arguments:

  GrowBuf    - Specifies the destination grow buffer
  Start      - Specifies the start of string to append
  EndPlusOne - Specifies one logical character beyond the end of
               the string, and can point to a nul.

Return Value:

  Always TRUE.

--*/

BOOL
RealGbAppendStringABA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )

{
    UINT OldEnd;
    PSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = SzByteCountABA (Start, EndPlusOne);

        OldEnd = GrowBuf->End;
        if (OldEnd) {
            p = (PSTR) (GrowBuf->Buf + OldEnd - sizeof (CHAR));
            if (*p == 0) {
                OldEnd -= sizeof (CHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (CHAR));

        p = (PSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (CHAR);
    }

    return TRUE;
}


BOOL
RealGbAppendStringABW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
    UINT OldEnd;
    PWSTR p;
    UINT Bytes;

    if (Start && Start < EndPlusOne) {
        Bytes = SzByteCountABW (Start, EndPlusOne);

        OldEnd = GrowBuf->End;
        if (OldEnd > sizeof (WCHAR)) {
            p = (PWSTR) (GrowBuf->Buf + OldEnd - sizeof (WCHAR));
            if (*p == 0) {
                OldEnd -= sizeof (WCHAR);
            }
        }

        RealGbGrow (GrowBuf, Bytes + sizeof (WCHAR));

        p = (PWSTR) (GrowBuf->Buf + OldEnd);
        CopyMemory (p, Start, Bytes);
        p = (PWSTR) ((PBYTE) p + Bytes);
        *p = 0;

        GrowBuf->End = OldEnd + Bytes + sizeof (WCHAR);
    }

    return TRUE;
}



/*++

Routine Description:

  GrowBufCopyString copies the specified string to the end of the grow buffer.

Arguments:

  GrowBuf - Specifies the grow buffer to add to, receives the updated buffer

  String - Specifies the string to add to GrowBuf

Return Value:



--*/

BOOL
RealGbCopyStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SzSizeA (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}


BOOL
RealGbCopyStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SzSizeW (String);

    Buf = RealGbGrow (GrowBuf, Size);
    if (!Buf) {
        return FALSE;
    }

    CopyMemory (Buf, String, Size);
    return TRUE;
}

BOOL
RealGbCopyQuotedStringA (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SzSizeA (String);

    Buf = RealGbGrow (GrowBuf, Size + 2 * sizeof (CHAR));
    if (!Buf) {
        return FALSE;
    }

    *((CHAR *)(Buf)) = '\"';
    CopyMemory (Buf + sizeof (CHAR), String, Size);
    *((CHAR *)(Buf + Size)) = '\"';
    *((CHAR *)(Buf + Size + sizeof (CHAR))) = 0;
    return TRUE;
}


BOOL
RealGbCopyQuotedStringW (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      PCWSTR String
    )
{
    PBYTE Buf;
    UINT Size;

    Size = SzSizeW (String);

    Buf = RealGbGrow (GrowBuf, Size + 2 * sizeof (WCHAR));
    if (!Buf) {
        return FALSE;
    }

    *((WCHAR *)(Buf)) = L'\"';
    CopyMemory (Buf + sizeof (WCHAR), String, Size);
    *((WCHAR *)(Buf + Size)) = L'\"';
    *((WCHAR *)(Buf + Size + sizeof (WCHAR))) = 0;
    return TRUE;
}


#ifdef DEBUG

VOID
GbDumpStatistics (
    VOID
    )
{
    DEBUGMSG ((
        DBG_STATS,
        "Grow buffers usage:\nPeak   : Usable:%-8d Used:%-8d\nCurrent: Usable:%-8d Leak:%-8d",
        g_GbMaxActiveAlloc,
        g_GbMaxUsedAlloc,
        g_GbCurrActiveAlloc,
        g_GbCurrUsedAlloc
        ));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\regdiff\str.h ===
// Str.h: interface for the CStr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STR_H__A4F6F853_1CB0_4AE5_A195_25F1AC01E6CA__INCLUDED_)
#define AFX_STR_H__A4F6F853_1CB0_4AE5_A195_25F1AC01E6CA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "precomp.h"
#include "counted_ptr.h"

//////////////////////////////////////////////////////////////////////
/*
struct sBinaryData
{
	sBinaryData(DWORD count, LPBYTE BinData)
		:m_Count(count), m_pData(BinData) {}

	DWORD m_Count;
	LPBYTE m_pData;
};

class CBinaryData : public counted_ptr<sBinaryData>
{};
*/
//////////////////////////////////////////////////////////////////////


#define MYSTRLEN(x) _tcsclen(x)
#define MYSTRCPY(x,y) _tcscpy(x,y)
#define MYSTRCMP(x,y) _tcscmp(x,y)




class CStr : protected counted_ptrA<TCHAR>
{
public:
	void OverideBuffer(TCHAR* buf);
	bool IsPrefix(LPCTSTR str);
	void UseBuffer(TCHAR* buf);
	CStr(const TCHAR* str=NULL)
	{
		if (str != NULL)
		{		
			int len = MYSTRLEN(str) + 1;

			TCHAR* temp = new TCHAR[len];
			MYSTRCPY(temp, str);

			itsCounter = new counter(temp);
		}		
	}

	void SplitString(CStr& first, CStr& last, TCHAR separator);

	bool IsEmpty() const {return (itsCounter == 0);}

	operator LPCTSTR() const 
	{return get();}

	void operator +=(const CStr& str)
	{
		int len1 = IsEmpty() ? 0 : MYSTRLEN(get());
		int len2 = str.IsEmpty() ? 0 : MYSTRLEN(str.get());

		if ((len1 + len2) == 0)
			return;

		TCHAR* temp=new TCHAR[len1+len2+1];

		if (len1)	MYSTRCPY(temp, get());

		if (len2)	MYSTRCPY(temp+len1, str.get());

		release();
		itsCounter = new counter(temp);
	}

	friend bool operator==(const CStr& s1, const CStr& s2);
	friend bool operator==(const CStr& s1, LPCTSTR s2);
	friend bool operator==(LPCTSTR s1, const CStr& s2);

protected:
	CStr GetCopy();
};


#endif // !defined(AFX_STR_H__A4F6F853_1CB0_4AE5_A195_25F1AC01E6CA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\dbgtrack.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    dbgtrack.c

Abstract:

    Allocation tracking implementation.

Author:

    Jim Schmidt  (jimschm) 18-Sept-2001

Revision History:

--*/

//
// Includes
//

#include "pch.h"
#include "commonp.h"


//
// NOTE: No code should appear outside the #ifdef DEBUG
//

#ifdef DEBUG

//
// Strings
//

// None

//
// Constants
//

#define TRACK_BUCKETS           1501
#define BUCKET_ITEMS_PER_POOL   8192




//
// Macros
//

// None

//
// Types
//

typedef ULONG_PTR ALLOCATION_ITEM_OFFSET;

typedef struct TAG_TRACKBUCKETITEM {
    struct TAG_TRACKBUCKETITEM *Next;
    struct TAG_TRACKBUCKETITEM *Prev;
    ALLOCTYPE Type;
    PCVOID Ptr;
    ALLOCATION_ITEM_OFFSET ItemOffset;
} TRACKBUCKETITEM, *PTRACKBUCKETITEM;

typedef struct _tagBUCKETPOOL {
    UINT Count;
    TRACKBUCKETITEM Items[BUCKET_ITEMS_PER_POOL];
} TRACKBUCKETPOOL, *PTRACKBUCKETPOOL;

typedef struct {
    ALLOCTYPE Type;
    PCVOID Ptr;
    PCSTR FileName;
    UINT Line;
    BOOL Allocated;
} ALLOCATION_ITEM, *PALLOCATION_ITEM;

typedef struct {
    PTRACKBUCKETITEM TrackBuckets[TRACK_BUCKETS];
    PTRACKBUCKETITEM TrackPoolDelHead;
    PTRACKBUCKETPOOL TrackPool;
    UINT DisabledRefCount;
    INT UseCount;
    CHAR TrackComment[1024];
    PCSTR TrackFile;
    UINT TrackLine;
    BOOL FreeTrackFile;
} THREADTRACK, *PTHREADTRACK;

//
// Globals
//

DWORD g_TlsIndex = TLS_OUT_OF_INDEXES;

CRITICAL_SECTION g_AllocListCs;
GROWBUFFER g_AllocationList;
PVOID g_FirstDeletedAlloc;

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

//
// Macro expansion definition
//

// None

//
// Code
//


PBYTE
pUntrackedGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD   SpaceNeeded
    )

/*++

Routine Description:

  pUntrackedGbGrow is the same as GbGrow, but it does not cause any tracking
  to occur.

Arguments:

  GrowBuf            - A pointer to a GROWBUFFER structure.
                       Initialize this structure to zero for
                       the first call to GrowBuffer.

  SpaceNeeded        - The number of free bytes needed in the buffer


Return Value:

  A pointer to the SpaceNeeded bytes, or NULL if a memory allocation
  error occurred.

--*/

{
    PBYTE newBuffer;
    DWORD totalSpaceNeeded;
    DWORD growTo;

    MYASSERT(SpaceNeeded);

    //
    // Make sure structure is initialized properly
    //

    if (!GrowBuf->Buf) {
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }

    if (!GrowBuf->GrowSize) {
        GrowBuf->GrowSize = 1024;
    }

    //
    // Compute new buffer size
    //

    totalSpaceNeeded = GrowBuf->End + SpaceNeeded;
    if (totalSpaceNeeded > GrowBuf->Size) {
        growTo = (totalSpaceNeeded + GrowBuf->GrowSize) - (totalSpaceNeeded % GrowBuf->GrowSize);
    } else {
        growTo = 0;
    }

    //
    // If no buffer, allocate one. If buffer is too small, reallocate it.
    //

    if (!GrowBuf->Buf) {
        GrowBuf->Buf = (PBYTE) MemAllocNeverFail (g_hHeap, 0, growTo);
        GrowBuf->Size = growTo;
    } else if (growTo) {
        newBuffer = MemReAllocNeverFail (g_hHeap, 0, GrowBuf->Buf, growTo);
        GrowBuf->Size = growTo;
        GrowBuf->Buf = newBuffer;
    }

    newBuffer = GrowBuf->Buf + GrowBuf->End;
    GrowBuf->End += SpaceNeeded;

    return newBuffer;
}


VOID
pUntrackedGbFree (
    IN  PGROWBUFFER GrowBuf
    )

/*++

Routine Description:

  pUntrackedGbFree frees a buffer allocated by pUntrackedGbGrow.

Arguments:

  GrowBuf  - A pointer to the same structure passed to pUntrackedGbGrow

Return Value:

  none

--*/


{
    MYASSERT(GrowBuf);

    if (GrowBuf->Buf) {
        HeapFree (g_hHeap, 0, GrowBuf->Buf);
        ZeroMemory (GrowBuf, sizeof (GROWBUFFER));
    }
}


PTHREADTRACK
pGetTrackStructForThread (
    VOID
    )
{
    PTHREADTRACK result;

    result = (PTHREADTRACK) TlsGetValue (g_TlsIndex);

    if (!result) {
        //
        // Need to allocate a struct
        //

        result = (PTHREADTRACK) MemAllocNeverFail (
                                    g_hHeap,
                                    HEAP_ZERO_MEMORY,
                                    sizeof (THREADTRACK)
                                    );

        TlsSetValue (g_TlsIndex, (PVOID) result);
    }

    return result;
}

VOID
DisableTrackComment (
    VOID
    )
{
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();
    trackStruct->DisabledRefCount += 1;
}

VOID
EnableTrackComment (
    VOID
    )
{
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    if (trackStruct->DisabledRefCount > 0) {
        trackStruct->DisabledRefCount -= 1;
    }
}


INT
DbgTrackPushEx (
    PCSTR Msg,
    PCSTR File,
    UINT Line,
    BOOL DupFileString
    )
{
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    if (trackStruct->DisabledRefCount > 0) {
        return 0;
    }

    if (trackStruct->UseCount > 0) {
        trackStruct->UseCount += 1;
        return 0;
    }

    if (Msg) {
        wsprintfA (trackStruct->TrackComment, "%s line %u [%s]", File, Line, Msg);
    } else {
        wsprintfA (trackStruct->TrackComment, "%s line %u", File, Line);
    }

    if (DupFileString) {
        trackStruct->TrackFile = (PCSTR) MemAllocNeverFail (g_hHeap, 0, SzSizeA (File));
        SzCopyA ((PSTR) trackStruct->TrackFile, File);
        trackStruct->FreeTrackFile = TRUE;
    } else {
        trackStruct->TrackFile = File;
        trackStruct->FreeTrackFile = FALSE;
    }

    trackStruct->TrackLine = Line;
    trackStruct->UseCount = 1;

    return 0;
}


INT
DbgTrackPop (
    VOID
    )
{
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    if (trackStruct->DisabledRefCount > 0) {
        return 0;
    }

    trackStruct->UseCount -= 1;

    if (!(trackStruct->UseCount)) {
        trackStruct->TrackComment[0] = 0;

        if (trackStruct->FreeTrackFile && trackStruct->TrackFile) {
            HeapFree (g_hHeap, 0, (PVOID)trackStruct->TrackFile);
        }

        trackStruct->TrackFile = NULL;
        trackStruct->TrackLine = 0;
        trackStruct->FreeTrackFile = FALSE;
    }

    return 0;
}


VOID
DbgTrackDump (
    VOID
    )
{
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    if (trackStruct->UseCount > 0) {
        DEBUGMSGA ((
            DBG_INFO,
            "Caller : %s line %u (%s)",
            trackStruct->TrackFile,
            trackStruct->TrackLine,
            trackStruct->TrackComment
            ));
    }
}


BOOL
DbgInitTracking (
    VOID
    )
{
    if (g_TlsIndex == TLS_OUT_OF_INDEXES) {
        g_TlsIndex = TlsAlloc();
        if (g_TlsIndex == TLS_OUT_OF_INDEXES) {
            return FALSE;
        }
    }

    InitializeCriticalSection (&g_AllocListCs);

    ZeroMemory (&g_AllocationList, sizeof (g_AllocationList));
    g_AllocationList.GrowSize = 65536;
    g_FirstDeletedAlloc = NULL;
    return TRUE;
}


VOID
DbgTerminateTracking (
    VOID
    )
{
    UINT size;
    UINT u;
    PALLOCATION_ITEM item;
    GROWBUFFER msg = { 0, 0, 0, 0, 0, 0 };
    CHAR text[1024];
    PSTR p;
    UINT byteCount;
    PTHREADTRACK trackStruct;

    EnterCriticalSection (&g_AllocListCs);

    trackStruct = pGetTrackStructForThread();

    size = g_AllocationList.End / sizeof (ALLOCATION_ITEM);

    for (u = 0 ; u < size ; u++) {
        item = (PALLOCATION_ITEM) g_AllocationList.Buf + u;
        if (!item->FileName) {
            continue;
        }

        //
        // Append the string but not the nul
        //

        byteCount = (UINT) wsprintfA (text, "%s line %u\r\n", item->FileName, item->Line);
        p = (PSTR) pUntrackedGbGrow (&msg, byteCount);
        CopyMemory (p, text, byteCount);
    }

    pUntrackedGbFree (&g_AllocationList);
    g_FirstDeletedAlloc = NULL;

    LeaveCriticalSection (&g_AllocListCs);

    //
    // Put the message in the log
    //

    if (msg.End) {

        p = (PSTR) pUntrackedGbGrow (&msg, 1);
        *p = 0;

        DEBUGMSGA ((DBG_WARNING, "Leaks : %s", msg.Buf));
        pUntrackedGbFree (&msg);
    }

    // Intentional leak -- who cares about track memory
    trackStruct->TrackPoolDelHead = NULL;
    trackStruct->TrackPool = NULL;

    TlsFree (g_TlsIndex);
    g_TlsIndex = TLS_OUT_OF_INDEXES;
}


PTRACKBUCKETITEM
pAllocTrackBucketItem (
    VOID
    )
{
    PTRACKBUCKETITEM bucketItem;
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    if (trackStruct->TrackPoolDelHead) {
        bucketItem = trackStruct->TrackPoolDelHead;
        trackStruct->TrackPoolDelHead = bucketItem->Next;
    } else {

        if (!trackStruct->TrackPool || trackStruct->TrackPool->Count == BUCKET_ITEMS_PER_POOL) {
            trackStruct->TrackPool = (PTRACKBUCKETPOOL) MemAllocNeverFail (g_hHeap, 0, sizeof (TRACKBUCKETPOOL));
            trackStruct->TrackPool->Count = 0;
        }

        bucketItem = trackStruct->TrackPool->Items + trackStruct->TrackPool->Count;
        trackStruct->TrackPool->Count++;
    }

    return bucketItem;
}

VOID
pFreeTrackBucketItem (
    PTRACKBUCKETITEM BucketItem
    )
{
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    BucketItem->Next = trackStruct->TrackPoolDelHead;
    trackStruct->TrackPoolDelHead = BucketItem;
}



UINT
pComputeTrackHashVal (
    IN      ALLOCTYPE Type,
    IN      PCVOID Ptr
    )
{
    ULONG_PTR hash;

    hash = ((ULONG_PTR) Type << 16) ^ (ULONG_PTR)Ptr;
    return (UINT) (hash % TRACK_BUCKETS);
}


VOID
pTrackHashTableInsert (
    IN      PBYTE Base,
    IN      ALLOCATION_ITEM_OFFSET ItemOffset
    )
{
    UINT hash;
    PTRACKBUCKETITEM bucketItem;
    PALLOCATION_ITEM item;
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    item = (PALLOCATION_ITEM) (Base + ItemOffset);

    hash = pComputeTrackHashVal (item->Type, item->Ptr);

    bucketItem = pAllocTrackBucketItem();

    bucketItem->Prev = NULL;
    bucketItem->Next = trackStruct->TrackBuckets[hash];
    bucketItem->Type = item->Type;
    bucketItem->Ptr  = item->Ptr;
    bucketItem->ItemOffset = ItemOffset;

    if (bucketItem->Next) {
        bucketItem->Next->Prev = bucketItem;
    }

    trackStruct->TrackBuckets[hash] = bucketItem;
}

VOID
pTrackHashTableDelete (
    IN      PTRACKBUCKETITEM BucketItem
    )
{
    UINT hash;
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    hash = pComputeTrackHashVal (BucketItem->Type, BucketItem->Ptr);

    if (BucketItem->Prev) {
        BucketItem->Prev->Next = BucketItem->Next;
    } else {
        trackStruct->TrackBuckets[hash] = BucketItem->Next;
    }

    if (BucketItem->Next) {
        BucketItem->Next->Prev = BucketItem->Prev;
    }

    pFreeTrackBucketItem (BucketItem);
}

PTRACKBUCKETITEM
pTrackHashTableFind (
    IN      ALLOCTYPE Type,
    IN      PCVOID Ptr
    )
{
    PTRACKBUCKETITEM bucketItem;
    UINT hash;
    PTHREADTRACK trackStruct;

    trackStruct = pGetTrackStructForThread();

    hash = pComputeTrackHashVal (Type, Ptr);

    bucketItem = trackStruct->TrackBuckets[hash];
    while (bucketItem) {
        if (bucketItem->Type == Type && bucketItem->Ptr == Ptr) {
            return bucketItem;
        }

        bucketItem = bucketItem->Next;
    }

    return NULL;
}


VOID
DbgRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    )
{
    PALLOCATION_ITEM item;
    PTHREADTRACK trackStruct;
    PCSTR fileToRecord;
    UINT lineToRecord;

    trackStruct = pGetTrackStructForThread();

    if (!trackStruct->TrackFile) {
        fileToRecord = File;
        lineToRecord = Line;
    } else {
        fileToRecord = trackStruct->TrackFile;
        lineToRecord = trackStruct->TrackLine;
    }

    EnterCriticalSection (&g_AllocListCs);

    if (!g_FirstDeletedAlloc) {
        item = (PALLOCATION_ITEM) pUntrackedGbGrow (&g_AllocationList,sizeof(ALLOCATION_ITEM));
    } else {
        item = (PALLOCATION_ITEM) g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = (PVOID)item->Ptr;
    }

    item->Type = Type;
    item->Ptr = Ptr;
    item->FileName = fileToRecord;
    item->Line = lineToRecord;

    pTrackHashTableInsert (
        g_AllocationList.Buf,
        (ALLOCATION_ITEM_OFFSET) ((PBYTE) item - g_AllocationList.Buf)
        );

    LeaveCriticalSection (&g_AllocListCs);
}


VOID
DbgUnregisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PCVOID Ptr
    )
{
    PALLOCATION_ITEM item;
    PTRACKBUCKETITEM bucketItem;

    EnterCriticalSection (&g_AllocListCs);

    bucketItem = pTrackHashTableFind (Type, Ptr);

    if (!g_AllocationList.Buf) {
        LeaveCriticalSection (&g_AllocListCs);
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Allocation buffer already freed"));
        return;
    }

    if (bucketItem) {
        item = (PALLOCATION_ITEM) (g_AllocationList.Buf + bucketItem->ItemOffset);

        if (item->Allocated) {
            HeapFree (g_hHeap, 0, (PSTR)item->FileName);
        }
        item->FileName = NULL;
        item->Type = (ALLOCTYPE) -1;
        item->Ptr = g_FirstDeletedAlloc;
        g_FirstDeletedAlloc = item;

        pTrackHashTableDelete (bucketItem);

        LeaveCriticalSection (&g_AllocListCs);

    } else {
        LeaveCriticalSection (&g_AllocListCs);
        DEBUGMSG ((DBG_WARNING, "Unregister allocation: Pointer not registered"));
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\hash.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.c

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    This routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     23-Nov-1999  Removed setup api compatibility, fixed enum
                             to be insertion order
    ovidiut     14-Oct-1999  New coding conventions + Win64 compliance.
    marcw        2-Sep-1999  Moved over from Win9xUpg project.

--*/

#include "pch.h"
#include "commonp.h"

//
// Includes
//

// None

#define DBG_HASH    "HashTable"

//
// Strings
//

#define S_HASHTABLE "HashTable"

//
// Constants
//

#define BUCKETS                 1009
#define HASHTABLE_SIGNATURE     0x122398ff

//
// Macros
//

#ifdef DEBUG
    #define ASSERT_TABLE_IS_VALID(table)        MYASSERT(pTableIsValid(table))
#else
    #define ASSERT_TABLE_IS_VALID(table)
#endif

//
// Types
//

typedef struct _tagBUCKETITEM {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    WORD StringSize;
    // string follows StringSize
    // optional data follows string
} BUCKETITEM, *PBUCKETITEM;

typedef struct {
    struct _tagBUCKETITEM *Next;
    struct _tagBUCKETITEM *NextLink, *PrevLink;
    INT Locked;
    PVOID String;
    // optional data follows struct
} BUCKETITEM_EXTERN_STR, *PBUCKETITEM_EXTERN_STR;

typedef struct {
    DWORD Signature;
    BOOL Unicode;
    BOOL ExternalStrings;
    BOOL CaseSensitive;
    PBUCKETITEM *Bucket;
    PBUCKETITEM FirstLink;
    PBUCKETITEM LastLink;
    PBUCKETITEM DelayedDelete;
    UINT ExtraDataSize;
    UINT MinimumStringBytes;
    UINT MaximumStringBytes;
    UINT Buckets;
} HASHTABLESTRUCT, *PHASHTABLESTRUCT;


//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//



#ifdef DEBUG

BOOL
pTableIsValid (
    IN      HASHTABLE Table
    )
{
    BOOL b = TRUE;

    if (!Table) {
        return FALSE;
    }

    __try {
        if (((PHASHTABLESTRUCT) Table)->Signature != HASHTABLE_SIGNATURE) {
            b = FALSE;
        }
    }
    __except (TRUE) {
        b = FALSE;
    }

    return b;
}

#endif


/*++

Routine Description:

  pComputeHashValue adds all the character values of the string, shifting to
  maintain order.

Arguments:

  String - Specifies the string to compute the hash value for

Return Value:

  The hash value, within the range of 0 to BUCKETS - 1.

--*/

UINT
pComputeHashValueA (
    IN      PCSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputeHashValueW (
    IN      PCWSTR String,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;

    while (*String) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueA (
    IN      PCSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCSTR end;

    end = (PCSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


UINT
pComputePrefixHashValueW (
    IN      PCWSTR String,
    IN      UINT Size,
    IN      UINT Buckets
    )
{
    UINT hashValue = 0;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) String + Size);

    while (String < end) {
        hashValue = _rotl (hashValue, 2);
        hashValue += (UINT) *String;
        String++;
    }

    hashValue %= Buckets;

    return hashValue;
}


HASHTABLE
RealHtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT Buckets
    )

/*++

Routine Description:

  AllocateHashTableEx creates a hash table.  If ExtraDataSize is non-zero,
  each hash table entry gets an allocation of ExtraDataSize added to it.

Arguments:

  CaseSensitive - Specifies TRUE if the hash table is case-sensitive, FALSE
                  if all strings should be stored and compared in lower-case
                  only

  Unicode - Specifies TRUE to allocate a UNICODE hash table, or FALSE to
            allocate an ANSI table.  None of the routines in this file do any
            sort of UNICODE/ANSI converstion.

  ExternalStrings - Specifies TRUE if the strings belong to memory maintained
                    by the caller

  ExtraDataSize - Specifies the size of binary data associated with the
                  table item, or 0 for none.

Return Value:

  A handle to the string table.

--*/

{
    PHASHTABLESTRUCT hashTable;

    if (!Buckets) {
        Buckets = BUCKETS;
    }

    hashTable = (PHASHTABLESTRUCT) FAST_MALLOC (sizeof (HASHTABLESTRUCT) + (sizeof (PBUCKETITEM) * Buckets));
    if (!hashTable) {
        return NULL;
    }

    hashTable->Signature = HASHTABLE_SIGNATURE;
    hashTable->CaseSensitive = CaseSensitive;
    hashTable->Unicode = Unicode;
    hashTable->ExternalStrings = ExternalStrings;
    hashTable->Bucket = (PBUCKETITEM *) ((PBYTE) hashTable + sizeof (HASHTABLESTRUCT));
    hashTable->FirstLink = NULL;
    hashTable->LastLink = NULL;
    hashTable->ExtraDataSize = ExtraDataSize;
    hashTable->MinimumStringBytes = (UINT) -1;
    hashTable->MaximumStringBytes = 0;
    hashTable->Buckets = Buckets;

    //
    // Zero out all of the bucket structures.
    //
    ZeroMemory (hashTable->Bucket, sizeof (PBUCKETITEM) * Buckets);

    return (HASHTABLE) hashTable;
}


VOID
HtFree (
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtFree releases all resources associated with a string table.

Arguments:

  None.

Return Value:

  None.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM itemToFree;

    if (table) {
        ASSERT_TABLE_IS_VALID (HashTable);

        item = table->FirstLink;
        while (item) {
            itemToFree = item;
            item = item->NextLink;

            FAST_FREE (itemToFree);
        }

        FAST_FREE (table);
    }
}


PBUCKETITEM
pHtFindStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )

/*++

Routine Description:

  pHtFindString implements the hash table lookup routine.  It returns the
  pointer to the bucket item or NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is already lower case
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.
  PrevBucketItem    - Receives the previous bucket item

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = SzDuplicateA (String);
        (void) CharLowerA (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueA (String, table->Buckets);

    item = table->Bucket[hashValue];

    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    SzFreeA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue,
    OUT     PBUCKETITEM *PrevBucketItem
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue;
    PBUCKETITEM item;
    PCWSTR p1, p2;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    *PrevBucketItem = NULL;

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = SzDuplicateW (String);
        (void) CharLowerW (dupStr);
        String = dupStr;
    }

    hashValue = pComputeHashValueW (String, table->Buckets);

    item = table->Bucket[hashValue];
    while (item) {

        if (table->ExternalStrings) {
            p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
        } else {
            p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        p2 = String;

        while (*p1) {
            if (*p1 != *p2) {
                break;
            }

            p1++;
            p2++;
        }

        if (*p1 == 0 && *p2 == 0) {
            break;
        }

        *PrevBucketItem = item;
        item = item->Next;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    if (dupStr) {
        SzFreeW (dupStr);
    }

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )

/*++

Routine Description:

  pHtFindPrefix implements a hash table lookup routine that tests each hash
  table entry, character-by-character, until a match is found, or until the
  hash table maximum is reached.  It returns the pointer to the bucket item or
  NULL if the item was not found.

Arguments:

  HashTable        - Specifies the handle to the hash table
  String           - Specifies the string to find.  If this string is
                     case-insensitive but has already been lowercased, then make
                     sure to pass TRUE in the AlreadyLowercase argument.
  BufferEnd        - Specifies the end of the string buffer, which may be longer
                     than all entries in the hash table, or it may be shorter.
  ExtraDataBuffer  - A buffer that receives the bytes stored as extra data with
                     the found item; caller must size this according to the
                     extra data size specified to HtAllocExAW
  AlreadyLowercase - Specifies TRUE if String is in lower-case, FALSE otherwise.
  OutHashValue     - Receives the hash value.  This is non optional for
                     efficiency.  If pHtFindPrefix does not find a match,
                     this value will be set to zero.

Return Value:

  The pointer to the bucket item or NULL if no item was found.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCSTR p1, p2;
    PCSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    UINT currentBytes;
    PCSTR shortestEnd;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {

        dupStr = SzAllocA (maxBytes / sizeof (CHAR));
        if (!dupStr) {
            return NULL;
        }

        SzCopyBytesA (dupStr, String, maxBytes + sizeof (CHAR));
        CharLowerA (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd = _mbsinc (shortestEnd);
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueA (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (CHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd = SzPrevCharA (String, BufferEnd);
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    SzFreeA (dupStr);

    *OutHashValue = hashValue;

    return item;
}


PBUCKETITEM
pHtFindPrefixW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase,
    OUT     PUINT OutHashValue
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PWSTR dupStr = NULL;
    UINT hashValue = 0;
    PBUCKETITEM item = NULL;
    PCWSTR p1, p2;
    PCWSTR p1End;
    PCVOID storedDataPtr;
    UINT maxBytes;
    PCWSTR shortestEnd;
    UINT currentBytes;

    ASSERT_TABLE_IS_VALID (HashTable);

    maxBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);
    maxBytes = min (maxBytes, table->MaximumStringBytes);

    if (!maxBytes || table->MinimumStringBytes == (UINT) -1) {
        return NULL;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {

        dupStr = SzAllocW (maxBytes / sizeof (WCHAR));
        if (!dupStr) {
            return NULL;
        }

        SzCopyBytesW (dupStr, String, maxBytes + sizeof (WCHAR));
        CharLowerW (dupStr);
        String = dupStr;
    }

    BufferEnd = (PCWSTR) ((PBYTE) String + maxBytes);
    shortestEnd = (PCWSTR) ((PBYTE) String + table->MinimumStringBytes);
    if (shortestEnd == String) {
        shortestEnd++;
    }

    while (BufferEnd >= shortestEnd) {

        currentBytes = (UINT)((PBYTE) BufferEnd - (PBYTE) String);

        hashValue = pComputePrefixHashValueW (String, currentBytes, table->Buckets);

        item = table->Bucket[hashValue];

        while (item) {

            if ((item->StringSize - sizeof (WCHAR)) == currentBytes) {

                if (table->ExternalStrings) {
                    p1 = (PCWSTR) ((PBUCKETITEM_EXTERN_STR) item)->String;
                } else {
                    p1 = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
                }

                p1End = (PCWSTR) ((PBYTE) p1 + currentBytes);
                p2 = String;

                while (p1 < p1End) {
                    if (*p1 != *p2) {
                        break;
                    }

                    p1++;
                    p2++;
                }

                if (p1 == p1End) {
                    break;
                }
            }

            item = item->Next;
        }

        if (item) {
            break;
        }

        BufferEnd--;
    }

    if (item && ExtraDataBuffer) {
        (void) HtGetExtraData (HashTable, (HASHITEM)item, &storedDataPtr);

        CopyMemory (
            (PBYTE) ExtraDataBuffer,
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    if (dupStr) {
        SzFreeW (dupStr);
    }

    *OutHashValue = hashValue;

    return item;
}


HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )

/*++

Routine Description:

  HtAddStringEx adds a string to the hash table, and copies ExtraData to the
  new hash table entry.  If String is already in the hash table, the ExtraData
  is updated.

Arguments:

  HashTable        - Specifies the handle to the hash table, as returned from
                     AllocateHashTable.
  String           - Specifies the string to add to the table
  ExtraData        - Specifies the source binary data to be copied to the hash
                     table entry
  AlreadyLowercase - Specifies TRUE String is in all lowercase

Return Value:

  Returns the pointer to the bucket item allocated or update.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = SzDuplicateA (String);
        CharLowerA (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringA (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SzSizeA (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) FAST_MALLOC (size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) FAST_MALLOC (size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (CHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    SzFreeA (dupStr);

    return rc;
}


HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,           OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;
    PBUCKETITEM existingItem;
    PWSTR dupStr = NULL;
    HASHITEM rc = NULL;
    UINT size;
    UINT hashValue;
    UINT strSize;
    PCVOID storedDataPtr;
    PBUCKETITEM dontCare;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot add ANSI string to UNICODE table"));
        return 0;
    }

    if (!AlreadyLowercase && !table->CaseSensitive) {
        dupStr = SzDuplicateW (String);
        CharLowerW (dupStr);
        String = dupStr;
    }

    existingItem = pHtFindStringW (HashTable, String, NULL, TRUE, &hashValue, &dontCare);

    if (existingItem) {

        rc = (HASHITEM) existingItem;

    } else {

        //
        // item does not exist, add it now
        //

        strSize = SzSizeW (String);

        if (table->ExternalStrings) {

            size = sizeof (BUCKETITEM_EXTERN_STR) + table->ExtraDataSize;

            externItem = (PBUCKETITEM_EXTERN_STR) FAST_MALLOC (size);
            MYASSERT (externItem);

            externItem->Locked = 0;

            externItem->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = (PBUCKETITEM) externItem;

            if (table->LastLink) {
                table->LastLink->NextLink = (PBUCKETITEM) externItem;
            }
            externItem->PrevLink = table->LastLink;
            table->LastLink = (PBUCKETITEM) externItem;
            externItem->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = (PBUCKETITEM) externItem;
            }

            rc = (HASHITEM) externItem;

        } else {

            size = sizeof (BUCKETITEM) + strSize + table->ExtraDataSize;

            item = (PBUCKETITEM) FAST_MALLOC (size);
            MYASSERT (item);

            item->Locked = 0;

            item->Next = table->Bucket[hashValue];
            table->Bucket[hashValue] = item;

            item->StringSize = (WORD) strSize;
            CopyMemory ((PBYTE) item + sizeof (BUCKETITEM), String, strSize);

            if (table->LastLink) {
                table->LastLink->NextLink = item;
            }
            item->PrevLink = table->LastLink;
            table->LastLink = item;
            item->NextLink = NULL;

            if (!table->FirstLink) {
                table->FirstLink = item;
            }

            rc = (HASHITEM) item;
        }

        strSize -= sizeof (WCHAR);
        table->MaximumStringBytes = max (table->MaximumStringBytes, strSize);
        table->MinimumStringBytes = min (table->MinimumStringBytes, strSize);
    }

    MYASSERT (rc);
    (void) HtGetExtraData (HashTable, rc, &storedDataPtr);

    if (ExtraData) {

        CopyMemory (
            (PBYTE) storedDataPtr,
            (PBYTE) ExtraData,
            table->ExtraDataSize
            );

    } else if (!existingItem) {

        ZeroMemory (
            (PBYTE) storedDataPtr,
            table->ExtraDataSize
            );
    }

    if (dupStr) {
        SzFreeW (dupStr);
    }

    return rc;
}


VOID
pRemoveHashItem (
    IN      PHASHTABLESTRUCT Table,
    IN      UINT BucketNum,
    IN      PBUCKETITEM PrevItem,
    IN      PBUCKETITEM ItemToDelete
    )
{
    if (!PrevItem) {
        MYASSERT (Table->Bucket[BucketNum] == ItemToDelete);
        Table->Bucket[BucketNum] = ItemToDelete->Next;
    } else {
        PrevItem->Next = ItemToDelete->Next;
    }

    if (ItemToDelete->PrevLink) {
        ItemToDelete->PrevLink->NextLink = ItemToDelete->NextLink;
    } else {
        Table->FirstLink = ItemToDelete->Next;
    }

    if (ItemToDelete->NextLink) {
        ItemToDelete->NextLink->PrevLink = ItemToDelete->PrevLink;
    } else {
        Table->LastLink = ItemToDelete->PrevLink;
    }

    if (ItemToDelete->Locked) {
        ItemToDelete->Next = Table->DelayedDelete;
        Table->DelayedDelete = ItemToDelete;
    } else {
        FAST_FREE (ItemToDelete);
    }
}


BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;
    PCSTR ansiStr;
    PCWSTR unicodeStr;

    if (!Item) {
        return FALSE;
    }

    //
    // Find prev bucket item
    //

    if (table->Unicode) {
        unicodeStr = HtGetStringFromItemW (Item);
        MYASSERT (unicodeStr);

        thisItem = pHtFindStringW (
                        HashTable,
                        unicodeStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    } else {
        ansiStr = HtGetStringFromItemA (Item);
        MYASSERT (ansiStr);

        thisItem = pHtFindStringA (
                        HashTable,
                        ansiStr,
                        NULL,
                        TRUE,
                        &bucketNumber,
                        &prevItem
                        );

    }

    MYASSERT (Item == thisItem);

    if (Item != thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}


BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete UNICODE table with ANSI api"));
        return FALSE;
    }

    thisItem = pHtFindStringA (
                    HashTable,
                    AnsiString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    UINT bucketNumber;
    PBUCKETITEM prevItem;
    PBUCKETITEM thisItem;

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot delete ANSI table with UNICODE api"));
        return FALSE;
    }

    thisItem = pHtFindStringW (
                    HashTable,
                    UnicodeString,
                    NULL,
                    FALSE,
                    &bucketNumber,
                    &prevItem
                    );

    if (!thisItem) {
        return FALSE;
    }

    pRemoveHashItem (table, bucketNumber, prevItem, thisItem);

    return TRUE;
}



/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if the String is in lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringA (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;
    PBUCKETITEM dontCare2;

    return (HASHITEM) pHtFindStringW (
                            HashTable,
                            String,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare,
                            &dontCare2
                            );
}


/*++

Routine Description:

  HtFindStringEx is the external entry point for pHtFindString.

Arguments:

  HashTable        - Specifies the hash table handle, as returned by
                     AllocateHashTable.
  String           - Specifies the string to find
  BufferEnd        - Specifies the end of the buffer for String
  ExtraDataBuffer  - Receives the extra data associated with the found item
  AlreadyLowercase - Specifies TRUE if String is in all lowercase

Return Value:

  A pointer to the bucket item or NULL if the string was not found.

--*/

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixA (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraDataBuffer,              OPTIONAL
    IN      BOOL AlreadyLowercase
    )
{
    UINT dontCare;

    return (HASHITEM) pHtFindPrefixW (
                            HashTable,
                            String,
                            BufferEnd,
                            ExtraDataBuffer,
                            AlreadyLowercase,
                            &dontCare
                            );
}


BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    )

/*++

Routine Description:

  HtGetExtraData gets the extra data associated with a bucket item.
  The caller must supply the ID as returned from HtFindStringEx or
  HtAddStringEx.  This routine is useful when ExtraData is large, and
  the normal find routine would be slow because of the CopyMemory code path.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Receives the extra data pointer (it does NOT copy the data to
              the buffer).

Return Value:

  TRUE if ExtraData was set, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externStrItem;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!Index) {
        return FALSE;
    }

    if (table->ExternalStrings) {

        externStrItem = (PBUCKETITEM_EXTERN_STR) Index;
        *ExtraData = (PCVOID) ((PBYTE) externStrItem + sizeof (PBUCKETITEM_EXTERN_STR));

    } else {

        item = (PBUCKETITEM) Index;
        *ExtraData = (PCVOID) ((PBYTE) item + sizeof (BUCKETITEM) + item->StringSize);

    }

    return TRUE;
}


BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraDataBuffer
    )

/*++

Routine Description:

  HtCopyStringData gets the extra data associated with a bucket item
  and copies it to the caller's buffer.

Arguments:

  HashTable       - Specifies the handle to the hash table
  Index           - Specifies the offset as returned from HtFindStringEx or
                    HtAddStringEx
  ExtraDataBuffer - Receives the extra data

Return Value:

  TRUE if ExtraDataBuffer was copied, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) ExtraDataBuffer,
        (PBYTE) storedDataPtr,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    )

/*++

Routine Description:

  HtSetStringData copies new extra data to the specified hash table entry.

Arguments:

  HashTable - Specifies the handle to the hash table
  Index     - Specifies the offset as returned from HtFindStringEx or
              HtAddStringEx
  ExtraData - Specifies the extra data

Return Value:

  TRUE if the item was updated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    PCVOID storedDataPtr;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!HtGetExtraData (HashTable, Index, &storedDataPtr)) {
        return FALSE;
    }

    CopyMemory (
        (PBYTE) storedDataPtr,
        (PBYTE) ExtraData,
        table->ExtraDataSize
        );

    return TRUE;
}


BOOL
HtEnumFirstStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    )

/*++

Routine Description:

  HtEnumFirstString begins an enumeration of the hash table structure.
  The return order is random.  Also, do not modify the hash table while an
  enumeration is active.

Arguments:

  EnumPtr   - Receives the string, extra data and offset for the first item
              in the hash table.
  HashTable - Specifies the handle of the hash table to enumerate.

Return Value:

  TRUE if an item was enumerated, FALSE otherwise.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum UNICODE table with ANSI wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));

    EnumPtr->Internal = (HASHTABLE) table;

    return HtEnumNextStringA (EnumPtr);
}


BOOL
HtEnumFirstStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (!table->Unicode) {
        DEBUGMSG ((DBG_WHOOPS, "Cannot enum ANSI table with UNICODE wrapper"));
        return FALSE;
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));

    EnumPtr->Internal = (HASHTABLE) table;

    return HtEnumNextStringW (EnumPtr);
}


BOOL
HtEnumNextStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    )

/*++

Routine Description:

  HtEnumNextString continues an enumeration started by HtEnumFirstString.
  Call the routine until it returns FALSE.

Arguments:

  EnumPtr - Specifies the structure of an active enumeration.  Receives
            updated string, extra data and offset members.

Return Value:

  TRUE if another item was enumerated, FALSE if no items remain.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


BOOL
HtEnumNextStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM_EXTERN_STR externItem;

    if (!EnumPtr->Internal) {
        return FALSE;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (!EnumPtr->Index) {
        item = table->FirstLink;
    } else {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
        item = item->NextLink;
    }

    if (item) {
        //
        // Return a valid item
        //

        item->Locked += 1;
        EnumPtr->Index = (HASHITEM) item;

        if (table->ExternalStrings) {
            externItem = (PBUCKETITEM_EXTERN_STR) item;
            EnumPtr->String = (PCWSTR) (externItem->String);
        } else {
            EnumPtr->String = (PCWSTR) ((PBYTE) item + sizeof (BUCKETITEM));
        }

        if (table->ExtraDataSize) {
            MYASSERT (EnumPtr->Index);
            (void) HtGetExtraData (EnumPtr->Internal, EnumPtr->Index, &EnumPtr->ExtraData);
        }

        return TRUE;
    }

    EnumPtr->Internal = 0;

    return FALSE;
}


VOID
AbortHashTableEnumA (
    IN      PHASHTABLE_ENUMA EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM nextItem;
    PBUCKETITEM prevItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                FAST_FREE (item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMA));
}


VOID
AbortHashTableEnumW (
    IN      PHASHTABLE_ENUMW EnumPtr
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) EnumPtr->Internal;
    PBUCKETITEM item;
    PBUCKETITEM prevItem;
    PBUCKETITEM nextItem;

    if (!EnumPtr->Internal) {
        return;
    }

    ASSERT_TABLE_IS_VALID (EnumPtr->Internal);

    if (EnumPtr->Index) {
        item = (PBUCKETITEM) EnumPtr->Index;
        item->Locked -= 1;
        MYASSERT (item->Locked >= 0);
    }

    //
    // Evaluate delayed delete items; remove those that are no longer locked
    //

    if (table->DelayedDelete) {
        item = table->DelayedDelete;
        prevItem = NULL;

        while (item) {

            nextItem = item->Next;

            if (!item->Locked) {
                FAST_FREE (item);
            } else {
                if (prevItem) {
                    prevItem->Next = item;
                } else {
                    table->DelayedDelete = item;
                }

                prevItem = item;
            }

            item = nextItem;
        }

        if (prevItem) {
            prevItem->Next = NULL;
        } else {
            table->DelayedDelete = NULL;
        }
    }

    ZeroMemory (EnumPtr, sizeof (HASHTABLE_ENUMW));
}


BOOL
HtEnumWithCallbackA (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  HtEnumWithCallback implements a setupapi-style enumerator.  The callback
  routine is called for each item in the string table, and if the callback
  routine returns FALSE, the enumeration ends.

Arguments:

  HashTable - Specifies the handle to the table to enumerate
  Proc      - Specifies the callback procedure address
  lParam    - Specifies a value to pass to the callback, and is intended only
              for use by the caller.

Return Value:

  Always TRUE.

--*/

{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMA e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (HtEnumFirstStringA (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumA (&e);
                break;
            }
        } while (HtEnumNextStringA (&e));
    }

    return TRUE;
}


BOOL
HtEnumWithCallbackW (
    IN      HASHTABLE HashTable,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    )
{
    PHASHTABLESTRUCT table = (PHASHTABLESTRUCT) HashTable;
    HASHTABLE_ENUMW e;

    ASSERT_TABLE_IS_VALID (HashTable);

    if (HtEnumFirstStringW (&e, HashTable)) {
        do {
            if (!Proc (HashTable, e.Index, e.String, (PVOID) e.ExtraData, table->ExtraDataSize, lParam)) {
                AbortHashTableEnumW (&e);
                break;
            }
        } while (HtEnumNextStringW (&e));
    }

    return TRUE;
}


PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}


PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Item
    )
{
    if (!Item) {
        return NULL;
    }

    return (PCWSTR) ((PBYTE) Item + sizeof (BUCKETITEM));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\unicode.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    unicode.c

Abstract:

    Simplified Unicode-Ansi conversion functions.

Author:

    Jim Schmidt (jimschm)   03-Aug-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "commonp.h"

static WORD g_GlobalCodePage = CP_ACP;
static DWORD g_WToAFlags;
static DWORD g_AToWFlags;

PWSTR
SzConvertBufferBytesAToW (
    OUT     PWSTR OutputBuffer,
    IN      PCSTR InputString,
    IN      UINT ByteCountInclNul
    )
{
    INT rc;
    DWORD flags;

    if (g_GlobalCodePage == CP_UTF8) {
        flags = 0;
    } else {
        flags = g_AToWFlags;
    }

    rc = MultiByteToWideChar (
            g_GlobalCodePage,
            flags,
            InputString,
            ByteCountInclNul,
            OutputBuffer,
            ByteCountInclNul * 2
            );

    if (!rc && ByteCountInclNul) {
        return NULL;
    }

    return OutputBuffer + rc;
}


PSTR
SzConvertBufferBytesWToA (
    OUT     PSTR OutputBuffer,
    IN      PCWSTR InputString,
    IN      UINT ByteCountInclNul
    )
{
    INT rc;
    DWORD flags;
    UINT logicalChars;

    if (g_GlobalCodePage == CP_UTF8) {
        flags = 0;
    } else {
        flags = g_WToAFlags;
    }

    logicalChars = ByteCountInclNul / sizeof (WCHAR);

    rc = WideCharToMultiByte (
            g_GlobalCodePage,
            flags,
            InputString,
            logicalChars,
            OutputBuffer,
            logicalChars * 3,
            NULL,
            NULL
            );

    if (!rc && logicalChars) {
        return NULL;
    }

    return (PSTR) ((PBYTE) OutputBuffer + rc);
}


PWSTR
RealSzConvertBytesAToW (
    IN      PCSTR AnsiString,
    IN      UINT ByteCountInclNul
    )
{
    PWSTR alloc;
    PWSTR result;
    DWORD error;

    alloc = SzAllocW (ByteCountInclNul);
    result = SzConvertBufferBytesAToW (alloc, AnsiString, ByteCountInclNul);

    if (!result) {
        error = GetLastError();
        SzFreeW (alloc);
        SetLastError (error);
    }

    return alloc;
}


PSTR
RealSzConvertBytesWToA (
    IN      PCWSTR UnicodeString,
    IN      UINT ByteCountInclNul
    )
{
    PSTR alloc;
    PSTR result;
    DWORD error;
    UINT logicalChars;

    logicalChars = ByteCountInclNul / sizeof (WCHAR);

    alloc = SzAllocA (logicalChars);
    result = SzConvertBufferBytesWToA (alloc, UnicodeString, ByteCountInclNul);

    if (!result) {
        error = GetLastError();
        SzFreeA (alloc);
        SetLastError (error);
    }

    return alloc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\log.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Tools for logging problems for the user.


Author:

    Jim Schmidt (jimschm)  23-Jan-1997

Revisions:

    ovidiut     08-Oct-1999 Updated for new coding conventions and Win64 compliance
    ovidiut     23-Oct-1998 Implemented a new log mechanism and added new logging capabilities
    marcw       2-Sep-1999  Moved over from Win9xUpg project.
    ovidiut     15-Mar-2000 Eliminate dependencies on HashTable/PoolMemory

--*/


#include "pch.h"
#include "commonp.h"

//
// Includes
//

// None

//
// Strings
//

#define S_COLUMNDOUBLELINEA     ":\r\n\r\n"
#define S_COLUMNDOUBLELINEW     L":\r\n\r\n"
#define S_NEWLINEA              "\r\n"
#define S_NEWLINEW              L"\r\n"
#define DEBUG_SECTION           "Debug"
#define ENTRY_ALL               "All"
#define ENTRY_DEFAULTOVERRIDE   "DefaultOverride"

//
// Constants
//

#define OUTPUT_BUFSIZE_LARGE    8192
#define OUTPUT_BUFSIZE_SMALL    1024
#define MAX_MSGTITLE_LEN        13
#define MSGBODY_INDENT          14
#define SCREEN_WIDTH            80
#define MAX_TYPE                32
#define TYPE_ARRAY_SIZE         10

//
// Macros
//

#define OUT_UNDEFINED(OutDest)      (OutDest == OD_UNDEFINED)
#define OUT_DEBUGLOG(OutDest)       ((OutDest & OD_DEBUGLOG) != 0)
#define OUT_SUPPRESSED(OutDest)     ((OutDest & OD_SUPPRESS) != 0)
#define OUT_NO_OUTPUT(OutDest)      (OUT_UNDEFINED(OutDest) || OUT_SUPPRESSED(OutDest))
#define OUT_ERROR(OutDest)          ((OutDest & OD_ERROR) != 0)
#define OUT_LOGFILE(OutDest)        ((OutDest & OD_LOGFILE) != 0)
#define OUT_DEBUGGER(OutDest)       ((OutDest & OD_DEBUGGER) != 0)
#define OUT_CONSOLE(OutDest)        ((OutDest & OD_CONSOLE) != 0)
#define OUT_POPUP(OutDest)          ((OutDest & (OD_POPUP|OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define OUT_POPUP_CANCEL(OutDest)   ((OutDest & (OD_POPUP_CANCEL|OD_FORCE_POPUP)) == OD_POPUP_CANCEL)
#define OUT_FORCED_POPUP(OutDest)   ((OutDest & (OD_FORCE_POPUP|OD_UNATTEND_POPUP)) != 0)
#define MUST_BE_LOCALIZED(OutDest)  ((OutDest & OD_MUST_BE_LOCALIZED) == OD_MUST_BE_LOCALIZED)
#define OUT_ASSERT(OutDest)         ((OutDest & OD_ASSERT) != 0)

#ifdef DEBUG
    #define DEFAULT_ERROR_FLAGS  (OD_DEBUGLOG | OD_LOGFILE | OD_POPUP | OD_ERROR | OD_UNATTEND_POPUP | OD_ASSERT)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP)
#else
    #define DEFAULT_ERROR_FLAGS  (OD_LOGFILE | OD_POPUP | OD_ERROR | OD_MUST_BE_LOCALIZED)
    #define USER_POPUP_FLAGS     (OD_FORCE_POPUP | OD_MUST_BE_LOCALIZED)
#endif

#define END_OF_BUFFER(buf)      ((buf) + (sizeof(buf) / sizeof(buf[0])) - 1)

// This constant sets the default output
#ifndef DEBUG
    #define NORMAL_DEFAULT      OD_LOGFILE
#else
    #define NORMAL_DEFAULT      OD_DEBUGLOG
#endif

#ifdef DEBUG
    #define PRIVATE_ASSERT(expr)        pPrivateAssert(expr,#expr,__LINE__);
#else
    #define PRIVATE_ASSERT(expr)
#endif // DEBUG

#define NEWLINE_CHAR_COUNTA  (sizeof (S_NEWLINEA) / sizeof (CHAR) - 1)
#define NEWLINE_CHAR_COUNTW  (sizeof (S_NEWLINEW) / sizeof (WCHAR) - 1)

//
// Types
//

typedef DWORD   OUTPUTDEST;

typedef struct {
    PCSTR Value;               // string value entered by the user (LOG,POPUP,SUPPRESS etc.)
    OUTPUTDEST OutDest;        // any combination of OutDest flags
} STRING2BINARY, *PSTRING2BINARY;

typedef struct {
    PCSTR Type;
    DWORD Flags;
} DEFAULT_DESTINATION, *PDEFAULT_DESTINATION;

typedef struct {
    CHAR Type[MAX_TYPE];
    DWORD OutputDest;
} MAPTYPE2OUTDEST, *PMAPTYPE2OUTDEST;

//
// Globals
//

const STRING2BINARY g_String2Binary[] = {
    "SUPPRESS", OD_SUPPRESS,
    "LOG",      OD_LOGFILE,
    "POPUP",    OD_POPUP,
    "DEBUGGER", OD_DEBUGGER,
    "CONSOLE",  OD_CONSOLE,
    "ERROR",    OD_ERROR,
    "NOCANCEL", OD_FORCE_POPUP,
    "ASSERT",   OD_ASSERT
};

const PCSTR g_IgnoreKeys[] = {
    "Debug",
    "KeepTempFiles"
};

BOOL g_LogInit;
HMODULE g_LibHandle;
CHAR g_MainLogFile [MAX_PATH] = "";
HANDLE g_LogMutex;
INT g_LoggingNow;

// a window handle for popup parent
HWND g_LogPopupParentWnd = NULL;
// thread id that set this window handle
DWORD g_InitThreadId = 0;
DWORD g_LogError;

//
// type table elements
//
PMAPTYPE2OUTDEST g_FirstTypePtr = NULL;
DWORD g_TypeTableCount = 0;
DWORD g_TypeTableFreeCount = 0;

OUTPUTDEST g_OutDestAll = OD_UNDEFINED;
OUTPUTDEST g_OutDestDefault = NORMAL_DEFAULT;
BOOL g_HasTitle = FALSE;
CHAR g_LastType [MAX_TYPE];
BOOL g_SuppressAllPopups = FALSE;
BOOL g_ResetLog = FALSE;
PLOGCALLBACKA g_LogCallbackA;
PLOGCALLBACKW g_LogCallbackW;

#ifdef DEBUG

CHAR g_DebugInfPathBufA[] = "C:\\debug.inf";
CHAR g_DebugLogFile[MAX_PATH];
// If g_DoLog is TRUE, then, debug logging is enabled in the
// checked build even if there is no debug.inf.
BOOL g_DoLog = FALSE;

DWORD g_FirstTickCount = 0;
DWORD g_LastTickCount  = 0;

#endif

//
// Macro expansion list
//

#ifndef DEBUG

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_MODULE_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)          \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_STATUS, OD_SUPPRESS)                                         \

#else

    #define TYPE_DEFAULTS                                                       \
        DEFMAC(LOG_FATAL_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)           \
        DEFMAC(LOG_MODULE_ERROR, DEFAULT_ERROR_FLAGS|USER_POPUP_FLAGS)          \
        DEFMAC(LOG_ERROR, DEFAULT_ERROR_FLAGS)                                  \
        DEFMAC(DBG_WHOOPS,  DEFAULT_ERROR_FLAGS)                                \
        DEFMAC(DBG_WARNING, OD_LOGFILE|OD_DEBUGGER)                             \
        DEFMAC(DBG_ASSERT,DEFAULT_ERROR_FLAGS|OD_UNATTEND_POPUP)                \
        DEFMAC(LOG_INFORMATION, OD_LOGFILE)                                     \
        DEFMAC(LOG_STATUS, OD_SUPPRESS)                                         \

#endif


//
// Private function prototypes
//

VOID
InitializeLog (
    VOID
    );


BOOL
pWriteFileStringA (
    IN      HANDLE File,
    IN      PCSTR String
    )

/*++

Routine Description:

  Writes a DBCS string to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the nul-terminated string to write to the file.

Return Value:

  TRUE if successful, FALSE if an error occurred.  Call GetLastError
  for error condition.

--*/

{
    DWORD DontCare;

    return WriteFile (File, String, SzByteCountA (String), &DontCare, NULL);
}


BOOL
pWriteFileStringW (
    IN      HANDLE File,
    IN      PCWSTR String
    )

/*++

Routine Description:

  Converts a UNICODE string to DBCS, then Writes it to the specified file.

Arguments:

  File - Specifies the file handle that was opened with write access.

  String - Specifies the UNICODE nul-terminated string to convert and
           write to the file.

Return Value:

 TRUE if successful, FALSE if an error occurred.  Call GetLastError for
 error condition.

--*/

{
    DWORD DontCare;
    PCSTR AnsiVersion;
    BOOL b;

    AnsiVersion = SzConvertWToA (String);
    if (!AnsiVersion) {
        return FALSE;
    }

    b = WriteFile (File, AnsiVersion, SzByteCountA (AnsiVersion), &DontCare, NULL);

    SzFreeA (AnsiVersion);

    return b;
}


//
// Macro expansion definition
//

/*++

Macro Expansion List Description:

  TYPE_DEFAULTS specify the default destination for the frequently used types,
  such as LOG_ERROR, LOG_FATAL_ERROR, and so on.

Line Syntax:

   DEFMAC(TypeString, Flags)

Arguments:

   TypeString - Specifies the LOG_ constant as defined in log.h

   Flags - One or more of:

           DEFAULT_ERROR_FLAGS - Specifies debug log, setup log, debugger,
                                 popup, and the value of GetLastError.

           OD_DEBUGLOG - Specifies the debug log

           OD_ERROR - Specifies type is an error (gets value of
                      GetLastError)

           OD_SUPPRESS - Suppresses all output for the type

           OD_LOGFILE - Specifies the setup log

           OD_DEBUGGER - Specifies the debugger (i.e., VC or remote debugger)

           OD_CONSOLE - Specifies the console (via printf)

           OD_POPUP - Specifies a message box

           OD_FORCE_POPUP - Specifies a message box, even if debug message
                            was turned off via a click on Cancel

           OD_MUST_BE_LOCALIZED - Indicates the type must originate from a
                                  localized message; used for LOG() calls that
                                  generate popups.  (So English messages
                                  don't sneak into the project.)

           OD_UNATTEND_POPUP - Causes popup even in unattend mode

           OD_ASSERT - Give DebugBreak option in popup

Variables Generated From List:

    g_DefaultDest

--*/

#define DEFMAC(typestr, flags)      {typestr, (flags)},

DEFAULT_DESTINATION g_DefaultDest[] = {
    TYPE_DEFAULTS /* , */
    {NULL, 0}
};

#undef DEFMAC


//
// Code
//


#ifdef DEBUG

VOID
pPrivateAssert (
    IN      BOOL Expr,
    IN      PCSTR StringExpr,
    IN      UINT Line
    )
{
    CHAR buffer[256];

    if (Expr) {
        return;
    }

    wsprintfA (buffer, "LOG FAILURE: %s (log.c line %u)", StringExpr, Line);
    MessageBoxA (NULL, buffer, NULL, MB_OK);
}

#endif


BOOL
pIgnoreKey (
    IN      PCSTR Key
    )

/*++

Routine Description:

  pIgnoreKey decides if a key from [debug] section of DEBUG.INF
  should be ignored for our purposes (we are only looking for
  <All>, <DefaultOverride> and log/debug types).
  Specifically, we ignore all keywords in <g_IgnoreKeys> table.

Arguments:

  Key - Specifies the key from [debug] section of DEBUG.INF

Return Value:

  TRUE if the key should be ignored, or FALSE if it will be taken into consideration.

--*/

{
    UINT i;

    for (i = 0; i < sizeof (g_IgnoreKeys) / sizeof (PCSTR); i++) {
        if (SzIMatchA (Key, g_IgnoreKeys[i])) {
            return TRUE;
        }
    }

    return FALSE;
}


OUTPUTDEST
pConvertToOutputType (
    IN      PCSTR Value
    )

/*++

Routine Description:

  pConvertToOutputType converts a text value entered by the user in
  DEBUG.INF file, associated with a type (e.g. "LOG", "POPUP" etc.).

Arguments:

  Value - Specifies the text value

Return Value:

  The OUTPUT_DESTINATION value associated with the given value or
  OD_UNDEFINED if the value is not valid.

--*/

{
    UINT i;

    for (i = 0; i < sizeof (g_String2Binary) / sizeof (STRING2BINARY); i++) {
        if (SzIMatchA (Value, g_String2Binary[i].Value)) {
            return g_String2Binary[i].OutDest;
        }
    }

    return OD_UNDEFINED;
}


OUTPUTDEST
pGetTypeOutputDestFromTable (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDestFromTable returns the output destination associated
  with the specified type in the global table

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    PMAPTYPE2OUTDEST typePtr;
    PMAPTYPE2OUTDEST last;
    OUTPUTDEST outDest = OD_UNDEFINED;

    if (g_FirstTypePtr) {
        typePtr = g_FirstTypePtr;
        last = g_FirstTypePtr + g_TypeTableCount;
        while (typePtr < last) {
            if (SzIMatchA (typePtr->Type, Type)) {
                outDest = typePtr->OutputDest;
#ifdef DEBUG
                if (g_DoLog) {
                    outDest |= OD_DEBUGLOG;
                }
#endif
                break;
            }
            typePtr++;
        }
    }

    return outDest;
}


OUTPUTDEST
pGetTypeOutputDest (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetTypeOutputDest returns the default output
  destination for the specified type.

Arguments:

  Type - Specifies the type

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given type.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check for ALL
    //

    if (!OUT_UNDEFINED (g_OutDestAll)) {
        outDest = g_OutDestAll;
    } else {

        //
        // otherwise try to get it from the table
        //

        outDest = pGetTypeOutputDestFromTable (Type);
        if (OUT_UNDEFINED (outDest)) {

            //
            // just return the default
            //

            outDest = g_OutDestDefault;
        }
    }

#ifdef DEBUG
    if (g_DoLog) {
        outDest |= OD_DEBUGLOG;
    }
#endif


    return outDest;
}


BOOL
pIsPopupEnabled (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pIsPopupEnabled decides if the type should produce a popup output. The user may
  disable popup display for a type.

Arguments:

  Type - Specifies the type

Return Value:

  TRUE if the type should display a popup message.

--*/

{
    OUTPUTDEST outDest;

    //
    // first check if any specific output is available for this type,
    // and if so, check if the OUT_POPUP_CANCEL flag is not set
    //

    if (g_SuppressAllPopups) {
        return FALSE;
    }

    outDest = pGetTypeOutputDestFromTable (Type);
    if (OUT_POPUP_CANCEL (outDest)) {
        return FALSE;
    }

    // just return the popup type of ALL of DefaultOverride
    return OUT_POPUP (pGetTypeOutputDest (Type));
}


LOGSEVERITY
pGetSeverityFromType (
    IN      PCSTR Type
    )

/*++

Routine Description:

  pGetSeverityFromType converts a type to a default severity
  that will be used by the debug log system.

Arguments:

  Type - Specifies the type

Return Value:

  The default log severity associated with the given type; if the specified
  type is not found, it returns LOGSEV_INFORMATION.

--*/

{
    if (OUT_ERROR (pGetTypeOutputDest (Type))) {
        return LOGSEV_ERROR;
    }

    return LOGSEV_INFORMATION;
}


BOOL
LogSetErrorDest (
    IN      PCSTR Type,
    IN      OUTPUT_DESTINATION OutDest
    )

/*++

Routine Description:

  LogSetErrorDest adds a <Type, OutDest> association
  to the table g_FirstTypePtr. If an association of Type already exists,
  it is modified to reflect the new association.

Arguments:

  Type - Specifies the log/debug type string

  OutDest - Specifies what new destination(s) are associated with the type

Return Value:

  TRUE if the association was successful and the Type is now in the table

--*/

{
    PMAPTYPE2OUTDEST typePtr;
    UINT u;

    //
    // Try to locate the existing type
    //

    for (u = 0 ; u < g_TypeTableCount ; u++) {
        typePtr = g_FirstTypePtr + u;
        if (SzIMatchA (typePtr->Type, Type)) {
            typePtr->OutputDest = OutDest;
            return TRUE;
        }
    }

    //
    // look if any free slots are available first
    //
    if (!g_TypeTableFreeCount) {

        PRIVATE_ASSERT (g_hHeap != NULL);

        if (!g_FirstTypePtr) {
            typePtr = HeapAlloc (
                            g_hHeap,
                            0,
                            sizeof (MAPTYPE2OUTDEST) * TYPE_ARRAY_SIZE
                            );
        } else {
            typePtr = HeapReAlloc (
                            g_hHeap,
                            0,
                            g_FirstTypePtr,
                            sizeof (MAPTYPE2OUTDEST) * (TYPE_ARRAY_SIZE + g_TypeTableCount)
                            );
        }

        if (!typePtr) {
            return FALSE;
        }

        g_FirstTypePtr = typePtr;
        g_TypeTableFreeCount = TYPE_ARRAY_SIZE;
    }

    typePtr = g_FirstTypePtr + g_TypeTableCount;
    SzCopyBytesA (typePtr->Type, Type, sizeof (typePtr->Type));
    typePtr->OutputDest = OutDest;

    g_TypeTableCount++;
    g_TypeTableFreeCount--;

    return TRUE;
}


OUTPUTDEST
pGetAttributes (
    IN OUT  PINFCONTEXT InfContext
    )

/*++

Routine Description:

  pGetAttributes converts the text values associated with the key on
  the line specified by the given context. If multiple values are
  specified, the corresponding OUTPUT_DESTINATION values are ORed together
  in the return value.

Arguments:

  InfContext - Specifies the DEBUG.INF context of the key whose values
               are being converted and receives the updated context
               after this processing is done

Return Value:

  Any combination of enum OUTPUT_DESTINATION values associated with
  the given key.

--*/

{
    OUTPUTDEST outDest = OD_UNDEFINED;
    CHAR value[OUTPUT_BUFSIZE_SMALL];
    UINT field;

/* BUGBUG - eliminate setupapi
    for (field = SetupGetFieldCount (InfContext); field > 0; field--) {
        if (SetupGetStringFieldA (
                InfContext,
                field,
                value,
                OUTPUT_BUFSIZE_SMALL,
                NULL
                )) {
            outDest |= pConvertToOutputType(value);
        }
    }
*/
    return outDest;
}


BOOL
pGetUserPreferences (
    IN      HINF Inf
    )

/*++

Routine Description:

  pGetUserPreferences converts user's options specified in the given Inf file
  (usually DEBUG.INF) and stores them in g_FirstTypePtr table. If <All> and
  <DefaultOverride> entries are found, their values are stored in OutputTypeAll
  and OutputTypeDefault, respectivelly, if not NULL.

Arguments:

  Inf - Specifies the open inf file hanlde to process

  OutputTypeAll - Receives the Output Dest for the special <All> entry

  OutputTypeDefault - Receives the Output Dest for the special <DefaultOverride> entry

Return Value:

  TRUE if the processing of the INF file was OK.

--*/

{
    INFCONTEXT infContext;
    OUTPUTDEST outDest;
    CHAR key[OUTPUT_BUFSIZE_SMALL];

/* BUGBUG - eliminate setupapi
    if (SetupFindFirstLineA (Inf, DEBUG_SECTION, NULL, &infContext)) {

        do {
            // check to see if this key is not interesting
            if (!SetupGetStringFieldA (
                    &infContext,
                    0,
                    key,
                    OUTPUT_BUFSIZE_SMALL,
                    NULL
                    )) {
                continue;
            }

            if (pIgnoreKey (key)) {
                continue;
            }

            // check for special cases
            if (SzIMatchA (key, ENTRY_ALL)) {
                g_OutDestAll = pGetAttributes (&infContext);
                // no reason to continue since ALL types will take this setting...
                break;
            } else {
                if (SzIMatchA (key, ENTRY_DEFAULTOVERRIDE)) {
                    g_OutDestDefault = pGetAttributes(&infContext);
                } else {
                    outDest = pGetAttributes(&infContext);
                    // lines like <Type>=   or like <Type>=<not a keyword(s)>  are ignored
                    if (!OUT_UNDEFINED (outDest)) {
                        if (!LogSetErrorDest (key, outDest)) {
                            return FALSE;
                        }
                    }
                }
            }
        } while (SetupFindNextLine (&infContext, &infContext));
    }
*/

    return TRUE;
}


/*++

Routine Description:

  pPadTitleA and pPadTitleW append to Title a specified number of spaces.

Arguments:

  Title - Specifies the title (it will appear on the left column).
          The buffer must be large enough to hold the additional spaces
  Indent  - Specifies the indent of the message body. If necessary,
            spaces will be appended to the Title to get to Indent column.

Return Value:

  none

--*/

VOID
pPadTitleA (
    IN OUT  PSTR Title,
    IN      UINT Indent
    )

{
    UINT i;
    PSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = SzByteCountA (Title), p = SzGetEndA (Title); i < Indent; i++) {
        *p++ = ' '; //lint !e613 !e794
    }

    *p = 0; //lint !e613 !e794
}


VOID
pPadTitleW (
    IN OUT  PWSTR Title,
    IN      UINT  Indent
    )
{
    UINT i;
    PWSTR p;

    if (Title == NULL) {
        return;
    }

    for (i = SzTcharCountW (Title), p = SzGetEndW (Title); i < Indent; i++) {
        *p++ = L' ';    //lint !e613
    }

    *p = 0; //lint !e613
}


/*++

Routine Description:

  pFindNextLineA and pFindNextLineW return the position where
  the next line begins

Arguments:

  Line - Specifies the current line

  Indent  - Specifies the indent of the message body. The next line
            will start preferably after a newline or a white space,
            but no further than the last column, which is
            SCREEN_WIDTH - Indent.

Return Value:

  The position of the first character on the next line.

--*/

PCSTR
pFindNextLineA (
    IN      PCSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCSTR lastSpace = NULL;
    PCSTR prevLine = Line;
    UINT ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = _mbsnextc (Line)) != 0 && column < columnMax) {

        if (ch == '\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
            column++;
        } else {
            if (_ismbcspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line = _mbsinc (Line);
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space or 2-byte char was found
        lastSpace = prevLine;
    }

    if (ch != '\n') {
        *TrimLeadingSpace = TRUE;
    }

    return _mbsinc (lastSpace);
}


PCWSTR
pFindNextLineW (
    IN      PCWSTR Line,
    IN      UINT Indent,
    OUT     PBOOL TrimLeadingSpace
    )
{
    UINT column = 0;
    UINT columnMax = SCREEN_WIDTH - 1 - Indent;
    PCWSTR lastSpace = NULL;
    PCWSTR prevLine = Line;
    WCHAR ch;

    *TrimLeadingSpace = FALSE;

    while ( (ch = *Line) != 0 && column < columnMax) {

        if (ch == L'\n') {
            lastSpace = Line;
            break;
        }

        if (ch > 255) {
            lastSpace = Line;
        } else {
            if (iswspace (ch)) {
                lastSpace = Line;
            }
        }

        column++;
        prevLine = Line;
        Line++;
    }

    if (ch == 0) {
        return Line;
    }

    if (lastSpace == NULL) {
        // we must cut this even if no white space was found
        lastSpace = prevLine;
    }

    if (ch != L'\n') {
        *TrimLeadingSpace = TRUE;
    }

    return lastSpace + 1;
}


/*++

Routine Description:

  pHangingIndentA and pHangingIndentW break in lines and indent
  the text in buffer, which is no larger than Size.

Arguments:

  buffer - Specifies the buffer containing text to format. The resulting
           text will be put in the same buffer

  Size  - Specifies the size of this buffer, in bytes

  Indent  - Specifies the indent to be used by all new generated lines.

Return Value:

  none

--*/

VOID
pHangingIndentA (
    IN OUT  PSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    CHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCSTR nextLine;
    PCSTR s;
    PSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 3;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PSTR)pFindNextLineA (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case '\r':
                s++;
                if (*s == '\r') {
                    continue;
                } else if (*s != '\n') {
                    s--;
                }

                // fall through

            case '\n':
                *d++ = '\r';
                *d++ = '\n';
                s++;
                break;

            default:
                if (isleadbyte (*s)) {
                    *d++ = *s++;
                }
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == ' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = ' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    SzCopyBytesA (buffer, indentBuffer, Size);
}


VOID
pHangingIndentW (
    IN OUT  PWSTR buffer,
    IN      DWORD Size,
    IN      UINT Indent
    )
{
    WCHAR indentBuffer[OUTPUT_BUFSIZE_LARGE];
    PCWSTR nextLine;
    PCWSTR s;
    PWSTR d;
    UINT i;
    BOOL trimLeadingSpace;
    PCWSTR endOfBuf;
    BOOL appendNewLine = FALSE;

    nextLine = buffer;
    s = buffer;
    d = indentBuffer;

    endOfBuf = END_OF_BUFFER(indentBuffer) - 1;

    while (*s && d < endOfBuf) {

        //
        // Find end of next line
        //

        nextLine = (PWSTR)pFindNextLineW (s, Indent, &trimLeadingSpace);

        //
        // Copy one line from source to dest
        //

        while (s < nextLine && d < endOfBuf) {

            switch (*s) {

            case L'\r':
                s++;
                if (*s == L'\r') {
                    continue;
                } else if (*s != L'\n') {
                    s--;
                }

                // fall through

            case L'\n':
                *d++ = L'\r';
                *d++ = L'\n';
                s++;
                break;

            default:
                *d++ = *s++;
                break;
            }
        }

        //
        // Trim leading space if necessary
        //

        if (trimLeadingSpace) {
            while (*s == L' ') {
                s++;
            }
        }

        if (*s) {

            //
            // If another line, prepare an indent and insert a new line
            // after this multiline message
            //

            appendNewLine = TRUE;

            if (d < endOfBuf && trimLeadingSpace) {
                *d++ = L'\r';
                *d++ = L'\n';
            }

            for (i = 0 ; i < Indent && d < endOfBuf ; i++) {
                *d++ = L' ';
            }
        }
    }

    if (appendNewLine && d < endOfBuf) {
        *d++ = L'\r';
        *d++ = L'\n';
    }

    // make sure the string is zero-terminated
    PRIVATE_ASSERT (d <= END_OF_BUFFER(indentBuffer));
    *d = 0;

    // copy the result to output buffer
    SzCopyTcharsW (buffer, indentBuffer, Size);
}


/*++

Routine Description:

  pAppendLastErrorA and pAppendLastErrorW append the specified error code
  to the Message and writes the output to the MsgWithErr buffer.

Arguments:

  MsgWithErr  - Receives the formatted message. This buffer
                is supplied by caller

  BufferSize  - Specifies the size of the buffer, in bytes

  Message  - Specifies the body of the message

  LastError  - Specifies the error code that will be appended

Return Value:

  none

--*/

VOID
pAppendLastErrorA (
    OUT     PSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCSTR Message,
    IN      DWORD LastError
    )
{
    PSTR append;
    DWORD errMsgLen;

    SzCopyBytesA (MsgWithErr, Message, BufferSize);
    append = SzGetEndA (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + BufferSize - append);  //lint !e613

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snprintf (append, errMsgLen, " [ERROR=%lu]", LastError);
        } else {
            _snprintf (append, errMsgLen, " [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


VOID
pAppendLastErrorW (
    OUT     PWSTR MsgWithErr,
    IN      DWORD BufferSize,
    IN      PCWSTR Message,
    IN      DWORD LastError
    )
{
    PWSTR append;
    DWORD errMsgLen;

    SzCopyTcharsW (MsgWithErr, Message, BufferSize / sizeof(WCHAR));
    append = SzGetEndW (MsgWithErr);
    errMsgLen = (DWORD)(MsgWithErr + (BufferSize / sizeof(WCHAR)) - append);

    if (errMsgLen > 0) {
        if (LastError < 10) {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu]", LastError);
        } else {
            _snwprintf (append, errMsgLen, L" [ERROR=%lu (%lXh)]", LastError, LastError);
        }
    }
}


/*++

Routine Description:

  pIndentMessageA and pIndentMessageW format the specified message
  with the type in the left column and body of the message in the right.

Arguments:

  formattedMsg  - Receives the formatted message. This buffer
                  is supplied by caller

  BufferSize  - Specifies the size of the buffer

  Type  - Specifies the type of the message

  Body  - Specifies the body of the message

  Indent  - Specifies the column to indent to

  LastError  - Specifies the last error code if different than ERROR_SUCCESS;
               in this case it will be appended to the message

Return Value:

  none

--*/

VOID
pIndentMessageA (
    OUT     PSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    CHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCSTR myMsgBody;
    PSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorA (bodyWithErr, sizeof (bodyWithErr), Body, LastError);
    }

    SzCopyBytesA (formattedMsg, Type, MAX_MSGTITLE_LEN);
    pPadTitleA (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    SzCopyBytesA (currentPos, myMsgBody, remaining);
    pHangingIndentA (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = SzGetEndA (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTA + 1 < formattedMsg + BufferSize) { //lint !e613
        *currentPos++ = '\r';   //lint !e613
        *currentPos++ = '\n';   //lint !e613
        *currentPos = 0;        //lint !e613
    }
}


VOID
pIndentMessageW (
    OUT     PWSTR formattedMsg,
    IN      DWORD BufferSize,
    IN      PCSTR Type,
    IN      PCWSTR Body,
    IN      UINT Indent,
    IN      DWORD LastError
    )
{
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];
    WCHAR bodyWithErr[OUTPUT_BUFSIZE_LARGE];
    PCWSTR myMsgBody;
    PWSTR currentPos;
    DWORD remaining;

    myMsgBody = Body;
    remaining = BufferSize - Indent;

    if (LastError != ERROR_SUCCESS) {

        myMsgBody = bodyWithErr;

        pAppendLastErrorW (bodyWithErr, sizeof (bodyWithErr), Body, LastError);
    }

    SzConvertBufferAToW (typeW, Type);

    SzCopyTcharsW (formattedMsg, typeW, MAX_MSGTITLE_LEN);
    pPadTitleW (formattedMsg, Indent);

    currentPos = formattedMsg + Indent;
    SzCopyTcharsW (currentPos, myMsgBody, remaining);
    pHangingIndentW (currentPos, remaining, Indent);

    // append a new line if space left
    currentPos = SzGetEndW (currentPos);
    if (currentPos + NEWLINE_CHAR_COUNTW + 1 < formattedMsg + BufferSize) {
        *currentPos++ = L'\r';
        *currentPos++ = L'\n';
        *currentPos = 0;
    }
}


PCSTR
pGetSeverityStr (
    IN      LOGSEVERITY Severity,
    IN      BOOL Begin
    )
{
    switch (Severity) {
    case LogSevFatalError:
        return Begin?"":"\r\n***";
    case LogSevError:
        return Begin?"":"\r\n***";
    case LogSevWarning:
        return "";
    }
    return "";
}

/*++

Routine Description:

  pWriteToMainLogA and pWriteToMainLogW log the specified message to the main
  end-user log.

Arguments:

  Severity  - Specifies the severity of the message, as defined by the Setup API

  formattedMsg  - Specifies the message

Return Value:

  none

--*/


VOID
pWriteToMainLogA (
    IN      PCSTR Type,
    IN      LOGSEVERITY Severity,
    IN      PCSTR FormattedMsg
    )
{
    HANDLE logHandle = NULL;

    logHandle = CreateFileA (
                    g_MainLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (logHandle != INVALID_HANDLE_VALUE) {
        SetFilePointer (logHandle, 0, NULL, FILE_END);
        pWriteFileStringA (logHandle, pGetSeverityStr (Severity, TRUE));
        pWriteFileStringA (logHandle, FormattedMsg);
        pWriteFileStringA (logHandle, pGetSeverityStr (Severity, FALSE));
        CloseHandle (logHandle);
    }
}


VOID
pWriteToMainLogW (
    IN      PCSTR Type,
    IN      LOGSEVERITY Severity,
    IN      PCWSTR FormattedMsg
    )
{
    HANDLE logHandle = NULL;

    logHandle = CreateFileA (
                    g_MainLogFile,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );
    if (logHandle != INVALID_HANDLE_VALUE) {
        SetFilePointer (logHandle, 0, NULL, FILE_END);
        pWriteFileStringA (logHandle, pGetSeverityStr (Severity, TRUE));
        pWriteFileStringW (logHandle, FormattedMsg);
        pWriteFileStringA (logHandle, pGetSeverityStr (Severity, FALSE));
        CloseHandle (logHandle);
    }
}


/*++

Routine Description:

  pDisplayPopupA and pDisplayPopupW displays the specified message to
  a popup window, if <g_LogPopupParentWnd> is not NULL (attended mode).

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

  LastError  - Specifies the last error; it will be printed if != ERROR_SUCCESS

  Forced - Specifies TRUE to force the popup, even in unattended mode

Return Value:

  none

--*/

VOID
pDisplayPopupA (
    IN      PCSTR Type,
    IN      PCSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
#ifdef DEBUG
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    CHAR buffer[OUTPUT_BUFSIZE_SMALL];
    PSTR currentPos = buffer;
#endif
    UINT mbStyle;
    LONG rc;
    OUTPUTDEST outDest;
    HWND parentWnd;
    PCSTR displayMessage = Msg;
    LOGSEVERITY severity = pGetSeverityFromType (Type);

    outDest = pGetTypeOutputDest (Type);

    if (g_LogPopupParentWnd || Forced) {

#ifdef DEBUG
        if (LastError != ERROR_SUCCESS) {
            if (LastError < 10) {
                currentPos += wsprintfA (buffer, " [ERROR=%u]", LastError);
            } else {
                currentPos += wsprintfA (buffer, " [ERROR=%u (%Xh)]", LastError, LastError);
            }
        }

        if (OUT_ASSERT (outDest)) {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\nBreak now? (Hit Yes to break, No to continue, or Cancel to disable '%s' message boxes)",
                            Type
                            );
        } else {
            currentPos += wsprintfA (
                            currentPos,
                            "\n\n(Hit Cancel to disable '%s' message boxes)",
                            Type
                            );
        }

        if (currentPos > buffer) {

            //
            // the displayed message should be modified to include additional info
            //

            displayMessage = formattedMsg;
            SzCopyBytesA (
                formattedMsg,
                Msg,
                ARRAYSIZE(formattedMsg) - (HALF_PTR) (currentPos - buffer)
                );
            SzCatA (formattedMsg, buffer);
        }
#endif

        switch (severity) {

        case LOGSEV_FATAL_ERROR:
            mbStyle = MB_ICONSTOP;
            break;

        case LOGSEV_ERROR:
            mbStyle = MB_ICONERROR;
            break;

        case LOGSEV_WARNING:
            mbStyle = MB_ICONEXCLAMATION;
            break;

        default:
            mbStyle = MB_ICONINFORMATION;

        }
        mbStyle |= MB_SETFOREGROUND;

#ifdef DEBUG
        if (OUT_ASSERT (outDest)) {
            mbStyle |= MB_YESNOCANCEL|MB_DEFBUTTON2;
        } else {
            mbStyle |= MB_OKCANCEL;
        }
#else
        mbStyle |= MB_OK;
#endif

        //
        // check current thread id; if different than thread that initialized
        // parent window handle, set parent to NULL
        //
        if (GetCurrentThreadId () == g_InitThreadId) {

            parentWnd = g_LogPopupParentWnd;

        } else {

            parentWnd = NULL;

        }

        rc = MessageBoxA (parentWnd, displayMessage, Type, mbStyle);

#ifdef DEBUG

        if (rc == IDCANCEL) {
            //
            // cancel this type of messages
            //

            LogSetErrorDest (Type, outDest | OD_POPUP_CANCEL);

        } else if (rc == IDYES) {

            //
            // If Yes was clicked, call DebugBreak to get assert behavoir
            //

            DebugBreak();

        }
#endif

    }
}


VOID
pDisplayPopupW (
    IN      PCSTR Type,
    IN      PWSTR Msg,
    IN      DWORD LastError,
    IN      BOOL Forced
    )
{
    PCSTR msgA;

    //
    // call the ANSI version because wsprintfW is not properly implemented on Win9x
    //
    msgA = SzConvertWToA (Msg);
    pDisplayPopupA (Type, msgA, LastError, Forced);
    SzFreeA (msgA);
}


/*++

Routine Description:

  pRawWriteLogOutputA and pRawWriteLogOutputW output specified message
  to all character devices implied by the type. The message is not
  formatted in any way

Arguments:

  Type  - Specifies the type of the message, displayed as the popup's title

  Msg  - Specifies the message

Return Value:

  none

--*/

VOID
pRawWriteLogOutputA (
    IN      PCSTR Type,
    IN      PCSTR Message,
    IN      PCSTR formattedMsg,
    IN      BOOL NoMainLog
    )
{
    OUTPUTDEST outDest;
    LOGARGA callbackArgA;
    LOGARGW callbackArgW;
    static BOOL inCallback = FALSE;
#ifdef DEBUG
    HANDLE handle;
#endif

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (!inCallback && (g_LogCallbackA || g_LogCallbackW)) {

        inCallback = TRUE;

        if (g_LogCallbackA) {
            ZeroMemory (&callbackArgA, sizeof (callbackArgA));
            callbackArgA.Type = Type;
            callbackArgA.ModuleInstance = g_LibHandle;
            callbackArgA.Message = Message;
            callbackArgA.FormattedMessage = formattedMsg;
            callbackArgA.Debug = NoMainLog;

            g_LogCallbackA (&callbackArgA);
        } else {
            ZeroMemory (&callbackArgW, sizeof (callbackArgW));
            callbackArgW.Type = Type;
            callbackArgW.ModuleInstance = g_LibHandle;
            callbackArgW.Message = SzConvertAToW (Message);
            callbackArgW.FormattedMessage = SzConvertAToW (formattedMsg);
            callbackArgW.Debug = NoMainLog;

            g_LogCallbackW (&callbackArgW);

            if (callbackArgW.Message) {
                SzFreeW (callbackArgW.Message);
            }
            if (callbackArgW.FormattedMessage) {
                SzFreeW (callbackArgW.FormattedMessage);
            }
        }

        inCallback = FALSE;
        return;
    }

    if (!NoMainLog && OUT_LOGFILE (outDest)) {
        pWriteToMainLogA (Type, LOGSEV_INFORMATION, formattedMsg);
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringA (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fprintf (stderr, "%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                            g_DebugLogFile,
                            GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            pWriteFileStringA (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif
}


VOID
pRawWriteLogOutputW (
    IN      PCSTR Type,
    IN      PCWSTR Message,
    IN      PCWSTR formattedMsg,
    IN      BOOL NoMainLog
    )
{
    OUTPUTDEST outDest;
    LOGARGA callbackArgA;
    LOGARGW callbackArgW;
    static BOOL inCallback = FALSE;
#ifdef DEBUG
    HANDLE handle;
#endif

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT (outDest)) {
        return;
    }

    if (!inCallback && (g_LogCallbackA || g_LogCallbackW)) {

        inCallback = TRUE;

        if (g_LogCallbackW) {
            ZeroMemory (&callbackArgW, sizeof (callbackArgW));
            callbackArgW.Type = Type;
            callbackArgW.ModuleInstance = g_LibHandle;
            callbackArgW.Message = Message;
            callbackArgW.FormattedMessage = formattedMsg;
            callbackArgW.Debug = NoMainLog;

            g_LogCallbackW (&callbackArgW);
        } else {
            ZeroMemory (&callbackArgA, sizeof (callbackArgA));
            callbackArgA.Type = Type;
            callbackArgA.ModuleInstance = g_LibHandle;
            callbackArgA.Message = SzConvertWToA (Message);
            callbackArgA.FormattedMessage = SzConvertWToA (formattedMsg);
            callbackArgA.Debug = NoMainLog;

            g_LogCallbackA (&callbackArgA);

            if (callbackArgA.Message) {
                SzFreeA (callbackArgA.Message);
            }
            if (callbackArgA.FormattedMessage) {
                SzFreeA (callbackArgA.FormattedMessage);
            }
        }

        inCallback = FALSE;
        return;
    }

    if (!NoMainLog && OUT_LOGFILE (outDest)) {
        pWriteToMainLogW (Type, LOGSEV_INFORMATION, formattedMsg);
    }

    //
    // log to each specified device
    //

    if (OUT_DEBUGGER(outDest)) {
        OutputDebugStringW (formattedMsg);
    }

    if (OUT_CONSOLE(outDest)) {
        fwprintf (stderr, L"%s", formattedMsg);
    }

#ifdef DEBUG
    if (OUT_DEBUGLOG (outDest)) {

        handle = CreateFileA (
                        g_DebugLogFile,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );
        if (handle != INVALID_HANDLE_VALUE) {

            SetFilePointer (handle, 0, NULL, FILE_END);
            pWriteFileStringW (handle, formattedMsg);
            CloseHandle (handle);
        }
    }
#endif
}


/*++

Routine Description:

  pFormatAndWriteMsgA and pFormatAndWriteMsgW format the message
  specified by the Format argument and outputs it to all destinations
  specified in OutDest. If no destination for the message,
  no action is performed.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  args  - Specifies a list of arguments to be used when formatting
          the message. If a message ID is used for Format, args
          is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
pFormatAndWriteMsgA (
    IN      BOOL NoMainLog,
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    PRIVATE_ASSERT (g_LoggingNow > 0);

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((ULONG_PTR)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageA (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_LibHandle,
                (DWORD)(ULONG_PTR) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID, Instance=0x%08X", g_LibHandle));
            return;
        }
    } else {

        //
        // format given string using printf style
        //

        _vsnprintf(output, OUTPUT_BUFSIZE_LARGE, Format, args);
    }

    pIndentMessageA (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputA (Type, output, formattedMsg, NoMainLog);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (
                !MUST_BE_LOCALIZED (outDest) ||
                (SHIFTRIGHT16((ULONG_PTR)Format) == 0)
                );
        }

        pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((ULONG_PTR)Format) == 0) {
            pDisplayPopupA (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


VOID
pFormatAndWriteMsgW (
    IN      BOOL NoMainLog,
    IN      PCSTR Type,
    IN      PCSTR Format,
    IN      va_list args
    )
{
    WCHAR formatW[OUTPUT_BUFSIZE_LARGE];
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    OUTPUTDEST outDest;
    DWORD lastError;

    PRIVATE_ASSERT (g_LoggingNow > 0);

    // clear LOGTITLE flag on each regular LOG
    g_HasTitle = FALSE;

    outDest = pGetTypeOutputDest (Type);

    if (OUT_NO_OUTPUT(outDest)) {
        return;
    }

    if (OUT_ERROR (outDest)) {
        lastError = GetLastError();
    } else {
        lastError = ERROR_SUCCESS;
    }

    // format output string
    if (SHIFTRIGHT16((ULONG_PTR)Format) == 0) {

        //
        // this is actually a Resource String ID
        //

        if (!FormatMessageW (
                FORMAT_MESSAGE_FROM_HMODULE,
                (LPVOID) g_LibHandle,
                (DWORD)(ULONG_PTR) Format,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPVOID) output,
                OUTPUT_BUFSIZE_LARGE,
                &args
                )) {
            // the string is missing from Resources
            DEBUGMSG ((DBG_WHOOPS, "Log() called with invalid MsgID, Instance=0x%08X", g_LibHandle));
            return;
        }
    } else {
        SzConvertBufferAToW (formatW, Format);

        //
        // format given string using printf style
        //

        _vsnwprintf(output, OUTPUT_BUFSIZE_LARGE, formatW, args);
    }

    pIndentMessageW (
        formattedMsg,
        OUTPUT_BUFSIZE_LARGE,
        Type,
        output,
        MSGBODY_INDENT,
        lastError
        );

    pRawWriteLogOutputW (Type, output, formattedMsg, NoMainLog);

    if (pIsPopupEnabled (Type)) {

#ifdef DEBUG
        if (MUST_BE_LOCALIZED (outDest)) {
            PRIVATE_ASSERT (SHIFTRIGHT16((ULONG_PTR)Format) == 0);
        }

        pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));

#else
        if (SHIFTRIGHT16 ((ULONG_PTR)Format) == 0) {
            pDisplayPopupW (Type, output, lastError, OUT_FORCED_POPUP(outDest));
        }
#endif

    }
}


BOOL
pInitLog (
    IN      BOOL FirstTimeInit,
    IN      HWND LogPopupParentWnd,     OPTIONAL
    OUT     HWND *OrgPopupParentWnd,    OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallbackA, OPTIONAL
    IN      PLOGCALLBACKW LogCallbackW  OPTIONAL
    )

/*++

Routine Description:

  pInitLog actually initializes the log system.

Arguments:

  LogPopupParentWnd  - Specifies the parent window to be used by the
                       popups, or NULL if popups are to be suppressed.
                       This value is not optional on the first call
                       to this function.

  OrgPopupParentWnd  - Receives the original parent window.

  LogFile - Specifies the name of the log file. If not specified,
            logging goes to a default file (%windir%\cobra.log).

  LogCallback - Specifies a function to call instead of the internal
                logging functions.

Return Value:

  TRUE if log system successfully initialized

--*/

{
    HINF hInf = INVALID_HANDLE_VALUE;
    BOOL result = FALSE;
    PDEFAULT_DESTINATION dest;
#ifdef DEBUG
    PSTR p;
#endif

    __try {

        g_LogInit = FALSE;

        if (FirstTimeInit) {
            PRIVATE_ASSERT (!g_FirstTypePtr);

            dest = g_DefaultDest;

            while (dest->Type) {
                LogSetErrorDest (dest->Type, dest->Flags);
                dest++;
            }

            GetWindowsDirectoryA (g_MainLogFile, ARRAYSIZE(g_MainLogFile));
            SzCatA (g_MainLogFile, "\\cobra");

#ifdef DEBUG
            SzCopyA (g_DebugLogFile, g_MainLogFile);
            SzCatA (g_DebugLogFile, ".dbg");
            g_DebugInfPathBufA[0] = g_DebugLogFile[0];
#endif

            SzCatA (g_MainLogFile, ".log");
        }

        if (LogFile) {
            SzBufferCopyA (g_MainLogFile, LogFile);

#ifdef DEBUG
            SzCopyA (g_DebugLogFile, g_MainLogFile);
            p = _mbsrchr (g_DebugLogFile, '.');
            if (p) {
                if (_mbschr (p, TEXT('\\'))) {
                    p = NULL;
                }
            }

            if (p) {
                SzCopyA (p, ".dbg");
            } else {
                SzCatA (g_DebugLogFile, ".dbg");
            }


#endif
        }

        if (g_ResetLog) {
            SetFileAttributesA (g_MainLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_MainLogFile);
        }

#ifdef DEBUG
        if (g_ResetLog) {
            SetFileAttributesA (g_DebugLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogFile);
        }
#endif

        if (LogCallbackA) {
            g_LogCallbackA = LogCallbackA;
        }

        if (LogCallbackW) {
            g_LogCallbackW = LogCallbackW;
        }

#ifdef DEBUG
        /* BUGBUG - eliminate setupapi
        if (FirstTimeInit) {
            //
            // get user's preferences
            //

            hInf = SetupOpenInfFileA (g_DebugInfPathBufA, NULL, INF_STYLE_WIN4 | INF_STYLE_OLDNT, NULL);
            if (INVALID_HANDLE_VALUE != hInf && pGetUserPreferences(hInf)) {
                g_DoLog = TRUE;
            }
        }
        */

        if (g_ResetLog) {
            SetFileAttributesA (g_DebugLogFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFileA (g_DebugLogFile);
        }
#endif

        if (OrgPopupParentWnd) {
            *OrgPopupParentWnd = g_LogPopupParentWnd;
        }

        if (LogPopupParentWnd) {
            g_LogPopupParentWnd = LogPopupParentWnd;
            g_InitThreadId = GetCurrentThreadId ();
        }

        result = TRUE;
    }
    __finally {

        /* BUGBUG - eliminate setupapi
        if (hInf != INVALID_HANDLE_VALUE) {
            SetupCloseInfFile (hInf);
        }
        */

        if (!result) {  //lint !e774

            if (g_FirstTypePtr) {
                HeapFree (g_hHeap, 0, g_FirstTypePtr);
                g_FirstTypePtr = NULL;
                g_TypeTableCount = 0;
                g_TypeTableFreeCount = 0;
            }

            g_OutDestAll = OD_UNDEFINED;
            g_OutDestDefault = OD_UNDEFINED;

#ifdef DEBUG
            g_DoLog = FALSE;
#endif
        }

        g_LogInit = TRUE;
        g_ResetLog = FALSE;
    }

    return result;
}


VOID
LogSetVerboseLevel (
    IN      OUTPUT_DESTINATION Level
    )
{
    OUTPUT_DESTINATION Debugger = 0;

    if (Level > 3) {
        Debugger = OD_DEBUGGER|OD_ASSERT;
    }

    LogSetErrorDest (LOG_FATAL_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_MODULE_ERROR, Level > 0 ? OD_POPUP_CANCEL|OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_WARNING, Level > 1 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    LogSetErrorDest (LOG_INFORMATION, Level > 2 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    LogSetErrorDest ("Assert", OD_POPUP|OD_ERROR|Debugger);
    LogSetErrorDest ("Verbose", Level > 2 ? OD_LOGFILE|Debugger : OD_SUPPRESS);
}

VOID
LogSetVerboseBitmap (
    IN      LOG_LEVEL Bitmap,
    IN      LOG_LEVEL BitsToAdjustMask,
    IN      BOOL EnableDebugger
    )
{

    OUTPUT_DESTINATION Debugger = 0;

    if (EnableDebugger) {
        Debugger = OD_DEBUGGER|OD_ASSERT;
    }

    if (BitsToAdjustMask & LL_FATAL_ERROR) {
        LogSetErrorDest (LOG_FATAL_ERROR, (Bitmap & LL_FATAL_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_MODULE_ERROR) {
        LogSetErrorDest (LOG_MODULE_ERROR, (Bitmap & LL_MODULE_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_ERROR) {
        LogSetErrorDest (LOG_ERROR, (Bitmap & LL_ERROR) ? OD_LOGFILE|OD_ERROR|OD_CONSOLE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_WARNING) {
        LogSetErrorDest (LOG_WARNING, (Bitmap & LL_WARNING) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_INFORMATION) {
        LogSetErrorDest (LOG_INFORMATION, (Bitmap & LL_INFORMATION) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_STATUS) {
        LogSetErrorDest (LOG_STATUS, (Bitmap & LL_STATUS) ? OD_LOGFILE|Debugger : OD_SUPPRESS);
    }

    if (BitsToAdjustMask & LL_UPDATE) {
        LogSetErrorDest (LOG_UPDATE, (Bitmap & LL_UPDATE) ? OD_CONSOLE : OD_SUPPRESS);
    }
}


/*++

Routine Description:

  pInitialize initializes the log system calling the worker pInitLog. This function
  should be only called once

Arguments:
  None

Return Value:

  TRUE if log system successfully initialized

--*/

BOOL
pInitialize (
    VOID
    )
{
    return pInitLog (TRUE, NULL, NULL, NULL, NULL, NULL);
}

/*++

Routine Description:

  LogReInit re-initializes the log system calling the worker pInitLog.
  This function may be called any number of times, but only after pInitialize()

Arguments:

  NewParent - Specifies the new parent handle.

  OrgParent - Receives the old parent handle.

  LogFile - Specifies a new log file name

  LogCallback - Specifies a callback function that handles the log message (so
                one module can pass log messages to another)

  ResourceImage - Specifies the module path to use in FormatMessage when the
                  message is resource-based

Return Value:

  TRUE if log system was successfully re-initialized

--*/

BOOL
LogReInitA (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCSTR LogFile,              OPTIONAL
    IN      PLOGCALLBACKA LogCallback   OPTIONAL
    )
{
    return pInitLog (FALSE, NewParent, OrgParent, LogFile, LogCallback, NULL);
}


BOOL
LogReInitW (
    IN      HWND NewParent,             OPTIONAL
    OUT     HWND *OrgParent,            OPTIONAL
    IN      PCWSTR LogFile,             OPTIONAL
    IN      PLOGCALLBACKW LogCallback   OPTIONAL
    )
{
    CHAR ansiLogFile[MAX_PATH];

    if (LogFile) {
        SzConvertBufferWToA (ansiLogFile, LogFile);
        LogFile = (PWSTR) ansiLogFile;
    }

    return pInitLog (FALSE, NewParent, OrgParent, (PCSTR) LogFile, NULL, LogCallback);
}


VOID
LogBegin (
    IN      HMODULE ModuleInstance
    )
{
    DWORD threadError;
    DWORD rc;

    threadError = GetLastError ();

    if (!g_LogMutex) {
        InitializeLog();
    }

    rc = WaitForSingleObject (g_LogMutex, INFINITE);

    PRIVATE_ASSERT (rc == WAIT_OBJECT_0 || rc == WAIT_ABANDONED);

    if (rc == WAIT_ABANDONED) {
        g_LoggingNow = 0;
    }

    if (!g_LoggingNow) {
        g_LibHandle = ModuleInstance;
        SetLastError (threadError);
        g_LogError = threadError;
    }

    g_LoggingNow++;
}

VOID
LogEnd (
    VOID
    )
{
    g_LoggingNow--;

    if (!g_LoggingNow) {
        g_LibHandle = g_hInst;
        SetLastError (g_LogError);
    }

    ReleaseMutex (g_LogMutex);
}


VOID
pDisableLog (
    VOID
    )
{
    g_LogInit = FALSE;
}


VOID
pExitLog (
    VOID
    )

/*++

Routine Description:

  pExitLog cleans up any resources used by the log system

Arguments:

  none

Return Value:

  none

--*/

{
    g_LogInit = FALSE;

    WaitForSingleObject (g_LogMutex, 60000);
    CloseHandle (g_LogMutex);
    g_LogMutex = NULL;

    if (g_FirstTypePtr) {
        HeapFree (g_hHeap, 0, g_FirstTypePtr);
        g_FirstTypePtr = NULL;
        g_TypeTableCount = 0;
        g_TypeTableFreeCount = 0;
    }

    g_OutDestAll = OD_UNDEFINED;
    g_OutDestDefault = OD_UNDEFINED;
}


/*++

Routine Description:

  LogA and LogW preserve the last error code; they call the helpers
  pFormatAndWriteMsgA and pFormatAndWriteMsgW respectivelly.

Arguments:

  Type  - Specifies the type (category) of the message

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
LogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
LogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        FALSE,
        Type,
        Format,
        args
        );
    va_end (args);
}


#ifdef DEBUG

VOID
_cdecl
DbgLogA (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogW (
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogIfA (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgA (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}


VOID
_cdecl
DbgLogIfW (
    IN      BOOL Condition,
    IN      PCSTR Type,
    IN      PCSTR Format,
    ...
    )
{
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!Condition) {
        return;
    }

    va_start (args, Format);
    pFormatAndWriteMsgW (
        TRUE,
        Type,
        Format,
        args
        );
    va_end (args);
}

#endif

VOID
LogTitleA (
    IN      PCSTR Type,
    IN      PCSTR Title         OPTIONAL
    )
{
    CHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];

    if (!g_LogInit) {
        return;
    }

    SzCopyBytesA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        Title = Type;
    }

    SzCopyBytesA (formattedMsg, Title, sizeof (formattedMsg) - sizeof (S_COLUMNDOUBLELINEA));
    SzCatA (formattedMsg, S_COLUMNDOUBLELINEA);

    pRawWriteLogOutputA (Type, NULL, formattedMsg, FALSE);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogTitleW (
    IN      PCSTR Type,
    IN      PCWSTR Title        OPTIONAL
    )
{
    WCHAR formattedMsg[OUTPUT_BUFSIZE_LARGE];
    WCHAR typeW[OUTPUT_BUFSIZE_SMALL];

    if (!g_LogInit) {
        return;
    }

    SzCopyTcharsA (g_LastType, Type, sizeof (g_LastType));

    if (!Title) {
        SzConvertBufferAToW (typeW, Type);
        Title = typeW;
    }

    SzCopyTcharsW (formattedMsg, Title, sizeof (formattedMsg) - sizeof (S_COLUMNDOUBLELINEW));
    SzCatW (formattedMsg, S_COLUMNDOUBLELINEW);

    pRawWriteLogOutputW (Type, NULL, formattedMsg, FALSE);

    //
    // set LOGTITLE flag
    //

    g_HasTitle = TRUE;
}


VOID
LogLineA (
    IN      PCSTR Line
    )
{
    CHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCSTR p;

    if (!g_LogInit) {
        return;
    }

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    SzCopyBytesA (output, Line, sizeof (output) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = _mbsstr (output, S_NEWLINEA); p; p = _mbsstr (p + NEWLINE_CHAR_COUNTA, S_NEWLINEA)) {
        if (p[NEWLINE_CHAR_COUNTA] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        SzCatA (output, S_NEWLINEA);
    }

    pRawWriteLogOutputA (g_LastType, NULL, output, FALSE);
}


VOID
LogLineW (
    IN      PCWSTR Line
    )
{
    WCHAR output[OUTPUT_BUFSIZE_LARGE];
    BOOL hasNewLine = FALSE;
    PCWSTR p;

    if (!g_LogInit) {
        return;
    }

    if (!Line) {
        return;
    }

    if (!g_HasTitle) {
        DEBUGMSG ((DBG_WHOOPS, "LOGTITLE missing before LOGLINE"));
        return;
    }

    SzCopyTcharsW (output, Line, sizeof (output) / sizeof (WCHAR) - 4);

    //
    // find out if the line terminates with newline
    //

    for (p = wcsstr (output, S_NEWLINEW); p; p = wcsstr (p + NEWLINE_CHAR_COUNTW, S_NEWLINEW)) {
        if (p[NEWLINE_CHAR_COUNTW] == 0) {

            //
            // the line ends with a newline
            //

            hasNewLine = TRUE;
            break;
        }
    }

    if (!hasNewLine) {
        SzCatW (output, S_NEWLINEW);
    }

    pRawWriteLogOutputW (g_LastType, NULL, output, FALSE);
}


VOID
LogDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text, FALSE);
}


VOID
LogDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text, FALSE);
}


#ifdef DEBUG
VOID
DbgDirectA (
    IN      PCSTR Type,
    IN      PCSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputA (Type, NULL, Text, TRUE);
}


VOID
DbgDirectW (
    IN      PCSTR Type,
    IN      PCWSTR Text
    )
{
    if (!g_LogInit) {
        return;
    }

    g_HasTitle = FALSE;
    pRawWriteLogOutputW (Type, NULL, Text, TRUE);
}
#endif


VOID
SuppressAllLogPopups (
    IN      BOOL SuppressOn
    )
{
    g_SuppressAllPopups = SuppressOn;
}


#ifdef DEBUG

/*++

Routine Description:

  DebugLogTimeA and DebugLogTimeW preserve the last error code;
  they append the current date and time to the formatted message,
  then call LogA and LogW to actually process the message.

Arguments:

  Format  - Specifies either the message in ASCII format or
            a message ID (if SHIFTRIGHT16(Format) == 0). The message
            will be formatted using args.

  ...  - Specifies a list of arguments to be used when formatting
         the message. If a message ID is used for Format, args
         is supposed to be an array of pointers to strings

Return Value:

  none

--*/

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    )
{
    CHAR msg[OUTPUT_BUFSIZE_LARGE];
    CHAR date[OUTPUT_BUFSIZE_SMALL];
    CHAR ttime[OUTPUT_BUFSIZE_SMALL];
    PSTR appendPos, end;
    DWORD currentTickCount;
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!g_DoLog) {
        return;
    }

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            date,
            OUTPUT_BUFSIZE_SMALL)) {
        SzCopyA (date,"** Error retrieving date. **");
    }

    if (!GetTimeFormatA (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            ttime,
            OUTPUT_BUFSIZE_SMALL)) {
        SzCopyA (ttime,"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }


    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    appendPos = msg + _vsnprintf (msg, OUTPUT_BUFSIZE_LARGE, Format, args);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    end = msg + OUTPUT_BUFSIZE_LARGE;
    _snprintf(
        appendPos,
        ((ULONG_PTR)end - (ULONG_PTR)appendPos) / (sizeof (CHAR)),
        "\nCurrent Date and Time: %s %s\n"
        "Milliseconds since last DEBUGLOGTIME call : %u\n"
        "Milliseconds since first DEBUGLOGTIME call: %u\n",
        date,
        ttime,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogA (DBG_TIME, "%s", msg);
}


VOID
_cdecl
DebugLogTimeW (
    IN      PCSTR Format,
    ...
    )
{
    WCHAR msgW[OUTPUT_BUFSIZE_LARGE];
    WCHAR dateW[OUTPUT_BUFSIZE_SMALL];
    WCHAR timeW[OUTPUT_BUFSIZE_SMALL];
    PCWSTR formatW;
    PWSTR appendPosW, endW;
    DWORD currentTickCount;
    va_list args;

    if (!g_LogInit) {
        return;
    }

    if (!g_DoLog) {
        return;
    }

    //
    // first, get the current date and time into the string.
    //
    if (!GetDateFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            dateW,
            OUTPUT_BUFSIZE_SMALL)) {
        SzCopyW (dateW, L"** Error retrieving date. **");
    }

    if (!GetTimeFormatW (
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            NULL,
            NULL,
            timeW,
            OUTPUT_BUFSIZE_SMALL)) {
        SzCopyW (timeW, L"** Error retrieving time. **");
    }

    //
    // Now, get the current tick count.
    //
    currentTickCount = GetTickCount();

    //
    // If this is the first call save the tick count.
    //
    if (!g_FirstTickCount) {
        g_FirstTickCount = currentTickCount;
        g_LastTickCount  = currentTickCount;
    }

    //
    // Now, build the passed in string.
    //
    va_start (args, Format);
    formatW = SzConvertAToW (Format);
    appendPosW = msgW + _vsnwprintf (msgW, OUTPUT_BUFSIZE_LARGE, formatW, args);
    SzFreeW (formatW);
    va_end (args);

    //
    // Append the time statistics to the end of the string.
    //
    endW = msgW + OUTPUT_BUFSIZE_LARGE;
    _snwprintf(
        appendPosW,
        ((ULONG_PTR)endW - (ULONG_PTR)appendPosW) / (sizeof (WCHAR)),
        L"\nCurrent Date and Time: %s %s\n"
        L"Milliseconds since last DEBUGLOGTIME call : %u\n"
        L"Milliseconds since first DEBUGLOGTIME call: %u\n",
        dateW,
        timeW,
        currentTickCount - g_LastTickCount,
        currentTickCount - g_FirstTickCount
        );

    g_LastTickCount = currentTickCount;

    //
    // Now, pass the results onto debugoutput.
    //
    LogW (DBG_TIME, "%s", msgW);
}

#endif // DEBUG


VOID
InitializeLog (
    VOID
    )
{
    g_LogMutex = CreateMutex (NULL, FALSE, TEXT("cobra_log_mutex"));
    pInitialize ();
}


#if 0
EXPORT
BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        g_hInst = hInstance;
        g_LibHandle = hInstance;
        InitializeLog ();

        PRIVATE_ASSERT (g_LogMutex != NULL);
    }

    return TRUE;
}
#endif

VOID
LogDeleteOnNextInit(
    VOID
    )
{
    g_ResetLog = TRUE;
}

#ifdef DEBUG

VOID
LogCopyDebugInfPathA(
    OUT     PSTR MaxPathBuffer
    )
{
    SzCopyBytesA (MaxPathBuffer, g_DebugInfPathBufA, MAX_PATH);
}


VOID
LogCopyDebugInfPathW(
    OUT     PWSTR MaxPathBuffer
    )
{
    SzConvertBufferAToW (MaxPathBuffer, g_DebugInfPathBufA);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\strmem.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strmem.c

Abstract:

    String routines that allocate memory

Author:

    Jim Schmidt (jimschm)   10-Aug-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "commonp.h"

PSTR
RealSzJoinPathsA (
    IN      PCSTR BasePath,
    IN      PCSTR ChildPath     OPTIONAL
    )
{
    PCSTR baseEnd;
    PSTR p;
    UINT_PTR baseByteCount;
    UINT_PTR childSize;
    PSTR result;

    //
    // Validate NULLs
    //

    if (!BasePath) {
        MYASSERT (FALSE);
        BasePath = "";
    }

    if (!ChildPath) {
        ChildPath = "";
    }

    //
    // Compute base length in bytes
    //

    baseEnd = SzGetEndA (BasePath);
    p = SzPrevCharA (BasePath, baseEnd);
    if ((p >= BasePath) && (*p == '\\')) {
        baseEnd = p;
    }

    baseByteCount = (PBYTE) baseEnd - (PBYTE) BasePath;

    //
    // Compute child length in bytes
    //

    if (*ChildPath == '\\') {
        ChildPath++;
    }

    childSize = SzSizeA (ChildPath);

    //
    // Allocate memory & copy strings
    //

    result = SzAllocBytesA (baseByteCount + sizeof (CHAR) + childSize);

    if (result) {
        CopyMemory (result, BasePath, baseByteCount);
        p = (PSTR) ((PBYTE) result + baseByteCount);
        *p++ = '\\';
        CopyMemory (p, ChildPath, childSize);
    }

    return result;
}


PWSTR
RealSzJoinPathsW (
    IN      PCWSTR BasePath,
    IN      PCWSTR ChildPath    OPTIONAL
    )
{
    PCWSTR baseEnd;
    PWSTR p;
    UINT_PTR baseByteCount;
    UINT_PTR childSize;
    PWSTR result;

    //
    // Validate NULLs
    //

    if (!BasePath) {
        MYASSERT (FALSE);
        BasePath = L"";
    }

    if (!ChildPath) {
        ChildPath = L"";
    }

    //
    // Compute base length in bytes
    //

    baseEnd = SzGetEndW (BasePath);
    p = (PWSTR) (baseEnd - 1);
    if ((p >= BasePath) && (*p == L'\\')) {
        baseEnd = p;
    }

    baseByteCount = (PBYTE) baseEnd - (PBYTE) BasePath;

    //
    // Compute child length in bytes
    //

    if (*ChildPath == L'\\') {
        ChildPath++;
    }

    childSize = SzSizeW (ChildPath);

    //
    // Allocate memory & copy strings
    //

    result = SzAllocBytesW (baseByteCount + sizeof (WCHAR) + childSize);

    if (result) {
        CopyMemory (result, BasePath, baseByteCount);
        p = (PWSTR) ((PBYTE) result + baseByteCount);
        *p++ = L'\\';
        CopyMemory (p, ChildPath, childSize);
    }

    return result;
}


DWORD
pGetMaxJoinSizeA (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCSTR source;

    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        size += SzByteCountA (source) + sizeof (CHAR);
    }

    return size;
}

DWORD
pGetMaxJoinSizeW (
    IN      va_list args
    )
{
    DWORD size = 0;
    PCWSTR source;

    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        size += SzByteCountW (source) + sizeof (WCHAR);
    }

    return size;
}


PSTR
pJoinPathsInBufferA (
    OUT     PSTR Buffer,
    IN      va_list args
    )
{
    PSTR end;
    PSTR endMinusOne;
    PCSTR source;
    PCSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCSTR); source != NULL; source = va_arg(args, PCSTR)) {
        if (counter > 0) {
            endMinusOne = SzPrevCharA (p, end);
            if (endMinusOne) {
                if (_mbsnextc (source) == '\\') {
                    if (_mbsnextc (endMinusOne) == '\\') {
                        source++;
                    }
                } else {
                    if (_mbsnextc (endMinusOne) != '\\') {
                        *end = '\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = SzCatA (end, source);
        }
        counter++;
    }

    return end;
}

PWSTR
pJoinPathsInBufferW (
    OUT     PWSTR Buffer,
    IN      va_list args
    )
{
    PWSTR end;
    PWSTR endMinusOne;
    PCWSTR source;
    PCWSTR p;
    INT counter;

    *Buffer = 0;

    counter = 0;
    p = end = Buffer;
    for (source = va_arg(args, PCWSTR); source != NULL; source = va_arg(args, PCWSTR)) {
        if (counter > 0) {
            endMinusOne = end > p ? end - 1 : NULL;
            if (endMinusOne) {
                if (*source == L'\\') {
                    if (*endMinusOne == L'\\') {
                        source++;
                    }
                } else {
                    if (*endMinusOne != L'\\') {
                        *end = L'\\';
                        end++;
                        *end = 0;
                    }
                }
            }
        }
        if (*source) {
            p = end;
            end = SzCatW (end, source);
        }
        counter++;
    }

    return end;
}


PCSTR
SzJoinPathsExA (
    IN OUT  PGROWBUFFER Buffer,
    IN      ...
    )
{
    PCSTR result = NULL;
    PSTR end;
    DWORD size;
    va_list args;

    if (!Buffer) {
        MYASSERT (FALSE);
        return NULL;
    }

    va_start (args, Buffer);
    size = pGetMaxJoinSizeA (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    end = (PSTR) GbGrow (Buffer, size);
    if (!end) {
        return NULL;
    }

    result = end;

    va_start (args, Buffer);
    end = pJoinPathsInBufferA (end, args);
    va_end (args);

    //
    // adjust Buffer->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Buffer->Buf && (PBYTE)(end + 1) <= Buffer->Buf + Buffer->End);
    Buffer->End = (DWORD)((PBYTE)(end + 1) - Buffer->Buf);

    return result;
}


PCWSTR
SzJoinPathsExW (
    IN OUT  PGROWBUFFER Buffer,
    IN      ...
    )
{
    PWSTR end;
    DWORD size;
    va_list args;
    PCWSTR result = NULL;

    MYASSERT (Buffer);
    if (!Buffer) {
        return NULL;
    }

    va_start (args, Buffer);
    size = pGetMaxJoinSizeW (args);
    va_end (args);

    if (size == 0) {
        return NULL;
    }

    end = (PWSTR) GbGrow (Buffer, size);
    if (!end) {
        return NULL;
    }

    result = end;

    va_start (args, Buffer);
    end = pJoinPathsInBufferW (end, args);
    va_end (args);

    //
    // adjust Buffer->End if resulting path is actually shorter than predicted
    //
    MYASSERT ((PBYTE)end >= Buffer->Buf && (PBYTE)(end + 1) <= Buffer->Buf + Buffer->End);
    Buffer->End = (DWORD)((PBYTE)(end + 1) - Buffer->Buf);

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\strings.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strings.c

Abstract:

    String routines

Author:

    Jim Schmidt (jimschm)   03-Aug-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "commonp.h"

PSTR
SzCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;

    return Destination;
}


PWSTR
SzCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )
{
    while (*Source) {
        *Destination++ = *Source++;
    }

    *Destination = 0;

    return Destination;
}


PSTR
SzNextCharA (
    IN      PCSTR CurrentPointer
    )
{
    PCSTR next;

    next = _mbsinc (CurrentPointer);
    switch (next - CurrentPointer) {

    case 3:
        if (CurrentPointer[2] == 0) {
            next = CurrentPointer + 2;
            break;
        }
    case 2:
        if (CurrentPointer[1] == 0) {
            next = CurrentPointer + 1;
        }
        break;
    }

    return (PSTR) next;
}


PSTR
SzCopyBytesA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    PCSTR maxEnd;
    PCSTR sourceEndPlusOne;
    PCSTR sourceEnd;
    UINT_PTR bytes;

    if (!MaxBytesToCopyIncNul) {
        //
        // Buffer can't fit anything
        //

        return Destination;
    }

    //
    // Find the nul terminator, or the last character that
    // will fit in the buffer.
    //

    maxEnd = (PCSTR) ((PBYTE) Source + MaxBytesToCopyIncNul);
    sourceEndPlusOne = Source;

    do {
        sourceEnd = sourceEndPlusOne;

        if (!(*sourceEndPlusOne)) {
            break;
        }

        sourceEndPlusOne = SzNextCharA (sourceEndPlusOne);

    } while (sourceEndPlusOne < maxEnd);

    bytes = (PBYTE) sourceEnd - (PBYTE) Source;
    CopyMemory (Destination, Source, bytes);

    Destination = (PSTR) ((PBYTE) Destination + bytes);
    *Destination = 0;

    return Destination;
}

PWSTR
SzCopyBytesW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    PCWSTR sourceMax;
    PCWSTR sourceEnd;
    UINT_PTR bytes;

    if (MaxBytesToCopyIncNul < sizeof (WCHAR)) {
        //
        // Buffer can't fit anything
        //

        return Destination;
    }

    sourceMax = (PCWSTR) ((PBYTE) Source + (MaxBytesToCopyIncNul & (~1)) - sizeof (WCHAR));
    sourceEnd = Source;

    do {
        if (!(*sourceEnd)) {
            break;
        }

        sourceEnd++;
    } while (sourceEnd < sourceMax);

    bytes = (PBYTE) sourceEnd - (PBYTE) Source;
    CopyMemory (Destination, Source, bytes);

    Destination = (PWSTR) ((PBYTE) Destination + bytes);
    *Destination = 0;

    return Destination;
}

PSTR
SzCopyBytesABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    UINT width;

    width = ((PBYTE) End - (PBYTE) Start) + sizeof (CHAR);

    return SzCopyBytesA (Destination, Start, min (width, MaxBytesToCopyIncNul));
}

PWSTR
SzCopyBytesABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    )
{
    UINT width;

    width = ((PBYTE) End - (PBYTE) Start) + sizeof (WCHAR);

    return SzCopyBytesW (Destination, Start, min (width, MaxBytesToCopyIncNul));
}


PSTR
SzCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    )
{
    Destination = SzGetEndA (Destination);
    return SzCopyA (Destination, Source);
}

PWSTR
SzCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    )
{
    Destination = SzGetEndW (Destination);
    return SzCopyW (Destination, Source);
}


BOOL
SzMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    )
{
    while (*String1) {
        if (*String1++ != *String2++) {
            return FALSE;
        }
    }

    return *String2 == 0;
}


BOOL
SzMemMatchA (
    IN      PCSTR Buffer1,
    IN      PCSTR Buffer2,
    IN      SIZE_T ByteCount
    )
{
    SIZE_T u;
    PCSTR end;

    end = (PCSTR) ((PBYTE) Buffer1 + ByteCount);

    while (Buffer1 < end) {

        if (*Buffer1 != *Buffer2++) {
            return FALSE;
        }

        if (*Buffer1++ == 0) {
            return TRUE;
        }
    }

    return TRUE;
}


BOOL
SzMemMatchW (
    IN      PCWSTR Buffer1,
    IN      PCWSTR Buffer2,
    IN      SIZE_T ByteCount
    )
{
    SIZE_T u;
    PCWSTR end;

    end = (PCWSTR) ((PBYTE) Buffer1 + ByteCount);

    while (Buffer1 < end) {

        if (*Buffer1 != *Buffer2++) {
            return FALSE;
        }

        if (*Buffer1++ == 0) {
            return TRUE;
        }
    }

    return TRUE;
}

INT
SzCompareBytesA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    )
{
    PCSTR end;
    INT bytesLeft;
    INT thisCharBytes;
    UINT ch1;
    UINT ch2;
    PCSTR maxString1;
    PCSTR maxString2;

    if (!ByteCount) {
        return 0;
    }

    bytesLeft = (INT) ByteCount;
    MYASSERT ((SIZE_T) bytesLeft == ByteCount);

    maxString1 = (PCSTR) ((PBYTE) String1 + ByteCount);
    maxString2 = (PCSTR) ((PBYTE) String2 + ByteCount);

    do {
        //
        // Compute ch1. We use this code instead of _mbsnextc, so we can
        // support mismatched code pages.
        //

        end = SzNextCharA (String1);
        if (end > maxString1) {
            end = maxString1;
        }

        ch1 = 0;
        do {
            ch1 = (ch1 << 8) | *String1++;
        } while (String1 < end);

        //
        // Compute ch2.
        //

        end = SzNextCharA (String2);
        if (end > maxString2) {
            end = maxString2;
        }

        ch2 = 0;
        do {
            ch2 = (ch2 << 8) | *String2++;
        } while (String2 < end);

        //
        // Compare
        //

        if (ch1 != ch2) {
            return (INT) ch1 - (INT) ch2;
        }

    } while (String1 < maxString1 && String2 < maxString2);

    //
    // One or both strings terminated
    //

    if (String1 < maxString1) {
        return -1;
    }

    if (String2 < maxString2) {
        return 1;
    }

    return 0;
}


INT
SzICompareBytesA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    )
{
    PCSTR end;
    INT bytesLeft;
    INT thisCharBytes;
    UINT ch1;
    UINT ch2;
    PCSTR maxString1;
    PCSTR maxString2;

    if (!ByteCount) {
        return 0;
    }

    bytesLeft = (INT) ByteCount;
    MYASSERT ((SIZE_T) bytesLeft == ByteCount);

    maxString1 = (PCSTR) ((PBYTE) String1 + ByteCount);
    maxString2 = (PCSTR) ((PBYTE) String2 + ByteCount);

    do {
        //
        // Compute ch1. We use this code instead of _mbsnextc, so we can
        // support mismatched code pages.
        //

        end = SzNextCharA (String1);
        if (end > maxString1) {
            end = maxString1;
        }

        ch1 = 0;
        do {
            ch1 = (ch1 << 8) | (*String1++);
        } while (String1 < end);

        ch1 = tolower (ch1);

        //
        // Compute ch2.
        //

        end = SzNextCharA (String2);
        if (end > maxString2) {
            end = maxString2;
        }

        ch2 = 0;
        do {
            ch2 = (ch2 << 8) | (*String2++);
        } while (String2 < end);

        ch2 = tolower (ch2);

        //
        // Compare
        //

        if (ch1 != ch2) {
            return (INT) ch1 - (INT) ch2;
        }

        //
        // If this is the end of the string, then we're done
        //

        if (!ch1) {
            return 0;
        }

    } while (String1 < maxString1 && String2 < maxString2);

    //
    // One or both strings terminated
    //

    if (String1 < maxString1) {
        return -1;
    }

    if (String2 < maxString2) {
        return 1;
    }

    return 0;
}


PSTR
SzUnsignedToHexA (
    IN      ULONG_PTR Number,
    OUT     PSTR String
    )
{
    PSTR p;

    *String++ = '0';
    *String++ = 'x';

    p = String + (sizeof (Number) * 2);
    *p = 0;

    while (p > String) {
        p--;
        *p = ((CHAR) Number & 0x0F) + '0';
        if (*p > '9') {
            *p += 'A' - ('9' + 1);
        }

        Number >>= 4;
    }

    return String + (sizeof (Number) * 2);
}


PWSTR
SzUnsignedToHexW (
    IN      ULONG_PTR Number,
    OUT     PWSTR String
    )
{
    PWSTR p;

    *String++ = L'0';
    *String++ = L'x';

    p = String + (sizeof (Number) * 2);
    *p = 0;

    while (p > String) {
        p--;
        *p = ((WCHAR) Number & 0x0F) + L'0';
        if (*p > L'9') {
            *p += L'A' - (L'9' + 1);
        }

        Number >>= 4;
    }

    return String + (sizeof (Number) * 2);
}


PSTR
SzUnsignedToDecA (
    IN      ULONG_PTR Number,
    OUT     PSTR String
    )
{
    UINT digits;
    ULONG_PTR temp;
    PSTR p;

    temp = Number;
    digits = 1;

    while (temp > 9) {
        digits++;
        temp /= 10;
    }

    p = String + digits;
    *p = 0;

    while (p > String) {
        p--;
        *p = (CHAR) (Number % 10) + '0';
        Number /= 10;
    }

    return String + digits;
}


PWSTR
SzUnsignedToDecW (
    IN      ULONG_PTR Number,
    OUT     PWSTR String
    )
{
    UINT digits;
    ULONG_PTR temp;
    PWSTR p;

    temp = Number;
    digits = 1;

    while (temp > 9) {
        digits++;
        temp /= 10;
    }

    p = String + digits;
    *p = 0;

    while (p > String) {
        p--;
        *p = (WCHAR) (Number % 10) + L'0';
        Number /= 10;
    }

    return String + digits;
}


PSTR
SzSignedToDecA (
    IN      LONG_PTR Number,
    OUT     PSTR String
    )
{
    if (Number < 0) {
        *String++ = '-';
        Number = -Number;
    }

    return SzUnsignedToDecA (Number, String);
}


PWSTR
SzSignedToDecW (
    IN      LONG_PTR Number,
    OUT     PWSTR String
    )
{
    if (Number < 0) {
        *String++ = L'-';
        Number = -Number;
    }

    return SzUnsignedToDecW (Number, String);
}


PSTR
SzFindPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    )
{
    PCSTR ptr = CurrPtr;

    while (ptr > StartStr) {

        ptr = _mbsdec (StartStr, ptr);
        if (!ptr) {
            ptr = StartStr;
        }

        if (_mbsnextc (ptr) == SearchChar) {
            return (PSTR) ptr;
        }
    }

    return NULL;
}


PWSTR
SzFindPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    )
{
    PCWSTR ptr = CurrPtr;

    while (ptr > StartStr) {
        ptr--;

        if (*ptr == SearchChar) {
            return (PWSTR) ptr;
        }
    }

    return NULL;
}


INT
pGetHexDigit (
    IN     INT c
    )
{
    if (c >= '0' && c <= '9') {
        return (c - '0');
    }

    if (c >= 'a' && c <= 'f') {
        return (c - 'a' + 10);
    }

    if (c >= 'A' && c <= 'F') {
        return (c - 'A' + 10);
    }

    return -1;
}


ULONG
SzToNumberA (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber      OPTIONAL
    )
{
    ULONG d = 0;
    INT v;

    if (_mbsnextc (String) == '0' &&
        tolower (_mbsnextc (SzNextCharA (String))) == 'x'
        ) {
        //
        // Get hex value
        //

        String = SzNextCharA (String);
        String = SzNextCharA (String);

        for (;;) {
            v = pGetHexDigit ((INT) _mbsnextc (String));
            if (v == -1) {
                break;
            }
            d = (d * 16) + v;

            String = SzNextCharA (String);
        }

    } else  {
        //
        // Get decimal value
        //

        while (_mbsnextc (String) >= '0' && _mbsnextc (String) <= '9')  {
            d = (d * 10) + (_mbsnextc (String) - '0');
            String = SzNextCharA (String);
        }
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return d;
}


ULONG
SzToNumberW (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber      OPTIONAL
    )
{
    ULONG d = 0;
    INT v;

    if (String[0] == L'0' && towlower (String[1]) == L'x') {
        //
        // Get hex value
        //

        String += 2;

        for (;;) {
            v = pGetHexDigit ((INT) (*String));
            if (v == -1) {
                break;
            }
            d = (d * 16) + v;

            String++;
        }

    } else  {
        //
        // Get decimal value
        //

        while (*String >= L'0' && *String <= L'9')  {
            d = (d * 10) + (*String - L'0');
            String++;
        }
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return d;
}


ULONGLONG
SzToULongLongA (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    ULONGLONG d = 0;
    INT v;

    if (_mbsnextc (String) == '0' &&
        tolower (_mbsnextc (SzNextCharA (String))) == 'x'
        ) {
        //
        // Get hex value
        //

        String = SzNextCharA (String);
        String = SzNextCharA (String);

        for (;;) {
            v = pGetHexDigit ((INT) _mbsnextc (String));
            if (v == -1) {
                break;
            }
            d = (d * 16) + (ULONGLONG) v;

            String = SzNextCharA (String);
        }

    } else  {
        //
        // Get decimal value
        //

        while (_mbsnextc (String) >= '0' && _mbsnextc (String) <= '9')  {
            d = (d * 10) + (ULONGLONG) (_mbsnextc (String) - '0');
            String = SzNextCharA (String);
        }
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return d;
}

ULONGLONG
SzToULongLongW (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    ULONGLONG d = 0;
    INT v;

    if (String[0] == L'0' && tolower (String[1]) == L'x') {
        //
        // Get hex value
        //

        String += 2;

        for (;;) {
            v = pGetHexDigit ((INT) (*String));
            if (v == -1) {
                break;
            }
            d = (d * 16) + (ULONGLONG) v;

            String++;
        }

    } else  {
        //
        // Get decimal value
        //

        while (*String >= L'0' && *String <= L'9')  {
            d = (d * 10) + (ULONGLONG) (*String - L'0');
            String++;
        }
    }

    if (EndOfNumber) {
        *EndOfNumber = String;
    }

    return d;
}

LONGLONG
SzToLongLongA (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    )
{
    LONGLONG l;

    if (_mbsnextc (String) == '-') {
        String = SzNextCharA (String);

        //
        // Get decimal value
        //

        l = 0;

        while (_mbsnextc (String) >= '0' && _mbsnextc (String) <= '9')  {
            l = (l * 10) + (LONGLONG) (_mbsnextc (String) - '0');
            String = SzNextCharA (String);
        }

        l = -l;

        if (EndOfNumber) {
            *EndOfNumber = String;
        }

        return l;

    } else {
        return (LONGLONG) SzToULongLongA (String, EndOfNumber);
    }
}

LONGLONG
SzToLongLongW (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    )
{
    LONGLONG l;

    if (*String == L'-') {
        String++;

        //
        // Get decimal value
        //

        l = 0;

        while (*String >= L'0' && *String <= L'9')  {
            l = (l * 10) + (LONGLONG) (*String - L'0');
            String++;
        }

        l = -l;

        if (EndOfNumber) {
            *EndOfNumber = String;
        }

        return l;

    } else {
        return (LONGLONG) SzToULongLongW (String, EndOfNumber);
    }
}


PSTR
SzCopyNextCharA (
    OUT     PSTR Dest,
    IN      PCSTR Source
    )
{
    PCSTR nextSrc;

    nextSrc = SzNextCharA (Source);
    switch (nextSrc - Source) {
    case 3:
        *Dest++ = *Source++;
    case 2:
        *Dest++ = *Source++;
    case 1:
        *Dest++ = *Source;
        break;
    }

    return Dest;
}


PSTR
SzTrimLastCharA (
    IN OUT  PSTR String,
    IN      MBCHAR LogChar
    )
{
    PSTR end;

    end = SzGetEndA (String);
    end = _mbsdec (String, end);

    if ((end >= String) && (_mbsnextc (end) == LogChar)) {
        do {
            *end = 0;
            end = _mbsdec (String, end);
        } while ((end >= String) && (_mbsnextc (end) == LogChar));

        return end < String ? String : end;
    }

    return NULL;
}


PWSTR
SzTrimLastCharW (
    IN OUT  PWSTR String,
    IN      WCHAR LogChar
    )
{
    PWSTR end;

    end = SzGetEndW (String);
    end--;

    if ((end >= String) && (*end == LogChar)) {
        do {
            *end = 0;
            end--;
        } while ((end >= String) && (*end == LogChar));

        return end < String ? String : end;
    }

    return NULL;
}


PSTR
SzAppendWackA (
    IN      PSTR String
    )
{
    PCSTR last;

    if (!String) {
        return NULL;
    }

    last = String;

    while (*String) {
        last = String;
        String = SzNextCharA (String);
    }

    if (_mbsnextc (last) != '\\') {
        *String = '\\';
        String++;
        *String = 0;
    }

    return String;
}


PWSTR
SzAppendWackW (
    IN      PWSTR String
    )
{
    PCWSTR last;

    if (!String) {
        return NULL;
    }

    if (*String) {
        String = SzGetEndW (String);
        last = String - 1;
    } else {
        last = String;
    }

    if (*last != '\\') {
        *String = L'\\';
        String++;
        *String = 0;
    }

    return String;
}


PCSTR
SzGetFileNameFromPathA (
    IN      PCSTR Path
    )
{
    PCSTR p;

    p = _mbsrchr (Path, '\\');
    if (p) {
        p = SzNextCharA (p);
    } else {
        p = Path;
    }

    return p;
}

PCWSTR
SzGetFileNameFromPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR p;

    p = wcsrchr (Path, L'\\');
    if (p) {
        p++;
    } else {
        p = Path;
    }

    return p;
}


PCSTR
SzGetFileExtensionFromPathA (
    IN      PCSTR Path
    )
{
    PCSTR p;
    MBCHAR ch;
    PCSTR returnPtr = NULL;

    p = Path;

    while (*p) {
        ch = _mbsnextc (p);

        if (ch == '.') {
            returnPtr = SzNextCharA (p);
        } else if (ch == '\\') {
            returnPtr = NULL;
        }

        p = SzNextCharA (p);
    }

    return returnPtr;
}

PCWSTR
SzGetFileExtensionFromPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR p;
    PCWSTR returnPtr = NULL;

    p = Path;

    while (*p) {
        if (*p == L'.') {
            returnPtr = p + 1;
        } else if (*p == L'\\') {
            returnPtr = NULL;
        }

        p++;
    }

    return returnPtr;
}


PCSTR
SzGetDotExtensionFromPathA (
    IN      PCSTR Path
    )
{
    PCSTR p;
    MBCHAR ch;
    PCSTR returnPtr = NULL;

    p = Path;

    while (*p) {
        ch = _mbsnextc (p);

        if (ch == '.') {
            returnPtr = p;
        } else if (ch == '\\') {
            returnPtr = NULL;
        }

        p = SzNextCharA (p);
    }

    if (!returnPtr) {
        return p;
    }

    return returnPtr;
}

PCWSTR
SzGetDotExtensionFromPathW (
    IN      PCWSTR Path
    )
{
    PCWSTR p;
    PCWSTR returnPtr = NULL;

    p = Path;

    while (*p) {
        if (*p == L'.') {
            returnPtr = p;
        } else if (*p == L'\\') {
            returnPtr = NULL;
        }

        p++;
    }

    if (!returnPtr) {
        return p;
    }

    return returnPtr;
}


PCSTR
SzSkipSpaceA (
    IN      PCSTR String
    )
{
    if (!String) {
        return NULL;
    }

    while (_ismbcspace (_mbsnextc (String))) {
        String = SzNextCharA (String);
    }

    return String;
}

PCWSTR
SzSkipSpaceW (
    IN      PCWSTR String
    )
{
    if (!String) {
        return NULL;
    }

    while (iswspace (*String)) {
        String++;
    }

    return String;
}


PCSTR
SzSkipSpaceRA (
    IN      PCSTR BaseString,
    IN      PCSTR String            OPTIONAL
    )
{
    if (!String) {
        String = SzGetEndA (BaseString);
    }

    if (*String == 0) {
        String = _mbsdec (BaseString, String);
    }

    while (String >= BaseString) {

        if (!_ismbcspace (_mbsnextc (String))) {
            return String;
        }

        String = _mbsdec (BaseString, String);
    }

    return NULL;
}


PCWSTR
SzSkipSpaceRW (
    IN      PCWSTR BaseString,
    IN      PCWSTR String       // can be any char along BaseString
    )
{
    if (!String) {
        String = SzGetEndW (BaseString);
    }

    if (*String == 0) {
        String--;
    }

    while (String >= BaseString) {

        if (!iswspace (*String)) {
            return String;
        }

        String--;

    }

    return NULL;
}


PSTR
SzTruncateTrailingSpaceA (
    IN OUT  PSTR String
    )
{
    PSTR end;
    MBCHAR ch;

    end = String;

    while (*String) {
        ch = _mbsnextc (String);
        String = SzNextCharA (String);

        if (!_ismbcspace (ch)) {
            end = String;
        }
    }

    *end = 0;

    return end;
}


PWSTR
SzTruncateTrailingSpaceW (
    IN OUT  PWSTR String
    )
{
    PWSTR end;
    WCHAR ch;

    end = String;

    while (*String) {
        ch = *String++;

        if (!iswspace (ch)) {
            end = String;
        }
    }

    *end = 0;

    return end;
}


BOOL
SzIsPrintA (
    IN      PCSTR String
    )

{
    while (*String && _ismbcprint (_mbsnextc (String))) {
        String = SzNextCharA (String);
    }

    return *String == 0;
}


BOOL
SzIsPrintW (
    IN      PCWSTR String
    )

{
    while (*String && iswprint (*String)) {
        String++;
    }

    return *String == 0;
}


PCSTR
SzIFindSubStringA (
    IN      PCSTR String,
    IN      PCSTR SubString
    )

{
    PCSTR start;
    PCSTR middle;
    PCSTR subStrMiddle;
    PCSTR end;

    end = (PSTR) ((PBYTE) String + SzByteCountA (String) - SzByteCountA (SubString));

    for (start = String ; start <= end ; start = SzNextCharA (start)) {
        middle = start;
        subStrMiddle = SubString;

        while (*subStrMiddle &&
               _mbctolower (_mbsnextc (subStrMiddle)) == _mbctolower (_mbsnextc (middle))
               ) {
            middle = SzNextCharA (middle);
            subStrMiddle = SzNextCharA (subStrMiddle);
        }

        if (!(*subStrMiddle)) {
            return start;
        }
    }

    return NULL;
}


PCWSTR
SzIFindSubStringW (
    IN      PCWSTR String,
    IN      PCWSTR SubString
    )

{
    PCWSTR start;
    PCWSTR middle;
    PCWSTR subStrMiddle;
    PCWSTR end;

    end = (PWSTR) ((PBYTE) String + SzByteCountW (String) - SzByteCountW (SubString));

    for (start = String ; start <= end ; start++) {
        middle = start;
        subStrMiddle = SubString;

        while (*subStrMiddle && (towlower (*subStrMiddle) == towlower (*middle))) {
            middle++;
            subStrMiddle++;
        }

        if (!(*subStrMiddle)) {
            return start;
        }
    }

    return NULL;
}


UINT
SzCountInstancesOfLcharA (
    IN      PCSTR String,
    IN      MBCHAR LogChar
    )
{
    UINT count;

    if (!String) {
        return 0;
    }

    count = 0;
    while (*String) {
        if (_mbsnextc (String) == LogChar) {
            count++;
        }

        String = SzNextCharA (String);
    }

    return count;
}


UINT
SzCountInstancesOfLcharW (
    IN      PCWSTR String,
    IN      WCHAR LogChar
    )
{
    UINT count;

    if (!String) {
        return 0;
    }

    count = 0;
    while (*String) {
        if (*String == LogChar) {
            count++;
        }

        String++;
    }

    return count;
}


UINT
SzICountInstancesOfLcharA (
    IN      PCSTR String,
    IN      MBCHAR LogChar
    )
{
    UINT count;

    if (!String) {
        return 0;
    }

    LogChar = _mbctolower (LogChar);

    count = 0;
    while (*String) {
        if (_mbctolower (_mbsnextc (String)) == LogChar) {
            count++;
        }

        String = SzNextCharA (String);
    }

    return count;
}


UINT
SzICountInstancesOfLcharW (
    IN      PCWSTR String,
    IN      WCHAR LogChar
    )
{
    UINT count;

    if (!String) {
        return 0;
    }

    LogChar = towlower (LogChar);

    count = 0;
    while (*String) {
        if (towlower (*String) == LogChar) {
            count++;
        }

        String++;
    }

    return count;
}


BOOL
SzReplaceA (
    IN OUT  PSTR Buffer,
    IN      SIZE_T MaxSize,
    IN      PSTR ReplaceStartPos,   // within Buffer
    IN      PSTR ReplaceEndPos,
    IN      PCSTR NewString
    )
{
    BOOL result = FALSE;
    SIZE_T oldSubStringLength;
    SIZE_T newSubStringLength;
    SIZE_T currentStringLength;
    SIZE_T offset;
    SIZE_T bytesToMove;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(ReplaceEndPos <= Buffer + MaxSize);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (PBYTE) ReplaceEndPos - (PBYTE) ReplaceStartPos;
    newSubStringLength  = SzByteCountA (NewString);
    currentStringLength = SzSizeA (Buffer);
    offset = newSubStringLength - oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if (currentStringLength + offset > MaxSize) {
        DEBUGMSG((DBG_WARNING, "ERROR: Buffer to small to perform string replacement."));
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (offset != 0) {

            //
            // Shift right side of string to make room for new data.
            //

            bytesToMove = currentStringLength;
            bytesToMove -= (PBYTE) ReplaceEndPos - (PBYTE) Buffer;

            MoveMemory (
                (PBYTE) ReplaceEndPos + offset,
                (PBYTE) ReplaceEndPos,
                bytesToMove
                );
        }

        //
        // Now, copy in the string.
        //
        CopyMemory (ReplaceStartPos, NewString, newSubStringLength);    //lint !e668

        //
        // String replacement completed successfully.
        //
        result = TRUE;
    }

    return result;

}



BOOL
SzReplaceW (
    IN OUT  PWSTR Buffer,
    IN      SIZE_T MaxSize,
    IN      PWSTR ReplaceStartPos,   // within Buffer
    IN      PWSTR ReplaceEndPos,
    IN      PCWSTR NewString
    )
{
    BOOL result = FALSE;
    SIZE_T oldSubStringLength;
    SIZE_T newSubStringLength;
    SIZE_T currentStringLength;
    SIZE_T offset;
    SIZE_T bytesToMove;

    //
    // Check assumptions.
    //
    MYASSERT(Buffer);
    MYASSERT(ReplaceStartPos && ReplaceStartPos >= Buffer);
    MYASSERT(ReplaceEndPos && ReplaceEndPos >= ReplaceStartPos);  //lint !e613
    MYASSERT(ReplaceEndPos <= Buffer + MaxSize);  //lint !e613
    MYASSERT(NewString);

    //
    // Compute sizes.
    //
    oldSubStringLength  = (PBYTE) ReplaceEndPos - (PBYTE) ReplaceStartPos;
    newSubStringLength  = SzByteCountW (NewString);
    currentStringLength = SzSizeW (Buffer);
    offset = newSubStringLength - oldSubStringLength;

    //
    // Make sure there is enough room in the buffer to perform the replace
    // operation.
    //
    if (currentStringLength + offset > MaxSize) {
        DEBUGMSG((DBG_WARNING, "ERROR: Buffer to small to perform string replacement."));
    } else {

        //
        // Shift the rest of the buffer to adjust it to the size of the new string.
        //
        if (offset != 0) {

            //
            // Shift right side of string to make room for new data.
            //

            bytesToMove = currentStringLength;
            bytesToMove -= (PBYTE) ReplaceEndPos - (PBYTE) Buffer;

            MoveMemory (
                (PBYTE) ReplaceEndPos + offset,
                (PBYTE) ReplaceEndPos,
                bytesToMove
                );
        }

        //
        // Now, copy in the string.
        //
        CopyMemory (ReplaceStartPos, NewString, newSubStringLength);    //lint !e668

        //
        // String replacement completed successfully.
        //
        result = TRUE;
    }

    return result;

}

UINT
SzCountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT count;
    UINT searchTchars;

    count = 0;
    p = SourceString;
    searchTchars = SzTcharCountA (SearchString);

    if (!searchTchars) {
        return 0;
    }

    while (p = SzFindSubStringA (p, SearchString)) {    //lint !e720
        count++;
        p += searchTchars;
    }

    return count;
}


UINT
SzCountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT count;
    UINT searchTchars;

    count = 0;
    p = SourceString;
    searchTchars = SzTcharCountW (SearchString);

    if (!searchTchars) {
        return 0;
    }

    while (p = SzFindSubStringW (p, SearchString)) {    //lint !e720
        count++;
        p += searchTchars;
    }

    return count;
}

UINT
SzICountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    )
{
    PCSTR p;
    UINT count;
    UINT searchTchars;

    count = 0;
    p = SourceString;
    searchTchars = SzTcharCountA (SearchString);

    if (!searchTchars) {
        return 0;
    }

    while (p = SzIFindSubStringA (p, SearchString)) {    //lint !e720
        count++;
        p += searchTchars;
    }

    return count;
}


UINT
SzICountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    )
{
    PCWSTR p;
    UINT count;
    UINT searchTchars;

    count = 0;
    p = SourceString;
    searchTchars = SzTcharCountW (SearchString);

    if (!searchTchars) {
        return 0;
    }

    while (p = SzIFindSubStringW (p, SearchString)) {    //lint !e720
        count++;
        p += searchTchars;
    }

    return count;
}


BOOL
MszEnumFirstA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    )
{
    ZeroMemory (MultiSzEnum, sizeof (MULTISZ_ENUMA));
    MultiSzEnum->Buffer = MultiSzStr;

    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = MultiSzStr;

    return TRUE;
}


BOOL
MszEnumFirstW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    )
{
    ZeroMemory (MultiSzEnum, sizeof (MULTISZ_ENUMA));
    MultiSzEnum->Buffer = MultiSzStr;

    if ((MultiSzStr == NULL) || (MultiSzStr [0] == 0)) {
        return FALSE;
    }

    MultiSzEnum->CurrentString = MultiSzStr;

    return TRUE;
}


BOOL
MszEnumNextA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    )
{
    BOOL result = FALSE;

    if (MultiSzEnum->CurrentString && (*MultiSzEnum->CurrentString)) {
        MultiSzEnum->CurrentString = SzGetEndA (MultiSzEnum->CurrentString) + 1;
        result = (MultiSzEnum->CurrentString [0] != 0);

        if (!result) {
            MultiSzEnum->CurrentString = NULL;
        }
    }

    return result;
}


BOOL
MszEnumNextW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    )
{
    BOOL result = FALSE;

    if (MultiSzEnum->CurrentString && (*MultiSzEnum->CurrentString)) {
        MultiSzEnum->CurrentString = SzGetEndW (MultiSzEnum->CurrentString) + 1;
        result = (MultiSzEnum->CurrentString [0] != 0);

        if (!result) {
            MultiSzEnum->CurrentString = NULL;
        }
    }

    return result;
}

PCSTR
MszFindStringA (
    IN      PCSTR MultiSz,
    IN      PCSTR String
    )
{
    MULTISZ_ENUMA multiSzEnum;

    ZeroMemory (&multiSzEnum, sizeof (multiSzEnum));
    if (!String || *String == 0) {
        return NULL;
    }

    if (MszEnumFirstA (&multiSzEnum, MultiSz)) {
        do {
            if (SzMatchA (String, multiSzEnum.CurrentString)) {
                break;
            }
        } while (MszEnumNextA (&multiSzEnum));
    }

    return multiSzEnum.CurrentString;
}


PCWSTR
MszFindStringW (
    IN      PCWSTR MultiSz,
    IN      PCWSTR String
    )
{
    MULTISZ_ENUMW multiSzEnum;

    ZeroMemory (&multiSzEnum, sizeof (multiSzEnum));
    if (!String || *String == 0) {
        return NULL;
    }

    if (MszEnumFirstW (&multiSzEnum, MultiSz)) {
        do {
            if (SzMatchW (String, multiSzEnum.CurrentString)) {
                break;
            }
        } while (MszEnumNextW (&multiSzEnum));
    }

    return multiSzEnum.CurrentString;
}


PCSTR
MszIFindStringA (
    IN      PCSTR MultiSz,
    IN      PCSTR String
    )
{
    MULTISZ_ENUMA multiSzEnum;

    ZeroMemory (&multiSzEnum, sizeof (multiSzEnum));
    if (!String || *String == 0) {
        return NULL;
    }

    if (MszEnumFirstA (&multiSzEnum, MultiSz)) {
        do {
            if (SzIMatchA (String, multiSzEnum.CurrentString)) {
                break;
            }
        } while (MszEnumNextA (&multiSzEnum));
    }

    return multiSzEnum.CurrentString;
}


PCWSTR
MszIFindStringW (
    IN      PCWSTR MultiSz,
    IN      PCWSTR String
    )
{
    MULTISZ_ENUMW multiSzEnum;

    ZeroMemory (&multiSzEnum, sizeof (multiSzEnum));
    if (!String || *String == 0) {
        return NULL;
    }

    if (MszEnumFirstW (&multiSzEnum, MultiSz)) {
        do {
            if (SzIMatchW (String, multiSzEnum.CurrentString)) {
                break;
            }
        } while (MszEnumNextW (&multiSzEnum));
    }

    return multiSzEnum.CurrentString;
}


PCSTR
SzConcatenatePathsA (
    IN OUT  PSTR PathBuffer,
    IN      PCSTR PathSuffix,           OPTIONAL
    IN      UINT BufferTchars
    )

/*++

Routine Description:

  Concatenate two path strings together, supplying a path separator character
  (\) if necessary between the two parts.

Arguments:

    PathBuffer - Specifies the base path, which can end with a backslash.
        Receives the joined path.

    PathSuffix - Specifies the suffix to concatinate to the base path
        specified by PathBuffer. It can start with a backslash. If NULL is
        specified, then PathBuffer will be terminated with a backslash.

    BufferTchars - Specifies the size, in CHARs (ANSI) or WCHARs (Unicode), of
        PathBuffer. The inbound PathBuffer string must fit within this size.
        If the result is truncated, it will fill the buffer as much as
        possible.

Return Value:

    A pointer to the end of the string in PathBuffer.

--*/

{
    PSTR p;
    PSTR q;
    PSTR end;
    PSTR lastChar;
    PCSTR srcEnd;
    PCSTR nextChar;
    PCSTR srcMax;

    if (!PathBuffer || !BufferTchars) {
        return NULL;
    }

    MYASSERT (BufferTchars > 128);      // BUGBUG -- temporary porting aide

    p = SzGetEndA (PathBuffer);
    end = PathBuffer + BufferTchars;

    MYASSERT (p < end); // inbound string must always fit in the buffer
    end--;
    if (p == end) {
        return p;       // inbound path fills buffer completely
    }

    lastChar = _mbsdec (PathBuffer, p);
    if ((lastChar < PathBuffer) || (*lastChar != '\\')) {
        *p++ = '\\';
    }

    if (PathSuffix) {
        if (*PathSuffix == '\\') {
            PathSuffix++;
        }

        srcEnd = PathSuffix;
        srcMax = PathSuffix + (end - p);

        while (*srcEnd) {
            nextChar = SzNextCharA (srcEnd);
            if (nextChar > srcMax) {
                break;
            }

            srcEnd = nextChar;
        }

        while (PathSuffix < srcEnd) {
            *p++ = *PathSuffix++;
        }
    }

    *p = 0;
    return p;
}


PCWSTR
SzConcatenatePathsW (
    IN OUT  PWSTR PathBuffer,
    IN      PCWSTR PathSuffix,      OPTIONAL
    IN      UINT BufferTchars
    )

/*++

Routine Description:

  Concatenate two path strings together, supplying a path separator character
  (\) if necessary between the two parts.

Arguments:

    PathBuffer - Specifies the base path, which can end with a backslash.
        Receives the joined path.

    PathSuffix - Specifies the suffix to concatinate to the base path
        specified by PathBuffer. It can start with a backslash. If NULL is
        specified, then PathBuffer will be terminated with a backslash.

    BufferTchars - Specifies the size, in CHARs (ANSI) or WCHARs (Unicode), of
        PathBuffer. The inbound PathBuffer string must fit within this size.
        If the result is truncated, it will fill the buffer as much as
        possible.

Return Value:

    A pointer to the end of the string in PathBuffer.

--*/

{
    PWSTR p;
    PWSTR q;
    PWSTR end;
    PWSTR lastChar;
    PCWSTR srcEnd;
    PCWSTR srcMax;

    if (!PathBuffer || !BufferTchars) {
        return NULL;
    }

    MYASSERT (BufferTchars > 128);      // BUGBUG -- temporary porting aide

    p = SzGetEndW (PathBuffer);
    end = PathBuffer + BufferTchars;

    MYASSERT (p < end); // inbound string must always fit in the buffer
    end--;
    if (p == end) {
        return p;       // inbound path fills buffer completely
    }

    lastChar = p - 1;
    if ((lastChar < PathBuffer) || (*lastChar != L'\\')) {
        *p++ = L'\\';
    }

    if (PathSuffix) {
        if (*PathSuffix == L'\\') {
            PathSuffix++;
        }

        srcEnd = SzGetEndW (PathSuffix);
        srcMax = PathSuffix + (end - p);
        srcEnd = min (srcEnd, srcMax);

        while (PathSuffix < srcEnd) {
            *p++ = *PathSuffix++;
        }
    }

    *p = 0;
    return p;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\strmap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    strmap.c

Abstract:

    The SzMap routines are used to do fast search and replace. The table is
    built of a linked list of characters, so that finding a string is
    simply a matter of walking down a linked list. These routines perform
    quite well for general search & replace use.

    Also, it is common to use string maps as index tables for certain
    types of data where search strings often repeat the same left side of
    the string (such as paths). In this case, often the replacement string is
    empty.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm)   05-Jun-2000     Added multi table capability

    Jim Schmidt (jimschm)   08-May-2000     Improved replacement routines and
                                            added consistent filtering and
                                            extra data option

    Jim Schmidt (jimschm)   18-Aug-1998     Redesigned to fix two bugs, made
                                            A & W versions

--*/

//
// Includes
//

#include "pch.h"
#include "commonp.h"

// BUGBUG - remove this
__inline
BOOL
SzIsLeadByte (
    MBCHAR ch
    )
{
    MYASSERT (FALSE);
    return FALSE;
}

//
// Strings
//

// None

//
// Constants
//

#define CHARNODE_SINGLE_BYTE            0x0000
#define CHARNODE_DOUBLE_BYTE            0x0001
#define CHARNODE_REQUIRE_WACK_OR_NUL    0x0002

//
// Macros
//

// None

//
// Types
//

typedef struct {
    PVOID Next;
    BYTE Memory[];
} MAPALLOC, *PMAPALLOC;

//
// Globals
//

// None

//
// Macro expansion list
//

// None

//
// Private function prototypes
//

// None

//
// Macro expansion definition
//

// None

//
// Code
//

PVOID
pAllocateInMap (
    IN      PSTRINGMAP Map,
    IN      UINT Bytes
    )
{
    PMAPALLOC alloc;

    alloc = (PMAPALLOC) MALLOC_UNINIT (Bytes + sizeof (MAPALLOC));
    MYASSERT (alloc);

    alloc->Next = Map->CleanUpChain;
    Map->CleanUpChain = alloc;

    return alloc->Memory;
}

PSTR
pDupInMapA (
    IN      PSTRINGMAP Map,
    IN      PCSTR String
    )
{
    UINT bytes;
    PSTR result;

    bytes = SzSizeA (String);
    result = pAllocateInMap (Map, bytes);
    MYASSERT (result);

    CopyMemory (result, String, bytes);
    return result;
}


PWSTR
pDupInMapW (
    IN      PSTRINGMAP Map,
    IN      PCWSTR String
    )
{
    UINT bytes;
    PWSTR result;

    bytes = SzSizeW (String);
    result = pAllocateInMap (Map, bytes);
    MYASSERT (result);

    CopyMemory (result, String, bytes);
    return result;
}


PSTRINGMAP
SzMapCreateEx (
    IN      BOOL UsesFilters,
    IN      BOOL UsesExtraData
    )

/*++

Routine Description:

  SzMapCreateEx allocates a string mapping data structure and initializes it.
  Callers can enable filter callbacks, extra data support, or both. The
  mapping structure contains either CHARNODE elements, or CHARNODEEX elements,
  depending on the UsesFilters or UsesExtraData flag.

Arguments:

  UsesFilters   - Specifies TRUE to enable filter callbacks. If enabled,
                  those who add string pairs must specify the filter callback
                  (each search/replace pair has its own callback)
  UsesExtraData - Specifies TRUE to associate extra data with the string
                  mapping pair.

Return Value:

  A handle to the string mapping structure, or NULL if a structure could not
  be created.

--*/

{
    PSTRINGMAP map;

    map = (PSTRINGMAP) MALLOC_ZEROED (sizeof (STRINGMAP));
    MYASSERT (map);

    map->UsesExNode = UsesFilters|UsesExtraData;
    map->UsesFilter = UsesFilters;
    map->UsesExtraData = UsesExtraData;
    map->CleanUpChain = NULL;

    return map;
}

VOID
SzMapDestroy (
    IN      PSTRINGMAP Map
    )
{
    PMAPALLOC next;
    PMAPALLOC current;

    if (Map) {
        next = (PMAPALLOC) Map->CleanUpChain;
        while (next) {
            current = next;
            next = current->Next;

            FREE(current);
        }

        FREE(Map);
    }
}

PCHARNODE
pFindCharNode (
    IN      PSTRINGMAP Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char
    )
{
    PCHARNODE Node;

    if (!PrevNode) {
        Node = Map->FirstLevelRoot;
    } else {
        Node = PrevNode->NextLevel;
    }

    while (Node) {
        if (Node->Char == Char) {
            return Node;
        }
        Node = Node->NextPeer;
    }

    return NULL;
}

PCHARNODE
pAddCharNode (
    IN      PSTRINGMAP Map,
    IN      PCHARNODE PrevNode,     OPTIONAL
    IN      WORD Char,
    IN      WORD Flags
    )
{
    PCHARNODE Node;
    PCHARNODEEX exNode;

    if (Map->UsesExNode) {
        exNode = pAllocateInMap (Map, sizeof (CHARNODEEX));
        Node = (PCHARNODE) exNode;
        MYASSERT (Node);
        ZeroMemory (exNode, sizeof (CHARNODEEX));
    } else {
        Node = pAllocateInMap (Map, sizeof (CHARNODE));
        MYASSERT (Node);
        ZeroMemory (Node, sizeof (CHARNODE));
    }

    Node->Char = Char;
    Node->Flags = Flags;

    if (PrevNode) {
        Node->NextPeer = PrevNode->NextLevel;
        PrevNode->NextLevel = Node;
    } else {
        Node->NextPeer = Map->FirstLevelRoot;
        Map->FirstLevelRoot = Node;
    }

    return Node;
}


VOID
SzMapAddExA (
    IN OUT  PSTRINGMAP Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      STRINGMAP_FILTER Filter,            OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  SzMapAddEx adds a search and replace string pair to the linked list data
  structures. If the same search string is already in the structures, then the
  replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag STRINGMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PSTR oldCopy;
    PSTR newCopy;
    PCSTR p;
    WORD w;
    PCHARNODE prev;
    PCHARNODE Node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & SZMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    oldCopy = pDupInMapA (Map, Old);
    newCopy = pDupInMapA (Map, New);

    //
    // Make oldCopy all lowercase
    //

    CharLowerA (oldCopy);

    //
    // Add the letters that are not in the mapping
    //

    for (prev = NULL, p = oldCopy ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);
        Node = pFindCharNode (Map, prev, w);
        if (!Node) {
            break;
        }
        prev = Node;
    }

    for ( ; *p ; p = _mbsinc (p)) {
        w = (WORD) _mbsnextc (p);

        nodeFlags |= (WORD) (SzIsLeadByte (*p) ? CHARNODE_DOUBLE_BYTE : CHARNODE_SINGLE_BYTE);
        prev = pAddCharNode (Map, prev, w, nodeFlags);
    }

    if (prev) {
        SzCopyA (oldCopy, Old);
        prev->OriginalStr = (PVOID) oldCopy;
        prev->ReplacementStr = (PVOID) newCopy;
        prev->ReplacementBytes = SzByteCountA (newCopy);

        exNode = (PCHARNODEEX) prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


VOID
SzMapAddExW (
    IN OUT  PSTRINGMAP Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      STRINGMAP_FILTER Filter,            OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    )

/*++

Routine Description:

  SzMapAddEx adds a search and replace string pair to the linked list data
  structures. If the same search string is already in the structures, then the
  replace string and optional extra data is updated.

Arguments:

  Map       - Specifies the string mapping
  Old       - Specifies the search string
  New       - Specifies the replace string
  Filter    - Specifies the callback filter. This is only supported if the
              map was created with filter support enabled.
  ExtraData - Specifies arbitrary data to assign to the search/replace pair.
              This is only valid if the map was created with extra data
              enabled.
  Flags     - Specifies optional flag SZMAP_REQUIRE_WACK_OR_NUL

Return Value:

  None.

--*/

{
    PWSTR oldCopy;
    PWSTR newCopy;
    PCWSTR p;
    WORD w;
    PCHARNODE prev;
    PCHARNODE node;
    PCHARNODEEX exNode;
    WORD nodeFlags = 0;

    if (Flags & SZMAP_REQUIRE_WACK_OR_NUL) {
        nodeFlags = CHARNODE_REQUIRE_WACK_OR_NUL;
    }

    MYASSERT (Map);
    MYASSERT (Old);
    MYASSERT (New);
    MYASSERT (*Old);

    //
    // Duplicate strings
    //

    oldCopy = pDupInMapW (Map, Old);
    newCopy = pDupInMapW (Map, New);

    //
    // Make oldCopy all lowercase
    //

    CharLowerW (oldCopy);

    //
    // Add the letters that are not in the mapping
    //

    prev = NULL;
    p = oldCopy;
    while (w = *p) {        // intentional assignment optimization

        node = pFindCharNode (Map, prev, w);
        if (!node) {
            break;
        }
        prev = node;

        p++;
    }

    while (w = *p) {        // intentional assignment optimization

        prev = pAddCharNode (Map, prev, w, nodeFlags);
        p++;
    }

    if (prev) {
        SzCopyW (oldCopy, Old);
        prev->OriginalStr = oldCopy;
        prev->ReplacementStr = (PVOID) newCopy;
        prev->ReplacementBytes = SzByteCountW (newCopy);

        exNode = (PCHARNODEEX) prev;

        if (Map->UsesExtraData) {
            exNode->ExtraData = ExtraData;
        }

        if (Map->UsesFilter) {
            exNode->Filter = Filter;
        }
    }
}


PCSTR
pFindReplacementStringInOneMapA (
    IN      PSTRINGMAP Map,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PSTRINGMAP_FILTER_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE bestMatch;
    PCHARNODE node;
    WORD mbChar;
    PCSTR OrgSource;
    PCSTR newString = NULL;
    INT newStringSizeInBytes = 0;
    PCHARNODEEX exNode;
    BOOL replacementFound;

    *SourceBytesPtr = 0;

    node = NULL;
    bestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        mbChar = (WORD) _mbsnextc (Source);

        node = pFindCharNode (Map, node, mbChar);

        if (node) {
            //
            // Advance string pointer
            //

            if (node->Flags & CHARNODE_DOUBLE_BYTE) {
                Source += 2;
            } else {
                Source++;
            }

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && _mbsnextc (Source) != '\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCSTR) node->ReplacementStr;
                newStringSizeInBytes = node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) node;

                    if (exNode->Filter) {
                        Data->Ansi.BeginningOfMatch = OrgSource;
                        Data->Ansi.OldSubString = (PCSTR) node->OriginalStr;
                        Data->Ansi.NewSubString = newString;
                        Data->Ansi.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Ansi.NewSubString;
                            newStringSizeInBytes = Data->Ansi.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    bestMatch = node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No node ends the search
            //

            break;
        }

    }

    if (bestMatch) {
        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) bestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCSTR
pFindReplacementStringA (
    IN      PSTRINGMAP *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PSTRINGMAP_FILTER_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapA (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


PCWSTR
pFindReplacementStringInOneMapW (
    IN      PSTRINGMAP Map,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PSTRINGMAP_FILTER_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    PCHARNODE bestMatch;
    PCHARNODE node;
    PCWSTR OrgSource;
    PCWSTR newString = NULL;
    INT newStringSizeInBytes;
    BOOL replacementFound;
    PCHARNODEEX exNode;

    *SourceBytesPtr = 0;

    node = NULL;
    bestMatch = NULL;

    OrgSource = Source;

    while (*Source) {

        node = pFindCharNode (Map, node, *Source);

        if (node) {
            //
            // Advance string pointer
            //

            Source++;

            if (((PBYTE) Source - (PBYTE) OrgSource) > MaxSourceBytes) {
                break;
            }

            //
            // If replacement string is available, keep it
            // until a longer match comes along
            //

            replacementFound = (node->ReplacementStr != NULL);

            if ((RequireWackOrNul || (node->Flags & CHARNODE_REQUIRE_WACK_OR_NUL)) && replacementFound) {

                if (*Source && *Source != L'\\') {
                    replacementFound = FALSE;
                }
            }

            if (replacementFound) {

                newString = (PCWSTR) node->ReplacementStr;
                newStringSizeInBytes = node->ReplacementBytes;

                if (Map->UsesFilter) {
                    //
                    // Call rename filter to allow denial of match
                    //

                    exNode = (PCHARNODEEX) node;

                    if (exNode->Filter) {
                        Data->Unicode.BeginningOfMatch = OrgSource;
                        Data->Unicode.OldSubString = (PCWSTR) node->OriginalStr;
                        Data->Unicode.NewSubString = newString;
                        Data->Unicode.NewSubStringSizeInBytes = newStringSizeInBytes;

                        if (!exNode->Filter (Data)) {
                            replacementFound = FALSE;
                        } else {
                            newString = Data->Unicode.NewSubString;
                            newStringSizeInBytes = Data->Unicode.NewSubStringSizeInBytes;
                        }
                    }
                }

                if (replacementFound) {
                    bestMatch = node;
                    *SourceBytesPtr = (HALF_PTR) ((PBYTE) Source - (PBYTE) OrgSource);
                }
            }

        } else {
            //
            // No node ends the search
            //

            break;
        }

    }

    if (bestMatch) {

        //
        // Return replacement data to caller
        //

        if (ExtraDataValue) {

            if (Map->UsesExtraData) {
                exNode = (PCHARNODEEX) bestMatch;
                *ExtraDataValue = exNode->ExtraData;
            } else {
                *ExtraDataValue = 0;
            }
        }

        *ReplacementBytesPtr = newStringSizeInBytes;
        return newString;
    }

    return NULL;
}


PCWSTR
pFindReplacementStringW (
    IN      PSTRINGMAP *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR Source,
    IN      INT MaxSourceBytes,
    OUT     PINT SourceBytesPtr,
    OUT     PINT ReplacementBytesPtr,
    IN      PSTRINGMAP_FILTER_DATA Data,
    OUT     ULONG_PTR *ExtraDataValue,          OPTIONAL
    IN      BOOL RequireWackOrNul
    )
{
    UINT u;
    PCWSTR result;

    for (u = 0 ; u < MapArrayCount ; u++) {

        if (!MapArray[u]) {
            continue;
        }

        result = pFindReplacementStringInOneMapW (
                        MapArray[u],
                        Source,
                        MaxSourceBytes,
                        SourceBytesPtr,
                        ReplacementBytesPtr,
                        Data,
                        ExtraDataValue,
                        RequireWackOrNul
                        );

        if (result) {
            return result;
        }
    }

    return NULL;
}


BOOL
SzMapMultiTableSearchAndReplaceExA (
    IN      PSTRINGMAP *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )

/*++

Routine Description:

  SzMapSearchAndReplaceEx performs a search/replace operation based on the
  specified string mapping. The replace can be in-place or to another buffer.

Arguments:

  MapArray          - Specifies an array of string mapping tables that holds
                      zero or more search/replace pairs
  MapArrayCount     - Specifies the number of mapping tables in MapArray
  SrcBuffer         - Specifies the source string that might contain one or
                      more search strings
  Buffer            - Specifies the outbound buffer. This arg can be the same
                      as SrcBuffer.
  InboundBytes      - Specifies the number of bytes in SrcBuffer to process,
                      or 0 to process a nul-terminated string in SrcBuffer.
                      If InboundBytes is specified, it must point to the nul
                      terminator of SrcBuffer.
  OutbountBytesPtr  - Receives the number of bytes that Buffer contains,
                      excluding the nul terminator.
  MaxSizeInBytes    - Specifies the size of Buffer, in bytes.
  Flags             - Specifies flags that control the search/replace:
                            SZMAP_COMPLETE_MATCH_ONLY
                            SZMAP_FIRST_CHAR_MUST_MATCH
                            SZMAP_RETURN_AFTER_FIRST_REPLACE
                            SZMAP_REQUIRE_WACK_OR_NUL
  ExtraDataValue    - Receives the extra data associated with the first search/
                      replace pair.
  EndOfString       - Receives a pointer to the end of the replace string, or
                      the nul pointer when the entire string is processed. The
                      pointer is within the string contained in Buffer.

--*/

{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCSTR lowerCaseSrc;
    PCSTR orgSrc;
    PCSTR lowerSrcPos;
    PCSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PSTR destPos;
    PCSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    STRINGMAP_FILTER_DATA filterData;
    PCSTR replaceString;
    BOOL result = FALSE;
    INT i;
    PCSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = SzByteCountA (SrcBuffer);
    } else {
        i = 0;
        while (i < InboundBytes) {
            if (SzIsLeadByte (SrcBuffer[i])) {
                MYASSERT (SrcBuffer[i + 1]);
                i += 2;
            } else {
                i++;
            }
        }

        if (i > InboundBytes) {
            InboundBytes--;
        }
    }

    inboundSize = InboundBytes + sizeof (CHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = SzAllocA (sizeOfTempBuf);

    CopyMemory ((PSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffA ((PSTR) lowerCaseSrc, InboundBytes / sizeof (CHAR));

    if (SrcBuffer == Buffer && !(Flags & SZMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (CHAR);

    filterData.UnicodeData = FALSE;
    filterData.Ansi.OriginalString = orgSrc;
    filterData.Ansi.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringA (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & SZMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & SZMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {

                //
                // Respect logical dbcs characters
                //

                replaceStringBytes = 0;
                i = 0;

                while (i < destBytesLeft) {
                    MYASSERT (replaceString[i]);

                    if (SzIsLeadByte (replaceString[i])) {
                        MYASSERT (replaceString[i + 1]);
                        i += 2;
                    } else {
                        i++;
                    }
                }

                if (i > destBytesLeft) {
                    destBytesLeft--;
                }

                replaceStringBytes = destBytesLeft;

            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & SZMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (SZMAP_FIRST_CHAR_MUST_MATCH|SZMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (SzIsLeadByte (*orgSrcPos)) {

                //
                // Copy double-byte character
                //

                if (destBytesLeft < sizeof (CHAR) * 2) {
                    break;
                }

                MYASSERT (sizeof (CHAR) * 2 == sizeof (WORD));

                *((PWORD) destPos)++ = *((PWORD) orgSrcPos)++;
                destBytesLeft -= sizeof (WORD);
                lowerSrcPos = (PCSTR) ((PBYTE) lowerSrcPos + sizeof (WORD));

            } else {

                //
                // Copy single-byte character
                //

                if (destBytesLeft < sizeof (CHAR)) {
                    break;
                }

                *destPos++ = *orgSrcPos++;
                destBytesLeft -= sizeof (CHAR);
                lowerSrcPos++;
            }
        }
    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = SzByteCountA (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = SzGetEndA (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = SzGetEndA (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    SzFreeA (lowerCaseSrc);

    return result;
}


BOOL
SzMapMultiTableSearchAndReplaceExW (
    IN      PSTRINGMAP *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    UINT sizeOfTempBuf;
    INT inboundSize;
    PCWSTR lowerCaseSrc;
    PCWSTR orgSrc;
    PCWSTR lowerSrcPos;
    PCWSTR orgSrcPos;
    INT orgSrcBytesLeft;
    PWSTR destPos;
    PCWSTR lowerSrcEnd;
    INT searchStringBytes;
    INT replaceStringBytes;
    INT destBytesLeft;
    STRINGMAP_FILTER_DATA filterData;
    PCWSTR replaceString;
    BOOL result = FALSE;
    PCWSTR endPtr;

    //
    // Empty string case
    //

    if (*SrcBuffer == 0 || MaxSizeInBytes <= sizeof (CHAR)) {
        if (MaxSizeInBytes >= sizeof (CHAR)) {
            *Buffer = 0;
        }

        if (OutboundBytesPtr) {
            *OutboundBytesPtr = 0;
        }

        return FALSE;
    }

    //
    // If caller did not specify inbound size, compute it now
    //

    if (!InboundBytes) {
        InboundBytes = SzByteCountW (SrcBuffer);
    } else {
        InboundBytes = (InboundBytes / sizeof (WCHAR)) * sizeof (WCHAR);
    }


    inboundSize = InboundBytes + sizeof (WCHAR);

    //
    // Allocate a buffer big enough for the lower-cased input string,
    // plus (optionally) a copy of the entire destination buffer. Then
    // copy the data to the buffer.
    //

    sizeOfTempBuf = inboundSize;

    if (SrcBuffer == Buffer) {
        sizeOfTempBuf += MaxSizeInBytes;
    }

    lowerCaseSrc = SzAllocW (sizeOfTempBuf);

    CopyMemory ((PWSTR) lowerCaseSrc, SrcBuffer, InboundBytes);
    *((PWSTR) ((PBYTE) lowerCaseSrc + InboundBytes)) = 0;

    CharLowerBuffW ((PWSTR) lowerCaseSrc, InboundBytes / sizeof (WCHAR));

    if (SrcBuffer == Buffer && !(Flags & SZMAP_COMPLETE_MATCH_ONLY)) {
        orgSrc = (PCWSTR) ((PBYTE) lowerCaseSrc + inboundSize);

        //
        // If we are processing entire inbound string, then just copy the
        // whole string.  Otherwise, copy the entire destination buffer, so we
        // don't lose data beyond the partial inbound string.
        //

        if (*((PCWSTR) ((PBYTE) SrcBuffer + InboundBytes))) {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, MaxSizeInBytes);
        } else {
            CopyMemory ((PWSTR) orgSrc, SrcBuffer, inboundSize);
        }

    } else {
        orgSrc = SrcBuffer;
    }

    //
    // Walk the lower cased string, looking for strings to replace
    //

    orgSrcPos = orgSrc;

    lowerSrcPos = lowerCaseSrc;
    lowerSrcEnd = (PCWSTR) ((PBYTE) lowerSrcPos + InboundBytes);

    destPos = Buffer;
    destBytesLeft = MaxSizeInBytes - sizeof (WCHAR);

    filterData.UnicodeData = TRUE;
    filterData.Unicode.OriginalString = orgSrc;
    filterData.Unicode.CurrentString = Buffer;

    endPtr = NULL;

    while (lowerSrcPos < lowerSrcEnd) {

        replaceString = pFindReplacementStringW (
                            MapArray,
                            MapArrayCount,
                            lowerSrcPos,
                            (HALF_PTR) ((PBYTE) lowerSrcEnd - (PBYTE) lowerSrcPos),
                            &searchStringBytes,
                            &replaceStringBytes,
                            &filterData,
                            ExtraDataValue,
                            (Flags & SZMAP_REQUIRE_WACK_OR_NUL) != 0
                            );

        if (replaceString) {

            //
            // Implement complete match flag
            //

            if (Flags & SZMAP_COMPLETE_MATCH_ONLY) {
                if (InboundBytes != searchStringBytes) {
                    break;
                }
            }

            result = TRUE;

            //
            // Verify replacement string isn't growing string too much. If it
            // is, truncate the replacement string.
            //

            if (destBytesLeft < replaceStringBytes) {
                replaceStringBytes = destBytesLeft;
            } else {
                destBytesLeft -= replaceStringBytes;
            }

            //
            // Transfer the memory
            //

            CopyMemory (destPos, replaceString, replaceStringBytes);

            destPos = (PWSTR) ((PBYTE) destPos + replaceStringBytes);
            lowerSrcPos = (PCWSTR) ((PBYTE) lowerSrcPos + searchStringBytes);
            orgSrcPos = (PCWSTR) ((PBYTE) orgSrcPos + searchStringBytes);

            //
            // Implement single match flag
            //

            if (Flags & SZMAP_RETURN_AFTER_FIRST_REPLACE) {
                endPtr = destPos;
                break;
            }

        } else if (Flags & (SZMAP_FIRST_CHAR_MUST_MATCH|SZMAP_COMPLETE_MATCH_ONLY)) {
            //
            // This string does not match any search strings
            //

            break;

        } else {
            //
            // This character does not match, so copy it to the destination and
            // try the next string.
            //

            if (destBytesLeft < sizeof (WCHAR)) {
                break;
            }

            *destPos++ = *orgSrcPos++;
            destBytesLeft -= sizeof (WCHAR);
            lowerSrcPos++;
        }

    }

    //
    // Copy any remaining part of the original source to the
    // destination, unless destPos == Buffer == SrcBuffer
    //

    if (destPos != SrcBuffer) {

        if (*orgSrcPos) {
            orgSrcBytesLeft = SzByteCountW (orgSrcPos);
            orgSrcBytesLeft = min (orgSrcBytesLeft, destBytesLeft);

            CopyMemory (destPos, orgSrcPos, orgSrcBytesLeft);
            destPos = (PWSTR) ((PBYTE) destPos + orgSrcBytesLeft);
        }

        MYASSERT ((PBYTE) (destPos + 1) <= ((PBYTE) Buffer + MaxSizeInBytes));
        *destPos = 0;

        if (!endPtr) {
            endPtr = destPos;
        }

    } else {

        MYASSERT (SrcBuffer == Buffer);
        if (EndOfString || OutboundBytesPtr) {
            endPtr = SzGetEndW (destPos);
        }
    }

    if (EndOfString) {
        MYASSERT (endPtr);
        *EndOfString = endPtr;
    }

    if (OutboundBytesPtr) {
        MYASSERT (endPtr);
        if (*endPtr) {
            endPtr = SzGetEndW (endPtr);
        }

        *OutboundBytesPtr = (HALF_PTR) ((PBYTE) endPtr - (PBYTE) Buffer);
    }

    SzFreeW (lowerCaseSrc);

    return result;
}


BOOL
SzMapSearchAndReplaceExA (
    IN      PSTRINGMAP Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    )
{
    return SzMapMultiTableSearchAndReplaceExA (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}

BOOL
SzMapSearchAndReplaceExW (
    IN      PSTRINGMAP Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    )
{
    return SzMapMultiTableSearchAndReplaceExW (
                &Map,
                1,
                SrcBuffer,
                Buffer,
                InboundBytes,
                OutboundBytesPtr,
                MaxSizeInBytes,
                Flags,
                ExtraDataValue,
                EndOfString
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\common\memory.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Implements macros and declares functions for basic allocation functions.

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:

    jimschm 25-Jul-2001     Consolidated coding conventions

--*/


#include "pch.h"
#include "commonp.h"


//
// Constants
//

#ifdef DEBUG

#define TRAIL_SIG               0x708aa210
#define TRACK_SIGNATURE         0x30405060

#endif

//
// Macros
//

#define REUSE_SIZE_PTR(ptr) ((PDWORD) ((PBYTE) ptr - sizeof (DWORD)))
#define REUSE_TAG_PTR(ptr)  ((PDWORD) ((PBYTE) ptr + (*REUSE_SIZE_PTR(ptr))))


//
// Types
//

#ifdef DEBUG

typedef struct {

    DWORD Signature;
    SIZE_T Size;

} TRACKSTRUCT, *PTRACKSTRUCT;

#endif

//
// Globals
//

#ifdef DEBUG

PTRACKSTRUCT g_TrackHead = NULL;

#endif

static DWORD g_MemTlsIndex;

static SIZE_T g_TotalBytesAllocated = 0;
static SIZE_T g_MaxBytesInUse = 0;
static SIZE_T g_HeapAllocs = 0;
static SIZE_T g_HeapReAllocs = 0;
static SIZE_T g_HeapFrees = 0;
static SIZE_T g_HeapAllocFails = 0;
static SIZE_T g_HeapReAllocFails = 0;
static SIZE_T g_HeapFreeFails = 0;

//
// Out of memory string -- loaded at initialization
//
PCSTR g_OutOfMemoryString = NULL;
PCSTR g_OutOfMemoryRetry = NULL;
HWND g_OutOfMemoryParentWnd;



//
// Macro expansion list
//

// None

//
// Private function prototypes
//

VOID
MemOutOfMemory_Terminate (
    VOID
    );

#ifdef DEBUG

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE HeapHandle,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    );



VOID
pCreateSignatures (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT p
    );

VOID
pCheckSignatures (
    PTRACKSTRUCT p
    );

#endif

//
// Macro expansion definition
//

// None

//
// Code
//



VOID
pHeapCallFailed (
    IN      PCSTR Msg,
    IN      PCSTR File,
    IN      DWORD Line
    )
{
    CHAR Msg2[2048];

    wsprintfA (Msg2, "Error in %s line %u\n\n", File, Line);
    if (strlen(Msg) + strlen(Msg2) < 2025) {
        strcat (Msg2, Msg);
    }
    strcat (Msg2, "\n\nBreak execution now?");

    if (IDYES == MessageBoxA (GetFocus(), Msg2, "Heap Call Failed", MB_YESNO|MB_APPLMODAL)) {
        BreakPoint();
    }
}

#ifdef DEBUG

SIZE_T
DbgHeapValidatePtr (
    HANDLE HeapHandle,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T rc;

    //EnterCriticalSection (&g_MemAllocCs);

    rc = pDebugHeapValidatePtrUnlocked (HeapHandle, CallerPtr, File, Line);

    //LeaveCriticalSection (&g_MemAllocCs);

    return rc;
}

SIZE_T
pDebugHeapValidatePtrUnlocked (
    HANDLE HeapHandle,
    PCVOID CallerPtr,
    PCSTR File,
    DWORD  Line
    )
{
    SIZE_T size;
    PCVOID realPtr;
    SIZE_T sizeAdjust;

    sizeAdjust = sizeof (TRACKSTRUCT);
    realPtr = (PCVOID) ((PBYTE) CallerPtr - sizeAdjust);

    if (IsBadWritePtr ((PBYTE) realPtr - 8, 8)) {
        CHAR badPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            badPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  This address is not valid.",
            (DWORD)((ULONG_PTR)CallerPtr >> 32),
            (DWORD)(ULONG_PTR)CallerPtr
            );

        pHeapCallFailed (badPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    size = HeapSize (HeapHandle, 0, realPtr);
    if (size == (SIZE_T)-1) {
        CHAR badPtrMsg[256];

        //lint --e(572)
        wsprintfA (
            badPtrMsg,
            "Attempt to free memory at 0x%08x%08x.  "
                "This address is not the start of a memory block.",
            (DWORD)((ULONGLONG)CallerPtr >> 32),
            (DWORD)(ULONG_PTR)CallerPtr
            );

        pHeapCallFailed (badPtrMsg, File, Line);

        return (SIZE_T)INVALID_PTR;
    }

    return size;
}

PVOID
DbgHeapAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE HeapHandle,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID realPtr;
    PVOID returnPtr = NULL;
    DWORD sizeAdjust;
    DWORD trackStructSize;
    DWORD orgError;

    //EnterCriticalSection (&g_MemAllocCs);

    __try {

        //
        // Save the last error
        //

        orgError = GetLastError();

        //
        // Compute the size we need to allocate, plus the offset to
        // the start of the return memory
        //

        sizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD); // DWORD is for a signature
        trackStructSize = sizeof (TRACKSTRUCT);

        //
        // Validate the entire heap. This is a slow operation!
        //

        if (!HeapValidate (HeapHandle, 0, NULL)) {
            pHeapCallFailed ("Heap is corrupt!", File, Line);
            // we want to go on, most likely we will AV shortly
        }

        //
        // Allocate memory
        //

        realPtr = HeapAlloc (HeapHandle, Flags, BytesToAlloc + sizeAdjust);

        if (realPtr) {
            g_HeapAllocs++;
            g_TotalBytesAllocated += HeapSize (HeapHandle, 0, realPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pCreateSignatures (File, Line, BytesToAlloc, (PTRACKSTRUCT) realPtr);

            returnPtr = (PVOID) ((PBYTE) realPtr + trackStructSize);

            if (!(Flags & HEAP_ZERO_MEMORY)) {
                FillMemory (returnPtr, BytesToAlloc, 0xAA);
            }

            SetLastError (orgError);

        } else {
            g_HeapAllocFails++;
        }
    }
    __finally {
        //LeaveCriticalSection (&g_MemAllocCs);
        MYASSERT (TRUE);            // debugger workaround
    }

    return returnPtr;
}

PVOID
DbgHeapAllocNeverFail (
    PCSTR File,
    DWORD Line,
    HANDLE HeapHandle,
    DWORD Flags,
    SIZE_T BytesToAlloc
    )
{
    PVOID result;
    INT_PTR rc;

    do {
        result = DbgHeapAlloc (File, Line, HeapHandle, Flags, BytesToAlloc);

        rc = MessageBoxA (
                g_OutOfMemoryParentWnd,
                g_OutOfMemoryRetry,
                NULL,
                MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                );

        if (rc == IDCANCEL) {
            MemOutOfMemory_Terminate();
        }
    } while (!result);

    return result;
}

PVOID
DbgHeapReAlloc (
    PCSTR File,
    DWORD Line,
    HANDLE HeapHandle,
    DWORD Flags,
    PCVOID CallerPtr,
    SIZE_T BytesToAlloc
    )
{
    ULONG_PTR lastSize;
    PVOID newRealPtr;
    PCVOID realPtr;
    PVOID returnPtr = NULL;
    DWORD sizeAdjust;
    DWORD orgError;
    DWORD trackStructSize;
    SIZE_T orgSize;
    PTRACKSTRUCT pts = NULL;

    //EnterCriticalSection (&g_MemAllocCs);

    __try {

        orgError = GetLastError();

        sizeAdjust = sizeof (TRACKSTRUCT) + sizeof (DWORD);
        trackStructSize = sizeof (TRACKSTRUCT);
        realPtr = (PCVOID) ((PBYTE) CallerPtr - trackStructSize);
        pts = (PTRACKSTRUCT) realPtr;
        orgSize = pts->Size;

        if (!HeapValidate (HeapHandle, 0, NULL)) {
            pHeapCallFailed ("Heap is corrupt!", File, Line);
            // we want to go on, most likely we will AV shortly
        }

        lastSize = pDebugHeapValidatePtrUnlocked (HeapHandle, CallerPtr, File, Line);
        if (lastSize == (ULONG_PTR)INVALID_PTR) {
            // we want to go on, most likely we will AV shortly
        }

        pCheckSignatures (pts);

        newRealPtr = HeapReAlloc (HeapHandle, Flags, (PVOID) realPtr, BytesToAlloc + sizeAdjust);

        if (newRealPtr) {
            g_HeapReAllocs++;
            g_TotalBytesAllocated -= lastSize;
            g_TotalBytesAllocated += HeapSize (HeapHandle, 0, newRealPtr);
            g_MaxBytesInUse = max (g_MaxBytesInUse, g_TotalBytesAllocated);

            pCreateSignatures (File, Line, BytesToAlloc, (PTRACKSTRUCT) newRealPtr);
            DbgUnregisterAllocation (RAW_MEMORY, realPtr);

            returnPtr = (PVOID) ((PBYTE) newRealPtr + trackStructSize);

            if (BytesToAlloc > orgSize && !(Flags & HEAP_ZERO_MEMORY)) {
                FillMemory ((PBYTE) returnPtr + orgSize, BytesToAlloc - orgSize, 0xAA);
            }

            SetLastError (orgError);

        } else {
            g_HeapReAllocFails++;

        }
    }
    __finally {
        //LeaveCriticalSection (&g_MemAllocCs);
    }

    return returnPtr;
}

PVOID
DbgHeapReAllocNeverFail (
    PCSTR File,
    DWORD Line,
    HANDLE HeapHandle,
    DWORD Flags,
    PCVOID OldMem,
    SIZE_T BytesToAlloc
    )
{
    PVOID result;
    INT_PTR rc;

    do {
        result = DbgHeapReAlloc (File, Line, HeapHandle, Flags, OldMem, BytesToAlloc);

        rc = MessageBoxA (
                g_OutOfMemoryParentWnd,
                g_OutOfMemoryRetry,
                NULL,
                MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                );

        if (rc == IDCANCEL) {
            MemOutOfMemory_Terminate();
        }
    } while (!result);

    return result;
}

BOOL
DbgHeapFree (
    PCSTR File,
    DWORD Line,
    HANDLE HeapHandle,
    DWORD Flags,
    PCVOID CallerPtr
    )
{
    ULONG_PTR size;
    PCVOID realPtr;
    DWORD sizeAdjust;
    DWORD orgError;
    BOOL result = FALSE;
    PTRACKSTRUCT pts = NULL;

    //EnterCriticalSection (&g_MemAllocCs);

    __try {
        orgError = GetLastError();

        sizeAdjust = sizeof (TRACKSTRUCT);
        realPtr = (PCVOID) ((PBYTE) CallerPtr - sizeAdjust);
        pts = (PTRACKSTRUCT) realPtr;

        if (!HeapValidate (HeapHandle, 0, NULL)) {
            pHeapCallFailed ("Heap is corrupt!", File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        size = pDebugHeapValidatePtrUnlocked (HeapHandle, CallerPtr, File, Line);
        if (size == (ULONG_PTR)INVALID_PTR) {
            g_HeapFreeFails++;
            __leave;
        }

        pCheckSignatures ((PTRACKSTRUCT) realPtr);

        if (!HeapFree (HeapHandle, Flags, (PVOID) realPtr)) {
            CHAR badPtrMsg[256];

            wsprintfA (
                badPtrMsg,
                "Attempt to free memory at 0x%08x with flags 0x%08x.  "
                "HeapFree() failed.",
                CallerPtr,
                Flags
                );

            pHeapCallFailed (badPtrMsg, File, Line);
            g_HeapFreeFails++;
            __leave;
        }

        g_HeapFrees++;
        if (g_TotalBytesAllocated < size) {
            DEBUGMSG ((DBG_WARNING, "Total bytes allocated is less than amount being freed.  "
                                    "This suggests memory corruption."));
            g_TotalBytesAllocated = 0;
        } else {
            g_TotalBytesAllocated -= size;
        }

        DbgUnregisterAllocation (RAW_MEMORY, realPtr);

        SetLastError (orgError);
        result = TRUE;
    }
    __finally {
        //LeaveCriticalSection (&g_MemAllocCs);
    }

    return result;

}

VOID
DbgDumpHeapStats (
    VOID
    )
{
    CHAR OutputMsg[4096];

    wsprintfA (
        OutputMsg,
        "Bytes currently allocated: %u\n"
            "Peak bytes allocated: %u\n"
            "Allocation count: %u\n"
            "Reallocation count: %u\n"
            "Free count: %u\n",
        g_TotalBytesAllocated,
        g_MaxBytesInUse,
        g_HeapAllocs,
        g_HeapReAllocs,
        g_HeapFrees
        );

    if (g_HeapAllocFails) {
        wsprintfA (
            strchr (OutputMsg, 0),
            "***Allocation failures: %u\n",
            g_HeapAllocFails
            );
    }
    if (g_HeapReAllocFails) {
        wsprintfA (
            strchr (OutputMsg, 0),
            "***Reallocation failures: %u\n",
            g_HeapReAllocFails
            );
    }
    if (g_HeapFreeFails) {
        wsprintfA (
            strchr (OutputMsg, 0),
            "***Free failures: %u\n",
            g_HeapFreeFails
            );
    }

    DEBUGMSG ((DBG_STATS, "%s", OutputMsg));
}


VOID
DbgHeapCheck (
    PCSTR File,
    DWORD Line,
    HANDLE HeapHandle
    )
{
    //EnterCriticalSection (&g_MemAllocCs);

    if (!HeapValidate (HeapHandle, 0, NULL)) {
        pHeapCallFailed ("HeapCheck failed: Heap is corrupt!", File, Line);
    }

    //LeaveCriticalSection (&g_MemAllocCs);
}

PVOID
DbgFastAlloc (
    IN      PCSTR SourceFile,
    IN      DWORD Line,
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return DbgHeapAlloc (SourceFile, Line, g_hHeap, 0, Size);
}

PVOID
DbgFastReAlloc (
    IN      PCSTR SourceFile,
    IN      DWORD Line,
    IN      PCVOID OldBlock,
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return DbgHeapReAlloc (SourceFile, Line, g_hHeap, 0, OldBlock, Size);
}

BOOL
DbgFastFree (
    IN      PCSTR SourceFile,
    IN      DWORD Line,
    IN      PCVOID Block
    )
{
    //
    // BUGBUG - implement
    //

    return DbgHeapFree (SourceFile, Line, g_hHeap, 0, Block);
}


PVOID
DbgFastAllocNeverFail (
    IN      PCSTR SourceFile,
    IN      DWORD Line,
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return DbgHeapAlloc (SourceFile, Line, g_hHeap, 0, Size);
}

PVOID
DbgFastReAllocNeverFail (
    IN      PCSTR SourceFile,
    IN      DWORD Line,
    IN      PCVOID OldBlock,
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return DbgHeapReAlloc (SourceFile, Line, g_hHeap, 0, OldBlock, Size);
}

#else

PVOID
MemFastAlloc (
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return HeapAlloc (g_hHeap, 0, Size);
}

PVOID
MemFastReAlloc (
    IN      PCVOID OldBlock,
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return HeapReAlloc (g_hHeap, 0, (PVOID) OldBlock, Size);
}

BOOL
MemFastFree (
    IN      PCVOID Block
    )
{
    //
    // BUGBUG - implement
    //

    return HeapFree (g_hHeap, 0, (PVOID) Block);
}

PVOID
MemFastAllocNeverFail (
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return MemAllocNeverFail (g_hHeap, 0, Size);
}

PVOID
MemFastReAllocNeverFail (
    IN      PVOID OldBlock,
    IN      SIZE_T Size
    )
{
    //
    // BUGBUG - implement
    //

    return MemReAllocNeverFail (g_hHeap, 0, OldBlock, Size);
}


#endif

PVOID
MemReuseAlloc (
    IN      HANDLE Heap,
    IN      PVOID OldPtr,           OPTIONAL
    IN      DWORD SizeNeeded
    )
{
    DWORD CurrentSize;
    PVOID Ptr = NULL;
    UINT AllocAdjustment = sizeof(DWORD);

    //
    // HeapSize is not very good, so while it may look good, don't
    // use it.
    //

#ifdef DEBUG
    AllocAdjustment += sizeof (DWORD);
#endif

    if (!OldPtr) {
        Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
    } else {

        CurrentSize = *REUSE_SIZE_PTR(OldPtr);

#ifdef DEBUG
        if (*REUSE_TAG_PTR(OldPtr) != 0x10a28a70) {
            DEBUGMSG ((DBG_WHOOPS, "MemReuse detected corruption!"));
            Ptr = MemAlloc (Heap, 0, SizeNeeded + AllocAdjustment);
        } else
#endif

        if (SizeNeeded > CurrentSize) {
            SizeNeeded += 1024 - (SizeNeeded & 1023);

            Ptr = MemReAlloc (Heap, 0, REUSE_SIZE_PTR(OldPtr), SizeNeeded + AllocAdjustment);
            OldPtr = NULL;
        }
    }

    if (Ptr) {
        *((PDWORD) Ptr) = SizeNeeded;
        Ptr = (PVOID) ((PBYTE) Ptr + sizeof (DWORD));

#ifdef DEBUG
        *REUSE_TAG_PTR(Ptr) = 0x10a28a70;
#endif
    }

    return Ptr ? Ptr : OldPtr;
}

VOID
MemReuseFree (
    HANDLE Heap,
    PVOID Ptr
    )
{
    if (Ptr) {
        MemFree (Heap, 0, REUSE_SIZE_PTR(Ptr));
    }
}


VOID
MemSetOutOfMemoryParent (
    HWND hwnd
    )
{
    g_OutOfMemoryParentWnd = hwnd;
}


VOID
MemOutOfMemory_Terminate (
    VOID
    )
{
    if (!g_OutOfMemoryString || !g_OutOfMemoryString[0]) {
        return;
    }

    MessageBoxA (
        g_OutOfMemoryParentWnd,
        g_OutOfMemoryString,
        NULL,
        MB_OK|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
        );

    ExitProcess (0);
    //
    // Not needed, will never get here
    //
    // TerminateProcess (GetModuleHandle (NULL), 0);
}

VOID
pValidateBlock (
    PVOID Block,
    SIZE_T Size
    )

/*++

Routine Description:

  pValidateBlock makes sure Block is non-NULL.  If it is NULL, then the user
  is given a popup, unless the request size is bogus.

  There are two cases for the popup.

   - If g_OutOfMemoryParentWnd was set with SetOutOfMemoryParent,
     then the user is asked to close other programs, and is given a retry
     option.

   - If there is no out of memory parent, then the user is told they
     need to get more memory.

  In either case, Setup is terminated.  In GUI mode, Setup will be
  stuck and the machine will be unbootable.

Arguments:

  Block - Specifies the block to validate.
  Size - Specifies the request size

Return Value:

  none

--*/

{
    LONG rc;

    if (!Block && Size < 0x2000000) {
        if (g_OutOfMemoryParentWnd) {
            rc = MessageBoxA (
                    g_OutOfMemoryParentWnd,
                    g_OutOfMemoryRetry,
                    NULL,
                    MB_RETRYCANCEL|MB_ICONHAND|MB_SYSTEMMODAL|MB_SETFOREGROUND|MB_TOPMOST
                    );

            if (rc == IDCANCEL) {
                MemOutOfMemory_Terminate();
            }
        } else {
            MemOutOfMemory_Terminate();
        }
    } else {
        if (!Block) {
            // this is serious. We want to break now and give Dr. Watson a
            // chance to get our stack.
            BreakPoint();
        }
    }
}


#ifndef DEBUG

PVOID
MemAllocNeverFail (
    HANDLE Heap,
    DWORD Flags,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapAlloc (Heap, Flags, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

PVOID
MemReAllocNeverFail (
    HANDLE Heap,
    DWORD Flags,
    PVOID OldBlock,
    SIZE_T Size
    )
{
    PVOID Block;

    do {
        Block = HeapReAlloc (Heap, Flags, OldBlock, Size);
        pValidateBlock (Block, Size);

    } while (!Block);

    return Block;
}

#endif



#ifdef DEBUG

VOID
pCreateSignatures (
    PCSTR File,
    DWORD Line,
    SIZE_T Size,
    PTRACKSTRUCT Pointer
    )
{
    DWORD signature;
    PBYTE end;

    DbgRegisterAllocation (RAW_MEMORY, Pointer, File, Line);

    Pointer->Signature = TRACK_SIGNATURE;
    Pointer->Size = Size;

    end = (PBYTE) Pointer + sizeof (TRACKSTRUCT) + Size;
    signature = TRAIL_SIG;
    CopyMemory (end, &signature, sizeof (DWORD));
}

VOID
pCheckSignatures (
    IN      PTRACKSTRUCT Pointer
    )
{
    DWORD signature;
    PBYTE end;

    if (Pointer->Signature != TRACK_SIGNATURE) {
        DEBUGMSG ((DBG_ERROR, "A tracking head signature is invalid.  "
                              "This suggests memory corruption."));
        return;
    }

    end = (PBYTE) Pointer + sizeof (TRACKSTRUCT) + Pointer->Size;
    CopyMemory (&signature, end, sizeof (DWORD));
    if (signature != TRAIL_SIG) {
        DEBUGMSG ((DBG_ERROR, "A tracking trail signature is invalid.  "
                              "This suggests memory corruption."));
        return;
    }
}


#endif


BOOL
MemInitialize (
    VOID
    )
{
    if (g_MemTlsIndex) {
        return TRUE;
    }

    g_MemTlsIndex = TlsAlloc();
    if (g_MemTlsIndex == TLS_OUT_OF_INDEXES) {
        return FALSE;
    }

    if (!g_hHeap) {
        g_hHeap = GetProcessHeap();
    }

    return TRUE;
}


PVOID
MemFastAllocAndZero (
    IN      SIZE_T Size
    )
{
    PVOID result;

    result = MemFastAlloc (Size);
    if (result) {
        ZeroMemory (result, Size);
    }

    return result;
}


PVOID
MemFastReAllocAndZero (
    IN      PCVOID Ptr,
    IN      SIZE_T Size
    )
{
    SIZE_T orgSize;
    PVOID result;

    orgSize = HeapSize (g_hHeap, 0, Ptr);

    result = MemFastReAlloc (Ptr, Size);
    if (result && Size > orgSize) {
        ZeroMemory ((PBYTE) result + orgSize, Size - orgSize);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\dbgtrack.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dbgtrack.h

Abstract:

    Implements macros and declares functions for resource tracking apis.

Author:

    Jim Schmidt (jimschm) 18-Jun-2001

Revision History:



--*/

#ifndef RC_INVOKED

#pragma once

#ifdef _cplusplus
extern "C" {
#endif


//
// Macros
//

#ifdef DEBUG

    #undef INITIALIZE_DBGTRACK_CODE
    #define INITIALIZE_DBGTRACK_CODE            if (!DbgInitTracking()) { __leave; }

    #undef TERMINATE_DBGTRACK_CODE
    #define TERMINATE_DBGTRACK_CODE             DbgTerminateTracking();

    #define ALLOCATION_TRACKING_DEF , PCSTR File, UINT Line
    #define ALLOCATION_TRACKING_CALL ,__FILE__,__LINE__
    #define ALLOCATION_TRACKING_INLINE_CALL ,File,Line

    #define DISABLETRACKCOMMENT()               DbgDisableTrackComment()
    #define ENABLETRACKCOMMENT()                DbgEnableTrackComment()

    #define DBGTRACK_BEGIN(type,name)           DbgTrack##type(DbgTrackPush(#name,__FILE__,__LINE__) ? (type) 0 : (
    #define DBGTRACK_END()                      ))
    #define DBGTRACK(type,fnname,fnargs)        (DBGTRACK_BEGIN(type,logname) Real##fnname fnargs DBGTRACK_END())

#else

    #undef INITIALIZE_DBGTRACK_CODE
    #define INITIALIZE_DBGTRACK_CODE

    #undef TERMINATE_DBGTRACK_CODE
    #define TERMINATE_DBGTRACK_CODE

    #define DISABLETRACKCOMMENT()
    #define ENABLETRACKCOMMENT()

    #define DBGTRACK_BEGIN(type,name)
    #define DBGTRACK_END()
    #define DBGTRACK(type,fnname,fnargs)        (Real##fnname fnargs)

    #define ALLOCATION_TRACKING_DEF
    #define ALLOCATION_TRACKING_CALL
    #define ALLOCATION_TRACKING_INLINE_CALL

    #define DbgInitTracking()
    #define DbgTerminateTracking()
    #define DbgRegisterAllocation(t,p,f,l)
    #define DbgUnregisterAllocation(t,p)

#endif

//
// Types
//

typedef enum {
    //
    // Add types here if you call DbgRegisterAllocation yourself
    // (for example, you are wrapping acess to a handle).
    //
    RAW_MEMORY
} ALLOCTYPE;


//
// List of the basic types for the routines that are tracked.
// This list generates inline functions for the tracking macros.
// Inline functions for other types are defined in the header
// file.
//

//
// include this for HINF
//
#include <setupapi.h>

#define TRACK_WRAPPERS              \
        DBGTRACK_DECLARE(PBYTE)     \
        DBGTRACK_DECLARE(DWORD)     \
        DBGTRACK_DECLARE(BOOL)      \
        DBGTRACK_DECLARE(UINT)      \
        DBGTRACK_DECLARE(PCSTR)     \
        DBGTRACK_DECLARE(PCWSTR)    \
        DBGTRACK_DECLARE(PVOID)     \
        DBGTRACK_DECLARE(PSTR)      \
        DBGTRACK_DECLARE(PWSTR)     \
        DBGTRACK_DECLARE(HINF)      \

//
// Public function prototypes
//

#ifdef DEBUG

BOOL
DbgInitTracking (
    VOID
    );

VOID
DbgTerminateTracking (
    VOID
    );

VOID
DbgRegisterAllocation (
    IN      ALLOCTYPE Type,
    IN      PVOID Ptr,
    IN      PCSTR File,
    IN      UINT Line
    );

VOID
DbgUnregisterAllocation (
    ALLOCTYPE Type,
    PCVOID Ptr
    );

VOID
DbgDisableTrackComment (
    VOID
    );

VOID
DbgEnableTrackComment (
    VOID
    );

INT
DbgTrackPushEx (
    IN      PCSTR Name,
    IN      PCSTR File,
    IN      UINT Line,
    IN      BOOL DupFileString
    );

#define DbgTrackPush(name,file,line)   DbgTrackPushEx(name,file,line,FALSE)

INT
DbgTrackPop (
    VOID
    );

VOID
DbgTrackDump (
    VOID
    );

#define DBGTRACKPUSH(n,f,l)         DbgTrackPush(n,f,l)
#define DBGTRACKPUSHEX(n,f,l,d)     DbgTrackPushEx(n,f,l,d)
#define DBGTRACKPOP()               DbgTrackPop()
#define DBGTRACKDUMP()              DbgTrackDump()

//
// Macro expansion definition
//

#define DBGTRACK_DECLARE(type)    __inline type DbgTrack##type (type Arg) {DbgTrackPop(); return Arg;}

TRACK_WRAPPERS


#else       // i.e., if !DEBUG

#define DBGTRACKPUSH(n,f,l)
#define DBGTRACKPUSHEX(n,f,l,d)
#define DBGTRACKPOP()
#define DBGTRACKDUMP()
#define DBGTRACK_DECLARE(type)

#endif

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\setuplog.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Standard log macros. Support standard
    setupact.log, setuperr.log and debug.log logs.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "log.h"

#undef  INITIALIZE_LOG_CODE
#ifndef DEBUG
#define INITIALIZE_LOG_CODE if(!LogStandardInit(NULL, NULL, TRUE, FALSE, FALSE, FALSE, FALSE)){__leave;}
#else
#define INITIALIZE_LOG_CODE \
{\
    WCHAR winDirectory[MAX_PATH];\
    GetWindowsDirectoryW(winDirectory, sizeof(winDirectory) / sizeof(winDirectory[0]));\
    lstrcatW (winDirectory, L"\\spsetup.log");\
    if(!LogStandardInit(winDirectory, NULL, TRUE, FALSE, FALSE, FALSE, FALSE)){__leave;}\
}
#endif

#undef  TERMINATE_LOG_CODE
#define TERMINATE_LOG_CODE  LogDestroyStandard();


#if defined(__cplusplus)
extern "C" {
#endif

#if _MSC_VER < 1300
#define __FUNCTION__        "AvailableOnlyInVersion13"
#endif

#define STD_CALL_TYPE  __stdcall

#if defined(DEBUG)
#ifdef _X86_
#define BreakPoint()        __asm {int 3};
#else
#define BreakPoint()        DebugBreak()
#endif
#else
#define BreakPoint()
#endif

#define MAX_MESSAGE_CHAR    (1<<11)

typedef union tagLOG_MESSAGE{
    CHAR  pAStr[MAX_MESSAGE_CHAR];
    WCHAR pWStr[MAX_MESSAGE_CHAR];
}LOG_MESSAGE, *PLOG_MESSAGE;

typedef struct tagLOG_PARTIAL_MSG{
    DWORD       Severity;
    LOG_MESSAGE Message;
}LOG_PARTIAL_MSG, *PLOG_PARTIAL_MSG;

ILogManager *
STD_CALL_TYPE
LogStandardInit(
    IN  PCWSTR      pDebugLogFileName,
    IN  HINSTANCE   hModuleInstance,        OPTIONAL
    IN  BOOL        bCreateNew,             OPTIONAL
    IN  BOOL        bExcludeSetupActLog,    OPTIONAL
    IN  BOOL        bExcludeSetupErrLog,    OPTIONAL
    IN  BOOL        bExcludeXMLLog,         OPTIONAL
    IN  BOOL        bExcludeDebugFilter     OPTIONAL
    );

VOID
STD_CALL_TYPE
LogDestroyStandard(
    VOID
    );

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgVW(
    IN DWORD dwSeverity,
    IN PCSTR Format,
    IN va_list args
    );

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgVA(
    IN DWORD dwSeverity,
    IN PCSTR Format,
    IN va_list args
    );

LOGRESULT
STD_CALL_TYPE
LogMessageA(
    IN PLOG_PARTIAL_MSG pPartialMsg,
    IN PCSTR            Condition,
    IN DWORD            SourceLineNumber,
    IN PCSTR            SourceFile,
    IN PCSTR            SourceFunction
    );

LOGRESULT
STD_CALL_TYPE
LogMessageW(
    IN PLOG_PARTIAL_MSG pPartialMsg,
    IN PCSTR            Condition,
    IN DWORD            SourceLineNumber,
    IN PCWSTR           SourceFile,
    IN PCWSTR           SourceFunction
    );

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgIfA(
    IN BOOL bCondition,
    IN DWORD dwSeverity,
    IN PCSTR Format,
    ...
    );

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgIfW(
    IN BOOL bCondition,
    IN DWORD dwSeverity,
    IN PCSTR Format,
    ...
    );

#ifdef DEBUG

VOID
_cdecl
DebugLogTimeA (
    IN      PCSTR Format,
    ...
    );

VOID
_cdecl
DebugLogTimeW (
    IN      PCWSTR Format,
    ...
    );

#endif

#if defined(__cplusplus)
}
#endif

__inline BOOL IsConditionTrue(BOOL bCondition, ...){
    return bCondition;
}

__inline
PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgA(
    IN DWORD dwSeverity,
    IN PCSTR Format,
    ...
    ){
    va_list args;
    va_start(args, Format);
    return ConstructPartialMsgVA(dwSeverity, Format, args);
}

__inline
PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgW(
    IN DWORD dwSeverity,
    IN PCSTR Format,
    ...
    ){
    va_list args;
    va_start(args, Format);
    return ConstructPartialMsgVW(dwSeverity, Format, args);
}

#ifdef UNICODE
#define ConstructPartialMsgIf   ConstructPartialMsgIfW
#define ConstructPartialMsg     ConstructPartialMsgW
#define LogMessage              LogMessageW
#define DebugLogTime            DebugLogTimeW
#else
#define ConstructPartialMsgIf   ConstructPartialMsgIfA
#define ConstructPartialMsg     ConstructPartialMsgA
#define LogMessage              LogMessageA
#define DebugLogTime            DebugLogTimeA
#endif

#define LOGMSGA(condition, message)  LogMessageA(ConstructPartialMsgA message, condition, __LINE__, TEXT(__FILE__), TEXT(__FUNCTION__));
#define LOGMSGW(condition, message)  LogMessageW(ConstructPartialMsgW message, condition, __LINE__, TEXT(__FILE__), TEXT(__FUNCTION__));
#define LOGMSGIFA(message)  LogMessageA(ConstructPartialMsgIfA message, NULL, __LINE__, TEXT(__FILE__), TEXT(__FUNCTION__));
#define LOGMSGIFW(message)  LogMessageW(ConstructPartialMsgIfW message, NULL, __LINE__, TEXT(__FILE__), TEXT(__FUNCTION__));

#define LOGA(message)              LOGMSGA(NULL, message);
#define LOGW(message)              LOGMSGW(NULL, message);

#define LOG_IFA(if_message)        if(IsConditionTrue if_message){LOGMSGIFA(if_message);}
#define LOG_IFW(if_message)        if(IsConditionTrue if_message){LOGMSGIFW(if_message);}

#define ELSE_LOGA(message)         else{LOGA(message);}
#define ELSE_LOGW(message)         else{LOGW(message);}

#define ELSE_LOG_IFA(if_message)   else LOG_IFA(if_message);
#define ELSE_LOG_IFW(if_message)   else LOG_IFW(if_message);

#ifdef UNICODE
#define LOGMSG      LOGMSGW
#define LOGMSGIF    LOGMSGIFW
#define LOG         LOGW
#define LOG_IF      LOG_IFW
#define ELSE_LOG    ELSE_LOGW
#define ELSE_LOG_IF ELSE_LOG_IFW
#else
#define LOGMSG      LOGMSGA
#define LOGMSGIF    LOGMSGIFA
#define LOG         LOGA
#define LOG_IF      LOG_IFA
#define ELSE_LOG    ELSE_LOGA
#define ELSE_LOG_IF ELSE_LOG_IFA
#endif

#if defined(DEBUG)
#define DBGMSGA(condition, message)  if(logBreakPoint == LogMessageA(ConstructPartialMsgA message, condition, __LINE__, TEXT(__FILE__), TEXT(__FUNCTION__))){BreakPoint();}
#define DBGMSGW(condition, message)  if(logBreakPoint == LogMessageW(ConstructPartialMsgW message, condition, __LINE__, TEXT(__FILE__), TEXT(__FUNCTION__))){BreakPoint();}
#define DBGMSGIFA(message)  LOGMSGIFA(message)
#define DBGMSGIFW(message)  LOGMSGIFW(message)
#else
#define DBGMSGA(condition, message)
#define DBGMSGW(condition, message)
#define DBGMSGIFA(message)
#define DBGMSGIFW(message)
#endif

#define DEBUGMSGA(message)  DBGMSGA(NULL, message);
#define DEBUGMSGW(message)  DBGMSGW(NULL, message);

#define DEBUGMSG_IFA(if_message)       if(IsConditionTrue if_message){DBGMSGIFA(if_message);}
#define DEBUGMSG_IFW(if_message)       if(IsConditionTrue if_message){DBGMSGIFW(if_message);}

#define ELSE_DEBUGMSGA(message)        else{DEBUGMSGA(message);}
#define ELSE_DEBUGMSGW(message)        else{DEBUGMSGW(message);}

#define ELSE_DEBUGMSG_IFA(if_message)  else DEBUGMSG_IF(if_message);
#define ELSE_DEBUGMSG_IFW(if_message)  else DEBUGMSG_IF(if_message);

#define DEBUGLOGTIMEA(message)  DebugLogTimeA(message)
#define DEBUGLOGTIMEW(message)  DebugLogTimeW(message)

#ifdef UNICODE
#define DBGMSG              DBGMSGW
#define DBGMSGIF            DBGMSGIFW
#define DEBUGMSG            DEBUGMSGW
#define DEBUGMSG_IF         DEBUGMSG_IFW
#define ELSE_DEBUGMSG       ELSE_DEBUGMSGW
#define ELSE_DEBUGMSG_IF    ELSE_DEBUGMSG_IFW
#define DEBUGLOGTIME        DEBUGLOGTIMEW
#else
#define DBGMSG              DBGMSGA
#define DBGMSGIF            DBGMSGIFA
#define DEBUGMSG            DEBUGMSGA
#define DEBUGMSG_IF         DEBUGMSG_IFA
#define ELSE_DEBUGMSG       ELSE_DEBUGMSGA
#define ELSE_DEBUGMSG_IF    ELSE_DEBUGMSG_IFA
#define DEBUGLOGTIME        DEBUGLOGTIMEA
#endif

#if defined(DEBUG)
#define MYVERIFY(condition) if(!(condition)){DBGMSG(#condition, (DBG_ASSERT, #condition));}
#else
#define MYVERIFY(condition) if(!(condition)){LOGMSG(#condition, (LOG_ASSERT, #condition));}
#endif

#define MYASSERT(condition) if(!(condition)){DBGMSG(#condition, (DBG_ASSERT, #condition));}
#define MYASSERT_F(condition, message) if(!(condition)){DBGMSG(#condition, (DBG_ASSERT, message));}

#define DEBUGMSG0(severity, message)                    DEBUGMSG((severity, message))
#define DEBUGMSG1(severity, message, p1)                DEBUGMSG((severity, message, p1))
#define DEBUGMSG2(severity, message, p1, p2)            DEBUGMSG((severity, message, p1, p2))
#define DEBUGMSG3(severity, message, p1, p2, p3)        DEBUGMSG((severity, message, p1, p2, p3))
#define DEBUGMSG4(severity, message, p1, p2, p3, p4)    DEBUGMSG((severity, message, p1, p2, p3, p4))

#define LOG0(severity, message)                         LOG((severity, message))
#define LOG1(severity, message, p1)                     LOG((severity, message, p1))
#define LOG2(severity, message, p1, p2)                 LOG((severity, message, p1, p2))
#define LOG3(severity, message, p1, p2, p3)             LOG((severity, message, p1, p2, p3))
#define LOG4(severity, message, p1, p2, p3, p4)         LOG((severity, message, p1, p2, p3, p4))

#define USEMSGID(x) ((PCSTR)(SIZE_T)(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\growbuf.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growbuf.h

Abstract:

    Implements the GROWBUFFER data type, a dynamically allocated buffer
    that grows (and potentially changes addresses).  GROWBUFFERs are
    typically used to maintain dynamic sized arrays, or multi-sz lists.

Author:

    Jim Schmidt (jimschm) 25-Feb-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Types
//

typedef struct TAG_GROWBUFFER {
    PBYTE Buf;
    DWORD Size;
    DWORD End;
    DWORD GrowSize;
    DWORD UserIndex;        // Unused by Growbuf. For caller use.
#ifdef DEBUG
    DWORD StatEnd;
#endif
} GROWBUFFER, *PGROWBUFFER;

//
// Function prototypes and wrapper macros
//

PBYTE
RealGbGrow (
    IN OUT  PGROWBUFFER GrowBuf,
    IN      DWORD SpaceNeeded
    );

#define GbGrow(buf,size)    DBGTRACK(PBYTE, GbGrow, (buf,size))

VOID
GbFree (
    IN  PGROWBUFFER GrowBuf
    );


BOOL
RealGbMultiSzAppendA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbMultiSzAppendA(buf,str)   DBGTRACK(BOOL, GbMultiSzAppendA, (buf,str))

BOOL
RealGbMultiSzAppendW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbMultiSzAppendW(buf,str)   DBGTRACK(BOOL, GbMultiSzAppendW, (buf,str))

BOOL
RealGbMultiSzAppendValA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValA(buf,k,v)    DBGTRACK(BOOL, GbMultiSzAppendValA, (buf,k,v))

BOOL
RealGbMultiSzAppendValW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    DWORD Val
    );

#define GbMultiSzAppendValW(buf,k,v)    DBGTRACK(BOOL, GbMultiSzAppendValW, (buf,k,v))

BOOL
RealGbMultiSzAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR Key,
    PCSTR Val
    );

#define GbMultiSzAppendStringA(buf,k,v)     DBGTRACK(BOOL, GbMultiSzAppendStringA, (buf,k,v))

BOOL
RealGbMultiSzAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR Key,
    PCWSTR Val
    );

#define GbMultiSzAppendStringW(buf,k,v)     DBGTRACK(BOOL, GbMultiSzAppendStringW, (buf,k,v))

BOOL
RealGbAppendDword (
    PGROWBUFFER GrowBuf,
    DWORD d
    );

#define GbAppendDword(buf,d)        DBGTRACK(BOOL, GbAppendDword, (buf,d))

BOOL
RealGbAppendPvoid (
    PGROWBUFFER GrowBuf,
    PCVOID p
    );

#define GbAppendPvoid(buf,p)        DBGTRACK(BOOL, GbAppendPvoid, (buf,p))


BOOL
RealGbAppendStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbAppendStringA(buf,str)    DBGTRACK(BOOL, GbAppendStringA, (buf,str))

BOOL
RealGbAppendStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbAppendStringW(buf,str)    DBGTRACK(BOOL, GbAppendStringW, (buf,str))


BOOL
RealGbAppendStringABA (
    PGROWBUFFER GrowBuf,
    PCSTR Start,
    PCSTR EndPlusOne
    );

#define GbAppendStringABA(buf,a,b)      DBGTRACK(BOOL, GbAppendStringABA, (buf,a,b))

BOOL
RealGbAppendStringABW (
    PGROWBUFFER GrowBuf,
    PCWSTR Start,
    PCWSTR EndPlusOne
    );

#define GbAppendStringABW(buf,a,b)      DBGTRACK(BOOL, GbAppendStringABW, (buf,a,b))



BOOL
RealGbCopyStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyStringA(buf,str)      DBGTRACK(BOOL, GbCopyStringA, (buf,str))

BOOL
RealGbCopyStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyStringW(buf,str)      DBGTRACK(BOOL, GbCopyStringW, (buf,str))

BOOL
RealGbCopyQuotedStringA (
    PGROWBUFFER GrowBuf,
    PCSTR String
    );

#define GbCopyQuotedStringA(buf,str) DBGTRACK(BOOL, GbCopyQuotedStringA, (buf,str))

BOOL
RealGbCopyQuotedStringW (
    PGROWBUFFER GrowBuf,
    PCWSTR String
    );

#define GbCopyQuotedStringW(buf,str) DBGTRACK(BOOL, GbCopyQuotedStringW, (buf,str))

#ifdef DEBUG
VOID
GbDumpStatistics (
    VOID
    );
#else
#define GbDumpStatistics()
#endif

//
// A & W macros
//

#ifdef UNICODE

#define GbMultiSzAppend             GbMultiSzAppendW
#define GbMultiSzAppendVal          GbMultiSzAppendValW
#define GbMultiSzAppendString       GbMultiSzAppendStringW
#define GbAppendString              GbAppendStringW
#define GbAppendStringAB            GbAppendStringABW
#define GbCopyString                GbCopyStringW
#define GbCopyQuotedString          GbCopyQuotedStringW

#else

#define GbMultiSzAppend             GbMultiSzAppendA
#define GbMultiSzAppendVal          GbMultiSzAppendValA
#define GbMultiSzAppendString       GbMultiSzAppendStringA
#define GbAppendString              GbAppendStringA
#define GbAppendStringAB            GbAppendStringABA
#define GbCopyString                GbCopyStringA
#define GbCopyQuotedString          GbCopyQuotedStringA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\growlist.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    growlist.h

Abstract:

    Implements a dynamic array-indexed list of binary objects.  Typically,
    the binary objects are strings.  The list uses a GROWBUF for the array,
    and a pool for the binary data of each list item.

Author:

    Jim Schmidt (jimschm) 08-Aug-1997

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//
// Types
//

typedef struct {
    GROWBUFFER ListArray;
} GROWLIST, *PGROWLIST;

#ifdef DEBUG
#define INIT_GROWLIST {NULL,0,0,0,0,0, NULL}
#else
#define INIT_GROWLIST {NULL,0,0,0,0, NULL}
#endif

//
// Function Prototypes
//

#define GlGetPtrArray(listptr)           ((PVOID *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayA(listptr)    ((PCSTR *) ((listptr)->ListArray.Buf))
#define GlGetStringPtrArrayW(listptr)    ((PCWSTR *) ((listptr)->ListArray.Buf))

PBYTE
RealGlAppend (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppend(list,data,size)    DBGTRACK(PBYTE, GlAppend, (list,data,size))

PBYTE
RealGlAppendAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlAppendAddNul(list,data,size)    DBGTRACK(PBYTE, GlAppendAddNul, (list,data,size))

VOID
GlFree (
    IN  PGROWLIST GrowList
    );

VOID
GlReset (
    IN OUT  PGROWLIST GrowList
    );

PBYTE
GlGetItem (
    IN      PGROWLIST GrowList,
    IN      UINT Index
    );

UINT
GlGetSize (
    IN      PGROWLIST GrowList
    );

PBYTE
RealGlInsert (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsert(list,index,data,size)      DBGTRACK(PBYTE, GlInsert, (list,index,data,size))


PBYTE
RealGlInsertAddNul (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PBYTE DataToAppend,         OPTIONAL
    IN      UINT SizeOfData
    );

#define GlInsertAddNul(list,index,data,size)    DBGTRACK(PBYTE, GlInsertAddNul, (list,index,data,size))


BOOL
GlDeleteItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

BOOL
GlResetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index
    );

PBYTE
RealGlSetItem (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCBYTE DataToSet,           OPTIONAL
    IN      UINT SizeOfData
    );

#define GlSetItem(list,index,data,size)     DBGTRACK(PBYTE, GlSetItem, (list,index,data,size))

__inline
PCSTR
RealGlAppendStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    MYASSERT_F(String < End, "Start is greater than End in GrowListAppendStringABA");

    return (PCSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? SzByteCountABA (String, End) : 0
                        );
}

__inline
PCWSTR
RealGlAppendStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    MYASSERT_F(String < End, "Start is greater than End in GrowListAppendStringABW");

    return (PCWSTR) GlAppendAddNul (
                        GrowList,
                        (PBYTE) String,
                        String < End ? SzByteCountABW (String, End) : 0
                        );
}

__inline
PCSTR
RealGlInsertStringABA (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCSTR String,
    IN      PCSTR End
    )
{
    MYASSERT_F(String < End, "Start is greater than End in GrowListInsertStringABA");

    return (PCSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        String < End ? SzByteCountABA (String, End) : 0
                        );
}

__inline
PCWSTR
RealGlInsertStringABW (
    IN OUT  PGROWLIST GrowList,
    IN      UINT Index,
    IN      PCWSTR String,
    IN      PCWSTR End
    )
{
    MYASSERT_F(String < End, "Start is greater than End in GrowListInsertStringABW");

    return (PCWSTR) GlInsertAddNul (
                        GrowList,
                        Index,
                        (PBYTE) String,
                        String < End ? SzByteCountABW (String, End) : 0
                        );
}

#define GlAppendStringABA(list,a,b)         DBGTRACK(PCSTR, GlAppendStringABA, (list,a,b))
#define GlAppendStringABW(list,a,b)         DBGTRACK(PCWSTR, GlAppendStringABW, (list,a,b))
#define GlInsertStringABA(list,index,a,b)   DBGTRACK(PCSTR, GlInsertStringABA, (list,index,a,b))
#define GlInsertStringABW(list,index,a,b)   DBGTRACK(PCWSTR, GlInsertStringABW, (list,index,a,b))



#define GlAppendStringA(list,str) GlAppendStringABA(list,str,SzGetEndA(str))
#define GlAppendStringW(list,str) GlAppendStringABW(list,str,SzGetEndW(str))

#define GlInsertStringA(list,index,str) GlInsertStringABA(list,index,str,SzGetEndA(str))
#define GlInsertStringW(list,index,str) GlInsertStringABW(list,index,str,SzGetEndW(str))

#define GlAppendStringNA(list,str,len) GlAppendStringABA(list,str,SzTcharsToPointerA(str,len))
#define GlAppendStringNW(list,str,len) GlAppendStringABW(list,str,SzTcharsToPointerW(str,len))

#define GlInsertStringNA(list,index,str,len) GlInsertStringABA(list,index,str,SzTcharsToPointerA(str,len))
#define GlInsertStringNW(list,index,str,len) GlInsertStringABW(list,index,str,SzTcharsToPointerW(str,len))

#define GlGetStringA(list,index) (PCSTR)(GlGetItem(list,index))
#define GlGetStringW(list,index) (PCWSTR)(GlGetItem(list,index))

#define GlAppendEmptyItem(list)           GlAppend (list,NULL,0)
#define GlInsertEmptyItem(list,index)     GlInsert (list,index,NULL,0)

//
// A & W Macros
//

#ifdef UNICODE

#define GlAppendString              GlAppendStringW
#define GlInsertString              GlInsertStringW
#define GlAppendStringAB            GlAppendStringABW
#define GlInsertStringAB            GlInsertStringABW
#define GlAppendStringN             GlAppendStringNW
#define GlInsertStringN             GlInsertStringNW
#define GlGetString                 GlGetStringW
#define GlGetStringPtrArray         GlGetStringPtrArrayW

#else

#define GlAppendString              GlAppendStringA
#define GlInsertString              GlInsertStringA
#define GlAppendStringAB            GlAppendStringABA
#define GlInsertStringAB            GlInsertStringABA
#define GlAppendStringN             GlAppendStringNA
#define GlInsertStringN             GlInsertStringNA
#define GlGetString                 GlGetStringA
#define GlGetStringPtrArray         GlGetStringPtrArrayA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\log.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Implements new log engine.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifndef MY_EXTERN_C
#ifdef __cplusplus
#define MY_EXTERN_C extern "C"
#else
#define MY_EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

#if defined(DBG) || defined(_DEBUG)
#undef DEBUG
#define DEBUG
#endif

#define MAX_LOG_NAME    256

#ifndef STDMETHODCALLTYPE
#define STDMETHODCALLTYPE __stdcall
#endif

typedef enum tagLOG_PROVIDER_TYPE{
    LOG_FILTER_TYPE,
    LOG_FORMATTER_TYPE,
    LOG_DEVICE_TYPE
}LOG_PROVIDER_TYPE, *PLOG_PROVIDER_TYPE;

typedef enum tagLOGRESULT{
// for all types of providers
    logError = FALSE,
    logOk = TRUE,

// for filter&formatter
    logContinue = logOk,
    logDoNotContinue,
    logBreakPoint,
    logAbortProcess,
// for device
    logAlreadyExist
}LOGRESULT, *PLOGRESULT;

typedef enum tagLOGTYPE{
    LT_SZ,
    LT_DWORD,
    LT_BINARY,
}LOGTYPE, *PLOGTYPE;


typedef struct tagLOG_FIELD_INFO
{
    LOGTYPE Type;
    BOOL    bMandatory;
    WCHAR   Name[MAX_LOG_NAME];
}LOG_FIELD_INFO, *PLOG_FIELD_INFO;

typedef struct tagLOG_VALUE{
    LOGTYPE Type;
    union{
        struct BinaryValue{
            PBYTE   Buffer;
            DWORD   Size;
        }Binary;
        DWORD   Dword;
        PCWSTR  String;
        PVOID   PVoid;
    };
}LOG_VALUE, *PLOG_VALUE;

typedef struct tagLOG_FIELD_VALUE{
    WCHAR       Name[MAX_LOG_NAME];
    BOOL        bMandatory;
    LOG_VALUE   Value;
}LOG_FIELD_VALUE, *PLOG_FIELD_VALUE;

typedef enum tagDEVICE_PROV_FLAGS{
    DEVICE_WRITE_THROUGH    = 0x1, 
    DEVICE_CREATE_NEW       = 0x2
}DEVICE_PROV_FLAGS, *PDEVICE_PROV_FLAGS;

typedef struct tagLOG_DEVICE_PROV_INIT_DATA{
    PCWSTR  PathName;
    DWORD   dwFlags;
    DWORD   dwReserved1;
    DWORD   dwReserved2;
}LOG_DEVICE_PROV_INIT_DATA, *PLOG_DEVICE_PROV_INIT_DATA;

typedef enum tagLOG_SETUPLOG_SEVERITY{
    LOG_ASSERT      = 0,
    LOG_FATAL_ERROR = 1,
    LOG_ERROR       = 2,
    LOG_WARNING     = 3,
    LOG_INFO        = 4,
    DBG_ASSERT      = 101,
    DBG_NAUSEA      = 102,
    DBG_INFO        = 103,
    DBG_VERBOSE     = 104,
    DBG_STATS       = 105,
    DBG_WARNING     = 106,
    DBG_ERROR       = 107,
    DBG_WHOOPS      = 108,
    DBG_TRACK       = 109,
    DBG_TIME        = 111
}LOG_SETUPLOG_SEVERITY, *PLOG_SETUPLOG_SEVERITY;

typedef struct tagLOG_SETUPLOG_FORMAT_PROV_INIT_DATA{
    PCWSTR  SeverityFieldName;
    PCWSTR  MessageFieldName;
    DWORD   dwFlags;
}LOG_SETUPLOG_FORMAT_PROV_INIT_DATA, *PLOG_SETUPLOG_FORMAT_PROV_INIT_DATA;

typedef struct tagLOG_SETUPLOG_FILTER_PROV_INIT_DATA{
    PCWSTR                  FieldName;
    LOG_SETUPLOG_SEVERITY   SeverityThreshold;
    BOOL                    SuppressDebugMessages;
}LOG_SETUPLOG_FILTER_PROV_INIT_DATA, *PLOG_SETUPLOG_FILTER_PROV_INIT_DATA;

typedef struct tagLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA{
    PCWSTR  SeverityFieldName;
    PCWSTR  MessageFieldName;
    PCWSTR  ConditionFieldName;
    PCWSTR  SourceLineFieldName;
    PCWSTR  SourceFileFieldName;
    PCWSTR  SourceFunctionFieldName;
}LOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA, *PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA;

MY_EXTERN_C const GUID GUID_STANDARD_SETUPLOG_FILTER;
MY_EXTERN_C const GUID GUID_STANDARD_SETUPLOG_FORMATTER;
MY_EXTERN_C const GUID GUID_FILE_DEVICE;
MY_EXTERN_C const GUID GUID_DEBUG_FORMATTER_AND_DEVICE;
MY_EXTERN_C const GUID GUID_DEBUG_FILTER;
MY_EXTERN_C const GUID GUID_XML_FORMATTER;

MY_EXTERN_C
BOOL
LogRegisterStockProviders(
    VOID
    );

MY_EXTERN_C
BOOL
LogUnRegisterStockProviders(
    VOID
    );

//////////////////////////////////////////////////////////////////////////////////////
//Interface ILogManager

#if defined(__cplusplus) && !defined(CINTERFACE)
class ILogManager
{
public:
    virtual BOOL STDMETHODCALLTYPE AddStack(const GUID *guidFilter,
                                            PVOID pFilterData,
                                            const GUID *guidFormater,
                                            PVOID pFormaterData,
                                            const GUID *guidDevice,
                                            PVOID pDeviceData,
                                            PVOID *pvHandle) = 0;

    virtual BOOL STDMETHODCALLTYPE RemoveStack(PVOID pvHandle) = 0;

    virtual LOGRESULT STDMETHODCALLTYPE LogA(UINT NumberOfFieldsToLog, ...) = 0;
    virtual LOGRESULT STDMETHODCALLTYPE LogW(UINT NumberOfFieldsToLog, ...) = 0;

};

#ifdef UNICODE
#define Log LogW
#else
#define Log LogA
#endif

#else

typedef struct ILogManagerVtbl;
typedef struct ILogManager
{
    const struct ILogManagerVtbl * pVtbl;
}ILogManager;

typedef struct ILogManagerVtbl
{
    BOOL (STDMETHODCALLTYPE *AddStack)(
        ILogManager * This,
        const GUID  *guidFilter,
        PVOID pFilterData,
        const GUID  *guidFormater,
        PVOID pFormaterData,
        const GUID  *guidDevice,
        PVOID pDeviceData,
        PVOID *pvHandle);

    BOOL (STDMETHODCALLTYPE *RemoveStack)(
        ILogManager * This,
        DWORD pvHandle);

    LOGRESULT (STDMETHODCALLTYPE *LogA)(
        ILogManager * This,
        UINT NumberOfFieldsToLog,
        ...);
    LOGRESULT (STDMETHODCALLTYPE *LogW)(
        ILogManager * This,
        UINT NumberOfFieldsToLog,
        ...);
} ILogManagerVtbl;

#define ILogManager_AddStack(This,guidFilter,pFilterData,guidFormater,pFormaterData,guidDevice,pDeviceData,pvHandle)    \
    (This)->pVtbl->AddStack(This,guidFilter,pFilterData,guidFormater,pFormaterData,guidDevice,pDeviceData,pvHandle)

#define ILogManager_RemoveStack(This,pvHandle)  \
    (This)->pVtbl->RemoveStack(This,pvHandle)

#define ILogManager_Log(This) (This)->pVtbl->Log
#define ILogManager(This) ((This)->pVtbl)

#ifdef UNICODE
#define Log LogW
#else
#define Log LogA
#endif

#endif

ILogManager *
LogCreateLog(
    IN PCWSTR pLogName,
    IN PLOG_FIELD_INFO pFields,
    IN UINT NumberOfFields
    );

VOID
LogDestroyLog(
    IN ILogManager * pLog
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\memory.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    memory.h

Abstract:

    Implements macros and declares functions for basic allocation functions.

Author:

    Marc R. Whitten (marcw) 09-Sep-1999

Revision History:

    jimschm 25-Jul-2001     Updated for consistent coding conventions

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// Constants
//

#define INVALID_PTR             ((PVOID)-1)

#undef INITIALIZE_MEMORY_CODE
#define INITIALIZE_MEMORY_CODE  if (!MemInitialize()) { __leave; }


//
// Globals
//

extern HANDLE g_hHeap;

//
// Function Prototypes
//

BOOL
MemInitialize (
    VOID
    );


//
// Reusable memory alloc, kind of like a GROWBUFFER but more simple. Here is
// an example of how it might be used:
//
// buffer = NULL;
//
// while (pGetAnItemIndex (&i)) {
//      size = pComputeBufferSizeForThisItem (i);
//      buffer = (PTSTR) MemReuseAlloc (g_hHeap, ptr, size);
//      pProcessSomething (i, buffer);
// }
//
// MemReuseFree (buffer);
//
// Allocations are always rounded up to the next 1K boundary, and allocations
// occur only when the buffer is too small or hasn't been allocated.
//

PVOID
MemReuseAlloc (
    IN      HANDLE Heap,
    IN      PVOID OldPtr,           OPTIONAL
    IN      DWORD SizeNeeded
    );

VOID
MemReuseFree (
    IN      HANDLE Heap,
    IN      PVOID Ptr
    );


#ifdef DEBUG

    //
    // Fast allocation routines (tracked versions)
    //

    PVOID
    DbgFastAlloc (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      SIZE_T Size
        );

    PVOID
    DbgFastReAlloc (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      PCVOID OldBlock,
        IN      SIZE_T Size
        );

    BOOL
    DbgFastFree (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      PCVOID Block
        );

    PVOID
    DbgFastAllocNeverFail (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      SIZE_T Size
        );

    PVOID
    DbgFastReAllocNeverFail (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      PCVOID OldBlock,
        IN      SIZE_T Size
        );

    #define MemFastAlloc(size)  DbgFastAlloc(__FILE__,__LINE__,size)
    #define MemFastReAlloc(oldblock,size)  DbgFastReAlloc(__FILE__,__LINE__,oldblock,size)
    #define MemFastFree(block)  DbgFastFree(__FILE__,__LINE__,block)
    #define MemFastAllocNeverFail(size)  DbgFastAllocNeverFail(__FILE__,__LINE__,size)
    #define MemFastReAllocNeverFail(oldblock,size)  DbgFastReAllocNeverFail(__FILE__,__LINE__,oldblock,size)

    //
    // Regular heap access (tracked versions)
    //

    PVOID
    DbgHeapAlloc (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      SIZE_T Size
        );

    PVOID
    DbgHeapReAlloc (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      PCVOID Mem,
        IN      SIZE_T Size
        );

    PVOID
    DbgHeapAllocNeverFail (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      SIZE_T Size
        );

    PVOID
    DbgHeapReAllocNeverFail (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      PCVOID Mem,
        IN      SIZE_T Size
        );

    BOOL
    DbgHeapFree (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      PCVOID Mem
        );

    #define MemAllocNeverFail(heap,flags,size)  DbgHeapAllocNeverFail(__FILE__,__LINE__,heap,flags,size)
    #define MemReAllocNeverFail(heap,flags,oldblock,size)  DbgHeapReAllocNeverFail(__FILE__,__LINE__,heap,flags,oldblock,size)
    #define MemAlloc(heap,flags,size)  DbgHeapAlloc(__FILE__,__LINE__,heap,flags,size)
    #define MemReAlloc(heap,flags,oldblock,size)  DbgHeapReAlloc(__FILE__,__LINE__,heap,flags,oldblock,size)
    #define MemFree(heap,flags,block)  DbgHeapFree(__FILE__,__LINE__,heap,flags,block)

    //
    // Aides for debugging memory corruption
    //

    VOID
    DbgHeapCheck (
        IN      PCSTR SourceFile,
        IN      DWORD Line,
        IN      HANDLE Heap
        );

    #define MemHeapCheck(heap)      DbgHeapCheck(__FILE__,__LINE__,heap)

    VOID
    DbgDumpHeapStats (
        VOID
        );

    VOID
    DbgDumpHeapLeaks (
        VOID
        );

    SIZE_T
    DbgHeapValidatePtr (
        IN      HANDLE Heap,
        IN      PCVOID CallerPtr,
        IN      PCSTR File,
        IN      DWORD Line
        );

    #define MemCheckPtr(heap,ptr)       (DbgHeapValidatePtr(heap,ptr,__FILE__,__LINE__) != INVALID_PTR)

#else   // !DEBUG

    //
    // Fast allocation routines
    //

    PVOID
    MemFastAlloc (
        IN      SIZE_T Size
        );

    PVOID
    MemFastReAlloc (
        IN      PCVOID OldBlock,
        IN      SIZE_T Size
        );

    BOOL
    MemFastFree (
        IN      PCVOID Block
        );

    PVOID
    MemFastAllocNeverFail (
        IN      SIZE_T Size
        );

    PVOID
    MemFastReAllocNeverFail (
        IN      PVOID OldBlock,
        IN      SIZE_T Size
        );

    //
    // Fail-proof memory allocators
    //

    PVOID
    MemAllocNeverFail (
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      SIZE_T Size
        );

    PVOID
    MemReAllocNeverFail (
        IN      HANDLE Heap,
        IN      DWORD Flags,
        IN      PVOID OldBlock,
        IN      SIZE_T Size
        );

    #define MemAlloc(heap,flags,size)  HeapAlloc(heap,flags,size)
    #define MemReAlloc(heap,flags,oldblock,size)  HeapReAlloc(heap,flags,oldblock,size)
    #define MemFree(x,y,z) HeapFree(x,y,(PVOID)(z))

    //
    // Stub macros
    //

    #define DbgDumpHeapStats()
    #define DbgDumpHeapLeaks()

    #define MemHeapCheck(heap)          (1)
    #define MemCheckPtr(heap,ptr)       (1)

#endif

PVOID
MemFastAllocAndZero (
    IN      SIZE_T Size
    );

PVOID
MemFastReAllocAndZero (
    IN      PCVOID Ptr,
    IN      SIZE_T Size
    );

//
// Wrapper macros
//

#define FAST_MALLOC_UNINIT(size)        MemFastAlloc (size)
#define FAST_MALLOC_ZEROED(size)        MemFastAllocAndZero (size)
#define FAST_MALLOC(size)               FAST_MALLOC_UNINIT (size)
#define FAST_REALLOC_UNINIT(ptr,size)   MemFastReAlloc (ptr, size)
#define FAST_REALLOC_ZEROED(ptr,size)   MemFastReAllocAndZero (ptr, size)
#define FAST_REALLOC(ptr,size)          REALLOC_UNINIT (ptr, size)
#define FAST_FREE(ptr)                  MemFastFree ((PVOID)(ptr))

#define MALLOC_UNINIT(size)             MemAlloc (g_hHeap, 0, size)
#define MALLOC_ZEROED(size)             MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, size)
#define MALLOC(size)                    MALLOC_UNINIT (size)
#define REALLOC_UNINIT(ptr,size)        MemReAlloc (g_hHeap, 0, ptr, size)
#define REALLOC_ZEROED(ptr,size)        MemReAlloc (g_hHeap, HEAP_ZERO_MEMORY, ptr, size)
#define REALLOC(ptr,size)               REALLOC_UNINIT (ptr, size)
#define FREE(ptr)                       MemFree (g_hHeap, 0, (PVOID)(ptr))


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\hash.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hash.h

Abstract:

    Replacement routines for the string table functions in setupapi.dll.
    These routines are much more easy to work with.

Author:

    Jim Schmidt (jimschm)   22-Dec-1998

Revision History:

    jimschm     25-Jul-2001 Minor coding convention fixups
    ovidiut     11-Oct-1999 Updated for new coding conventions and Win64 compliance

--*/

#pragma once

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Macros
//

#define CASE_SENSITIVE      TRUE
#define CASE_INSENSITIVE    FALSE

#define UNKNOWN_LETTER_CASE FALSE
#define ALREADY_LOWERCASE   TRUE

#define DEFAULT_BUCKET_SIZE 0

//
// Types
//

typedef const void *HASHTABLE;

typedef const void *HASHITEM;

typedef struct {

    PCSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMA, *PHASHTABLE_ENUMA;

typedef struct {
    PCWSTR String;
    PCVOID ExtraData;
    HASHITEM Index;

    HASHTABLE Internal;

} HASHTABLE_ENUMW, *PHASHTABLE_ENUMW;

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEA)(
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCSTR String,
    IN      PVOID ExtraData,
    IN      UINT ExtraDataSize,
    IN      LPARAM lParam
    );

typedef
BOOL
(*PHASHTABLE_CALLBACK_ROUTINEW)(
    IN HASHTABLE HashTable,
    IN HASHITEM Index,
    IN PCWSTR String,
    IN PVOID ExtraData,
    IN UINT ExtraDataSize,
    IN LPARAM lParam
    );

//
// Function prototypes and wrapper macros
//

HASHTABLE
RealHtAllocExAW (
    IN      BOOL CaseSensitive,
    IN      BOOL Unicode,
    IN      BOOL ExternalStrings,
    IN      UINT ExtraDataSize,
    IN      UINT BucketCount            OPTIONAL
    );

DBGTRACK_DECLARE(HASHTABLE)

#define HtAllocExAW(cs,u,s,d,b)     DBGTRACK_BEGIN(HASHTABLE, HtAllocExAW)\
                                    RealHtAllocExAW(cs,u,s,d,b)\
                                    DBGTRACK_END()

#define HtAllocA()                                  HtAllocExAW(FALSE,FALSE,FALSE,0,0)
#define HtAllocW()                                  HtAllocExAW(FALSE,TRUE,FALSE,0,0)

#define HtAllocWithDataA(size)                      HtAllocExAW(FALSE,FALSE,FALSE,size,0)
#define HtAllocWithDataW(size)                      HtAllocExAW(FALSE,TRUE,FALSE,size,0)

#define HtAllocExA(cs,datasize,bucketcount)         HtAllocExAW(cs,FALSE,FALSE,datasize,bucketcount)
#define HtAllocExW(cs,datasize,bucketcount)         HtAllocExAW(cs,TRUE,FALSE,datasize,bucketcount)

#define HtAllocExternStrA()                         HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrW()                         HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrWithDataA(size)             HtAllocExAW(FALSE,FALSE,TRUE,0,0)
#define HtAllocExternStrWithDataW(size)             HtAllocExAW(FALSE,TRUE,TRUE,0,0)

#define HtAllocExternStrExA(cs,size,bucketcount)    HtAllocExAW(cs,FALSE,TRUE,size,bucketcount)
#define HtAllocExternStrExW(cs,size,bucketcount)    HtAllocExAW(cs,TRUE,TRUE,size,bucketcount)

VOID
HtFree (
    IN      HASHTABLE HashTable
    );

HASHITEM
HtAddStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringA(table,string)              HtAddStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataA(table,string,data)  HtAddStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtAddStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    IN      PCVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtAddStringW(table,string)              HtAddStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtAddStringAndDataW(table,string,data)  HtAddStringExW(table,string,data,UNKNOWN_LETTER_CASE)

BOOL
HtRemoveItem (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Item
    );

BOOL
HtRemoveStringA (
    IN      HASHTABLE HashTable,
    IN      PCSTR AnsiString
    );

BOOL
HtRemoveStringW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR UnicodeString
    );


HASHITEM
HtFindStringExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringA(table,string)             HtFindStringExA(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataA(table,string,data) HtFindStringExA(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindStringExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR String,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindStringW(table,string)             HtFindStringExW(table,string,NULL,UNKNOWN_LETTER_CASE)
#define HtFindStringAndDataW(table,string,data) HtFindStringExW(table,string,data,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExA (
    IN      HASHTABLE HashTable,
    IN      PCSTR StringStart,
    IN      PCSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixA(table,str,end)    HtFindPrefixExA(table,str,end,NULL,UNKNOWN_LETTER_CASE)

HASHITEM
HtFindPrefixExW (
    IN      HASHTABLE HashTable,
    IN      PCWSTR StringStart,
    IN      PCWSTR BufferEnd,
    OUT     PVOID ExtraData,            OPTIONAL
    IN      BOOL AlreadyLowercase
    );

#define HtFindPrefixW(table,str,end)     HtFindPrefixExW(table,str,end,NULL,UNKNOWN_LETTER_CASE)

BOOL
HtGetExtraData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PCVOID *ExtraData
    );

BOOL
HtCopyStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    OUT     PVOID ExtraData
    );

BOOL
HtSetStringData (
    IN      HASHTABLE HashTable,
    IN      HASHITEM Index,
    IN      PCVOID ExtraData
    );

PCSTR
HtGetStringFromItemA (
    IN      HASHITEM Index
    );

PCWSTR
HtGetStringFromItemW (
    IN      HASHITEM Index
    );

BOOL
HtEnumFirstStringA (
    OUT     PHASHTABLE_ENUMA EnumPtr,
    IN      HASHTABLE HashTable
    );

BOOL
HtEnumFirstStringW (
    OUT     PHASHTABLE_ENUMW EnumPtr,
    IN      HASHTABLE HashTable
    );


BOOL
HtEnumNextStringA (
    IN OUT  PHASHTABLE_ENUMA EnumPtr
    );

BOOL
HtEnumNextStringW (
    IN OUT  PHASHTABLE_ENUMW EnumPtr
    );

BOOL
HtEnumWithCallbackA (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEA Proc,
    IN      LPARAM lParam
    );

BOOL
HtEnumWithCallbackW (
    IN      HASHTABLE Table,
    IN      PHASHTABLE_CALLBACK_ROUTINEW Proc,
    IN      LPARAM lParam
    );

//
// A & W macros
//

#ifdef UNICODE

#define HASHTABLE_ENUM              HASHTABLE_ENUMW
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMW
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEW
#define HtAlloc                     HtAllocW
#define HtAllocWithData             HtAllocWithDataW
#define HtAllocEx                   HtAllocExW
#define HtAllocExternStr            HtAllocExternStrW
#define HtAllocExternStrWithData    HtAllocExternStrWithDataW
#define HtAllocExternStrEx          HtAllocExternStrExW
#define HtAddString                 HtAddStringW
#define HtAddStringAndData          HtAddStringAndDataW
#define HtAddStringEx               HtAddStringExW
#define HtRemoveString              HtRemoveStringW
#define HtFindString                HtFindStringW
#define HtFindStringAndData         HtFindStringAndDataW
#define HtFindStringEx              HtFindStringExW
#define HtFindPrefix                HtFindPrefixW
#define HtFindPrefixEx              HtFindPrefixExW
#define HtGetStringFromItem         HtGetStringFromItemW
#define HtEnumFirstString           HtEnumFirstStringW
#define HtEnumNextString            HtEnumNextStringW
#define HtEnumWithCallback          HtEnumWithCallbackW

#else

#define HASHTABLE_ENUM              HASHTABLE_ENUMA
#define PHASHTABLE_ENUM             PHASHTABLE_ENUMA
#define PHASH_CALLBACK_ROUTINE      PHASH_CALLBACK_ROUTINEA
#define HtAlloc                     HtAllocA
#define HtAllocWithData             HtAllocWithDataA
#define HtAllocEx                   HtAllocExA
#define HtAllocExternStr            HtAllocExternStrA
#define HtAllocExternStrWithData    HtAllocExternStrWithDataA
#define HtAllocExternStrEx          HtAllocExternStrExA
#define HtAddString                 HtAddStringA
#define HtAddStringAndData          HtAddStringAndDataA
#define HtAddStringEx               HtAddStringExA
#define HtRemoveString              HtRemoveStringA
#define HtFindString                HtFindStringA
#define HtFindStringAndData         HtFindStringAndDataA
#define HtFindStringEx              HtFindStringExA
#define HtFindPrefix                HtFindPrefixA
#define HtFindPrefixEx              HtFindPrefixExA
#define HtGetStringFromItem         HtGetStringFromItemA
#define HtEnumFirstString           HtEnumFirstStringA
#define HtEnumNextString            HtEnumNextStringA
#define HtEnumWithCallback          HtEnumWithCallbackA

#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\init.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Declares initialization and termination functions for all utility sets
    that have been included.

Author:

    Jim Schmidt (jimschm) 02-Aug-2001

Revision History:

    <alias> <date> <comment>

--*/


HANDLE g_hHeap;
HINSTANCE g_hInst;

BOOL
Initialize (
    VOID
    )
{
    BOOL result = FALSE;

    __try {

        INITIALIZE_MEMORY_CODE
        INITIALIZE_LOG_CODE
        INITIALIZE_UNICODE_CODE
        INITIALIZE_STRMEM_CODE
        INITIALIZE_STRMAP_CODE
        INITIALIZE_HASH_CODE
        INITIALIZE_GROWBUF_CODE
        INITIALIZE_GROWLIST_CODE
        INITIALIZE_XML_CODE

        result = TRUE;
    }
    __finally {
        MYASSERT (TRUE);    // debugger workaround
    }

    return result;
}


BOOL
Terminate (
    VOID
    )
{
    BOOL result = FALSE;

    __try {

        TERMINATE_GROWLIST_CODE
        TERMINATE_GROWBUF_CODE
        TERMINATE_HASH_CODE
        TERMINATE_STRMAP_CODE
        TERMINATE_STRMEM_CODE
        TERMINATE_UNICODE_CODE
        TERMINATE_LOG_CODE
        TERMINATE_MEMORY_CODE
        TERMINATE_XML_CODE

        result = TRUE;
    }
    __finally {
        MYASSERT (TRUE);    // debugger workaround
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\strings.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    strings.h

Abstract:

    Declares the string utilities implemented in common\migutil.

Author:

    Several

Revision History:

    See SLM log

--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <tchar.h>
#include <mbstring.h>
#include <wchar.h>

#pragma once

//
// Worker routines for faster SzMatch* functions
//

BOOL
SzMemMatchA (
    IN      PCSTR Buffer1,
    IN      PCSTR Buffer2,
    IN      SIZE_T ByteCount
    );

BOOL
SzMemMatchW (
    IN      PCWSTR Buffer1,
    IN      PCWSTR Buffer2,
    IN      SIZE_T ByteCount
    );

// SzNextCharA is _mbsinc with a check for a broken mbcs char
PSTR
SzNextCharA (
    IN      PCSTR CurrentPointer
    );

// Bug fix for C Runtime _tcsdec
__inline
PWSTR
SzPrevCharW (
    IN      PCWSTR Base,
    IN      PCWSTR Pointer
    )
{
    if (Base >= Pointer) {
        return NULL;
    }

    return (PWSTR) (Pointer - 1);
}

// Bug fix for C Runtime _tcsdec
__inline
PSTR
SzPrevCharA (
    PCSTR Base,
    PCSTR Pointer
    )
{
    if (Base >= Pointer) {
        return NULL;
    }

    return (PSTR) _mbsdec ((const unsigned char *) Base, (const unsigned char *) Pointer);
}


//
// String sizing routines and unit conversion
//

#define SzLcharCountA(x)   ((UINT)_mbslen(x))
#define SzLcharCountW(x)   ((UINT)wcslen(x))


__inline
PSTR
SzLcharsToPointerA (
    PCSTR String,
    UINT Char
    )
{
    while (Char > 0) {
        MYASSERT (*String != 0);
        Char--;
        String = SzNextCharA (String);
    }

    return (PSTR) String;
}

__inline
PWSTR
SzLcharsToPointerW (
    PCWSTR String,
    UINT Char
    )
{
#ifdef DEBUG
    UINT u;
    for (u = 0 ; u < Char ; u++) {
        MYASSERT (String[u] != 0);
    }
#endif

    return (PWSTR) (&String[Char]);
}


__inline
UINT
SzLcharCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
    register UINT count;

    count = 0;
    while (Start < EndPlusOne) {
        MYASSERT (*Start != 0);
        count++;
        Start = SzNextCharA (Start);
    }

    return count;
}

__inline
UINT
SzLcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}


__inline
UINT
SzLcharsInByteRangeA (
    IN      PCSTR Start,
    IN      UINT Bytes
    )
{
    register UINT count;
    PCSTR endPlusOne = (PCSTR) ((PBYTE) Start + Bytes);

    count = 0;
    while (Start < endPlusOne) {
        count++;
        Start = SzNextCharA (Start);
    }

    return count;
}

__inline
UINT
SzLcharsInByteRangeW (
    IN      PCWSTR Start,
    IN      UINT Bytes
    )
{
    PCWSTR endPlusOne = (PCWSTR) ((PBYTE) Start + Bytes);

    if (Start < endPlusOne) {
        //cast is OK, we don't expect pointers to be that far
        return (UINT)(endPlusOne - Start);
    }

    MYASSERT (FALSE);
    return 0;
}

__inline
UINT
SzLcharsToBytesA (
    IN      PCSTR Start,
    IN      UINT LogChars
    )
{
    PCSTR endPlusOne;

    endPlusOne = SzLcharsToPointerA (Start, LogChars);
    //cast is OK, we don't expect pointers to be that far
    return (UINT)(endPlusOne - Start);
}

__inline
UINT
SzLcharsToBytesW (
    IN      PCWSTR Start,
    IN      UINT LogChars
    )
{
    return LogChars * SIZEOF (WCHAR);
}

#define SzLcharsToTcharsA   SzLcharsToBytesA

__inline
UINT
SzLcharsToTcharsW (
    IN      PCWSTR Start,
    IN      UINT LogChars
    )
{
    return LogChars;
}


#define SzByteCountA(x)   ((UINT) strlen (x))
#define SzByteCountW(x)   ((UINT) wcslen (x) * SIZEOF(WCHAR))

#define SzSizeA(str)  ((UINT) SzByteCountA (str) + SIZEOF (CHAR))
#define SzSizeW(str)  ((UINT) SzByteCountW (str) + SIZEOF (WCHAR))

__inline
PSTR
SzBytesToPointerA (
    PCSTR String,
    UINT BytePos
    )
{
    return (PSTR)((ULONG_PTR) String + BytePos);
}

__inline
PWSTR
SzBytesToPointerW (
    PCWSTR String,
    UINT BytePos
    )
{
    return (PWSTR)((ULONG_PTR) String + (BytePos & (~1)));
}


__inline
UINT
SzByteCountABA (
    IN      PCSTR Start,
    IN      PCSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCSTR p;
    for (p = Start ; p < EndPlusOne ; p = SzNextCharA (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

__inline
UINT
SzByteCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;
    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) * SIZEOF (WCHAR) : 0;
}

__inline
UINT
SzBytesToLcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
    PCSTR endPlusOne;

    endPlusOne = Start + ByteCount;
    return SzLcharCountABA (Start, endPlusOne);
}

__inline
UINT
SzBytesToLcharsW (
    IN      PCWSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR endPlusOne;
    endPlusOne = (PCWSTR) ((ULONG_PTR) Start + ByteCount);

    for (p = Start ; p < endPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount / SIZEOF (WCHAR);
}

__inline
UINT
SzBytesToTcharsA (
    IN      PCSTR Start,
    IN      UINT ByteCount
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR endPlusOne;
    endPlusOne = Start + ByteCount;

    for (p = Start ; p < endPlusOne ; p = SzNextCharA (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return ByteCount;
}

#define SzBytesToTcharsW  SzBytesToLcharsW


#define SzTcharCountA     strlen
#define SzTcharCountW     wcslen

__inline
PSTR
SzTcharsToPointerA (
    PCSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR endPlusOne;
    endPlusOne = String + Tchars;

    for (p = String ; p < endPlusOne ; p = SzNextCharA (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return (PSTR) (String + Tchars);
}

__inline
PWSTR
SzTcharsToPointerW (
    PCWSTR String,
    UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR endPlusOne;
    endPlusOne = String + Tchars;

    for (p = String ; p < endPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return (PWSTR) (String + Tchars);
}


#define SzTcharCountABA       SzByteCountABA

__inline
UINT
SzTcharCountABW (
    IN      PCWSTR Start,
    IN      PCWSTR EndPlusOne
    )
{
#ifdef DEBUG
    PCWSTR p;

    for (p = Start ; p < EndPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return EndPlusOne > Start ? (UINT)(EndPlusOne - Start) : 0;
}

#define SzTcharsToLcharsA      SzBytesToLcharsA

__inline
UINT
SzTcharsToLcharsW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR endPlusOne;
    endPlusOne = Start + Tchars;

    for (p = Start ; p < endPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
SzTcharsToBytesA (
    IN      PCSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCSTR p;
    PCSTR endPlusOne;
    endPlusOne = Start + Tchars;

    for (p = Start ; p < endPlusOne ; p = SzNextCharA (p)) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars;
}

__inline
UINT
SzTcharsToBytesW (
    IN      PCWSTR Start,
    IN      UINT Tchars
    )
{
#ifdef DEBUG
    PCWSTR p;
    PCWSTR endPlusOne;
    endPlusOne = Start + Tchars;

    for (p = Start ; p < endPlusOne ; p++) {
        MYASSERT (*p != 0);
    }
#endif

    return Tchars * SIZEOF (WCHAR);
}

#define SzBufferCopyA(stackbuf,src)                  SzCopyBytesA(stackbuf,src,SIZEOF(stackbuf))
#define SzBufferCopyW(stackbuf,src)                  SzCopyBytesW(stackbuf,src,SIZEOF(stackbuf))


//
// String comparison routines
//

#define SzCompareA                                  _mbscmp
#define SzCompareW                                  wcscmp

BOOL
SzMatchA (
    IN      PCSTR String1,
    IN      PCSTR String2
    );

#define SzMatchW(str1,str2)                         (wcscmp(str1,str2)==0)

#define SzICompareA                                 _mbsicmp
#define SzICompareW                                 _wcsicmp

#define SzIMatchA(str1,str2)                        (_mbsicmp(str1,str2)==0)
#define SzIMatchW(str1,str2)                        (_wcsicmp(str1,str2)==0)

INT
SzCompareBytesA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    );

#define SzCompareBytesW(str1,str2,bytes)            wcsncmp(str1,str2,(bytes)/sizeof(WCHAR))

#define SzMatchBytesA(str1,str2,bytes)              (SzMemMatchA (str1, str2, bytes))
#define SzMatchBytesW(str1,str2,bytes)              (SzMemMatchW (str1, str2, bytes))

INT
SzICompareBytesA (
    IN      PCSTR String1,
    IN      PCSTR String2,
    IN      SIZE_T ByteCount
    );

#define SzICompareBytesW(str1,str2,bytes)           _wcsnicmp (str1, str2, (bytes) / sizeof(WCHAR))

#define SzIMatchBytesA(str1,str2,bytes)             (SzICompareBytesA (str1, str2, bytes) == 0)
#define SzIMatchBytesW(str1,str2,bytes)             (_wcsnicmp (str1, str2, (bytes) / sizeof(WCHAR)) == 0)

#define SzCompareLcharsA(str1,str2,chars)           _mbsncmp (str1, str2, chars)
#define SzCompareLcharsW(str1,str2,chars)           wcsncmp (str1, str2, chars)

#define SzMatchLcharsA(str1,str2,chars)             (_mbsncmp (str1,str2,chars) == 0)
#define SzMatchLcharsW(str1,str2,chars)             SzMemMatchW (str1, str2, (chars) * sizeof (WCHAR))

#define SzICompareLcharsA(str1,str2,chars)          _mbsnicmp (str1, str2, chars)
#define SzICompareLcharsW(str1,str2,chars)          _wcsnicmp (str1, str2, chars)

#define SzIMatchLcharsA(str1,str2,chars)            (_mbsnicmp (str1, str2, chars)==0)
#define SzIMatchLcharsW(str1,str2,chars)            (_wcsnicmp (str1, str2, chars)==0)

#define SzCompareTcharsA(str1,str2,tchars)          SzCompareBytesA (str1, str2, (tchars) / sizeof(CHAR))
#define SzCompareTcharsW(str1,str2,tchars)          wcsncmp (str1, str2, tchars)

#define SzMatchTcharsA(str1,str2,tchars)            SzMemMatchA (str1, str2, (tchars) * sizeof (CHAR))
#define SzMatchTcharsW(str1,str2,tchars)            SzMemMatchW (str1, str2, (tchars) * sizeof (WCHAR))

#define SzICompareTcharsA(str1,str2,tchars)         SzICompareBytesA (str1, str2, tchars)
#define SzICompareTcharsW(str1,str2,tchars)         _wcsnicmp (str1, str2, tchars)

#define SzIMatchTcharsA(str1,str2,tchars)           SzIMatchBytesA (str1, str2, tchars)
#define SzIMatchTcharsW(str1,str2,tchars)           (_wcsnicmp (str1, str2, tchars)==0)

#define SzPrefixA(string,prefix)                    SzMatchTcharsA (string, prefix, SzTcharCountA (prefix))
#define SzPrefixW(string,prefix)                    SzMatchTcharsW (string, prefix, SzTcharCountW (prefix))

#define SzIPrefixA(string,prefix)                   SzIMatchTcharsA (string, prefix, SzTcharCountA (prefix))
#define SzIPrefixW(string,prefix)                   SzIMatchTcharsW (string, prefix, SzTcharCountW (prefix))

#define SzCompareABA(string1,start2,end2)           SzCompareTcharsA (string1, start2, (end2) - (start2))
#define SzCompareABW(string1,start2,end2)           SzCompareTcharsW (string1, start2, (end2) - (start2))

#define SzMatchABA(string1,start2,end2)             SzMemMatchA (string1, start2, (end2) - (start2))
#define SzMatchABW(string1,start2,end2)             SzMemMatchW (string1, start2, (end2) - (start2))

#define SzICompareABA(string1,start2,end2)          SzICompareTcharsA (string1, start2, (end2) - (start2))
#define SzICompareABW(string1,start2,end2)          SzICompareTcharsW (string1, start2, (end2) - (start2))

#define SzIMatchABA(string1,start2,end2)            SzIMatchTcharsA (string1, start2, (end2) - (start2))
#define SzIMatchABW(string1,start2,end2)            SzIMatchTcharsW (string1, start2, (end2) - (start2))



//
// String copy routines -- they return the END of the string
//

PSTR
SzCopyA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
SzCopyW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );

PSTR
SzCopyBytesA (
    OUT     PSTR Destination,
    IN      PCSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

PWSTR
SzCopyBytesW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source,
    IN      UINT MaxBytesToCopyIncNul
    );

PSTR
SzCopyBytesABA (
    OUT     PSTR Destination,
    IN      PCSTR Start,
    IN      PCSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

PWSTR
SzCopyBytesABW (
    OUT     PWSTR Destination,
    IN      PCWSTR Start,
    IN      PCWSTR End,
    IN      UINT MaxBytesToCopyIncNul
    );

#define SzCopyLcharsA(str1,str2,chars)          SzCopyBytesA(str1,str2,SzLcharsToBytesA(str2,chars))
#define SzCopyLcharsW(str1,str2,chars)          SzCopyBytesW(str1,str2,SzLcharsToBytesW(str2,chars))

#define SzCopyTcharsA(str1,str2,tchars)         SzCopyBytesA(str1,str2,tchars * sizeof (CHAR))
#define SzCopyTcharsW(str1,str2,tchars)         SzCopyBytesW(str1,str2,tchars * sizeof (WCHAR))

#define SzCopyABA(dest,stra,strb)               SzCopyBytesA((dest),(stra),((UINT)((ULONG_PTR)(strb)-(ULONG_PTR)(stra))+(UINT)SIZEOF(CHAR)))
#define SzCopyABW(dest,stra,strb)               SzCopyBytesW((dest),(stra),((UINT)((ULONG_PTR)(strb)-(ULONG_PTR)(stra))+(UINT)SIZEOF(WCHAR)))

//
// String cat routines -- they return the END of the string
//

PSTR
SzCatA (
    OUT     PSTR Destination,
    IN      PCSTR Source
    );

PWSTR
SzCatW (
    OUT     PWSTR Destination,
    IN      PCWSTR Source
    );


//
// Character search routines
//

// note the use of strchr, not _mbschr, is critical
#define SzGetEndA(s)      strchr(s,0)
#define SzGetEndW(s)      wcschr(s,0)

__inline
UINT
MszSizeA (
    PCSTR MultiSz
    )
{
    PCSTR Base;

    Base = MultiSz;

    while (*MultiSz) {
        MultiSz = SzGetEndA (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((ULONG_PTR) MultiSz - (ULONG_PTR) Base);
}


__inline
UINT
MszSizeW (
    PCWSTR MultiSz
    )
{
    PCWSTR base;

    base = MultiSz;

    while (*MultiSz) {
        MultiSz = SzGetEndW (MultiSz) + 1;
    }

    MultiSz++;

    return (UINT)((ULONG_PTR) MultiSz - (ULONG_PTR) base);
}


__inline
UINT
MszTcharCountA (
    PCSTR MultiSz
    )
{
    PCSTR end = MultiSz;

    while (*end) {

        do {
            end = SzNextCharA (end);
        } while (*end);

        end++;
    }

    end++;

    return (UINT) (end - MultiSz);
}


__inline
UINT
MszTcharCountW (
    PCWSTR MultiSz
    )
{
    PCWSTR end = MultiSz;

    while (*end) {

        do {
            end++;
        } while (*end);

        end++;
    }

    end++;

    return (UINT) (end - MultiSz);
}

PSTR
SzFindPrevCharA (
    IN      PCSTR StartStr,
    IN      PCSTR CurrPtr,
    IN      MBCHAR SearchChar
    );

PWSTR
SzFindPrevCharW (
    IN      PCWSTR StartStr,
    IN      PCWSTR CurrPtr,
    IN      WCHAR SearchChar
    );

// pointer to string conversion, returns eos
PSTR
SzUnsignedToHexA (
    IN      ULONG_PTR Number,
    OUT     PSTR String
    );

PWSTR
SzUnsignedToHexW (
    IN      ULONG_PTR Number,
    OUT     PWSTR String
    );

PSTR
SzUnsignedToDecA (
    IN      ULONG_PTR Number,
    OUT     PSTR String
    );

PWSTR
SzUnsignedToDecW (
    IN      ULONG_PTR Number,
    OUT     PWSTR String
    );

PSTR
SzSignedToDecA (
    IN      LONG_PTR Number,
    OUT     PSTR String
    );

PWSTR
SzSignedToDecW (
    IN      LONG_PTR Number,
    OUT     PWSTR String
    );

//
// All conversion routines that return values support both decimal and hex
// (even the signed routines).
//

ULONG
SzToNumberA (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

ULONG
SzToNumberW (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

ULONGLONG
SzToULongLongA (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

ULONGLONG
SzToULongLongW (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

LONGLONG
SzToLongLongA (
    IN      PCSTR String,
    OUT     PCSTR *EndOfNumber          OPTIONAL
    );

LONGLONG
SzToLongLongW (
    IN      PCWSTR String,
    OUT     PCWSTR *EndOfNumber         OPTIONAL
    );

// determines if an entire string is printable chars
BOOL
SzIsPrintA (
    IN      PCSTR String
    );

BOOL
SzIsPrintW (
    IN      PCWSTR String
    );

//
// String-in-string search routines
//

// you could use _mbsstr or wcsstr, but for convention sake, these defines are provided
#define SzFindSubStringA(String1, String2)     _mbsstr (String1, String2)
#define SzFindSubStringW(String1, String2)     wcsstr (String1, String2)

PCSTR
SzIFindSubStringA (
    IN      PCSTR FullString,
    IN      PCSTR SubString
    );

PCWSTR
SzIFindSubStringW (
    IN      PCWSTR FullString,
    IN      PCWSTR SubString
    );

//
// Character copy routines
//

PSTR
SzCopyNextCharA (
    OUT     PSTR Dest,
    IN      PCSTR Source
    );

// Most people use *dest++ = *source++, but for completeness, this fn is provided.
// Maybe you need the separate return value.
__inline
PWSTR
SzCopyNextCharW (
    OUT     PWSTR Dest,
    IN      PCWSTR Source
    )
{
    *Dest++ = *Source;
    return Dest;
}

// trims off last character and returns a pointer to the end of string;
// returns NULL pointer if last character was not found
PSTR
SzTrimLastCharA (
    IN OUT  PSTR String,
    IN      MBCHAR LogChar
    );

PWSTR
SzTrimLastCharW (
    IN OUT  PWSTR String,
    IN      WCHAR LogChar
    );

// Removes a trailing backslash, if it exists
#define SzRemoveWackAtEndA(str)  SzTrimLastCharA(str,'\\')
#define SzRemoveWackAtEndW(str)  SzTrimLastCharW(str,L'\\')

// always appends a wack
PSTR
SzAppendWackA (
    IN OUT  PSTR String
    );

PWSTR
SzAppendWackW (
    IN OUT  PWSTR String
    );

PCSTR
SzConcatenatePathsA (
    IN OUT  PSTR PathBuffer,
    IN      PCSTR PathSuffix,      OPTIONAL
    IN      UINT BufferTchars
    );

PCWSTR
SzConcatenatePathsW (
    IN OUT  PWSTR PathBuffer,
    IN      PCWSTR PathSuffix,      OPTIONAL
    IN      UINT BufferTchars
    );

//
// File strings
//

// Routine to extract the file from a path, never returns NULL
PCSTR
SzGetFileNameFromPathA (
    IN      PCSTR Path
    );

PCWSTR
SzGetFileNameFromPathW (
    IN      PCWSTR Path
    );

//
// SzGetFileExtensionFromPath extracts the file extension from a path, returns
// NULL if no extension exists
//

PCSTR
SzGetFileExtensionFromPathA (
    IN      PCSTR Path
    );

PCWSTR
SzGetFileExtensionFromPathW (
    IN      PCWSTR Path
    );

//
// Routine to extract the file extension from a path, including the dot, or the
// end of the string if no extension exists
//

PCSTR
SzGetDotExtensionFromPathA (
    IN      PCSTR Path
    );

PCWSTR
SzGetDotExtensionFromPathW (
    IN      PCWSTR Path
    );

__inline
PCSTR
SzFindLastWackA (
    IN      PCSTR Str
    )
{
    return (PSTR) _mbsrchr ((const unsigned char *) Str, '\\');
}

__inline
PCWSTR
SzFindLastWackW (
    IN      PCWSTR Str
    )
{
    return wcsrchr (Str, L'\\');
}


// Returns a pointer to the next non-space character (uses isspace)
PCSTR
SzSkipSpaceA (
    IN      PCSTR String
    );

PCWSTR
SzSkipSpaceW (
    IN      PCWSTR String
    );

// Returns a pointer to the first space character at the end of a string,
// or a pointer to the terminating nul if no space exists at the end of the
// string.  (Used for trimming space.)
PCSTR
SzSkipSpaceRA (
    IN      PCSTR BaseString,
    IN      PCSTR String        OPTIONAL    // can be any char along BaseString
    );

PCWSTR
SzSkipSpaceRW (
    IN      PCWSTR BaseString,
    IN      PCWSTR String       OPTIONAL    // can be any char along BaseString
    );

// Truncates a string after the last non-whitepace character & returns the end
PSTR
SzTruncateTrailingSpaceA (
    IN OUT  PSTR String
    );

PWSTR
SzTruncateTrailingSpaceW (
    IN OUT  PWSTR String
    );

// Character counters
UINT
SzCountInstancesOfLcharA (
    IN      PCSTR String,
    IN      MBCHAR LogChar
    );

UINT
SzCountInstancesOfLcharW (
    IN      PCWSTR String,
    IN      WCHAR LogChar
    );

UINT
SzICountInstancesOfLcharA (
    IN      PCSTR String,
    IN      MBCHAR LogChar
    );

UINT
SzICountInstancesOfLcharW (
    IN      PCWSTR String,
    IN      WCHAR LogChar
    );

//
// Sub String Replacement functions.
//
BOOL
SzReplaceA (
    IN OUT  PSTR Buffer,
    IN      SIZE_T MaxSize,
    IN      PSTR ReplaceStartPos,
    IN      PSTR ReplaceEndPos,
    IN      PCSTR NewString
    );

BOOL
SzReplaceW (
    IN OUT  PWSTR Buffer,
    IN      SIZE_T MaxSize,
    IN      PWSTR ReplaceStartPos,
    IN      PWSTR ReplaceEndPos,
    IN      PCWSTR NewString
    );

UINT
SzCountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
SzCountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

UINT
SzICountInstancesOfSubStringA (
    IN      PCSTR SourceString,
    IN      PCSTR SearchString
    );

UINT
SzICountInstancesOfSubStringW (
    IN      PCWSTR SourceString,
    IN      PCWSTR SearchString
    );

typedef struct {
    PCSTR Buffer;
    PCSTR CurrentString;
} MULTISZ_ENUMA, *PMULTISZ_ENUMA;

typedef struct {
    PCWSTR Buffer;
    PCWSTR CurrentString;
} MULTISZ_ENUMW, *PMULTISZ_ENUMW;

BOOL
MszEnumNextA (
    IN OUT  PMULTISZ_ENUMA MultiSzEnum
    );

BOOL
MszEnumNextW (
    IN OUT  PMULTISZ_ENUMW MultiSzEnum
    );

BOOL
MszEnumFirstA (
    OUT     PMULTISZ_ENUMA MultiSzEnum,
    IN      PCSTR MultiSzStr
    );

BOOL
MszEnumFirstW (
    OUT     PMULTISZ_ENUMW MultiSzEnum,
    IN      PCWSTR MultiSzStr
    );

PCSTR
MszFindStringA (
    IN      PCSTR MultiSz,
    IN      PCSTR String
    );

PCWSTR
MszFindStringW (
    IN      PCWSTR MultiSz,
    IN      PCWSTR String
    );

PCSTR
MszIFindStringA (
    IN      PCSTR MultiSz,
    IN      PCSTR String
    );

PCWSTR
MszIFindStringW (
    IN      PCWSTR MultiSz,
    IN      PCWSTR String
    );

//
// TCHAR mappings
//

#ifdef UNICODE

// units of logical characters
#define SzLcharCount                                SzLcharCountW
#define SzLcharCountAB                              SzLcharCountABW

#define SzLcharsToPointer                           SzLcharsToPointerW
#define SzLcharsInByteRange                         SzLcharsInByteRangeW
#define SzLcharsToBytes                             SzLcharsToBytesW
#define SzLcharsToTchars                            SzLcharsToTcharsW

// units of bytes
#define SzByteCount                                 SzByteCountW
#define SzByteCountAB                               SzByteCountABW
#define SzSize                                      SzSizeW

#define SzBytesToPointer                            SzBytesToPointerW
#define SzBytesToLchars                             SzBytesToLcharsW
#define SzBytesToTchars                             SzBytesToTcharsW

// units of TCHARs
#define SzTcharCount                                SzTcharCountW
#define SzTcharCountAB                              SzTcharCountABW

#define SzTcharsToPointer                           SzTcharsToPointerW
#define SzTcharsToLchars                            SzTcharsToLcharsW
#define SzTcharsToBytes                             SzTcharsToBytesW

// multi-sz
#define MszSize                                     MszSizeW
#define MszTcharCount                               MszTcharCountW

#define MULTISZ_ENUM                                MULTISZ_ENUMW
#define MszEnumFirst                                MszEnumFirstW
#define MszEnumNext                                 MszEnumNextW
#define MszFindString                               MszFindStringW
#define MszIFindString                              MszIFindStringW

// copy routines
#define SzBufferCopy                                SzBufferCopyW
#define SzCopy                                      SzCopyW
#define SzCopyBytes                                 SzCopyBytesW
#define SzCopyLchars                                SzCopyLcharsW
#define SzCopyTchars                                SzCopyTcharsW
#define SzCopyAB                                    SzCopyABW
#define SzCat                                       SzCatW

// compare routines
#define SzCompare                                   SzCompareW
#define SzMatch                                     SzMatchW
#define SzICompare                                  SzICompareW
#define SzIMatch                                    SzIMatchW
#define SzCompareBytes                              SzCompareBytesW
#define SzMatchBytes                                SzMatchBytesW
#define SzICompareBytes                             SzICompareBytesW
#define SzIMatchBytes                               SzIMatchBytesW
#define SzCompareLchars                             SzCompareLcharsW
#define SzMatchLchars                               SzMatchLcharsW
#define SzICompareLchars                            SzICompareLcharsW
#define SzIMatchLchars                              SzIMatchLcharsW
#define SzCompareTchars                             SzCompareTcharsW
#define SzMatchTchars                               SzMatchTcharsW
#define SzICompareTchars                            SzICompareTcharsW
#define SzIMatchTchars                              SzIMatchTcharsW
#define SzCompareAB                                 SzCompareABW
#define SzMatchAB                                   SzMatchABW
#define SzICompareAB                                SzICompareABW
#define SzIMatchAB                                  SzIMatchABW
#define SzPrefix                                    SzPrefixW
#define SzIPrefix                                   SzIPrefixW

// char copy routines
#define SzCopyNextChar                              SzCopyNextCharW
#define SzReplaceChar                               SzReplaceCharW
#define SzTrimLastChar                              SzTrimLastCharW

// search routines
#define SzGetEnd                                    SzGetEndW
#define SzFindPrevChar                              SzFindPrevCharW
#define SzIsPrint                                   SzIsPrintW
#define SzFindSubString                             SzFindSubStringW
#define SzIFindSubString                            SzIFindSubStringW
#define SzSkipSpace                                 SzSkipSpaceW
#define SzSkipSpaceR                                SzSkipSpaceRW
#define SzCountInstancesOfLchar                     SzCountInstancesOfLcharW
#define SzICountInstancesOfLchar                    SzICountInstancesOfLcharW
#define SzCountInstancesOfSubString                 SzCountInstancesOfSubStringW
#define SzICountInstancesOfSubString                SzICountInstancesOfSubStringW

// search-replace routines
#define SzTruncateTrailingSpace                     SzTruncateTrailingSpaceW
#define SzReplace                                   SzReplaceW

// numeric conversion
#define SzToNumber                                  SzToNumberW
#define SzToULongLong                               SzToULongLongW
#define SzToLongLong                                SzToLongLongW
#define SzUnsignedToHex                             SzUnsignedToHexW
#define SzUnsignedToDec                             SzUnsignedToDecW
#define SzSignedToDec                               SzSignedToDecW

// path routines
#define SzAppendWack                                SzAppendWackW
#define SzConcatenatePaths                          SzConcatenatePathsW
#define SzAppendDosWack                             SzAppendDosWackW
#define SzAppendUncWack                             SzAppendUncWackW
#define SzAppendPathWack                            SzAppendPathWackW
#define SzRemoveWackAtEnd                           SzRemoveWackAtEndW
#define SzGetFileNameFromPath                       SzGetFileNameFromPathW
#define SzGetFileExtensionFromPath                  SzGetFileExtensionFromPathW
#define SzGetDotExtensionFromPath                   SzGetDotExtensionFromPathW
#define SzFindLastWack                              SzFindLastWackW



#else


// units of logical characters
#define SzLcharCount                                SzLcharCountA
#define SzLcharCountAB                              SzLcharCountABA

#define SzLcharsToPointer                           SzLcharsToPointerA
#define SzLcharsInByteRange                         SzLcharsInByteRangeA
#define SzLcharsToBytes                             SzLcharsToBytesA
#define SzLcharsToTchars                            SzLcharsToTcharsA

// units of bytes
#define SzByteCount                                 SzByteCountA
#define SzByteCountAB                               SzByteCountABA
#define SzSize                                      SzSizeA

#define SzBytesToPointer                            SzBytesToPointerA
#define SzBytesToLchars                             SzBytesToLcharsA
#define SzBytesToTchars                             SzBytesToTcharsA

// units of TCHARs
#define SzTcharCount                                SzTcharCountA
#define SzTcharCountAB                              SzTcharCountABA

#define SzTcharsToPointer                           SzTcharsToPointerA
#define SzTcharsToLchars                            SzTcharsToLcharsA
#define SzTcharsToBytes                             SzTcharsToBytesA

// multi-sz
#define MszSize                                     MszSizeA
#define MszTcharCount                               MszTcharCountA

#define MULTISZ_ENUM                                MULTISZ_ENUMA
#define MszEnumFirst                                MszEnumFirstA
#define MszEnumNext                                 MszEnumNextA
#define MszFindString                               MszFindStringA
#define MszIFindString                              MszIFindStringA

// copy routines
#define SzBufferCopy                                SzBufferCopyA
#define SzCopy                                      SzCopyA
#define SzCopyBytes                                 SzCopyBytesA
#define SzCopyLchars                                SzCopyLcharsA
#define SzCopyTchars                                SzCopyTcharsA
#define SzCopyAB                                    SzCopyABA
#define SzCat                                       SzCatA

// compare routines
#define SzCompare                                   SzCompareA
#define SzMatch                                     SzMatchA
#define SzICompare                                  SzICompareA
#define SzIMatch                                    SzIMatchA
#define SzCompareBytes                              SzCompareBytesA
#define SzMatchBytes                                SzMatchBytesA
#define SzICompareBytes                             SzICompareBytesA
#define SzIMatchBytes                               SzIMatchBytesA
#define SzCompareLchars                             SzCompareLcharsA
#define SzMatchLchars                               SzMatchLcharsA
#define SzICompareLchars                            SzICompareLcharsA
#define SzIMatchLchars                              SzIMatchLcharsA
#define SzCompareTchars                             SzCompareTcharsA
#define SzMatchTchars                               SzMatchTcharsA
#define SzICompareTchars                            SzICompareTcharsA
#define SzIMatchTchars                              SzIMatchTcharsA
#define SzCompareAB                                 SzCompareABA
#define SzMatchAB                                   SzMatchABA
#define SzICompareAB                                SzICompareABA
#define SzIMatchAB                                  SzIMatchABA
#define SzPrefix                                    SzPrefixA
#define SzIPrefix                                   SzIPrefixA

// char copy routines
#define SzCopyNextChar                              SzCopyNextCharA
#define SzReplaceChar                               SzReplaceCharA
#define SzTrimLastChar                              SzTrimLastCharA

// search routines
#define SzGetEnd                                    SzGetEndA
#define SzFindPrevChar                              SzFindPrevCharA
#define SzIsPrint                                   SzIsPrintA
#define SzFindSubString                             SzFindSubStringA
#define SzIFindSubString                            SzIFindSubStringA
#define SzSkipSpace                                 SzSkipSpaceA
#define SzSkipSpaceR                                SzSkipSpaceRA
#define SzCountInstancesOfLchar                     SzCountInstancesOfLcharA
#define SzICountInstancesOfLchar                    SzICountInstancesOfLcharA
#define SzCountInstancesOfSubString                 SzCountInstancesOfSubStringA
#define SzICountInstancesOfSubString                SzICountInstancesOfSubStringA

// search-replace routines
#define SzTruncateTrailingSpace                     SzTruncateTrailingSpaceA
#define SzReplace                                   SzReplaceA

// numeric conversion
#define SzToNumber                                  SzToNumberA
#define SzToULongLong                               SzToULongLongA
#define SzToLongLong                                SzToLongLongA
#define SzUnsignedToHex                             SzUnsignedToHexA
#define SzUnsignedToDec                             SzUnsignedToDecA
#define SzSignedToDec                               SzSignedToDecA

// path routines
#define SzAppendWack                                SzAppendWackA
#define SzConcatenatePaths                          SzConcatenatePathsA
#define SzAppendDosWack                             SzAppendDosWackA
#define SzAppendUncWack                             SzAppendUncWackA
#define SzAppendPathWack                            SzAppendPathWackA
#define SzRemoveWackAtEnd                           SzRemoveWackAtEndA
#define SzGetFileNameFromPath                       SzGetFileNameFromPathA
#define SzGetFileExtensionFromPath                  SzGetFileExtensionFromPathA
#define SzGetDotExtensionFromPath                   SzGetDotExtensionFromPathA
#define SzFindLastWack                              SzFindLastWackA


#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\top.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Pre-define init and terminate constants to empty strings
//

//#define INITIALIZE_MEMORY_CODE
//#define INITIALIZE_LOG_CODE
#define INITIALIZE_DBGTRACK_CODE
#define INITIALIZE_UNICODE_CODE
#define INITIALIZE_STRMEM_CODE
#define INITIALIZE_STRMAP_CODE
#define INITIALIZE_HASH_CODE
#define INITIALIZE_GROWBUF_CODE
#define INITIALIZE_GROWLIST_CODE
#define INITIALIZE_XML_CODE

#define TERMINATE_MEMORY_CODE
//#define TERMINATE_LOG_CODE
#define TERMINATE_DBGTRACK_CODE
#define TERMINATE_UNICODE_CODE
#define TERMINATE_STRMEM_CODE
#define TERMINATE_STRMAP_CODE
#define TERMINATE_HASH_CODE
#define TERMINATE_GROWBUF_CODE
#define TERMINATE_GROWLIST_CODE
#define TERMINATE_XML_CODE

//
// The following are required headers for anyone who uses the setup runtime.
//
// PLEASE TRY TO KEEP THIS LIST TO A MINIMUM.
//

#include "types.h"
#include "dbgtrack.h"
#include "memory.h"
#include "setuplog.h"
#include "strings.h"
#include "strmem.h"
#include "unicode.h"

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\strmem.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    strmem.h

Abstract:

    The header file for allocation-based string routines

Author:

    Jim Schmidt (jimschm) 25-Jun-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once
#include "growbuf.h"

//
// Function Prototypes
//

#define SzAllocBytesA(bytes_incl_nul)   ((PSTR) MemFastAlloc(bytes_incl_nul))
#define SzAllocA(logchars_incl_nul)     SzAllocBytesA((logchars_incl_nul) * 3)

#define SzAllocBytesW(bytes_incl_nul)   ((PWSTR) MemFastAlloc(bytes_incl_nul))
#define SzAllocW(logchars_incl_nul)     SzAllocBytesW((logchars_incl_nul) * 2)

__inline
PSTR
RealSzDuplicateA (
    IN      PCSTR String
    )
{
    UINT bytes;
    PSTR result;

    bytes = SzSizeA (String);
    result = (PSTR) MemFastAllocNeverFail (bytes);
    CopyMemory (result, String, bytes);

    return result;
}

__inline
PWSTR
RealSzDuplicateW (
    IN      PCWSTR String
    )
{
    UINT bytes;
    PWSTR result;

    bytes = SzSizeW (String);
    result = (PWSTR) MemFastAllocNeverFail (bytes);
    CopyMemory (result, String, bytes);

    return result;
}

__inline
PSTR
RealSzDuplicateExA (
    IN      PCSTR String,
    OUT     PUINT SizeOfString
    )
{
    PSTR result;

    *SizeOfString = SzSizeA (String);
    result = (PSTR) MemFastAllocNeverFail (*SizeOfString);
    CopyMemory (result, String, *SizeOfString);

    return result;
}

__inline
PWSTR
RealSzDuplicateExW (
    IN      PCWSTR String,
    OUT     PUINT SizeOfString
    )
{
    PWSTR result;

    *SizeOfString = SzSizeW (String);
    result = (PWSTR) MemFastAllocNeverFail (*SizeOfString);
    CopyMemory (result, String, *SizeOfString);

    return result;
}

#ifdef DEBUG

//
// Wrap duplicates for leak detection in checked build
//

#define SzDuplicateA(str)               DBGTRACK(PSTR,SzDuplicateA,(str))
#define SzDuplicateW(str)               DBGTRACK(PWSTR,SzDuplicateW,(str))
#define SzDuplicateExA(str,outsize)     DBGTRACK(PSTR,SzDuplicateExA,(str,outsize))
#define SzDuplicateExW(str,outsize)     DBGTRACK(PWSTR,SzDuplicateExW,(str,outsize))

#else

//
// No wrapping
//

#define SzDuplicateA        RealSzDuplicateA
#define SzDuplicateW        RealSzDuplicateW
#define SzDuplicateExA      RealSzDuplicateExA
#define SzDuplicateExW      RealSzDuplicateExW

#endif


#define SzFreeA(string)     MemFastFree(string)
#define SzFreeW(string)     MemFastFree(string)

PSTR
RealSzJoinPathsA (
    IN      PCSTR BasePath,
    IN      PCSTR ChildPath     OPTIONAL
    );

PWSTR
RealSzJoinPathsW (
    IN      PCWSTR BasePath,
    IN      PCWSTR ChildPath    OPTIONAL
    );

#define SzJoinPathsA(p1,p2)             DBGTRACK(PSTR,SzJoinPathsA,(p1,p2))
#define SzJoinPathsW(p1,p2)             DBGTRACK(PWSTR,SzJoinPathsW,(p1,p2))

PCSTR
SzJoinPathsExA (
    IN OUT  PGROWBUFFER Buffer,
    IN      ...
    );

PCWSTR
SzJoinPathsExW (
    IN OUT  PGROWBUFFER Buffer,
    IN      ...
    );


//
// A & W Macros
//

#ifdef UNICODE

#define SzAlloc             SzAllocW
#define SzAllocBytes        SzAllocBytesA
#define SzDuplicate         SzDuplicateW
#define SzFree              SzFreeW
#define SzJoinPaths         SzJoinPathsW
#define SzJoinPathsEx       SzJoinPathsExW

#else

#define SzAlloc             SzAllocA
#define SzAllocBytes        SzAllocBytesA
#define SzDuplicate         SzDuplicateA
#define SzFree              SzFreeA
#define SzJoinPaths         SzJoinPathsA
#define SzJoinPathsEx       SzJoinPathsExA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\types.h ===
#ifndef RC_INVOKED

#pragma once

#ifdef _cplusplus
extern "C" {
#endif


//
// This header derives types and defines from existing settings
//

//
// If either DBG or DEBUG defined, use debug mode
//

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif

#endif

#ifdef DEBUG

#ifndef DBG
#define DBG
#endif

#endif

//
// If _UNICODE defined, use unicode mode
//

#ifdef _UNICODE

#ifndef UNICODE
#define UNICODE
#endif

#endif

//
// Misc macros
//

#define ZEROED
#define INVALID_ATTRIBUTES  0xFFFFFFFF
#define SIZEOF(x)           ((UINT)sizeof(x))
#define SHIFTRIGHT8(l)      (/*lint --e(506)*/sizeof(l)<=1?0:l>>8)
#define SHIFTRIGHT16(l)     (/*lint --e(506)*/sizeof(l)<=2?0:l>>16)
#define SHIFTRIGHT32(l)     (/*lint --e(506)*/sizeof(l)<=4?0:l>>32)


#ifdef DEBUG

// Use INVALID_POINTER after you free memory or a handle
#define INVALID_POINTER(x)      (PVOID)(x)=(PVOID)(1)

#else

#define INVALID_POINTER(x)

#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

#ifndef EXPORT
#define EXPORT  __declspec(dllexport)
#endif

//
// Missing types
//

typedef const void * PCVOID;
typedef const unsigned char *PCBYTE;
typedef int MBCHAR;



#ifdef _cplusplus
}
#endif

#endif // ifndef RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\strmap.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    strmap.h

Abstract:

    Strmap (formally pathmap) is a fast hueristic-based program that
    searches strings and attempts to replace substrings when there
    are matching substrings in the mapping database.

Author:

    Marc R. Whitten (marcw) 20-Mar-1997

Revision History:

    Jim Schmidt (jimschm) 08-May-2000       Rewrote mapping, added Flags & ex nodes
    Calin Negreanu (calinn) 02-Mar-2000     Ported from win9xupg project

--*/

#pragma once

//
// Constants
//

#define SZMAP_COMPLETE_MATCH_ONLY                   0x0001
#define SZMAP_FIRST_CHAR_MUST_MATCH                 0x0002
#define SZMAP_RETURN_AFTER_FIRST_REPLACE            0x0004
#define SZMAP_REQUIRE_WACK_OR_NUL                   0x0008

//
// Types
//

typedef struct {
    BOOL UnicodeData;

    //
    // The filter can replace NewSubString.  (The filter must also
    // set NewSubStringSizeInBytes when replacing NewSubString.)
    //

    union {
        struct {
            PCWSTR OriginalString;
            PCWSTR BeginningOfMatch;
            PCWSTR CurrentString;
            PCWSTR OldSubString;
            PCWSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Unicode;

        struct {
            PCSTR OriginalString;
            PCSTR BeginningOfMatch;
            PCSTR CurrentString;
            PCSTR OldSubString;
            PCSTR NewSubString;
            INT NewSubStringSizeInBytes;
        } Ansi;
    };
} STRINGMAP_FILTER_DATA, *PSTRINGMAP_FILTER_DATA;

typedef BOOL(STRINGMAP_FILTER_PROTOTYPE)(PSTRINGMAP_FILTER_DATA Data);
typedef STRINGMAP_FILTER_PROTOTYPE * STRINGMAP_FILTER;

typedef struct TAG_CHARNODE {
    WORD Char;
    WORD Flags;
    PVOID OriginalStr;
    PVOID ReplacementStr;
    INT ReplacementBytes;

    struct TAG_CHARNODE *NextLevel;
    struct TAG_CHARNODE *NextPeer;

} CHARNODE, *PCHARNODE;

typedef struct {
    CHARNODE Node;
    STRINGMAP_FILTER Filter;
    ULONG_PTR ExtraData;
} CHARNODEEX, *PCHARNODEEX;



typedef struct {
    PCHARNODE FirstLevelRoot;
    BOOL UsesExNode;
    BOOL UsesFilter;
    BOOL UsesExtraData;
    PVOID CleanUpChain;
} STRINGMAP, *PSTRINGMAP;

//
// Function Prototypes
//

PSTRINGMAP
SzMapCreateEx (
    IN      BOOL UsesFilter,
    IN      BOOL UsesExtraData
    );

#define SzMapCreate()   SzMapCreateEx(FALSE,FALSE)

VOID
SzMapDestroy (
    IN      PSTRINGMAP Map
    );

VOID
SzMapAddExA (
    IN OUT  PSTRINGMAP Map,
    IN      PCSTR Old,
    IN      PCSTR New,
    IN      STRINGMAP_FILTER Filter,            OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define SzMapAddA(Map,Old,New) SzMapAddExA(Map,Old,New,NULL,0,0)

VOID
SzMapAddExW (
    IN OUT  PSTRINGMAP Map,
    IN      PCWSTR Old,
    IN      PCWSTR New,
    IN      STRINGMAP_FILTER Filter,            OPTIONAL
    IN      ULONG_PTR ExtraData,            OPTIONAL
    IN      DWORD Flags
    );

#define SzMapAddW(Map,Old,New) SzMapAddExW(Map,Old,New,NULL,0,0)

BOOL
SzMapSearchAndReplaceExA (
    IN      PSTRINGMAP Map,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define SzMapSearchAndReplaceA(map,buffer,maxbytes)   SzMapSearchAndReplaceExA(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
SzMapSearchAndReplaceExW (
    IN      PSTRINGMAP Map,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define SzMapSearchAndReplaceW(map,buffer,maxbytes)   SzMapSearchAndReplaceExW(map,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
SzMapMultiTableSearchAndReplaceExA (
    IN      PSTRINGMAP *MapArray,
    IN      UINT MapArrayCount,
    IN      PCSTR SrcBuffer,
    OUT     PSTR Buffer,                    // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytesPtr,          OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCSTR *EndOfString              OPTIONAL
    );

#define SzMapMultiTableSearchAndReplaceA(array,count,buffer,maxbytes)   \
        SzMapMultiTableSearchAndReplaceExA(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

BOOL
SzMapMultiTableSearchAndReplaceExW (
    IN      PSTRINGMAP *MapArray,
    IN      UINT MapArrayCount,
    IN      PCWSTR SrcBuffer,
    OUT     PWSTR Buffer,                   // can be the same as SrcBuffer
    IN      INT InboundBytes,               OPTIONAL
    OUT     PINT OutboundBytes,             OPTIONAL
    IN      INT MaxSizeInBytes,
    IN      DWORD Flags,
    OUT     ULONG_PTR *ExtraDataValue,      OPTIONAL
    OUT     PCWSTR *EndOfString             OPTIONAL
    );

#define SzMapMultiTableSearchAndReplaceW(array,count,buffer,maxbytes)   \
        SzMapMultiTableSearchAndReplaceExW(array,count,buffer,buffer,0,NULL,maxbytes,0,NULL,NULL)

//
// A & W Macros
//

#ifdef UNICODE

#define SzMapAddEx                              SzMapAddExW
#define SzMapAdd                                SzMapAddW
#define SzMapSearchAndReplaceEx                 SzMapSearchAndReplaceExW
#define SzMapSearchAndReplace                   SzMapSearchAndReplaceW
#define SzMapMultiTableSearchAndReplaceEx       SzMapMultiTableSearchAndReplaceExW
#define SzMapMultiTableSearchAndReplace         SzMapMultiTableSearchAndReplaceW

#else

#define SzMapAddEx                              SzMapAddExA
#define SzMapAdd                                SzMapAddA
#define SzMapSearchAndReplaceEx                 SzMapSearchAndReplaceExA
#define SzMapSearchAndReplace                   SzMapSearchAndReplaceA
#define SzMapMultiTableSearchAndReplaceEx       SzMapMultiTableSearchAndReplaceExA
#define SzMapMultiTableSearchAndReplace         SzMapMultiTableSearchAndReplaceA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\unicode.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    unicode.h

Abstract:

    Declares the interfaces for unicode/ansi conversion.

    See macros at the end of this file for details! (Search for ***)

Author:

    Jim Schmidt (jimschm)   02-Sep-1997

Revision History:

    jimschm 16-Mar-2000     PTSTR<->PCSTR/PCWSTR routines
    jimschm 15-Feb-1999     Eliminated AnsiFromUnicode and UnicodeFromAnsi
    calinn  07-Jul-1998     SetGlobalPage/GetGlobalPage
    mikeco  03-Nov-1997     AnsiFromUnicode/UnicodeFromAnsi

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototoypes
//

//
//  Pre-allocated buffer conversion routines.
//  End of string is returned.
//

PWSTR
SzConvertBufferBytesAToW (
    OUT     PWSTR OutputBuffer,
    IN      PCSTR InputString,
    IN      UINT ByteCountInclNul
    );

#define SzConvertBufferAToW(out,in)         SzConvertBufferBytesAToW(out,in,SzSizeA(in))

PSTR
SzConvertBufferBytesWToA (
    OUT     PSTR OutputBuffer,
    IN      PCWSTR InputString,
    IN      UINT ByteCountInclNul
    );

#define SzConvertBufferWToA(out,in)         SzConvertBufferBytesWToA(out,in,SzSizeW(in))


//
// Duplicate & convert routines
//
//  SzConvertAToW(ansi) returns unicode
//  SzConvertWToA(unicode) returns ansi
//

PWSTR
RealSzConvertBytesAToW (
    IN      PCSTR AnsiString,
    IN      UINT ByteCountInclNul
    );

#define SzConvertBytesAToW(ansi,bytes)      DBGTRACK(PWSTR, SzConvertBytesAToW, (ansi,bytes))
#define SzConvertAToW(ansi)                 SzConvertBytesAToW(ansi,SzSizeA(ansi))

PSTR
RealSzConvertBytesWToA (
    IN      PCWSTR UnicodeString,
    IN      UINT ByteCountInclNul
    );

#define SzConvertBytesWToA(unicode,bytes)   DBGTRACK(PSTR, SzConvertBytesWToA, (unicode,bytes))
#define SzConvertWToA(unicode)              SzConvertBytesWToA(unicode,SzSizeW(unicode))


//
// Routines to convert to & from TCHAR
//

#ifdef UNICODE

#define SzConvertToTstrA(ansi)              SzConvertAToW(ansi)
#define SzConvertToTstrW(unicode)           (unicode)
#define SzConvertFromTstrA(tstr)            SzConvertWToA(tstr)
#define SzConvertFromTstrW(tstr)            (tstr)

#else

#define SzConvertToTstrA(ansi)              (ansi)
#define SzConvertToTstrW(unicode)           SzConvertWToA(unicode)
#define SzConvertFromTstrA(tstr)            (tstr)
#define SzConvertFromTstrW(tstr)            SzConvertAToW(tstr)

#endif

#define SzFreeTstrConversion(original,converted)    ((converted) && ((PBYTE) (converted) != (PBYTE) (original)) ? FAST_FREE(converted) : 1)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\inc\xml.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xml.h

Abstract:

    Declares the interfaces for the COM XML interface wrapper library.

Author:

    Jim Schmidt (jimschm) 31-Jan-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include <oleauto.h>

typedef struct { BOOL Dummy; } * PXMLDOC;

typedef enum {
    XMLNODE_PREFIX          = 0x0001,   // XML syntax is <prefix:basename>
    XMLNODE_BASENAME        = 0x0002,

    XMLNODE_TEXT            = 0x0004,   // all text contained in the node's subtree

    XMLNODE_NAMESPACE_URI   = 0x0008,   // xmlns:nnn=namespace_uri such as
                                        //      "urn:schemas-microsoft-com:xml-data"

    XMLNODE_TYPESTRING      = 0x0010,   // the node type, in a string format

    XMLNODE_VALUE           = 0x0020    // depending on node type, returns attribute value,
                                        //      comments, CDATA, processing instruction or text
} XMLNODE_MEMBERS;

#define XMLNODE_ALL 0xFFFF

typedef struct {

    PCSTR Prefix;
    PCSTR BaseName;
    PCSTR Text;
    PCSTR NamespaceUri;
    PCSTR TypeString;
    VARIANT Value;
    PCSTR ValueString;      // filled when Value is filled

} XMLNODEA, *PXMLNODEA;

typedef struct {

    PCWSTR Prefix;
    PCWSTR BaseName;
    PCWSTR Text;
    PCWSTR NamespaceUri;
    PCWSTR TypeString;
    VARIANT Value;
    PCWSTR ValueString;     // filled when Value is filled

} XMLNODEW, *PXMLNODEW;

//
// This enum is used to filter nodes by screening IXMLDOMNodeType.
// IXMLDOMNodeType is a constant from 1 to 12, but we want a bitmap.
//

typedef enum {
    XMLFILTER_ELEMENTS                      = 0x00000001,
    XMLFILTER_ATTRIBUTES                    = 0x00000002,
    XMLFILTER_TEXT                          = 0x00000004,
    XMLFILTER_CDATA                         = 0x00000008,
    XMLFILTER_ENTITY_REFERENCE              = 0x00000010,
    XMLFILTER_ENTITY                        = 0x00000020,
    XMLFILTER_NODE_PROCESSING_INSTRUCTION   = 0x00000040,
    XMLFILTER_COMMENT                       = 0x00000080,
    XMLFILTER_DOCUMENT                      = 0x00000100,
    XMLFILTER_DOCUMENT_TYPE                 = 0x00000200,
    XMLFILTER_DOCUMENT_FRAGMENT             = 0x00000400,
    XMLFILTER_NODE_NOTATION                 = 0x00000800,
    XMLFILTER_PARENT_ATTRIBUTES             = 0x10000000,
    XMLFILTER_NO_ELEMENT_SUBENUM            = 0x20000000
} XMLFILTERFLAGS;

#define XMLFILTER_ALL                   ((XMLFILTERFLAGS) 0xffff)
#define XMLFILTER_ELEMENT_ATTRIBUTES    ((XMLFILTERFLAGS) (XMLFILTER_ATTRIBUTES|XMLFILTER_PARENT_ATTRIBUTES|XMLFILTER_NO_ELEMENT_SUBENUM))

//
// Define a constant that indicates what the max # is for NODE_* flags
// from the DOM. It is assumed that NODE_* constants are ordered from
// 1 to 12, and since we have a bitmap, we convert the constants with
// 2 ^ (constant - 1). Constants > NUMBER_OF_FLAGS are ignored.
//

#define NUMBER_OF_FLAGS                     12

typedef struct {
    // output of enum
    PXMLNODEA CurrentNode;

    // internal use only
    PVOID Reserved;
} XMLNODE_ENUMA, *PXMLNODE_ENUMA;

typedef struct {
    // output of enum
    PXMLNODEW CurrentNode;

    // internal use only
    PVOID Reserved;
} XMLNODE_ENUMW, *PXMLNODE_ENUMW;

//
// Library routines
//

BOOL
XmlInitialize (
    VOID
    );

#undef INITIALIZE_XML_CODE
#define INITIALIZE_XML_CODE  if (!XmlInitialize()) { __leave; }

VOID
XmlTerminate (
    VOID
    );

#undef TERMINATE_XML_CODE
#define TERMINATE_XML_CODE  XmlTerminate();

//
// XML file routines
//

PXMLDOC
XmlOpenFileA (
    IN      PCSTR XmlFileName,
    IN      PCSTR SchemaFileName        OPTIONAL
    );

PXMLDOC
XmlOpenFileW (
    IN      PCWSTR XmlFileName,
    IN      PCWSTR SchemaFileName       OPTIONAL
    );


VOID
XmlCloseFile (
    IN OUT  PXMLDOC *XmlDoc
    );

//
// Node manipulation
//

BOOL
XmlFillNodeA (
    IN OUT  PXMLNODEA XmlNode,
    IN      XMLNODE_MEMBERS Flags
    );

BOOL
XmlFillNodeW (
    IN OUT  PXMLNODEW XmlNode,
    IN      XMLNODE_MEMBERS Flags
    );

PXMLNODEA
XmlDuplicateNodeA (
    IN      PXMLNODEA XmlNode
    );

PXMLNODEW
XmlDuplicateNodeW (
    IN      PXMLNODEW XmlNode
    );

VOID
XmlFreeNodeA (
    IN      PXMLNODEA XmlNode
    );

VOID
XmlFreeNodeW (
    IN      PXMLNODEW XmlNode
    );

//
// XML document enumeration
//

BOOL
XmlEnumFirstNodeA (
    OUT     PXMLNODE_ENUMA EnumPtr,
    IN      PXMLDOC XmlDocPtr,              OPTIONAL
    IN      PXMLNODEA Parent,               OPTIONAL
    IN      XMLFILTERFLAGS FilterFlags
    );

BOOL
XmlEnumFirstNodeW (
    OUT     PXMLNODE_ENUMW EnumPtr,
    IN      PXMLDOC XmlDocPtr,              OPTIONAL
    IN      PXMLNODEW Parent,               OPTIONAL
    IN      XMLFILTERFLAGS FilterFlags
    );

BOOL
XmlEnumNextNodeA (
    IN OUT  PXMLNODE_ENUMA EnumPtr
    );

BOOL
XmlEnumNextNodeW (
    IN OUT  PXMLNODE_ENUMW EnumPtr
    );

VOID
XmlAbortNodeEnumA (
    IN      PXMLNODE_ENUMA EnumPtr           ZEROED
    );

VOID
XmlAbortNodeEnumW (
    IN      PXMLNODE_ENUMW EnumPtr           ZEROED
    );

PXMLNODEA
XmlGetSchemaDefinitionNodeA (
    IN      PXMLNODEA Node
    );

PXMLNODEW
XmlGetSchemaDefinitionNodeW (
    IN      PXMLNODEW Node
    );

PCSTR
XmlGetAttributeA (
    IN      PXMLNODEA Node,
    IN      PCSTR AttributeName
    );

PCWSTR
XmlGetAttributeW (
    IN      PXMLNODEW Node,
    IN      PCWSTR AttributeName
    );


typedef struct {
    PCSTR AttributeName;
    PCSTR ValueString;
} XMLATTRIBUTEA, *PXMLATTRIBUTEA;

typedef struct {
    PCWSTR AttributeName;
    PCWSTR ValueString;
} XMLATTRIBUTEW, *PXMLATTRIBUTEW;

INT
XmlFillAttributeListA (
    IN      PXMLNODEA ElementNode,
    IN OUT  PXMLATTRIBUTEA List,
    IN      UINT ListLength
    );

INT
XmlFillAttributeListW (
    IN      PXMLNODEW ElementNode,
    IN OUT  PXMLATTRIBUTEW List,
    IN      UINT ListLength
    );

VOID
XmlResetAttributeListA (
    IN OUT  PXMLATTRIBUTEA List,
    IN      UINT ListLength
    );

VOID
XmlResetAttributeListW (
    IN OUT  PXMLATTRIBUTEW List,
    IN      UINT ListLength
    );


#ifdef UNICODE

#define XmlOpenFile                 XmlOpenFileW
#define XmlFillNode                 XmlFillNodeW
#define XmlDuplicateNode            XmlDuplicateNodeW
#define XmlFreeNode                 XmlFreeNodeW
#define XmlEnumFirstNode            XmlEnumFirstNodeW
#define XmlEnumNextNode             XmlEnumNextNodeW
#define XmlAbortNodeEnum            XmlAbortNodeEnumW
#define XmlGetSchemaDefinitionNode  XmlGetSchemaDefinitionNodeW
#define XmlGetAttribute             XmlGetAttributeW
#define XmlFillAttributeList        XmlFillAttributeListW
#define XmlResetAttributeList       XmlResetAttributeListW

#define XMLNODE_ENUM                XMLNODE_ENUMW
#define PXMLNODE_ENUM               PXMLNODE_ENUMW
#define XMLNODE                     XMLNODEW
#define PXMLNODE                    PXMLNODEW
#define XMLATTRIBUTE                XMLATTRIBUTEW
#define PXMLATTRIBUTE               PXMLATTRIBUTEW

#else

#define XmlOpenFile                 XmlOpenFileA
#define XmlFillNode                 XmlFillNodeA
#define XmlDuplicateNode            XmlDuplicateNodeA
#define XmlFreeNode                 XmlFreeNodeA
#define XmlEnumFirstNode            XmlEnumFirstNodeA
#define XmlEnumNextNode             XmlEnumNextNodeA
#define XmlAbortNodeEnum            XmlAbortNodeEnumA
#define XmlGetSchemaDefinitionNode  XmlGetSchemaDefinitionNodeA
#define XmlGetAttribute             XmlGetAttributeA
#define XmlFillAttributeList        XmlFillAttributeListA
#define XmlResetAttributeList       XmlResetAttributeListA

#define XMLNODE_ENUM                XMLNODE_ENUMA
#define PXMLNODE_ENUM               PXMLNODE_ENUMA
#define XMLNODE                     XMLNODEA
#define PXMLNODE                    PXMLNODEA
#define XMLATTRIBUTE                XMLATTRIBUTEA
#define PXMLATTRIBUTE               PXMLATTRIBUTEA

#endif


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\functions.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Environment independed definition of system functions, 
    that should be implemented for specific enviroment.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

typedef HANDLE (*MY_OPENMUTEX)(PCWSTR pObjectName);
typedef HANDLE (*MY_CREATEMUTEX)(PCWSTR pObjectName, BOOL bInitialOwnership);
typedef VOID   (*MY_RELEASEMUTEX)(HANDLE hObject);
typedef DWORD  (*MY_WAITFORSINGLEOBJECT)(HANDLE hObject, DWORD dwTimeout);
typedef VOID   (*MY_CLOSEHANDLE)(HANDLE hObject);
typedef HANDLE (*MY_OPENSHAREDMEMORY)(PCWSTR pObjectName);
typedef HANDLE (*MY_CREATESHAREDMEMORY)(UINT uiInitialSizeOfMapView, PCWSTR pObjectName);
typedef PVOID  (*MY_MAPSHAREDMEMORY)(HANDLE hObject);
typedef BOOL   (*MY_UNMAPSHAREDMEMORY)(PVOID pSharedMemory);
typedef HANDLE (*MY_CREATESHAREDFILE)(PCWSTR pFilePath, DWORD dwShareMode, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes);
typedef BOOL   (*MY_SETFILEPOINTER)(HANDLE hObject, UINT uiOffset, DWORD dwMoveMethod);
typedef BOOL   (*MY_WRITEFILE)(HANDLE hObject, PVOID pBuffer, UINT uiNumberOfBytesToWrite, DWORD * pdwNumberOfBytesWritten);
typedef UINT   (*MY_GETPROCESSORNUMBER)();

extern MY_OPENMUTEX            g_OpenMutex;
extern MY_CREATEMUTEX          g_CreateMutex;
extern MY_RELEASEMUTEX         g_ReleaseMutex;
extern MY_WAITFORSINGLEOBJECT  g_WaitForSingleObject;
extern MY_CLOSEHANDLE          g_CloseHandle;
extern MY_OPENSHAREDMEMORY     g_OpenSharedMemory;
extern MY_CREATESHAREDMEMORY   g_CreateSharedMemory;
extern MY_MAPSHAREDMEMORY      g_MapSharedMemory;
extern MY_UNMAPSHAREDMEMORY    g_UnMapSharedMemory;
extern MY_CREATESHAREDFILE     g_CreateSharedFile;
extern MY_SETFILEPOINTER       g_SetFilePointer;
extern MY_WRITEFILE            g_WriteFile;
extern MY_GETPROCESSORNUMBER   g_GetProcessorsNumber;

BOOL InitSystemFunctions();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\mem.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    New and delete operators overriding for 
    consistence memory management.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

//#define TrackPop DbgTrackPop
//#define HINF    PVOID
//#include "top.h"
#include "malloc.h"

#define MALLOC(n)       HeapAlloc(GetProcessHeap(), 0, n)
#define FREE(x)         HeapFree(GetProcessHeap(), 0, x)
#define REALLOC(x, n)   HeapReAlloc(GetProcessHeap(), 0, x, n)

#ifdef __cplusplus

inline void *operator new[](size_t size)
{
    PVOID ptr = MALLOC(size);
    return ptr;
}
 
inline void operator delete[](void * ptr)
{
   FREE(ptr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\log_man.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Log Engine declaration.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "log.h"
#include "sysfunc.h"
#include "templ.h"
#include "mem.h"

#define HEADER_SIZE 4096 //PAGE_ALIGNED
#define SHARED_DATA_STRUCTURE_ALIGMENT 8
#define ALIGN_DATA(addr, alignment) ((addr)%(alignment)?(((addr)-((addr)%(alignment)))+(alignment)):(addr))
#define INITIAL_SIZE_OF_SHARED_SECTION  (HEADER_SIZE<<3)

#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

#pragma warning(disable:4200)
#pragma warning(disable:4103)

class ILogContext
{
public:
    virtual BOOL  PreAllocBuffer(UINT uiSize, DWORD dwReserved) = 0;
    virtual PVOID AllocBuffer(UINT uiSize, DWORD dwReserved) = 0;
    virtual PVOID ReAllocBuffer(UINT uiSize, DWORD dwReserved) = 0;
    virtual PVOID GetBuffer(UINT* puiSize, DWORD dwReserved) = 0;
    virtual VOID  FreeBuffer() = 0;

    virtual BOOL  GetFieldIndexFromName(PCWSTR pFieldName, UINT* puiFieldIndex) = 0;
    virtual const PLOG_FIELD_VALUE  GetFieldValue(UINT iFieldNumber) = 0;
    virtual UINT                    GetFieldsCount() = 0;
};

class ILogProvider
{
public:
    virtual LOG_PROVIDER_TYPE GetType() = 0;
    virtual VOID GetGUID(GUID *pGUID) = 0;
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext) = 0;
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance) = 0;
    virtual LOGRESULT Process(ILogContext * pLogContext) = 0;
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance) = 0;
    virtual PCWSTR ToString() = 0;
    virtual VOID DestroyObject() = 0; // never call this method from provider
};

#pragma pack(push, log_pack)
#pragma pack(8)

typedef struct tagLOG_FILTER_WITH_REF_COUNT{
    UINT    Size;
    UINT    ReferenceCount;
    GUID    FormatterGUID;
    WCHAR   UniqueDestinationString[0];
}LOG_FILTER_WITH_REF_COUNT, *PLOG_FILTER_WITH_REF_COUNT;

typedef struct tagLOG_FIELD_INFO_WITH_REF_COUNT{
    UINT    ReferenceCount;
    LOG_FIELD_INFO FieldDescription;
}LOG_FIELD_INFO_WITH_REF_COUNT, *PLOG_FIELD_INFO_WITH_REF_COUNT;

typedef struct tagLOG_SHARED_STRUCTURES_INFO{
    DWORD   FirstElementOffset; //Offset from begining of shared data;
    DWORD   SizeOfUsedMemory;
    DWORD   MaxSizeOfMemory;
}LOG_SHARED_STRUCTURES_INFO, *PLOG_SHARED_STRUCTURES_INFO;

typedef struct tagLOG_SHARED_DATA{
    LOG_SHARED_STRUCTURES_INFO Fields;
    LOG_SHARED_STRUCTURES_INFO Filters;
    
    LOG_SHARED_STRUCTURES_INFO Reserved;
}LOG_SHARED_DATA, *PLOG_SHARED_DATA;

#pragma pack(pop, log_pack)

typedef struct tagLOG_OUTPUT_STACK{
    ILogProvider *  m_Filter;
    ILogProvider *  m_Formater;
    ILogProvider *  m_Device;
}LOG_OUTPUT_STACK, *PLOG_OUTPUT_STACK;

#define STACK_LIST_CLASS CPtrList<PLOG_OUTPUT_STACK>

class CLogManager: 
                public ILogManager, 
                protected ILogContext
{
    PLOG_SHARED_DATA                m_SharedData;
    CSharedMemory                   m_SharedMemory;
    CMutualExclusionObject          m_Mutex; // controls access to m_SharedData

    PLOG_FIELD_VALUE                m_FieldsValue;
    UINT                            m_FieldsNumber;
    CBuffer *                       m_ConversionBuffers;
    UINT                            m_ConversionBuffersNumber;

    STACK_LIST_CLASS                m_StackList;

    CBuffer                         m_CommonBuffer;

protected:
    BOOL InitSharedData(UINT SizeForAllSharedData);
    BOOL GetSharedData(IN  PCWSTR pLogName); // initialize SHARED_DATA structures
    BOOL ReleaseSharedData(VOID);
    
    BOOL ValidateAndAddFieldsIfOk(PLOG_FIELD_INFO pFields, UINT NumberOfFields);
    BOOL RemoveFields();

    VOID Close();
    
    BOOL FindSharedStack(const GUID *pFormaterGUID, PCWSTR UniqueDestString, PLOG_FILTER_WITH_REF_COUNT * ppFilterData);
    BOOL ShareStack(const GUID *pFormaterGUID, PCWSTR UniqueDestString, BOOL bDestAlreadyExist);
    BOOL UnShareStack(const GUID *pFormaterGUID, PCWSTR UniqueDestString);
    BOOL DestroyStack(PLOG_OUTPUT_STACK pLogStack);

    BOOL CreateConversionBuffers(UINT NumberOfConversionBuffers);
    VOID DestroyConversionBuffers();
    
    LOGRESULT LogMessage();

public:
    CLogManager();
    ~CLogManager();

    BOOL Init(PCWSTR pLogName, 
              LOG_FIELD_INFO * pFields, 
              UINT NumberOfFields);

    BOOL STDMETHODCALLTYPE AddStack(const GUID * guidFilter,   PVOID pFilterData, 
                                    const GUID * guidFormater, PVOID pFormaterData, 
                                    const GUID * guidDevice,   PVOID pDeviceData, 
                                    PVOID * pvHandle);
    BOOL STDMETHODCALLTYPE RemoveStack(PVOID pvHandle);

    LOGRESULT STDMETHODCALLTYPE LogA(UINT NumberOfFieldsToLog, ...);
    LOGRESULT STDMETHODCALLTYPE LogW(UINT NumberOfFieldsToLog, ...);

protected:
    // interface ILogContext
    BOOL  PreAllocBuffer(UINT uiSize, DWORD dwReserved){return m_CommonBuffer.PreAllocate(uiSize);};
    PVOID AllocBuffer(UINT uiSize, DWORD dwReserved){return m_CommonBuffer.Allocate(uiSize);};
    PVOID ReAllocBuffer(UINT uiSize, DWORD dwReserved){return m_CommonBuffer.ReAllocate(uiSize);};
    PVOID GetBuffer(UINT* puiSize, DWORD dwReserved){if(puiSize){*puiSize = m_CommonBuffer.GetSize();};return m_CommonBuffer.GetBuffer();};
    VOID  FreeBuffer(){m_CommonBuffer.Free();};
    BOOL  GetFieldIndexFromName(PCWSTR pFieldName, UINT* puiFieldIndex);
    const PLOG_FIELD_VALUE GetFieldValue(UINT iFieldNumber){ASSERT(iFieldNumber < m_FieldsNumber);return &m_FieldsValue[iFieldNumber];}
    UINT             GetFieldsCount(){return m_FieldsNumber;}
};

typedef ILogProvider* (*CREATE_OBJECT_FUNC)();

BOOL LogRegisterProvider(
    IN const GUID * pGUID, 
    IN CREATE_OBJECT_FUNC pCreateObject
    );

BOOL LogUnRegisterProvider(
    IN const GUID * pGUID
    );

ILogProvider * 
LogiCreateProvider(
    IN const GUID * pGUID
    );

BOOL 
LogiDestroyProvider(
    IN ILogProvider * pILogProvider
    );

class __declspec(uuid("00000000-0000-0000-c000-000000000000")) CStandardSetupLogFilter;
class __declspec(uuid("00000000-0000-0000-c000-000000000001")) CStandardSetupLogFormatter;
class __declspec(uuid("00000000-0000-0000-c000-000000000002")) CFileDevice;
class __declspec(uuid("00000000-0000-0000-c000-000000000003")) CDebugFormatterAndDevice;
class __declspec(uuid("00000000-0000-0000-c000-000000000004")) CDebugFilter;
class __declspec(uuid("00000000-0000-0000-c000-000000000005")) CXMLLogFormatter;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\log_man.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Log Engine implementation.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "log_man.h"

#define GET_SECTION_PTR(addr, pSharedInfo)      (((BYTE *)addr) + pSharedInfo.FirstElementOffset)
#define LOG_MANAGER_MUTEX_DEFAULT_SPIN_COUNT    1000
#define LOGMANAGER_CANNOT_CONVERT_PARAMETER     L"Log: Cannot convert to ansi->unicode"
#define LOG_MANAGER_CONVERSION_BUFFER_DEFAULT_SIZE  (1<<10)

UINT
GetOffsetForNewItem(
    PLOG_SHARED_STRUCTURES_INFO pSharedInfo,
    UINT Size
    )
{
    ASSERT(pSharedInfo && Size);
    if(Size > (pSharedInfo->MaxSizeOfMemory - pSharedInfo->SizeOfUsedMemory)){
        return 0;
    }

    pSharedInfo->SizeOfUsedMemory += Size;

    return pSharedInfo->FirstElementOffset + pSharedInfo->SizeOfUsedMemory - Size;
}

VOID
UpdateForRemovedItem(
    PLOG_SHARED_STRUCTURES_INFO pSharedInfo,
    UINT Size
    )
{
    ASSERT(pSharedInfo && Size);
    if(Size > pSharedInfo->SizeOfUsedMemory){
        return;
    }

    pSharedInfo->SizeOfUsedMemory -= Size;
}

BOOL
CLogManager::CreateConversionBuffers(
    UINT NumberOfConversionBuffers
    )
{
    if(!NumberOfConversionBuffers){
        ASSERT(NumberOfConversionBuffers);
        return FALSE;
    }

    if(m_ConversionBuffers){
        ASSERT(!m_ConversionBuffers);
        DestroyConversionBuffers();
    }

    m_ConversionBuffers = new CBuffer[NumberOfConversionBuffers];
    if(!m_ConversionBuffers){
        ASSERT(m_ConversionBuffers);
        return FALSE;
    }
    m_ConversionBuffersNumber = NumberOfConversionBuffers;
    for(UINT i = 0; i < NumberOfConversionBuffers; i++){
        m_ConversionBuffers[i].PreAllocate(LOG_MANAGER_CONVERSION_BUFFER_DEFAULT_SIZE);
    }


    return TRUE;
}

VOID
CLogManager::DestroyConversionBuffers(
    VOID
    )
{
    if(!m_ConversionBuffers){
        return;
    }
    delete[m_ConversionBuffersNumber] m_ConversionBuffers;

    m_ConversionBuffers = NULL;
    m_ConversionBuffersNumber = 0;
}


CLogManager::CLogManager() : m_SharedMemory(), m_Mutex(), m_StackList()
{
    m_SharedData = NULL;

    m_FieldsValue = NULL;
    m_FieldsNumber = NULL;

    m_ConversionBuffers = NULL;
    m_ConversionBuffersNumber = NULL;
}

CLogManager::~CLogManager()
{
    Close();
}

BOOL
CLogManager::InitSharedData(
    UINT SizeForAllSharedData
    )
{
    ASSERT(m_SharedData && SizeForAllSharedData > HEADER_SIZE);
    memset(m_SharedData, 0, SizeForAllSharedData);

    PLOG_SHARED_STRUCTURES_INFO pSharedStructure;
    UINT offset;

    if(((HEADER_SIZE/SHARED_DATA_STRUCTURE_ALIGMENT) * SHARED_DATA_STRUCTURE_ALIGMENT +
        (HEADER_SIZE%SHARED_DATA_STRUCTURE_ALIGMENT? 1: 0)*SHARED_DATA_STRUCTURE_ALIGMENT) +
        (SHARED_DATA_STRUCTURE_ALIGMENT * 2) > SizeForAllSharedData){
        ASSERT(FALSE);
        return FALSE;
    }

    pSharedStructure = &((PLOG_SHARED_DATA)m_SharedData)->Fields;

    pSharedStructure->FirstElementOffset = ALIGN_DATA(HEADER_SIZE, SHARED_DATA_STRUCTURE_ALIGMENT);
    pSharedStructure->SizeOfUsedMemory = 0;
    pSharedStructure->MaxSizeOfMemory = ALIGN_DATA((SizeForAllSharedData - pSharedStructure->FirstElementOffset) / 2,
                                                   SHARED_DATA_STRUCTURE_ALIGMENT);

    offset = pSharedStructure->FirstElementOffset + pSharedStructure->MaxSizeOfMemory;

    pSharedStructure = &((PLOG_SHARED_DATA)m_SharedData)->Filters;

    pSharedStructure->FirstElementOffset = offset;
    pSharedStructure->SizeOfUsedMemory = 0;
    pSharedStructure->MaxSizeOfMemory = SizeForAllSharedData - pSharedStructure->FirstElementOffset;

    return TRUE;
}

BOOL
CLogManager::GetSharedData(
    IN  PCWSTR pLogName
    )
{
    BOOL  alreadyExist = FALSE;

    CBuffer SectionName;
    SectionName.Allocate((wcslen(pLogName) + wcslen(L"Section") + 1) * sizeof(WCHAR));
    PWSTR pSectionName = (PWSTR)SectionName.GetBuffer();
    wcscpy(pSectionName, pLogName);
    wcscat(pSectionName, L"Section");


    if(!m_SharedMemory.Open(pSectionName, INITIAL_SIZE_OF_SHARED_SECTION, &alreadyExist)){
        return FALSE;
    }

    m_SharedData = (PLOG_SHARED_DATA)m_SharedMemory.GetMapOfView();

    if(!alreadyExist){
        InitSharedData(INITIAL_SIZE_OF_SHARED_SECTION);
    }

    return TRUE;
}

BOOL
CLogManager::ReleaseSharedData(
    VOID
    )
{
    m_SharedMemory.Close();
    m_SharedData = NULL;

    m_Mutex.Close();

    if(m_FieldsValue){
        FREE(m_FieldsValue);
        m_FieldsValue = NULL;
        m_FieldsNumber= 0;
    }

    return TRUE;
}

BOOL
CLogManager::Init(
    PCWSTR pLogName,
    LOG_FIELD_INFO * pFields,
    UINT NumberOfFields
    )
{
    BOOL bResult;

    if(!pLogName || !pFields || !NumberOfFields){
        ASSERT(pLogName && pFields && NumberOfFields);
        return FALSE;
    }

    if(!m_Mutex.Open(pLogName, TRUE, LOG_MANAGER_MUTEX_DEFAULT_SPIN_COUNT)){
        return FALSE;
    }

    bResult = FALSE;

    __try{
        if(!GetSharedData(pLogName)){
            __leave;
        }
        if(!ValidateAndAddFieldsIfOk(pFields, NumberOfFields)){
            __leave;
        }

        m_FieldsValue = (PLOG_FIELD_VALUE)MALLOC(sizeof(LOG_FIELD_VALUE) * NumberOfFields);
        if(!m_FieldsValue){
            __leave;
        }
        m_FieldsNumber = NumberOfFields;

        memset(m_FieldsValue, 0, sizeof(LOG_FIELD_VALUE) * NumberOfFields);
        for(UINT i = 0, iStringNumber = 0; i < NumberOfFields; i++){
            wcscpy(m_FieldsValue[i].Name, pFields[i].Name);
            m_FieldsValue[i].bMandatory = pFields[i].bMandatory;
            m_FieldsValue[i].Value.Type = pFields[i].Type;

            if(LT_SZ == pFields[i].Type){
                iStringNumber++;
            }
        }

        if(iStringNumber && !CreateConversionBuffers(iStringNumber)){
            __leave;
        }

        bResult = TRUE;
    }
    __finally{
        if(!bResult){
            RemoveFields();
        }
    }

    m_Mutex.Release();

    if(!bResult){
        Close();
    }

    return bResult;
}

BOOL
CLogManager::ValidateAndAddFieldsIfOk(
    PLOG_FIELD_INFO pFields,
    UINT NumberOfFields
    )
{
    ASSERT(pFields && NumberOfFields);

    PLOG_FIELD_INFO_WITH_REF_COUNT pSharedFields = (PLOG_FIELD_INFO_WITH_REF_COUNT)(m_SharedData->Fields.FirstElementOffset + (BYTE*)m_SharedData);
    UINT NumberOfSharedFields = m_SharedData->Fields.SizeOfUsedMemory / sizeof(LOG_FIELD_INFO_WITH_REF_COUNT);

    for(UINT j = 0; j < NumberOfSharedFields; j++){
        PLOG_FIELD_INFO_WITH_REF_COUNT pSharedField = pSharedFields + j;

        for(UINT i = 0; i < NumberOfFields; i++){
            PLOG_FIELD_INFO pField = pFields + i;

            if(!wcscmp(pSharedField->FieldDescription.Name, pField->Name)){
                if(pSharedField->FieldDescription.Type != pField->Type ||
                    pSharedField->FieldDescription.bMandatory != pField->bMandatory){
                    return FALSE;
                }
                break;
            }
        }

        if(i == NumberOfFields && pSharedField->FieldDescription.bMandatory){
            return FALSE;
        }
    }

    for(UINT i = 0; i < NumberOfFields; i++){
        PLOG_FIELD_INFO pField = pFields + i;

        BOOL bPresent = FALSE;
        for(UINT j = 0; j < NumberOfSharedFields; j++){
            PLOG_FIELD_INFO_WITH_REF_COUNT pSharedField = pSharedFields + j;

            if(!wcscmp(pSharedField->FieldDescription.Name, pField->Name)){
                pSharedField->ReferenceCount++;
                bPresent = TRUE;
                break;
            }
        }

        if(!bPresent){
            UINT offset = GetOffsetForNewItem(&m_SharedData->Fields, sizeof(LOG_FIELD_INFO_WITH_REF_COUNT));
            if(!offset){
                return FALSE;
            }
            PLOG_FIELD_INFO_WITH_REF_COUNT pNewSharedField;
            pNewSharedField = (PLOG_FIELD_INFO_WITH_REF_COUNT)(offset + (BYTE*)m_SharedData);
            pNewSharedField->ReferenceCount = 1;
            wcscpy(pNewSharedField->FieldDescription.Name, pField->Name);
            pNewSharedField->FieldDescription.Type = pField->Type;
            pNewSharedField->FieldDescription.bMandatory = pField->bMandatory;
            bPresent = TRUE;
        }
    }

    return TRUE;
}

BOOL
CLogManager::RemoveFields(
    )
{
    if(!m_SharedData || !m_FieldsValue){
        return FALSE;
    }

    ASSERT(m_FieldsValue && m_FieldsNumber);
    PLOG_FIELD_INFO_WITH_REF_COUNT pSharedFields = (PLOG_FIELD_INFO_WITH_REF_COUNT)(m_SharedData->Fields.FirstElementOffset + (BYTE*)m_SharedData);
    UINT NumberOfSharedFields = m_SharedData->Fields.SizeOfUsedMemory / sizeof(LOG_FIELD_INFO_WITH_REF_COUNT);

    for(int i = m_FieldsNumber - 1; i >= 0 ; i--){
        PLOG_FIELD_VALUE pField = m_FieldsValue + i;

        UINT HowBytesToCopy = 0;
        for(int j = NumberOfSharedFields - 1; j >= 0; j--){
            PLOG_FIELD_INFO_WITH_REF_COUNT pSharedField = pSharedFields + j;

            if(!wcscmp(pSharedField->FieldDescription.Name, pField->Name)){
                pSharedField->ReferenceCount--;
                if(!pSharedField->ReferenceCount){
                    if(HowBytesToCopy){
                        memcpy(pSharedField, pSharedField + 1, HowBytesToCopy);
                    }
                    UpdateForRemovedItem(&m_SharedData->Fields, sizeof(LOG_FIELD_INFO_WITH_REF_COUNT));
                    break;
                }
            }

            HowBytesToCopy += sizeof(LOG_FIELD_INFO_WITH_REF_COUNT);
        }
    }

    return TRUE;
}

VOID
CLogManager::Close()
{
    m_Mutex.Acquiry();

    RemoveFields();


    //walk through list
    for(PLOG_OUTPUT_STACK pLogStack = m_StackList.BeginEnum(); pLogStack; pLogStack = m_StackList.Next()){
        ASSERT(pLogStack);
        DestroyStack(pLogStack);
    }

    m_Mutex.Release();

    m_StackList.RemoveAll();

    ReleaseSharedData();

    DestroyConversionBuffers();
}

BOOL
CLogManager::AddStack(
    const GUID * guidFilter,   PVOID pFilterData,
    const GUID * guidFormater, PVOID pFormaterData,
    const GUID * guidDevice,   PVOID pDeviceData,
    PVOID * pvHandle
    )
{
    ILogProvider * pDevice = NULL;
    ILogProvider * pFormater = NULL;
    ILogProvider * pFilter = NULL;
    PLOG_OUTPUT_STACK pNewStack = NULL;

    BOOL bResult = FALSE;
    BOOL bDestAlreadyExist = FALSE;

    if(!guidFormater){
        return FALSE;
    }

    m_Mutex.Acquiry();

    __try{
        if(guidDevice){
            pDevice = LogiCreateProvider(guidDevice);
            if(!pDevice || LOG_DEVICE_TYPE != pDevice->GetType()){
                __leave;
            }
            LOGRESULT logResult = pDevice->Init(pDeviceData, this);
            if(logError == logResult){
                __leave;
            }
            bDestAlreadyExist = (logAlreadyExist == logResult);
        }

        pFormater = LogiCreateProvider(guidFormater);
        if(!pFormater || LOG_FORMATTER_TYPE != pFormater->GetType() ||
           logError == pFormater->Init(pFormaterData, this)){
            __leave;
        }

        if(guidFilter){
            pFilter = LogiCreateProvider(guidFilter);
            if(!pFilter || LOG_FILTER_TYPE != pFilter->GetType() ||
               logError == pFilter->Init(pFilterData, this)){
                __leave;
            }
        }

        pNewStack = (PLOG_OUTPUT_STACK)MALLOC(sizeof(LOG_OUTPUT_STACK));
        if(!pNewStack){
            __leave;
        }

        pNewStack->m_Device = pDevice;
        pNewStack->m_Filter = pFilter;
        pNewStack->m_Formater = pFormater;

        if(pDevice){
            if(!ShareStack(guidFormater, pDevice->ToString(), bDestAlreadyExist)){
                __leave;
            }
        }

        {
            AllocBuffer(0, 0);
            if(pFilter){
                pFilter->PreProcess(this, !bDestAlreadyExist);
            }
            pFormater->PreProcess(this, !bDestAlreadyExist);
            if(pDevice){
                pDevice->PreProcess(this, !bDestAlreadyExist);
            }
            FreeBuffer();
        }

        //append to list
        m_StackList.Add(pNewStack);

        bResult = TRUE;
    }
    __finally{
        if(!bResult){
            if(pNewStack){
                FREE(pNewStack);
            }
            if(pFilter){
                LogiDestroyProvider(pFilter);
            }
            if(pFormater){
                LogiDestroyProvider(pFormater);
            }
            if(pDevice){
                UnShareStack(guidFormater, pDevice->ToString());
                LogiDestroyProvider(pDevice);
            }
        }
        if(pvHandle){
            *pvHandle = bResult? (PVOID)pNewStack: NULL;
        }
    }

    m_Mutex.Release();

    return bResult;
}

BOOL
CLogManager::RemoveStack(
    IN PVOID pvHandle
    )
{
    m_Mutex.Acquiry();

    //walk through list
    for(PLOG_OUTPUT_STACK pLogStack = m_StackList.BeginEnum(); pLogStack; pLogStack = m_StackList.Next()){
        ASSERT(pLogStack);
        if(((PVOID)pLogStack) == pvHandle){
            if(DestroyStack(pLogStack)){
                m_StackList.Remove(pLogStack);
                break;
            }
        }
    }

    m_Mutex.Release();

    return TRUE;
}

BOOL
CLogManager::DestroyStack(
    IN PLOG_OUTPUT_STACK pLogStack
    )
{
    BOOL bLastInstance = FALSE;
    PLOG_FILTER_WITH_REF_COUNT pSharedFilterData;
    GUID guidDevice;

    if(pLogStack->m_Device){
        pLogStack->m_Formater->GetGUID(&guidDevice);
        if(FindSharedStack(&guidDevice, pLogStack->m_Device->ToString(), &pSharedFilterData)){
            bLastInstance = 1 == pSharedFilterData->ReferenceCount;
        }
    }

    AllocBuffer(0, 0);

    if(pLogStack->m_Filter){
        pLogStack->m_Filter->PreDestroy(this, bLastInstance);
        LogiDestroyProvider(pLogStack->m_Filter);
    }

    pLogStack->m_Formater->PreDestroy(this, bLastInstance);
    LogiDestroyProvider(pLogStack->m_Formater);

    if(pLogStack->m_Device){
        pLogStack->m_Device->PreDestroy(this, bLastInstance);
        if(!UnShareStack(&guidDevice, pLogStack->m_Device->ToString())){
            return FALSE;
        }
        LogiDestroyProvider(pLogStack->m_Device);
    }

    FreeBuffer();

    FREE(pLogStack);

    return TRUE;
}

BOOL
CLogManager::FindSharedStack(
    IN const GUID *pFormaterGUID,
    IN PCWSTR UniqueDestString,
    PLOG_FILTER_WITH_REF_COUNT * ppFilterData
    )
{
    PLOG_FILTER_WITH_REF_COUNT pSharedFilterData;
    ASSERT(pFormaterGUID && UniqueDestString && ppFilterData);


    BYTE * pData = GET_SECTION_PTR(m_SharedData, m_SharedData->Filters);
    UINT offset = 0;

    while(offset < m_SharedData->Filters.SizeOfUsedMemory){
        pSharedFilterData = (PLOG_FILTER_WITH_REF_COUNT)(pData + offset);
        if(!wcscmp(pSharedFilterData->UniqueDestinationString, UniqueDestString)){//must be wcsicmp
            if(InlineIsEqualGUID(&pSharedFilterData->FormatterGUID, pFormaterGUID)){
                *ppFilterData = pSharedFilterData;
                return TRUE;
            }
            else{
                return FALSE;
            }
        }
        offset += pSharedFilterData->Size;
    };

    *ppFilterData = NULL;

    return TRUE;
}

BOOL
CLogManager::ShareStack(
    IN const GUID * pFormaterGUID,
    IN PCWSTR UniqueDestString,
    IN BOOL bDestAlreadyExist
    )
{
    PLOG_FILTER_WITH_REF_COUNT pSharedFilterData;
    UINT offset;
    UINT size;

    if(!FindSharedStack(pFormaterGUID, UniqueDestString, &pSharedFilterData)){
        return FALSE;
    }

    if(!pSharedFilterData){
        if(bDestAlreadyExist){
            return FALSE;
        }

        size = sizeof(LOG_FILTER_WITH_REF_COUNT) + (wcslen(UniqueDestString) + 1/*'\0'*/) * sizeof(WCHAR);

        offset = GetOffsetForNewItem(&m_SharedData->Filters, size);
        if(!offset){
            return FALSE;
        }

        pSharedFilterData = (PLOG_FILTER_WITH_REF_COUNT)(offset + (BYTE*)m_SharedData);
        pSharedFilterData->ReferenceCount = 1;
        pSharedFilterData->FormatterGUID = *pFormaterGUID;
        wcscpy(pSharedFilterData->UniqueDestinationString, UniqueDestString);
        pSharedFilterData->Size = size;
    }
    else{
        pSharedFilterData->ReferenceCount++;
    }

    return TRUE;
}

BOOL
CLogManager::UnShareStack(
    IN const GUID * pFormaterGUID,
    IN PCWSTR UniqueDestString
    )
{
    PLOG_FILTER_WITH_REF_COUNT pSharedFilterData;
    PLOG_FILTER_WITH_REF_COUNT pSharedNextFilterData;
    UINT_PTR offset;
    UINT size;

    if(!FindSharedStack(pFormaterGUID, UniqueDestString, &pSharedFilterData)){
        return FALSE;
    }

    if(pSharedFilterData){
        pSharedFilterData->ReferenceCount--;
        if(!pSharedFilterData->ReferenceCount){
            size = pSharedFilterData->Size;
            offset = ((BYTE *)pSharedFilterData) - GET_SECTION_PTR(m_SharedData, m_SharedData->Filters) + size;
            pSharedNextFilterData = (PLOG_FILTER_WITH_REF_COUNT)(GET_SECTION_PTR(m_SharedData, m_SharedData->Filters) + offset);
            if(offset < m_SharedData->Filters.SizeOfUsedMemory){
                memcpy(pSharedFilterData, pSharedNextFilterData, m_SharedData->Filters.SizeOfUsedMemory - offset);
            }
            UpdateForRemovedItem(&m_SharedData->Filters, size);
        }
    }

    return TRUE;
}

LOGRESULT
CLogManager::LogMessage()
{
    LOGRESULT logResult;
    BOOL      bBreakPoint = FALSE;
    BOOL      bAbortProcess = FALSE;

    ASSERT(0 != m_StackList.GetSize());

    logResult = logError;

    __try{
        //walk through list
        for(PLOG_OUTPUT_STACK pLogStack = m_StackList.BeginEnum(); pLogStack; pLogStack = m_StackList.Next()){
            ASSERT(pLogStack);

            if(!pLogStack){
                ASSERT(pLogStack);
                continue;
            }

            FreeBuffer();

            if(pLogStack->m_Filter){
                logResult = pLogStack->m_Filter->Process(this);

                if(logOk != logResult){
                    if(logBreakPoint == logResult){
                        bBreakPoint = TRUE;
                    }
                    else if(logAbortProcess == logResult){
                        bAbortProcess = TRUE;
                    }
                    else{
                        continue;
                    }
                }
            }

            logResult = pLogStack->m_Formater->Process(this);
            if(logOk != logResult){
                continue;
            }

            if(pLogStack->m_Device){
                logResult = pLogStack->m_Device->Process(this);
                if(logOk != logResult){
                    continue;
                }
            }
        }

        if(bAbortProcess){
            logResult = logAbortProcess;
        }
        else{
            logResult = bBreakPoint? logBreakPoint: logOk;
        }

    }
    __finally{
    }

    return logResult;
}

LOGRESULT
STDMETHODCALLTYPE
CLogManager::LogA(
    IN UINT NumberOfFieldsToLog
    IN ...
    )
{
    PCSTR pTempStr;
    LOGRESULT logResult;
    PLOG_VALUE pFieldValue;
    va_list argList;

    if(NumberOfFieldsToLog > m_FieldsNumber){
        NumberOfFieldsToLog = m_FieldsNumber;
    }

    m_Mutex.Acquiry();

    logResult = logError;

    __try{
        va_start(argList, NumberOfFieldsToLog);

        for(UINT i = 0, iStringNumber = 0; i < NumberOfFieldsToLog; i++){
            pFieldValue = &m_FieldsValue[i].Value;

#ifdef DEBUG
            //
            // init value union
            //
            memset(&pFieldValue->Binary, 0, sizeof(pFieldValue->Binary));
#endif

            switch(pFieldValue->Type){
            case LT_DWORD:
                pFieldValue->Dword = va_arg(argList, DWORD);
                break;
            case LT_SZ:
                ASSERT(m_ConversionBuffers);
                pTempStr = va_arg(argList, PCSTR);
                if(pTempStr){
                    if(!m_ConversionBuffers ||
                       !(m_ConversionBuffers[iStringNumber].ReAllocate((strlen(pTempStr) + 1) * sizeof(WCHAR)))){
                        pFieldValue->String = LOGMANAGER_CANNOT_CONVERT_PARAMETER;
                        break;
                    }
                    pFieldValue->String = (PCWSTR)m_ConversionBuffers[iStringNumber].GetBuffer();
                    swprintf((PWSTR)pFieldValue->String, L"%S", pTempStr);
                }
                else{
                    pFieldValue->String = NULL;
                }
                iStringNumber++;
                break;
            case LT_BINARY:
                pFieldValue->Binary.Buffer = va_arg(argList, BYTE *);
                pFieldValue->Binary.Size = va_arg(argList, DWORD);
                break;
            default:
                ASSERT(FALSE);
            };
        }
        
        for(; i < m_FieldsNumber; i++){
            pFieldValue = &m_FieldsValue[i].Value;
            //
            // init value union
            //
            memset(&pFieldValue->Binary, 0, sizeof(pFieldValue->Binary));
       }

        va_end(argList);

        logResult = LogMessage();
    }
    __finally{
        m_Mutex.Release();
    }

    return logResult;
}

LOGRESULT
STDMETHODCALLTYPE
CLogManager::LogW(
    IN UINT NumberOfFieldsToLog
    IN ...
    )
{
    LOGRESULT logResult;
    PLOG_VALUE pFieldValue;
    va_list argList;

    if(NumberOfFieldsToLog > m_FieldsNumber){
        NumberOfFieldsToLog = m_FieldsNumber;
    }

    m_Mutex.Acquiry();

    logResult = logError;

    __try{
        va_start(argList, NumberOfFieldsToLog);

        for(UINT i = 0; i < NumberOfFieldsToLog; i++){
            pFieldValue = &m_FieldsValue[i].Value;

#ifdef DEBUG
            //
            // init value union
            //
            memset(&pFieldValue->Binary, 0, sizeof(pFieldValue->Binary));
#endif

            switch(pFieldValue->Type){
            case LT_DWORD:
                pFieldValue->Dword = va_arg(argList, DWORD);
                break;
            case LT_SZ:
                pFieldValue->String = va_arg(argList, PCWSTR);
                break;
            case LT_BINARY:
                pFieldValue->Binary.Buffer = va_arg(argList, BYTE *);
                pFieldValue->Binary.Size = va_arg(argList, DWORD);
                break;
            default:
                ASSERT(FALSE);
            };
        }

        for(; i < m_FieldsNumber; i++){
            pFieldValue = &m_FieldsValue[i].Value;
            //
            // init value union
            //
            memset(&pFieldValue->Binary, 0, sizeof(pFieldValue->Binary));
        }
        
        va_end(argList);

        logResult = LogMessage();
    }
    __finally{
        m_Mutex.Release();
    }

    return logResult;
}

// interface ILogContext

BOOL
CLogManager::GetFieldIndexFromName(
    IN PCWSTR pFieldName,
    IN UINT* puiFieldIndex
    )
{
    ASSERT(pFieldName && pFieldName);

    if(!pFieldName){
        return FALSE;
    }

    for(UINT i = 0; i < m_FieldsNumber; i++){
        if(!wcscmp(m_FieldsValue[i].Name, pFieldName)){//must be wcsicmp
            if(puiFieldIndex){
                *puiFieldIndex = i;
            }
            return TRUE;
        }
    }

    return FALSE;
}

ILogManager *
LogCreateLog(
    IN PCWSTR pLogName,
    IN PLOG_FIELD_INFO pFields,
    IN UINT NumberOfFields
    )
{
    CLogManager * pLogManager = new CLogManager;

    ASSERT(pLogManager);
    if(!pLogManager){
        return NULL;
    }

    if(!pLogManager->Init(pLogName, pFields, NumberOfFields)){
        delete pLogManager;
        return NULL;
    }

    return (ILogManager *)pLogManager;
}

VOID
LogDestroyLog(
    IN ILogManager * pLog
    )
{
    ASSERT(pLog);
    if(!pLog){
        return;
    }

    delete (CLogManager *)pLog;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\setuplog.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Implementation of standard logs support:
    setupact.log, setuperr.log and debug.log.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"
#include "mem.h"

#include "setuplog.h"

ILogManager * g_pLogManager = NULL;
HINSTANCE     g_ModuleInstance = NULL;
DWORD         g_ProcessID = 0;

#define L_QUOTE1(x)  L##x
#define L_QUOTE(x)  L_QUOTE1(x)

#define TOO_LONG_MESSAGEA           "Log: Too Long Message"
#define TOO_LONG_MESSAGEW           L_QUOTE(TOO_LONG_MESSAGEA)

#define FAILED_TO_GET_MSG_FROM_IDA  "Log: Failed To Get Msg From ID"

#define STANDART_LOG_FIELD_SEVERITY         L"Severity"
#define STANDART_LOG_FIELD_MESSAGE          L"Message"
#define STANDART_LOG_FIELD_CONDITION        L"Condition"
#define STANDART_LOG_FIELD_SOURCELINENUMBER L"SourceLineNumber"
#define STANDART_LOG_FIELD_SOURCEFILE       L"SourceFile"
#define STANDART_LOG_FIELD_SOURCEFUNCTION   L"SourceFunction"
#define STANDART_LOG_PROCESS_ID             L"ProcessID"
#define STANDART_LOG_THREAD_ID              L"ThreadID"

static LOG_FIELD_INFO g_infoFields[] =  {
                                            {LT_DWORD, TRUE, STANDART_LOG_FIELD_SEVERITY},
                                            {LT_SZ, TRUE, STANDART_LOG_FIELD_MESSAGE},
                                            {LT_DWORD, TRUE, STANDART_LOG_PROCESS_ID},
                                            {LT_DWORD, TRUE, STANDART_LOG_THREAD_ID},
                                            {LT_SZ, FALSE, STANDART_LOG_FIELD_CONDITION},
                                            {LT_DWORD, FALSE, STANDART_LOG_FIELD_SOURCELINENUMBER},
                                            {LT_SZ, FALSE, STANDART_LOG_FIELD_SOURCEFILE},
                                            {LT_SZ, FALSE, STANDART_LOG_FIELD_SOURCEFUNCTION},
                                        };

#define NUMBER_OF_FIELDS    (sizeof(g_infoFields) / sizeof(g_infoFields[0]))

ILogManager *
STD_CALL_TYPE
LogStandardInit(
    IN  PCWSTR      pDebugLogFileName,
    IN  HINSTANCE   hModuleInstance,        OPTIONAL
    IN  BOOL        bCreateNew,             OPTIONAL
    IN  BOOL        bExcludeSetupActLog,    OPTIONAL
    IN  BOOL        bExcludeSetupErrLog,    OPTIONAL
    IN  BOOL        bExcludeXMLLog,         OPTIONAL
    IN  BOOL        bExcludeDebugFilter     OPTIONAL
    )
{
    BOOL bResult;
    ILogManager * pLogManager;
    UINT uiNumberOfFields;
    DWORD dwFlags = bCreateNew? DEVICE_CREATE_NEW: 0;
    CHAR  winDirectory[MAX_PATH];
    WCHAR  setupactDir[MAX_PATH];
    WCHAR  setuperrDir[MAX_PATH];
    WCHAR  setupxmlDir[MAX_PATH];


    if(g_pLogManager){
        return NULL;
    }

    uiNumberOfFields = NUMBER_OF_FIELDS;

    LogRegisterStockProviders();

    pLogManager = LogCreateLog(L"SetupLog", g_infoFields, uiNumberOfFields);
    if(!pLogManager){
        return NULL;
    }

    bResult = FALSE;

    GetWindowsDirectoryA(winDirectory, sizeof(winDirectory) / sizeof(winDirectory[0]));
    
    swprintf(setupactDir, L"%S\\%s", winDirectory, L"setupact.log");
    swprintf(setuperrDir, L"%S\\%s", winDirectory, L"setuperr.log");
    swprintf(setupxmlDir, L"%S\\%s", winDirectory, L"setuplog.xml");

    __try{
        LOG_DEVICE_PROV_INIT_DATA deviceActInitData = {setupactDir, dwFlags | DEVICE_WRITE_THROUGH, 0, 0};
        LOG_DEVICE_PROV_INIT_DATA deviceErrInitData = {setuperrDir, dwFlags, 0, 0};
        LOG_DEVICE_PROV_INIT_DATA deviceDbgInitData = {pDebugLogFileName, dwFlags, 0, 0};
        LOG_DEVICE_PROV_INIT_DATA deviceXMLInitData = {setupxmlDir, dwFlags, 0, 0};

        LOG_SETUPLOG_FORMAT_PROV_INIT_DATA formatterInitData =  {
                                                                    STANDART_LOG_FIELD_SEVERITY,
                                                                    STANDART_LOG_FIELD_MESSAGE,
                                                                    0
                                                                };

        LOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA debugFormatterAndDevice =    {
                                                                                    STANDART_LOG_FIELD_SEVERITY,
                                                                                    STANDART_LOG_FIELD_MESSAGE,
                                                                                    STANDART_LOG_FIELD_CONDITION,
                                                                                    STANDART_LOG_FIELD_SOURCELINENUMBER,
                                                                                    STANDART_LOG_FIELD_SOURCEFILE,
                                                                                    STANDART_LOG_FIELD_SOURCEFUNCTION
                                                                                };

        LOG_SETUPLOG_FILTER_PROV_INIT_DATA filterActInitData = {STANDART_LOG_FIELD_SEVERITY, LOG_INFO, TRUE};
        LOG_SETUPLOG_FILTER_PROV_INIT_DATA filterErrInitData = {STANDART_LOG_FIELD_SEVERITY, LOG_ERROR, TRUE};
        //LOG_SETUPLOG_FILTER_PROV_INIT_DATA filterDbgInitData = {L"Severity", LOG_INFO, L"Debug", FALSE};

        if(!bExcludeSetupActLog){
            if(!ILogManager_AddStack(pLogManager,
                                     &GUID_STANDARD_SETUPLOG_FILTER, &filterActInitData,
                                     &GUID_STANDARD_SETUPLOG_FORMATTER, &formatterInitData,
                                     &GUID_FILE_DEVICE, &deviceActInitData,
                                     NULL)){
                __leave;
                return NULL;
            }
        }

        if(!bExcludeSetupErrLog){
            if(!ILogManager_AddStack(pLogManager,
                                     &GUID_STANDARD_SETUPLOG_FILTER, &filterErrInitData,
                                     &GUID_STANDARD_SETUPLOG_FORMATTER, &formatterInitData,
                                     &GUID_FILE_DEVICE, &deviceErrInitData,
                                     NULL)){
                __leave;
            }
        }

        if(pDebugLogFileName){
            if(!ILogManager_AddStack(pLogManager,
                                     NULL, NULL,
                                     &GUID_STANDARD_SETUPLOG_FORMATTER, &formatterInitData,
                                     &GUID_FILE_DEVICE, &deviceDbgInitData,
                                     NULL)){
                __leave;
            }
        }

        if(!bExcludeDebugFilter){
            if(!ILogManager_AddStack(pLogManager,
                                     &GUID_DEBUG_FILTER, &debugFormatterAndDevice,
                                     &GUID_DEBUG_FORMATTER_AND_DEVICE, &debugFormatterAndDevice,
                                     NULL, NULL,
                                     NULL)){
                __leave;
            }
        }

        if(!bExcludeXMLLog){
            if(!ILogManager_AddStack(pLogManager,
                                     NULL, NULL,
                                     &GUID_XML_FORMATTER, NULL,
                                     &GUID_FILE_DEVICE, &deviceXMLInitData,
                                     NULL)){
                __leave;
            }
        }

        g_ProcessID = GetCurrentProcessId();

        bResult = TRUE;
    }
    __finally{
        if(!bResult){
            LogDestroyStandard();
            pLogManager = NULL;
        }
    }

    g_pLogManager = pLogManager;

    return pLogManager;
}

VOID
STD_CALL_TYPE
LogDestroyStandard(
    VOID
    )
{
    if(!g_pLogManager){
        return;
    }

    LogDestroyLog(g_pLogManager);

    LogUnRegisterStockProviders();
}

LOGRESULT
STD_CALL_TYPE
LogMessageW(
    IN PLOG_PARTIAL_MSG pPartialMsg,
    IN PCSTR            Condition,
    IN DWORD            SourceLineNumber,
    IN PCWSTR           SourceFile,
    IN PCWSTR           SourceFunction
    )
{
    LOGRESULT logResult;
    WCHAR   unicodeConditionBuffer[MAX_MESSAGE_CHAR];
    PCWSTR  pUnicodeCondition;
    DWORD lastError = GetLastError();

    if(!g_pLogManager || !pPartialMsg){
        return logError;
    }

    if(Condition){
        _snwprintf(unicodeConditionBuffer, MAX_MESSAGE_CHAR, L"%S", Condition);
        pUnicodeCondition = unicodeConditionBuffer;
    }
    else{
        pUnicodeCondition = NULL;
    }

    logResult = ILogManager(g_pLogManager)->LogW(g_pLogManager,
                                                 NUMBER_OF_FIELDS,
                                                 pPartialMsg->Severity,
                                                 pPartialMsg->Message.pWStr,
                                                 g_ProcessID,
                                                 GetCurrentThreadId(),
                                                 pUnicodeCondition,
                                                 SourceLineNumber,
                                                 SourceFile,
                                                 SourceFunction);

    if(logAbortProcess == logResult){
        LogDestroyStandard();
        ExitProcess(0);
    }
    
    FREE(pPartialMsg);

    SetLastError (lastError);

    return logResult;
}

LOGRESULT
STD_CALL_TYPE
LogMessageA(
    IN PLOG_PARTIAL_MSG pPartialMsg,
    IN PCSTR            Condition,
    IN DWORD            SourceLineNumber,
    IN PCSTR            SourceFile,
    IN PCSTR            SourceFunction
    )
{
    LOGRESULT logResult;
    DWORD lastError = GetLastError();

    if(!g_pLogManager || !pPartialMsg){
        return logError;
    }

    logResult = ILogManager(g_pLogManager)->LogA(g_pLogManager,
                                                 NUMBER_OF_FIELDS,
                                                 pPartialMsg->Severity,
                                                 pPartialMsg->Message.pAStr,
                                                 g_ProcessID,
                                                 GetCurrentThreadId(),
                                                 Condition,
                                                 SourceLineNumber,
                                                 SourceFile,
                                                 SourceFunction);

    if(logAbortProcess == logResult){
        LogDestroyStandard();
        ExitProcess(0);
    }


    FREE(pPartialMsg);

    SetLastError (lastError);

    return logResult;
}

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgVA(
    IN DWORD dwSeverity,
    IN PCSTR Format,
    IN va_list args
    )
{
    PLOG_PARTIAL_MSG partialMsg;
    PSTR ptrString;

    if(!g_pLogManager){
        return NULL;
    }

    //
    // improve later, by using TLS
    //
    partialMsg = (PLOG_PARTIAL_MSG)MALLOC(sizeof(LOG_PARTIAL_MSG));

    if(partialMsg){
        partialMsg->Severity = dwSeverity;

        if(Format){
            ptrString = NULL;

            if(!(HIWORD(Format))){
                //
                // StringID
                //
                if(!FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_HMODULE,
                                     g_ModuleInstance,
                                     (DWORD)LOWORD(Format),
                                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                     (PVOID)&ptrString,
                                     0,
                                     &args)){
                    Format = FAILED_TO_GET_MSG_FROM_IDA;
                }
                else{
                    Format = ptrString;
                }
            }

            if(_vsnprintf(partialMsg->Message.pAStr,
                          MAX_MESSAGE_CHAR,
                          Format,
                          args) < 0){
                strcpy(partialMsg->Message.pAStr, TOO_LONG_MESSAGEA);
            }

            if(ptrString){
                LocalFree(ptrString);
            }
        }
        else{
            partialMsg->Message.pAStr[0] = '0';
        }

    }

    return partialMsg;
}

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgVW(
    IN DWORD dwSeverity,
    IN PCSTR Format,
    IN va_list args
    )
{
    PLOG_PARTIAL_MSG partialMsg;
    PWSTR ptrString;
    PCWSTR unicodeFormatString = NULL;
    PCWSTR pStringToFree = NULL;
    WCHAR unicodeBuffer[MAX_MESSAGE_CHAR];

    if(!g_pLogManager){
        return NULL;
    }

    //
    // improve later, by using TLS
    //
    partialMsg = (PLOG_PARTIAL_MSG)MALLOC(sizeof(LOG_PARTIAL_MSG));

    if(partialMsg){
        partialMsg->Severity = dwSeverity;

        if(Format){
            ptrString = NULL;

            if(!(HIWORD(Format))){
                //
                // StringID
                //
                if(!FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_FROM_HMODULE,
                                     g_ModuleInstance,
                                     (DWORD)LOWORD(Format),
                                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                     (PVOID)&ptrString,
                                     0,
                                     &args)){
                    Format = FAILED_TO_GET_MSG_FROM_IDA;
                }
                else{
                    unicodeFormatString = ptrString;
                }
            }

            if(!unicodeFormatString){
                _snwprintf(unicodeBuffer, MAX_MESSAGE_CHAR, L"%S", Format);
                unicodeBuffer[MAX_MESSAGE_CHAR - 1] = 0;
                unicodeFormatString = unicodeBuffer;
            }

            if(_vsnwprintf(partialMsg->Message.pWStr,
                           MAX_MESSAGE_CHAR,
                           unicodeFormatString,
                           args) < 0){
                wcscpy(partialMsg->Message.pWStr, TOO_LONG_MESSAGEW);
            }

            if(ptrString){
                LocalFree(ptrString);
            }
        }
        else{
            partialMsg->Message.pWStr[0] = '0';
        }
    }

    return partialMsg;
}

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgIfA(
    IN BOOL bCondition,
    IN DWORD dwSeverity,
    IN PCSTR Format,
    ...
    )
{
    va_list args;

    if(!bCondition){
        return NULL;
    }

    va_start(args, Format);

    return ConstructPartialMsgVA(dwSeverity, Format, args);
}

PLOG_PARTIAL_MSG
STD_CALL_TYPE
ConstructPartialMsgIfW(
    IN BOOL bCondition,
    IN DWORD dwSeverity,
    IN PCSTR Format,
    ...
    )
{
    va_list args;

    if(!bCondition){
        return NULL;
    }

    va_start(args, Format);

    return ConstructPartialMsgVW(dwSeverity, Format, args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\pcha\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\logprovreg.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    API for register/unregister and using Log Providers.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#include "log.h"
#include "log_man.h"
#include "stockpr.h"
#include "templ.h"

const GUID GUID_STANDARD_SETUPLOG_FILTER    = __uuidof(CStandardSetupLogFilter);
const GUID GUID_STANDARD_SETUPLOG_FORMATTER = __uuidof(CStandardSetupLogFormatter);
const GUID GUID_FILE_DEVICE                 = __uuidof(CFileDevice);
const GUID GUID_DEBUG_FORMATTER_AND_DEVICE  = __uuidof(CDebugFormatterAndDevice);
const GUID GUID_DEBUG_FILTER                = __uuidof(CDebugFilter);
const GUID GUID_XML_FORMATTER               = __uuidof(CXMLLogFormatter);

typedef struct tagLOG_PROVIDER_ENTRY{
    UINT    uiRefCount;
    GUID    ProviderGUID;
    CREATE_OBJECT_FUNC pCreateObject;
}LOG_PROVIDER_ENTRY, *PLOG_PROVIDER_ENTRY;

#define PROV_LIST_CLASS CPtrList<PLOG_PROVIDER_ENTRY>

static PROV_LIST_CLASS * g_ProviderList = NULL;

BOOL 
LogRegisterProvider(
    IN const GUID * pGUID, 
    IN CREATE_OBJECT_FUNC pCreateObject
    )
{
    PLOG_PROVIDER_ENTRY pProviderEntry;

    if(!pGUID || !pCreateObject){
        ASSERT(pGUID && pCreateObject);
        return FALSE;
    }

    if(!g_ProviderList){
        g_ProviderList = new PROV_LIST_CLASS;
        if(!g_ProviderList){
            return FALSE;
        }
    }
    
    //walk through list
    for(pProviderEntry = g_ProviderList->BeginEnum(); pProviderEntry; pProviderEntry = g_ProviderList->Next()){
        ASSERT(pProviderEntry);

        if(InlineIsEqualGUID(&pProviderEntry->ProviderGUID, pGUID)){
            if(pProviderEntry->pCreateObject == pCreateObject){
                return TRUE;
            }
            ASSERT(FALSE);
            return FALSE;
        }
    }
    
    pProviderEntry = (PLOG_PROVIDER_ENTRY)MALLOC(sizeof(LOG_PROVIDER_ENTRY));
    if(!pProviderEntry){
        ASSERT(pProviderEntry);
        return FALSE;
    };
    
    //append to list
    pProviderEntry->uiRefCount = 0;
    pProviderEntry->ProviderGUID = *pGUID;
    pProviderEntry->pCreateObject = pCreateObject;

    g_ProviderList->Add(pProviderEntry);

    return TRUE;
}

BOOL 
LogUnRegisterProvider(
    IN const GUID * pGUID
    )
{
    PLOG_PROVIDER_ENTRY pProviderEntry;

    if(!g_ProviderList){
        return TRUE;
    }
    
    if(!pGUID){
        ASSERT(pGUID);
        return FALSE;
    }
    
    //walk through list
    for(pProviderEntry = g_ProviderList->BeginEnum(); pProviderEntry; pProviderEntry = g_ProviderList->Next()){
        ASSERT(pProviderEntry);
        
        if(InlineIsEqualGUID(&pProviderEntry->ProviderGUID, pGUID)){
            if(pProviderEntry->uiRefCount){
                return FALSE;
            }
            //exclude and free list item
            g_ProviderList->Remove(pProviderEntry);
            
            FREE(pProviderEntry);

            if(!g_ProviderList->BeginEnum()){
                delete g_ProviderList;
                g_ProviderList = NULL;
            }

            return TRUE;
        }
    }

    return TRUE;
}

ILogProvider * 
LogiCreateProvider(
    IN const GUID * pGUID
    )
{
    PLOG_PROVIDER_ENTRY pProviderEntry;
    ILogProvider * pLogProvider = NULL;

    if(!g_ProviderList){
        return NULL;
    }
    
    if(!pGUID){
        ASSERT(pGUID);
        return NULL;
    }
    
    //walk through list
    for(pProviderEntry = g_ProviderList->BeginEnum(); pProviderEntry; pProviderEntry = g_ProviderList->Next()){
        ASSERT(pProviderEntry);
    
        if(InlineIsEqualGUID(&pProviderEntry->ProviderGUID, pGUID)){
            ASSERT(pProviderEntry->pCreateObject);
            pLogProvider = pProviderEntry->pCreateObject();
            if(pLogProvider){
                pProviderEntry->uiRefCount++;
            }
            return pLogProvider;
        }
    }

    return NULL;
}

BOOL 
LogiDestroyProvider(
    IN ILogProvider * pILogProvider
    )
{
    PLOG_PROVIDER_ENTRY pProviderEntry;
    GUID guidProvider;

    if(!g_ProviderList){
        return NULL;
    }
    
    if(!pILogProvider){
        ASSERT(pILogProvider);
        return FALSE;
    }

    pILogProvider->GetGUID(&guidProvider);
    
    //walk through list
    for(pProviderEntry = g_ProviderList->BeginEnum(); pProviderEntry; pProviderEntry = g_ProviderList->Next()){
        ASSERT(pProviderEntry);
        if(InlineIsEqualGUID(&pProviderEntry->ProviderGUID, &guidProvider)){
            pProviderEntry->uiRefCount--;
            pILogProvider->DestroyObject();
            return TRUE;
        }
    }

    return FALSE;
}

BOOL 
LogRegisterStockProviders(
    VOID
    )
{
    LogRegisterProvider(&GUID_STANDARD_SETUPLOG_FILTER, CStandardSetupLogFilter::CreateObject);
    LogRegisterProvider(&GUID_STANDARD_SETUPLOG_FORMATTER, CStandardSetupLogFormatter::CreateObject);
    LogRegisterProvider(&GUID_FILE_DEVICE, CFileDevice::CreateObject);
    LogRegisterProvider(&GUID_DEBUG_FORMATTER_AND_DEVICE, CDebugFormatterAndDevice::CreateObject);
    LogRegisterProvider(&GUID_DEBUG_FILTER, CDebugFilter::CreateObject);
    LogRegisterProvider(&GUID_XML_FORMATTER, CXMLLogFormatter::CreateObject);
    
    return TRUE;
}

BOOL 
LogUnRegisterStockProviders(
    VOID
    )
{
    LogUnRegisterProvider(&GUID_XML_FORMATTER);
    LogUnRegisterProvider(&GUID_DEBUG_FORMATTER_AND_DEVICE);
    LogUnRegisterProvider(&GUID_DEBUG_FILTER);
    LogUnRegisterProvider(&GUID_FILE_DEVICE);
    LogUnRegisterProvider(&GUID_STANDARD_SETUPLOG_FORMATTER);
    LogUnRegisterProvider(&GUID_STANDARD_SETUPLOG_FILTER);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\stockpr.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Implementation of stock Log Providers.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#include "log_man.h"
#include "stockpr.h"
#include "mem.h"

BOOL
pFieldValidation(
    IN ILogContext * pLogContext,
    IN PFIELD_VALIDATION_DATA StructArray,
    IN UINT ArraySize
    )
{
    ASSERT(pLogContext && StructArray && ArraySize);

    for(UINT i = 0; i < ArraySize; i++){
        BOOL bMandatoryField = StructArray[i].Mandatory;
        if(!StructArray[i].FieldName){
            if(bMandatoryField){
                return FALSE;
            }
            continue;
        }

        if(pLogContext->GetFieldIndexFromName(StructArray[i].FieldName,
                                              StructArray[i].FieldIndexPtr)){
            PLOG_FIELD_VALUE pValue = pLogContext->GetFieldValue(*StructArray[i].FieldIndexPtr);

            if(!pValue || StructArray[i].Type != pValue->Value.Type){
                ASSERT(pValue && StructArray[i].Type == pValue->Value.Type);
                return FALSE;
            }
        }
        else{
            if(bMandatoryField){
                return FALSE;
            }
        }
    }

    return TRUE;
}

PCWSTR
pGetStandardLogSeverityString(
    IN DWORD dwSeverity
    )
{
    PCWSTR pSeverity;

    switch(dwSeverity){
    case LOG_ASSERT:
        pSeverity = L"Assert";
        break;
    case LOG_FATAL_ERROR:
        pSeverity = L"FatalError";
        break;
    case LOG_ERROR:
        pSeverity = L"Error";
        break;
    case LOG_WARNING:
        pSeverity = L"Warning";
        break;
    case DBG_INFO:
    case LOG_INFO:
        pSeverity = L"Info";
        break;
    case DBG_ASSERT:
        pSeverity = L"Assert";
        break;
    case DBG_NAUSEA:
        pSeverity = L"Nausea";
        break;
    case DBG_VERBOSE:
        pSeverity = L"Nausea";
        break;
    case DBG_STATS:
        pSeverity = L"Stats";
        break;
    case DBG_WARNING:
        pSeverity = L"Warning";
        break;
    case DBG_ERROR:
        pSeverity = L"Error";
        break;
    case DBG_WHOOPS:
        pSeverity = L"Whoops";
        break;
    case DBG_TRACK:
        pSeverity = L"Track";
        break;
    case DBG_TIME:
        pSeverity = L"Time";
        break;
    default:
        ASSERT(FALSE);
        pSeverity = L"UndefinedLogType";
    }

    return pSeverity;
}

BOOL
pIsLogSeverityCorrect(
    IN  DWORD dwSeverity,
    OUT BOOL * pbDebugType
    )
{
    BOOL bDebugType = FALSE;
    switch(dwSeverity){
    case LOG_ASSERT:
    case LOG_FATAL_ERROR:
    case LOG_ERROR:
    case LOG_WARNING:
    case LOG_INFO:
        bDebugType = FALSE;
        break;
    case DBG_ASSERT:
    case DBG_NAUSEA:
    case DBG_INFO:
    case DBG_VERBOSE:
    case DBG_STATS:
    case DBG_WARNING:
    case DBG_ERROR:
    case DBG_WHOOPS:
    case DBG_TRACK:
    case DBG_TIME:
        bDebugType = TRUE;
        break;
    default:
        ASSERT(FALSE);
        return FALSE;
    }

    if(pbDebugType){
        *pbDebugType = bDebugType;
    }

    return TRUE;
}

CStandardSetupLogFilter::CStandardSetupLogFilter(
    VOID
    )
{
    m_uiSeverityFieldNumber = UNDEFINED_FIELD_INDEX;
    m_SeverityThreshold = LOG_INFO;
    m_bSuppressDebugMessages = TRUE;
}

LOGRESULT
CStandardSetupLogFilter::Init(
    IN PVOID pvCustomData,
    IN ILogContext * pLogContext
    )
{
    UINT   uiFieldIndex;

    if(!pvCustomData){
        return logOk;
    }

    PCWSTR pFieldName = ((PLOG_SETUPLOG_FILTER_PROV_INIT_DATA)pvCustomData)->FieldName;
    if(!pFieldName){
        return logError;
    }

    if(!pLogContext->GetFieldIndexFromName(pFieldName, &uiFieldIndex)){
        return logError;
    }

    m_uiSeverityFieldNumber = uiFieldIndex;

    PLOG_FIELD_VALUE pValue = pLogContext->GetFieldValue(uiFieldIndex);

    if(!pValue || LT_DWORD != pValue->Value.Type){
        ASSERT(pValue && LT_DWORD == pValue->Value.Type);
        return logError;
    }

    if(!pIsLogSeverityCorrect(((PLOG_SETUPLOG_FILTER_PROV_INIT_DATA)pvCustomData)->SeverityThreshold, NULL)){
        return logError;
    }

    m_SeverityThreshold = ((PLOG_SETUPLOG_FILTER_PROV_INIT_DATA)pvCustomData)->SeverityThreshold;

    m_bSuppressDebugMessages = ((PLOG_SETUPLOG_FILTER_PROV_INIT_DATA)pvCustomData)->SuppressDebugMessages;

    return logOk;
}

LOGRESULT
CStandardSetupLogFilter::Process(ILogContext * pLogContext)
{
    if(m_uiSeverityFieldNumber == UNDEFINED_FIELD_INDEX){
        return logOk;
    }

    DWORD dwSeverityLevel = pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Dword;
    ASSERT(LT_DWORD == pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Type);

    BOOL bDbg;
    if(!pIsLogSeverityCorrect(dwSeverityLevel, &bDbg)){
        return logError;
    }

    if(bDbg){
        if(m_bSuppressDebugMessages){
            return logDoNotContinue;
        }
    }
    else{
        if(((LOG_SETUPLOG_SEVERITY)dwSeverityLevel) > m_SeverityThreshold){
            return logDoNotContinue;
        }
    }

    return logOk;
}

CStandardSetupLogFormatter::CStandardSetupLogFormatter(
    VOID
    )
{
    m_uiSeverityFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiMessageFieldNumber = UNDEFINED_FIELD_INDEX;
}

LOGRESULT
CStandardSetupLogFormatter::Init(
    IN PVOID pvCustomData,
    IN ILogContext * pLogContext
    )
{
    ASSERT(pLogContext);
    if(!pvCustomData){
        return logError;
    }

    {
        FIELD_VALIDATION_DATA
            fieldsInfo[] =  {
                                {
                                    ((PLOG_SETUPLOG_FORMAT_PROV_INIT_DATA)pvCustomData)->SeverityFieldName,
                                    LT_DWORD,
                                    &m_uiSeverityFieldNumber,
                                    FALSE
                                },

                                {
                                    ((PLOG_SETUPLOG_FORMAT_PROV_INIT_DATA)pvCustomData)->MessageFieldName,
                                    LT_SZ,
                                    &m_uiMessageFieldNumber,
                                    TRUE
                                }
                            };

        if(!pFieldValidation(pLogContext, fieldsInfo, sizeof(fieldsInfo) / sizeof(fieldsInfo[0]))){
            return logError;
        };
    }

    if(!pLogContext->PreAllocBuffer(DEFAULT_MEMORY_SIZE, 0)){
        return logError;
    }

    return logOk;
}

LOGRESULT
CStandardSetupLogFormatter::Process(
    IN ILogContext * pLogContext
    )
{
    PCWSTR pMessage;
    PCWSTR pSeverity;
    UINT size;

    ASSERT(UNDEFINED_FIELD_INDEX == m_uiSeverityFieldNumber || (LT_DWORD == pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Type));
    ASSERT(LT_SZ == pLogContext->GetFieldValue(m_uiMessageFieldNumber)->Value.Type);
    
    pMessage = pLogContext->GetFieldValue(m_uiMessageFieldNumber)->Value.String;
    if(!pMessage){
        ASSERT(pMessage);
        return logError;
    }

    size = wcslen(pMessage);

    pSeverity = NULL;
    if(UNDEFINED_FIELD_INDEX != m_uiSeverityFieldNumber){
        ASSERT(LT_DWORD == pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Type);
        pSeverity = pGetStandardLogSeverityString(
                            pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Dword);

        size += wcslen(pSeverity);
    }

    size += 3;//strlen("/r/n/0");
    size *= sizeof(CHAR);

    PSTR pBuffer = (PSTR)pLogContext->AllocBuffer(size, NULL);

    if(pSeverity){
        sprintf(pBuffer, "%-11S %S\r\n", pSeverity, pMessage);
    }
    else{
        sprintf(pBuffer, "%S\r\n", pMessage);
    }

    pLogContext->ReAllocBuffer(strlen(pBuffer) * sizeof(pBuffer[0]), NULL);

    return logOk;
}

CFileDevice::~CFileDevice(
    VOID
    )
{
    m_File.Close();
    if(m_pPath){
        FREE(m_pPath);
    }
}

LOGRESULT
CFileDevice::Init(
    IN PVOID pvCustomData,
    IN ILogContext * pLogContext
    )
{
    UINT Size;
    BOOL bAlreadyExist;

    if(!pvCustomData){
        return logError;
    }

    if(!((PLOG_DEVICE_PROV_INIT_DATA)pvCustomData)->PathName){
        return logError;
    }

    Size = wcslen(((PLOG_DEVICE_PROV_INIT_DATA)pvCustomData)->PathName);

    if(!Size){
        return logError;
    }

    bAlreadyExist = FALSE;
    if(!m_File.Open(((PLOG_DEVICE_PROV_INIT_DATA)pvCustomData)->PathName,
                    TRUE,
                    ((PLOG_DEVICE_PROV_INIT_DATA)pvCustomData)->dwFlags&DEVICE_CREATE_NEW,
                    ((PLOG_DEVICE_PROV_INIT_DATA)pvCustomData)->dwFlags&DEVICE_WRITE_THROUGH,
                    &bAlreadyExist)){
        return logError;
    }

    if(m_pPath){
        FREE(m_pPath);
    }

    m_pPath = (PWSTR)MALLOC((Size + 1) * sizeof(m_pPath[0]));

    wcscpy(m_pPath, ((PLOG_DEVICE_PROV_INIT_DATA)pvCustomData)->PathName);
//    wcslwr(m_pPath);

    return bAlreadyExist? logAlreadyExist: logOk;
}

LOGRESULT
CFileDevice::Process(
    IN ILogContext * pLogContext
    )
{
    UINT Size = 0;
    PVOID pBuffer = pLogContext->GetBuffer(&Size, NULL);
    if(!pBuffer || !Size){
        return logContinue;
    }

    m_File.Append(pBuffer, Size);

    return logOk;
}

CDebugFormatterAndDevice::CDebugFormatterAndDevice(
    VOID
    )
{
    m_uiSeverityFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiMessageFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiConditionFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiSourceLineFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiSourceFileFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiSourceFunctionFieldNumber = UNDEFINED_FIELD_INDEX;
}

LOGRESULT
CDebugFormatterAndDevice::Init(
    IN PVOID pvCustomData,
    IN ILogContext * pLogContext
    )
{
    ASSERT(pLogContext);
    if(!pvCustomData){
        return logError;
    }

    {
        FIELD_VALIDATION_DATA
            fieldsInfo[] =  {
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SeverityFieldName,
                                    LT_DWORD,
                                    &m_uiSeverityFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->MessageFieldName,
                                    LT_SZ,
                                    &m_uiMessageFieldNumber,
                                    TRUE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->ConditionFieldName,
                                    LT_SZ,
                                    &m_uiConditionFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SourceLineFieldName,
                                    LT_DWORD,
                                    &m_uiSourceLineFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SourceFileFieldName,
                                    LT_SZ,
                                    &m_uiSourceFileFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SourceFunctionFieldName,
                                    LT_SZ,
                                    &m_uiSourceFunctionFieldNumber,
                                    FALSE
                                },
                            };
        if(!pFieldValidation(pLogContext, fieldsInfo, sizeof(fieldsInfo) / sizeof(fieldsInfo[0]))){
            return logError;
        }
    }

    if(!pLogContext->PreAllocBuffer(DEFAULT_MEMORY_SIZE, 0)){
        return logError;
    }

    return logOk;
}

LOGRESULT CDebugFormatterAndDevice::Process(
    IN ILogContext * pLogContext
    )
{
    PCWSTR pMessage;
    PCWSTR pSeverity;
    PCWSTR pFileName;
    PCWSTR pFunctionName;
    PCWSTR pCondition = NULL;

    DWORD  dwSourceLineNumber;

    UINT   size;

    BOOL   bAssert = FALSE;

    pMessage = pLogContext->GetFieldValue(m_uiMessageFieldNumber)->Value.String;
    if(!pMessage){
        ASSERT(pMessage);
        return logError;
    }
    size = wcslen(pMessage);

    if(UNDEFINED_FIELD_INDEX != m_uiSeverityFieldNumber){
        ASSERT(LT_DWORD == pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Type);
        DWORD dwSeverityLevel = pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Dword;
        pSeverity = pGetStandardLogSeverityString(dwSeverityLevel);

        if(LOG_ASSERT == dwSeverityLevel ||
           DBG_ASSERT == dwSeverityLevel){
            pCondition = pLogContext->GetFieldValue(m_uiConditionFieldNumber)->Value.String;
            bAssert = TRUE;
            if(pCondition){
                size += wcslen(pSeverity);
            }
            else{
                ASSERT(pCondition);
            }
        }

        size += wcslen(pSeverity);
    }

    pFunctionName = pLogContext->GetFieldValue(m_uiSourceFunctionFieldNumber)->Value.String;
    pFileName = pLogContext->GetFieldValue(m_uiSourceFileFieldNumber)->Value.String;
    if(pFileName){
        size += wcslen(pFileName);
        if(pFunctionName){
            size += wcslen(pFunctionName);
        }
    }

    size += DEBUG_STRING_DEFAULT_PADDING_SIZE;//strlen("(%d) : /r/n/t/r/n/0");
    size *= sizeof(CHAR);

    PSTR pBuffer = (PSTR)pLogContext->AllocBuffer(size, NULL);
    pBuffer[0] = '\0';

    dwSourceLineNumber = pLogContext->GetFieldValue(m_uiSourceLineFieldNumber)->Value.Dword;
    if(pFileName){
        if(pFunctionName){
            sprintf(pBuffer, "%S(%d) : %S\r\n\t", pFileName, dwSourceLineNumber, pFunctionName);
        }
        else{
            sprintf(pBuffer, "%S(%d) : ", pFileName, dwSourceLineNumber);
        }
    }


    if(pSeverity){
        if(pCondition){
            sprintf(pBuffer, "%s%-S(%S)\t%S\r\n", pBuffer, pSeverity, pCondition, pMessage);
        }
        else{
            sprintf(pBuffer, "%s%-20S%S\r\n", pBuffer, pSeverity, pMessage);
        }
    }
    else{
        sprintf(pBuffer, "%s%S\r\n", pBuffer, pMessage);
    }

    OutputDebugStringA(pBuffer);

    pLogContext->FreeBuffer();

    return logDoNotContinue;
}

CDebugFilter::CDebugFilter(
    VOID
    )
{
    m_uiSeverityFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiMessageFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiConditionFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiSourceLineFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiSourceFileFieldNumber = UNDEFINED_FIELD_INDEX;
    m_uiSourceFunctionFieldNumber = UNDEFINED_FIELD_INDEX;
    if(!GetModuleFileNameA(NULL, m_ProgramName, MAX_PATH)){
        strcpy(m_ProgramName, "<program name unknown>");
    }
}

LOGRESULT
CDebugFilter::Init(
    IN PVOID pvCustomData,
    IN ILogContext * pLogContext
    )
{
    ASSERT(pLogContext);
    if(!pvCustomData){
        return logError;
    }

    {
//            PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA initStruct =
//                    (PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData;

        FIELD_VALIDATION_DATA
            fieldsInfo[] =  {
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SeverityFieldName,
                                    LT_DWORD,
                                    &m_uiSeverityFieldNumber,
                                    TRUE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->MessageFieldName,
                                    LT_SZ,
                                    &m_uiMessageFieldNumber,
                                    TRUE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->ConditionFieldName,
                                    LT_SZ,
                                    &m_uiConditionFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SourceLineFieldName,
                                    LT_DWORD,
                                    &m_uiSourceLineFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SourceFileFieldName,
                                    LT_SZ,
                                    &m_uiSourceFileFieldNumber,
                                    FALSE
                                },
                                {
                                    ((PLOG_DEBUG_FORMAT_AND_DEVICE_PROV_INIT_DATA)pvCustomData)->SourceFunctionFieldName,
                                    LT_SZ,
                                    &m_uiSourceFunctionFieldNumber,
                                    FALSE
                                },
                            };
        if(!pFieldValidation(pLogContext, fieldsInfo, sizeof(fieldsInfo) / sizeof(fieldsInfo[0]))){
            return logError;
        }
    }

    if(!pLogContext->AllocBuffer(DEFAULT_MEMORY_SIZE, 0)){
        return logError;
    }

    return logOk;
}

LOGRESULT
CDebugFilter::Process(
    IN ILogContext * pLogContext
    )
{
    PCWSTR pMessage;
    PCWSTR pSeverity;
    PCWSTR pFileName;
    PCWSTR pFunctionName;
    PCWSTR pCondition = NULL;

    DWORD  dwSourceLineNumber;

    UINT   size;

    BOOL   bAssert = FALSE;

    LOGRESULT result;

    pMessage = pLogContext->GetFieldValue(m_uiMessageFieldNumber)->Value.String;
    if(!pMessage){
        ASSERT(pMessage);
        return logError;
    }
    size = wcslen(pMessage);

    if(UNDEFINED_FIELD_INDEX == m_uiSeverityFieldNumber){
        return logError;
    }

    ASSERT(LT_DWORD == pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Type);
    DWORD dwSeverityLevel = pLogContext->GetFieldValue(m_uiSeverityFieldNumber)->Value.Dword;
    pSeverity = pGetStandardLogSeverityString(dwSeverityLevel);

    if(LOG_ASSERT == dwSeverityLevel ||
       DBG_ASSERT == dwSeverityLevel){
        pCondition = pLogContext->GetFieldValue(m_uiConditionFieldNumber)->Value.String;
        bAssert = TRUE;
        if(pCondition){
            size += wcslen(pSeverity);
        }
        else{
            ASSERT(pCondition);
        }
    }

    size += wcslen(pSeverity);

    pFunctionName = pLogContext->GetFieldValue(m_uiSourceFunctionFieldNumber)->Value.String;
    pFileName = pLogContext->GetFieldValue(m_uiSourceFileFieldNumber)->Value.String;
    if(pFileName){
        size += wcslen(pFileName);
        if(pFunctionName){
            size += wcslen(pFunctionName);
        }
    }

    size += DEBUG_STRING_DEFAULT_PADDING_SIZE;
    size *= sizeof(CHAR);

    PSTR pBuffer = (PSTR)pLogContext->AllocBuffer(size, NULL);
    pBuffer[0] = '\0';

    dwSourceLineNumber = pLogContext->GetFieldValue(m_uiSourceLineFieldNumber)->Value.Dword;

    if(_snprintf(pBuffer, size,
                 "Debug %s!%S%S\n\nProgram: %s%S%S%S%d%S%S%S%S%S"
                 "\n\n(Press Retry to debug the application)",
                 "Assertion Failed",
                 pMessage? L"\n\n": L"",
                 pMessage? pMessage: L"",
                 m_ProgramName,
                 pFileName? L"\nFile: ": L"",
                 pFileName? pFileName: L"",
                 dwSourceLineNumber ? L"\nLine: ": L"",
                 dwSourceLineNumber,
                 pFunctionName? L"\nFunction: ": L"",
                 pFunctionName? pFunctionName: L"",
                 pCondition? L"\n\n": L"",
                 pCondition? L"Expression: ": L"",
                 pCondition? pCondition : L"") < 0){
        strcpy(pBuffer, "Too Long Message");
    }

    if(bAssert){
        result = ShowAssert(pBuffer);
    }
    else{
        result = logContinue;
    }

    pLogContext->FreeBuffer();

    return result;
}

LOGRESULT
CDebugFilter::ShowAssert(
    IN PCSTR pMessage
    )
{
    HWND hWndParent = GetActiveWindow();
    if(hWndParent != NULL){
        hWndParent = GetLastActivePopup(hWndParent);
    }

    MSG msg;
    BOOL bQuit = PeekMessage(&msg, NULL, WM_QUIT, WM_QUIT, PM_REMOVE);
    int res = MessageBoxA(hWndParent,
                          pMessage,
                          "Assertion Failed!",
                          MB_TASKMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND);
    if(bQuit){
        PostQuitMessage((INT) msg.wParam);
    }

    if(IDIGNORE == res){
        return logContinue;
    }

    if(IDRETRY == res){
        return logBreakPoint;
    }

    return logAbortProcess;
}

LOGRESULT
CXMLLogFormatter::Init(
    IN  PVOID pvCustomData,
    IN  ILogContext * pLogContext
    )
{
    strcpy(m_xmlDataFormatString, "<z:row");
    for(UINT i = 0, iLen = pLogContext->GetFieldsCount(); i < iLen; i++){
        PLOG_FIELD_VALUE pField = pLogContext->GetFieldValue(i);
        if(0 > _snprintf(m_xmlDataFormatString,
                         sizeof(m_xmlDataFormatString) / sizeof(m_xmlDataFormatString[0]),
                         "%s %S=\"%%%c\"",
                         m_xmlDataFormatString,
                         pField->Name,
                         (LT_DWORD == pField->Value.Type)? 'd': 'S')){
            return logError;
        }
    }
    strcat(m_xmlDataFormatString, "/>\n");

    return logOk;
}

LOGRESULT
CXMLLogFormatter::WriteHeader(
    IN PVOID pvCustomData,
    IN ILogContext * pLogContext
    )
{
    ASSERT(pLogContext);

    CHAR * xmlHeader = (CHAR *)pLogContext->AllocBuffer(XML_HEADER_INITIAL_SIZE, 0);//BUG

    strcpy(xmlHeader, "<xml xmlns:s=\"uuid:BDC6E3F0-6DA3-11d1-A2A3-00AA00C14882\"\n xmlns:dt=\"uuid:C2F41010-65B3-11d1-A29F-00AA00C14882\"\n xmlns:rs=\"urn:schemas-microsoft-com:rowset\"\n xmlns:z=\"#RowsetSchema\">\n");
    strcat(xmlHeader, "<s:Schema id=\"RowsetSchema\">\n");
    strcat(xmlHeader, "<s:ElementType name=\"row\" content=\"eltOnly\" rs:updatable=\"true\">\n");

    for(UINT i = 0, iLen = pLogContext->GetFieldsCount(); i < iLen; i++){
        PLOG_FIELD_VALUE pField = pLogContext->GetFieldValue(i);
        sprintf(xmlHeader,
                "%s<s:AttributeType name=\"%S\" rs:number=\"%d\">\n""<s:datatype dt:type=\"%s\"/>\n""</s:AttributeType>\n",
                xmlHeader, pField->Name, i,
                (LT_DWORD == pField->Value.Type)? "int": "string");
    }

    strcat(xmlHeader, "</s:ElementType>\n");
    strcat(xmlHeader, "</s:Schema>\n");
    strcat(xmlHeader, "<rs:data>\n");

    pLogContext->ReAllocBuffer(strlen(xmlHeader), 0);

    return logOk;
}

LOGRESULT
CXMLLogFormatter::Process(
    IN ILogContext * pLogContext
    )
{
    CHAR * xmlData = (CHAR *)pLogContext->ReAllocBuffer(XML_HEADER_INITIAL_SIZE, 0);//BUG

    PVOID * pValues = (PVOID *)_alloca(pLogContext->GetFieldsCount() * sizeof(PVOID));

    for(UINT i = 0, iLen = pLogContext->GetFieldsCount(); i < iLen; i++){
        PLOG_FIELD_VALUE pField = pLogContext->GetFieldValue(i);
        pValues[i] = pField->Value.PVoid;
    }

    va_list args = (char *)(pValues);
    vsprintf(xmlData, m_xmlDataFormatString, args);
    va_end (args);

    pLogContext->ReAllocBuffer(strlen(xmlData), 0);

    return logOk;
}

VOID
CXMLLogFormatter::PreProcess(
    IN  ILogContext * pLogContext,
    IN  BOOL bFirstInstance
    )
{
    if(bFirstInstance){
        WriteHeader(NULL, pLogContext);
    }
}

VOID
CXMLLogFormatter::PreDestroy(
    IN ILogContext * pLogContext,
    IN BOOL bLastInstance
    )
{
    if(bLastInstance){
#define XML_END_OF_FILE "</rs:data>\n</xml>\n"
        PSTR pBuffer = (PSTR)pLogContext->AllocBuffer(strlen(XML_END_OF_FILE) + 1, 0);
        strcpy(pBuffer, XML_END_OF_FILE);
        pLogContext->ReAllocBuffer(strlen(pBuffer), 0);
    }
    else{
        pLogContext->AllocBuffer(0, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\pchw\empty.c ===
#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\sysfunc.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Declaration of helper classes.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "mem.h"

#ifdef DEBUG
inline void Assert(PCSTR pCondition)
{
    MessageBoxA(NULL, pCondition, "Error", MB_OK);
#ifdef _X86_
    __asm int 3
#else
    DebugBreak();
#endif
}

#undef ASSERT
#define ASSERT(x)  {if(!(x)){Assert(#x);}}
#else
#undef ASSERT
#define ASSERT(x)
#endif

class CMutualExclusionObject
{
    HANDLE  m_hHandle;
    UINT    m_SpinCount;
public:
    CMutualExclusionObject(){
        m_hHandle = NULL;
        m_SpinCount = 0;
    }
    ~CMutualExclusionObject(){
            Close();
    }

    BOOL Open(PCWSTR pNameOfObject,
              BOOL bInitialOwnership,
              UINT SpinCount = 0);

    VOID Acquiry();
    VOID Release();

    VOID Close();
};

class CSharedMemory
{
    HANDLE m_hHandle;
    PVOID  m_ViewOfSection;
public:
    CSharedMemory(){
        m_hHandle = NULL;
        m_ViewOfSection = NULL;
    }

    ~CSharedMemory(){
        Close();
    }

    BOOL    Open(PCWSTR pNameOfObject, UINT uiInitialSizeOfMapView, IN BOOL * pAlreadyExist);
    PVOID   GetMapOfView(){return m_ViewOfSection;}
    VOID    Close();
};

class CBuffer
{
    PVOID m_pvBuffer;
    UINT  m_uiSize;
    UINT  m_uiUsedSize;
public:
    CBuffer() : m_pvBuffer(NULL), m_uiSize(0), m_uiUsedSize(0){};
    ~CBuffer(){
        if(m_pvBuffer){
            HeapFree (GetProcessHeap(), 0, m_pvBuffer); //FREE(m_pvBuffer);
        }
    }

    PVOID   GetBuffer(){return m_pvBuffer;}
    UINT    GetSize(){return m_uiUsedSize;}
    VOID    Free()
    {
        m_uiUsedSize = 0;
        /*if m_uiSize > THRESHOLD then reallocate with THRESHOLD*/
    }

    PVOID Allocate(UINT uiSize);
    PVOID ReAllocate(UINT uiSize);
    BOOL  PreAllocate(UINT uiSize);
};


class CSharedAccessFile
{
    HANDLE m_hHandle;
public:
    CSharedAccessFile() : m_hHandle(INVALID_HANDLE_VALUE){}
    ~CSharedAccessFile(){Close();}

    BOOL Open(PCWSTR    pFilePath,
              BOOL      SharedWriteAccess,
              BOOL      CreateAlwaysNewIfPossible,
              BOOL      bWriteThrough,
              BOOL  *   pbAlreadyOpened);
    VOID Close();

    BOOL Append(PVOID pBuffer, UINT Size);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\sysfunc.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Implementation of helper classes.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#include "log.h"
#include "log_man.h"

#include "functions.h"

BOOL 
CMutualExclusionObject::Open(
    IN PCWSTR pNameOfObject, 
    IN BOOL bInitialOwnership, 
    IN UINT SpinCount
    )
{
    m_hHandle = g_OpenMutex(pNameOfObject);
    if(m_hHandle){
        if(bInitialOwnership){
            Acquiry();
        }
        return TRUE;
    }
    
    m_hHandle = g_CreateMutex(pNameOfObject, bInitialOwnership);
    if(!m_hHandle){
        return FALSE;
    }

    m_SpinCount = (g_GetProcessorsNumber() > 1)? SpinCount: 0;

    return TRUE;
}

VOID 
CMutualExclusionObject::Close(
    VOID
    )
{
    if(!m_hHandle){
        return;
    }

    g_CloseHandle(m_hHandle);

    m_hHandle = NULL;
    m_SpinCount = 0;
}

VOID 
CMutualExclusionObject::Acquiry(
    VOID
    )
{
    if(!m_hHandle){
        ASSERT(m_hHandle);
        return;
    }
    
    for(UINT i = 0; i < m_SpinCount; i++){
        if(WAIT_TIMEOUT != g_WaitForSingleObject(m_hHandle, 0)){
            return;
        }
    }
    
    g_WaitForSingleObject(m_hHandle, INFINITE);
}

VOID 
CMutualExclusionObject::Release(
    VOID
    )
{
    if(!m_hHandle){
        ASSERT(m_hHandle);
        return;
    }
    g_ReleaseMutex(m_hHandle);
}

BOOL 
CSharedMemory::Open(
    IN PCWSTR pNameOfObject, 
    IN UINT uiInitialSizeOfMapView, 
    IN BOOL * pAlreadyExist         OPTIONAL
    )
{
    m_hHandle = g_OpenSharedMemory(pNameOfObject);
    if(m_hHandle){
        if(pAlreadyExist){
            *pAlreadyExist = TRUE;
        }
    }
    else{
        m_hHandle = g_CreateSharedMemory(uiInitialSizeOfMapView, pNameOfObject);
        if(!m_hHandle){
            return FALSE;
        }
        
        if(pAlreadyExist){
            *pAlreadyExist = FALSE;
        }
    }

    m_ViewOfSection = g_MapSharedMemory(m_hHandle);
    if(!m_ViewOfSection){
        Close();
        return FALSE;
    }
    
    return TRUE;
}

VOID CSharedMemory::Close(
    VOID
    )
{
    if(m_hHandle){
        if(m_ViewOfSection){
            g_UnMapSharedMemory(m_ViewOfSection);
            m_ViewOfSection = NULL;
        }
        g_CloseHandle(m_hHandle);
        m_hHandle = NULL;
    }
}

PVOID 
CBuffer::Allocate(
    IN UINT uiSize
    )
{
#define DEFAULT_SIZE    (1<<12)
    if(!m_pvBuffer){
        UINT uiTempSize = uiSize? uiSize: DEFAULT_SIZE;
        m_pvBuffer = MALLOC(uiSize);
        if(!m_pvBuffer){
            return FALSE;
        }
        m_uiSize = uiSize;
        m_uiUsedSize = uiTempSize;
    }
    else
    {
        if(m_uiSize < uiSize){
            FREE(m_pvBuffer);
            m_pvBuffer = MALLOC(uiSize);
            if(!m_pvBuffer){
                m_uiUsedSize = m_uiSize = 0;
                return FALSE;
            }
            m_uiUsedSize = m_uiSize = uiSize;
        }
        else{
            m_uiUsedSize = uiSize;
        }
    }
    
    return m_pvBuffer;
}

BOOL 
CBuffer::PreAllocate(
    IN UINT uiSize
    )
{
    if(Allocate(uiSize)){
        Allocate(0);
        return TRUE;
    }

    return FALSE;
}

PVOID 
CBuffer::ReAllocate(
    IN UINT uiSize
    )
{
    ASSERT(uiSize);

    if(!m_pvBuffer){
        return Allocate(uiSize);
    }

    if(m_uiSize < uiSize){
        PVOID pvBuffer = REALLOC(m_pvBuffer, uiSize);
        if(!pvBuffer){
            return NULL;
        }
        m_pvBuffer = pvBuffer;
        m_uiUsedSize = m_uiSize = uiSize;
    }
    else{
        m_uiUsedSize = uiSize;
    }

    return m_pvBuffer;
}

BOOL 
CSharedAccessFile::Open(
    IN PCWSTR   pFilePath, 
    IN BOOL     SharedWriteAccess, 
    IN BOOL     CreateAlwaysNewIfPossible, 
    IN BOOL     bWriteThrough, 
    IN BOOL *   pbAlreadyOpened
    )
{
    BOOL bAlreadyOpened = FALSE;

    m_hHandle = g_CreateSharedFile(pFilePath, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL);

    if(INVALID_HANDLE_VALUE != m_hHandle){
        g_CloseHandle(m_hHandle);
        bAlreadyOpened = FALSE;
    }
    else{
        bAlreadyOpened = (ERROR_SHARING_VIOLATION == GetLastError());
    }
    
    if(pbAlreadyOpened){
        *pbAlreadyOpened = bAlreadyOpened;
    }

    m_hHandle = g_CreateSharedFile(pFilePath, 
                                   SharedWriteAccess? FILE_SHARE_WRITE | FILE_SHARE_READ: 0, 
                                   (CreateAlwaysNewIfPossible && !bAlreadyOpened)? CREATE_ALWAYS: OPEN_ALWAYS, 
                                   FILE_ATTRIBUTE_NORMAL | (bWriteThrough? FILE_FLAG_WRITE_THROUGH: 0));
    
    if(INVALID_HANDLE_VALUE == m_hHandle){
        return FALSE;
    }
    
    return TRUE;
}

VOID 
CSharedAccessFile::Close()
{
    if(INVALID_HANDLE_VALUE != m_hHandle){
        g_CloseHandle(m_hHandle);
        m_hHandle = INVALID_HANDLE_VALUE;
    }
}

BOOL 
CSharedAccessFile::Append(
    IN PVOID pBuffer, 
    IN UINT Size
    )
{
    DWORD dwNumberOfBytesWritten;
    ASSERT(pBuffer && Size);
    
    g_SetFilePointer(m_hHandle, 0, FILE_END);
    BOOL bResult = g_WriteFile(m_hHandle, pBuffer, Size, &dwNumberOfBytesWritten);
    
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\templ.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Helper templates implementation.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "sysfunc.h"

#define DEFAULT_GROW_SIZE   100

template<class T> class CPtrList
{
    T* m_pPtrArray;
    UINT m_uiNumberOfElements;
    UINT m_uiEnumIndex;

    CBuffer m_Buffer;
public:
    CPtrList(UINT uiInitialSize = DEFAULT_GROW_SIZE){
        if(!uiInitialSize){
            uiInitialSize = DEFAULT_GROW_SIZE;
        }
        
        m_uiEnumIndex = 0;
        m_uiNumberOfElements = 0;
        m_pPtrArray = NULL;
        SetSize(uiInitialSize);
        ASSERT(m_pPtrArray);
    }
    
    ~CPtrList()
    {
        m_Buffer.Free();
    }
    
    UINT GetSize(){
        UINT uiNumberOfActualItems = 0;
        for(UINT i = 0; i < m_uiNumberOfElements; i++){
            if(m_pPtrArray[i]){
                uiNumberOfActualItems++;
            }
        }

        return uiNumberOfActualItems;
    }
    
    BOOL SetSize(UINT uiNewSize)
    {
        T* pPtrArray = (T*)m_Buffer.ReAllocate(uiNewSize * sizeof(void*));
        if(!pPtrArray){
            return FALSE;
        }
        
        if(m_uiNumberOfElements < uiNewSize){
            memset(pPtrArray + m_uiNumberOfElements, 0, (uiNewSize - m_uiNumberOfElements) * sizeof(void*));
        }
        
        m_uiNumberOfElements = uiNewSize;
        m_pPtrArray = pPtrArray;

        return TRUE;
    }
    
    BOOL Add(T pPtr)
    {
        ASSERT(m_pPtrArray);
        
        if(!pPtr){
            return FALSE;
        }
        
        for(UINT i = 0; i < m_uiNumberOfElements; i++){
            if(m_pPtrArray[i] == pPtr){
                return TRUE;
            }
        }
        
        UINT uiEmptyPlace;
        for(i = 0; i < m_uiNumberOfElements; i++){
            if(!m_pPtrArray[i]){
                uiEmptyPlace = i;
                break;
            }
        }


        if(i == m_uiNumberOfElements){
            if(!SetSize(m_uiNumberOfElements + 1)){
                return FALSE;
            }
            uiEmptyPlace = i;
        }
        
        m_pPtrArray[uiEmptyPlace] = pPtr;

        return TRUE;
    }
    
    VOID RemoveAll()
    {
        ASSERT(m_pPtrArray);

        if(!m_pPtrArray){
            return;
        }
        
        memset(m_pPtrArray, 0, sizeof(void*) * m_uiNumberOfElements);
        m_uiNumberOfElements = NULL;
    }

    BOOL Remove(T pItemPtr)
    {
        ASSERT(m_pPtrArray);

        if(!pItemPtr){
            return FALSE;
        }
        
        for(UINT i = 0; i < m_uiNumberOfElements; i++){
            if(m_pPtrArray[i] == pItemPtr){
                m_pPtrArray[i] = NULL;
                return TRUE;
            }
        }

        ASSERT(FALSE);

        return FALSE;
    }
    
    T BeginEnum()
    {
        m_uiEnumIndex = 0;
        return Next();
    }
    
    T Next()
    {
        for(m_uiEnumIndex; m_uiEnumIndex < m_uiNumberOfElements; m_uiEnumIndex++){
            if(m_pPtrArray[m_uiEnumIndex]){
                return m_pPtrArray[m_uiEnumIndex++];
            }
        }

        return NULL;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\sysprim.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Environment independed system functions implementation for Win32, 

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#include "pch.h"

#include "sysfunc.h"
#include "functions.h"
#include "windows.h"

MY_OPENMUTEX            g_OpenMutex = NULL;
MY_CREATEMUTEX          g_CreateMutex = NULL;
MY_RELEASEMUTEX         g_ReleaseMutex = NULL;
MY_WAITFORSINGLEOBJECT  g_WaitForSingleObject = NULL;
MY_CLOSEHANDLE          g_CloseHandle = NULL;
MY_OPENSHAREDMEMORY     g_OpenSharedMemory = NULL;
MY_CREATESHAREDMEMORY   g_CreateSharedMemory = NULL;
MY_MAPSHAREDMEMORY      g_MapSharedMemory = NULL;
MY_UNMAPSHAREDMEMORY    g_UnMapSharedMemory = NULL;
MY_CREATESHAREDFILE     g_CreateSharedFile = NULL;
MY_SETFILEPOINTER       g_SetFilePointer = NULL;
MY_WRITEFILE            g_WriteFile = NULL;
MY_GETPROCESSORNUMBER   g_GetProcessorsNumber = NULL;

VOID ReleaseMutexWin32(HANDLE hObject)
{
    ReleaseMutex(hObject);
}
DWORD WaitForSingleObjectWin32(HANDLE hObject, DWORD dwTimeout)
{
    return WaitForSingleObject(hObject, dwTimeout);
}
VOID CloseHandleWin32(HANDLE hObject)
{
    CloseHandle(hObject);
}
PVOID MapSharedMemoryWin32(HANDLE hObject)
{
    return MapViewOfFile(hObject, FILE_MAP_ALL_ACCESS, 0, 0, 0);
}

BOOL UnMapSharedMemoryWin32(PVOID pSharedMemory)
{
    return UnmapViewOfFile(pSharedMemory);
}

BOOL SetFilePointerWin32(HANDLE hObject, UINT uiOffset, DWORD dwMoveMethod)
{
    return SetFilePointer(hObject, uiOffset, NULL, dwMoveMethod);
}

BOOL WriteFileWin32(HANDLE hObject, PVOID pBuffer, UINT uiNumberOfBytesToWrite, DWORD * pdwNumberOfBytesWritten)
{
    return WriteFile(hObject, pBuffer, uiNumberOfBytesToWrite, pdwNumberOfBytesWritten, NULL);
}

//
// Ansi version
//

HANDLE OpenMutexWin32A(PCWSTR pObjectName)
{
    ASSERT(pObjectName);
    
    CBuffer buffer;buffer.Allocate(wcslen(pObjectName) + 2);
    
    PSTR pBuffer = (PSTR)buffer.GetBuffer();
    sprintf(pBuffer, "%S", pObjectName);
    
    return OpenMutexA(MUTEX_ALL_ACCESS, FALSE, pBuffer);
}

HANDLE CreateMutexWin32A(PCWSTR pObjectName, BOOL bInitialOwnership)
{
    ASSERT(pObjectName);
    
    CBuffer buffer;buffer.Allocate(wcslen(pObjectName) + 2);
    
    PSTR pBuffer = (PSTR)buffer.GetBuffer();
    sprintf(pBuffer, "%S", pObjectName);
    
    return CreateMutexA(NULL, bInitialOwnership, pBuffer);
}

HANDLE OpenSharedMemoryWin32A(PCWSTR pObjectName)
{
    ASSERT(pObjectName);
    
    CBuffer buffer;buffer.Allocate(wcslen(pObjectName) + 2);
    
    PSTR pBuffer = (PSTR)buffer.GetBuffer();
    sprintf(pBuffer, "%S", pObjectName);

    return OpenFileMappingA(FILE_MAP_ALL_ACCESS, FALSE, pBuffer);
}

HANDLE CreateSharedMemoryWin32A(UINT uiInitialSizeOfMapView, PCWSTR pObjectName)
{
    ASSERT(pObjectName);
    
    CBuffer buffer;buffer.Allocate(wcslen(pObjectName) + 2);
    
    PSTR pBuffer = (PSTR)buffer.GetBuffer();
    sprintf(pBuffer, "%S", pObjectName);

    return CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE | SEC_COMMIT, 0, uiInitialSizeOfMapView, pBuffer);
}

HANDLE 
CreateSharedFileWin32A(
    IN  PCWSTR pFilePath, 
    IN  DWORD dwShareMode, 
    IN  DWORD dwCreationDisposition, 
    IN  DWORD dwFlagsAndAttributes
    )
{
    ASSERT(pFilePath);
    
    CBuffer buffer;buffer.Allocate(wcslen(pFilePath) + 2);
    
    PSTR pAnsiFilePath = (PSTR)buffer.GetBuffer();
    sprintf(pAnsiFilePath, "%S", pFilePath);

    return CreateFileA(pAnsiFilePath, GENERIC_WRITE | GENERIC_READ, dwShareMode, NULL, dwCreationDisposition, dwFlagsAndAttributes, NULL);
}

//
// Unicode version
//

HANDLE OpenMutexWin32W(PCWSTR pObjectName)
{
    ASSERT(pObjectName);
    
    return OpenMutexW(MUTEX_ALL_ACCESS, FALSE, pObjectName);
}

HANDLE CreateMutexWin32W(PCWSTR pObjectName, BOOL bInitialOwnership)
{
    ASSERT(pObjectName);
    
    return CreateMutexW(NULL, bInitialOwnership, pObjectName);
}

HANDLE OpenSharedMemoryWin32W(PCWSTR pObjectName)
{
    ASSERT(pObjectName);
    
    return OpenFileMappingW(FILE_MAP_ALL_ACCESS, FALSE, pObjectName);
}

HANDLE CreateSharedMemoryWin32W(UINT uiInitialSizeOfMapView, PCWSTR pObjectName)
{
    ASSERT(pObjectName);
    
    return CreateFileMappingW(INVALID_HANDLE_VALUE, 
                              NULL, 
                              PAGE_READWRITE | SEC_COMMIT, 
                              0, 
                              uiInitialSizeOfMapView, 
                              pObjectName);
}

HANDLE 
CreateSharedFileWin32W(
    IN  PCWSTR pFilePath, 
    IN  DWORD dwShareMode, 
    IN  DWORD dwCreationDisposition, 
    IN  DWORD dwFlagsAndAttributes
    )
{
    ASSERT(pFilePath);

    return CreateFileW(pFilePath, 
                       GENERIC_WRITE | GENERIC_READ, 
                       dwShareMode, 
                       NULL, 
                       dwCreationDisposition, 
                       dwFlagsAndAttributes, 
                       NULL);
}

BOOL 
IsSystemNT(
    VOID
    )
{
    static BOOL bSystemIsNT = FALSE;
    static BOOL bFirstTime = TRUE;

    if(bFirstTime){
        bFirstTime = FALSE;
        bSystemIsNT = (GetVersion() < 0x80000000);
    }

    return bSystemIsNT;
}

UINT 
GetProcessorsNumberWin32(
    VOID
    )
{
    SYSTEM_INFO systemInfo;
    GetSystemInfo(&systemInfo);

    return systemInfo.dwNumberOfProcessors;
}

BOOL InitSystemFunctions()
{
    if(IsSystemNT()){
        g_OpenMutex = OpenMutexWin32W;
        g_CreateMutex = CreateMutexWin32W;
        g_OpenSharedMemory = OpenSharedMemoryWin32W;
        g_CreateSharedMemory = CreateSharedMemoryWin32W;
        g_CreateSharedFile = CreateSharedFileWin32W;
    }
    else{
        g_OpenMutex = OpenMutexWin32A;
        g_CreateMutex = CreateMutexWin32A;
        g_OpenSharedMemory = OpenSharedMemoryWin32A;
        g_CreateSharedMemory = CreateSharedMemoryWin32A;
        g_CreateSharedFile = CreateSharedFileWin32A;
    }

    g_ReleaseMutex = ReleaseMutexWin32;
    g_WaitForSingleObject = WaitForSingleObjectWin32;
    g_CloseHandle = CloseHandleWin32;
    g_MapSharedMemory = MapSharedMemoryWin32;
    g_UnMapSharedMemory = UnMapSharedMemoryWin32;
    g_SetFilePointer = SetFilePointerWin32;
    g_WriteFile = WriteFileWin32;              
    g_GetProcessorsNumber = GetProcessorsNumberWin32;
    
    return TRUE;
}

BOOL bInit = InitSystemFunctions();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\pchw\pch.h ===
#pragma warning(push)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\pcha\pch.h ===
#pragma warning(push)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <imagehlp.h>
#include <stdio.h>
#include <time.h>
#include <setupapi.h>

#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\runtime\log\stockpr.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Abstract:

    Declaration of stock Log Providers.

Author:

    Souren Aghajanyan (sourenag) 24-Sep-2001

Revision History:

    <alias> <date> <comments>

--*/

#pragma once

#include "sysfunc.h"

#define UNDEFINED_FIELD_INDEX   ((UINT)-1)
#define DEFAULT_MEMORY_SIZE     (1 << 14)
#define MAX_MSG                 DEFAULT_MEMORY_SIZE
#define DEBUG_STRING_DEFAULT_PADDING_SIZE   ((DEFAULT_MEMORY_SIZE)>>1)

typedef struct tagFIELD_VALIDATION_DATA{
    PCWSTR  FieldName;
    LOGTYPE Type;
    UINT *  FieldIndexPtr;
    BOOL    Mandatory;
}FIELD_VALIDATION_DATA, *PFIELD_VALIDATION_DATA;


class CStandardSetupLogFilter : public ILogProvider
{
    UINT m_uiSeverityFieldNumber;
    LOG_SETUPLOG_SEVERITY m_SeverityThreshold;
    
    BOOL m_bSuppressDebugMessages;
public:
    CStandardSetupLogFilter();
    
    virtual LOG_PROVIDER_TYPE GetType(){return LOG_FILTER_TYPE;};
    virtual VOID GetGUID(GUID *pGUID){if(pGUID){*pGUID = CStandardSetupLogFilter::GetGUID();}};
    
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext);
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance){};
    virtual LOGRESULT Process(ILogContext * pLogContext);
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance){}

    virtual PCWSTR ToString(){return L"StandardSetupLogFilter";};
    virtual VOID DestroyObject(){delete this;}

    static const GUID& GetGUID(){return __uuidof(CStandardSetupLogFilter);}
    static ILogProvider * CreateObject(){return new CStandardSetupLogFilter;}
};

class CStandardSetupLogFormatter : public ILogProvider
{
    UINT m_uiSeverityFieldNumber;
    UINT m_uiMessageFieldNumber;
public:
    CStandardSetupLogFormatter();
    
    virtual LOG_PROVIDER_TYPE GetType(){return LOG_FORMATTER_TYPE;};
    virtual VOID GetGUID(GUID *pGUID){if(pGUID){*pGUID = CStandardSetupLogFormatter::GetGUID();}};
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext);
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance){};
    virtual LOGRESULT Process(ILogContext * pLogContext);
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance){}

    virtual PCWSTR ToString(){return L"StandardSetupLogFormatter";};
    virtual VOID DestroyObject(){delete this;}

    static const GUID& GetGUID(){return __uuidof(CStandardSetupLogFormatter);}
    static ILogProvider * CreateObject(){return new CStandardSetupLogFormatter;}
};

class CFileDevice : public ILogProvider
{
    PWSTR               m_pPath;
    CSharedAccessFile   m_File;
public:
    CFileDevice() : m_File(), m_pPath(NULL){};
    ~CFileDevice();
    
    virtual LOG_PROVIDER_TYPE GetType(){return LOG_DEVICE_TYPE;};
    virtual VOID GetGUID(GUID *pGUID){if(pGUID){*pGUID = CFileDevice::GetGUID();}};
    
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext);
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance){Process(pLogContext);};
    virtual LOGRESULT Process(ILogContext * pLogContext);
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance){Process(pLogContext);}
    
    virtual PCWSTR ToString(){return m_pPath;};
    virtual VOID DestroyObject(){delete this;}

    static const GUID& GetGUID(){return __uuidof(CFileDevice);}
    static ILogProvider * CreateObject(){return new CFileDevice;}
};

class CDebugFormatterAndDevice : public ILogProvider
{
    UINT m_uiSeverityFieldNumber;
    UINT m_uiMessageFieldNumber;
    UINT m_uiConditionFieldNumber;
    UINT m_uiSourceLineFieldNumber;
    UINT m_uiSourceFileFieldNumber;
    UINT m_uiSourceFunctionFieldNumber;
public:
    CDebugFormatterAndDevice();
    
    virtual LOG_PROVIDER_TYPE GetType(){return LOG_FORMATTER_TYPE;};
    virtual VOID GetGUID(GUID *pGUID){if(pGUID){*pGUID = CDebugFormatterAndDevice::GetGUID();}};
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext);
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance){};
    virtual LOGRESULT Process(ILogContext * pLogContext);
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance){}
    
    virtual PCWSTR ToString(){return L"DebugFormatterAndDevice";};
    virtual VOID DestroyObject(){delete this;}

    static const GUID& GetGUID(){return __uuidof(CDebugFormatterAndDevice);}
    static ILogProvider * CreateObject(){return new CDebugFormatterAndDevice;}
};

class CDebugFilter : public ILogProvider
{
    UINT m_uiSeverityFieldNumber;
    UINT m_uiMessageFieldNumber;
    UINT m_uiConditionFieldNumber;
    UINT m_uiSourceLineFieldNumber;
    UINT m_uiSourceFileFieldNumber;
    UINT m_uiSourceFunctionFieldNumber;
    CHAR m_ProgramName[MAX_PATH];

    LOGRESULT ShowAssert(PCSTR pMessage);
public:
    CDebugFilter();
    
    virtual LOG_PROVIDER_TYPE GetType(){return LOG_FILTER_TYPE;};
    virtual VOID GetGUID(GUID *pGUID){if(pGUID){*pGUID = CDebugFilter::GetGUID();}};
    
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext);
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance){};
    virtual LOGRESULT Process(ILogContext * pLogContext);
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance){}

    virtual PCWSTR ToString(){return L"DebugFilter";};
    virtual VOID DestroyObject(){delete this;}

    static const GUID& GetGUID(){return __uuidof(CDebugFilter);}
    static ILogProvider * CreateObject(){return new CDebugFilter;}
};

class CXMLLogFormatter : public ILogProvider
{
    CHAR m_xmlDataFormatString[MAX_MSG];
    
    LOGRESULT WriteHeader(PVOID pvCustomData, ILogContext * pLogContext);
public:
    CXMLLogFormatter(){};
    ~CXMLLogFormatter(){};
    
    virtual LOG_PROVIDER_TYPE GetType(){return LOG_FORMATTER_TYPE;};
    virtual VOID GetGUID(GUID *pGUID){if(pGUID){*pGUID = CXMLLogFormatter::GetGUID();}};
    
    virtual LOGRESULT Init(PVOID pvCustomData, ILogContext * pLogContext);
    virtual VOID      PreProcess(ILogContext * pLogContext, BOOL bFirstInstance);
    virtual LOGRESULT Process(ILogContext * pLogContext);
    virtual VOID      PreDestroy(ILogContext * pLogContext, BOOL bLastInstance);

    virtual PCWSTR ToString(){return L"XMLLogFormatter";};
    virtual VOID DestroyObject(){delete this;}

    static const GUID& GetGUID(){return __uuidof(CXMLLogFormatter);}
    static ILogProvider * CreateObject(){return new CXMLLogFormatter;}
};

#define XML_HEADER_INITIAL_SIZE 10000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\dll.c ===
#include "spsetupp.h"
#pragma hdrstop

HANDLE g_ModuleHandle;


//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain (
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    UNREFERENCED_PARAMETER(Reserved);

    if (Reason == DLL_PROCESS_ATTACH) {
        g_ModuleHandle = DllHandle;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\ctls.c ===
#include "spsetupp.h"
#pragma hdrstop
#include <licdll_i.c>


typedef struct _SPREG_TO_TEXT {
    DWORD FailureCode;
    PCWSTR FailureText;
} SPREG_TO_TEXT, *PSPREG_TO_TEXT;

SPREG_TO_TEXT RegErrorToText[] = {
    { SPREG_SUCCESS,     L"Success"           },
    { SPREG_LOADLIBRARY, L"LoadLibrary"       },
    { SPREG_GETPROCADDR, L"GetProcAddress"    },
    { SPREG_REGSVR,      L"DllRegisterServer" },
    { SPREG_DLLINSTALL,  L"DllInstall"        },
    { SPREG_TIMEOUT,     L"Timed out"         },
    { SPREG_UNKNOWN,     L"Unknown"           },
    { 0,                 NULL                 }
};

UINT
RegistrationQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
/*++

Routine Description:

    Callback routine that is called each time we self-register a file.

Arguments:

    Context - context message passed from parent to caller.

    Notification - specifies an SPFILENOTIFY_*** code, which tells us how
                   to interpret Param1 and Param2.

    Param1 - dependent on notification.

    Param2 - dependent on notification.


Return Value:

    FILEOP_*** code dependent on Notification code.

--*/
{
    PSP_REGISTER_CONTROL_STATUS Status = (PSP_REGISTER_CONTROL_STATUS)Param1;
    PPROGRESS_MANAGER ProgressManager = (PPROGRESS_MANAGER) Context;
    DWORD i, ErrorMessageId;
    PCWSTR p;

    if (Notification == SPFILENOTIFY_STARTREGISTRATION) {
        DEBUGMSG1(DBG_INFO, 
                  "SETUP: file to register is %s...", 
                  Status->FileName);

        return FILEOP_DOIT;

    }

    if (Notification == SPFILENOTIFY_ENDREGISTRATION) {
        if (ProgressManager) {
            PmTick (ProgressManager);
        }
        //
        // the file has been registered, so log failure if necessary
        // Note that we have a special code for timeouts
        //
        switch(Status->FailureCode) {
            case SPREG_SUCCESS:

                DEBUGMSG1(DBG_INFO, 
                          "SETUP: %s registered successfully", 
                          Status->FileName);
                break;
            case SPREG_TIMEOUT:
                LOG1(LOG_ERROR, 
                     USEMSGID(MSG_OLE_REGISTRATION_HUNG), 
                     Status->FileName);
                DEBUGMSG1(DBG_ERROR, 
                          "SETUP: %s timed out during registration", 
                          Status->FileName);
                break;
            default:
                //
                // log an error
                //
                for (i = 0;RegErrorToText[i].FailureText != NULL;i++) {
                    if (RegErrorToText[i].FailureCode == Status->FailureCode) {
                        p = RegErrorToText[i].FailureText;
                        if ((Status->FailureCode == SPREG_LOADLIBRARY) &&
                            (Status->Win32Error == ERROR_MOD_NOT_FOUND)) 
                            ErrorMessageId = MSG_LOG_X_MOD_NOT_FOUND;
                        else 
                        if ((Status->FailureCode == SPREG_GETPROCADDR) &&
                            (Status->Win32Error == ERROR_PROC_NOT_FOUND)) 
                            ErrorMessageId = MSG_LOG_X_PROC_NOT_FOUND;
                        else
                            ErrorMessageId = MSG_LOG_X_RETURNED_WINERR;

                        break;
                    }
                }

                if (!p) {
                    p = L"Unknown";
                    ErrorMessageId = MSG_LOG_X_RETURNED_WINERR;
                }
                LOG1(LOG_ERROR, 
                     USEMSGID(MSG_LOG_OLE_CONTROL_NOT_REGISTERED), 
                     Status->FileName);
                LOG2(LOG_ERROR, 
                     USEMSGID(ErrorMessageId), 
                     p, 
                     Status->Win32Error);
                /*SetuplogError(
                        LogSevError,
                        SETUPLOG_USE_MESSAGEID,
                        MSG_LOG_OLE_CONTROL_NOT_REGISTERED,
                        Status->FileName,
                        NULL,
                        SETUPLOG_USE_MESSAGEID,
                        ErrorMessageId,
                        p,
                        Status->Win32Error,
                        NULL,
                        NULL
                        );*/

                DEBUGMSG1(DBG_ERROR, 
                          "SETUP: %s did not register successfully", 
                          Status->FileName);
        }

        //
        // Verify that the DLL didn't change our unhandled exception filter.
        //
        if( SpsUnhandledExceptionFilter !=
            SetUnhandledExceptionFilter(SpsUnhandledExceptionFilter)) {

            DEBUGMSG1(DBG_INFO, 
                      "SETUP: %ws broke the exception handler.", 
                      Status->FileName);
            MessageBoxFromMessage(
                g_MainDlg,
                MSG_EXCEPTION_FILTER_CHANGED,
                NULL,
                IDS_WINNT_SPSETUP,
                MB_OK | MB_ICONWARNING,
                Status->FileName );
        }

        return FILEOP_DOIT;
    }


    MYASSERT(FALSE);

    return(FILEOP_DOIT);
}


TCHAR szRegistrationPhaseFormat[] = TEXT("Registration.Phase%u");

DWORD
SpsRegistration (
    IN      HINF InfHandle,
    IN      PCTSTR SectionName,
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    TCHAR sectionReg[MAX_PATH];
    DWORD lines, sections, i;
    INFCONTEXT ic;
    DWORD rc;
    DWORD spapiFlags;

    switch (Request) {

    case SfrQueryTicks:
        lines = 0;
        if (SetupFindFirstLine (InfHandle, SectionName, TEXT("RegisterDlls"), &ic)) {
            do {
                sections = SetupGetFieldCount(&ic);
                for (i = 1; i <= sections; i++) {
                    if (SetupGetStringField (&ic, i, sectionReg, MAX_PATH, NULL)) {
                        lines += SetupGetLineCount (InfHandle, sectionReg);
                    }
                }
            } while (SetupFindNextMatchLine (&ic, TEXT("RegisterDlls"), &ic));
        }
        return lines;

    case SfrRun:
        rc = ERROR_SUCCESS;
        //
        // tell SetupAPI to ignore the digital signature of our INF
        //
        spapiFlags = pSetupGetGlobalFlags ();
        pSetupSetGlobalFlags (spapiFlags | PSPGF_NO_VERIFY_INF);
        //
        // allow Setup API to register the files, using our callback to log
        // errors if and when they occur.
        //
        if (!SetupInstallFromInfSection(
                     NULL,
                     InfHandle,
                     SectionName,
                     SPINST_REGSVR| SPINST_REGISTERCALLBACKAWARE,
                     NULL,
                     NULL,
                     0,
                     RegistrationQueueCallback,
                     (PVOID)ProgressManager,
                     NULL,
                     NULL
                     )) {
            rc = GetLastError();
            LOG3(LOG_ERROR, 
                 USEMSGID(MSG_OLE_REGISTRATION_SECTION_FAILURE), 
                 SectionName, 
                 g_SpSetupInfName, 
                 rc);
            LOG2(LOG_ERROR, 
                 USEMSGID(MSG_LOG_X_RETURNED_WINERR), 
                 szSetupInstallFromInfSection, 
                 rc);
            /*SetuplogError(
                    LogSevError,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_OLE_REGISTRATION_SECTION_FAILURE,
                    SectionName,
                    g_SpSetupInfName,
                    rc,
                    NULL,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_X_RETURNED_WINERR,
                    szSetupInstallFromInfSection,
                    rc,
                    NULL,
                    NULL
                    );*/
        }
        //
        // restore tell SetupAPI to ignore the digital signature of our INF
        //
        pSetupSetGlobalFlags (spapiFlags);
        return rc;
    }

    MYASSERT (FALSE);
    return 0;
}

DWORD
SpsRegistrationPhase1 (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    return SpsRegistration (g_SysSetupInf, TEXT("RegistrationCrypto"), Request, ProgressManager);
}

DWORD
SpsRegistrationPhase2 (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    return SpsRegistration (g_SysSetupInf, TEXT("RegistrationPhase1"), Request, ProgressManager);
}

DWORD
SpsRegistrationPhase3 (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    return SpsRegistration (g_SysSetupInf, TEXT("RegistrationPhase2"), Request, ProgressManager);
}


#ifdef _X86_
HRESULT WINAPI SetProductKey(LPCWSTR pszNewProductKey);
#endif

DWORD
SpsRegisterWPA (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    switch (Request) {

    case SfrQueryTicks:
#ifdef _X86_
        return 10;
#else
        return 0;
#endif


#ifdef _X86_
    case SfrRun:
        {
            INFCONTEXT ic;
            TCHAR buffer[MAX_PATH];
            HRESULT hr;

            if (!SetupFindFirstLine (g_SpSetupInf, TEXT("Data"), TEXT("Pid"), &ic) ||
                !SetupGetStringField (&ic, 1, buffer, sizeof(buffer)/sizeof(buffer[0]), NULL)) {

                LOG((
                    LOG_ERROR,
                    "WPA: Unable to read %s from %s section [%s] (rc=%#x)",
                    TEXT("Pid"),
                    g_SpSetupInfName,
                    TEXT("Data"),
                    GetLastError ()
                    ));

                MYASSERT (FALSE);
                return GetLastError ();
            }

            hr = SetProductKey (buffer);
            if (FAILED(hr)) {
                LOG1(LOG_ERROR, "Failed to set pid (hr=%#x)", hr);
            }
            return SUCCEEDED(hr) ? ERROR_SUCCESS : hr;
        }
#endif

    }

    MYASSERT (FALSE);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\debug.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Diagnositc/debug routines for Windows NT Setup module.

Author:

    Ted Miller (tedm) 31-Mar-1995

Revision History:

--*/

#include "spsetupp.h"
#pragma hdrstop

//
// This can be turned on in the debugger so that we get debug spew on free builds.
//
bWriteDebugSpew = FALSE;

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA (g_ModuleHandle, Name, MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}


#endif


VOID
pSetupDebugPrint(
    PWSTR FileName,
    ULONG LineNumber,
    PWSTR TagStr,
    PWSTR FormatStr,
    ...
    )
{
    static WCHAR buf[4096];
    static HANDLE hFile = NULL;
    va_list arg_ptr;
    ULONG Bytes;
    PWSTR s,p;
    PSTR str;
    SYSTEMTIME CurrTime;
    DWORD Result;


    //
    // Note: If hFile is NULL, that means it's the first time we've been called,
    // and we may want to open the log file.  If we set hFile to
    // INVALID_HANDLE_VALUE, that means we've decided not to write to the file.
    //

    GetLocalTime( &CurrTime );

    if (hFile == NULL) {
        Result = GetWindowsDirectory( buf, sizeof(buf)/sizeof(WCHAR) );
        if(Result == 0) {
            MYASSERT(FALSE);
            return;
        }
        ConcatenatePaths( buf, L"spsetup.log", sizeof(buf)/sizeof(WCHAR));

        hFile = CreateFile(
            buf,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
            NULL
            );
        if (hFile != INVALID_HANDLE_VALUE)
        {
            swprintf(buf, L"Time,File,Line,Tag,Message\r\n");
            Bytes = wcslen(buf) + 4;
            str =  MALLOC(Bytes);
            if (str != NULL)
            {
                WideCharToMultiByte(
                    CP_ACP,
                    0,
                    buf,
                    -1,
                    str,
                    Bytes,
                    NULL,
                    NULL
                    );
                WriteFile(
                    hFile,
                    str,
                    wcslen(buf),
                    &Bytes,
                    NULL
                    );

                FREE( str );

            }
            buf[0] = '\0';
        } else {    // !IsSetup

            //
            // Don't write to file, just do DbgPrintEx
            //
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    _try {
        p = buf;
        *p = 0;
        swprintf( p, L"%02d/%02d/%04d %02d:%02d:%02d,%s,%d,%s,",
            CurrTime.wMonth,
            CurrTime.wDay,
            CurrTime.wYear,
            CurrTime.wHour,
            CurrTime.wMinute,
            CurrTime.wSecond,
            (NULL != FileName) ? FileName : L"",
            LineNumber,
            (NULL != TagStr) ? TagStr : L""
            );
        p += wcslen(p);
        va_start( arg_ptr, FormatStr );
        _vsnwprintf( p, 2048, FormatStr, arg_ptr );
        va_end( arg_ptr );
        p += wcslen(p);
        wcscat( p, L"\r\n" );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        buf[0] = 0;
    }

    if (buf[0] == 0) {
        return;
    }

    Bytes = (wcslen( buf )*2) + 4;

    str = MALLOC( Bytes );
    if (str == NULL) {
        return;
    }

    WideCharToMultiByte(
        CP_ACP,
        0,
        buf,
        -1,
        str,
        Bytes,
        NULL,
        NULL
        );

    //
    // Write out the string to the debugger if the process is being debugged, or the
    // debug filter allows it.
    //
    if ( bWriteDebugSpew ) {

        OutputDebugString( buf );

    } else {

#if DBG
        DbgPrintEx( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, str );
#endif

    }

    if (hFile == INVALID_HANDLE_VALUE) {
        FREE( str );
        return;
    }

    WriteFile(
        hFile,
        str,
        wcslen(buf),
        &Bytes,
        NULL
        );

    FREE( str );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\misc.c ===
#include "spsetupp.h"
#pragma hdrstop

//
// Constant strings used for logging in various places.
//
PCWSTR szSetupInstallFromInfSection = L"SetupInstallFromInfSection";
PCWSTR szOpenSCManager              = L"OpenSCManager";
PCWSTR szOpenService                = L"OpenService";
PCWSTR szStartService               = L"StartService";

const WCHAR pwNull[]            = WINNT_A_NULL;
const WCHAR pwYes[]             = WINNT_A_YES;
const WCHAR pwNo[]              = WINNT_A_NO;


UINT
MyGetDriveType(
    IN WCHAR Drive
    )
{
    WCHAR DriveNameNt[] = L"\\\\.\\?:";
    WCHAR DriveName[] = L"?:\\";
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk. Otherwise
    // just believe the api.
    //
    DriveName[0] = Drive;
    if((rc = GetDriveType(DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile(
                    DriveNameNt,
                    FILE_READ_ATTRIBUTES,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if(hDisk != INVALID_HANDLE_VALUE) {

            b = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if(b && (MediaInfo.MediaType == RemovableMedia)) {
                rc = DRIVE_FIXED;
            }

            CloseHandle(hDisk);
        }
    }

    return(rc);
}


BOOL
GetPartitionInfo(
    IN  WCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    WCHAR DriveName[] = L"\\\\.\\?:";
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFile(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}


PVOID
InitSysSetupQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    )
{
    PSYSSETUP_QUEUE_CONTEXT SysSetupContext;

    SysSetupContext = MALLOC(sizeof(SYSSETUP_QUEUE_CONTEXT));

    if(SysSetupContext) {

        SysSetupContext->Skipped = FALSE;

        SysSetupContext->DefaultContext = SetupInitDefaultQueueCallbackEx(
            OwnerWindow,
            AlternateProgressWindow,
            ProgressMessage,
            Reserved1,
            Reserved2
            );
    }

    return SysSetupContext;
}


PVOID
InitSysSetupQueueCallback(
    IN HWND OwnerWindow
    )
{
    return(InitSysSetupQueueCallbackEx(OwnerWindow,NULL,0,0,NULL));
}


VOID
TermSysSetupQueueCallback(
    IN PVOID SysSetupContext
    )
{
    PSYSSETUP_QUEUE_CONTEXT Context = SysSetupContext;

    try {
        if(Context->DefaultContext) {
            SetupTermDefaultQueueCallback(Context->DefaultContext);
        }
        FREE(Context);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ;
    }
}


UINT
SysSetupQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT                    Status;
    PSYSSETUP_QUEUE_CONTEXT SysSetupContext = Context;
    PFILEPATHS              FilePaths = (PFILEPATHS)Param1;
    PSOURCE_MEDIA           SourceMedia = (PSOURCE_MEDIA)Param1;


    if ((Notification == SPFILENOTIFY_COPYERROR
         || Notification == SPFILENOTIFY_RENAMEERROR
         || Notification == SPFILENOTIFY_DELETEERROR) &&
        (FilePaths->Win32Error == ERROR_DIRECTORY)) {
            WCHAR Buffer[MAX_PATH];
            PWSTR p;
            //
            // The target directory has been converted into a file by autochk.
            // just delete it -- we might be in trouble if the target directory was
            // really important, but it's worth trying
            //

            wcscpy( Buffer,FilePaths->Target);
            p = wcsrchr(Buffer,L'\\');
            if (p) {
                *p = (WCHAR)NULL;
            }
            if (FileExists(Buffer,NULL)) {
                DeleteFile( Buffer );
                DEBUGMSG1(DBG_INFO, "autochk turned directory %s into file, delete file and retry\n", Buffer);
                return(FILEOP_RETRY);
            }
    }

    //
    // If we're being notified that a version mismatch was found,
    // silently overwrite the file.  Otherwise, pass the notification on.
    //
    if((Notification & (SPFILENOTIFY_LANGMISMATCH |
                        SPFILENOTIFY_TARGETNEWER |
                        SPFILENOTIFY_TARGETEXISTS)) != 0) {

        LOG2(LOG_INFO, 
             USEMSGID(MSG_LOG_VERSION_MISMATCH), 
             FilePaths->Source, 
             FilePaths->Target);

/*        SetuplogError(
            LogSevInformation,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_VERSION_MISMATCH,
            FilePaths->Source,
            FilePaths->Target,
            NULL,NULL);*/

        return(FILEOP_DOIT);
    }


    //
    // Use default processing, then check for errors.
    //
    Status = SetupDefaultQueueCallback(
        SysSetupContext->DefaultContext,Notification,Param1,Param2);

    switch(Notification) {

    case SPFILENOTIFY_STARTQUEUE:
    case SPFILENOTIFY_STARTSUBQUEUE:
    case SPFILENOTIFY_ENDSUBQUEUE:
        //
        // Nothing is logged in this case.
        //
        break;

    case SPFILENOTIFY_ENDQUEUE:

        if(!Param1) {
            LOG0(LOG_INFO, USEMSGID(MSG_LOG_QUEUE_ABORT));
            /*SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_QUEUE_ABORT, NULL,
                SETUPLOG_USE_MESSAGEID,
                GetLastError(),
                NULL,NULL);*/
        }
        break;

    case SPFILENOTIFY_STARTRENAME:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDRENAME:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            LOG2(LOG_INFO, 
                 USEMSGID(MSG_LOG_FILE_RENAMED), 
                 FilePaths->Source,
                 FilePaths->Target);
            /*SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_RENAMED,
                FilePaths->Source,
                FilePaths->Target,
                NULL,NULL);*/

        } else {

            LOG2(LOG_ERROR, 
                 USEMSGID(MSG_LOG_FILE_RENAME_ERROR), 
                 FilePaths->Source,
                 FilePaths->Target);
            LOG0(LOG_ERROR, 
                 FilePaths->Win32Error == NO_ERROR ?
                    USEMSGID(MSG_LOG_USER_SKIP) :
                    USEMSGID(FilePaths->Win32Error));
            /*SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_RENAME_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);*/
        }
        break;

    case SPFILENOTIFY_RENAMEERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_STARTDELETE:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDDELETE:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {

            LOG1(LOG_INFO, 
                 USEMSGID(MSG_LOG_FILE_DELETED), 
                 FilePaths->Target);
/*            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETED,
                FilePaths->Target,
                NULL,NULL);*/

        } else if(FilePaths->Win32Error == ERROR_FILE_NOT_FOUND ||
            FilePaths->Win32Error == ERROR_PATH_NOT_FOUND) {
            //
            // This failure is not important.
            //
            LOG1(LOG_INFO, 
                 USEMSGID(MSG_LOG_FILE_DELETE_ERROR), 
                 FilePaths->Target);
            LOG0(LOG_INFO, USEMSGID(FilePaths->Win32Error));
/*            SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETE_ERROR,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error,
                NULL,NULL);*/

        } else {
            //
            // Here we have an actual error.
            //
            LOG1(LOG_INFO, 
                 USEMSGID(MSG_LOG_FILE_DELETE_ERROR), 
                 FilePaths->Target);
            LOG0(LOG_INFO, 
                 FilePaths->Win32Error == NO_ERROR ?
                    USEMSGID(MSG_LOG_USER_SKIP) :
                    USEMSGID(FilePaths->Win32Error));
            /*SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_DELETE_ERROR,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);*/
        }
        break;

    case SPFILENOTIFY_DELETEERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_STARTCOPY:
        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        } else {
            SysSetupContext->Skipped = FALSE;
        }
        break;

    case SPFILENOTIFY_ENDCOPY:

        if(FilePaths->Win32Error == NO_ERROR &&
            !SysSetupContext->Skipped) {
#if 0
            LogRepairInfo(
                FilePaths->Source,
                FilePaths->Target
                );
#endif
            LOG2(LOG_INFO, 
                 USEMSGID(MSG_LOG_FILE_COPIED), 
                 FilePaths->Source, 
                 FilePaths->Target);
            /*SetuplogError(
                LogSevInformation,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPIED,
                FilePaths->Source,
                FilePaths->Target,
                NULL,NULL);*/

            //
            // clear the file's readonly attribute that it may have gotten
            // from the cdrom.
            //
            SetFileAttributes(
                FilePaths->Target,
                GetFileAttributes(FilePaths->Target) & ~FILE_ATTRIBUTE_READONLY );

        } else {

            LOG2(LOG_ERROR, 
                 USEMSGID(MSG_LOG_FILE_COPY_ERROR), 
                 FilePaths->Source, 
                 FilePaths->Target);
            LOG0(LOG_ERROR, 
                 FilePaths->Win32Error == NO_ERROR ?
                    USEMSGID(MSG_LOG_USER_SKIP) :
                    USEMSGID(FilePaths->Win32Error));
/*            SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_FILE_COPY_ERROR,
                FilePaths->Source,
                FilePaths->Target, NULL,
                SETUPLOG_USE_MESSAGEID,
                FilePaths->Win32Error == NO_ERROR ?
                    MSG_LOG_USER_SKIP :
                    FilePaths->Win32Error,
                NULL,NULL);*/
        }
        break;

    case SPFILENOTIFY_COPYERROR:

        if(Status == FILEOP_SKIP) {
            SysSetupContext->Skipped = TRUE;
        }
        break;

    case SPFILENOTIFY_NEEDMEDIA:

        if(Status == FILEOP_SKIP) {

            LOG2(LOG_INFO, 
                 USEMSGID(MSG_LOG_NEEDMEDIA_SKIP), 
                 SourceMedia->SourceFile, 
                 SourceMedia->SourcePath);
            /*SetuplogError(
                LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_NEEDMEDIA_SKIP,
                SourceMedia->SourceFile,
                SourceMedia->SourcePath,
                NULL,NULL);*/

            SysSetupContext->Skipped = TRUE;
        }

        break;

    case SPFILENOTIFY_STARTREGISTRATION:
    case SPFILENOTIFY_ENDREGISTRATION:
        RegistrationQueueCallback(
                        Context,
                        Notification,
                        Param1,
                        Param2);
        break;

    default:

        break;
    }

    return Status;
}


VOID
SaveInstallInfoIntoEventLog(
    VOID
    )
/*++
Routine Description:

    This routine will store information into the event log regarding
    - if we upgraded or cleaninstall
    - what build did the install originate from
    - what build are we?
    - were there errors during Setup

Arguments:

    None.

Return Value:

    None.

--*/
{
#define     AnswerBufLen (64)
WCHAR       AnswerFile[MAX_PATH];
WCHAR       Answer[AnswerBufLen];
WCHAR       OrigVersion[AnswerBufLen];
WCHAR       NewVersion[AnswerBufLen];
HANDLE      hEventSrc;
PCWSTR      MyArgs[2];
PCWSTR      ErrorArgs[1];
DWORD       MessageID;
WORD        MyArgCount;




    //
    // Go get the starting information out of $winnt$.sif
    //
    OrigVersion[0] = L'0';
    OrigVersion[1] = L'\0';
    GetSystemDirectory(AnswerFile,MAX_PATH);
    ConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH);
    if( GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_WIN32_VER,
                                 pwNull,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {

        if( lstrcmp( pwNull, Answer ) ) {

            wsprintf( OrigVersion, L"%d", HIWORD(wcstoul( Answer, NULL, 16 )) );
        }
    }
    MyArgs[1] = OrigVersion;



    //
    // Get the new version information.
    //
    wsprintf( NewVersion, L"%d", HIWORD(GetVersion()) );
    MyArgs[0] = NewVersion;



    //
    // See if we're an NT upgrade?
    //
    MessageID = 0;
    if( GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_NTUPGRADE,
                                 pwNo,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( !lstrcmp( pwYes, Answer ) ) {

            MessageID = MSG_NTUPGRADE_SUCCESS;
            MyArgCount = 2;
        }
    }



    //
    // See if we're a Win9X upgrade.
    //
    if( (!MessageID) &&
        GetPrivateProfileString( WINNT_DATA,
                                 WINNT_D_WIN95UPGRADE,
                                 pwNo,
                                 Answer,
                                 AnswerBufLen,
                                 AnswerFile ) ) {
        if( !lstrcmp( pwYes, Answer ) ) {

            MessageID = MSG_WIN9XUPGRADE_SUCCESS;
            MyArgCount = 2;
        }
    }



    //
    // Clean install.
    //
    if( (!MessageID) ) {
        MessageID = MSG_CLEANINSTALL_SUCCESS;
        MyArgCount = 1;
    }


    //
    // If this is anything but an NT upgrade, then
    // we need to go try and manually start the eventlog
    // service.
    //
    if( MessageID != MSG_NTUPGRADE_SUCCESS ) {
        SetupStartService( L"Eventlog", TRUE );
    }



    //
    // Get a handle to the eventlog.
    //
    hEventSrc = RegisterEventSource( NULL, L"Setup" );

    if( (hEventSrc == NULL) ||
        (hEventSrc == INVALID_HANDLE_VALUE) ) {

        //
        // Fail quietly.
        //
        return;
    }

#if 0
    //
    // Log event if there were errors during Setup.
    //
    if ( !IsErrorLogEmpty() ) {
        ReportEvent( hEventSrc,
                     EVENTLOG_ERROR_TYPE,
                     0,
                     MSG_NONFATAL_ERRORS,
                     NULL,
                     0,
                     0,
                     NULL,
                     NULL );
    }
#endif

    //
    // Build the event log message.
    //
    ReportEvent( hEventSrc,
                 EVENTLOG_INFORMATION_TYPE,
                 0,
                 MessageID,
                 NULL,
                 MyArgCount,
                 0,
                 MyArgs,
                 NULL );


    DeregisterEventSource( hEventSrc );


}


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}



BOOL IsSafeMode(
    VOID
    )
{
	LONG lStatus;
	HKEY hk;
	DWORD dwVal;
	DWORD dwType;
	DWORD dwSize;

	lStatus = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                0,
                KEY_QUERY_VALUE,
                &hk
                );

	if(lStatus != ERROR_SUCCESS)
		return FALSE;

	dwSize = sizeof(dwVal);
	lStatus = RegQueryValueEx (hk, TEXT("OptionValue"), NULL, &dwType, (LPBYTE) &dwVal, &dwSize);
	RegCloseKey(hk);
	return ERROR_SUCCESS == lStatus && REG_DWORD == dwType && dwVal != 0;
}


VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;

    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) <= BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}

PTSTR
SzJoinPaths (
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    )
{
    DWORD size = lstrlen (Path1) + lstrlen (Path2) + 1 + 1;
    PTSTR p = MALLOC(size * sizeof (TCHAR));
    if (p) {
        lstrcpy (p, Path1);
        ConcatenatePaths (p, Path2, size);
    }
    return p;
}


PSTR
UnicodeToAnsi(
    IN PCWSTR UnicodeString
    )

/*++

Routine Description:

    Convert a string from unicode to ansi.

Arguments:

    UnicodeString - supplies string to be converted.

    Codepage - supplies codepage to be used for the conversion.

Return Value:

    NULL if out of memory or invalid codepage.
    Caller can free buffer with pSetupFree().

--*/

{
    UINT WideCharCount;
    PSTR String;
    UINT StringBufferSize;
    UINT BytesInString;
    PSTR p;

    WideCharCount = lstrlenW(UnicodeString) + 1;

    //
    // Allocate maximally sized buffer.
    // If every unicode character is a double-byte
    // character, then the buffer needs to be the same size
    // as the unicode string. Otherwise it might be smaller,
    // as some unicode characters will translate to
    // single-byte characters.
    //
    StringBufferSize = WideCharCount * 2;
    String = MALLOC(StringBufferSize);
    if(String == NULL) {
        return(NULL);
    }

    //
    // Perform the conversion.
    //
    BytesInString = WideCharToMultiByte(
                        CP_ACP,
                        0,                      // default composite char behavior
                        UnicodeString,
                        WideCharCount,
                        String,
                        StringBufferSize,
                        NULL,
                        NULL
                        );

    if(BytesInString == 0) {
        FREE(String);
        return(NULL);
    }

    return(String);
}

PTSTR
DupString(
    IN      PCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = MALLOC((lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}

PWSTR
RetrieveAndFormatMessageV(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    IN va_list *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    PWSTR Buffer;
    PWSTR Message;
    WCHAR ModuleName[MAX_PATH];
    WCHAR ErrorNumber[24];
    PWCHAR p;
    PWSTR Args[2];
    DWORD Msg_Type;
    UINT Msg_Id = MessageId;

    if(!HIWORD(MessageString)) {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (PWSTR)&Buffer,
                0,
                ArgumentList
                );
    } else {

        if( Msg_Id & 0x0FFF0000 )
            Msg_Type = FORMAT_MESSAGE_FROM_SYSTEM;      // If the facility bits are set this is still Win32
        else{
            Msg_Id &= 0x0000FFFF;                       // Mask out Severity and Facility bits so that we do the right thing
            Msg_Type = ((Msg_Id < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE);
        }


        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | Msg_Type,
                (PVOID)g_ModuleHandle,
                MessageId,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PWSTR)&Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        wsprintf(ErrorNumber,L"%x",MessageId);
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(GetModuleFileName(g_ModuleHandle,ModuleName,MAX_PATH)) {
            if(p = wcsrchr(ModuleName,L'\\')) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (PWSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DupString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}

BOOL
SetupStartService(
    IN PCWSTR ServiceName,
    IN BOOLEAN Wait        // if TRUE, try to wait until it is started.
    )
{
    SC_HANDLE hSC,hSCService;
    BOOL b;
    DWORD d;
    DWORD dwDesiredAccess;

    b = FALSE;
    //
    // Open a handle to the service controller manager
    //
    hSC = OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);
    if(hSC == NULL) {
        LOG1(LOG_WARNING, 
             USEMSGID(MSG_LOG_STARTSVC_FAIL), 
             ServiceName);
        LOG2(LOG_WARNING, 
             USEMSGID(MSG_LOG_X_RETURNED_WINERR), 
             szOpenSCManager, 
             GetLastError());
/*        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_RETURNED_WINERR,
            szOpenSCManager,
            GetLastError(),
            NULL,NULL);*/
        return(FALSE);
    }

    if (Wait) {
        dwDesiredAccess = SERVICE_START | SERVICE_QUERY_STATUS;
    } else {
        dwDesiredAccess = SERVICE_START;
    }
    if(hSCService = OpenService(hSC,ServiceName,dwDesiredAccess)) {
        DEBUGMSG1(DBG_INFO, "SetupStartService: Sending StartService to <%ws>\n", ServiceName);
        b = StartService(hSCService,0,NULL);
        DEBUGMSG1(DBG_INFO, "SetupStartService: Sent StartService to <%ws>\n", ServiceName);
        if(!b && ((d = GetLastError()) == ERROR_SERVICE_ALREADY_RUNNING)) {
            //
            // Service is already running.
            //
            b = TRUE;
        }
        if(!b) {
            LOG1(LOG_WARNING, 
                 USEMSGID(MSG_LOG_STARTSVC_FAIL), 
                 ServiceName);
            LOG3(LOG_WARNING, 
                 USEMSGID(MSG_LOG_X_PARAM_RETURNED_WINERR), 
                 szStartService, 
                 d, 
                 ServiceName);
            /*SetuplogError(
                LogSevWarning,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_STARTSVC_FAIL,
                ServiceName, NULL,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_X_PARAM_RETURNED_WINERR,
                szStartService,
                d,
                ServiceName,
                NULL,NULL);*/
        }
        if (b && Wait) {
#define SLEEP_TIME 4000
#define LOOP_COUNT 30
            SERVICE_STATUS ssStatus;
            DWORD loopCount = 0;
            //DEBUGMSG0(DBG_INFO, "  ) Looping waiting for start\n"));
            do {
                b = QueryServiceStatus( hSCService, &ssStatus);
                if ( !b ) {
                    //DEBUGMSG1(DBG_INFO, "FAILED %d\n", GetLastError());
                    break;
                }
                if (ssStatus.dwCurrentState == SERVICE_START_PENDING) {
                    //DEBUGMSG0(DBG_INFO, "PENDING\n");
                    if ( loopCount++ == LOOP_COUNT ) {
                        DEBUGMSG2(DBG_INFO, "SYSSETUP: STILL PENDING after %d times: <%ws> service\n", loopCount, ServiceName);
                        break;
                    }
                    Sleep( SLEEP_TIME );
                } else {
                    //DEBUGMSG3(DBG_INFO, "SYSSETUP: WAITED %d times: <%ws> service, status %d\n", loopCount, ServiceName, ssStatus.dwCurrentState);
                    break;
                }
            } while ( TRUE );
        }
        CloseServiceHandle(hSCService);
    } else {
        b = FALSE;
        LOG1(LOG_WARNING, 
             USEMSGID(MSG_LOG_STARTSVC_FAIL), 
             ServiceName);
        LOG3(LOG_WARNING, 
             USEMSGID(MSG_LOG_X_PARAM_RETURNED_WINERR), 
             szOpenService, 
             GetLastError(), 
             ServiceName);
/*        SetuplogError(
            LogSevWarning,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_STARTSVC_FAIL,
            ServiceName, NULL,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_X_PARAM_RETURNED_WINERR,
            szOpenService,
            GetLastError(),
            ServiceName,
            NULL,NULL);*/
    }

    CloseServiceHandle(hSC);

    return(b);
}

int
MessageBoxFromMessage(
    IN HWND   Owner,            OPTIONAL
    IN UINT   MessageId,
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    )
{
    PCWSTR Message;
    PCWSTR Title;
    va_list ArgumentList;
    int i;
    BOOL b;

    va_start(ArgumentList,Style);
    Message = RetrieveAndFormatMessageV(NULL,MessageId,&ArgumentList);
    va_end(ArgumentList);

    b = FALSE;
    i = IDOK;

    if(Message) {

        if(Title = Caption ? Caption : MyLoadString(CaptionStringId)) {

            b = TRUE;
            i = MessageBox(Owner,Message,Title,Style);

            if(Title != Caption) {
                FREE(Title);
            }
        }
        FREE(Message);
    }

    return(i);
}

PWSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    WCHAR Buffer[4096];
    UINT Length;

    Length = LoadString(g_ModuleHandle,StringId,Buffer,sizeof(Buffer)/sizeof(WCHAR));
    if(!Length) {
        Buffer[0] = 0;
    }

    return(DupString(Buffer));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\log.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Routines for logging actions performed during setup.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "spsetupp.h"
#pragma hdrstop

//
// Constant strings used for logging in various places.
//
PCWSTR szSetupInstallFromInfSection = L"SetupInstallFromInfSection";
PCWSTR szOpenSCManager              = L"OpenSCManager";
PCWSTR szOpenService                = L"OpenService";
PCWSTR szStartService               = L"StartService";

PVOID
pOpenFileCallback(
    IN  PCTSTR  Filename,
    IN  BOOL    WipeLogFile
    )
{
    WCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;
    DWORD   Result;

    //
    // Form the pathname of the logfile.
    //
    Result = GetWindowsDirectory(CompleteFilename,MAX_PATH);
    if( Result == 0) {
        MYASSERT(FALSE);
        return NULL;
    }
    ConcatenatePaths(CompleteFilename,Filename,MAX_PATH);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}

BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )
{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;

    // Write message to log file
    //
    if(AnsiBuffer = UnicodeToAnsi (Buffer)) {
        SetFilePointer (LogFile, 0, NULL, FILE_END);

        Status = WriteFile (
            LogFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        FREE (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    // Write log message to debugging log
    //
    DEBUGMSG0(DBG_INFO, (LPWSTR)Buffer);

    return Status;

}

BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}

PVOID
MyMalloc (
    SIZE_T Size
    )
{
    return MALLOC(Size);
}

VOID
MyFree (
    PCVOID Ptr
    )
{
    FREE(Ptr);
}


VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called spsetup.log and it exists in the windows dir.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;
    PWSTR   p;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = CloseHandle;
    Context->AllocMem = MyMalloc;
    Context->FreeMem = MyFree;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;
    Context->Lock = pAcquireMutex;
    Context->Unlock = ReleaseMutex;

    Context->Mutex = CreateMutex(NULL,FALSE,L"SetuplogMutex");

    SetuplogInitialize (Context, FALSE);

    SetuplogError(
        LogSevInformation,
        USEMSGID(SETUPLOG_USE_MESSAGEID),
        MSG_LOG_GUI_START,
        NULL,NULL);

}

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

    Close the Setup log and free resources.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    None.

--*/

{
    UINT    i;

    if(Context->Mutex) {
        CloseHandle(Context->Mutex);
        Context->Mutex = NULL;
    }

    SetuplogTerminate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\progress.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    progress.h

Abstract:

    

Author:

    Ovidiu Temereanca (ovidiut)

Revision History:

--*/

#define PF_ERROR        ((DWORD) (~0))
#define PF_NO_RUN       ((DWORD) (0))

typedef enum {
    SfrQueryTicks,
    SfrRun,
} PROGRESS_FUNCTION_REQUEST;

typedef struct tagPROGRESS_MANAGER* PPROGRESS_MANAGER;


typedef
DWORD
(PROGRESS_FUNCTION_PROTOTYPE) (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    );

typedef PROGRESS_FUNCTION_PROTOTYPE *PPROGRESS_FUNCTION_PROTOTYPE;

typedef struct {
    PPROGRESS_FUNCTION_PROTOTYPE FunctionBody;
    PCTSTR FunctionName;
    BOOL Disabled;
} PROGRESS_FUNCTION, *PPROGRESS_FUNCTION;


typedef struct {
    HWND ProgressText;
    HWND ProgressBar;
	DWORD CurrentTicks, 
		TotalTicks,
		LowerPercent,
		UpperPercent;
} PROGRESS_INDICATOR, *PPROGRESS_INDICATOR;

typedef struct tagPROGRESS_SLICE {
    struct tagPROGRESS_SLICE* Next;
    struct tagPROGRESS_SLICE* Prev;
    PPROGRESS_FUNCTION Function;
    DWORD TicksRequested;
    DWORD TicksCompleted;
} PROGRESS_SLICE, *PPROGRESS_SLICE;

#define NUM_INDICATORS 2

typedef PROGRESS_INDICATOR** INDICATOR_ARRAY;

typedef struct tagPROGRESS_MANAGER {
    INDICATOR_ARRAY Indicators;
    PBOOL CancelFlag;
    DWORD TotalTicks;
    PPROGRESS_SLICE ProgressHead;
    PPROGRESS_SLICE ProgressTail;
    PPROGRESS_SLICE ProgressCurrent;
} PROGRESS_MANAGER, *PPROGRESS_MANAGER;



BOOL
PfQueryTicks (
    IN OUT  PPROGRESS_FUNCTION FunctionTable,
    IN OUT  PPROGRESS_MANAGER ProgressManager                   OPTIONAL
    );

VOID
PfRun (
    IN      PPROGRESS_FUNCTION FunctionTable
    );

PPROGRESS_MANAGER
PmCreate (
    IN      INDICATOR_ARRAY Indicators,     OPTIONAL
    IN      PBOOL CancelFlag                    OPTIONAL
    );

BOOL
PmAttachFunctionTable (
    IN OUT  PPROGRESS_MANAGER ProgressManager,
    IN OUT  PPROGRESS_FUNCTION FunctionTable
    );

BOOL
PmRun (
    IN OUT  PPROGRESS_MANAGER ProgressManager
    );

VOID
PmDestroy (
    IN OUT  PPROGRESS_MANAGER ProgressManager
    );

PPROGRESS_SLICE
SliceCreate (
    IN      PPROGRESS_FUNCTION Function,
    IN      DWORD TicksRequested
    );

VOID
SliceDestroy (
    IN OUT  PPROGRESS_SLICE Slice
    );

PPROGRESS_INDICATOR
PiCreate (
    IN      HWND ProgressText,          OPTIONAL
    IN      HWND ProgressBar            OPTIONAL
    );

VOID
PiDestroy (
    IN OUT  PPROGRESS_INDICATOR Indicator
    );

BOOL
PmTickDelta (
    IN OUT  PPROGRESS_MANAGER ProgressManager,
    IN      DWORD Ticks
    );

#define PmTick(pm)  PmTickDelta(pm,1)

BOOL
PmTickRemaining (
    IN OUT  PPROGRESS_MANAGER ProgressManager
    );

VOID
PiInitialize (
    IN OUT  PPROGRESS_INDICATOR Indicator,
    IN      DWORD TotalTicks,
	IN		DWORD LowerPercent,
	IN		DWORD UpperPercent
    );

VOID
PiTerminate (
    IN OUT  PPROGRESS_INDICATOR Indicator
    );

VOID
PiSetDescription (
    IN OUT  PPROGRESS_INDICATOR Indicator,
    IN      PCTSTR Description                      OPTIONAL
    );

VOID
PiTickDelta (
    IN OUT  PPROGRESS_INDICATOR Indicator,
    IN      DWORD Ticks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by spsetup.rc
//
#define IDS_FATALERROR                  1
#define IDS_WINNT_SPSETUP               2
#define IDD_SPSETUP                     101
#define IDD_SPSETUPNEW                  102
#define IDC_DESCRIPTION                 1000

#define IDC_PROGRESS                    1001
#define IDC_OPERATION_PROGRESS          1002
#define IDC_OVERALL_PROGRESS            1003
#define IDC_TOQUIT                      1004
#define IDC_OPERATION                   1005
#define IDC_ANIMATE1                    1006
#define IDC_OPERATION_DESCRIPTION       1007
#define IDC_OVERALL_DESCRIPTION         1008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        104

#define _APS_NEXT_COMMAND_VALUE         40001

#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\spreg.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spfunc.c

Abstract:

    This module implements the main functions of SpSetup.

Author:

    Ovidiu Temereanca (ovidiut)

Revision History:

--*/

#include "spsetupp.h"
#pragma hdrstop

#define SYSREG_DEFAULT_MAX_COUNT_LEVEL     3
#define SYSREG_PROGRESS_GRANULARITY        128

static HREGANL g_SysRegAnalyzer;
static TCHAR FilenameSysSnapshot1[] = TEXT("sysreg1.rdf");
static TCHAR FilenameSysSnapshot2[] = TEXT("sysreg2.rdf");
static TCHAR FilenameSysRegDiff[] = TEXT("sysdiff.rdf");
static TCHAR SectionMachineRegistryInclude[] = TEXT("SysRegInclude");
static TCHAR SectionMachineRegistryExclude[] = TEXT("SysRegExclude");
static PTSTR SysSnapshot1File = NULL;
static PTSTR SysSnapshot2File = NULL;
static PTSTR SysRegDiffFile = NULL;

#define DEFUSERREG_DEFAULT_MAX_COUNT_LEVEL     4
#define DEFUSERREG_PROGRESS_GRANULARITY        64

static HREGANL g_DefUserRegAnalyzer;
static TCHAR FilenameDefUserSnapshot1[] = TEXT("defuser1.rdf");
static TCHAR FilenameDefUserSnapshot2[] = TEXT("defuser2.rdf");
static TCHAR FilenameDefUserRegDiff[] = TEXT("userdiff.rdf");
static TCHAR SectionDefUserRegistryInclude[] = TEXT("DefUserRegInclude");
static TCHAR SectionDefUserRegistryExclude[] = TEXT("DefUserRegExclude");
static PTSTR DefUserSnapshot1File = NULL;
static PTSTR DefUserSnapshot2File = NULL;
static PTSTR DefUserRegDiffFile = NULL;


VOID
SpsRegDone (
    VOID
    )
{
    if (SysRegDiffFile) {
        FREE(SysRegDiffFile);
        SysRegDiffFile = NULL;
    }

#ifndef PRERELEASE
    DeleteFile (SysSnapshot1File);
    DeleteFile (SysSnapshot2File);
#endif

    if (SysSnapshot2File) {
        FREE(SysSnapshot2File);
        SysSnapshot2File = NULL;
    }
    if (SysSnapshot1File) {
        FREE(SysSnapshot1File);
        SysSnapshot1File = NULL;
    }

    if (DefUserRegDiffFile) {
        FREE(DefUserRegDiffFile);
        DefUserRegDiffFile = NULL;
    }

#ifndef PRERELEASE
    DeleteFile (DefUserSnapshot1File);
    DeleteFile (DefUserSnapshot2File);
#endif

    if (DefUserSnapshot2File) {
        FREE(DefUserSnapshot2File);
        DefUserSnapshot2File = NULL;
    }
    if (DefUserSnapshot1File) {
        FREE(DefUserSnapshot1File);
        DefUserSnapshot1File = NULL;
    }
}

BOOL
SpsRegInit (
    VOID
    )
{
    BOOL b = FALSE;

    __try {

        TCHAR sysPath[MAX_PATH];

        if (!GetSystemDirectory (sysPath, MAX_PATH)) {
            __leave;
        }
        SysSnapshot1File = SzJoinPaths (sysPath, FilenameSysSnapshot1);
        if (!SysSnapshot1File) {
            OOM();
            __leave;
        }
        SysSnapshot2File = SzJoinPaths (sysPath, FilenameSysSnapshot2);
        if (!SysSnapshot2File) {
            OOM();
            __leave;
        }
        SysRegDiffFile = SzJoinPaths (sysPath, FilenameSysRegDiff);
        if (!SysRegDiffFile) {
            OOM();
            __leave;
        }
        DefUserSnapshot1File = SzJoinPaths (sysPath, FilenameDefUserSnapshot1);
        if (!DefUserSnapshot1File) {
            OOM();
            __leave;
        }
        DefUserSnapshot2File = SzJoinPaths (sysPath, FilenameDefUserSnapshot2);
        if (!DefUserSnapshot2File) {
            OOM();
            __leave;
        }
        DefUserRegDiffFile = SzJoinPaths (sysPath, FilenameDefUserRegDiff);
        if (!DefUserRegDiffFile) {
            OOM();
            __leave;
        }
        b = TRUE;
    }
    __finally {
        if (!b) {
            SpsRegDone ();
        }
    }

    return b;
}

DWORD
SysSnapshotProgressCallback (
    IN      PVOID Context,
    IN      DWORD NodesProcessed
    )
{
    if (NodesProcessed % SYSREG_PROGRESS_GRANULARITY == 0) {
        PPROGRESS_MANAGER pm = (PPROGRESS_MANAGER)Context;
        if (!pm) {
            return ERROR_INVALID_PARAMETER;
        }
        if (!PmTickDelta (pm, SYSREG_PROGRESS_GRANULARITY)) {
            return GetLastError ();
        }
    }
    return ERROR_SUCCESS;
}

DWORD
SpsSnapshotSysRegistry (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    TCHAR root[MAX_PATH];
    TCHAR subkey[MAX_PATH];
    INFCONTEXT ic;
    DWORD rc = ERROR_INVALID_PARAMETER;

    switch (Request) {
    case SfrQueryTicks:
        {
            DWORD ticks = 0;
            DWORD nodes;
            if (SetupFindFirstLine (g_SpSetupInf, SectionMachineRegistryInclude, NULL, &ic)) {
                do {
                    if (SetupGetStringField (&ic, 1, root, MAX_PATH, NULL)) {
                        if (!SetupGetStringField (&ic, 2, subkey, MAX_PATH, NULL)) {
                            subkey[0] = 0;
                        }
                        if (CountRegSubkeys (root, subkey, SYSREG_DEFAULT_MAX_COUNT_LEVEL, &nodes)) {
                            ticks += nodes;
                        } else {
                            LOG2(LOG_WARNING, "Failure counting nodes for registry path %s\\%s", root, subkey);
                        }
                    }
                } while (SetupFindNextLine (&ic, &ic));
            }
            rc = ticks;
            break;
        }
    case SfrRun:
        {
            g_SysRegAnalyzer = CreateRegAnalyzer ();
            if (!g_SysRegAnalyzer) {
                rc = GetLastError ();
                break;
            }

            __try {
                if (SetupFindFirstLine (g_SpSetupInf, SectionMachineRegistryInclude, NULL, &ic)) {
                    do {
                        if (SetupGetStringField (&ic, 1, root, MAX_PATH, NULL)) {
                            if (!SetupGetStringField (&ic, 2, subkey, MAX_PATH, NULL)) {
                                subkey[0] = 0;
                            }
                            if (!AddRegistryKey (g_SysRegAnalyzer, root, subkey)) {
                                rc = GetLastError ();
                                LOG2(LOG_ERROR, "Failure adding reg node %s\\%s", root, subkey);
                                __leave;
                            }
                        }
                    } while (SetupFindNextLine (&ic, &ic));
                }
                if (SetupFindFirstLine (g_SpSetupInf, SectionMachineRegistryExclude, NULL, &ic)) {
                    do {
                        if (SetupGetStringField (&ic, 1, root, MAX_PATH, NULL)) {
                            if (!SetupGetStringField (&ic, 2, subkey, MAX_PATH, NULL)) {
                                subkey[0] = 0;
                            }
                            if (!ExcludeRegistryKey (g_SysRegAnalyzer, root, subkey)) {
                                rc = GetLastError ();
                                LOG2(LOG_ERROR, "Failure adding reg node %s\\%s", root, subkey);
                                __leave;
                            }
                        }
                    } while (SetupFindNextLine (&ic, &ic));
                }

                if (!TakeSnapshot (
                        g_SysRegAnalyzer,
                        SysSnapshot1File,
                        SysSnapshotProgressCallback,
                        ProgressManager,
                        SYSREG_DEFAULT_MAX_COUNT_LEVEL,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG2(LOG_ERROR, "TakeSnapshot(%s) failed %u", SysSnapshot1File, rc);
                    __leave;
                }
                if (!PmTickRemaining (ProgressManager)) {
                    rc = GetLastError ();
                    __leave;
                }
                rc = ERROR_SUCCESS;
            }
            __finally {
                if (rc != ERROR_SUCCESS) {
                    CloseRegAnalyzer (g_SysRegAnalyzer);
                    g_SysRegAnalyzer = NULL;
                }
            }
            break;
        }
    default:
        MYASSERT (FALSE);
    }
    return rc;
}

DWORD
SpsSaveSysRegistryChanges (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    DWORD rc = ERROR_INVALID_PARAMETER;

    switch (Request) {
    case SfrQueryTicks:
        rc = SpsSnapshotSysRegistry (Request, ProgressManager);
        break;
    case SfrRun:
        {
            if (!g_SysRegAnalyzer) {
                MYASSERT (FALSE);
                rc = ERROR_INVALID_FUNCTION;
                break;
            }
            __try {
                if (!TakeSnapshot (
                        g_SysRegAnalyzer,
                        SysSnapshot2File,
                        SysSnapshotProgressCallback,
                        ProgressManager,
                        SYSREG_DEFAULT_MAX_COUNT_LEVEL,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG2(LOG_ERROR, "TakeSnapshot(%s) failed %u", SysSnapshot2File, rc);
                    __leave;
                }
                if (!ComputeDifferences (
                        g_SysRegAnalyzer,
                        SysSnapshot2File,
                        SysSnapshot1File,
                        SysRegDiffFile,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG1(LOG_ERROR, "ComputeDifferences failed %u", rc);
                    __leave;
                }
                if (!PmTickRemaining (ProgressManager)) {
                    rc = GetLastError ();
                    __leave;
                }

                rc = ERROR_SUCCESS;
            }
            __finally {
                CloseRegAnalyzer (g_SysRegAnalyzer);
                g_SysRegAnalyzer = NULL;
            }
            break;
        }
    default:
        MYASSERT (FALSE);
    }
    return rc;
}

DWORD
DefUserSnapshotProgressCallback (
    IN      PVOID Context,
    IN      DWORD NodesProcessed
    )
{
    if (NodesProcessed % DEFUSERREG_PROGRESS_GRANULARITY == 0) {
        PPROGRESS_MANAGER pm = (PPROGRESS_MANAGER)Context;
        if (!pm) {
            return ERROR_INVALID_PARAMETER;
        }
        if (!PmTickDelta (pm, DEFUSERREG_PROGRESS_GRANULARITY)) {
            return GetLastError ();
        }
    }
    return ERROR_SUCCESS;
}

DWORD
SpsSnapshotDefUserRegistry (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    TCHAR root[MAX_PATH];
    TCHAR subkey[MAX_PATH];
    INFCONTEXT ic;
    DWORD rc = ERROR_INVALID_PARAMETER;

    switch (Request) {
    case SfrQueryTicks:
        {
            DWORD ticks = 0;
            DWORD nodes;
            if (SetupFindFirstLine (g_SpSetupInf, SectionDefUserRegistryInclude, NULL, &ic)) {
                do {
                    if (SetupGetStringField (&ic, 1, root, MAX_PATH, NULL)) {
                        if (!SetupGetStringField (&ic, 2, subkey, MAX_PATH, NULL)) {
                            subkey[0] = 0;
                        }
                        if (CountRegSubkeys (root, subkey, DEFUSERREG_DEFAULT_MAX_COUNT_LEVEL, &nodes)) {
                            ticks += nodes;
                        } else {
                            LOG2(LOG_WARNING, "Failure counting nodes for registry path %s\\%s", root, subkey);
                        }
                    }
                } while (SetupFindNextLine (&ic, &ic));
            }
            rc = ticks;
            break;
        }
    case SfrRun:
        {
            g_DefUserRegAnalyzer = CreateRegAnalyzer ();
            if (!g_DefUserRegAnalyzer) {
                rc = GetLastError ();
                break;
            }

            __try {
                if (SetupFindFirstLine (g_SpSetupInf, SectionDefUserRegistryInclude, NULL, &ic)) {
                    do {
                        if (SetupGetStringField (&ic, 1, root, MAX_PATH, NULL)) {
                            if (!SetupGetStringField (&ic, 2, subkey, MAX_PATH, NULL)) {
                                subkey[0] = 0;
                            }
                            if (!AddRegistryKey (g_DefUserRegAnalyzer, root, subkey)) {
                                rc = GetLastError ();
                                LOG2(LOG_ERROR, "Failure adding reg node %s\\%s", root, subkey);
                                __leave;
                            }
                        }
                    } while (SetupFindNextLine (&ic, &ic));
                }
                if (SetupFindFirstLine (g_SpSetupInf, SectionDefUserRegistryExclude, NULL, &ic)) {
                    do {
                        if (SetupGetStringField (&ic, 1, root, MAX_PATH, NULL)) {
                            if (!SetupGetStringField (&ic, 2, subkey, MAX_PATH, NULL)) {
                                subkey[0] = 0;
                            }
                            if (!ExcludeRegistryKey (g_DefUserRegAnalyzer, root, subkey)) {
                                rc = GetLastError ();
                                LOG2(LOG_ERROR, "Failure adding reg node %s\\%s", root, subkey);
                                __leave;
                            }
                        }
                    } while (SetupFindNextLine (&ic, &ic));
                }
                if (!TakeSnapshot (
                        g_DefUserRegAnalyzer,
                        DefUserSnapshot1File,
                        DefUserSnapshotProgressCallback,
                        ProgressManager,
                        DEFUSERREG_DEFAULT_MAX_COUNT_LEVEL,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG2(LOG_ERROR, "TakeSnapshot(%s) failed %u", DefUserSnapshot1File, rc);
                    __leave;
                }
                if (!PmTickRemaining (ProgressManager)) {
                    rc = GetLastError ();
                    __leave;
                }
                rc = ERROR_SUCCESS;
            }
            __finally {
                if (rc != ERROR_SUCCESS) {
                    CloseRegAnalyzer (g_DefUserRegAnalyzer);
                    g_DefUserRegAnalyzer = NULL;
                }
            }
            break;
        }
    default:
        MYASSERT (FALSE);
    }
    return rc;
}

DWORD
SpsSaveDefUserRegistryChanges (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    DWORD rc = ERROR_INVALID_PARAMETER;

    switch (Request) {
    case SfrQueryTicks:
        rc = SpsSnapshotDefUserRegistry (Request, ProgressManager);
        break;
    case SfrRun:
        {
            if (!g_DefUserRegAnalyzer) {
                MYASSERT (FALSE);
                rc = ERROR_INVALID_FUNCTION;
                break;
            }
            __try {
                if (!TakeSnapshot (
                        g_DefUserRegAnalyzer,
                        DefUserSnapshot2File,
                        DefUserSnapshotProgressCallback,
                        ProgressManager,
                        DEFUSERREG_DEFAULT_MAX_COUNT_LEVEL,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG2(LOG_ERROR, "TakeSnapshot(%s) failed %u", DefUserSnapshot2File, rc);
                    __leave;
                }
                if (!ComputeDifferences (
                        g_DefUserRegAnalyzer,
                        DefUserSnapshot2File,
                        DefUserSnapshot2File,
                        DefUserRegDiffFile,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG1(LOG_ERROR, "ComputeDifferences failed %u", rc);
                    __leave;
                }
                if (!PmTickRemaining (ProgressManager)) {
                    rc = GetLastError ();
                    __leave;
                }

                rc = ERROR_SUCCESS;
            }
            __finally {
                CloseRegAnalyzer (g_DefUserRegAnalyzer);
                g_DefUserRegAnalyzer = NULL;
            }
            break;
        }
    default:
        MYASSERT (FALSE);
    }
    return rc;
}

DWORD
SpsRegisterUserLogonAction (
    IN      PROGRESS_FUNCTION_REQUEST Request,
    IN      PPROGRESS_MANAGER ProgressManager
    )
{
    DWORD rc = ERROR_INVALID_PARAMETER;

    switch (Request) {
    case SfrQueryTicks:
        rc = 20;
        break;
    case SfrRun:
        {
            SYSSETUP_QUEUE_CONTEXT qc;

            qc.Skipped = FALSE;
            qc.DefaultContext = SetupInitDefaultQueueCallback (g_MainDlg);

            __try {

                if (!SetupInstallFromInfSection (
                        g_MainDlg,
                        g_SpSetupInf,
                        TEXT("PerUserRegistration"),
                        SPINST_ALL,
                        HKEY_CURRENT_USER,
                        NULL,
                        0,
                        SysSetupQueueCallback,
                        &qc,
                        NULL,
                        NULL
                        )) {
                    rc = GetLastError ();
                    LOG3(
                        LOG_ERROR,
                        "%s(%s) failed %#x",
                        TEXT("SetupInstallFromInfSection"),
                        TEXT("PerUserRegistration"),
                        rc
                        );
                    __leave;
                }

                if (!PmTickRemaining (ProgressManager)) {
                    rc = GetLastError ();
                    __leave;
                }

                rc = ERROR_SUCCESS;
            }
            __finally {
                SetupTermDefaultQueueCallback (qc.DefaultContext);
            }
            break;
        }
    default:
        MYASSERT (FALSE);
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\spsetup.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    spsetup.c

Abstract:

    This module is the main body of Service Pack Setup program.
    It runs in system context (before any user logs on).

Author:

    Ovidiu Temereanca (ovidiut)

Revision History:

--*/

#include "spsetupp.h"
#pragma hdrstop

//#include "init.c"


#define SPSETUP_FUNCTION_TABLE                      \
            DEFMAC(SpsSnapshotSysRegistry)          \
            DEFMAC(SpsSnapshotDefUserRegistry)      \
            DEFMAC(SpsRegistrationPhase1)           \
            DEFMAC(SpsRegistrationPhase2)           \
            DEFMAC(SpsRegistrationPhase3)           \
            DEFMAC(SpsRegisterWPA)                  \
            DEFMAC(SpsSaveDefUserRegistryChanges)   \
            DEFMAC(SpsRegisterUserLogonAction)      \
            DEFMAC(SpsSaveSysRegistryChanges)       \


#define DEFMAC(f) PROGRESS_FUNCTION_PROTOTYPE f;
SPSETUP_FUNCTION_TABLE
#undef DEFMAC

#define DEFMAC(f) { f, TEXT(#f), FALSE },

static PROGRESS_FUNCTION g_FunctionTable[] = {
    SPSETUP_FUNCTION_TABLE
    { NULL, NULL, FALSE }
};

#undef DEFMAC


HANDLE g_hSpSetupHeap;

TCHAR g_SpSetupInfName[] = TEXT("update2.inf");

HINF g_SpSetupInf = INVALID_HANDLE_VALUE;

TCHAR g_SysSetupInfName[] = TEXT("syssetup.inf");

HINF g_SysSetupInf = INVALID_HANDLE_VALUE;

//
// Save the unhandled exception filter so we can restore it when we're done.
//
LPTOP_LEVEL_EXCEPTION_FILTER SavedExceptionFilter = NULL;
//
// Unique Id for the main Setup thread.  If any other thread has an unhandled
// exception, we just log an error and try to keep going.
//
DWORD MainThreadId;

HWND g_MainDlg;
HWND g_DescriptionWnd;
HWND g_ProgressWnd;
HWND g_OverallDescriptWnd;
HWND g_OverallProgressWnd;

LONG
WINAPI
SpsUnhandledExceptionFilter (
    IN      PEXCEPTION_POINTERS ExceptionInfo
    )

/*++

Routine Description:

    The routine deals with any unhandled exceptions in SpSetup.  We log an error
    and kill the offending thread if it's not the main thread or let SpSetup die
    if the main thread faulted.

Arguments:

    Same as UnhandledExceptionFilter.

Return Value:

    Same as UnhandledExceptionFilter.

--*/

{
    UINT_PTR Param1, Param2;


    switch(ExceptionInfo->ExceptionRecord->NumberParameters) {
    case 1:
        Param1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
        Param2 = 0;
        break;
    case 2:
        Param1 = ExceptionInfo->ExceptionRecord->ExceptionInformation[0];
        Param2 = ExceptionInfo->ExceptionRecord->ExceptionInformation[1];
        break;
    default:
        Param1 = Param2 = 0;
    }

    DEBUGMSG4(DBG_ERROR, 
              "SpSetup: (critical error) Encountered an unhandled exception (%lx) at address %lx with the following parameters: %lx %lx.", 
              ExceptionInfo->ExceptionRecord->ExceptionCode, 
              ExceptionInfo->ExceptionRecord->ExceptionAddress, 
              Param1, 
              Param2);

    LOG4(LOG_ERROR, 
         USEMSGID(MSG_LOG_UNHANDLED_EXCEPTION), 
         ExceptionInfo->ExceptionRecord->ExceptionCode, 
         ExceptionInfo->ExceptionRecord->ExceptionAddress, 
         Param1, 
         Param2);
    /*SetuplogError(
        LogSevError | SETUPLOG_SINGLE_MESSAGE,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_UNHANDLED_EXCEPTION,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2,
        NULL,
        NULL
        );*/

#if 0
#ifdef PRERELEASE
    //
    // If we're an internal build, then we want to debug this.
    //
    MessageBoxFromMessage (
        NULL,
        MSG_UNHANDLED_EXCEPTION,
        NULL,
        IDS_ERROR,
        MB_OK | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND,
        ExceptionInfo->ExceptionRecord->ExceptionCode,
        ExceptionInfo->ExceptionRecord->ExceptionAddress,
        Param1,
        Param2
        );

    return EXCEPTION_CONTINUE_EXECUTION;
#endif
#endif

    //
    // If we're running under the debugger, then pass the exception to the
    // debugger.  If the exception occurred in some thread other than the main
    // Setup thread, then kill the thread and hope that Setup can continue.
    // If the exception is in the main thread, then don't handle the exception,
    // and let Setup die.
    //
    if (GetCurrentThreadId() != MainThreadId &&
        !IsDebuggerPresent()
        ) {
        ExitThread (-1);
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

BOOL
LogInitialize (
    VOID
    )
{
    BOOL bResult = FALSE;
    __try{
        INITIALIZE_LOG_CODE;
        bResult = TRUE;
    }
    __finally{
        ;
    }

    return bResult;
}

VOID
LogTerminate (
    VOID
    )
{
    __try{
        TERMINATE_LOG_CODE;
    }
    __finally{
        ;
    }
}

VOID
SpsTerminate (
    VOID
    )
{
    SpsRegDone ();

    LogTerminate ();

    //
    // restore the exception handler
    //
    if (SavedExceptionFilter) {
        SetUnhandledExceptionFilter (SavedExceptionFilter);
    }
    if (g_SpSetupInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile (g_SpSetupInf);
        g_SpSetupInf = INVALID_HANDLE_VALUE;
    }
    if (g_SysSetupInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile (g_SysSetupInf);
        g_SysSetupInf = INVALID_HANDLE_VALUE;
    }
/*
    Terminate ();
*/
}


BOOL
SpsParseCommandLine (
    VOID
    )
{
    //
    // TO DO
    //
    return TRUE;
}


BOOL
SpsInitialize (
    VOID
    )
{
    TCHAR infSpSetup[MAX_PATH];
    UINT line;
    BOOL b = FALSE;

    //
    // set up an exception handler first
    //
    SavedExceptionFilter = SetUnhandledExceptionFilter (SpsUnhandledExceptionFilter);

    MainThreadId = GetCurrentThreadId();

    g_hSpSetupHeap = GetProcessHeap();
/*
    g_hHeap = g_hSpSetupHeap;

    if (!Initialize ()) {
        return FALSE;
    }
*/
    LogInitialize ();

    __try {
        if (!SpsParseCommandLine ()) {
            __leave;
        }

        //
        // read the unattend file
        // we expect it always at a fixed location like system32\update2.inf
        //
        if (!GetSystemDirectory (infSpSetup, MAX_PATH)) {
            __leave;
        }
        ConcatenatePaths (infSpSetup, g_SpSetupInfName, MAX_PATH);
        g_SpSetupInf = SetupOpenInfFile (infSpSetup, NULL, INF_STYLE_WIN4, &line);
        if (g_SpSetupInf == INVALID_HANDLE_VALUE) {
            __leave;
        }

        //
        // get a handle on syssetup.inf as well
        //
        if (!GetWindowsDirectory (infSpSetup, MAX_PATH)) {
            __leave;
        }
        ConcatenatePaths (infSpSetup, TEXT("inf"), MAX_PATH);
        ConcatenatePaths (infSpSetup, g_SysSetupInfName, MAX_PATH);
        g_SysSetupInf = SetupOpenInfFile (infSpSetup, NULL, INF_STYLE_WIN4, &line);
        if (g_SysSetupInf == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (!SpsRegInit ()) {
            __leave;
        }

        b = TRUE;
    }
    __finally {
        if (!b) {
            SpsTerminate ();
        }
    }
    return b;
}

INT_PTR
CALLBACK
SpsDialogProc (
    IN      HWND HwndDlg,  // handle to dialog box
    IN      UINT Msg,     // message
    IN      WPARAM wParam, // first message parameter
    IN      LPARAM lParam  // second message parameter
    )
{
    switch (Msg) {
    case WM_INITDIALOG:
        g_DescriptionWnd = GetDlgItem (HwndDlg, IDC_OPERATION_DESCRIPTION);
        g_ProgressWnd = GetDlgItem (HwndDlg, IDC_OPERATION_PROGRESS);
		g_OverallDescriptWnd = GetDlgItem (HwndDlg, IDC_OVERALL_DESCRIPTION);
        g_OverallProgressWnd = GetDlgItem (HwndDlg, IDC_OVERALL_PROGRESS);
        return TRUE;
    case WM_DESTROY:
        g_DescriptionWnd = NULL;
        g_ProgressWnd = NULL;
		g_OverallDescriptWnd = NULL;
		g_OverallProgressWnd = NULL;
        break;
    }
    return FALSE;
}

BOOL
BbStart (
    VOID
    )
{	
/*	
	LPTSTR lpMsgBuff[250];
	DWORD code;
   //
  */  // TO DO


    //
    INITCOMMONCONTROLSEX ic;

    ic.dwSize = sizeof (ic);
    ic.dwICC = ICC_PROGRESS_CLASS;
    if (!InitCommonControlsEx (&ic)) {
        return FALSE;
    }
    g_MainDlg = CreateDialog (g_ModuleHandle, MAKEINTRESOURCE(IDD_SPSETUPNEW), NULL, SpsDialogProc);
    if (!g_MainDlg) {
        DWORD rc = GetLastError ();
        return FALSE;
    }
    return TRUE;

}

VOID
BbEnd (
    VOID
    )
{
    //
    // TO DO
    //
    if (g_MainDlg) {
        DestroyWindow (g_MainDlg);
        g_MainDlg = NULL;
    }
}

// Wait for plug and play to complete.  WinLogon creates the OOBE_PNP_DONE
// event and signals it when PnP completes.
//
void
WaitForPnPCompletion()
{
    DWORD dwResult;
    HANDLE hevent;

    // This event pauses until PnP is complete.  To avoid a deadlock,
    // both services.exe and msobmain.dll try to create the event.  The one
    // that does not successfully create the event will then open it.
    //
    hevent = CreateEvent( NULL,
                          TRUE,  // manual reset
                          FALSE, // initially not signalled)
                          SC_OOBE_PNP_DONE );
    if (NULL == hevent)
    {
        LOG1(LOG_ERROR,"CreateEvent(SC_OOBE_PNP_DONE) failed (0x%08X)", GetLastError());
        return;
    }

    // If we get wedged here it is most likely because we're in an Oem mode
    // that doesn't require services.exe to run PnP.
    //
    LOG1(LOG_INFO, "Waiting for %s event from services.exe\n", SC_OOBE_PNP_DONE);
    dwResult = WaitForSingleObject(hevent, INFINITE);

    MYASSERT(WAIT_OBJECT_0 == dwResult);
    switch(dwResult)
    {
    case WAIT_OBJECT_0:
        LOG1(LOG_INFO, "SC_OOBE_PNP_DONE(%s) signalled\n", SC_OOBE_PNP_DONE);
        break;
    default:
        LOG2(LOG_ERROR, "Wait for SC_OOBE_PNP_DONE(%s) failed: 0x%08X\n", SC_OOBE_PNP_DONE, GetLastError());
        break;
    }
}



// Signal winlogon that the computer name has been changed.  WinLogon waits to
// start services that depend on the computer name until this event is
// signalled.
//
BOOL
SignalComputerNameChangeComplete()
{
    BOOL fReturn = TRUE;

    // Open event with EVENT_ALL_ACCESS so that synchronization and state
    // change can be done.
    //
    HANDLE hevent = OpenEvent(EVENT_ALL_ACCESS, FALSE, SC_OOBE_MACHINE_NAME_DONE);

    // It is not fatal for OpenEvent to fail: this synchronization is only
    // required when OOBE will be run in OEM mode.
    //
    if (NULL != hevent)
    {
        if (! SetEvent(hevent))
        {
            // It is fatal to open but not set the event: services.exe will not
            // continue until this event is signalled.
            //
            LOG2(LOG_ERROR, "Failed to signal SC_OOBE_MACHINE_NAME_DONE(%s): 0x%08X\n",
                  SC_OOBE_MACHINE_NAME_DONE, GetLastError());
            fReturn = FALSE;
        }
        MYASSERT(fReturn);  // Why did we fail to set an open event??
    }

    return fReturn;
}


BOOL
SpsSignalComplete (
    VOID
    )
{
    BOOL fReturn = TRUE;
    HANDLE hEvent;

    SignalComputerNameChangeComplete();

    // Open event with EVENT_ALL_ACCESS so that synchronization and state
    // change can be done.
    //
    hEvent = OpenEvent (EVENT_ALL_ACCESS, FALSE, /*SC_SPSETUP_DONE*/L"SP_SETUP_DONE");

    // It is not fatal for OpenEvent to fail: this synchronization is only
    // required when OOBE will be run in OEM mode.
    //
    if (hEvent) {
        if (!SetEvent (hEvent)) {
            //
            // It is fatal to open but not set the event: services.exe will not
            // continue until this event is signalled.
            //
            fReturn = FALSE;
            LOG2(LOG_ERROR, 
                 "Failed to signal SC_SPSETUP_DONE(%s): 0x%x\n", 
                 /*SC_SPSETUP_DONE*/L"SP_SETUP_DONE", 
                 GetLastError());
            /*SetuplogError (
                LogSevError,
                TEXT("Failed to signal SC_SPSETUP_DONE(%1): 0x%2!x!\n"),
                0,
                L"SP_SETUP_DONE",
                GetLastError (),
                NULL,
                NULL
                );*/
            MYASSERT (FALSE);
        }
    }

    return fReturn;
}


DWORD
SpsConfigureStartAfterReboot (
    VOID
    )
{
    PVOID pvContext = NULL;
    DWORD dwErr=ERROR_SUCCESS;

    pvContext = SetupInitDefaultQueueCallbackEx( NULL, (struct HWND__ *)INVALID_HANDLE_VALUE, 0, 0, NULL);
    if (!pvContext) {
        LOG1(LOG_ERROR, "Could not create context for callback, errorcode = 0x%08X.\n", ERROR_NOT_ENOUGH_MEMORY);   
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto EH1;
    }
     
    if (!SetupInstallFromInfSection(
            NULL,
            g_SpSetupInf,
            L"SPSetupResetConfig",
            SPINST_ALL,
            NULL,
            NULL,
            SP_COPY_NEWER,
            SetupDefaultQueueCallback,
            pvContext,
            NULL,
            NULL
            )) {
        dwErr = GetLastError();
        LOG2(LOG_ERROR, "Could not run %s, errorcode = 0x%08X.\n", g_SpSetupInfName, dwErr);
		goto EH1;
    }
    
    dwErr = SetupCommitFileQueue( NULL, 0, NULL, pvContext);

EH1:
    if( pvContext) {
        SetupTermDefaultQueueCallback(pvContext);
    }

    return( dwErr);
}

INT
SpsInstallServicePack (
    IN      INT Argc,
    IN      PSTR Argv[]
    )
{
    DWORD rc;
    PPROGRESS_MANAGER pm;

    BOOL b = FALSE;
	INDICATOR_ARRAY ppIndicators;

    //
    // initialize the module
    //
    if (!SpsInitialize ()) {
        return FALSE;
    }

//    WaitForPnPCompletion();

    __try {
        //
        // init was successful, now start the billboard
        //
        if (!BbStart ()) {
            __leave;
        }

        //
        // initialize the watcher;
        // ISSUE - it should actually gather the state of needed folders on the first run
        // and reuse that data on subsequent restarts (due to unknown errors)
        //

		ppIndicators = MALLOC_ZEROED(sizeof(PPROGRESS_INDICATOR[NUM_INDICATORS]));

		ASSERT(ppIndicators);

		ppIndicators[0] = PiCreate (g_DescriptionWnd, g_ProgressWnd);
		ppIndicators[1] = PiCreate (g_OverallDescriptWnd, g_OverallProgressWnd);

        pm = PmCreate (ppIndicators, NULL);
        if (!pm) {
            __leave;
        }

        if (!PmAttachFunctionTable (pm, g_FunctionTable)) {
            __leave;
        }

        b = PmRun (pm);
    }
    __finally {

        rc = b ? ERROR_SUCCESS : GetLastError ();

        if (pm) {
            PmDestroy (pm);
        }

        if (ppIndicators) {
            PiDestroy (ppIndicators[0]);
			PiDestroy (ppIndicators[1]);
			FREE(ppIndicators);
        }


        //
        // stop the billboard
        //
        BbEnd ();
/*
        if (b) {
            //
            // inform services.exe that it can continue loading the rest of the services
            //
            SpsSignalComplete ();
            SpsConfigureStartAfterReboot ();
        }
*/
        SpsTerminate ();
        SetLastError (rc);
    }

    return rc;
}

VOID
FatalError(
    IN UINT MessageId,
    ...
    )

/*++

Routine Description:

    Inform the user of an error which prevents Setup from continuing.
    The error is logged as a fatal error, and a message box is presented.

Arguments:

    MessageId - supplies the id for the message in the message table.

    Additional agruments specify parameters to be inserted in the message.

Return Value:

    DOES NOT RETURN.

--*/

{
    PWSTR   Message;
    va_list arglist;
    HKEY    hKey;
    DWORD   RegData;


    va_start(arglist,MessageId);
/*    Message = SetuplogFormatMessageV(
        0,
        SETUPLOG_USE_MESSAGEID,
        MessageId,
        &arglist);*/

    if(!FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                         FORMAT_MESSAGE_FROM_HMODULE, 
                         g_ModuleHandle, 
                         MessageId, 
                         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                         (PVOID)&Message, 
                         0, 
                         &arglist)){
        Message = NULL;
    }
    va_end(arglist);

    if(Message) {

        //
        // Log the error first.
        //
        LOGW((LOG_FATAL_ERROR, "%s", Message));
        /*SetuplogError(LogSevFatalError, Message, 0, NULL, NULL);*/

        //
        // Now tell the user.
        //
        MessageBoxFromMessage(
            g_MainDlg,
            MSG_FATAL_ERROR,
            NULL,
            IDS_FATALERROR,
            MB_ICONERROR | MB_OK | MB_SYSTEMMODAL,
            Message
            );
        
        LocalFree(Message);
    }
    
    LOG0(LOG_FATAL_ERROR, USEMSGID(MSG_LOG_GUI_ABORTED));
    /*SetuplogError(LogSevInformation, SETUPLOG_USE_MESSAGEID, MSG_LOG_GUI_ABORTED, NULL, NULL);*/
    if (SavedExceptionFilter) {
        SetUnhandledExceptionFilter (SavedExceptionFilter);
    }

    LogTerminate();

//    ViewSetupActionLog(g_MainDlg, NULL, NULL);

//    SendSMSMessage( MSG_SMS_FAIL, FALSE );

    ExitProcess(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsrestr\psp.h ===
#pragma once

//
// Define result codes.
//
#define SUCCESS 0
#define FAILURE 1

//
// Define helper macro to deal with subtleties of NT-level programming.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

//
// Memory routines
//
#define MALLOC(size)    RtlAllocateHeap(RtlProcessHeap(),0,(size))
#define FREE(block)     RtlFreeHeap(RtlProcessHeap(),0,(block))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\spsetupp.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    spsetupp.h

Abstract:

    Private top-level header file for Windows XP Service Pack module.

Author:

    Ovidiu Temereanca (ovidiut) 06-Sep-2001

Revision History:

--*/

#pragma warning(push, 3)

//
// System header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvcp.h>
#include <commdlg.h>
#include <commctrl.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <objbase.h>
#include <regstr.h>
#include <licdll.h>
#include <activation.h>
//
// CRT header files
//
#include <process.h>
#include <tchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <limits.h>
#include <tchar.h>
#include <setupbat.h>
#include <winioctl.h>
#include <spapip.h>
#pragma warning(pop)

//
// Private header files
//
#include "setuplog.h"
#include "progress.h"
#include "msg.h"
#include "resource.h"
#include "regdiff.h"
//#include "top.h"

#define SIZECHARS(x)    (sizeof((x))/sizeof(TCHAR))
#define CSTRLEN(x)      ((sizeof((x))/sizeof(TCHAR)) - 1)
#define ARRAYSIZE(x)    (sizeof((x))/sizeof((x)[0]))

#define SIZEOF_STRING(String)   ((_tcslen(String) + 1) * sizeof (TCHAR))

#define OOM()           SetLastError(ERROR_NOT_ENOUGH_MEMORY)

#ifdef PRERELEASE

#define LOG_ENTER_TIME()    DEBUGLOGTIME(TEXT("Entering %s"), __FUNCTION__)
#define LOG_LEAVE_TIME()    DEBUGLOGTIME(TEXT("Leaving %s"), __FUNCTION__)

#else

#define LOG_ENTER_TIME()
#define LOG_LEAVE_TIME()

#endif


extern HWND g_MainDlg;
extern HINF g_SpSetupInf;
extern HINF g_SysSetupInf;

//
// Memory handling routines
//
extern HANDLE g_hSpSetupHeap;

#define MALLOC(s)           HeapAlloc(g_hSpSetupHeap,0,s)
#define FREE(p)             HeapFree(g_hSpSetupHeap,0,(PVOID)p)
#define MALLOC_ZEROED(s)    HeapAlloc(g_hSpSetupHeap,HEAP_ZERO_MEMORY,s)


#if DBG
    #define ASSERT_HEAP_IS_VALID()  if (g_hSpSetupHeap) MYASSERT(RtlValidateHeap(g_hSpSetupHeap,0,NULL))
#else
    #define ASSERT_HEAP_IS_VALID()
#endif

extern const WCHAR          pwNull[];
extern const WCHAR          pwYes[];
extern const WCHAR          pwNo[];

//
// Module handle for this module.
//

extern TCHAR g_SpSetupInfName[];
extern TCHAR g_SpRegSnapshot1[];
extern TCHAR g_SpRegSnapshot2[];
extern TCHAR g_SpRegDiff[];

extern HANDLE g_ModuleHandle;

PTSTR
SzJoinPaths (
    IN      PCTSTR Path1,
    IN      PCTSTR Path2
    );

BOOL
SpsRegInit (
    VOID
    );

VOID
SpsRegDone (
    VOID
    );
/*#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT(x)

#endif


void
pSetupDebugPrint(
    PWSTR FileName,
    ULONG LineNumber,
    PWSTR TagStr,
    PWSTR FormatStr,
    ...
    );

#define SetupDebugPrint(_fmt_)                            pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_)
#define SetupDebugPrint1(_fmt_,_arg1_)                    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_)
#define SetupDebugPrint2(_fmt_,_arg1_,_arg2_)             pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_)
#define SetupDebugPrint3(_fmt_,_arg1_,_arg2_,_arg3_)      pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_)
#define SetupDebugPrint4(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)
#define SetupDebugPrint5(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_) pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)

VOID
FatalError(
    IN UINT MessageId,
    ...
    );


VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    );
*/

//
// Flags indicating whether any accessibility utilities are in use.
//
extern BOOL AccessibleSetup;
extern BOOL Magnifier;
extern BOOL ScreenReader;
extern BOOL OnScreenKeyboard;

extern PCWSTR szSetupInstallFromInfSection;
extern PCWSTR szOpenSCManager;
extern PCWSTR szOpenService;
extern PCWSTR szStartService;


//
// Context for file queues in SysSetup
//
typedef struct _SYSSETUP_QUEUE_CONTEXT {
    PVOID   DefaultContext;
    BOOL    Skipped;
} SYSSETUP_QUEUE_CONTEXT, *PSYSSETUP_QUEUE_CONTEXT;

PVOID
InitSysSetupQueueCallbackEx(
    IN HWND  OwnerWindow,
    IN HWND  AlternateProgressWindow, OPTIONAL
    IN UINT  ProgressMessage,
    IN DWORD Reserved1,
    IN PVOID Reserved2
    );

PVOID
InitSysSetupQueueCallback(
    IN HWND OwnerWindow
    );

VOID
TermSysSetupQueueCallback(
    IN PVOID SysSetupContext
    );

UINT
SysSetupQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );

UINT
RegistrationQueueCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );


LONG
WINAPI
SpsUnhandledExceptionFilter(
    IN      PEXCEPTION_POINTERS ExceptionInfo
    );

#ifdef _OCM
PVOID
#else
VOID
#endif
CommonInitialization(
    VOID
    );



BOOL
pSetupWaitForScmInitialization();

VOID
SetUpDataBlock(
    VOID
    );


//
// Message string routines
//
PWSTR
MyLoadString(
    IN UINT StringId
    );

PWSTR
FormatStringMessageV(
    IN UINT     FormatStringId,
    IN va_list *ArgumentList
    );

PWSTR
FormatStringMessage(
    IN UINT FormatStringId,
    ...
    );

PWSTR
RetrieveAndFormatMessageV(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    IN va_list *ArgumentList
    );

PWSTR
RetrieveAndFormatMessage(
    IN PCWSTR   MessageString,
    IN UINT     MessageId,      OPTIONAL
    ...
    );

int
MessageBoxFromMessageExV (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    IN va_list ArgumentList
    );

int
MessageBoxFromMessageEx (
    IN HWND   Owner,            OPTIONAL
    IN LogSeverity  Severity,   OPTIONAL
    IN PCWSTR MessageString,
    IN UINT   MessageId,        OPTIONAL
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    );

int
MessageBoxFromMessage(
    IN HWND   Owner,            OPTIONAL
    IN UINT   MessageId,
    IN PCWSTR Caption,          OPTIONAL
    IN UINT   CaptionStringId,  OPTIONAL
    IN UINT   Style,
    ...
    );


//
// ARC routines.
//
PWSTR
ArcDevicePathToNtPath(
    IN PCWSTR ArcPath
    );

PWSTR
NtFullPathToDosPath(
    IN PCWSTR NtPath
    );

BOOL
ChangeBootTimeout(
    IN UINT Timeout
    );

BOOL
SetNvRamVariable(
    IN PCWSTR VarName,
    IN PCWSTR VarValue
    );

PWSTR
NtPathToDosPath(
    IN PCWSTR NtPath
    );

//
// Plug&Play initialization
//
HANDLE
SpawnPnPInitialization(
    VOID
    );

DWORD
PnPInitializationThread(
    IN PVOID ThreadParam
    );



//
// Service control.
//
BOOL
MyCreateService(
    IN PCWSTR  ServiceName,
    IN PCWSTR  DisplayName,         OPTIONAL
    IN DWORD   ServiceType,
    IN DWORD   StartType,
    IN DWORD   ErrorControl,
    IN PCWSTR  BinaryPathName,
    IN PCWSTR  LoadOrderGroup,      OPTIONAL
    IN PWCHAR  DependencyList,
    IN PCWSTR  ServiceStartName,    OPTIONAL
    IN PCWSTR  Password             OPTIONAL
    );

BOOL
MyChangeServiceConfig(
    IN PCWSTR ServiceName,
    IN DWORD  ServiceType,
    IN DWORD  StartType,
    IN DWORD  ErrorControl,
    IN PCWSTR BinaryPathName,   OPTIONAL
    IN PCWSTR LoadOrderGroup,   OPTIONAL
    IN PWCHAR DependencyList,
    IN PCWSTR ServiceStartName, OPTIONAL
    IN PCWSTR Password,         OPTIONAL
    IN PCWSTR DisplayName       OPTIONAL
    );

BOOL
MyChangeServiceStart(
    IN PCWSTR ServiceName,
    IN DWORD  StartType
    );

BOOL
UpdateServicesDependencies(
    IN HINF InfHandle
    );

//
// Registry manipulation
//
typedef struct _REGVALITEM {
    PCWSTR Name;
    PVOID Data;
    DWORD Size;
    DWORD Type;
} REGVALITEM, *PREGVALITEM;

//
// Names of frequently used keys/values
//
extern PCWSTR SessionManagerKeyName;
extern PCWSTR EnvironmentKeyName;
extern PCWSTR szBootExecute;
extern PCWSTR WinntSoftwareKeyName;

UINT
SetGroupOfValues(
    IN HKEY        RootKey,
    IN PCWSTR      SubkeyName,
    IN PREGVALITEM ValueList,
    IN UINT        ValueCount
    );

BOOL
CreateWindowsNtSoftwareEntry(
    IN BOOL FirstPass
    );

BOOL
CreateInstallDateEntry(
    );


BOOL
SaveHive(
    IN HKEY   RootKey,
    IN PCWSTR Subkey,
    IN PCWSTR Filename,
    IN DWORD  Format
    );

BOOL
SaveAndReplaceSystemHives(
    VOID
    );

DWORD
FixupUserHives(
    VOID
    );

DWORD
QueryValueInHKLM (
    IN PWCH KeyName OPTIONAL,
    IN PWCH ValueName,
    OUT PDWORD ValueType,
    OUT PVOID *ValueData,
    OUT PDWORD ValueDataLength
    );

VOID
ConfigureSystemFileProtection(
    VOID
    );

VOID
RemoveRestartability (
    HWND hProgress
    );

BOOL
ResetSetupInProgress(
    VOID
    );

BOOL
RemoveRestartStuff(
    VOID
    );

BOOL
RegisterOleControls(
    IN      HINF InfHandle,
    IN      PTSTR SectionName,
    IN      PPROGRESS_MANAGER ProgressManager
    );


//
// Ini file routines.
//
BOOL
ReplaceIniKeyValue(
    IN PCWSTR IniFile,
    IN PCWSTR Section,
    IN PCWSTR Key,
    IN PCWSTR Value
    );

//
//  PnP stuff.
//
BOOL
InstallPnpDevices(
    IN HWND  hwndParent,
    IN HINF  InfHandle,
    IN HWND  ProgressWindow,
    IN ULONG StartAtPercent,
    IN ULONG StopAtPercent
    );

VOID
PnpStopServerSideInstall( VOID );

VOID
PnpUpdateHAL(
    VOID
    );

#ifdef _OCM
PVOID
FireUpOcManager(
    VOID
    );

VOID
KillOcManager(
    PVOID OcManagerContext
    );
#endif

//
// Boolean value indicating whether we found any new
// optional component infs.
//
extern BOOL AnyNewOCInfs;

//
// INF caching -- used during optional components processing.
// WARNING: NOT MULTI-THREAD SAFE!
//
HINF
InfCacheOpenInf(
    IN PCWSTR FileName,
    IN PCWSTR InfType       OPTIONAL
    );

HINF
InfCacheOpenLayoutInf(
    IN HINF InfHandle
    );

VOID
InfCacheEmpty(
    IN BOOL CloseInfs
    );

//
//  Pnp stuff
//

BOOL
InstallPnpClassInstallers(
    IN HWND hwndParent,
    IN HINF InfHandle,
    IN HSPFILEQ FileQ
    );


VOID
SaveInstallInfoIntoEventLog(
    VOID
    );


BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
IsSafeMode(
    VOID
    );

VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    );

PSTR
UnicodeToAnsi(
    IN PCWSTR UnicodeString
    );

PTSTR
DupString(
    IN      PCTSTR String
    );

BOOL
SetupStartService(
    IN PCWSTR ServiceName,
    IN BOOLEAN Wait        // if TRUE, try to wait until it is started.
    );

PWSTR
MyLoadString(
    IN UINT StringId
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsetup\progress.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    progress.c

Abstract:

    This module defines the list of functions performed by SpSetup.

Author:

    Ovidiu Temereanca (ovidiut)

Revision History:

--*/

#include "spsetupp.h"
#pragma hdrstop


BOOL
PfQueryTicks (
    IN OUT  PPROGRESS_FUNCTION FunctionTable,
    IN OUT  PPROGRESS_MANAGER ProgressManager                   OPTIONAL
    )
{
    PPROGRESS_FUNCTION function;
    PPROGRESS_SLICE slice;
    DWORD rc;
    DWORD total = 0;
    BOOL b = TRUE;

    for (function = FunctionTable; function->FunctionBody; function++) {
        LOG1(LOG_INFO, 
             "QueryTicks for %s ...", 
             function->FunctionName);
        rc = function->FunctionBody (SfrQueryTicks, ProgressManager);
        LOG2(LOG_INFO, 
             "%s requested %d ticks", 
             function->FunctionName, 
             (DWORD)rc);

        if (rc == PF_ERROR) {
            LOG2(LOG_ERROR, "%s failed (rc=%#x)", function->FunctionName, GetLastError ());
            b = FALSE;
            break;
        }

        if (rc == PF_NO_RUN) {
            function->Disabled = TRUE;
            LOG1(LOG_INFO, "%s won't run", function->FunctionName);
        } else {
            if (ProgressManager) {
                total += (DWORD)rc;
                slice = SliceCreate (function, rc);
                if (!slice) {
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                if (ProgressManager->ProgressTail) {
                    MYASSERT (ProgressManager->ProgressHead);
                    ProgressManager->ProgressTail->Next = slice;
                    slice->Prev = ProgressManager->ProgressTail;
                    ProgressManager->ProgressTail = slice;
                } else {
                    ProgressManager->ProgressTail = ProgressManager->ProgressHead = slice;
                }
            }
        }
    }

    if (b) {
        if (ProgressManager) {
            ProgressManager->TotalTicks += total;
        }
    }

    return b;
}


VOID
PfRun (
    IN      PPROGRESS_FUNCTION FunctionTable
    )
{
    PPROGRESS_FUNCTION function;
    DWORD rc;

    for (function = FunctionTable; function->FunctionBody; function++) {
        if (!function->Disabled) {
            LOG1(LOG_INFO, "Starting %s",  function->FunctionName);
            rc = function->FunctionBody (SfrRun, NULL);
            LOG2(LOG_INFO,
                 "%s returned %d",
                 function->FunctionName,
                 (DWORD)rc);
        }
    }
}


PPROGRESS_MANAGER
PmCreate (
    IN      INDICATOR_ARRAY Indicators,      OPTIONAL
    IN      PBOOL CancelFlag                    OPTIONAL
    )
{
    PPROGRESS_MANAGER tracker = MALLOC_ZEROED(sizeof(PROGRESS_MANAGER));
    if (tracker) {
        tracker->Indicators = Indicators;
        tracker->CancelFlag = CancelFlag;
    }

    return tracker;
}


BOOL
PmAttachFunctionTable (
    IN OUT  PPROGRESS_MANAGER ProgressManager,
    IN OUT  PPROGRESS_FUNCTION FunctionTable
    )
{
    return PfQueryTicks (FunctionTable, ProgressManager);
}


BOOL
PmRun (
    IN OUT  PPROGRESS_MANAGER ProgressManager
    )
{
    BOOL b = TRUE;
    DWORD rc;
	DWORD OverallTicks;
    TCHAR timeFmt[100];
#ifdef PRERELEASE
    DWORD start, finish;
    DWORD msecs;
#endif

    if (ProgressManager->Indicators) {
        PiInitialize (ProgressManager->Indicators[0], ProgressManager->TotalTicks, 0,100);
		PiInitialize (ProgressManager->Indicators[1], ProgressManager->TotalTicks, 70,95);
    }

    for (ProgressManager->ProgressCurrent = ProgressManager->ProgressHead;
         ProgressManager->ProgressCurrent;
         ProgressManager->ProgressCurrent = ProgressManager->ProgressCurrent->Next
         ) {

        if (ProgressManager->CancelFlag && *ProgressManager->CancelFlag) {
            SetLastError (ERROR_CANCELLED);
            LOG0(LOG_INFO, "PmRun was cancelled");
            b = FALSE;
            break;
        }

        MYASSERT (!ProgressManager->ProgressCurrent->Function->Disabled);

        LOG2(LOG_INFO, 
             "%s: starting %s",
             _tstrtime (timeFmt),
             ProgressManager->ProgressCurrent->Function->FunctionName
             );
        if (ProgressManager->Indicators) {
            //
            // BUGBUG - need a localizable string
            //
            PiSetDescription (ProgressManager->Indicators[0], ProgressManager->ProgressCurrent->Function->FunctionName);
        }

#ifdef PRERELEASE
        start = GetTickCount();
#endif
        rc = ProgressManager->ProgressCurrent->Function->FunctionBody (SfrRun, ProgressManager);
#ifdef PRERELEASE
        finish = GetTickCount();
#endif

        LOG3(LOG_INFO, 
             "%s: %s returned %d",
             _tstrtime (timeFmt),
             ProgressManager->ProgressCurrent->Function->FunctionName, 
             (DWORD)rc
             );

#ifdef PRERELEASE
        msecs = finish - start;
        if (msecs == 0) msecs++;
        LOG3(LOG_INFO,
            "Stats: %u ticks completed in %u msecs (%u ticks/sec)",
            ProgressManager->ProgressCurrent->TicksCompleted,
            msecs,
            ProgressManager->ProgressCurrent->TicksCompleted * 1000 / msecs
            );
#endif

        if (ProgressManager->ProgressCurrent->TicksCompleted < ProgressManager->ProgressCurrent->TicksRequested) {
            DEBUGMSG1(DBG_NAUSEA, 
                      "Function %s didn't complete the number of requested ticks", 
                      ProgressManager->ProgressCurrent->Function->FunctionName);
            ProgressManager->ProgressCurrent->TicksCompleted = ProgressManager->ProgressCurrent->TicksRequested;
        }
    }

    if (ProgressManager->Indicators) {
        PiTerminate (ProgressManager->Indicators[0]);
        PiTerminate (ProgressManager->Indicators[1]);
    }

    return b;
}

VOID
PmDestroy (
    IN OUT  PPROGRESS_MANAGER ProgressManager
    )
{
    PPROGRESS_SLICE slice, next;

	slice = ProgressManager->ProgressHead;
    while (slice) {
        next = slice->Next;
        SliceDestroy (slice);
        slice = next;
    }
    
    FREE (ProgressManager);
}

BOOL
PmTickDelta (
    IN OUT  PPROGRESS_MANAGER ProgressManager,
    IN      DWORD Ticks
    )
{
    if (ProgressManager->CancelFlag && *ProgressManager->CancelFlag) {
        SetLastError (ERROR_CANCELLED);
        return FALSE;
    }
    ProgressManager->ProgressCurrent->TicksCompleted += Ticks;
    if (ProgressManager->ProgressCurrent->TicksCompleted > ProgressManager->ProgressCurrent->TicksRequested) {
        DEBUGMSG1(DBG_NAUSEA, 
                  "Function %s exceeded the number of requested ticks", 
                  ProgressManager->ProgressCurrent->Function->FunctionName);
        ProgressManager->ProgressCurrent->TicksCompleted = ProgressManager->ProgressCurrent->TicksRequested;
    }
    if (ProgressManager->Indicators) {
        PiTickDelta (ProgressManager->Indicators[0], Ticks);
		PiTickDelta (ProgressManager->Indicators[1], Ticks);
    }
    return TRUE;
}

BOOL
PmTickRemaining (
    IN OUT  PPROGRESS_MANAGER ProgressManager
    )
{
    BOOL b = TRUE;
    if (ProgressManager->ProgressCurrent->TicksRequested > ProgressManager->ProgressCurrent->TicksCompleted) {
        b = PmTickDelta (
                ProgressManager,
                ProgressManager->ProgressCurrent->TicksRequested - ProgressManager->ProgressCurrent->TicksCompleted
                );
    }
    return b;
}


PPROGRESS_SLICE
SliceCreate (
    IN      PPROGRESS_FUNCTION Function,
    IN      DWORD TicksRequested
    )
{
    PPROGRESS_SLICE slice = MALLOC_ZEROED(sizeof(PROGRESS_SLICE));
    if (slice) {
        slice->Function = Function;
        slice->TicksRequested = TicksRequested;
    }
    return slice;
}


VOID
SliceDestroy (
    IN OUT  PPROGRESS_SLICE Slice
    )
{
    FREE (Slice);
}

PPROGRESS_INDICATOR
PiCreate (
    IN      HWND ProgressText,          OPTIONAL
    IN      HWND ProgressBar            OPTIONAL
    )
{
    PPROGRESS_INDICATOR indicator = MALLOC(sizeof(PROGRESS_INDICATOR));
    if (indicator) {
        indicator->ProgressText = ProgressText;
        indicator->ProgressBar = ProgressBar;
    }
    return indicator;
}

VOID
PiDestroy (
    IN OUT  PPROGRESS_INDICATOR Indicator
    )
{
    FREE (Indicator);
}


const int MAXPOS = 100000;
//max position in progress bar

VOID
PiInitialize (
    IN OUT  PPROGRESS_INDICATOR Indicator,
    IN      DWORD TotalTicks,
	IN		DWORD LowerPercent,
	IN		DWORD UpperPercent
    )
{
    if (Indicator->ProgressBar) {
		Indicator->CurrentTicks = 0;
		Indicator->TotalTicks   = TotalTicks;
		Indicator->LowerPercent = LowerPercent;
		Indicator->UpperPercent = UpperPercent;

		SendMessage (Indicator->ProgressBar, PBM_SETRANGE32, 0, MAXPOS);
		SendMessage (Indicator->ProgressBar, PBM_SETPOS, (LowerPercent*MAXPOS)/100, 0);
    }
}

VOID
PiTerminate (
    IN OUT  PPROGRESS_INDICATOR Indicator
    )
{
    PiSetDescription (Indicator, NULL);
}

VOID
PiSetDescription (
    IN OUT  PPROGRESS_INDICATOR Indicator,
    IN      PCTSTR Description                      OPTIONAL
    )
{
    if (Indicator->ProgressText) {
        SendMessage (Indicator->ProgressText, WM_SETTEXT, 0, (LPARAM)(Description ? Description : TEXT("")));
    }
}


VOID
PiTickDelta (
    IN OUT  PPROGRESS_INDICATOR Indicator,
    IN      DWORD Ticks
    )
{
	DWORD NewPos;
	float lowerPos, upperPos;

	Indicator->CurrentTicks += Ticks;


	lowerPos = (float)Indicator->LowerPercent / 100.0f * (float)MAXPOS;
	upperPos = (float)Indicator->UpperPercent / 100.0f * (float)MAXPOS;

	NewPos = (DWORD)(lowerPos + (float)Indicator->CurrentTicks * (upperPos-lowerPos)/(float)Indicator->TotalTicks);

    if (Indicator->ProgressBar) {
        SendMessage (Indicator->ProgressBar, PBM_SETPOS, (WPARAM)NewPos, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\spsrestr\spsrestr.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sprestrt.c

Abstract:

    This program is used to help make GUI Setup restartable,
    if setup was started in restartable mode.

    Text mode setup will create a system hive containing the value

        HKLM\System\Setup:RestartSpSetup = REG_DWORD FALSE

    and a system.sav with RestartSpSetup set to TRUE. In both hives
    the session manager key will be written such that this program
    runs at autochk time.

    When this program starts, it checks the RestartSpSetup flag.
    If FALSE, then this is the first boot into GUI Setup, and we change it
    to TRUE and we're done here. If TRUE, then GUI setup needs to be
    restarted, and we clean out the config directory, copying *.sav to *.
    and erase everything else in there. System.sav has RestartSpSetup = TRUE,
    so GUI setup will be restarted over and over again until it succeeds.

    At the end of GUI Setup, sprestrt.exe is removed from the list of
    autochk programs and RestartSpSetup is set to FALSE.

    The boot loader looks at RestartSpSetup to see whether it needs to unload
    system and load system.sav instead. On the first boot into gui setup,
    we don't want to do this but on subsequent boots we do. The logic above
    makes this work correctly.

Author:

    Ted Miller (tedm) Feb 1996

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "msg.h"
#include "psp.h"

//
// Define result codes.
//
#define SUCCESS 0
#define FAILURE 1

#define SIZEOFARRAY(a)          (sizeof(a)/sizeof(a[0]))
#define BACKUP_EXTENSION        L".sav"
#define BACKUP_EXTENSION_LEN    4
#define SPS_EXTENSION           L".sps"
#define SPS_EXTENSION_LEN       4

PCWSTR g_RestartHiveNames[] = {
    L"default",
    L"security",
    L"software",
    L"system",
};

//
// Define helper macro to deal with subtleties of NT-level programming.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )
//
// Relevent registry key and values.
//
const PCWSTR SetupRegistryKeyName = L"\\Registry\\Machine\\SYSTEM\\Setup";
const PCWSTR RestartSpSetupValueName = L"RestartSpSetup";
const PCWSTR ConfigDirectory =L"\\SystemRoot\\System32\\Config";
const PCWSTR ProgressIndicator = L".";

//
// Copy buffer. What the heck, it doesn't take up any space in the image.
//
#define COPYBUF_SIZE 65536
UCHAR CopyBuffer[COPYBUF_SIZE];

//
// Tristate value, where a boolean just won't do.
//
typedef enum {
    xFALSE,
    xTRUE,
    xUNKNOWN
} TriState;


//
// Define structure for keeping a linked list of unicode strings.
//
typedef struct _COPY_LIST_NODE {
    LONGLONG FileSize;
    UNICODE_STRING UnicodeString;
    struct _COPY_LIST_NODE *Next;
} COPY_LIST_NODE, *PCOPY_LIST_NODE;

//
// Memory routines
//
#define MALLOC(size)    RtlAllocateHeap(RtlProcessHeap(),0,(size))
#define FREE(block)     RtlFreeHeap(RtlProcessHeap(),0,(block))

//
// Forward references
//
TriState
CheckRestartValue(
    VOID
    );

BOOLEAN
SetRestartValue(
    VOID
    );

BOOLEAN
SaveConfigForSpSetupRestart (
    VOID
    );

BOOLEAN
RestoreConfigForSpSetupRestart(
    VOID
    );

BOOLEAN
RestoreConfigDirectory(
    VOID
    );

NTSTATUS
CopyAFile(
    IN HANDLE DirectoryHandle,
    IN LONGLONG FileSize,
    IN PCWSTR ExistingFile,
    IN PCWSTR NewFile,
    IN BOOLEAN BackupTargetIfExists
    );

BOOLEAN
AreStringsEqual(
    IN PCWSTR String1,
    IN PCWSTR String2
    );

BOOLEAN
Message(
    IN ULONG MessageId,
    IN ULONG DotCount,
    ...
    );


BOOLEAN
pIsRestartHive (
    IN      PCWSTR HiveName
    )
{
    int i;

    for (i = 0; i < SIZEOFARRAY(g_RestartHiveNames); i++) {
        if (AreStringsEqual (g_RestartHiveNames[i], HiveName)) {
            return TRUE;
        }
    }
    return FALSE;
}

int
__cdecl
main(
    VOID
    )
{
    int Result = FAILURE;

    //
    // Check the status of the RestartSpSetup flag.
    // If not present, do nothing.
    // If FALSE, set to TRUE.
    // If TRUE, clean up config directory.
    //

    switch(CheckRestartValue()) {

    case xFALSE:

        if (SaveConfigForSpSetupRestart () && SetRestartValue()) {
            Result = SUCCESS;
        } else {
            Message(MSG_WARNING_CANT_SET_RESTART,0);
        }
        break;

    case xTRUE:

        Result = RestoreConfigForSpSetupRestart();
        Message(MSG_CRLF,0);
        if(!Result) {
            Message(MSG_WARNING_CANT_CLEAN_UP,0);
        }
        break;

    default:
        break;
    }

    return(Result);
}



TriState
CheckRestartValue(
    VOID
    )

/*++

Routine Description:

    Check if HKLM\System\Setup:RestartSpSetup is present as a REG_DWORD
    and if so get its value.

Arguments:

    None.

Return Value:

    Value indicating whether the flag is set (xTrue), not set (xFalse),
    or in an unknown state (ie, not present or not REG_DWORD, etc; xUnknown).

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    ULONG DataLength;
    UCHAR Buffer[1024];
    PKEY_VALUE_PARTIAL_INFORMATION KeyInfo;
    TriState b;

    //
    // Assume not present.
    //
    b = xUNKNOWN;

    //
    // Attempt to open the key.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,SetupRegistryKeyName);

    Status = NtOpenKey(
                &KeyHandle,
                READ_CONTROL | KEY_QUERY_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: Unable to open %ws (%lx)\n",
                   SetupRegistryKeyName,
                   Status));

        goto c0;
    }

    //
    // Attempt to get the value of "RestartSpSetup"
    //
    RtlInitUnicodeString(&UnicodeString,RestartSpSetupValueName);

    Status = NtQueryValueKey(
                KeyHandle,
                &UnicodeString,
                KeyValuePartialInformation,
                Buffer,
                sizeof(Buffer),
                &DataLength
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: Unable to get value of %ws (%lx)\n",
                   RestartSpSetupValueName,
                   Status));

        goto c1;
    }

    //
    // Check for a REG_DWORD value and fetch.
    //
    KeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;

    if((KeyInfo->Type == REG_DWORD) && (KeyInfo->DataLength == sizeof(ULONG))) {

        b = *(PULONG)KeyInfo->Data ? xTRUE : xFALSE;

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_INFO_LEVEL,
                   "RestartSpSetup: Restart value is %u\n",
                   b));

    } else {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: %ws is corrupt!\n",
                   RestartSpSetupValueName));
    }

c1:
    NtClose(KeyHandle);
c0:
    return(b);
}


BOOLEAN
SetRestartValue(
    VOID
    )

/*++

Routine Description:

    Set HKLM\System\Setup:RestartSpSetup to REG_DWORD 1.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    BOOLEAN b;
    ULONG One;

    //
    // Assume failure.
    //
    b = FALSE;

    //
    // Attempt to open the key, which must already be present.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,SetupRegistryKeyName);

    Status = NtOpenKey(
                &KeyHandle,
                READ_CONTROL | KEY_SET_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: Unable to open %ws (%lx)\n",
                   SetupRegistryKeyName,
                   Status));

        goto c0;
    }

    //
    // Attempt to set the value of "RestartSpSetup" to REG_DWORD 1.
    //
    RtlInitUnicodeString(&UnicodeString,RestartSpSetupValueName);
    One = 1;

    Status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_DWORD,
                &One,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: Unable to set value of %ws (%lx)\n",
                   RestartSpSetupValueName,
                   Status));

        goto c1;
    }

    //
    // Success.
    //
    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "RestartSpSetup: Value of %ws set to 1\n",
               RestartSpSetupValueName));

    b = TRUE;

c1:
    NtClose(KeyHandle);
c0:
    return(b);
}


BOOLEAN
SaveConfigForSpSetupRestart (
    VOID
    )

/*++

Routine Description:

    Prepares the system for restartability

Arguments:

    None.

Return Value:

    Boolean value indicating whether we were successful.

--*/

{
    NTSTATUS Status;
    HANDLE DirectoryHandle;
    HANDLE FileHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LONGLONG Buffer[2048/8];
    BOOLEAN FirstQuery;
    PFILE_DIRECTORY_INFORMATION FileInfo;
    USHORT LengthChars;
    BOOLEAN b;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN AnyErrors;
    PCOPY_LIST_NODE CopyList,CopyNode,NextNode;

    //
    // Open \SystemRoot\system32\config for list access.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,ConfigDirectory);

    Status = NtOpenFile(
                &DirectoryHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: unable to open system32\\config for list access (%lx)\n",
                   Status));

        return(FALSE);
    }

    FirstQuery = TRUE;
    FileInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;
    AnyErrors = FALSE;
    CopyList = NULL;
    do {

        Status = NtQueryDirectoryFile(
                    DirectoryHandle,
                    NULL,                           // no event to signal
                    NULL,                           // no apc routine
                    NULL,                           // no apc context
                    &IoStatusBlock,
                    Buffer,
                    sizeof(Buffer)-sizeof(WCHAR),   // leave room for terminating nul
                    FileDirectoryInformation,
                    TRUE,                           // want single entry
                    NULL,                           // get 'em all
                    FirstQuery
                    );

        if(NT_SUCCESS(Status)) {

            if(!(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                LengthChars = (USHORT)FileInfo->FileNameLength / sizeof(WCHAR);
                if (FileInfo->FileName[LengthChars]) {
                   FileInfo->FileName[LengthChars] = 0;
                }
                if (pIsRestartHive (FileInfo->FileName)) {
                    //
                    // remember .sav files for later.
                    //
                    if(CopyNode = MALLOC(sizeof(COPY_LIST_NODE))) {
                        if(RtlCreateUnicodeString(&CopyNode->UnicodeString,FileInfo->FileName)) {
                            CopyNode->FileSize = FileInfo->EndOfFile.QuadPart;
                            CopyNode->Next = CopyList;
                            CopyList = CopyNode;
                        } else {
                            Status = STATUS_NO_MEMORY;
                            FREE(CopyNode);
                        }
                    } else {
                        Status = STATUS_NO_MEMORY;
                    }
                }
            }

            FirstQuery = FALSE;
        }
    } while(NT_SUCCESS(Status));

    //
    // Check for normal loop termination.
    //
    if(Status == STATUS_NO_MORE_FILES) {
        Status = STATUS_SUCCESS;
    }

    //
    // Even if we got errors, try to keep going.
    //
    if(!NT_SUCCESS(Status)) {
        AnyErrors = TRUE;
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: Status %lx enumerating files\n",
                   Status));
    }

    //
    // Now run down our list of *.sav and copy to *.
    //
    for(CopyNode=CopyList; CopyNode; CopyNode=NextNode) {

        //
        // Remember next node, because we're going to free this one.
        //
        NextNode = CopyNode->Next;

        //
        // Create the target name, which is the same as the source name
        // with the .sav appended.
        //
        LengthChars = wcslen (CopyNode->UnicodeString.Buffer) + 1 + BACKUP_EXTENSION_LEN;
        UnicodeString.Buffer = MALLOC(LengthChars * sizeof(WCHAR));
        if(UnicodeString.Buffer) {
            UnicodeString.Length = UnicodeString.MaximumLength = LengthChars * sizeof(WCHAR);

            RtlCopyMemory (UnicodeString.Buffer, CopyNode->UnicodeString.Buffer, CopyNode->UnicodeString.Length);
            RtlCopyMemory (UnicodeString.Buffer + CopyNode->UnicodeString.Length, BACKUP_EXTENSION, BACKUP_EXTENSION_LEN * sizeof(WCHAR));
            UnicodeString.Buffer[LengthChars] = 0;

            Status = CopyAFile(
                        DirectoryHandle,
                        CopyNode->FileSize,
                        CopyNode->UnicodeString.Buffer,
                        UnicodeString.Buffer,
                        TRUE
                        );

        } else {
            Status = STATUS_NO_MEMORY;
        }

        if(!NT_SUCCESS(Status)) {
            AnyErrors = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "RestartSpSetup: Unable to copy %ws (%lx)\n",
                       CopyNode->UnicodeString.Buffer,Status));
        }

        FREE(CopyNode->UnicodeString.Buffer);
        FREE(CopyNode);
    }

    NtClose(DirectoryHandle);
    return((BOOLEAN)!AnyErrors);
}


BOOLEAN
RestoreConfigForSpSetupRestart(
    VOID
    )

/*++

Routine Description:

    Prepares the system for restarting gui mode setup.
    Currently this consists of erasing %sysroot%\system32\config\*,
    except *.sav, then copying *.sav to *.

Arguments:

    None.

Return Value:

    Boolean value indicating whether we were successful.

--*/

{
    BOOLEAN b;

    //
    // Display a message indicating that we are rolling back to the
    // start of gui mode setup.
    //
    Message(MSG_CRLF,0);
    Message(MSG_RESTARTING_SETUP,0);

    b = RestoreConfigDirectory();

    return b;
}

BOOLEAN
RestoreConfigDirectory(
    VOID
    )

/*++

Routine Description:

    Erase %sysroot%\system32\config\*, except *.sav, and userdiff,
    then copy *.sav to *.

Arguments:

    None.

Return Value:

    Boolean value indicating whether we were successful.

--*/

{
    NTSTATUS Status;
    HANDLE DirectoryHandle;
    HANDLE FileHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LONGLONG Buffer[2048/8];
    BOOLEAN FirstQuery;
    PFILE_DIRECTORY_INFORMATION FileInfo;
    ULONG LengthChars;
    BOOLEAN b;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN AnyErrors;
    PCOPY_LIST_NODE CopyList,CopyNode,NextNode;
    ULONG DotCount;

    //
    // Open \SystemRoot\system32\config for list access.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,ConfigDirectory);

    Status = NtOpenFile(
                &DirectoryHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    DotCount = 0;
    Message(MSG_RESTARTING_SETUP,++DotCount);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: unable to open system32\\config for list access (%lx)\n",
                   Status));

        return(FALSE);
    }

    FirstQuery = TRUE;
    FileInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;
    AnyErrors = FALSE;
    CopyList = NULL;
    do {

        Status = NtQueryDirectoryFile(
                    DirectoryHandle,
                    NULL,                           // no event to signal
                    NULL,                           // no apc routine
                    NULL,                           // no apc context
                    &IoStatusBlock,
                    Buffer,
                    sizeof(Buffer)-sizeof(WCHAR),   // leave room for terminating nul
                    FileDirectoryInformation,
                    TRUE,                           // want single entry
                    NULL,                           // get 'em all
                    FirstQuery
                    );

        if(NT_SUCCESS(Status)) {

            if(!(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                LengthChars = FileInfo->FileNameLength / sizeof(WCHAR);
                if (FileInfo->FileName[LengthChars]) {
                   FileInfo->FileName[LengthChars] = 0;
                }
                if (LengthChars > BACKUP_EXTENSION_LEN &&
                    AreStringsEqual (FileInfo->FileName + LengthChars - BACKUP_EXTENSION_LEN, BACKUP_EXTENSION)
                    ) {
                    FileInfo->FileName[LengthChars - BACKUP_EXTENSION_LEN] = 0;
                    b = pIsRestartHive (FileInfo->FileName);
                    FileInfo->FileName[LengthChars - BACKUP_EXTENSION_LEN] = L'.';
                    if (b) {
                        //
                        // remember .sav files for later.
                        //
                        if(CopyNode = MALLOC(sizeof(COPY_LIST_NODE))) {
                            if(RtlCreateUnicodeString(&CopyNode->UnicodeString,FileInfo->FileName)) {
                                CopyNode->FileSize = FileInfo->EndOfFile.QuadPart;
                                CopyNode->Next = CopyList;
                                CopyList = CopyNode;
                            } else {
                                Status = STATUS_NO_MEMORY;
                                FREE(CopyNode);
                            }
                        } else {
                            Status = STATUS_NO_MEMORY;
                        }
                    }
                }
            }

            FirstQuery = FALSE;
        }
    } while(NT_SUCCESS(Status));

    //
    // Check for normal loop termination.
    //
    if(Status == STATUS_NO_MORE_FILES) {
        Status = STATUS_SUCCESS;
    }

    //
    // Even if we got errors, try to keep going.
    //
    if(!NT_SUCCESS(Status)) {
        AnyErrors = TRUE;
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSpSetup: Status %lx enumerating files\n",
                   Status));
    }

    //
    // Now run down our list of *.sav and copy to *.
    //
    for(CopyNode=CopyList; CopyNode; CopyNode=NextNode) {

        Message(MSG_RESTARTING_SETUP,++DotCount);

        //
        // Remember next node, because we're going to free this one.
        //
        NextNode = CopyNode->Next;

        //
        // Create the target name, which is the same as the source name
        // with the .sav stripped off.
        //
        if(RtlCreateUnicodeString(&UnicodeString,CopyNode->UnicodeString.Buffer)) {

            UnicodeString.Buffer[(UnicodeString.Length/sizeof(WCHAR))-4] = 0;
            UnicodeString.Length -= 4*sizeof(WCHAR);

            Status = CopyAFile(
                        DirectoryHandle,
                        CopyNode->FileSize,
                        CopyNode->UnicodeString.Buffer,
                        UnicodeString.Buffer,
                        FALSE
                        );

            RtlFreeUnicodeString(&UnicodeString);

        } else {
            Status = STATUS_NO_MEMORY;
        }

        if(!NT_SUCCESS(Status)) {
            AnyErrors = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "RestartSpSetup: Unable to copy %ws (%lx)\n",
                       CopyNode->UnicodeString.Buffer,Status));
        }

        RtlFreeUnicodeString(&CopyNode->UnicodeString);
        FREE(CopyNode);
    }

    NtClose(DirectoryHandle);
    return((BOOLEAN)!AnyErrors);
}


NTSTATUS
CopyAFile(
    IN HANDLE DirectoryHandle,
    IN LONGLONG FileSize,
    IN PCWSTR ExistingFile,
    IN PCWSTR NewFile,
    IN BOOLEAN BackupTargetIfExists
    )

/*++

Routine Description:

    Performs a simple file copy within a directory.
    The target file must either not exist or be writable.
    Only the default stream is copied.

Arguments:

    DirectoryHandle - supplies handle to directory within which
        the file is to be copied. The handle must have appropriate
        access to allow this.

    FileSize - supplies size of file to be copied.

    ExistingFile - supplies filename of file within directory to
        be copied.

    NewFile - supplies name of file to be created as a copy of
        the existing file.

    BackupTargetIfExists - specifies if a backup of the target should
         be created (if target file exists) by appending ".sps"

Return Value:

    NT Status code indicating outcome.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    HANDLE SetAttributesHandle;
    ULONG XFerSize;
    PCWSTR NewFileBackup;
    UNICODE_STRING NewFileString;
    USHORT Length;
    PFILE_RENAME_INFORMATION RenameInformation;
    FILE_INFORMATION_CLASS SetInfoClass;
    FILE_BASIC_INFORMATION BasicInfo;
    ULONG SetInfoLength;
    PVOID SetInfoBuffer;


    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "RestartSpSetup: Copying %ws to %ws\n",
               ExistingFile,
               NewFile));

    //
    // backup the target fisrt, if it exists and the caller wanted that
    //
    if (BackupTargetIfExists) {

        INIT_OBJA(&ObjectAttributes,&UnicodeString,NewFile);
        ObjectAttributes.RootDirectory = DirectoryHandle;
        Status = NtOpenFile(&TargetHandle,
                            (ACCESS_MASK)DELETE | SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_SYNCHRONOUS_IO_NONALERT
                            );

        if(NT_SUCCESS(Status)) {
            //
            // the *.sav file does exist; NewFileString is *.sav.psp
            //
            Length = UnicodeString.Length + (SPS_EXTENSION_LEN + 1) * sizeof(WCHAR);
            NewFileString.Buffer = MALLOC(Length);
            if(!NewFileString.Buffer) {
                return STATUS_NO_MEMORY;
            }
            NewFileString.Length = NewFileString.MaximumLength = Length;

            RtlCopyMemory (NewFileString.Buffer, UnicodeString.Buffer, UnicodeString.Length);
            RtlCopyMemory (NewFileString.Buffer + UnicodeString.Length / sizeof(WCHAR), SPS_EXTENSION, SPS_EXTENSION_LEN * sizeof(WCHAR));
            NewFileString.Buffer[Length / sizeof(WCHAR)] = 0;

            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "RestartSpSetup: Backing up %ws to %ws\n",
                       NewFile,
                       NewFileString.Buffer
                       ));

            SetInfoClass = FileRenameInformation;
            SetInfoLength = NewFileString.Length + sizeof(*RenameInformation);
            SetInfoBuffer = MALLOC(SetInfoLength);
            if (!SetInfoBuffer) {
                FREE(NewFileString.Buffer);
                return STATUS_NO_MEMORY;
            }

            RenameInformation = (PFILE_RENAME_INFORMATION)SetInfoBuffer;
            RenameInformation->ReplaceIfExists = TRUE;
            RenameInformation->RootDirectory = DirectoryHandle;
            RenameInformation->FileNameLength = NewFileString.Length;
            RtlMoveMemory(RenameInformation->FileName,
                          NewFileString.Buffer,
                          NewFileString.Length);

            Status = NtSetInformationFile(TargetHandle,
                                          &IoStatusBlock,
                                          SetInfoBuffer,
                                          SetInfoLength,
                                          SetInfoClass);
            if (Status == STATUS_OBJECT_NAME_COLLISION) {

                //
                // oops, the *.sav.sps file does exist and it's read-only;
                // we must force the rename
                //
                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_INFO_LEVEL,
                           "RestartSpSetup: %ws exists and is read-only; resetting attribs\n",
                           NewFileString.Buffer
                           ));

                //
                // Open the file for Write Attributes access
                //
                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &NewFileString,
                    OBJ_CASE_INSENSITIVE,
                    DirectoryHandle,
                    NULL
                    );

                Status = NtOpenFile(&SetAttributesHandle,
                                        (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                        &ObjectAttributes,
                                        &IoStatusBlock,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        FILE_SYNCHRONOUS_IO_NONALERT);

                if(NT_SUCCESS(Status)){

                    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
                    BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

                    Status = NtSetInformationFile(SetAttributesHandle,
                                                      &IoStatusBlock,
                                                      &BasicInfo,
                                                      sizeof(BasicInfo),
                                                      FileBasicInformation);
                    NtClose(SetAttributesHandle);
                    if(NT_SUCCESS(Status)){
                        Status = NtSetInformationFile(TargetHandle,
                                                      &IoStatusBlock,
                                                      SetInfoBuffer,
                                                      SetInfoLength,
                                                      SetInfoClass);

                        if(NT_SUCCESS(Status)){
                            KdPrintEx((DPFLTR_SETUP_ID,
                                       DPFLTR_INFO_LEVEL,
                                       "RestartSpSetup: Re-Rename Worked OK\n"));
                        }
                        else {
                            KdPrintEx((DPFLTR_SETUP_ID,
                                       DPFLTR_WARNING_LEVEL,
                                       "RestartSpSetup: Re-Rename Failed - Status == %x\n",
                                       Status));
                        }
                    }
                    else {
                        KdPrintEx((DPFLTR_SETUP_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "RestartSpSetup: Set To NORMAL Failed - Status == %x\n",
                                   Status));
                    }
                }
                else {
                    KdPrintEx((DPFLTR_SETUP_ID,
                               DPFLTR_WARNING_LEVEL,
                               "RestartSpSetup: Open Existing file %ws Failed - Status == %x\n",
                               NewFileString.Buffer,
                               Status));
                }
            }

            NtClose(TargetHandle);
        }

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    //
    // Open the source for reading. The source must exist.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,ExistingFile);
    ObjectAttributes.RootDirectory = DirectoryHandle;

    Status = NtOpenFile(
                &SourceHandle,
                FILE_READ_DATA | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );

    if(!NT_SUCCESS(Status)) {
        goto c0;
    }

    //
    // Open/create the target for writing.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,NewFile);
    ObjectAttributes.RootDirectory = DirectoryHandle;

    Status = NtCreateFile(
                &TargetHandle,
                FILE_WRITE_DATA | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        goto c1;
    }

    //
    // Read/write buffers while there's still data to copy.
    //
    while(NT_SUCCESS(Status) && FileSize) {

        XFerSize = (FileSize < COPYBUF_SIZE) ? (ULONG)FileSize : COPYBUF_SIZE;

        Status = NtReadFile(
                    SourceHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    CopyBuffer,
                    XFerSize,
                    NULL,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {

            Status = NtWriteFile(
                        TargetHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        CopyBuffer,
                        XFerSize,
                        NULL,
                        NULL
                        );

            FileSize -= XFerSize;
        }
    }

    NtClose(TargetHandle);
c1:
    NtClose(SourceHandle);
c0:
    return(Status);
}


BOOLEAN
AreStringsEqual(
    IN PCWSTR String1,
    IN PCWSTR String2
    )

/*++

Routine Description:

    Compare 2 0-terminated unicode strings, case insensitively.

Arguments:

    String1 - supplies first string for comparison

    String2 - supplies second string for comparison

Return Value:

    Boolean value indicating whether strings are equal.
    TRUE = yes; FALSE = no.

--*/

{
    UNICODE_STRING u1;
    UNICODE_STRING u2;

    RtlInitUnicodeString(&u1,String1);
    RtlInitUnicodeString(&u2,String2);

    return((BOOLEAN)(RtlCompareUnicodeString(&u1,&u2,TRUE) == 0));
}


BOOLEAN
Message(
    IN ULONG MessageId,
    IN ULONG DotCount,
    ...
    )

/*++

Routine Description:

    Format and display a message, which is retreived from
    the image's message resources.

Arguments:

    MessageId - Supplies the message id of the message resource.

    DotCount - Supplies number of trailing dots to be appended to
        the message text prior to display. If this value is non-0,
        then the message shouldn't have a trailing cr/lf!

    Additional arguments specify message-specific inserts.

Return Value:

    Boolean value indicating whether the message was displayed.

--*/

{
    PVOID ImageBase;
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    va_list arglist;
    WCHAR Buffer[1024];
    ULONG u;

    //
    // Get our image base address
    //
    ImageBase = NtCurrentPeb()->ImageBaseAddress;
    if(!ImageBase) {
        return(FALSE);
    }

    //
    // Find the message.
    // For DBCS codepages we will use English resources instead of
    // default resource because we can only display ASCII characters onto
    // blue Screen via HalDisplayString()
    //
    Status = RtlFindMessage(
                ImageBase,
                11,
                NLS_MB_CODE_PAGE_TAG ? MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) : 0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // If the message is not unicode, convert to unicode.
    // Let the conversion routine allocate the buffer.
    //
    if(!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {

        RtlInitAnsiString(&AnsiString,MessageEntry->Text);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString,&AnsiString,TRUE);
        if(!NT_SUCCESS(Status)) {
            return(FALSE);
        }

    } else {
        //
        // Message is already unicode. Make a copy.
        //
        if(!RtlCreateUnicodeString(&UnicodeString,(PWSTR)MessageEntry->Text)) {
            return(FALSE);
        }
    }

    //
    // Format the message.
    //
    va_start(arglist,DotCount);

    Status = RtlFormatMessage(
                UnicodeString.Buffer,
                0,                      // max width
                FALSE,                  // don't ignore inserts
                FALSE,                  // args are not ansi
                FALSE,                  // args are not an array
                &arglist,
                Buffer,
                sizeof(Buffer)/sizeof(Buffer[0]),
                NULL
                );

    va_end(arglist);

    //
    // We don't need the message source any more. Free it.
    //
    RtlFreeUnicodeString(&UnicodeString);

    //
    // Add dots and cr.
    //
    for(u=0; u<DotCount; u++) {
        wcscat(Buffer,L".");
    }
    wcscat(Buffer,L"\r");

    //
    // Print out the message
    //
    RtlInitUnicodeString(&UnicodeString,Buffer);
    Status = NtDisplayString(&UnicodeString);

    return(NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\tryregdiff\tryregdiff.cpp ===
#include <windows.h>
#include <conio.h>
#include <stdio.h>
#include <tchar.h>
#include <time.h>
#include "regdiff.h"


DWORD
SnapshotCallback (
    IN      PVOID Context,
    IN      DWORD NodesProcessed
    )
{
    return ERROR_SUCCESS;
}



BOOL
TakeSnapshot (
    IN      HREGANL RegAnalyzer,
    IN      PCTSTR SnapshotFile,
    IN      PFNSNAPSHOTPROGRESS ProgressCallback,
    IN      PVOID Context,
    IN      DWORD MaxLevel,
	IN		HANDLE hEvent);


bool ReadMultipleKeys(HANDLE hRA) //read in some registry key names from the console
{
	_tprintf(TEXT("All Names are case sensitive\n"));

	bool result = false;

	while (true)
	{
		_tprintf(TEXT("Please enter the root key name (HKLM, HKCU, HKCR, HKU, HKCC)\n"
			   TEXT("or type 'quit' to stop entering keys\n")));

		TCHAR buf1[1024];
		_tscanf(TEXT("%s"), buf1);

		if (_tcscmp(buf1, TEXT("quit")) == 0)
			break;

		_tprintf(TEXT("Pleae enter the sub key name (e.g. SOFTWARE\\Microsoft\n"));

		TCHAR buf2[1024];
		_tscanf(TEXT("%s"), buf2);

		AddRegistryKey(hRA, buf1, buf2);
		result = true;
	}

	return result;
}



int __cdecl _tmain(int Argc, TCHAR **Argv)
{

	TCHAR helpmsg[] =	TEXT("\n\ntryregdiff usage:\n")
						TEXT("_________________\n\n")
						TEXT("Take Snapshot:\n")
						TEXT("    tryregdiff /s <rootkey> <subkey> <snapshot file>\n\n")
						TEXT("Take Snapshot with multiple keys:\n")
						TEXT("    tryregdiff /k <snapshot file>\n\n")
						TEXT("Compute Differences:\n")
						TEXT("    tryregdiff /d <snap f1> <snap f2> <diff f>\n\n")
						TEXT("Install Differences:\n")
						TEXT("    tryregdiff /i <diff f> <undo f>\n\n");
		
	bool bReadyToGo = false;
	
	if (Argc >= 3)
	{
		for (int k=0; k<Argc; k++)
			_tprintf(TEXT("%s\n"), Argv[k]);


		switch (Argv[1][1])
		{
		case TEXT('s'):	if (Argc == 5)
						bReadyToGo = true;
					break;

		case TEXT('d'):	if (Argc == 5)
						bReadyToGo = true;
					break;

		case TEXT('i'): 	if (Argc == 4)
						bReadyToGo = true;
					break;
		
		case TEXT('k'): 	if (Argc == 3)
						bReadyToGo = true;
					break;
		};
	}


	if (!bReadyToGo)
		_tprintf(TEXT("%s"), helpmsg);
	else
	{
		HREGANL hRA;

		time_t   start, finish;   long loop;   double   result, elapsed_time;
		time( &start );
		///////////////////////
		hRA = CreateRegAnalyzer();
		
		switch (Argv[1][1])
		{
		case 's':	
			{
				_tprintf(TEXT("taking snapshot...\n"));
				AddRegistryKey(hRA, Argv[2], Argv[3]);

				HANDLE hEvent = CreateEvent(0,0,0,0);
				TakeSnapshot(hRA, Argv[4], SnapshotCallback, 0, 3, hEvent);

				WaitForSingleObject(hEvent, INFINITE);
				break;
			}

		case 'd':
			{
				_tprintf(TEXT("computing differences...\n"));	
				
				HANDLE hEvent = CreateEvent(0,0,0,0);
				ComputeDifferences(hRA, Argv[2], Argv[3], Argv[4],hEvent);

				WaitForSingleObject(hEvent, INFINITE);
				break;
			}

		case 'i':	_tprintf(TEXT("installing differences...\n"));			
					InstallDifferences(Argv[2], Argv[3]);
					break;

		case 'k':	_tprintf(TEXT("taking snapshot of multiple keys...\n"));
					//if (ReadMultipleKeys(hRA))
					AddRegistryKey(hRA, TEXT("HKLM"), TEXT(""));
					for (int j=0; j<100; j++)
						ExcludeRegistryKey(hRA, TEXT("HKLM"), TEXT("SOFTWARE\\Matty"));

					ExcludeRegistryKey(hRA, TEXT("HKLM"), TEXT("SOFTWARE\\Microsoft"));
					ExcludeRegistryKey(hRA, TEXT("HKLM"), TEXT("SOFTWARE\\Intel"));
					ExcludeRegistryKey(hRA, TEXT("HKLM"), TEXT("SOFTWARE\\Gemplus"));
					ExcludeRegistryKey(hRA, TEXT("HKLM"), TEXT("SOFTWARE\\ODBC"));
					TakeSnapshot(hRA, Argv[2], SnapshotCallback, 0, 3, 0);
					break;
		};

		CloseRegAnalyzer(hRA);
		/////////////////
		time( &finish );
		elapsed_time = difftime( finish, start );
		printf("Program takes %6.0f seconds.", elapsed_time );
	}

	//c:\nt\base\ntsetup\srvpack\regdiff\debug\i386\regdiff.dll /s HKLM "" c:\uutext.txt
	printf("Press any key to quit");
	_getch();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\srvpack_binary_release\sources.inc ===
!IF 0

Copyright (c) 2002  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Rick Goodwill (richg)  2/14/2002

!ENDIF


!IF "$(LANG)" != "USA" && "$(LANG)" != "usa"
ALT_PROJECT_TARGET=$(LANG)
!ENDIF

BINPLACE_PLACEFILE=..\..\placefil.txt


TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=

!ifndef BDIR
BDIR=fre
!endif

SOURCES=

MISCFILES =  \
    $(BDIR)\spmsg.dll    \
    $(BDIR)\spcustom.dll \
    $(BDIR)\spuninst.exe \
    $(BDIR)\update.exe
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\spsetup\update2\update2.c ===
#include <windows.h>
#include <tchar.h>
#include "regdiff.h"

#define SIZEOFARRAY(a)      (sizeof (a) / sizeof (a[0]))
#define CHARS(text)       (SIZEOFARRAY(text)-1)

typedef
INT
(*PFNUPDATE2_CALL_PROTOTYPE) (
    IN      INT Argc,
    IN      TCHAR* Argv[]
    );


BOOL
pGetUserProfileDir (
    OUT     PTSTR Path,
    IN      DWORD BufChars
    )
{
    BOOL b = FALSE;
//  HANDLE token = NULL;

    if (ExpandEnvironmentStrings (TEXT("%USERPROFILE%"), Path, BufChars)) {
        b = TRUE;
    } else {
/*
        if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &token)) {
            rc = GetLastError ();
            __leave;
        }
        if (!GetUserProfileDirectory (token, Path, &BufChars)) {
            rc = GetLastError ();
            __leave;
        }
        if (token) {
            CloseHandle (token);
        }
*/
    }
    return b;
}

INT
ApplyDefUserChanges (
    IN      INT Argc,
    IN      TCHAR* Argv[]
    )
{
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;
    PFNINSTALLDIFFERENCES pfnInstallUserDiff;
    TCHAR fileUserDiff[MAX_PATH];
    TCHAR fileUserUndo[MAX_PATH];

    HMODULE hLibrary = LoadLibrary (TEXT("regdiff.dll"));
    if (!hLibrary) {
        return GetLastError ();
    }

    __try {
        pfnInstallUserDiff = (PFNINSTALLDIFFERENCES) GetProcAddress (hLibrary, "InstallDifferences");
        if (!pfnInstallUserDiff) {
            __leave;
        }
        if (!GetSystemDirectory (fileUserDiff, MAX_PATH)) {
            __leave;
        }
        lstrcat (fileUserDiff, TEXT("\\userdiff.rdf"));
        if (GetFileAttributes (fileUserDiff) == ~0) {
            __leave;
        }

        if (!pGetUserProfileDir (fileUserUndo, MAX_PATH)) {
            __leave;
        }
        lstrcat (fileUserUndo, TEXT("\\userundo.rdf"));
        if (!pfnInstallUserDiff (fileUserDiff, fileUserUndo)) {
            __leave;
        }
        b = TRUE;
    }
    __finally {
        rc = b ? ERROR_SUCCESS : GetLastError ();
        FreeLibrary (hLibrary);
    }
    return rc;
}


INT
__cdecl
_tmain (
    IN      INT Argc,
    IN      TCHAR* Argv[]
    )
{
    INT i;
    PCTSTR szModuleName = NULL;
    PCSTR procName = NULL;
    HMODULE hLibrary = NULL;
    PFNUPDATE2_CALL_PROTOTYPE proc = NULL;
    INT result = ERROR_INVALID_PARAMETER;

    //
    // Scan Command Line
    //
    for (i = 1; i < Argc; i++) {

        if (Argv[i][0] == TEXT('-') || Argv[i][0] == TEXT('/')) {

            if (!_tcsnicmp (&Argv[i][1], TEXT("spsetup"), CHARS(TEXT("spsetup")))) {

                if (Argv[i][1 + CHARS(TEXT("spsetup"))] == 0) {
                    szModuleName = TEXT("spsetup.dll");
                } else if (Argv[i][1 + CHARS(TEXT("spsetup"))] == TEXT(':')) {
                    szModuleName = &Argv[i][1 + CHARS(TEXT("spsetup:"))];
                } else {
                    return result;
                }
                procName = "SpsInstallServicePack";

            } else if (!_tcsnicmp (&Argv[i][1], TEXT("user"), CHARS(TEXT("user")))) {
                proc = ApplyDefUserChanges;
                break;
            } else {
                return result;
            }
        }
    }

    //
    // Load the Appropriate Libary and function pointer
    //
    if (procName && szModuleName && !proc) {
        hLibrary = LoadLibrary (szModuleName);

        if (hLibrary) {
            //
            // Call the target function.
            //
            proc = (PFNUPDATE2_CALL_PROTOTYPE) GetProcAddress (hLibrary, procName);
            if (proc) {
                result = proc (Argc, Argv);
            }
            //
            // done with the library
            //
            FreeLibrary (hLibrary);
        }
    } else if (proc && !procName && !szModuleName) {
        result = proc (Argc, Argv);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\svcpack\svcpack.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	svcpack.h

 --*/

#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wtypes.h>
#include <tchar.h>
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <winuser.h>
#include <commctrl.h>
#include <richedit.h>
#include <winsvc.h>
#include <prsht.h>

//
// Defining the EXPORT qualifier
//

BOOL
CALLBACK
SvcPackCallbackRoutine(
    IN  DWORD dwSetupInterval,
    IN  DWORD dwParam1,
    IN  DWORD dwParam2,
    IN  DWORD dwParam3
    )   ;

#define SVCPACK_PHASE_1 1
#define SVCPACK_PHASE_2 2
#define SVCPACK_PHASE_3 3
#define SVCPACK_PHASE_4 4

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\stripinf\stripinf.c ===
#include <stdio.h>
#include <stdlib.h>


/*
   This program reads NT SETUP INF files and removes:

        o   blank lines
        o   lines whose first non-white-space character is ';'
        o   all data after and including a non-quoted ';'
            character in a line


   Command line:

        stripinf  <input INF name>  <output INF name>

 */

#define MAX_CHARACTERS_PER_LINE    1000

#if !defined(TRUE)
    #define TRUE  1
    #define FALSE 0
#endif

typedef int bool ;

void die ( char * pszMsg )
{
    fprintf( stderr, "STRIPINF error: %s", pszMsg ) ;
    exit(3);
}


int processInf ( FILE * fIn, FILE * fOut )
{
    char chLine [ MAX_CHARACTERS_PER_LINE ] ;
    char * pch,
         * pchComment ;
    bool bKeep,
         bQuote,
         bStop ;

    for ( ; (! feof(fIn)) && (pch = fgets( chLine, sizeof chLine, fIn )) ; )
    {
        bStop = bQuote = bKeep = FALSE ;
        pchComment = NULL ;

        for ( ; *pch && (! bStop) ; pch++ )
        {
            switch ( *pch )
            {
            case '\n':
                 bStop = TRUE ;
                 break ;

            case '\0':
                 die( "input line longer than 1000 characters" ) ;
                 break ;

            case '\"':
                 bQuote = ! bQuote ;
                 bKeep = TRUE ;
                 break ;

            case ' ':
            case '\t':
                 break ;

            case ';':
                 if ( bQuote )
                     break ;
                 if ( bKeep )
                 {
                     *pch++ = '\n' ;
                     *pch   = '\0' ;
                 }
                 bStop = TRUE ;
                 break ;
	    case 0x1a: /* control-Z */
		 *pch = '\0';
		 break;

            default:
                 bKeep = TRUE ;
                 break ;
            }
        }

        if ( bKeep )
        {
            if ( fputs( chLine, fOut ) == EOF )
                die("failure writing output file") ;
        }
    }

    return TRUE ;
}

int
__cdecl
main ( int argc, char * argv[], char * envp[] )

{
    int i ;
    char * pchIn  = NULL,
         * pchOut = NULL,
         chOpt ;
    FILE * fIn, * fOut ;

    for ( i = 1 ; argv[i] ; i++ )
    {
         switch ( chOpt = argv[i][0] )
         {
         case '-':
         case '/':
             die( "invalid option" ) ;
             break;

         default:
             if ( pchIn == NULL )
                 pchIn = argv[i] ;
             else
             if ( pchOut == NULL )
                 pchOut = argv[i] ;
             else
                 die( "too many file specifications" ) ;

             break;
         }
    }

    if ( pchIn == NULL || pchOut == NULL )
        die( "too few file specifications" ) ;


    fIn = fopen( pchIn, "r" ) ;
    if ( ! fIn )
        die( "input file failed to open" ) ;

    fOut = fopen( pchOut, "w" );
    if ( ! fOut )
        die( "output file failed to open" );

    if ( ! processInf( fIn, fOut ) )
        die( "internal failure in processing" );

    fclose( fOut ) ;
    fclose( fIn ) ;

    return 0 ;
}

// End of STRIPINF.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\svcpack\svcpack.c ===
#include "svcpack.h"

//
// The module instance and name
//
HINSTANCE   hDllInstance;

//
// The path to the OS Source
//
TCHAR OsSourcePath[MAX_PATH];


//
// Function declarations
//
BOOL
DoPhaseOneWork(VOID);

BOOL
DoPhaseTwoWork(VOID);

BOOL
DoPhaseThreeWork(VOID);

BOOL
DoPhaseFourWork(VOID);

BOOL
InitializeSourcePath(
    PTSTR SourcePath,
    HINF  hInf
    );

BOOL
MyInstallProductCatalog(
    LPCTSTR PathToCatalog,
    LPCTSTR CatalogNoPath
    );

LPTSTR
CombinePaths(
    IN  LPTSTR ParentPath,
    IN  LPCTSTR ChildPath,
    OUT LPTSTR  TargetPath   // can be same as ParentPath if want to append
    );

BOOL
SpawnProcessAndWaitForItToComplete(
    IN  LPTSTR CommandLine,
    OUT PDWORD ReturnCode OPTIONAL
    );

BOOL
RunInfProcesses(
    IN     HINF     hInf
    );

BOOL
GetInfValue(
    IN  HINF   hInf,
    IN  LPTSTR SectionName,
    IN  LPTSTR KeyName,
    OUT PDWORD pdwValue
    );

BOOL
DoesInfVersionInfoMatch(
    IN     HINF     hInf
    );


BOOL
CALLBACK
SvcPackCallbackRoutine(
    IN  DWORD dwSetupInterval,
    IN  DWORD dwParam1,
    IN  DWORD dwParam2,
    IN  DWORD dwParam3
    )   

{

    switch ( dwSetupInterval ) {
        case SVCPACK_PHASE_1:
             //
             // install catalogs, etc.
             // 
             DoPhaseOneWork();
        case SVCPACK_PHASE_2:
        case SVCPACK_PHASE_3:
             break;

        case SVCPACK_PHASE_4:
             //
             // Do registry changes, etc.
             //
             DoPhaseFourWork();
             break;

    }

    return TRUE;

}




BOOL
WINAPI
DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvResreved)
{

    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            //
            // Save the module instance and name
            //
            hDllInstance = hInstance;

            break;

        case DLL_THREAD_DETACH:
            break;
        case DLL_PROCESS_DETACH:
            break;
        case DLL_THREAD_ATTACH:
        default:
            break;
    }
    return TRUE;
}

BOOL
DoPhaseOneWork(
    VOID
    )
/*++

Routine Description:

    Routine installs the catalogs listed in the svcpack.inf's
    [ProductCatalogsToInstall] section.  It is assumed that these
    catalogs are present at the os source path.
    

Arguments:

    None.


Return Value:

    TRUE if the catalogs were successfully installed.

--*/
{
    HINF hInf;
    TCHAR CatalogSourcePath[MAX_PATH];
    INFCONTEXT InfContext;
    BOOL RetVal = TRUE;
    
    //
    // Open the svcpack.inf so we can install items from it.
    //
    hInf = SetupOpenInfFile(
                        TEXT("SVCPACK.INF"),
                        NULL,
                        INF_STYLE_WIN4,
                        NULL);
    if (hInf == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    //
    // Make sure the INF has matching version info
    // Return TRUE even if the versions don't match so setup doesn't barf.
    //
    if (!DoesInfVersionInfoMatch(hInf)) {
        goto e0;        
    }

    //
    // Initialize the source path global variable and save it off for later.
    //
    if (!InitializeSourcePath(OsSourcePath,hInf)) {
        RetVal = FALSE;
        goto e0;        
    }


    //
    // see if we actually have any catalogs to install
    //
    if (SetupFindFirstLine(
                        hInf,
                        TEXT("ProductCatalogsToInstall"),
                        NULL,
                        &InfContext)) {
        UINT Count,Total;
        //
        // we have catalogs in the section, so let's install them.
        //
        Total = SetupGetLineCount(hInf, TEXT("ProductCatalogsToInstall"));

        for (Count = 0; Count < Total; Count++) {
            PCTSTR CatalogNoPath;

             //
             // retrieve a catalog name
             //
             if(SetupGetLineByIndex(
                            hInf, 
                            TEXT("ProductCatalogsToInstall"),
                            Count,
                            &InfContext)) {
                 CatalogNoPath = pSetupGetField(&InfContext,1);


                 //
                 // build the full path to the catalog
                 //
                 _tcscpy(CatalogSourcePath,OsSourcePath);
                 CombinePaths(
                         CatalogSourcePath,
                         CatalogNoPath,
                         CatalogSourcePath);

                 //
                 // now install the catalog
                 // 
                 if (!MyInstallProductCatalog(
                                    CatalogSourcePath,
                                    CatalogNoPath)) {
                    RetVal = FALSE;
                 }
             } else {
                 RetVal = FALSE;
             }
        }        
    }

e0:
    SetupCloseInfFile( hInf );    
    return(RetVal);
}

BOOL 
MyInstallProductCatalog(
    LPCTSTR PathToCatalog,
    LPCTSTR CatalogSourceNoPath
    )
/*++

Routine Description:

    Routine installs the specified catalog with the given source name.
    
    The routine will copy (and if necessary, expand) the catalog file.
    It then validates and installs the catalog.
    

Arguments:

    PathToCatalog - full path to catalog
    CatalogSourceNoPath - just the filename part of the catalog, which we use
                          as the filename of the catalog to be installed.


Return Value:

    TRUE if the catalogs were successfully installed.

--*/

{
    TCHAR CatalogDestPath[MAX_PATH];
    TCHAR CatalogDestWithPath[MAX_PATH];
    BOOL RetVal = FALSE;
    SetupapiVerifyProblem Problem = SetupapiVerifyCatalogProblem;

    //
    // we need to copy (and potentially expand) the catalog from the source,
    // and we use %windir% as a working directory.
    //
    if(GetWindowsDirectory(
                    CatalogDestPath, 
                    sizeof(CatalogDestPath)/sizeof(CatalogDestPath[0]))
        && GetTempFileName(
                    CatalogDestPath, 
                    TEXT("SETP"), 
                    0, 
                    CatalogDestWithPath)) {

        //
        // assume that media is already present -- since product catalogs
        // we installed just prior to this, we know that media was present
        // just a few moments ago
        //
        if ((SetupDecompressOrCopyFile(
                                PathToCatalog,
                                CatalogDestWithPath,
                                NULL) == NO_ERROR)

            && (pSetupVerifyCatalogFile(CatalogDestWithPath) == NO_ERROR)
            && (pSetupInstallCatalog(
                        CatalogDestWithPath,
                        CatalogSourceNoPath,
                        NULL) == NO_ERROR)) {
            RetVal = TRUE;
        }

        //
        // cleanup the temp file.
        //
        DeleteFile(CatalogDestWithPath);

    }

    return(RetVal);

}

BOOL
InitializeSourcePath(
    PTSTR SourcePath,
    HINF hInf
    )
/*++

Routine Description:

    Routine retrieves the os source path from the registry, then appends
    the subdirectory in the specified inf.    

Arguments:

    None.


Return Value:

    TRUE if the catalogs were successfully installed.

--*/

{
    HKEY hKey = NULL;
    TCHAR TempPath[MAX_PATH];
    TCHAR MyAnswerFile[MAX_PATH];
    DWORD Type,Size = MAX_PATH;
    INFCONTEXT InfContext;
    BOOL RetVal = FALSE;
    
    //
    // if it was already initialized to something, just return TRUE.
    //
    if (*SourcePath != (TCHAR)TEXT('\0')) {
        RetVal = TRUE;
        goto e0;
    }

        GetSystemDirectory(MyAnswerFile, MAX_PATH);
        CombinePaths( MyAnswerFile, TEXT("$winnt$.inf"), MyAnswerFile );

        GetPrivateProfileString( TEXT("Data"),
                                 TEXT("DosPath"),
                                 TEXT(""),
                                 TempPath,
                                 sizeof(TempPath)/sizeof(TCHAR),
                                 MyAnswerFile );
        _tcscpy(SourcePath,TempPath);
        RetVal = TRUE;

        //
        // now append the subdirectory specified in the inf (if any)
        //
        if (hInf && SetupFindFirstLine(
                            hInf,
                            TEXT("SetupData"),
                            TEXT("CatalogSubDir"),
                            &InfContext)) {
            PCTSTR p = pSetupGetField(&InfContext,1);

            CombinePaths(
                SourcePath,
                p,
                SourcePath);                        
        } 

e0:
    return(RetVal);
}


BOOL
DoPhaseFourWork(VOID)
{

    BOOL    Success = TRUE;
    HINF    hInf = NULL;

    //
    // Attempt to open the SVCPACK.INF file.
    // If found, and no problems with it, do
    // the associated work.
    //
    hInf = SetupOpenInfFile (
                TEXT("SVCPACK.INF"),
                NULL,
                INF_STYLE_WIN4,
                NULL
                );

    if (( hInf == NULL ) || ( hInf == INVALID_HANDLE_VALUE )) {
        Success = FALSE;
        goto exit0;
    }

    //
    // Make sure the INF has matching version info.
    // Return TRUE even if the versions don't match so setup doesn't barf.
    //
    if (!DoesInfVersionInfoMatch(hInf)) {
        goto exit1;
    }

    Success = RunInfProcesses( hInf );

exit1:
    SetupCloseInfFile( hInf );
exit0:
    return Success;

}


BOOL
SpawnProcessAndWaitForItToComplete(
    IN  LPTSTR CommandLine,
    OUT PDWORD ReturnCode OPTIONAL
    )
    {
    LPTSTR InternalCommandLine = NULL;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo;
    BOOL Success;

    //
    //  CreateProcess needs a non-const command line buffer because it likes
    //  to party on it.
    //
    InternalCommandLine = malloc( MAX_PATH );

    if ( InternalCommandLine == NULL ) {
        return FALSE;
    }

    _tcscpy( InternalCommandLine, CommandLine );

    ZeroMemory( &StartupInfo, sizeof( StartupInfo ));
    StartupInfo.cb = sizeof( StartupInfo );

    Success = CreateProcess(
                  NULL,
                  InternalCommandLine,
                  NULL,
                  NULL,
                  FALSE,
                  0,
                  NULL,
                  NULL,
                  &StartupInfo,
                  &ProcessInfo
                  );

    if ( ! Success ) {
        free( InternalCommandLine );
        return FALSE;
        }

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

    if ( ReturnCode != NULL ) {
        GetExitCodeProcess( ProcessInfo.hProcess, ReturnCode );
        }

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );
    free( InternalCommandLine );

    return TRUE;
    }


LPTSTR
CombinePaths(
    IN  LPTSTR ParentPath,
    IN  LPCTSTR ChildPath,
    OUT LPTSTR  TargetPath   // can be same as ParentPath if want to append
    )
    {
    ULONG ParentLength = _tcslen( ParentPath );
    LPTSTR p;

    if ( ParentPath != TargetPath ) {
        memcpy( TargetPath, ParentPath, ParentLength * sizeof(TCHAR) );
        }

    p = TargetPath + ParentLength;

    if (( ParentLength > 0 )   &&
        ( *( p - 1 ) != '\\' ) &&
        ( *( p - 1 ) != '/'  )) {
        *p++ = '\\';
        }

    _tcscpy( p, ChildPath );

    return TargetPath;
    }



BOOL
RunInfProcesses(
    IN     HINF     hInf
    )
{

    LPTSTR  SectionName = TEXT("SetupHotfixesToRun");
    LPTSTR  szFileName;
    LPTSTR  szFullPath;
    INFCONTEXT InfContext;
    BOOL Success = TRUE;

    //
    // Loop through all the lines in the SetupHotfixesToRun section,
    // spawning off each one.
    //
    szFileName = malloc( MAX_PATH );
    if (szFileName == NULL) {
       Success = FALSE;
       goto exit0;
    }

    szFullPath = malloc( MAX_PATH );
    if (szFullPath == NULL) {
       Success = FALSE;
       goto exit1;
    }
    
    Success = SetupFindFirstLine( hInf, SectionName, NULL, &InfContext ) &&
             SetupGetLineText( &InfContext, NULL, NULL, NULL, szFileName, MAX_PATH, NULL );
    
    while ( Success ) {
    
       *szFullPath = 0;
       CombinePaths( OsSourcePath, szFileName, szFullPath );
    
       //
       // OK, spawn the EXE, and ignore any errors returned
       //
       SpawnProcessAndWaitForItToComplete( szFullPath, NULL );
    
       Success = SetupFindNextLine( &InfContext, &InfContext ) &&
                 SetupGetLineText( &InfContext, NULL, NULL, NULL, szFileName, MAX_PATH, NULL );
    }
    
    Success = TRUE;
    free( (PVOID)szFullPath );         
exit1:
    free( (PVOID)szFileName );    
exit0:
    return Success;

}


BOOL
GetInfValue(
    IN  HINF   hInf,
    IN  LPTSTR SectionName,
    IN  LPTSTR KeyName,
    OUT PDWORD pdwValue
    )
    {
    BOOL Success;
    TCHAR TextBuffer[MAX_PATH];

    Success = SetupGetLineText(
                  NULL,
                  hInf,
                  SectionName,
                  KeyName,
                  TextBuffer,
                  (sizeof(TextBuffer)/sizeof(TCHAR)),
                  NULL
                  );

    *pdwValue = _tcstoul( TextBuffer, NULL, 0 );

    return Success;
    }



BOOL
DoesInfVersionInfoMatch(
    IN     HINF     hInf
    )
{

    DWORD dwBuildNumber, dwMajorVersion, dwMinorVersion;
    OSVERSIONINFOEX OsVersionInfo;

    if (( ! GetInfValue( hInf, TEXT("Version"), TEXT("BuildNumber"),  &dwBuildNumber )) ||
        ( ! GetInfValue( hInf, TEXT("Version"), TEXT("MajorVersion"), &dwMajorVersion )) ||
        ( ! GetInfValue( hInf, TEXT("Version"), TEXT("MinorVersion"), &dwMinorVersion ))) {

        return FALSE;
    }

    OsVersionInfo.dwOSVersionInfoSize = sizeof( OsVersionInfo );
    if (!GetVersionEx( (LPOSVERSIONINFO) &OsVersionInfo )) {

        return FALSE;
    }

    if ((OsVersionInfo.dwBuildNumber  != dwBuildNumber) ||
        (OsVersionInfo.dwMajorVersion != dwMajorVersion) ||
        (OsVersionInfo.dwMinorVersion != dwMinorVersion)) {

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\applyacl.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    applyacl.c

Abstract:

    Routines to apply default ACLs to system files and directories
    during setup.

Author:

    Ted Miller (tedm) 16-Feb-1996

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

#define MAXULONG    0xffffffff

//
// Universal well known SIDs
//
PSID NullSid;
PSID WorldSid;
PSID LocalSid;
PSID CreatorOwnerSid;
PSID CreatorGroupSid;

//
// SIDs defined by NT
//
PSID DialupSid;
PSID NetworkSid;
PSID BatchSid;
PSID InteractiveSid;
PSID ServiceSid;
PSID LocalSystemSid;
PSID AliasAdminsSid;
PSID AliasUsersSid;
PSID AliasGuestsSid;
PSID AliasPowerUsersSid;
PSID AliasAccountOpsSid;
PSID AliasSystemOpsSid;
PSID AliasPrintOpsSid;
PSID AliasBackupOpsSid;
PSID AliasReplicatorSid;


typedef struct _ACE_DATA {
    ACCESS_MASK AccessMask;
    PSID        *Sid;
    UCHAR       AceType;
    UCHAR       AceFlags;
} ACE_DATA, *PACE_DATA;

//
// This structure is valid for access allowed, access denied, audit,
// and alarm ACEs.
//
typedef struct _ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    //
    // The SID follows in the buffer
    //
} ACE, *PACE;


//
// Number of ACEs currently defined for files and directories.
//
#define DIRS_AND_FILES_ACE_COUNT 19

//
// Table describing the data to put into each ACE.
//
// This table will be read during initialization and used to construct a
// series of ACEs.  The index of each ACE in the Aces array defined below
// corresponds to the ordinals used in the ACL section of perms.inf
//
ACE_DATA AceDataTableForDirsAndFiles[DIRS_AND_FILES_ACE_COUNT] = {

    //
    // Index 0 is unused
    //
    { 0,NULL,0,0 },

    //
    // ACE 1
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasAccountOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 2
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 3
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasAdminsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 4
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &CreatorOwnerSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 5
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &NetworkSid,
        ACCESS_DENIED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 6
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &AliasPrintOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 7
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasReplicatorSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 8
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE,
        &AliasReplicatorSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 9
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 10
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasSystemOpsSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 11
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 12
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 13
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 14
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE
    },

    //
    // ACE 15
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 16
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_EXECUTE | GENERIC_WRITE,
        &WorldSid,
        ACCESS_ALLOWED_ACE_TYPE,
        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE
    },

    //
    // ACE 17
    // (for files and directories)
    //
    {
        GENERIC_ALL,
        &LocalSystemSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    },

    //
    // ACE 18
    // (for files and directories)
    //
    {
        GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE,
        &AliasPowerUsersSid,
        ACCESS_ALLOWED_ACE_TYPE,
        CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE
    }
};


//
// Array of ACEs to be applied to the objects (files and directories).
// They will be initialized during program startup based on the data in the
// AceDataTable. The index of each element corresponds to the
// ordinals used in the [ACL] section of perms.inf.
//
PACE AcesForDirsAndFiles[DIRS_AND_FILES_ACE_COUNT];

//
// Array that contains the size of each ACE in the
// array AcesForDirsAndFiles. These sizes are needed
// in order to allocate a buffer of the right size
// when we build an ACL.
//
ULONG AceSizesForDirsAndFiles[DIRS_AND_FILES_ACE_COUNT];



VOID
TearDownAces(
    IN OUT PACE*        AcesArray,
    IN     ULONG        ArrayCount
    );


VOID
TearDownSids(
    VOID
    );


DWORD
InitializeSids(
    VOID
    )

/*++

Routine Description:

    This function initializes the global variables used by and exposed
    by security.

Arguments:

    None.

Return Value:

    Win32 error indicating outcome.

--*/

{
    SID_IDENTIFIER_AUTHORITY NullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY NtAuthority         = SECURITY_NT_AUTHORITY;

    BOOL b = TRUE;

    //
    // Ensure the SIDs are in a well-known state
    //
    NullSid = NULL;
    WorldSid = NULL;
    LocalSid = NULL;
    CreatorOwnerSid = NULL;
    CreatorGroupSid = NULL;
    DialupSid = NULL;
    NetworkSid = NULL;
    BatchSid = NULL;
    InteractiveSid = NULL;
    ServiceSid = NULL;
    LocalSystemSid = NULL;
    AliasAdminsSid = NULL;
    AliasUsersSid = NULL;
    AliasGuestsSid = NULL;
    AliasPowerUsersSid = NULL;
    AliasAccountOpsSid = NULL;
    AliasSystemOpsSid = NULL;
    AliasPrintOpsSid = NULL;
    AliasBackupOpsSid = NULL;
    AliasReplicatorSid = NULL;

    //
    // Allocate and initialize the universal SIDs
    //
    b = b && AllocateAndInitializeSid(
                &NullSidAuthority,
                1,
                SECURITY_NULL_RID,
                0,0,0,0,0,0,0,
                &NullSid
                );

    b = b && AllocateAndInitializeSid(
                &WorldSidAuthority,
                1,
                SECURITY_WORLD_RID,
                0,0,0,0,0,0,0,
                &WorldSid
                );

    b = b && AllocateAndInitializeSid(
                &LocalSidAuthority,
                1,
                SECURITY_LOCAL_RID,
                0,0,0,0,0,0,0,
                &LocalSid
                );

    b = b && AllocateAndInitializeSid(
                &CreatorSidAuthority,
                1,
                SECURITY_CREATOR_OWNER_RID,
                0,0,0,0,0,0,0,
                &CreatorOwnerSid
                );

    b = b && AllocateAndInitializeSid(
                &CreatorSidAuthority,
                1,
                SECURITY_CREATOR_GROUP_RID,
                0,0,0,0,0,0,0,
                &CreatorGroupSid
                );

    //
    // Allocate and initialize the NT defined SIDs
    //
    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_DIALUP_RID,
                0,0,0,0,0,0,0,
                &DialupSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_NETWORK_RID,
                0,0,0,0,0,0,0,
                &NetworkSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_BATCH_RID,
                0,0,0,0,0,0,0,
                &BatchSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_INTERACTIVE_RID,
                0,0,0,0,0,0,0,
                &InteractiveSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_SERVICE_RID,
                0,0,0,0,0,0,0,
                &ServiceSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &LocalSystemSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0,0,0,0,0,0,
                &AliasAdminsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_USERS,
                0,0,0,0,0,0,
                &AliasUsersSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_GUESTS,
                0,0,0,0,0,0,
                &AliasGuestsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_POWER_USERS,
                0,0,0,0,0,0,
                &AliasPowerUsersSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                0,0,0,0,0,0,
                &AliasAccountOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_SYSTEM_OPS,
                0,0,0,0,0,0,
                &AliasSystemOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_PRINT_OPS,
                0,0,0,0,0,0,
                &AliasPrintOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_BACKUP_OPS,
                0,0,0,0,0,0,
                &AliasBackupOpsSid
                );

    b = b && AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_REPLICATOR,
                0,0,0,0,0,0,
                &AliasReplicatorSid
                );

    if(!b) {
        TearDownSids();
    }

    return(b ? NO_ERROR : GetLastError());
}


VOID
TearDownSids(
    VOID
    )
{
    if(NullSid) {
        FreeSid(NullSid);
    }
    if(WorldSid) {
        FreeSid(WorldSid);
    }
    if(LocalSid) {
        FreeSid(LocalSid);
    }
    if(CreatorOwnerSid) {
        FreeSid(CreatorOwnerSid);
    }
    if(CreatorGroupSid) {
        FreeSid(CreatorGroupSid);
    }
    if(DialupSid) {
        FreeSid(DialupSid);
    }
    if(NetworkSid) {
        FreeSid(NetworkSid);
    }
    if(BatchSid) {
        FreeSid(BatchSid);
    }
    if(InteractiveSid) {
        FreeSid(InteractiveSid);
    }
    if(ServiceSid) {
        FreeSid(ServiceSid);
    }
    if(LocalSystemSid) {
        FreeSid(LocalSystemSid);
    }
    if(AliasAdminsSid) {
        FreeSid(AliasAdminsSid);
    }
    if(AliasUsersSid) {
        FreeSid(AliasUsersSid);
    }
    if(AliasGuestsSid) {
        FreeSid(AliasGuestsSid);
    }
    if(AliasPowerUsersSid) {
        FreeSid(AliasPowerUsersSid);
    }
    if(AliasAccountOpsSid) {
        FreeSid(AliasAccountOpsSid);
    }
    if(AliasSystemOpsSid) {
        FreeSid(AliasSystemOpsSid);
    }
    if(AliasPrintOpsSid) {
        FreeSid(AliasPrintOpsSid);
    }
    if(AliasBackupOpsSid) {
        FreeSid(AliasBackupOpsSid);
    }
    if(AliasReplicatorSid) {
        FreeSid(AliasReplicatorSid);
    }
}



DWORD
InitializeAces(
    IN OUT PACE_DATA    DataTable,
    IN OUT PACE*        AcesArray,
    IN OUT PULONG       AceSizesArray,
    IN     ULONG        ArrayCount
    )

/*++

Routine Description:

    Initializes the array of ACEs as described in the DataTable

Arguments:

    DataTable - Pointer to the array that contains the data
                describing each ACE.
    AcesArray - Array that will contain the ACEs.

    AceSizesArray - Array that contains the sizes for each ACE.

    ArrayCount - Number of elements in each array.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    unsigned u;
    DWORD Length;
    DWORD rc;
    BOOL b;
    DWORD SidLength;

    //
    // Initialize to a known state.
    //
    ZeroMemory(AcesArray,ArrayCount*sizeof(PACE));

    //
    // Create ACEs for each item in the data table.
    // This involves merging the ace data with the SID data, which
    // are initialized in an earlier step.
    //
    for(u=1; u<ArrayCount; u++) {

        SidLength = GetLengthSid(*(DataTable[u].Sid));
        Length = SidLength + sizeof(ACE) + sizeof(ACCESS_MASK)- sizeof(ULONG);
        AceSizesArray[u] = Length;

        AcesArray[u] = malloc(Length);
        if(!AcesArray[u]) {
            TearDownAces(AcesArray, ArrayCount);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        AcesArray[u]->Header.AceType  = DataTable[u].AceType;
        AcesArray[u]->Header.AceFlags = DataTable[u].AceFlags;
        AcesArray[u]->Header.AceSize  = (WORD)Length;

        AcesArray[u]->Mask = DataTable[u].AccessMask;

        b = CopySid(
                SidLength,                           // Length - sizeof(ACE) + sizeof(ULONG),
                (PUCHAR)AcesArray[u] + sizeof(ACE),
                *(DataTable[u].Sid)
                );

        if(!b) {
            rc = GetLastError();
            TearDownAces(AcesArray, ArrayCount);
            return(rc);
        }
    }

    return(NO_ERROR);
}



VOID
TearDownAces(
    IN OUT PACE*        AcesArray,
    IN     ULONG        ArrayCount
    )

/*++

Routine Description:

    Destroys the array of ACEs as described in the DataTable

Arguments:

    None

Return Value:

    None

--*/

{
    unsigned u;


    for(u=1; u<ArrayCount; u++) {

        if(AcesArray[u]) {
            free(AcesArray[u]);
        }
    }
}


ULONG
ApplyAclToDirOrFile(
    IN PCWSTR FullPath,
    IN PULONG AcesToApply,
    IN ULONG  ArraySize
    )

/*++

Routine Description:

    Applies an ACL to a specified file or directory.

Arguments:

    FullPath - supplies full win32 path to the file or directory
        to receive the ACL

    AcesIndexArray - Array that contains the index to the ACEs to be used in the ACL.

    ArraySize - Number of elements in the array.

Return Value:

--*/

{
    DWORD AceCount;
    DWORD Ace;
    INT AceIndex;
    DWORD rc;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    PACL Acl;
    UCHAR AclBuffer[2048];
    BOOL b;
    PCWSTR AclSection;
    ACL_SIZE_INFORMATION AclSizeInfo;

    //
    // Initialize a security descriptor and an ACL.
    // We use a large static buffer to contain the ACL.
    //
    Acl = (PACL)AclBuffer;
    if(!InitializeAcl(Acl,sizeof(AclBuffer),ACL_REVISION2)
    || !InitializeSecurityDescriptor(&SecurityDescriptor,SECURITY_DESCRIPTOR_REVISION)) {
        return(GetLastError());
    }


    //
    // Build up the DACL from the indices on the list we just looked up
    // in the ACL section.
    //
    rc = NO_ERROR;
    AceCount = ArraySize;
    for(Ace=0; Ace < AceCount; Ace++) {
       AceIndex = AcesToApply[ Ace ];
       if((AceIndex == 0) || (AceIndex >= DIRS_AND_FILES_ACE_COUNT)) {
          return(ERROR_INVALID_DATA);
       }

        b = AddAce(
                Acl,
                ACL_REVISION2,
                MAXULONG,
                AcesForDirsAndFiles[AceIndex],
                AcesForDirsAndFiles[AceIndex]->Header.AceSize
                );

        //
        // Track first error we encounter.
        //
        if(!b) {
            rc = GetLastError();
        }
    }

    if(rc != NO_ERROR) {
        return(rc);
    }

    //
    // Truncate the ACL, since only a fraction of the size we originally
    // allocated for it is likely to be in use.
    //
    if(!GetAclInformation(Acl,&AclSizeInfo,sizeof(ACL_SIZE_INFORMATION),AclSizeInformation)) {
        return(GetLastError());
    }
    Acl->AclSize = (WORD)AclSizeInfo.AclBytesInUse;

    //
    // Add the ACL to the security descriptor as the DACL
    //
    if(!SetSecurityDescriptorDacl(&SecurityDescriptor,TRUE,Acl,FALSE)) {
        return(GetLastError());
    }

    //
    // Finally, apply the security descriptor.
    //
    rc = SetFileSecurity(FullPath,DACL_SECURITY_INFORMATION,&SecurityDescriptor)
       ? NO_ERROR
       : GetLastError();

    return(rc);
}



DWORD
ApplySecurityToRepairInfo(
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    DWORD d, TempError;
    WCHAR Directory[MAX_PATH];
    BOOL SetAclsNt;
    DWORD FsFlags;
    DWORD Result;
    BOOL b;
    ULONG Count;
    PWSTR  Files[] = {
        L"sam",
        L"security",
        L"software",
        L"system",
        L"default",
        L"ntuser.dat",
        L"sam._",
        L"security._",
        L"software._",
        L"system._",
        L"default._",
        L"ntuser.da_"
        };

    //
    // Get the file system of the system drive.
    // On x86 get the file system of the system partition.
    //
    d = NO_ERROR;
    SetAclsNt = FALSE;
    Result = GetWindowsDirectory(Directory,MAX_PATH);
    if(Result == 0) {
        MYASSERT(FALSE);
        return( GetLastError());
    }
    Directory[3] = 0;


    //
    //  ApplySecurity to directories and files, if needed
    //

    b = GetVolumeInformation(Directory,NULL,0,NULL,NULL,&FsFlags,NULL,0);
    if(b && (FsFlags & FS_PERSISTENT_ACLS)) {
        SetAclsNt = TRUE;
    }

    if(SetAclsNt) {
        //
        // Initialize SIDs
        //
        d = InitializeSids();
        if(d != NO_ERROR) {
            return(d);
        }
        //
        // Initialize ACEs
        //
        d = InitializeAces(AceDataTableForDirsAndFiles, AcesForDirsAndFiles, AceSizesForDirsAndFiles, DIRS_AND_FILES_ACE_COUNT);
        if(d != NO_ERROR) {
            TearDownSids();
            return(d);
        }
        //
        // Go do the real work.
        //
        for( Count = 0; Count < sizeof( Files ) / sizeof( PWSTR ); Count++ ) {
            ULONG   AcesToApply[] = {  2,
                                      17
                                    };

            GetWindowsDirectory(Directory,MAX_PATH);
            wcscat( Directory, L"\\repair\\" );
            wcscat( Directory, Files[ Count ] );
            TempError = ApplyAclToDirOrFile( Directory, AcesToApply, sizeof( AcesToApply) / sizeof( ULONG ) );
            if( TempError != NO_ERROR ) {
                if( d == NO_ERROR ) {
                    d = TempError;
                }
            }
        }

        //
        // Clean up.
        //
        TearDownAces(AcesForDirsAndFiles, DIRS_AND_FILES_ACE_COUNT);
        TearDownSids();
    }
    return(d);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\afpnp.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    afpnp.c

Abstract:

    Routines to manage installation of devices via the answer file.

    The main entry points are:

        CreateAfDriverTable
        DestroyAfDriverTable
        SyssetupInstallAnswerFileDriver
        CountAfDrivers

    The rest of the functions are utilities or routines used by outside
    callers only in a special case of some sort.

Author:

    Jim Schmidt (jimschm) 20-Mar-1998

Revision History:


--*/

#include "setupp.h"
#pragma hdrstop

//
// Contants
//

#if DBG
#define PNP_DEBUG  1
#else
#define PNP_DEBUG  0
#endif

#if PNP_DEBUG
#define PNP_DBGPRINT(x) DebugPrintWrapper x
#else
#define PNP_DBGPRINT(x)
#endif

//
// Local prototypes
//

BOOL
pBuildAfDriverAttribs (
    IN OUT  PAF_DRIVER_ATTRIBS Attribs
    );

BOOL
pAddAfDriver (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    IN      BOOL First
    );

PAF_DRIVER_ATTRIBS
pGetSelectedSourceDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    );


//
// Implementation
//

#if DBG

VOID
DebugPrintWrapper (
    PCSTR FormatStr,
    ...
    )
{
    va_list list;
    WCHAR OutStr[2048];
    WCHAR UnicodeFormatStr[256];

    //
    // Args are wchar by default!!
    //

    MultiByteToWideChar (CP_ACP, 0, FormatStr, -1, UnicodeFormatStr, 256);

    va_start (list, FormatStr);
    vswprintf (OutStr, UnicodeFormatStr, list);
    va_end (list);

    SetupDebugPrint (OutStr);
}

#endif

HINF
pOpenAnswerFile (
    VOID
    )
{
    HINF AnswerInf;
    WCHAR AnswerFile[MAX_PATH];

    GetSystemDirectory(AnswerFile,MAX_PATH);
    pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

    AnswerInf = SetupOpenInfFile(AnswerFile,NULL,INF_STYLE_OLDNT,NULL);
    return AnswerInf;
}


#define S_DEVICE_DRIVERSW       L"DeviceDrivers"

VOID
MySmartFree (
    PCVOID p
    )
{
    if (p) {
        MyFree (p);
    }
}


PVOID
MySmartAlloc (
    PCVOID Old,     OPTIONAL
    UINT Size
    )
{
    if (Old) {
        return MyRealloc ((PVOID) Old, Size);
    }

    return MyMalloc (Size);
}


PVOID
ReusableAlloc (
    IN OUT  PBUFFER Buf,
    IN      UINT SizeNeeded
    )
{
    if (!Buf->Buffer || Buf->Size < SizeNeeded) {
        Buf->Size = SizeNeeded - (SizeNeeded & 1023) + 1024;

        if (Buf->Buffer) {
            MyFree (Buf->Buffer);
        }

        Buf->Buffer = (PWSTR) MyMalloc (Buf->Size);
        if (!Buf->Buffer) {
            PNP_DBGPRINT (( "SETUP: Mem alloc failed for %u bytes. \n", Buf->Size ));
            Buf->Size = 0;
            return NULL;
        }
    }

    return Buf->Buffer;
}


VOID
ReusableFree (
    IN OUT  PBUFFER Buf
    )
{
    MySmartFree (Buf->Buffer);
    ZeroMemory (Buf, sizeof (BUFFER));
}


PWSTR
MultiSzAppendString (
    IN OUT  PMULTISZ MultiSz,
    IN      PCWSTR String
    )
{
    UINT BytesNeeded;
    UINT NewSize;
    PWSTR p;

    BytesNeeded = (UINT)((PBYTE) MultiSz->End - (PBYTE) MultiSz->Start);
    BytesNeeded += (UINT)(((PBYTE) wcschr (String, 0)) - (PBYTE) String) + sizeof (WCHAR);
    BytesNeeded += sizeof (WCHAR);

    if (!MultiSz->Start || MultiSz->Size < BytesNeeded) {
        NewSize = BytesNeeded - (BytesNeeded & 0xfff) + 0x1000;

        p = (PWSTR) MySmartAlloc (MultiSz->Start, NewSize);
        if (!p) {
            PNP_DBGPRINT (( "SETUP: Mem alloc failed for %u bytes", NewSize ));
            return NULL;
        }

        MultiSz->End = p + (MultiSz->End - MultiSz->Start);
        MultiSz->Start = p;
        MultiSz->Size = BytesNeeded;
    }

    p = MultiSz->End;
    lstrcpyW (p, String);
    MultiSz->End = wcschr (p, 0) + 1;

    MYASSERT (((PBYTE) MultiSz->Start + BytesNeeded) >= ((PBYTE) MultiSz->End + sizeof (WCHAR)));
    *MultiSz->End = 0;

    return p;
}


VOID
MultiSzFree (
    IN OUT  PMULTISZ MultiSz
    )
{
    MySmartFree (MultiSz->Start);
    ZeroMemory (MultiSz, sizeof (MULTISZ));
}


BOOL
EnumFirstMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr,
    IN      PCWSTR MultiSz
    )
{
    EnumPtr->Start = MultiSz;
    EnumPtr->Current = MultiSz;

    return MultiSz && *MultiSz;
}


BOOL
EnumNextMultiSz (
    IN OUT  PMULTISZ_ENUM EnumPtr
    )
{
    if (!EnumPtr->Current || *EnumPtr->Current == 0) {
        return FALSE;
    }

    EnumPtr->Current = wcschr (EnumPtr->Current, 0) + 1;
    return *EnumPtr->Current;
}


BOOL
pBuildAfDriverAttribs (
    IN OUT  PAF_DRIVER_ATTRIBS Attribs
    )

/*++

Routine Description:

  pBuildAfDriverAttribs updates the driver attribute structure by setting all
  the members of the structure.  If the members were previously set, this
  function is a NOP.

Arguments:

  Attribs - Specifies the answer file driver attribute structure, which does
            not need to be empty.  Receives the attributes.

Return Value:

  TRUE if the driver is valid, or FALSE if something went wrong during
  attribute gathering.

--*/

{
    PWSTR p;
    INFCONTEXT ic;
    BUFFER Buf = BUFFER_INIT;

    if (Attribs->Initialized) {
        return TRUE;
    }

    Attribs->Initialized = TRUE;

    //
    // Compute paths
    //

    Attribs->FilePath = pSetupDuplicateString (Attribs->InfPath);

    p = wcsrchr (Attribs->FilePath, L'\\');
    if (p) {
        *p = 0;
    }

    Attribs->Broken = (Attribs->InfPath == NULL) ||
                      (Attribs->FilePath == NULL);

    //
    // Open the INF and look for ClassInstall32
    //

    if (!Attribs->Broken) {
        Attribs->InfHandle = SetupOpenInfFile (Attribs->InfPath, NULL, INF_STYLE_WIN4, NULL);
        Attribs->Broken = (Attribs->InfHandle == INVALID_HANDLE_VALUE);
    }

    if (!Attribs->Broken) {

#if defined _X86_
        Attribs->ClassInstall32Section = L"ClassInstall32.NTx86";
#elif defined _AMD64_
        Attribs->ClassInstall32Section = L"ClassInstall32.NTAMD64";
#elif defined _IA64_
        Attribs->ClassInstall32Section = L"ClassInstall32.NTIA64";
#else
#error "No Target Architecture"
#endif

        if (!SetupFindFirstLine (
                Attribs->InfHandle,
                Attribs->ClassInstall32Section,
                NULL,
                &ic
                )) {

            Attribs->ClassInstall32Section = L"ClassInstall32.NT";

            if (!SetupFindFirstLine (
                    Attribs->InfHandle,
                    Attribs->ClassInstall32Section,
                    NULL,
                    &ic
                    )) {

                Attribs->ClassInstall32Section = L"ClassInstall32";

                if (!SetupFindFirstLine (
                        Attribs->InfHandle,
                        Attribs->ClassInstall32Section,
                        NULL,
                        &ic
                        )) {

                    Attribs->ClassInstall32Section = NULL;

                }
            }
        }
    }

    if (!Attribs->Broken && Attribs->ClassInstall32Section) {
        //
        // ClassInstall32 was found, so there's got to be a GUID
        //

        if (SetupFindFirstLine (
                Attribs->InfHandle,
                L"Version",
                L"ClassGUID",
                &ic
                )) {

            p = (PWSTR) SyssetupGetStringField (&ic, 1, &Buf);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid GUID line. \n" ));
            } else {
                if (!pSetupGuidFromString (p, &Attribs->Guid)) {
                    PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid GUID. \n" ));
                }
            }
        }
        else {
            PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: ClassInstall32 found but GUID not found. \n" ));
        }
    }

    ReusableFree (&Buf);

    return !Attribs->Broken;
}


PCWSTR
SyssetupGetStringField (
    IN      PINFCONTEXT InfContext,
    IN      DWORD Field,
    IN OUT  PBUFFER Buf
    )

/*++

Routine Description:

  SyssetupGetStringField is a wrapper for SetupGetStringField.   It uses the
  BUFFER structure to minimize allocation requests.

Arguments:

  InfContext - Specifies the INF context as provided by other Setup API
               functions.
  Field      - Specifies the field to query.
  Buf        - Specifies the buffer to reuse.  Any previously allocated
               pointers to this buffer's data are invalid.  The caller must
               free the buffer.

Return Value:

  A pointer to the string, allocated in Buf, or NULL if the field does not
  exist or an error occurred.

--*/

{
    DWORD SizeNeeded;
    DWORD BytesNeeded;
    PWSTR p;

    if (!SetupGetStringField (InfContext, Field, NULL, 0, &SizeNeeded)) {
        return NULL;
    }

    BytesNeeded = (SizeNeeded + 1) * sizeof (WCHAR);
    p = ReusableAlloc (Buf, BytesNeeded);

    if (p) {
        if (!SetupGetStringField (InfContext, Field, p, SizeNeeded, NULL)) {
            return NULL;
        }
    }

    return p;
}


INT
CountAfDrivers (
    IN      PAF_DRIVERS Drivers,
    OUT     INT *ClassInstallers        OPTIONAL
    )

/*++

Routine Description:

  CountAfDrivers enumerates the drivers in the table specified and returns
  the count.  The caller can also receive the number of class installers (a
  subset of the driver list).  Querying the number of class installers may
  take a little time if there are a lot of drivers listed in the answer file
  and the driver INFs have not been opened yet.  (Otherwise this routine is
  very fast.)

Arguments:

  Drivers         - Specifies the driver table to process.
  ClassInstallers - Receives a count of the number of class installers
                    specified in the answer file.

Return Value:

  The number of drivers specified in the answer file.

--*/

{
    AF_DRIVER_ENUM e;
    INT UniqueDriverDirs;

    MYASSERT (Drivers && Drivers->DriverTable);

    //
    // Count entries in the DriverTable string table, and open each one to look for
    // a ClassInstall32 section
    //

    UniqueDriverDirs = 0;
    *ClassInstallers  = 0;

    if (EnumFirstAfDriver (&e, Drivers)) {
        do {
            if (ClassInstallers) {
                if (e.Driver->ClassInstall32Section) {
                    *ClassInstallers += 1;
                }
            }

            UniqueDriverDirs++;

        } while (EnumNextAfDriver (&e));
    }

    return UniqueDriverDirs;
}


PAF_DRIVERS
CreateAfDriverTable (
    VOID
    )

/*++

Routine Description:

  CreateAfDriverTable generates a string table populated with the paths
  to device driver INFs specified in the answer file.  This is the first step
  in processing the [DeviceDrivers] section of unattend.txt.

  The caller must destroy a non-NULL driver table via DestroyAfDriverTable
  to free memory used by the table and each entry in the table.

Arguments:

  None.

Return Value:

  A pointer to the populated string table, or NULL if no entries exist.

--*/

{
    PAF_DRIVERS Drivers;
    HINF AnswerInf;
    PVOID NewDriverTable;
    INFCONTEXT ic;
    PWSTR InfPath;
    PCWSTR OriginalInstallMedia;
    PWSTR PnpId;
    PWSTR p;
    BOOL FoundOne = FALSE;
    PAF_DRIVER_ATTRIBS Attribs;
    PAF_DRIVER_ATTRIBS FirstAttribs = NULL;
    BUFFER b1, b2, b3;
    LONG Index;

    //
    // Init
    //

    AnswerInf = pOpenAnswerFile();
    if (AnswerInf == INVALID_HANDLE_VALUE) {
        return NULL;
    }

    NewDriverTable = pSetupStringTableInitializeEx (sizeof (PAF_DRIVER_ATTRIBS), 0);
    if (!NewDriverTable) {
        PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: String table alloc failed. \n" ));
        SetupCloseInfFile (AnswerInf);
        return NULL;
    }

    ZeroMemory (&b1, sizeof (b1));
    ZeroMemory (&b2, sizeof (b2));
    ZeroMemory (&b3, sizeof (b3));

    //
    // Build a list of unique INF paths that are in the [DeviceDrivers]
    // section of the answer file, if any.
    //

    if (SetupFindFirstLine (AnswerInf, S_DEVICE_DRIVERSW, NULL, &ic)) {
        do {
            //
            // Get the data from the answer file
            //

            p = (PWSTR) SyssetupGetStringField (&ic, 0, &b1);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid answer file line ignored. \n" ));
                continue;
            }

            PnpId = p;

            p = (PWSTR) SyssetupGetStringField (&ic, 1, &b2);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Invalid answer file line ignored. \n" ));
                continue;
            }

            InfPath = p;

            p = (PWSTR) SyssetupGetStringField (&ic, 2, &b3);
            if (!p) {
                PNP_DBGPRINT (( "SETUP: No original media path; assuming floppy \n" ));
                OriginalInstallMedia = IsNEC_98 ? L"C:\\" : L"A:\\";
            } else {
                OriginalInstallMedia = p;
            }

            //
            // Check to see if INF path has already been added.  If so, add PNP
            // ID to list of IDs, and continue to next PNP ID.
            //

            Index = pSetupStringTableLookUpString (
                        NewDriverTable,
                        InfPath,
                        STRTAB_CASE_INSENSITIVE
                        );

            if (Index != -1) {
                //
                // Get the Attribs struct
                //

                if (!pSetupStringTableGetExtraData (
                        NewDriverTable,
                        Index,
                        &Attribs,
                        sizeof (Attribs)
                        )) {
                    PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: String table extra data failure. \n" ));
                    continue;
                }

                MultiSzAppendString (&Attribs->PnpIdList, PnpId);
                continue;
            }

            //
            // New INF path: Allocate an attribute structure and put the path in a
            // string table.
            //

            Attribs = (PAF_DRIVER_ATTRIBS) MyMalloc (sizeof (AF_DRIVER_ATTRIBS));
            if (!Attribs) {
                PNP_DBGPRINT ((
                    "SETUP: CreateAfDriverTable: Mem alloc failed for %u bytes. \n",
                    sizeof (AF_DRIVER_ATTRIBS)
                    ));

                break;
            }

            ZeroMemory (Attribs, sizeof (AF_DRIVER_ATTRIBS));
            Attribs->InfHandle = INVALID_HANDLE_VALUE;
            Attribs->InfPath  = pSetupDuplicateString (InfPath);
            Attribs->OriginalInstallMedia = pSetupDuplicateString (OriginalInstallMedia);
            MultiSzAppendString (&Attribs->PnpIdList, PnpId);

            Attribs->Next = FirstAttribs;
            FirstAttribs = Attribs;

            pSetupStringTableAddStringEx (
                NewDriverTable,
                InfPath,
                STRTAB_CASE_INSENSITIVE,
                &Attribs,
                sizeof (Attribs)
                );

            FoundOne = TRUE;

        } while (SetupFindNextLine (&ic, &ic));
    }

    //
    // Clean up and exit
    //

    SetupCloseInfFile (AnswerInf);

    ReusableFree (&b1);
    ReusableFree (&b2);
    ReusableFree (&b3);

    if (FoundOne) {
        Drivers = (PAF_DRIVERS) MyMalloc (sizeof (AF_DRIVERS));
        if (Drivers) {
            Drivers->DriverTable = NewDriverTable;
            Drivers->FirstDriver = FirstAttribs;

            //
            // Exit with success
            //

            return Drivers;
        }
        else {
            PNP_DBGPRINT (( "SETUP: CreateAfDriverTable: Can't allocate %u bytes. \n", sizeof (AF_DRIVERS) ));
        }
    }

    //
    // Failure or empty
    //

    pSetupStringTableDestroy (NewDriverTable);
    return NULL;
}


VOID
DestroyAfDriverTable (
    IN      PAF_DRIVERS Drivers
    )

/*++

Routine Description:

  DestroyAfDriverTable enumerates the specified driver table and cleans up
  all memory used by the table.

Arguments:

  Drivers - Specifies the table to clean up.  Caller should not use table
            handle after this routine completes.

Return Value:

  None.

--*/

{
    AF_DRIVER_ENUM e;

    if (!Drivers) {
        return;
    }

    MYASSERT (Drivers->DriverTable);

    if (EnumFirstAfDriverEx (&e, Drivers, TRUE)) {
        do {
            MySmartFree (e.Driver->InfPath);
            MySmartFree (e.Driver->FilePath);
            MultiSzFree (&e.Driver->PnpIdList);

            if (e.Driver->InfHandle != INVALID_HANDLE_VALUE) {
                SetupCloseInfFile (e.Driver->InfHandle);
            }
        } while (EnumNextAfDriver (&e));
    }

    pSetupStringTableDestroy (Drivers->DriverTable);
}


BOOL
EnumFirstAfDriver (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers
    )

/*++

Routine Description:

  EnumFirstAfDriver returns attributes for the first answer file-supplied
  driver.  The driver is returned in the enum structure.

Arguments:

  EnumPtr - Receives a pointer to the first valid driver (supplied in the
            answer file).
  Drivers - Specifies the driver table to enumerate.

Return Value:

  TRUE if a driver was enumerated, or FALSE if none exist.

--*/

{
    return EnumFirstAfDriverEx (EnumPtr, Drivers, FALSE);
}


BOOL
EnumFirstAfDriverEx (
    OUT     PAF_DRIVER_ENUM EnumPtr,
    IN      PAF_DRIVERS Drivers,
    IN      BOOL WantAll
    )

/*++

Routine Description:

  EnumFirstAfDriverEx works the same as EnumFirstAfDriver, except it
  optionally enumerates all drivers (i.e., those considered "broken").

Arguments:

  EnumPtr - Receives the first driver supplied in the answer file.
  Drivers - Specifies the driver table to enumerate.
  WantAll - Specifies TRUE if broken drivers should be enumerated, or FALSE
            if they should be skipped.

Return Value:

  TRUE if a driver was enumerated, or FALSE if none exist.

--*/

{
    if (!Drivers) {
        return FALSE;
    }

    MYASSERT (Drivers->DriverTable);

    EnumPtr->Driver  = Drivers->FirstDriver;
    EnumPtr->WantAll = WantAll;

    if (!WantAll && EnumPtr->Driver) {
        //
        // Make sure attribs are accurate
        //

        pBuildAfDriverAttribs (EnumPtr->Driver);
    }

    if (!WantAll && EnumPtr->Driver && EnumPtr->Driver->Broken) {
        return EnumNextAfDriver (EnumPtr);
    }

    return EnumPtr->Driver != NULL;
}


BOOL
EnumNextAfDriver (
    IN OUT  PAF_DRIVER_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextAfDriver continues an enumeration started by
  EnumFirstAfDriver(Ex).

Arguments:

  EnumPtr - Specifies the enumeration to continue.  Receives the next driver
            pointer.

Return Value:

  TRUE if another driver was enumerated, or FALSE if no more drivers exist.

--*/

{
    if (!EnumPtr->Driver) {
        return FALSE;
    }

    do {

        EnumPtr->Driver = EnumPtr->Driver->Next;

        if (!EnumPtr->WantAll && EnumPtr->Driver) {
            //
            // Make sure attribs are accurate
            //

            pBuildAfDriverAttribs (EnumPtr->Driver);
        }

    } while (EnumPtr->Driver && EnumPtr->Driver->Broken && !EnumPtr->WantAll);

    return EnumPtr->Driver != NULL;
}


PWSTR
pMyGetDeviceRegistryProperty (
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    IN      DWORD Property,
    IN OUT  PBUFFER Buf
    )
{
    DWORD SizeNeeded;
    DWORD Type;
    PBYTE p;

    SizeNeeded = 0;

    SetupDiGetDeviceRegistryProperty (
        hDevInfo,
        DeviceInfoData,
        Property,
        &Type,
        NULL,
        0,
        &SizeNeeded
        );

    if (!SizeNeeded) {
        return NULL;
    }

    if (Type != REG_MULTI_SZ) {
        PNP_DBGPRINT (( "SETUP: Device ID not REG_MULTI_SZ. \n" ));
        return NULL;
    }

    p = ReusableAlloc (Buf, SizeNeeded);
    if (!p) {
        return NULL;
    }

    if (!SetupDiGetDeviceRegistryProperty (
            hDevInfo,
            DeviceInfoData,
            Property,
            NULL,
            p,
            SizeNeeded,
            NULL
            )) {
        return NULL;
    }

    return (PWSTR) p;
}


VOID
pAddIdsToStringTable (
    IN OUT  PVOID StringTable,
    IN      PWSTR IdString
    )
{
    MULTISZ_ENUM e;

    if (EnumFirstMultiSz (&e, IdString)) {
        do {
            PNP_DBGPRINT (( "SETUP: Device has PNP ID %s \n", e.Current));
            pSetupStringTableAddString (StringTable, (PWSTR) e.Current, STRTAB_CASE_INSENSITIVE);
        } while (EnumNextMultiSz (&e));
    }
}


PSP_DRVINFO_DETAIL_DATA
pMyGetDriverInfoDetail (
    IN     HDEVINFO         hDevInfo,
    IN     PSP_DEVINFO_DATA DeviceInfoData,
    IN     PSP_DRVINFO_DATA DriverInfoData,
    IN OUT PBUFFER Buf
    )
{
    PSP_DRVINFO_DETAIL_DATA Ptr;
    DWORD SizeNeeded = 0;

    SetupDiGetDriverInfoDetail (
        hDevInfo,
        DeviceInfoData,
        DriverInfoData,
        NULL,
        0,
        &SizeNeeded
        );

    if (!SizeNeeded) {
        PNP_DBGPRINT (( "SETUP: SetupDiGetDriverInfoDetail failed to get size for answer file driver, error 0%Xh. \n", GetLastError() ));
        return NULL;
    }

    Ptr = (PSP_DRVINFO_DETAIL_DATA) ReusableAlloc (Buf, SizeNeeded);

    if (!Ptr) {
        return NULL;
    }

    Ptr->cbSize = sizeof (SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail (
            hDevInfo,
            DeviceInfoData,
            DriverInfoData,
            Ptr,
            SizeNeeded,
            NULL
            )) {
        PNP_DBGPRINT (( "SETUP: SetupDiGetDriverInfoDetail failed for answer file driver, error 0%Xh. \n", GetLastError() ));
        return NULL;
    }

    return Ptr;
}


BOOL
SyssetupInstallAnswerFileDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    OUT     PAF_DRIVER_ATTRIBS *AfDriver
    )

/*++

Routine Description:

    SyssetupInstallAnswerFileDriver builds a device list from each
    answer file-specified driver and tests it against the current
    device.  If support is found, the device is installed.

Arguments:

    Drivers - Specifies the structure that maintains answer file-supplied
              driver attributes.  If Drivers is NULL, no processing is
              performed.

    hDevInfo - Specifies the device info handle for the device being
               processed

    DeviceInfoData - Specifies device state.

    AfDriver - Receives a pointer to the selected answer file driver
               details, or NULL if no answer file driver was selected.

Return Value:

    Returns TRUE if a driver was successfully installed.

--*/

{
    AF_DRIVER_ENUM e;
    PVOID PnpIdTable;
    BUFFER Buf = BUFFER_INIT;
    BOOL b = FALSE;
    PWSTR IdString;
    MULTISZ_ENUM AfId;
    BOOL First = TRUE;
    WCHAR CurrentId[512];
    PWSTR p;
    SP_DEVINSTALL_PARAMS deviceInstallParams;

    *AfDriver = NULL;

    PnpIdTable = pSetupStringTableInitialize();
    if (!PnpIdTable) {
        return FALSE;
    }

    __try {
        //
        // Enumeration will fail if there are no drivers specified in the answer file
        //

        if (!EnumFirstAfDriver (&e, Drivers)) {
            __leave;
        }

        //
        // Determine IDs of the device
        //

        IdString = pMyGetDeviceRegistryProperty (
                        hDevInfo,
                        DeviceInfoData,
                        SPDRP_HARDWAREID,
                        &Buf
                        );

        if (IdString) {
            pAddIdsToStringTable (PnpIdTable, IdString);
        }

        IdString = pMyGetDeviceRegistryProperty (
                        hDevInfo,
                        DeviceInfoData,
                        SPDRP_COMPATIBLEIDS,
                        &Buf
                        );

        if (IdString) {
            pAddIdsToStringTable (PnpIdTable, IdString);
        }

        //
        // For each af-supplied driver, compare driver IDs against device IDs
        //

        do {
            //
            // Look for PNP match
            //

            if (EnumFirstMultiSz (&AfId, e.Driver->PnpIdList.Start)) {
                do {
                    if (-1 != pSetupStringTableLookUpString (
                                    PnpIdTable,
                                    (PWSTR) AfId.Current,
                                    STRTAB_CASE_INSENSITIVE
                                    )) {

                        //
                        // Found match, add INF to the list of choices
                        //

                        if (!pAddAfDriver (e.Driver, hDevInfo, DeviceInfoData, First)) {
                            __leave;
                        }

                        First = FALSE;

                    }
                } while (EnumNextMultiSz (&AfId));
            }

        } while (EnumNextAfDriver (&e));

        //
        // If First is still TRUE, then we have no match
        //

        if (First) {
            __leave;
        }

        //
        // Prepare for driver install by choosing the driver
        //

        b = SetupDiCallClassInstaller (
                DIF_SELECTBESTCOMPATDRV,
                hDevInfo,
                DeviceInfoData
                );

        if (!b) {
            PNP_DBGPRINT (( "SETUP: SetupDiCallClassInstaller failed for answer file driver, error 0%Xh. \n", GetLastError() ));

            //
            // reset the struct
            //
            deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams (hDevInfo, DeviceInfoData, &deviceInstallParams)) {
                ZeroMemory (deviceInstallParams.DriverPath, sizeof (deviceInstallParams.DriverPath));
                deviceInstallParams.Flags &= ~DI_ENUMSINGLEINF;
                deviceInstallParams.FlagsEx &= ~DI_FLAGSEX_APPENDDRIVERLIST;

                if (SetupDiSetDeviceInstallParams (hDevInfo, DeviceInfoData, &deviceInstallParams)) {
                    if (!SetupDiDestroyDriverInfoList (hDevInfo, DeviceInfoData, SPDIT_COMPATDRIVER)) {
                        PNP_DBGPRINT (( "SETUP: SyssetupInstallAnswerFileDriver: SetupDiDestroyDriverInfoList() failed. Error = 0%Xh \n", GetLastError() ));
                    }
                } else {
                    PNP_DBGPRINT (( "SETUP: SyssetupInstallAnswerFileDriver: SetupDiSetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
                }
            } else {
                PNP_DBGPRINT (( "SETUP: SyssetupInstallAnswerFileDriver: SetupDiGetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
            }
        } else {

            //
            // Identify which driver of ours, if any, was chosen
            //

            *AfDriver = pGetSelectedSourceDriver (Drivers, hDevInfo, DeviceInfoData);

            if (*AfDriver == NULL) {
                PNP_DBGPRINT (( "SETUP: WARNING: Answer File Driver was not chosen for its device. \n" ));
            }
        }

    }
    __finally {

        pSetupStringTableDestroy (PnpIdTable);
        ReusableFree (&Buf);

    }

    return b;

}


BOOL
pAddAfDriver (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData,
    IN      BOOL First
    )

/*++

Routine Description:

  pAddAfDriver adds the INF specified in the answer file to the list of INFs.
  This causes the PNP setup code to include it when finding the best device
  driver.

Arguments:

  Driver         - Specifies the attributes of the answer file-supplied driver

  hDevInfo       - Specifies the current device

  DeviceInfoData - Specifies current device info

  First          - TRUE if this is the first answer file-supplied INF for the
                   device, otherwise FALSE

Return Value:

  TRUE if the INF was added to the device install parameters, FALSE otherwise

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    HKEY Key;

    //
    // Fill in DeviceInstallParams struct
    //

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (!SetupDiGetDeviceInstallParams (hDevInfo, DeviceInfoData, &DeviceInstallParams)) {
        PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiGetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
        return FALSE;
    }

    //
    // Modify the struct
    //

    MYASSERT (!DeviceInstallParams.DriverPath[0]);
    lstrcpynW (DeviceInstallParams.DriverPath, Driver->InfPath, MAX_PATH);
    DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_APPENDDRIVERLIST;

    //
    // Tell setup api where to find the driver
    //

    if (!SetupDiSetDeviceInstallParams (hDevInfo, DeviceInfoData, &DeviceInstallParams)) {
        PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiSetDeviceInstallParams() failed. Error = 0%Xh \n", GetLastError() ));
        return FALSE;
    }

    if( !SetupDiBuildDriverInfoList( hDevInfo, DeviceInfoData, SPDIT_COMPATDRIVER ) ) {
        PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiBuildDriverInfoList() failed. Error = 0%Xh \n", GetLastError() ));
        return FALSE;
    }

    //
    // Install ClassInstall32 if necessary
    //

    if (Driver->ClassInstall32Section) {
        //
        // Is class already installed?
        //

        Key = SetupDiOpenClassRegKey (&Driver->Guid, KEY_READ);
        if (Key == (HKEY) INVALID_HANDLE_VALUE || !Key) {
            //
            // No, install class.
            //

            if (!SetupDiInstallClass (NULL, Driver->InfPath, DI_FORCECOPY, NULL)) {
                PNP_DBGPRINT (( "SETUP: pAddAfDriver: SetupDiInstallClass() failed. Error = 0%Xh \n", GetLastError() ));
            }
        } else {
            RegCloseKey (Key);
        }
    }

    return TRUE;
}


PAF_DRIVER_ATTRIBS
pGetSelectedSourceDriver (
    IN      PAF_DRIVERS Drivers,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

  pGetSelectedSourceDriver finds which answer file driver was selected, if
  any.

Arguments:

  Drivers        - Specifies the answer file driver table, as created by
                   CreateAfDriverTable

  hDevInfo       - Specifies the current device.  The driver for this
                   device must be selected, but not yet installed.

  DeviceInfoData - Specifies the device data

Return Value:

  A pointer to the answer file driver attributes, or NULL if no answer file
  driver was selected for the device.

--*/

{
    SP_DRVINFO_DATA DriverData;
    PAF_DRIVER_ATTRIBS OurDriver = NULL;
    PSP_DRVINFO_DETAIL_DATA DetailData;
    BUFFER Buf = BUFFER_INIT;
    AF_DRIVER_ENUM e;

    __try {
        //
        // After the PNP subsystem installs a driver for the device, we get the
        // actual installed device INF path, and see if it was one of our
        // answer file-supplied drivers.
        //

        DriverData.cbSize = sizeof(SP_DRVINFO_DATA);

        if (!SetupDiGetSelectedDriver (hDevInfo, DeviceInfoData, &DriverData)) {
            PNP_DBGPRINT (( "SETUP: SetupDiGetSelectedDriver failed for answer file driver, error 0%Xh. \n", GetLastError() ));
        } else {
            DetailData = pMyGetDriverInfoDetail (hDevInfo, DeviceInfoData, &DriverData, &Buf);

            if (DetailData) {

                //
                // Check our driver list
                //

                if (EnumFirstAfDriver (&e, Drivers)) {
                    do {

                        if (!lstrcmpi (e.Driver->InfPath, DetailData->InfFileName)) {
                            //
                            // Match found
                            //

                            OurDriver = e.Driver;
                            break;
                        }
                    } while (EnumNextAfDriver (&e));
                }

            } else {
                PNP_DBGPRINT (( "SETUP: No driver details available, error 0%Xh. \n", GetLastError() ));
            }
        }

    }
    __finally {
        ReusableFree (&Buf);
    }

    return OurDriver;
}


BOOL
SyssetupFixAnswerFileDriverPath (
    IN      PAF_DRIVER_ATTRIBS Driver,
    IN      HDEVINFO hDevInfo,
    IN      PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

  SyssetupFixAnswerFileDriverPath calls SetupCopyOEMFile to copy the device
  INF over itself.  The source is the same as the destination, which causes
  the PNF to be rebuilt, and doesn't cause any copy
  activity.


Arguments:

  Driver         - Specifies the attributes of the answer file-supplied driver
  hDevInfo       - Specifies the device.  The driver for this device must
                   already be installed.
  DeviceInfoData - Specifies the device info

Return Value:

  TRUE if the PNF was updated, FALSE otherwise.

--*/

{
    HKEY Key = NULL;
    LONG rc;
    DWORD Type;
    DWORD DataSize;
    WCHAR Data[MAX_PATH - 48];
    WCHAR WinDir[48];
    WCHAR FullNtInfPath[MAX_PATH];
    BOOL b = FALSE;


    __try {
        //
        // Now the driver in the temp dir has been installed.  We must
        // get the PNF to point to the original media.  We do this by
        // recopying the INF over itself.
        //

        Key = SetupDiOpenDevRegKey (
                    hDevInfo,
                    DeviceInfoData,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DRV,
                    KEY_READ
                    );

        if (!Key) {
            PNP_DBGPRINT (( "SETUP: Can't open key for device, error 0%Xh. \n", GetLastError() ));
            __leave;
        }

        DataSize = sizeof (Data);

        rc = RegQueryValueEx (
                Key,
                REGSTR_VAL_INFPATH,
                NULL,
                &Type,
                (PBYTE) Data,
                &DataSize
                );

        if (rc != ERROR_SUCCESS) {
            PNP_DBGPRINT (( "SETUP: Can't query value for device, error 0%Xh. \n", rc ));
            __leave;
        }

        if (!GetSystemWindowsDirectory (WinDir, sizeof (WinDir) / sizeof (WinDir[0]))) {
            MYASSERT (FALSE);
            PNP_DBGPRINT (( "SETUP: Can't get %%windir%%, error 0%Xh. \n", GetLastError() ));
            __leave;
        }

        wsprintfW (FullNtInfPath, L"%s\\INF\\%s", WinDir, Data);

        MYASSERT (GetFileAttributes (FullNtInfPath) != 0xFFFFFFFF);

        //
        // We now have the installed INF path.  Recopy the INF so we can
        // change the original media path.
        //

        b = SetupCopyOEMInf (
                FullNtInfPath,
                Driver->OriginalInstallMedia,
                SPOST_PATH,
                SP_COPY_SOURCE_ABSOLUTE|SP_COPY_NOSKIP|SP_COPY_NOBROWSE,
                NULL,
                0,
                NULL,
                NULL
                );

        if (!b) {
            PNP_DBGPRINT (( "SETUP: pFixSourceInfPath: SetupCopyOEMInf() failed. Error = 0%Xh \n", GetLastError() ));
            b = TRUE;
        }

    }
    __finally {
        if (Key) {
            RegCloseKey (Key);
        }
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\arc.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    arc.c

Abstract:

    Routines relating to boot.ini.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


PWSTR
ArcDevicePathToNtPath(
    IN PCWSTR ArcPath
    )

/*++

Routine Description:

    Convert an ARC path (device only) to an NT path.

Arguments:

    ArcPath - supplies path to be converted.

Return Value:

    Converted path. Caller must free with MyFree().

--*/

{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    PWSTR arcPath;
    PWSTR ntPath;

    //
    // Assume failure
    //
    ntPath = NULL;

    arcPath = MyMalloc(((lstrlen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(L"\\ArcName"));
    if( !arcPath ) {
        return NULL;
    }

    lstrcpy(arcPath,L"\\ArcName\\");
    lstrcat(arcPath,ArcPath);

    RtlInitUnicodeString(&UnicodeString,arcPath);
    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {

        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject(ObjectHandle,&UnicodeString,NULL);
        if(NT_SUCCESS(Status)) {

            ntPath = MyMalloc(UnicodeString.Length+sizeof(WCHAR));
            if( ntPath ) {
                CopyMemory(ntPath,UnicodeString.Buffer,UnicodeString.Length);

                ntPath[UnicodeString.Length/sizeof(WCHAR)] = 0;
            }
        }

        NtClose(ObjectHandle);
    }

    MyFree(arcPath);

    return(ntPath);
}


PWSTR
NtFullPathToDosPath(
    IN PCWSTR NtPath
    )
{
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    HANDLE DosDevicesDir;
    HANDLE DosDevicesObj;
    PWSTR dosPath;
    PWSTR currentDosPath;
    ULONG Context;
    ULONG Length;
    BOOLEAN RestartScan;
    CHAR Buffer[1024];
    WCHAR LinkSource[2*MAX_PATH];
    WCHAR LinkTarget[2*MAX_PATH];
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    UINT PrefixLength;
    UINT NtPathLength;
    WCHAR canonNtPath[MAX_PATH];
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    PWSTR ntPath;

    //
    // Canonicalize the NT path by following the symbolic link.
    //

    ntPath = (PWSTR) NtPath;
    dosPath = NULL;

    RtlInitUnicodeString(&UnicodeString,ntPath);
    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    NtPathLength = UnicodeString.Length/sizeof(WCHAR);
    PrefixLength = UnicodeString.Length/sizeof(WCHAR);

    for (;;) {

        Status = NtOpenSymbolicLinkObject(
                    &ObjectHandle,
                    READ_CONTROL | SYMBOLIC_LINK_QUERY,
                    &Obja
                    );

        if (NT_SUCCESS(Status)) {

            UnicodeString.Buffer = canonNtPath;
            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = sizeof(WCHAR)*MAX_PATH;

            RtlZeroMemory(canonNtPath, UnicodeString.MaximumLength);

            Status = NtQuerySymbolicLinkObject(ObjectHandle,&UnicodeString,NULL);
            if(NT_SUCCESS(Status)) {
                if (NtPathLength > PrefixLength) {
                    RtlCopyMemory((PCHAR) canonNtPath + UnicodeString.Length,
                                  ntPath + PrefixLength,
                                  (NtPathLength - PrefixLength)*sizeof(WCHAR));
                }
                ntPath = canonNtPath;
            }

            NtClose(ObjectHandle);
            break;
        }

        RtlInitUnicodeString(&UnicodeString,ntPath);

        PrefixLength--;
        while (PrefixLength > 0) {
            if (ntPath[PrefixLength] == '\\') {
                break;
            }
            PrefixLength--;
        }

        if (!PrefixLength) {
            break;
        }

        UnicodeString.Length = (USHORT)(PrefixLength*sizeof(WCHAR));

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
    }

    NtPathLength = lstrlen(ntPath);

    //
    // Open \DosDevices directory.
    //
    RtlInitUnicodeString(&UnicodeString,L"\\DosDevices");
    InitializeObjectAttributes(&Attributes,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);

    Status = NtOpenDirectoryObject(&DosDevicesDir,DIRECTORY_QUERY,&Attributes);
    if(!NT_SUCCESS(Status)) {
        return(NULL);
    }

    //
    // Iterate each object in that directory.
    //
    Context = 0;
    RestartScan = TRUE;

    Status = NtQueryDirectoryObject(
                DosDevicesDir,
                Buffer,
                sizeof(Buffer),
                TRUE,
                RestartScan,
                &Context,
                &Length
                );

    RestartScan = FALSE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

    while(NT_SUCCESS(Status)) {

        DirInfo->Name.Buffer[DirInfo->Name.Length/sizeof(WCHAR)] = 0;
        DirInfo->TypeName.Buffer[DirInfo->TypeName.Length/sizeof(WCHAR)] = 0;

        //
        // Skip this entry if it's not a symbolic link.
        //
        if(DirInfo->Name.Length && !lstrcmpi(DirInfo->TypeName.Buffer,L"SymbolicLink")) {

            //
            // Get this \DosDevices object's link target.
            //
            UnicodeString.Buffer = LinkSource;
            UnicodeString.Length = sizeof(L"\\DosDevices\\") - sizeof(WCHAR);
            UnicodeString.MaximumLength = sizeof(LinkSource);
            lstrcpy(LinkSource,L"\\DosDevices\\");
            RtlAppendUnicodeStringToString(&UnicodeString,&DirInfo->Name);

            InitializeObjectAttributes(&Attributes,&UnicodeString,OBJ_CASE_INSENSITIVE,NULL,NULL);
            Status = NtOpenSymbolicLinkObject(
                        &DosDevicesObj,
                        READ_CONTROL|SYMBOLIC_LINK_QUERY,
                        &Attributes
                        );

            if(NT_SUCCESS(Status)) {

                UnicodeString.Buffer = LinkTarget;
                UnicodeString.Length = 0;
                UnicodeString.MaximumLength = sizeof(LinkTarget);
                Status = NtQuerySymbolicLinkObject(DosDevicesObj,&UnicodeString,NULL);
                CloseHandle(DosDevicesObj);
                if(NT_SUCCESS(Status)) {
                    //
                    // Make sure LinkTarget is nul-terminated.
                    //
                    PrefixLength = UnicodeString.Length/sizeof(WCHAR);
                    UnicodeString.Buffer[PrefixLength] = 0;

                    //
                    // See if it's a prefix of the path we're converting,
                    //
                    if(!_wcsnicmp(ntPath,LinkTarget,PrefixLength)) {
                        //
                        // Got a match.
                        //
                        currentDosPath = dosPath;
                        if(dosPath = MyMalloc(DirInfo->Name.Length + ((NtPathLength - PrefixLength + 1)*sizeof(WCHAR)))) {
                            lstrcpy(dosPath,DirInfo->Name.Buffer);
                            lstrcat(dosPath,ntPath + PrefixLength);
                        }
                        if (currentDosPath) {
                            if (lstrlen(currentDosPath) < lstrlen(dosPath)) {
                                MyFree(dosPath);
                                dosPath = currentDosPath;
                            } else {
                                MyFree(currentDosPath);
                            }
                        }
                    }
                }
            }
        }

        //
        // Go on to next object.
        //
        Status = NtQueryDirectoryObject(
                    DosDevicesDir,
                    Buffer,
                    sizeof(Buffer),
                    TRUE,
                    RestartScan,
                    &Context,
                    &Length
                    );
    }

    CloseHandle(DosDevicesDir);
    return dosPath;
}


BOOL
SetNvRamVariable(
    IN PCWSTR VarName,
    IN PCWSTR VarValue
    )
{
    UNICODE_STRING VarNameU,VarValueU;
    NTSTATUS Status;

    //
    // Set up unicode strings.
    //
    RtlInitUnicodeString(&VarNameU ,VarName );
    RtlInitUnicodeString(&VarValueU,VarValue);

    pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE);
    Status = NtSetSystemEnvironmentValue(&VarNameU,&VarValueU);
    return(NT_SUCCESS(Status));
}


BOOL
ChangeBootTimeoutNvram(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in nv-ram.
    The non-ARC version (which operates on boot.ini) is in i386\bootini.c.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{
    WCHAR TimeoutValue[24];

    wsprintf(TimeoutValue,L"%u",Timeout);

    if(!SetNvRamVariable(L"COUNTDOWN",TimeoutValue)) {
        return(FALSE);
    }

    return(SetNvRamVariable(L"AUTOLOAD",L"YES"));
}

#if defined(EFI_NVRAM_ENABLED)

BOOL
ChangeBootTimeoutEfiNvram(
    IN UINT Timeout
    )

/*++

Routine Description:

    Changes the boot countdown value in EFI nv-ram.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    BOOT_OPTIONS BootOptions;

    ASSERT(IsEfi());

    BootOptions.Version = BOOT_OPTIONS_VERSION;
    BootOptions.Length = sizeof(BootOptions);
    BootOptions.Timeout = Timeout;

    pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE);
    Status = NtSetBootOptions(&BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
    return(NT_SUCCESS(Status));
}

#endif // defined(EFI_NVRAM_ENABLED)

#if defined(_X86_)
BOOL
IsArc(
    VOID
    )

/*++

Routine Description:

    Run time check to determine if this is an Arc system. We attempt to read an
    Arc variable using the Hal. This will fail for Bios based systems.

Arguments:

    None

Return Value:

    True = This is an Arc system.

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    WCHAR Buffer[4096];

    if(!pSetupEnablePrivilege(SE_SYSTEM_ENVIRONMENT_NAME,TRUE))
        return(FALSE); // need better error handling?

    //
    // Get the env var into the temp buffer.
    //
    RtlInitUnicodeString(&UnicodeString, L"OSLOADER");

    Status = NtQuerySystemEnvironmentValue(
                        &UnicodeString,
                        Buffer,
                        sizeof(Buffer)/sizeof(WCHAR),
                        NULL
                        );


    return(NT_SUCCESS(Status) ? TRUE: FALSE);
}
#endif


BOOL
ChangeBootTimeout(
    IN UINT Timeout
    )
/*++

Routine Description:

    Changes the boot countdown value; decides whether
    to use ARC or non-ARC version.

Arguments:

    Timeout - supplies new timeout value, in seconds.

Return Value:

    None.

--*/

{

#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {
        return ChangeBootTimeoutEfiNvram(Timeout);
    }

#endif


    if (IsArc()) {
        return ChangeBootTimeoutNvram(Timeout);

    }

#if defined(_AMD64_) || defined(_X86_)

    return ChangeBootTimeoutBootIni(Timeout);

#else

    return FALSE;

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\asrbkup.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asrbkup.c

Abstract:

    This module contains the following ASR routines:
        AsrCreateStateFile{A|W}
        AsrAddSifEntry{A|W}
        AsrFreeContext


Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Environment:

    User-mode only.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Revision History:
    
    27-May-2000 guhans  
        Moved ASR-backup related routines from asr.c to 
        asrbkup.c

    01-Jan-2000 guhans
        Initial implementation for Asr routines in asr.c

--*/
#include "setupp.h"
#pragma hdrstop

#include <initguid.h>   // DiskClassGuid
#include <diskguid.h>   // GPT partition type guids
#include <ntddvol.h>    // ioctl_volume_query_failover_set
#include <setupapi.h>   // SetupDi routines
#include <mountmgr.h>   // mountmgr ioctls
#include <rpcdce.h>     // UuidToStringW, RpcStringFreeW
#include <winasr.h>     // ASR public routines

#define THIS_MODULE 'B'
#include <accctrl.h>    // EXPLICIT_ACCESS, ACL related stuff
#include <aclapi.h>     // SetEntriesInAcl

#include "asrpriv.h"    // Private ASR definitions and routines


//
// --------
// constants local to this module. These are not accessed outside this file.
// --------
//

//
// The Setup Key to find the system partition from
//
const WCHAR ASR_REGKEY_SETUP[]              = L"SYSTEM\\SETUP";
const WCHAR ASR_REGVALUE_SYSTEM_PARTITION[] = L"SystemPartition";

//
// The ASR registry entries.  Currently, this is used to look 
// up the commands to run during an Asr backup, but we could
// have other settings here later.
//
const WCHAR ASR_REGKEY_ASR_COMMANDS[]   
    = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands";

const WCHAR ASR_REGKEY_ASR[]            
    = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\";

const WCHAR ASR_REGVALUE_TIMEOUT[]          = L"ProcessTimeOut";

//
// File to save the PnP information in.
//
const WCHAR ASR_DEFAULT_SIF_PATH[]          = L"\\\\?\\%systemroot%\\repair\\asr.sif";
const WCHAR ASRPNP_DEFAULT_SIF_NAME[]       = L"asrpnp.sif";

//
// We only support x86, AMD64, and IA64 architectures.
//
const WCHAR ASR_PLATFORM_X86[]              = L"x86";
const WCHAR ASR_PLATFORM_AMD64[]            = L"AMD64";
const WCHAR ASR_PLATFORM_IA64[]             = L"IA64";

//
// This is the suffix that we add when launching the apps registered for ASR.
// Remember to change the length if you're changing this.  The length should
// include space for 20 digits (max 64-bit int) + null + space at the beginning.
//
#define ASR_COMMANDLINE_SUFFIX_LEN  35
const WCHAR ASR_COMMANDLINE_SUFFIX[]        = L" /context=%I64u";

//
// Miscellaneous constants
//
const WCHAR ASR_DOS_DEVICES_PREFIX[]        = L"\\DosDevices\\";
const WCHAR ASR_DEVICE_PATH_PREFIX[]        = L"\\Device\\Harddisk";
const WCHAR ASR_PARTITION_1[]               = L"\\\\\?\\GLOBALROOT\\Device\\Harddisk%u\\Partition1";
const WCHAR ASR_WSZ_VOLUME_PREFIX[]         = L"\\??\\Volume";

const WCHAR ASR_WSZ_DEVICE_PATH_FORMAT[]    = L"\\Device\\Harddisk%d\\Partition%d";


//
// Sections in asr.sif
//
const WCHAR ASR_SIF_VERSION_SECTION_NAME[]          = L"[VERSION]";
const WCHAR ASR_SIF_SYSTEM_SECTION_NAME[]           = L"[SYSTEMS]";
const WCHAR ASR_SIF_BUSES_SECTION_NAME[]            = L"[BUSES]";
const WCHAR ASR_SIF_MBR_DISKS_SECTION_NAME[]        = L"[DISKS.MBR]";
const WCHAR ASR_SIF_GPT_DISKS_SECTION_NAME[]        = L"[DISKS.GPT]";
const WCHAR ASR_SIF_MBR_PARTITIONS_SECTION_NAME[]   = L"[PARTITIONS.MBR]";
const WCHAR ASR_SIF_GPT_PARTITIONS_SECTION_NAME[]   = L"[PARTITIONS.GPT]";


const WCHAR ASR_SIF_PROVIDER_PREFIX[]       = L"Provider=";

// wcslen("Provider=""\r\n\0")
#define ASR_SIF_CCH_PROVIDER_STRING 14


//
// While launching registered applications during an ASR backup, we
// add two environment variables to the environment block for the 
// process being launched:  the AsrContext and the critical volume
// list.
//
#define ASR_CCH_ENVBLOCK_ASR_ENTRIES (32 + 1 + 28 + 2)
const WCHAR ASR_ENVBLOCK_CONTEXT_ENTRY[]    = L"_AsrContext=%I64u";

const WCHAR ASR_ENVBLOCK_CRITICAL_VOLUME_ENTRY[] 
    = L"_AsrCriticalVolumeList=";

//
// Pre-defined flags designating the boot and system partitions
// in the partitions section of asr.sif.  Remember to change the
// counter-parts in setupdd.sys if you change these!
//
const BYTE  ASR_FLAGS_BOOT_PTN              = 1;
const BYTE  ASR_FLAGS_SYSTEM_PTN            = 2;

//
// For now, we only allow one system per sif file.  If a sif
// already exists at the location AsrCreateStateFile is called,
// the existing sif is deleted.  The asr.sif architecture does
// allow for multiple systems per sif file, but
// - I don't see any compelling reason to support this, and
// - It would be a test nightmare
//
const BYTE  ASR_SYSTEM_KEY                  = 1;

//
// _AsrpCheckTrue: primarily used with WriteFile calls.
//
#define _AsrpCheckTrue( Expression )    \
    if (!Expression) {                  \
        return FALSE;                   \
    }                               

//
// --------
// constants used across asr modules.
// --------
//
const WCHAR ASR_SIF_SYSTEM_SECTION[]            = L"SYSTEMS";
const WCHAR ASR_SIF_BUSES_SECTION[]             = L"BUSES";
const WCHAR ASR_SIF_MBR_DISKS_SECTION[]         = L"DISKS.MBR";
const WCHAR ASR_SIF_GPT_DISKS_SECTION[]         = L"DISKS.GPT";
const WCHAR ASR_SIF_MBR_PARTITIONS_SECTION[]    = L"PARTITIONS.MBR";
const WCHAR ASR_SIF_GPT_PARTITIONS_SECTION[]    = L"PARTITIONS.GPT";


//
// --------
// function prototypes
// --------
//

//
// Function prototype for AsrCreatePnpStateFileW.
// (linked into syssetup.dll from pnpsif.lib)
//
BOOL
AsrCreatePnpStateFileW(
    IN  PCWSTR    lpFilePath
    );


//
// --------
// private functions
// --------
//
BOOL
AsrpConstructSecurityAttributes(
    PSECURITY_ATTRIBUTES  psaSecurityAttributes,
    SecurityAttributeType eSaType,
    BOOL                  bIncludeBackupOperator
    )
{
    DWORD           dwStatus;
    DWORD           dwAccessMask         = 0;
    BOOL            bResult = TRUE;
    PSID            psidBackupOperators  = NULL;
    PSID            psidAdministrators   = NULL;
    PSID            psidLocalSystem      = NULL;
    PACL            paclDiscretionaryAcl = NULL;
    SID_IDENTIFIER_AUTHORITY    sidNtAuthority       = SECURITY_NT_AUTHORITY;
    EXPLICIT_ACCESS     eaExplicitAccess [3];

    switch (eSaType) {

    case esatMutex: 
        dwAccessMask = MUTEX_ALL_ACCESS; 
        break;
        
    case esatSemaphore:
        dwAccessMask = SEMAPHORE_ALL_ACCESS;
        break;

    case esatEvent:
        dwAccessMask = EVENT_ALL_ACCESS;
        break;
        
    case esatFile:  
        dwAccessMask = FILE_ALL_ACCESS;  
        break;

    default:
        bResult = FALSE;
        break;
    }


    /*
    ** Initialise the security descriptor.
    */
    if (bResult) {
        bResult = InitializeSecurityDescriptor(psaSecurityAttributes->lpSecurityDescriptor,
            SECURITY_DESCRIPTOR_REVISION
            );
    }

    if (bResult && bIncludeBackupOperator) {
        /*
        ** Create a SID for the Backup Operators group.
        */
        bResult = AllocateAndInitializeSid(&sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_BACKUP_OPS,
            0, 0, 0, 0, 0, 0,
            &psidBackupOperators
            );
    }

    if (bResult) {
        /*
        ** Create a SID for the Administrators group.
        */
        bResult = AllocateAndInitializeSid(&sidNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            );

    }

    if (bResult) {
        /*
        ** Create a SID for the Local System.
        */
        bResult = AllocateAndInitializeSid(&sidNtAuthority, 
            1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &psidLocalSystem
            );
    }

    if (bResult) {
        /*
        ** Initialize the array of EXPLICIT_ACCESS structures for an
        ** ACEs we are setting.
        **
            ** The first ACE allows the Backup Operators group full access
            ** and the second, allowa the Administrators group full
            ** access.
        */

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        eaExplicitAccess[0].grfAccessPermissions = FILE_ALL_ACCESS;
        eaExplicitAccess[0].grfAccessMode = SET_ACCESS;
        eaExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[0].Trustee.pMultipleTrustee = NULL;
        eaExplicitAccess[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        eaExplicitAccess[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        eaExplicitAccess[0].Trustee.ptstrName  = (LPTSTR) psidLocalSystem;

        eaExplicitAccess[1].grfAccessPermissions             = dwAccessMask;
        eaExplicitAccess[1].grfAccessMode                    = SET_ACCESS;
        eaExplicitAccess[1].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        eaExplicitAccess[1].Trustee.pMultipleTrustee         = NULL;
        eaExplicitAccess[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
        eaExplicitAccess[1].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
        eaExplicitAccess[1].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
        eaExplicitAccess[1].Trustee.ptstrName                = (LPTSTR) psidAdministrators;


        if (bIncludeBackupOperator) {
            eaExplicitAccess[2].grfAccessPermissions             = dwAccessMask;
            eaExplicitAccess[2].grfAccessMode                    = SET_ACCESS;
            eaExplicitAccess[2].grfInheritance                   = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
            eaExplicitAccess[2].Trustee.pMultipleTrustee         = NULL;
            eaExplicitAccess[2].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            eaExplicitAccess[2].Trustee.TrusteeForm              = TRUSTEE_IS_SID;
            eaExplicitAccess[2].Trustee.TrusteeType              = TRUSTEE_IS_WELL_KNOWN_GROUP;
            eaExplicitAccess[2].Trustee.ptstrName                = (LPTSTR) psidBackupOperators;
        }


        /*
        ** Create a new ACL that contains the new ACEs.
        */
        dwStatus = SetEntriesInAcl(bIncludeBackupOperator ? 3 : 2,
                    eaExplicitAccess,
                    NULL,
                    &paclDiscretionaryAcl);
        
        if (ERROR_SUCCESS != dwStatus) {
            bResult = FALSE;
        }
    }

    if (bResult) {
        /*
        ** Add the ACL to the security descriptor.
        */
        bResult = SetSecurityDescriptorDacl(psaSecurityAttributes->lpSecurityDescriptor,
            TRUE,
            paclDiscretionaryAcl,
            FALSE
            );
    }

    if (bResult) {
        paclDiscretionaryAcl = NULL;
    }

    /*
    ** Clean up any left over junk.
    */
    if (NULL != psidLocalSystem) {
        FreeSid (psidLocalSystem);
        psidLocalSystem = NULL;
    }

    if (NULL != psidAdministrators) {
        FreeSid (psidAdministrators);
        psidAdministrators = NULL;
    }

    if (NULL != psidBackupOperators) {
        FreeSid (psidBackupOperators);
        psidBackupOperators = NULL;
    }
    
    if (NULL != paclDiscretionaryAcl) {
        LocalFree (paclDiscretionaryAcl);
        paclDiscretionaryAcl = NULL;
    }

    return bResult;
} /* ConstructSecurityAttributes () */


VOID 
AsrpCleanupSecurityAttributes(
    PSECURITY_ATTRIBUTES psaSecurityAttributes
    )
{
    BOOL    bSucceeded;
    BOOL    bDaclPresent         = FALSE;
    BOOL    bDaclDefaulted       = TRUE;
    PACL    paclDiscretionaryAcl = NULL;

    bSucceeded = GetSecurityDescriptorDacl (psaSecurityAttributes->lpSecurityDescriptor,
                        &bDaclPresent,
                        &paclDiscretionaryAcl,
                        &bDaclDefaulted);


    if (bSucceeded && bDaclPresent && !bDaclDefaulted && (NULL != paclDiscretionaryAcl)) {
        LocalFree (paclDiscretionaryAcl);
    }

} /* CleanupSecurityAttributes () */


BOOL
AsrpIsInaccessibleSanDisk(
    IN CONST ULONG DeviceNumber
    )
/*++

Routine Description:
    
    Utility to check if the current disk is a shared SAN disk that's "owned"
    by a different machine (and is hence inaccessible).
    
Arguments:

    DeviceNumber - NT Device number to the disk of interest.

Return Value:

    If the function succeeds and the disk is a shared SAN disk that is 
            owned by some other machine, the return value is a nonzero value.

    If the function fails, or if the disk is not a shared SAN disk that
            is owned by a different machine (ie, is a local unshared disk, or
            a shared disk owned by this machine) the return value 
            is zero. 

--*/
{
    DWORD dwStatus = ERROR_SUCCESS,
        dwDummy = 0;
    HANDLE hPartition = INVALID_HANDLE_VALUE;
    HANDLE heapHandle = GetProcessHeap();
    BOOL bIsInaccessibleDevice = FALSE;
    PWSTR lpPartitionPath = NULL;
    DWORD cchPartitionPath = 0;

    cchPartitionPath = MAX_PATH+1; //wcslen(lpDevicePath);

    lpPartitionPath = (LPWSTR) HeapAlloc(
        heapHandle, 
        HEAP_ZERO_MEMORY,
        (cchPartitionPath + wcslen(ASR_PARTITION_1) + 1) * sizeof(WCHAR)
        );
    _AsrpErrExitCode(!lpPartitionPath, dwStatus, GetLastError())

    wsprintf(lpPartitionPath, ASR_PARTITION_1, DeviceNumber);

    //
    // Get a handle to the first partition on disk
    //
    hPartition = CreateFileW(
        lpPartitionPath,                    // lpFileName
        0,                                  // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
        NULL,                               // lpSecurityAttributes
        OPEN_EXISTING,                      // dwCreationFlags
        FILE_ATTRIBUTE_NORMAL,              // dwFlagsAndAttributes
        NULL                                // hTemplateFile
        );

    if ((!hPartition) || (INVALID_HANDLE_VALUE == hPartition)) {
        //
        // We couldn't open the partition.  Now check for the specific error
        // code we're interested in (STATUS_OFF_LINE, which gets mapped to
        // ERROR_NOT_READY).
        //
        dwStatus = GetLastError();

        if (ERROR_NOT_READY == dwStatus) {
            bIsInaccessibleDevice = TRUE;
        }
    }
    else {

        //
        // Dynamic disks don't support this IOCTL, and will return a failure.  
        // Basic disks that are online will return FALSE as well.  
        //
        bIsInaccessibleDevice = DeviceIoControl(
            hPartition,
            IOCTL_VOLUME_IS_OFFLINE,
            NULL,
            0,
            NULL,
            0,
            &dwDummy,
            NULL
            );
    }


EXIT:

    _AsrpCloseHandle(hPartition);
    _AsrpHeapFree(lpPartitionPath);

    return bIsInaccessibleDevice;
}


BOOL
AsrpGetMountPoints(
    IN  PCWSTR DeviceName,
    IN  CONST DWORD  SizeDeviceName,
    OUT PMOUNTMGR_MOUNT_POINTS  *pMountPointsOut
    )

/*++

Routine Description:

    Returns the current list of mount-points for DeviceName, by querying the 
    mount manager.

Arguments:

    DeviceName - The device name that the mount-point list is requested for.  
            Typically, this is something of the form 
            \Device\HarddiskX\PartitionY or \DosDevices\X:

    SizeDeviceName - The size, in bytes, of DeviceName.  This includes the
            terminating null character.

    pMountPointsOut - Receives the output list of mount-points.  The caller 
            must free this memory by calling HeapFree for the current process 
            heap.

Return Values:
   
    TRUE, if everything went well.  MountPointsOut contains the promised data.

    FALSE, if the mount manager returned an error.  MountPoints is NULL.  Call
            GetLastError() for more information.

--*/

{
    PMOUNTMGR_MOUNT_POINT   mountPointIn    = NULL;
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;
    MOUNTMGR_MOUNT_POINTS   mountPointsTemp;
    DWORD   mountPointsSize                 = 0;

    HANDLE  mpHandle                        = NULL;
    HANDLE  heapHandle                      = NULL;

    ULONG   index                           = 0;
    LONG    status                          = ERROR_SUCCESS;
    BOOL    result                          = FALSE;

    memset(&mountPointsTemp, 0L, sizeof(MOUNTMGR_MOUNT_POINTS));

    MYASSERT(pMountPointsOut);
    *pMountPointsOut = NULL;

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    mountPointIn = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (MOUNTMGR_MOUNT_POINT) + (SizeDeviceName - sizeof(WCHAR))
        );
    _AsrpErrExitCode((!mountPointIn), status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Try with a decently sized mountPoints out: if it isn't big
    // enough, we'll realloc as needed
    //
    mountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (MAX_PATH + 1) * (sizeof(WCHAR))
        );
    _AsrpErrExitCode(!mountPointsOut, status, ERROR_NOT_ENOUGH_MEMORY);

    // 
    // Get a handle to the mount manager
    //
    mpHandle = CreateFileW(
        MOUNTMGR_DOS_DEVICE_NAME,      // lpFileName
        0,                           // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,     // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_EXISTING,              // dwCreationFlags
        FILE_ATTRIBUTE_NORMAL,      // dwFlagsAndAttributes
        NULL                        // hTemplateFile
        );
    _AsrpErrExitCode((!mpHandle || INVALID_HANDLE_VALUE == mpHandle), 
        status, 
        GetLastError()
        );

    // 
    // put the DeviceName right after struct mountPointIn
    //
    wcsncpy((PWSTR) (mountPointIn + 1), 
        DeviceName, 
        (SizeDeviceName / sizeof(WCHAR)) - 1
        );
    mountPointIn->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    mountPointIn->DeviceNameLength = (USHORT)(SizeDeviceName - sizeof(WCHAR));

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_QUERY_POINTS,
        mountPointIn,
        sizeof(MOUNTMGR_MOUNT_POINT) + mountPointIn->DeviceNameLength,
        &mountPointsTemp,
        sizeof(MOUNTMGR_MOUNT_POINTS),
        &mountPointsSize,
        NULL
        );

    while (!result) {

        status = GetLastError();
        
        if (ERROR_MORE_DATA == status) {
            //
            // The buffer is not big enough, re-size and try again
            //
            status = ERROR_SUCCESS;
            _AsrpHeapFree(mountPointsOut);

            mountPointsOut = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                mountPointsTemp.Size
                );
            _AsrpErrExitCode((!mountPointsOut), 
                status, 
                ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                mpHandle,
                IOCTL_MOUNTMGR_QUERY_POINTS,
                mountPointIn,
                sizeof(MOUNTMGR_MOUNT_POINT) + mountPointIn->DeviceNameLength,
                mountPointsOut,
                mountPointsTemp.Size,
                &mountPointsSize,
                NULL
                );
            _AsrpErrExitCode((!mountPointsSize), status, GetLastError());

        }
        else {
            //
            // If some other error occurred, EXIT.
            //
            result = TRUE;
            status = GetLastError();
//            _AsrpErrExitCode(status, status, GetLastError());
        }
    }


EXIT:
    //
    // Free up locally allocated memory
    //
    _AsrpHeapFree(mountPointIn);

    if (ERROR_SUCCESS != status) {
        //
        // On failure, free up mountPointsOut as well
        //
        _AsrpHeapFree(mountPointsOut);
    }

    _AsrpCloseHandle(mpHandle);

    *pMountPointsOut = mountPointsOut;

    return (BOOL) (ERROR_SUCCESS == status);
}


BOOL
AsrpGetMorePartitionInfo(
    IN  PCWSTR                  DeviceName,
    IN  CONST DWORD             SizeDeviceName,
    IN  CONST PASR_SYSTEM_INFO  pSystemInfo         OPTIONAL,
    OUT PWSTR                   pVolumeGuid,
    OUT USHORT*                 pPartitionFlags     OPTIONAL,
    OUT UCHAR*                  pFileSystemType     OPTIONAL,
    OUT LPDWORD                 pClusterSize        OPTIONAL
    )

/*++

Routine Description:

    Gets additional information about the partition specified by DeviceName, 
    including the volume guid (if any) for the volume that maps to the 
    partition specified by DeviceName.

    If the partition is the current system or boot drive, pPartitionFlags and 
    pFileSystemType are set appropriately.

Arguments:

    DeviceName - A null terminated string containing the device path to the 
            partition, typically of the form \Device\HarddiskX\PartitionY

    SizeDeviceName - Size, in bytes, of DeviceName, including \0 at the end

    pSystemInfo - The SYSTEM_INFO structure for the current system; used for 
            finding out the current system partition.

            This is an optional parameter.  If absent, pPartitionFlags will 
            not have the SYSTEM_FLAG set, even if DeviceName is in fact the 
            system partition.

    pVolumeGuid - Receives a null-terminated string containing the GUID for 
            the volume on this partition.  This is only relevant for basic 
            disks, where volumes and partitions have a one-on-one 
            relationship.  

            This will be set to a blank null-terminated string if there is no 
            volume (or multiple volumes) on this partition.


    *** Note that if ANY of three of the OPTIONAL parameters are not present, 
    NONE of them will be filled with valid data.

    pPartitionFlags - If the current partition is a partition of interest,
            this receives the appropriate flags, IN ADDITION TO THE FLAGS
            ALREADY SET when the routine is called (i.e., caller should 
            usually zero this out). Currently, the two flags of interest are:
            ASR_FLAGS_BOOT_PTN      for the boot partition
            ASR_FLAGS_SYSTEM_PTN    for (you guessed it) the system partition

    pFileSystemType - If (and ONLY if) the current partition is a partition of 
            interest, this will contain a UCHAR to the file-system type of the 
            partition.  Currently, the three file-systems this recognises are:
            PARTITION_HUGE  (FAT)
            PARTITION_FAT32 (FAT32)
            PARTITION_IFS   (NTFS)

    pClusterSize - The file-system cluster size.  Set to 0 if the information
            could not be obtained.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;
    HANDLE  heapHandle                      = NULL;

    ULONG   index                           = 0;
    LONG    status                          = ERROR_SUCCESS;
    BOOL    result                          = FALSE;
    BOOL    volumeGuidSet                   = FALSE;

    //
    // set OUT variables to known values.
    //
    MYASSERT(pVolumeGuid);
    wcscpy(pVolumeGuid, L"");

/*    if (ARGUMENT_PRESENT(pPartitionFlags)) {
        *pPartitionFlags = 0;
    }
*/

    if (ARGUMENT_PRESENT(pClusterSize)) {
        *pClusterSize = 0;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    // Open the mount manager, and get a list of all the symbolic links
    // this partition
    //
    result = AsrpGetMountPoints(DeviceName, SizeDeviceName, &mountPointsOut);
    _AsrpErrExitCode((!result), status, GetLastError());
    _AsrpErrExitCode((!mountPointsOut), status, ERROR_SUCCESS);

    //
    // Check if this is the system partition, by comparing the
    // device path with the one stored in the Setup key.
    //
    if (ARGUMENT_PRESENT(pSystemInfo) && ARGUMENT_PRESENT(pPartitionFlags)) {
        
        PWSTR deviceName = (PWSTR) (
            ((LPBYTE) mountPointsOut) +
            mountPointsOut->MountPoints[index].DeviceNameOffset
            );

        UINT sizeDeviceName = 
            (UINT)(mountPointsOut->MountPoints[index].DeviceNameLength);

        if ((pSystemInfo->SystemPath) && 
            (wcslen(pSystemInfo->SystemPath)==sizeDeviceName/sizeof(WCHAR)) && 
            (!wcsncmp(pSystemInfo->SystemPath, deviceName, 
                sizeDeviceName/sizeof(WCHAR)))
            ) {
            *pPartitionFlags |= ASR_FLAGS_SYSTEM_PTN;
        }
    }

    for (index = 0; index < mountPointsOut->NumberOfMountPoints; index++) {

        //
        // Go through the list of mount points returned, and find the one 
        // that looks like an nt volume guid 
        //
        PWSTR linkName = (PWSTR) (((LPBYTE) mountPointsOut) +
            mountPointsOut->MountPoints[index].SymbolicLinkNameOffset
            );

        UINT sizeLinkName = 
            (UINT)(mountPointsOut->MountPoints[index].SymbolicLinkNameLength);

        if ((!volumeGuidSet) &&
            
            !wcsncmp(ASR_WSZ_VOLUME_PREFIX, 
                linkName, 
                wcslen(ASR_WSZ_VOLUME_PREFIX))
            
            ) {
            
            wcsncpy(pVolumeGuid, linkName, sizeLinkName / sizeof(WCHAR));
            volumeGuidSet = TRUE;   // we got a GUID, no need to check again

        }
        else if (
            ARGUMENT_PRESENT(pSystemInfo) && 
            ARGUMENT_PRESENT(pPartitionFlags)
            ) {

            //
            // Also, if this link isn't a GUID, it might be a drive letter.
            // use the boot directory's drive letter to check if this
            // is the boot volume, and mark it if so.
            //

            if (!wcsncmp(ASR_DOS_DEVICES_PREFIX, 
                    linkName, 
                    wcslen(ASR_DOS_DEVICES_PREFIX))
                ) {

                if ((pSystemInfo->BootDirectory) &&
                    (pSystemInfo->BootDirectory[0] 
                        == linkName[wcslen(ASR_DOS_DEVICES_PREFIX)])
                    ) {
                    
                    *pPartitionFlags |= ASR_FLAGS_BOOT_PTN;

                }
            }
        }
    }


EXIT:
    //
    // If this is a partition of interest, we need to get the file-system 
    // type as well
    //
    if (ARGUMENT_PRESENT(pFileSystemType) && 
        ARGUMENT_PRESENT(pPartitionFlags) && 
        ARGUMENT_PRESENT(pClusterSize)
        ) {

        if (*pPartitionFlags) {
            WCHAR fsName[20];
            DWORD dwSectorsPerCluster = 0,
                dwBytesPerSector = 0,
                dwNumFreeClusters = 0,
                dwTotalNumClusters = 0;
            
            // 
            // Convert the NT Volume-GUID (starts with \??\) to a DOS 
            // Volume (begins with a \\?\, and ends with a back-slash),
            // since GetVolumeInformation needs it in this format.
            //
            pVolumeGuid[1] = L'\\'; 
            wcscat(pVolumeGuid, L"\\");

            memset(fsName, 0L, 20*sizeof(WCHAR));
            result = GetVolumeInformationW(pVolumeGuid, NULL, 0L, 
                    NULL, NULL, NULL, fsName, 20);

            if (result) {
                if (!wcscmp(fsName, L"NTFS")) {
                    *pFileSystemType = PARTITION_IFS;
                }
                else if (!wcscmp(fsName, L"FAT32")) {
                    *pFileSystemType = PARTITION_FAT32;
                }
                else if (!wcscmp(fsName, L"FAT")) {
                    *pFileSystemType = PARTITION_HUGE;
                }
                else {
                    *pFileSystemType = 0;
                }
            }
            else {
                GetLastError(); // debug
            }

           result = GetDiskFreeSpace(pVolumeGuid,
                &dwSectorsPerCluster,
                &dwBytesPerSector,
                &dwNumFreeClusters,
                &dwTotalNumClusters
                );
           if (result) {
                *pClusterSize = dwSectorsPerCluster * dwBytesPerSector;
           }
           else {
               GetLastError();  // debug
           }

            // 
            // Convert the guid back to NT namespace, by changing \\?\
            // to \??\ and removing the trailing slash.
            //
            pVolumeGuid[1] = L'?';  
            pVolumeGuid[wcslen(pVolumeGuid)-1] = L'\0';
        }
    }


    //
    // Free up locally allocated data
    //
    _AsrpHeapFree(mountPointsOut);

    //
    // If we hit errors, make sure the VolumeGuid is a blank string.
    //
    if (status != ERROR_SUCCESS) {
        wcscpy(pVolumeGuid, L"");
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AsrpDetermineBuses(
    IN PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    This attempts to group the disks based on which bus they are on.  For 
        SCSI disks, this is relatively easy, since it can be based on the 
    location info (port).

    For other disks, we attempt to get the PnP parent node of the disks, and 
    group all disks having the same parent.

    The groups are identified by the SifBusKey field of each disk structure--
    i.e., all disks that have SifBusKey == 1 are on one bus, SifBusKey == 2 
    are on another bus, and so on.  The SifBusKey values are guaranteed to be
    sequential, and not have any holes (i.e., For a system with "n" buses, 
    the SifBusKey values will be 1,2,3,...,n).

    At the end SifBusKey is zero for disks which couldn't be grouped.  

Arguments:

    pDiskList - The ASR_DISK_INFO list of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/    
    
{
    BOOL    done    = FALSE,
            newPass = TRUE;
    
    ULONG   port = 0,
            sifBusKey = 0;

    DEVINST parent;

    STORAGE_BUS_TYPE busType = BusTypeUnknown;
    PASR_DISK_INFO   pCurrentDisk = pDiskList;

    //
    // The first pass goes through and groups all the scsi disks together.  
    // Note that this works for IDE too, since IDE disks respond to the 
    // IOCTL_SCSI_GET_ADDRESS and appear to us to have valid location info.
    //
    do {

        sifBusKey++;
        pCurrentDisk = pDiskList;
        done    = TRUE;
        newPass = TRUE;

        while (pCurrentDisk) {

            if ((BusTypeUnknown == pCurrentDisk->BusType) ||
                (!pCurrentDisk->pScsiAddress)) {
                pCurrentDisk = pCurrentDisk->pNext;
                continue;
            }

            if (0 == pCurrentDisk->SifBusKey) {

                done = FALSE;

                if (newPass) {
                    pCurrentDisk->SifBusKey = sifBusKey;
                    port = pCurrentDisk->pScsiAddress->PortNumber;
                    busType = pCurrentDisk->BusType;
                    newPass = FALSE;
                }
                else {
                    if ((pCurrentDisk->pScsiAddress->PortNumber == port) &&
                        (pCurrentDisk->BusType == busType)) {
                        pCurrentDisk->SifBusKey = sifBusKey;
                    }
                }
            }

            pCurrentDisk = pCurrentDisk->pNext;
        }
    } while (!done);

    //
    //  By now, the only disks with SifBusKey is 0 are disks for which
    //  pScsiAddress is NULL, ie (most-likely) non SCSI/IDE disks.  Attempt
    //  to group them on the basis of their parent dev node (which is usually
    //  the bus).  We may have to loop through multiple times again.
    //
    --sifBusKey;  // compensate for the last pass above
    do {
        sifBusKey++;
        pCurrentDisk = pDiskList;
        done    = TRUE;
        newPass = TRUE;

        while (pCurrentDisk) {

            if ((BusTypeUnknown == pCurrentDisk->BusType) ||
                (!pCurrentDisk->pScsiAddress)) {

                if ((0 == pCurrentDisk->SifBusKey) 
                    && (pCurrentDisk->ParentDevInst)) {

                    done = FALSE;

                    if (newPass) {
                        pCurrentDisk->SifBusKey = sifBusKey;
                        parent = pCurrentDisk->ParentDevInst;
                        newPass = FALSE;
                    }
                    else {
                        if (pCurrentDisk->ParentDevInst == parent) {
                            pCurrentDisk->SifBusKey = sifBusKey;
                        }
                    }
                }
            }

            pCurrentDisk = pCurrentDisk->pNext;
        }

    } while (!done);

    //
    // Disks that still have SifBusKey = 0 couldn't be grouped.  Either the 
    // BusType is unknown, or the parent node couldn't be found.
    //
    return TRUE;
}


BOOL
AsrpGetDiskLayout(
    IN  CONST HANDLE hDisk,
    IN  CONST PASR_SYSTEM_INFO pSystemInfo,
    OUT PASR_DISK_INFO pCurrentDisk,
    IN  BOOL AllDetails
    )
/*++

Routine Description:

    Fills in the fields of the pCurrentDisk structure with the relevant 
    information about the disk represented by hDisk, by querying the system 
    with the appropriate IOCTL's.

Arguments:

    hDisk - handle to the disk of interest.

    pSystemInfo - The SYSTEM_INFO structure for the current system.
        
    pCurrentDisk - Receives the information about the disk represented by 
            hDisk

    AllDetails - If FALSE, only the pDriveLayout information of pCurrentDisk 
            is filled in.  This is an optimisation that comes in handy when 
            we're dealing with disks on a shared cluster bus.

            If TRUE, all the fields of pCurrentDisk are filled in.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/    
{
    DWORD   index = 0,
            status              = ERROR_SUCCESS;

    DWORD   dwBytesReturned     = 0L,
            bufferLength        = 0L;

    BOOL    result              = FALSE;

    PDISK_GEOMETRY               diskGeometry       = NULL;
    DWORD                        sizeDiskGeometry   = 0L;

    PDRIVE_LAYOUT_INFORMATION_EX driveLayoutEx      = NULL;
    DWORD                        sizeDriveLayoutEx  = 0L;

    STORAGE_DEVICE_NUMBER        deviceNumber;
    DWORD                        sizeDeviceNumber   = 0L;

    PPARTITION_INFORMATION_EX    partition0Ex       = NULL;
    DWORD                        sizePartition0Ex   = 0L;

    PASR_PTN_INFO                pPartitionTable    = NULL;
    DWORD                        sizePartitionTable = 0L;

    STORAGE_PROPERTY_QUERY       propertyQuery;
    STORAGE_DEVICE_DESCRIPTOR    *deviceDesc        = NULL;
    STORAGE_BUS_TYPE             busType            = BusTypeUnknown;

    PSCSI_ADDRESS                scsiAddress        = NULL;

    HANDLE  heapHandle = GetProcessHeap();  // For memory allocations
    MYASSERT(heapHandle);                   // It better not be NULL

    MYASSERT(pCurrentDisk);
    MYASSERT((hDisk) && (INVALID_HANDLE_VALUE != hDisk));

    // 
    // Initialize OUT variables to known values
    //
    pCurrentDisk->Style             = PARTITION_STYLE_RAW;

    pCurrentDisk->pDriveLayoutEx    = NULL;
    pCurrentDisk->sizeDriveLayoutEx = 0L;

    pCurrentDisk->pDiskGeometry     = NULL;
    pCurrentDisk->sizeDiskGeometry  = 0L;

    pCurrentDisk->pPartition0Ex     = NULL;
    pCurrentDisk->sizePartition0Ex  = 0L;

    pCurrentDisk->pScsiAddress      = NULL;
    pCurrentDisk->BusType           = BusTypeUnknown;

    pCurrentDisk->SifBusKey         = 0L;

    SetLastError(ERROR_SUCCESS);

    //
    // Get the device number for this device.  This should succeed even if 
    // this is a clustered disk that this node doesn't own.
    //
    result = DeviceIoControl(
        hDisk,
        IOCTL_STORAGE_GET_DEVICE_NUMBER,
        NULL,
        0,
        &deviceNumber,
        sizeof(STORAGE_DEVICE_NUMBER),
        &sizeDeviceNumber,
        NULL
        );
    _AsrpErrExitCode(!result, status, GetLastError());

    pCurrentDisk->DeviceNumber      = deviceNumber.DeviceNumber;

    //
    // The output buffer for IOCTL_DISK_GET_DRIVE_LAYOUT_EX consists of a
    // DRIVE_LAYOUT_INFORMATION_EX structure as a header, followed by an 
    // array of PARTITION_INFORMATION_EX structures.
    //
    // We initially allocate enough space for the DRIVE_LAYOUT_INFORMATION_EX
    // struct, which contains a single PARTITION_INFORMATION_EX struct, and
    // 3 more PARTITION_INFORMATION_EX structs, since each (MBR) disk will
    // have a minimum of four partitions, even if they are not all in use. 
    // If the disk contains more than four partitions, we'll increase the 
    // buffer size as needed
    //
    bufferLength = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + 
        (sizeof(PARTITION_INFORMATION_EX) * 3);

    driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        bufferLength
        );
    _AsrpErrExitCode(!driveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

    result = FALSE;
    while (!result) {

        result = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0L,
            driveLayoutEx,
            bufferLength,
            &sizeDriveLayoutEx,
            NULL
            );

        if (!result) {
            status = GetLastError();
            _AsrpHeapFree(driveLayoutEx);

            // 
            // If the buffer is of insufficient size, resize the buffer.  
            // Note that get-drive-layout-ex could return error-insufficient-
            // buffer (instead of? in addition to? error-more-data)
            //
            if ((ERROR_MORE_DATA == status) || 
                (ERROR_INSUFFICIENT_BUFFER == status)
                ) {
                status = ERROR_SUCCESS;
                bufferLength += sizeof(PARTITION_INFORMATION_EX) * 4;

                driveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    bufferLength
                    );
                _AsrpErrExitCode(!driveLayoutEx, 
                    status, 
                    ERROR_NOT_ENOUGH_MEMORY
                    );
            }
            else {
                // 
                // some other error occurred, EXIT, and go to the next drive.
                //
                result = TRUE;
                status = ERROR_SUCCESS;
            }
        }
        else {

            if (!AllDetails) {
                //
                // If we don't want all the details for this disk, just exit 
                // now.  This is used in the case of clusters, where we don't
                // want to get all the details twice even if the current node 
                // owns the disk
                //
                pCurrentDisk->pDriveLayoutEx    = driveLayoutEx;
                pCurrentDisk->sizeDriveLayoutEx = sizeDriveLayoutEx;

                //
                // Jump to EXIT
                //
                _AsrpErrExitCode(TRUE, status, ERROR_SUCCESS);
            }

            //
            // The disk geometry: so that we can match the bytes-per-sector 
            // value during restore.
            //
            diskGeometry = (PDISK_GEOMETRY) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(DISK_GEOMETRY)
                );
            _AsrpErrExitCode(!diskGeometry, status, ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_DRIVE_GEOMETRY,
                NULL,
                0,
                diskGeometry,
                sizeof(DISK_GEOMETRY),
                &sizeDiskGeometry,
                NULL
                );
            _AsrpErrExitCode(!result, status, ERROR_READ_FAULT);


           partition0Ex = (PPARTITION_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(PARTITION_INFORMATION_EX)
                );
           _AsrpErrExitCode(!partition0Ex, status, ERROR_NOT_ENOUGH_MEMORY);

           //
           // Information about partition 0 (the whole disk), to get the true 
           // sector count of the disk
           //
           result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_GET_PARTITION_INFO_EX,
                NULL,
                0,
                partition0Ex,
                sizeof(PARTITION_INFORMATION_EX),
                &sizePartition0Ex,
                NULL
                );
            _AsrpErrExitCode(!result, status, ERROR_READ_FAULT);

            //
            // Figure out the bus that this disk is on.  This will only be 
            // used to group the disks--all the disks on a bus will be 
            // restored to the same bus if possible
            //
            propertyQuery.QueryType     = PropertyStandardQuery;
            propertyQuery.PropertyId    = StorageDeviceProperty;

            deviceDesc = (STORAGE_DEVICE_DESCRIPTOR *) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                ASR_BUFFER_SIZE
                );
            _AsrpErrExitCode(!deviceDesc, status, ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                hDisk,
                IOCTL_STORAGE_QUERY_PROPERTY,
                &propertyQuery,
                sizeof(STORAGE_PROPERTY_QUERY),
                deviceDesc,
                ASR_BUFFER_SIZE,
                &dwBytesReturned,
                NULL
                );
            if (result) {
               busType = deviceDesc->BusType;
            }
            _AsrpHeapFree(deviceDesc);

            scsiAddress = (PSCSI_ADDRESS) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(SCSI_ADDRESS)
                );
            _AsrpErrExitCode(!scsiAddress, status, ERROR_NOT_ENOUGH_MEMORY);

            result = DeviceIoControl(
                hDisk,
                IOCTL_SCSI_GET_ADDRESS,
                NULL,
                0,
                scsiAddress,
                sizeof(SCSI_ADDRESS),
                &dwBytesReturned,
                NULL
                );
            if (!result) {      // Not fatal--expected for non SCSI/IDE disks
                _AsrpHeapFree(scsiAddress);
                result = TRUE;
            }
        }
    }

    if (driveLayoutEx) {
        PPARTITION_INFORMATION_EX currentPartitionEx = NULL;
        WCHAR devicePath[MAX_PATH + 1];

        pCurrentDisk->Style = driveLayoutEx->PartitionStyle;

        sizePartitionTable = sizeof(ASR_PTN_INFO) *
            (driveLayoutEx->PartitionCount);

        pPartitionTable = (PASR_PTN_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizePartitionTable
            );
        _AsrpErrExitCode(!pPartitionTable, status, ERROR_NOT_ENOUGH_MEMORY);

        for (index = 0; index < driveLayoutEx->PartitionCount; index++) {

            currentPartitionEx = &driveLayoutEx->PartitionEntry[index];
            pPartitionTable[index].SlotIndex = index;

            if (currentPartitionEx->PartitionNumber) {
                swprintf(devicePath,
                    ASR_WSZ_DEVICE_PATH_FORMAT,
                    deviceNumber.DeviceNumber,
                    currentPartitionEx->PartitionNumber
                    );

                pPartitionTable[index].PartitionFlags = 0;

                //
                // Check specially for the EFI system partition
                //
                if ((PARTITION_STYLE_GPT == driveLayoutEx->PartitionStyle) &&
                    IsEqualGUID(&(currentPartitionEx->Gpt.PartitionType), &(PARTITION_SYSTEM_GUID))
                    ) { 

                    pPartitionTable[index].PartitionFlags |= ASR_FLAGS_SYSTEM_PTN;
                }

                AsrpGetMorePartitionInfo(
                    devicePath,
                    (wcslen(devicePath)+1) * sizeof(WCHAR), // cb including \0
                    pSystemInfo,
                    pPartitionTable[index].szVolumeGuid,
                    &(pPartitionTable[index].PartitionFlags),
                    &(pPartitionTable[index].FileSystemType),
                    &(pPartitionTable[index].ClusterSize)
                    );

                //
                // Make sure that the file-system type for the EFI system 
                // partition is set to FAT
                //
                if ((PARTITION_STYLE_GPT == driveLayoutEx->PartitionStyle) &&
                    IsEqualGUID(&(currentPartitionEx->Gpt.PartitionType), &(PARTITION_SYSTEM_GUID))
                    ) { 

                    pPartitionTable[index].FileSystemType = PARTITION_HUGE;
                }

                if (pPartitionTable[index].PartitionFlags) {
                    pCurrentDisk->IsCritical = TRUE;
                }
            }
        }
    }

    pCurrentDisk->pDriveLayoutEx    = driveLayoutEx;
    pCurrentDisk->sizeDriveLayoutEx = sizeDriveLayoutEx;

    pCurrentDisk->pDiskGeometry     = diskGeometry;
    pCurrentDisk->sizeDiskGeometry  = sizeDiskGeometry;

    pCurrentDisk->DeviceNumber      = deviceNumber.DeviceNumber;

    pCurrentDisk->pPartition0Ex     = partition0Ex;
    pCurrentDisk->sizePartition0Ex  = sizePartition0Ex;

    pCurrentDisk->pScsiAddress      = scsiAddress;
    pCurrentDisk->BusType           = busType;

    pCurrentDisk->PartitionInfoTable = pPartitionTable;
    pCurrentDisk->sizePartitionInfoTable = sizePartitionTable;

EXIT:
    // 
    // Free up locally allocated memory on failure
    //
    if (status != ERROR_SUCCESS) {
        _AsrpHeapFree(driveLayoutEx);
        _AsrpHeapFree(diskGeometry);
        _AsrpHeapFree(partition0Ex);
        _AsrpHeapFree(scsiAddress);
        _AsrpHeapFree(pPartitionTable);
    }

    //
    // Make sure the last error is set if we are going to return FALSE
    //
    if ((ERROR_SUCCESS != status) && (ERROR_SUCCESS == GetLastError())) {
        SetLastError(status);
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AsrpGetSystemPath(
    IN PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Gets the system partition DevicePath, and fills in the SystemPath field
    of the ASR_SYSTEM_INFO struct, by looking up the HKLM\Setup registry key.
    This key is updated at every boot with the path to the current system 
    device.  The path is of the form
    \Device\Harddisk0\Partition1                (basic disks)
    \Device\HarddiskDmVolumes\DgName\Volume1    (dynamic disks)

Arguments:
    
    pSystemInfo - The SystemPath field of this struct will be filled with
            a pointer to the path to the current system device

Return Value:

    If the function succeeds, the return value is a nonzero value. 
            pSystemInfo->SystemPath is a pointer to a null-terminated string 
            containing the path to the current system device.  The caller is 
            reponsible for freeing this memory with a call to 
            HeapFree(GetProcessHeap(),...).

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError(). pSystemInfo->SystemPath is set 
            to NULL.

--*/

{
    HKEY    regKey              = NULL;
    DWORD   type                = 0L;

    HANDLE  heapHandle          = NULL;
    DWORD   status              = ERROR_SUCCESS;

    PWSTR   systemPartition     = NULL;
    DWORD   cbSystemPartition   = 0L;

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    MYASSERT(pSystemInfo);
    if (!pSystemInfo) {
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    pSystemInfo->SystemPath = NULL;

    // 
    // Open the reg key to find the system partition
    //
    status = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, // hKey
        ASR_REGKEY_SETUP,   // lpSubKey
        0,                  // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,    // samDesired
        &regKey             // phkResult    
        );
    _AsrpErrExitCode(status, status, ERROR_REGISTRY_IO_FAILED);

    //
    // Allocate a reasonably sized buffer for the system partition, to
    // start off with.  If this isn't big enough, we'll re-allocate as
    // needed.
    //
    cbSystemPartition = (MAX_PATH + 1) * sizeof(WCHAR);
    systemPartition = HeapAlloc(heapHandle, 
        HEAP_ZERO_MEMORY, 
        cbSystemPartition
        );

    _AsrpErrExitCode((!systemPartition), status, ERROR_NOT_ENOUGH_MEMORY);

    // 
    // Get the system partition device Name. This is of the form
    //      \Device\Harddisk0\Partition1                (basic disks)
    //      \Device\HarddiskDmVolumes\DgName\Volume1    (dynamic disks)
    //
    status = RegQueryValueExW(
        regKey,
        ASR_REGVALUE_SYSTEM_PARTITION,
        NULL,
        &type,
        (LPBYTE)systemPartition,
        &cbSystemPartition        // \0 is included
        );
    _AsrpErrExitCode((type != REG_SZ), status, ERROR_REGISTRY_IO_FAILED);

    while (ERROR_MORE_DATA == status) {
        //
        // Our buffer wasn't big enough, cbSystemPartition contains 
        // the required size.
        //
        _AsrpHeapFree(systemPartition);
        systemPartition = HeapAlloc(heapHandle, 
            HEAP_ZERO_MEMORY, 
            cbSystemPartition
            );
        _AsrpErrExitCode((!systemPartition), status, ERROR_NOT_ENOUGH_MEMORY);

        status = RegQueryValueExW(
            regKey,
            ASR_REGVALUE_SYSTEM_PARTITION,
            NULL,
            &type,
            (LPBYTE)systemPartition,
            &cbSystemPartition        // \0 is included
            );
    }

EXIT:
    if (regKey) {
        RegCloseKey(regKey);
        regKey = NULL;
    }

    if (ERROR_SUCCESS != status) {
        _AsrpHeapFree(systemPartition);
        return FALSE;
    }
    else {
        pSystemInfo->SystemPath = systemPartition;
        return TRUE;
    }
}


BOOL
AsrpInitSystemInformation(
    IN OUT PASR_SYSTEM_INFO pSystemInfo,
    IN CONST BOOL bEnableAutoExtend
    )

/*++

Routine Description:

    Initialisation routine to allocate memory for various fields in the
    ASR_SYSTEM_INFO structure, and fill them in with the relevant information.

Arguments:
    pSystemInfo - The struct to be filled in with info about the current 
            system.

Return Value:

    If the function succeeds, the return value is a nonzero value.  The caller
            is responsible for freeing memory pointed to by the various 
            pointers in the struct, using HeapFree(GetProcessHeap(),...).

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  The caller is still responsible
            for checking the fields and releasing any non-NULL pointers using
            HeapFree(GetProcessHeap(),...).

--*/

{
    DWORD cchBootDirectory = 0L,
        reqdSize = 0L;

    BOOL result = FALSE;

    HANDLE heapHandle = GetProcessHeap();

    //
    // Initialise the structure to zeroes
    //
    memset(pSystemInfo, 0L, sizeof (ASR_SYSTEM_INFO));

    //
    //  The auto-extension feature
    //
    pSystemInfo->AutoExtendEnabled = bEnableAutoExtend;

    // 
    // Get the machine name
    //
    pSystemInfo->sizeComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerNameW(pSystemInfo->ComputerName, 
            &(pSystemInfo->sizeComputerName)
        )) {
        //
        // GetComputerName sets LastError
        //
        return FALSE;
    }

    // 
    // Get the Processor Architecture.  We expect the process architecture
    // to be a either x86, amd64, or ia64, so if it doesn't fit in our buffer of
    // six characters, we don't support it anyway.
    //
    pSystemInfo->Platform = HeapAlloc(heapHandle, 
        HEAP_ZERO_MEMORY, 
        6*sizeof(WCHAR)
        );

    if (!pSystemInfo->Platform) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    reqdSize = GetEnvironmentVariableW(L"PROCESSOR_ARCHITECTURE",
        pSystemInfo->Platform,
        6
        );

    if (0 == reqdSize) {
        //
        // We couldn't find the PROCESSOR_ARCHITECTURE variable
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    if (reqdSize > 6) {
        //
        // The architecture didn't fit in our buffer
        //
        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    // 
    // Get the OS version
    //
    pSystemInfo->OsVersionEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    result = GetVersionEx((LPOSVERSIONINFO) (&(pSystemInfo->OsVersionEx)));
    if (!result) {
        //
        // GetVersionEx sets the LastError
        //
        return FALSE;
    }

    //
    // Get the boot directory
    //
    pSystemInfo->BootDirectory = HeapAlloc(heapHandle, 
        HEAP_ZERO_MEMORY, 
        (MAX_PATH+1)*sizeof(WCHAR)
        );

    if (!(pSystemInfo->BootDirectory)) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    cchBootDirectory = GetSystemWindowsDirectoryW(pSystemInfo->BootDirectory, 
        MAX_PATH + 1
        );
    if (0 == cchBootDirectory) {
        // 
        // GetSystemWindowsDirectoryW sets LastError
        //
        return FALSE;
    }

    if (cchBootDirectory > 
        ASR_SIF_ENTRY_MAX_CHARS - MAX_COMPUTERNAME_LENGTH - 26) {
        //
        // We can't write out sif lines that are more than 
        // ASR_SIF_ENTRY_MAX_CHARS chars long
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    if (cchBootDirectory > MAX_PATH) {
        UINT cchNewSize = cchBootDirectory + 1;
        //
        // Our buffer wasn't big enough, free and re-alloc as needed
        //
        _AsrpHeapFree(pSystemInfo->BootDirectory);
        pSystemInfo->BootDirectory = HeapAlloc(heapHandle, 
            HEAP_ZERO_MEMORY, 
            (cchNewSize + 1) * sizeof(WCHAR)
            );
        if (!(pSystemInfo->BootDirectory)) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        cchBootDirectory = GetSystemWindowsDirectoryW(pSystemInfo->BootDirectory, 
            MAX_PATH + 1
            );
        if (!cchBootDirectory) {
            // 
            // GetSystemWindowsDirectoryW sets LastError
            //
            return FALSE;
        }

        if (cchBootDirectory > cchNewSize) {
            SetLastError(ERROR_BAD_ENVIRONMENT);
            return FALSE;
        }
    }

    // 
    // Get the system directory
    //
    if (!AsrpGetSystemPath(pSystemInfo)) {
        //
        // AsrpGetSystemPath sets LastError
        //
        return FALSE;
    }

    //
    // Get the time-zone information.   We need to save and restore this since
    // GUI-mode Setup (ASR) will otherwise default to GMT, and the file-time
    // stamps on all the restored files will be off, since most back-up apps 
    // assume that they're restoring in the same time-zone that they backed 
    // up in and do nothing special to restore the time-zone first.
    //
    GetTimeZoneInformation(&(pSystemInfo->TimeZoneInformation));


    return TRUE;
}


BOOL
AsrpInitLayoutInformation(
    IN CONST PASR_SYSTEM_INFO pSystemInfo,
    IN OUT PASR_DISK_INFO pDiskList,
    OUT PULONG MaxDeviceNumber OPTIONAL,
    IN BOOL AllDetailsForLocalDisks,
    IN BOOL AllDetailsForOfflineClusteredDisks
    )

/*++

Routine Description:
    
    Initialisation routine to fill in layout and other interesting information 
    about the disks on the system.

Arguments:

    pSystemInfo - the ASR_SYSTEM_INFO for the current system

    pDiskList - ASR_DISK_INFO list of disks on the current system, with 
            the DevicePath field for each disk pointing to a null terminated 
            path to the disk, that can be used to open a handle to the disk.

            The other fields of the structure are filled in by this routine,
            if the disk could be accessed and the appropriate info could be
            obtained.

    MaxDeviceNumber - Receives the max device number of all the disks on the
            system.  This can be used as an optimisation to allocate memory
            for a table of disks based on the device number.

            This is an optional argument.

    AllDetailsForLocalDisks - If FALSE, only the pDriveLayout information is 
            filled in for each disk.  This is an optimisation that comes in 
            handy when we're dealing with disks on a shared cluster bus.

            If TRUE, all the fields are filled in for each "local" disk, 
            which includes all unshared disks and shared clustered disks
            owned by this node.

    AllDetailsForOfflineClusteredDisks - If FALSE, only the pDriveLayout 
            information is filled in for each disk.  
            
            If TRUE, all the fields are filled in for each disk, and any
            errors encountered are treated as failures (even if the
            disk is a shared disk that is offline on this node).

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    BOOL   result = FALSE;
    HANDLE hDisk  = NULL;
    PASR_DISK_INFO currentDisk = pDiskList;
    BOOL getAllDetails = FALSE;

    if (ARGUMENT_PRESENT(MaxDeviceNumber)) {
        *MaxDeviceNumber = 0;
    }

    while (currentDisk) {
        //
        // Open the disk.  If an error occurs, get the next
        // disk from the disk list and continue.
        //
        hDisk = CreateFileW(
            currentDisk->DevicePath,        // lpFileName
            0,                   // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,                           // lpSecurityAttributes
            OPEN_EXISTING,                  // dwCreationFlags
            FILE_ATTRIBUTE_NORMAL,          // dwFlagsAndAttributes
            NULL                            // hTemplateFile
            );

        if ((!hDisk) || (INVALID_HANDLE_VALUE == hDisk)) {
            //
            // We couldn't open the disk.  If this is a critical disk, we'll
            // fail later in AsrpMarkCriticalDisks, so it's okay to ignore 
            // this error for now.
            //
            currentDisk = currentDisk->pNext;
            continue;
        }


        //
        // Set getAllDetails to the appropriate flag, based on whether this
        // is a clustered disk that's offline, or a local disk.  Note that 
        // this routine will open (and close) another handle to the disk, 
        // since the ioctl it uses to figure this out needs FILE_WRITE_ACCESS
        // (and our handle above is opened with 0 access, which suffices for
        // the rest of the IOCTL's).
        //
        if (AsrpIsOfflineClusteredDisk(hDisk)) {
            getAllDetails = AllDetailsForOfflineClusteredDisks;
        }
        else {
            getAllDetails = AllDetailsForLocalDisks;
        }

        //
        // Get the layout and other interesting info for this disk.  
        // If this fails, we must abort.
        //
        result = AsrpGetDiskLayout(hDisk, 
            pSystemInfo, 
            currentDisk, 
            getAllDetails
            );
        if (!result) {
            DWORD status = GetLastError();
            _AsrpCloseHandle(hDisk);    // this may change LastError. 
            SetLastError(status);
            return FALSE;
        }

        _AsrpCloseHandle(hDisk);

        //
        // Set the max device number if needed
        //
        if (ARGUMENT_PRESENT(MaxDeviceNumber) &&
            (currentDisk->DeviceNumber > *MaxDeviceNumber)
            ) {
            *MaxDeviceNumber = currentDisk->DeviceNumber;
        }

        //
        // Get the next drive from the drive list.
        //
        currentDisk = currentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpInitDiskInformation(
    OUT PASR_DISK_INFO  *ppDiskList
    )

/*++

Routine Description:

    Initialisation routine to get a list of disks present on the system.  This
    routine allocates a ASR_DISK_INFO struct for each disk on the machine, and
    fills in the DevicePath and ParentDevInst fields of each with a path to 
    the disk.  It is expected that the other fields will be filled in with a 
    subsequent call to AsrpInitLayoutInformation().

Arguments:
    ppDiskList - Receives the location of the first ASR_DISK_INFO struct.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  ppDiskList may point to an 
            incomplete list of disks on the system, and it is the caller's 
            responsibility to free the memory allocated, if any, using
            HeapFree(GetProcessHeap(),...).

--*/

{
    DWORD count = 0,
        status = ERROR_SUCCESS;

    HDEVINFO hdevInfo = NULL;

    BOOL result = FALSE;

    PASR_DISK_INFO pNewDisk = NULL;

    HANDLE heapHandle = NULL;

    PSP_DEVICE_INTERFACE_DETAIL_DATA_W pDiDetail = NULL;

    SP_DEVICE_INTERFACE_DATA devInterfaceData;
    
    DWORD sizeDiDetail = 0;

    SP_DEVINFO_DATA devInfoData;

    //
    // Initialise stuff to zeros
    //
    memset(&devInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
    *ppDiskList = NULL;

    heapHandle = GetProcessHeap();    // used for HeapAlloc functions
    MYASSERT(heapHandle);

    //
    // Get a device interface set which includes all Disk devices
    // present on the machine. DiskClassGuid is a predefined GUID that
    // will return all disk-type device interfaces
    //
    hdevInfo = SetupDiGetClassDevsW(
        &DiskClassGuid,
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE
        );
    _AsrpErrExitCode(
        ((NULL == hdevInfo) || (INVALID_HANDLE_VALUE == hdevInfo)),
        status,
        ERROR_IO_DEVICE
        );

    //
    // Iterate over all devices interfaces in the set
    //
    for (count = 0; ; count++) {

        // must set size first
        devInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA); 

        //
        // Retrieve the device interface data for each device interface
        //
        result = SetupDiEnumDeviceInterfaces(
            hdevInfo,
            NULL,
            &DiskClassGuid,
            count,
            &devInterfaceData
            );

        if (!result) {
            //
            // If we retrieved the last item, break
            //
            status = GetLastError();

            if (ERROR_NO_MORE_ITEMS == status) {
                status = ERROR_SUCCESS;
                break;
            }
            else {
                //
                // Some other error occured, goto EXIT.  We overwrite the 
                // last error.
                //
                _AsrpErrExitCode(status, status, ERROR_IO_DEVICE);
            }
        }

        //
        // Get the required buffer-size for the device path
        //
        result = SetupDiGetDeviceInterfaceDetailW(
            hdevInfo,
            &devInterfaceData,
            NULL,
            0,
            &sizeDiDetail,
            NULL
            );

        if (!result) {

            status = GetLastError();
            //
            // If a value other than "insufficient buffer" is returned,
            // an error occured
            //
            _AsrpErrExitCode((ERROR_INSUFFICIENT_BUFFER != status), 
                status, 
                ERROR_IO_DEVICE
                );
        }
        else {
            //
            // The call should have failed since we're getting the
            // required buffer size.  If it doesn't, and error occurred.
            //
            _AsrpErrExitCode(status, status, ERROR_IO_DEVICE);
        }

        //
        // Allocate memory for the buffer
        //
        pDiDetail = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeDiDetail
            );
        _AsrpErrExitCode(!pDiDetail, status, ERROR_NOT_ENOUGH_MEMORY);

        // must set the struct's size member
        pDiDetail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
        devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        //
        // Finally, retrieve the device interface detail info
        //
        result = SetupDiGetDeviceInterfaceDetailW(
            hdevInfo,
            &devInterfaceData,
            pDiDetail,
            sizeDiDetail,
            NULL,
            &devInfoData
            );
        _AsrpErrExitCode(!result, status, GetLastError());

        //
        // Okay, now alloc a struct for this disk, and fill in the DevicePath
        // field with the Path from the interface detail.
        //
        pNewDisk = (PASR_DISK_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_DISK_INFO)
            );
        _AsrpErrExitCode(!pNewDisk, status, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Insert at the head so this is O(1) and not O(n!)
        //
        pNewDisk->pNext = *ppDiskList;
        *ppDiskList = pNewDisk;

        pNewDisk->DevicePath = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(WCHAR) * (wcslen(pDiDetail->DevicePath) + 1)
            );
        _AsrpErrExitCode(!(pNewDisk->DevicePath), 
            status, 
            ERROR_NOT_ENOUGH_MEMORY
            );
        wcscpy(pNewDisk->DevicePath, pDiDetail->DevicePath);

        //
        // Get the PnP parent of this disk, so we can use it for grouping 
        // disks later based on the bus they are on.
        //
        CM_Get_Parent(&(pNewDisk->ParentDevInst),
            devInfoData.DevInst,
            0
            );

        _AsrpHeapFree(pDiDetail);
    }

EXIT:
    //
    // Free local mem allocs
    //
    _AsrpHeapFree(pDiDetail);

    if ((hdevInfo) && (INVALID_HANDLE_VALUE != hdevInfo)) {
        SetupDiDestroyDeviceInfoList(hdevInfo);
        hdevInfo = NULL;
    }

    return (BOOL) (status == ERROR_SUCCESS);
}


BOOL
AsrpMarkCriticalDisks(
    IN PASR_DISK_INFO pDiskList,
    IN PCWSTR         CriticalVolumeList,
    IN ULONG          MaxDeviceNumber
    )

/*++

Routine Description:
  
   Sets the IsCritical flag of each of the critical disks on the system.  A 
   disk is deemed "critical" if it is part of part of the failover set for 
   any of the critical volumes present on the system.

Arguments:

    pDiskList - The list of disks on the current system.

    CriticalVolumeList - A multi-string containing a list of the volume GUID's
            of each of the critical volumes present on the system.  The GUID's
            must be in the NT name-space, i.e., must be of the form:
            \??\Volume{GUID}

    MaxDeviceNumber - The highest storage device number of the disks present 
            in the disk list, as determined by calling 
            IOCTL_STORAGE_GET_DEVICE_NUMBER for each of them.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    PCWSTR volGuid = NULL;

    PASR_DISK_INFO currentDisk = NULL;
    
    PVOLUME_FAILOVER_SET failoverSet = NULL;
    
    DWORD index = 0, 
        reqdSize=0, 
        sizeFailoverSet = 0,
        status = ERROR_SUCCESS;

    BOOL result = TRUE,
        *criticalDiskTable = NULL;

    WCHAR devicePath[ASR_CCH_DEVICE_PATH_FORMAT + 1];

    HANDLE heapHandle = NULL, 
        hDevice = NULL;

    memset(devicePath, 0L, (ASR_CCH_DEVICE_PATH_FORMAT+1)*sizeof(WCHAR));

    if (!CriticalVolumeList) {
        //
        //  No critical volumes:
        //
#ifdef PRERELEASE
        return TRUE;
#else
        return FALSE;
#endif
    }

    if (!pDiskList) {
        //
        //  No disks on machine?!
        //
        MYASSERT(0 && L"DiskList is NULL");
        return FALSE;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    //  criticalDiskTable is our table of BOOL values.
    //
    criticalDiskTable = (BOOL *) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (BOOL) * (MaxDeviceNumber + 1)
        );
    _AsrpErrExitCode(!criticalDiskTable, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Try with a reasonable sized buffer first--say 10 disks.  We'll
    // realloc as needed if this isn't enough.
    //
    sizeFailoverSet = sizeof(VOLUME_FAILOVER_SET) +  (10 * sizeof(ULONG));
    failoverSet = (PVOLUME_FAILOVER_SET) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeFailoverSet
        );
    _AsrpErrExitCode(!failoverSet, status, ERROR_NOT_ENOUGH_MEMORY);

    volGuid = CriticalVolumeList;
    while (*volGuid) {
        //
        // Convert the \??\ to \\?\ so that CreateFile can use it
        //
        wcsncpy(devicePath, volGuid, ASR_CCH_DEVICE_PATH_FORMAT);
        devicePath[1] = L'\\';

        //
        //  Get a handle so we can send the ioctl
        //
        hDevice = CreateFileW(
            devicePath,       // lpFileName
            0,       // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,               // lpSecurityAttributes
            OPEN_EXISTING,      // dwCreationFlags
            0,                  // dwFlagsAndAttributes
            NULL                // hTemplateFile
            );
        _AsrpErrExitCode(((!hDevice) || (INVALID_HANDLE_VALUE == hDevice)),
            status,
            GetLastError());

        result = DeviceIoControl(
            hDevice,
            IOCTL_VOLUME_QUERY_FAILOVER_SET,
            NULL,
            0,
            failoverSet,
            sizeFailoverSet,
            &reqdSize,
            NULL
            );

        //
        // We're doing this in a while loop because if the disk configuration  
        // changes in the small interval between when we get the reqd buffer 
        // size and when we send the ioctl again with a buffer of the "reqd" 
        // size, we may still end up with a buffer that isn't big enough.
        //
        while (!result) {
            status = GetLastError();

            if (ERROR_MORE_DATA == status) {
                //
                // The buffer was too small, reallocate the reqd size.
                //
                status = ERROR_SUCCESS;

                sizeFailoverSet = (sizeof(VOLUME_FAILOVER_SET)  + 
                    ((failoverSet->NumberOfDisks) * sizeof(ULONG)));

                _AsrpHeapFree(failoverSet);

                failoverSet = (PVOLUME_FAILOVER_SET) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    sizeFailoverSet
                    );
                _AsrpErrExitCode(!failoverSet, 
                    status, 
                    ERROR_NOT_ENOUGH_MEMORY
                    );

                result = DeviceIoControl(
                    hDevice,
                    IOCTL_VOLUME_QUERY_FAILOVER_SET,
                    NULL,
                    0,
                    failoverSet,
                    sizeFailoverSet,
                    &reqdSize,
                    NULL
                    );
            }
            else {
                //
                // The IOCTL failed because of something else, this is
                // fatal since we can't find the critical disk list now.
                //
                _AsrpErrExitCode((TRUE), status, status);
            }
        }

        //
        // Mark the appropriate entries in our table
        //
        for (index = 0; index < failoverSet->NumberOfDisks; index++) {
            criticalDiskTable[failoverSet->DiskNumbers[index]] = 1;
        }
        _AsrpCloseHandle(hDevice);

        //
        // Repeat for next volumeguid in list
        //
        volGuid += (wcslen(CriticalVolumeList) + 1);
    }

    //
    // Now go through the list of disks, and mark the critical flags.
    //
    currentDisk = pDiskList;
    while (currentDisk) {

        if (currentDisk->IsClusterShared) {
            //
            // By definition, cluster shared disks cannot be critical.
            //
            currentDisk = currentDisk->pNext;
            continue;
        }
    
        currentDisk->IsCritical = 
            (criticalDiskTable[currentDisk->DeviceNumber] ? TRUE : FALSE);

        //
        // Increment the entry, so that we can track how many critical volumes
        // reside on this disk, and--more importantly--ensure that all the
        // critical disks exist on the system (next loop below)
        //
        if (currentDisk->IsCritical) {
            ++(criticalDiskTable[currentDisk->DeviceNumber]);
        }

        currentDisk = currentDisk->pNext;

    }

    //
    // Finally, we want to make sure that we don't have any critical disks
    // in our table that we didn't find physical disks for.  (I.e., make  
    // sure that the system has no "missing" critical disks)
    //
    for (index = 0; index < MaxDeviceNumber; index++) {
        if (1 == criticalDiskTable[index]) {
            //
            // If the table still has "1" for the value, it was never 
            // incremented in the while loop above, ie our diskList doesn't 
            // have a disk corresponding to this.
            //
            _AsrpErrExitCode(TRUE, status, ERROR_DEV_NOT_EXIST);
        }
    }

EXIT:
    _AsrpHeapFree(failoverSet);
    _AsrpHeapFree(criticalDiskTable);
    _AsrpCloseHandle(hDevice);

    return (BOOL)(ERROR_SUCCESS == status);
}


PASR_DISK_INFO
AsrpFreeDiskInfo(
    PASR_DISK_INFO  pCurrentDisk
    )

/*++

Routine Description:

    Helper function to free memory pointed to by various pointers in the
    ASR_DISK_INFO struct, and then free the struct itself.

Arguments:

    pCurrentDisk - the struct to be freed

Return Value:

    pCurrentDisk->Next, which is a pointer to the next disk in the list

--*/

{
    HANDLE          heapHandle  = NULL;
    PASR_DISK_INFO  pNext       = NULL;

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    if (pCurrentDisk) {

        pNext = pCurrentDisk->pNext;
        //
        // If it's a packed struct, then we only need to free the struct 
        // itself.  If not, we need to free the memory the pointers point 
        // to as well.
        //
        if (!pCurrentDisk->IsPacked) {
            _AsrpHeapFree(pCurrentDisk->DevicePath);
            _AsrpHeapFree(pCurrentDisk->pDriveLayoutEx);
            _AsrpHeapFree(pCurrentDisk->pDiskGeometry);
            _AsrpHeapFree(pCurrentDisk->pPartition0Ex);
            _AsrpHeapFree(pCurrentDisk->pScsiAddress);
            _AsrpHeapFree(pCurrentDisk->PartitionInfoTable);
        }

        _AsrpHeapFree(pCurrentDisk);
    }

    return pNext;
}


BOOL
AsrpIsRemovableOrInaccesibleMedia(
    IN PASR_DISK_INFO pDisk
    ) 
/*++

Routine Description:

    Checks if the disk represented by pDisk should be removed from our list
    of disks that we'll store information on in the state file.  

    Disks that should be removed include disks that are removable, or disks
    that we couldn't access.
 
Arguments:

    pDisk - the disk structure to be checked

Return Value:

    TRUE if the device is removable, or some key information about the disk is 
            missing.  Since code depends on the driveLayout being non-NULL, 
            for instance, we shall just remove the disk from the list if we 
            couldn't get it's drive layout.  We shall therefore not backup 
            information about any disk whose drive geo or layout we couldn't 
            get, and not restore to any such disk.

    FALSE if the structure contains all the required information, and is not
            a removable device.

--*/

{

    if ((NULL == pDisk->pDiskGeometry) ||
        (NULL == pDisk->pDriveLayoutEx) ||
        (NULL == pDisk->pPartition0Ex) ||
        (FixedMedia != pDisk->pDiskGeometry->MediaType)
        ) {
        
        return TRUE;
    }

    if (AsrpIsInaccessibleSanDisk(pDisk->DeviceNumber) && (!pDisk->IsClusterShared)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
AsrpFreeNonFixedMedia(
    IN OUT PASR_DISK_INFO *ppDiskList
    )

/*++

Routine Description:
    
    Removes removable media, and disks that are inaccessible, from the list of
    disks passed in.

Arguments:

    ppDiskList - a pointer to the address of the first disk in the list of all
            the disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  
            
    Currently, this function always succeeds.

--*/

{
    PASR_DISK_INFO  prevDisk = NULL,
        currentDisk = *ppDiskList;

    while (currentDisk) {

        if (AsrpIsRemovableOrInaccesibleMedia(currentDisk)) {
            //
            // Disk is not Fixed, we should remove it from out list
            //
            if (NULL == prevDisk) {      // this is the first disk in the list
                *ppDiskList = currentDisk->pNext;
            }
            else {
                prevDisk->pNext = currentDisk->pNext;
            }

            //
            // Free it and get a pointer to the next disk
            //
            currentDisk = AsrpFreeDiskInfo(currentDisk);
        }
        else {
            //
            // Disk is okay, move on to the next disk
            //
            prevDisk = currentDisk;
            currentDisk = currentDisk->pNext;

        }
    }

    return TRUE;
}


VOID
AsrpFreeStateInformation(
    IN OUT PASR_DISK_INFO *ppDiskList OPTIONAL,
    IN OUT PASR_SYSTEM_INFO pSystemInfo OPTIONAL
    )

/*++

Routine Description:
    
    Frees the memory addressed by pointers in the ASR_DISK_INFO and 
    ASR_SYSTEM_INFO structs.

    Frees the list of disks pointed to by the ASR_DISK_INFO struct.

Arguments:
    
    ppDiskList - Pointer to the address of the first Disk in the DiskList 
            being freed.  The address is set to NULL after the list is freed,
            to prevent further unintended accesses to the freed object.

    pSystemInfo - A pointer to the ASR_SYSTEM_INFO struct, containing the
            pointers to be freed.

Return Value:

    If the function succeeds, the return value is a nonzero value.  
            *ppDiskList is set to NULL.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

    Currently, this function always succeeds.

--*/

{
    PASR_DISK_INFO  pTempDisk = NULL;

    HANDLE heapHandle = GetProcessHeap();
    
    MYASSERT(heapHandle);

    if (ARGUMENT_PRESENT(ppDiskList)) {

        pTempDisk = *ppDiskList;

        while (pTempDisk) {
            pTempDisk = AsrpFreeDiskInfo(pTempDisk);
        }

        *ppDiskList = NULL;
    }

    if (ARGUMENT_PRESENT(pSystemInfo)) {
        _AsrpHeapFree(pSystemInfo->SystemPath);
        _AsrpHeapFree(pSystemInfo->BootDirectory);
    }
}


VOID
AsrpFreePartitionList(
    IN OUT PASR_PTN_INFO_LIST *ppPtnList OPTIONAL
    )

/*++

Routine Description:

    Frees the list of partitions, along with memory addressed by all the 
    pointers in the list.

Arguments:

    ppPtnList - Pointer to the address of the first partition in the list
            being freed.  The address is set to NULL after the list is freed,
            to prevent further unintended accesses to the freed object.

Return Value:

    If the function succeeds, the return value is a nonzero value.  
            *ppPtnList is set to NULL.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

    Currently, this function always succeeds.

--*/

{
    DWORD index = 0,
        numberOfPartitions = 0;

    PASR_PTN_INFO_LIST pList = NULL;

    PASR_PTN_INFO pCurrent = NULL,
        pNext = NULL;

    HANDLE  heapHandle = GetProcessHeap();

    if (!ARGUMENT_PRESENT(ppPtnList) || !(*ppPtnList)) {
        return;
    }

    pList = *ppPtnList;

    numberOfPartitions = pList[0].numTotalPtns;

    for (index = 0; index < numberOfPartitions; index++) {

        pCurrent = pList[index].pOffsetHead;

        while (pCurrent) {
            //
            // Save a pointer to the next
            //
            pNext = pCurrent->pOffsetNext;

            //
            // No pointers in PASR_PTN_INFO, okay to free as-is.
            //
            _AsrpHeapFree(pCurrent);

            pCurrent = pNext;
        }
    }

    _AsrpHeapFree(pList);
    *ppPtnList = NULL;
}


BOOL
AsrpWriteVersionSection(
    IN CONST HANDLE SifHandle,
    IN PCWSTR Provider OPTIONAL
    )

/*++

Routine Description:

    Creates the VERSION section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    Provider - Pointer to a null-terminated string containing the name of the
            application creating the asr.sif.  The length of this string must
            not exceed (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING)
            characters.

            This is an optional argument.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{

    WCHAR   infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];
    DWORD   size;

    // 
    // Write out the section name
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_VERSION_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Section Entries
    //
    wcscpy(infstring, L"Signature=\"$Windows NT$\"\r\n");
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    wcscpy(infstring, L"ASR-Version=\"1.0\"\r\n");
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    if (ARGUMENT_PRESENT(Provider)) {
        if (wcslen(Provider) > 
            (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING)
            ) {
            //
            // This string is too long to fit into one line in asr.sif
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        swprintf(infstring, L"%ws\"%.*ws\"\r\n", 
            ASR_SIF_PROVIDER_PREFIX, 
            (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING), 
            Provider
            );
        _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
            wcslen(infstring)*sizeof(WCHAR), &size, NULL));
    }

    return TRUE;
}


BOOL
AsrpWriteSystemsSection(
    IN CONST HANDLE SifHandle,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Creates the SYSTEMS section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pSystemInfo - Pointer to information about the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];
    DWORD size = 0, SKU = 0;

    if ((!pSystemInfo) || (!pSystemInfo->BootDirectory)) {
        //
        // We need a boot directory
        //
        SetLastError(ERROR_BAD_ENVIRONMENT);
        return FALSE;
    }

    // 
    // Write out the section name
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_SYSTEM_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    SKU = (DWORD) (pSystemInfo->OsVersionEx.wProductType);
    SKU = SKU << 16;            // shift the ProductType left 2 bytes
    SKU = SKU | (DWORD) (pSystemInfo->OsVersionEx.wSuiteMask);
    //
    // Create the section entry, and write it out to file.
    //
    swprintf(infstring,
        L"1=\"%ws\",\"%ws\",\"%d.%d\",\"%ws\",%d,0x%08x,\"%ld %ld %ld %hd-%hd-%hd-%hd %hd:%02hd:%02hd.%hd %hd-%hd-%hd-%hd %hd:%02hd:%02hd.%hd\",\"%ws\",\"%ws\"\r\n",
        pSystemInfo->ComputerName,
        pSystemInfo->Platform,
        pSystemInfo->OsVersionEx.dwMajorVersion,
        pSystemInfo->OsVersionEx.dwMinorVersion,
        pSystemInfo->BootDirectory,
        ((pSystemInfo->AutoExtendEnabled) ? 1 : 0),

        // Product SKU
        SKU, 

        // Time-zone stuff
        pSystemInfo->TimeZoneInformation.Bias,
        pSystemInfo->TimeZoneInformation.StandardBias,
        pSystemInfo->TimeZoneInformation.DaylightBias,

        pSystemInfo->TimeZoneInformation.StandardDate.wYear,
        pSystemInfo->TimeZoneInformation.StandardDate.wMonth,
        pSystemInfo->TimeZoneInformation.StandardDate.wDayOfWeek,
        pSystemInfo->TimeZoneInformation.StandardDate.wDay,

        pSystemInfo->TimeZoneInformation.StandardDate.wHour,
        pSystemInfo->TimeZoneInformation.StandardDate.wMinute,
        pSystemInfo->TimeZoneInformation.StandardDate.wSecond,
        pSystemInfo->TimeZoneInformation.StandardDate.wMilliseconds,

        pSystemInfo->TimeZoneInformation.DaylightDate.wYear,
        pSystemInfo->TimeZoneInformation.DaylightDate.wMonth,
        pSystemInfo->TimeZoneInformation.DaylightDate.wDayOfWeek,
        pSystemInfo->TimeZoneInformation.DaylightDate.wDay,

        pSystemInfo->TimeZoneInformation.DaylightDate.wHour,
        pSystemInfo->TimeZoneInformation.DaylightDate.wMinute,
        pSystemInfo->TimeZoneInformation.DaylightDate.wSecond,
        pSystemInfo->TimeZoneInformation.DaylightDate.wMilliseconds,

        pSystemInfo->TimeZoneInformation.StandardName,
        pSystemInfo->TimeZoneInformation.DaylightName
        );

    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    return TRUE;
}


BOOL
AsrpWriteBusesSection(
    IN CONST HANDLE SifHandle,
    IN CONST PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    Creates the BUSES section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD size = 0,
        busKey = 1;

    BOOL done = FALSE;
    
    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PASR_DISK_INFO pCurrentDisk = NULL;

    // 
    // Write out the section name
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_BUSES_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Create the list of buses.  This routine fills in the SifBusKey field
    // for each disk.
    //
    AsrpDetermineBuses(pDiskList);

    //
    // Go through the list of disks now, and add one entry in asr.sif for each
    // bus present on the system (i.e., each unique SifBusKey value).  Note 
    // that we won't care about disks for which we couldn't get any bus info--
    // SifBusKey is 0 for such disks, and we start here from SifBusKey == 1.
    //
    // Also, we assume that SifBusKey values have no holes.
    //
    while (!done) {

        done = TRUE;    // assume that we've been through all the buses.
        //
        // Start from the beginning of the list
        //
        pCurrentDisk = pDiskList;

        while (pCurrentDisk) {

            if (pCurrentDisk->SifBusKey > busKey) {
                //
                // There are SifBusKeys we haven't covered yet.
                //
                done = FALSE;
            }

            if (pCurrentDisk->SifBusKey == busKey) {
                //
                // This is the SifBusKey we're looking for, so lets write 
                // out the bus type to file.
                //
                swprintf(infstring, L"%lu=%d,%lu\r\n",
                    busKey,
                    ASR_SYSTEM_KEY,
                    pCurrentDisk->BusType
                    );
                _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
                    wcslen(infstring)*sizeof(WCHAR), &size, NULL));

                //
                // We've already covered this SifBusKey, lets move on to the 
                // next.
                //
                ++busKey;
            }

            pCurrentDisk = pCurrentDisk->pNext;
        }
    }

    return TRUE;
}


BOOL
AsrpWriteMbrDisksSection(
    IN CONST HANDLE         SifHandle,       // handle to the state file
    IN CONST PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    Creates the DISKS.MBR section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD  size = 0,
        diskKey = 1;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PASR_DISK_INFO  pCurrentDisk = pDiskList;

    // 
    // Write out the section name: [DISKS.MBR]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_MBR_DISKS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each MBR disk
    // on the list.
    //
        while (pCurrentDisk) {

        if (PARTITION_STYLE_MBR != 
                pCurrentDisk->pDriveLayoutEx->PartitionStyle
            ) {
            //
                    // Skip non-MBR (i.e., GPT) disks.
                    //
            pCurrentDisk = pCurrentDisk->pNext;
            continue;
        }

        pCurrentDisk->SifDiskKey = diskKey;
        swprintf(infstring, L"%lu=%d,%lu,%lu,0x%08x,%lu,%lu,%lu,%I64u\r\n",
            diskKey,
            ASR_SYSTEM_KEY,
            pCurrentDisk->SifBusKey,
            pCurrentDisk->IsCritical,
            pCurrentDisk->pDriveLayoutEx->Mbr.Signature,
            pCurrentDisk->pDiskGeometry->BytesPerSector,
            pCurrentDisk->pDiskGeometry->SectorsPerTrack,
            pCurrentDisk->pDiskGeometry->TracksPerCylinder,
            (ULONG64)(pCurrentDisk->pPartition0Ex->PartitionLength.QuadPart /
                pCurrentDisk->pDiskGeometry->BytesPerSector)
            );
        _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
            wcslen(infstring)*sizeof(WCHAR), &size, NULL));

        ++diskKey;
        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpWriteGptDisksSection(
    IN CONST HANDLE         SifHandle,       // handle to the state file
    IN CONST PASR_DISK_INFO pDiskList
    )

/*++

Routine Description:

    Creates the DISKS.GPT section of the ASR state file, and writes out the
    entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD  size = 0,
        diskKey = 1;

    PWSTR lpGuidString = NULL;

    RPC_STATUS rpcStatus = RPC_S_OK;

    PASR_DISK_INFO  pCurrentDisk = pDiskList;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    // 
    // Write out the section name: [DISKS.GPT]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_GPT_DISKS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each GPT disk
    // on the list.
    //
        while (pCurrentDisk) {

        if (PARTITION_STYLE_GPT != 
                pCurrentDisk->pDriveLayoutEx->PartitionStyle
            ) {
            //
                    // Skip non-GPT (i.e., MBR) disks.
                    //
            pCurrentDisk = pCurrentDisk->pNext;
            continue;
        }

        //
        // Convert the DiskId to a printable string
        //
        rpcStatus = UuidToStringW(
            &pCurrentDisk->pDriveLayoutEx->Gpt.DiskId, 
            &lpGuidString
            );
        if (rpcStatus != RPC_S_OK) {
            if (lpGuidString) {
                RpcStringFreeW(&lpGuidString);
            }
            //
            // The only error from UuidToStringW is RPC_S_OUT_OF_MEMORY
            //
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        pCurrentDisk->SifDiskKey = diskKey;
        swprintf(infstring, L"%lu=%d,%lu,%lu,%ws%ws%ws,%lu,%lu,%lu,%lu,%I64u\r\n", 
            diskKey,
            ASR_SYSTEM_KEY,
            pCurrentDisk->SifBusKey,
            pCurrentDisk->IsCritical,
            (lpGuidString ? L"\"" : L""),
            (lpGuidString ? lpGuidString : L""),
            (lpGuidString ? L"\"" : L""),
            pCurrentDisk->pDriveLayoutEx->Gpt.MaxPartitionCount,
            pCurrentDisk->pDiskGeometry->BytesPerSector,
            pCurrentDisk->pDiskGeometry->SectorsPerTrack,
            pCurrentDisk->pDiskGeometry->TracksPerCylinder,
            (ULONG64) (pCurrentDisk->pPartition0Ex->PartitionLength.QuadPart /
                pCurrentDisk->pDiskGeometry->BytesPerSector)
            );
        _AsrpCheckTrue(WriteFile(SifHandle, infstring, wcslen(infstring)*sizeof(WCHAR), &size, NULL));

        if (lpGuidString) {
            RpcStringFreeW(&lpGuidString);
            lpGuidString = NULL;
        }

        ++diskKey;
        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpWriteMbrPartitionsSection(
    IN CONST HANDLE SifHandle,       // handle to the state file
    IN CONST PASR_DISK_INFO pDiskList,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Creates the PARTITIONS.MBR section of the ASR state file, and writes 
    out the entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

    pSystemInfo - Info about the current system, used to determine the current
            boot and system partitions (and mark them appropriately in 
            asr.sif)

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{

    DWORD size = 0,
        index = 0,
        partitionKey = 1;

    UCHAR fsType = 0;
    
    PWSTR volumeGuid = NULL;

    BOOL writeVolumeGuid = FALSE;

    PASR_DISK_INFO pCurrentDisk = pDiskList;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PPARTITION_INFORMATION_EX currentPartitionEx = NULL;

    //
    // Write out the section name: [PARTITIONS.MBR]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_MBR_PARTITIONS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each partition on
    // each of the MBR disks on the list.
    //
    while (pCurrentDisk) {

        if (pCurrentDisk->pDriveLayoutEx) {

            if (PARTITION_STYLE_MBR != 
                    pCurrentDisk->pDriveLayoutEx->PartitionStyle
                ) {
                //
                // Skip non-MBR (i.e., GPT) disks
                //
                pCurrentDisk = pCurrentDisk->pNext;
                continue;
            }

            //
            // Enumerate partitions on the disk.  We expect to find only 
            // MBR partitions.
            //
            for (index =0; 
                index < pCurrentDisk->pDriveLayoutEx->PartitionCount; 
                index++
                ) {

                currentPartitionEx = 
                    &pCurrentDisk->pDriveLayoutEx->PartitionEntry[index];
                
                MYASSERT(currentPartitionEx->PartitionStyle == 
                    PARTITION_STYLE_MBR);

                if (currentPartitionEx->Mbr.PartitionType == 0) {
                    //
                    // Empty partition table entry.
                    //
                    continue;
                }

                fsType = 
                    pCurrentDisk->PartitionInfoTable[index].FileSystemType;

                volumeGuid = 
                    pCurrentDisk->PartitionInfoTable[index].szVolumeGuid;
                
                //
                // We only want to write out the Volume GUID for basic
                // (recognized) partitions/volumes, since it does not make 
                // sense in the context of LDM or other unknown partition 
                // types which would need special handling from their 
                // respective recovery agents such as asr_ldm in GUI-mode 
                // Setup.
                //
                writeVolumeGuid = (wcslen(volumeGuid) > 0) &&
                    IsRecognizedPartition(currentPartitionEx->Mbr.PartitionType);

                // 
                // Create the entry and write it to file.
                //
                swprintf(
                    infstring,
                    L"%d=%d,%d,%lu,%ws%ws%ws,0x%02x,0x%02x,0x%02x,%I64u,%I64u,0x%x\r\n",
                    partitionKey,
                    pCurrentDisk->SifDiskKey,
                    index,
                    pCurrentDisk->PartitionInfoTable[index].PartitionFlags,
                    (writeVolumeGuid ? L"\"" : L""),
                    (writeVolumeGuid ? volumeGuid : L""),
                    (writeVolumeGuid ? L"\"" : L""),
                    (currentPartitionEx->Mbr.BootIndicator)?0x80:0,
                    currentPartitionEx->Mbr.PartitionType,
                    
                    ((fsType) ? fsType : 
                        currentPartitionEx->Mbr.PartitionType),
                    
                    (ULONG64) ((currentPartitionEx->StartingOffset.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),

                    (ULONG64) ((currentPartitionEx->PartitionLength.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),

                    pCurrentDisk->PartitionInfoTable[index].ClusterSize
                    );

                _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
                    wcslen(infstring)*sizeof(WCHAR), &size, NULL));

                ++partitionKey;
            }
        }

        pCurrentDisk = pCurrentDisk->pNext;
    }
    return TRUE;
}


BOOL
AsrpWriteGptPartitionsSection(
    IN CONST HANDLE SifHandle,
    IN CONST PASR_DISK_INFO pDiskList,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Creates the PARTITIONS.GPT section of the ASR state file, and writes 
    out the entries in that section to file.

Arguments:

    SifHandle - Handle to asr.sif, the ASR state file.

    pDiskList - List of disks present on the current system.

    pSystemInfo - Info about the current system, used to determine the current
            boot and system partitions (and mark them appropriately in 
            asr.sif)

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    DWORD size = 0,
        index  = 0,
        partitionKey = 1;

    UCHAR fsType = 0;

    PWSTR volumeGuid = NULL,
        partitionId  = NULL,
        partitionType = NULL;

    BOOL writeVolumeGuid = FALSE;

    RPC_STATUS rpcStatus = RPC_S_OK;

    PASR_DISK_INFO pCurrentDisk = pDiskList;

    WCHAR infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    PPARTITION_INFORMATION_EX currentPartitionEx = NULL;

    //
    // Write out the section name: [PARTITIONS.GPT]
    //
    swprintf(infstring, L"\r\n%ws\r\n", ASR_SIF_GPT_PARTITIONS_SECTION_NAME);
    _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL));

    //
    // Go through the list of disks, and write one entry for each partition on
    // each of the GPT disks on the list.
    //
    while (pCurrentDisk) {

        if (pCurrentDisk->pDriveLayoutEx) {

            if (PARTITION_STYLE_GPT != 
                    pCurrentDisk->pDriveLayoutEx->PartitionStyle
                ) {
                //
                // Skip non-GPT (i.e., MBR) disks.
                //
                pCurrentDisk = pCurrentDisk->pNext;
                continue;
            }

            //
            // Enumerate partitions on the disk. We expect to find only 
            // GPT partitions.
            //
            for (index =0; 
                index < pCurrentDisk->pDriveLayoutEx->PartitionCount; 
                index++) {

                currentPartitionEx = 
                    &pCurrentDisk->pDriveLayoutEx->PartitionEntry[index];
                
                MYASSERT(currentPartitionEx->PartitionStyle == 
                    PARTITION_STYLE_GPT);

                //
                // Convert the Guids to printable strings
                //
                rpcStatus = UuidToStringW(
                    &currentPartitionEx->Gpt.PartitionType, 
                    &partitionType
                    );
                if (rpcStatus != RPC_S_OK) {
                    
                    if (partitionType) {
                        RpcStringFreeW(&partitionType);
                        partitionType = NULL;
                    }
                    
                    //
                    // The only error from UuidToString is RPC_S_OUT_OF_MEMORY
                    //
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

                rpcStatus = UuidToStringW(
                    &currentPartitionEx->Gpt.PartitionId, 
                    &partitionId
                    );
                if (rpcStatus != RPC_S_OK) {
                    
                    if (partitionType) {
                        RpcStringFreeW(&partitionType);
                        partitionType = NULL;
                    }
                    
                    if (partitionId) {
                        RpcStringFreeW(&partitionId);
                        partitionId = NULL;
                    }

                    //
                    // The only error from UuidToString is RPC_S_OUT_OF_MEMORY
                    //
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }

                fsType = 
                    pCurrentDisk->PartitionInfoTable[index].FileSystemType;

                volumeGuid = 
                    pCurrentDisk->PartitionInfoTable[index].szVolumeGuid;

                //
                // We only want to write out the Volume GUID for basic
                // (recognized) partitions/volumes, since it does not make 
                // sense in the context of LDM or other unknown partition 
                // types which would need special handling from their 
                // respective recovery agents such as asr_ldm in GUI-mode 
                // Setup.
                //
                writeVolumeGuid = (wcslen(volumeGuid) > 0) &&
                    IsEqualGUID(&(partitionType), &(PARTITION_BASIC_DATA_GUID));

                // 
                // Create the entry and write it to file.
                //
                swprintf(
                    infstring,
                    L"%d=%d,%d,%d,%ws%ws%ws,%ws%ws%ws,%ws%ws%ws,0x%I64x,%ws%ws%ws,0x%02x,%I64u,%I64u,0x%x\r\n",

                    partitionKey,
                    pCurrentDisk->SifDiskKey,
                    index,      //slot-index
                    pCurrentDisk->PartitionInfoTable[index].PartitionFlags,

                    (writeVolumeGuid ? L"\"" : L""),
                    (writeVolumeGuid ? volumeGuid : L""),
                    (writeVolumeGuid ? L"\"" : L""),

                    (partitionType ? L"\"" :  L""),
                    (partitionType ? partitionType : L""),
                    (partitionType ? L"\"" :  L""),

                    (partitionId ? L"\"" :  L""),
                    (partitionId ? partitionId : L""),
                    (partitionId ? L"\"" :  L""),

                    currentPartitionEx->Gpt.Attributes,

                    (currentPartitionEx->Gpt.Name ? L"\"" :  L""),
                    (currentPartitionEx->Gpt.Name ? 
                        currentPartitionEx->Gpt.Name : L""),
                    (currentPartitionEx->Gpt.Name ? L"\"" :  L""),

                    //
                    // ISSUE-2000/04/12-guhans: GetVolumeInformation does not 
                    // work on GPT and fstype is always zero
                    //
                    fsType,

                    (ULONG64) ((currentPartitionEx->StartingOffset.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),
                    
                    (ULONG64) ((currentPartitionEx->PartitionLength.QuadPart)/
                        (pCurrentDisk->pDiskGeometry->BytesPerSector)),

                    pCurrentDisk->PartitionInfoTable[index].ClusterSize                    
                    );

                _AsrpCheckTrue(WriteFile(SifHandle, infstring, 
                    wcslen(infstring)*sizeof(WCHAR), &size, NULL));

                if (partitionType) {
                    RpcStringFreeW(&partitionType);
                    partitionType = NULL;
                }
                if (partitionId) {
                    RpcStringFreeW(&partitionId);
                    partitionId = NULL;
                }

                ++partitionKey;
            }
        }

        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpCreateEnvironmentBlock(
    IN  PCWSTR  CriticalVolumeList,
    IN  HANDLE  SifHandle,
    OUT PWSTR   *NewBlock
    )

/*++

Routine Description:

    Creates a new environment block that is passed in to apps launched as part 
    of an ASR backup.  This routine retrieves the current process's 
    environment block, adds the ASR environment variables to it, and creates a
    multi-sz suitable for being passed in as the lpEnvironment parameter of 
    CreateProcess.
    

Arguments:

    CriticalVolumeList - A multi-string containing a list of the volume GUID's
            of each of the critical volumes present on the system.  The GUID's
            must be in the NT name-space, i.e., must be of the form:
            \??\Volume{GUID}

            This multi-sz is used to create the semi-colon separated list of 
            volumes in the "_AsrCriticalVolumeList" variable in NewBlock.

    SifHandle - A (duplicate) handle to asr.sif, the ASR state file.  This is
            used in creating the "_AsrContext" variable in NewBlock.

    NewBlock - Receives the new environment block.  In addition to all the 
            environment variables in the current process environment block, 
            this block contains two additional "ASR" variables:
            _AsrContext=<DWORD_PTR value>
            _AsrCriticalVolumeList=<volumeguid>;<volumeguid>;...;<volumeguid>

            The caller is responsible for freeing this block when it is no
            longer needed, using HeapFree(GetProcessHeap(),...).

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().  (*NewBlock) is set to NULL.

--*/

{
    PCWSTR lpTemp = CriticalVolumeList;

    PWSTR lpCurrentEnvStrings = NULL;

    DWORD cchContextEntry = 0,
        cchEnvBlock = 0,
        cbEnvBlock = 0,
        cbCurrentProcessEnvBlock = 0,
        status = ERROR_SUCCESS;

    HANDLE heapHandle = GetProcessHeap();

    MYASSERT(NewBlock);

    //
    // Find out how much space the environment block will need
    //

    //
    // For _AsrContext=1234 and _AsrCriticalVolumes="..." entries
    //
    lpTemp = CriticalVolumeList;
    if (CriticalVolumeList) {
        while (*lpTemp) {
            lpTemp += (wcslen(lpTemp) + 1);
        }
    }
    cbEnvBlock = (DWORD) ((lpTemp - CriticalVolumeList + 1) * sizeof(WCHAR));
    cbEnvBlock += ASR_CCH_ENVBLOCK_ASR_ENTRIES * sizeof(WCHAR);

    //
    // For all the current environment strings
    //
    lpCurrentEnvStrings = GetEnvironmentStringsW();
    lpTemp = lpCurrentEnvStrings;
    if (lpCurrentEnvStrings ) {
        while (*lpTemp) {
            lpTemp += (wcslen(lpTemp) + 1);
        }
    }
    cbCurrentProcessEnvBlock = (DWORD) ((lpTemp - lpCurrentEnvStrings + 1) * sizeof(WCHAR));
    cbEnvBlock += cbCurrentProcessEnvBlock;

    //
    // And allocate the space
    //
    *NewBlock = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        cbEnvBlock
        );
    _AsrpErrExitCode(!(*NewBlock), status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // First, add the AsrContext=1234 entry in the environment block
    //
    swprintf(
        (*NewBlock),
        ASR_ENVBLOCK_CONTEXT_ENTRY,
        (ULONG64) (SifHandle)
        );
    
    //
    // Keep track of where this entry ends, so we can add a NULL at this
    // index later.
    //
    cchContextEntry = wcslen((*NewBlock));    
    wcscat((*NewBlock), L" "); // this character will be replaced by a NULL later

    //
    // Append each critical volume GUID, separated by a semi-colon.
    //
    wcscat((*NewBlock), ASR_ENVBLOCK_CRITICAL_VOLUME_ENTRY);
    if (CriticalVolumeList) {
        lpTemp = CriticalVolumeList;
        while (*lpTemp) {
            wcscat((*NewBlock), lpTemp);
            wcscat((*NewBlock), L";");
            lpTemp += (wcslen(lpTemp) + 1);
        }
    }
    else {
        wcscat((*NewBlock), L";");
    }

    //
    // Mark the end with two NULL's
    //
    cchEnvBlock = wcslen(*NewBlock) - 1;
//    (*NewBlock)[cchEnvBlock - 1] = L'"';
    (*NewBlock)[cchEnvBlock] = L'\0';

    //
    // Separate the two entries with a NULL
    //
    (*NewBlock)[cchContextEntry] = L'\0';

    //
    // Copy over the current environment strings
    //
    RtlCopyMemory(&(*NewBlock)[cchEnvBlock + 1],
        lpCurrentEnvStrings,
        cbCurrentProcessEnvBlock
        );

EXIT:
    if (lpCurrentEnvStrings) {
        FreeEnvironmentStringsW(lpCurrentEnvStrings);
        lpCurrentEnvStrings = NULL;
    }

    if (ERROR_SUCCESS != status) {
        _AsrpHeapFree((*NewBlock));
    }

    return (BOOL) (ERROR_SUCCESS == status);
}


BOOL
AsrpLaunchRegisteredCommands(
    IN HANDLE SifHandle,
    IN PCWSTR CriticalVolumeList
) 

/*++

Routine Description:

    This launches apps that have registered to be part of an ASR-backup.  The 
    commands are read from the following ASR-Commands key:
    "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Asr\\Commands"

    This key contains a REG_EXPAND_SZ entry for each application to be 
    launched, with the data containing the full command-line to be invoked:
    ApplicationName::REG_EXPAND_SZ::<Command-line with parameters>

    Such as:
    ASR utility::REG_EXPAND_SZ::"%systemroot%\\system32\\asr_fmt.exe /backup"

    When invoking the app, we expand out all the environment variables in the
    command-line.  In addition, we append a "context" parameter to the command
    line, which the app is expected to use in calls to AsrAddSifEntry.  
    The above entry would thus translate something like:

    c:\windows\system32\asr_fmt.exe /backup /context=2000

    The environment block of the process is a duplicate of the current process
    environment block, with one exception--it contains two additional "Asr"
    variables:
    _AsrContext=<DWORD_PTR value>
    _AsrCriticalVolumeList=<volumeguid>;<volumeguid>;...;<volumeguid>

    Each application invoked must complete in the allowed time-out value.  
    The time-out is configurable in the registry, by changing the value of the
    "ProcessTimeOut" value under the ASR key.  We ship with a default of 3600
    seconds, but the sys-admin can change it if needed.  (0=infinite).

Arguments:

    SifHandle - A handle to asr.sif, the ASR state file.  A duplicate of this
            handle is passed in to applications as the "context" parameter,
            and as the "_AsrContext" variable in the environment block.

    CriticalVolumeList - A multi-string containing a list of the volume GUID's
            of each of the critical volumes present on the system.  The GUID's
            must be in the NT name-space, i.e., must be of the form:
            \??\Volume{GUID}

            This multi-sz is used to create the semi-colon separated list of 
            volumes in the "_AsrCriticalVolumeList" variable in the env
            block of the new processes.

            Applications (such as volume-managers) can use this list to 
            determine if they manage any critical volumes, and make a note of
            it in the asr.sif.  This way, they can intelligently decide to
            abort the ASR restore process if needed.

Return Value:

    If the function succeeds, the return value is a nonzero value.  This 
            implies that all the applications invoked were successful (i.e.,
            returned an exit code of 0).

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

    Note that if any of the applications returned an exit code other than 0, 
            we interpret that as a fatal error, and will return an error.

--*/

{
    HKEY    regKey          = NULL;

    DWORD   status          = ERROR_SUCCESS,
            waitResult      = WAIT_ABANDONED,

            lpcValues       = 0L,
            index           = 0L,

            cbData          = 0L,
            cbMaxDataLen    = 0L,

            cchValueName    = 0L,
            cchMaxValueLen  = 0L,

            cbCommand       = 0L,
            cchReqd         = 0L,

            timeLeft        = 0L,
            maxTimeOutValue = 0L;

    HANDLE  heapHandle      = NULL,
            processHandle   = NULL,
            dupSifHandle    = NULL;

    PWSTR   valueName       = NULL,
            data            = NULL,
            command         = NULL,
            lpEnvBlock      = NULL;

    WCHAR   cmdLineSuffix[ASR_COMMANDLINE_SUFFIX_LEN + 1];

    BOOL    result          = FALSE;

    STARTUPINFOW        startUpInfo;

    PROCESS_INFORMATION processInfo;

    heapHandle      = GetProcessHeap();
    processHandle   = GetCurrentProcess();
    MYASSERT(heapHandle && processHandle);

    ZeroMemory(cmdLineSuffix, (ASR_COMMANDLINE_SUFFIX_LEN + 1) * sizeof(WCHAR));
    ZeroMemory(&startUpInfo, sizeof(STARTUPINFOW));
    ZeroMemory(&processInfo, sizeof(PROCESS_INFORMATION));

    //
    // Get the time out value for processes, if set in the registry
    // If the key is missing, or is set to "0", the timeout is set
    // to INFINITE.
    //
    status = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, // hKey
        ASR_REGKEY_ASR,         // lpSubKey
        0,                  // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,    // samDesired
        &regKey             // phkResult
        );

    if ((regKey) && (ERROR_SUCCESS == status)) {
        DWORD type = 0L,
            timeOut = 0L,
            cbTimeOut = (sizeof(DWORD));

        status = RegQueryValueExW(
            regKey,     // hKey
            ASR_REGVALUE_TIMEOUT,   // lpValueName
            NULL,       // lpReserved
            &type,      // lpType
            (LPBYTE) &timeOut,      // lpData
            &cbTimeOut  // lpcbData
            );
            
        if ((ERROR_SUCCESS == status) && (REG_DWORD == type)) {
            maxTimeOutValue = timeOut;
        }
    }

    if (regKey) {
        RegCloseKey(regKey);
        regKey = NULL;
    }

    //
    //  Open and enumerate the entries in the ASR command key. If
    //  the key doesn't exist, we don't have to execute anything
    //
    status = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,  // hKey
        ASR_REGKEY_ASR_COMMANDS, // lpSubKey
        0,                   // ulOptions--Reserved, must be 0
        MAXIMUM_ALLOWED,     // samDesired
        &regKey              // phkResult
        );

    if ((!regKey) || (ERROR_SUCCESS != status)) {
        return TRUE;
    }

    //
    // Get the max ValueName and Data entries, and
    // allocate memory for them
    //
    status = RegQueryInfoKey(
        regKey,
        NULL,       // class
        NULL,       // lpcClass
        NULL,       // lpReserved
        NULL,       // lpcSubKeys
        NULL,       // lpcMaxSubKeyLen
        NULL,       // lpcMaxClassLen,
        &lpcValues, // number of values
        &cchMaxValueLen,    // max value length, in cch
        &cbMaxDataLen,      // max data length, in cb
        NULL,       // lpcbSecurityDescriptor
        NULL        // lpftLastWriteTime
        );
    _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);
    _AsrpErrExitCode((0 == lpcValues), status, ERROR_SUCCESS);  // Key is empty, we're done

    valueName = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (cchMaxValueLen + 1) * sizeof (WCHAR)   // cch not cb
        );
    _AsrpErrExitCode(!valueName, status, ERROR_NOT_ENOUGH_MEMORY);

    data = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        cbMaxDataLen + ((ASR_COMMANDLINE_SUFFIX_LEN + 2) * sizeof(WCHAR))
        );
    _AsrpErrExitCode(!data, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // "command" will contain the full command string, after any environment
    // variables (eg %systemroot%) in "data" have been expanded.  We'll start
    // off with "command" being MAX_PATH characters longer than "data", and
    // we'll re-allocate a bigger buffer if/when needed
    //
    cbCommand = cbMaxDataLen + 
        ((ASR_COMMANDLINE_SUFFIX_LEN + MAX_PATH + 2) * sizeof(WCHAR));

    command = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        cbCommand
        );
    _AsrpErrExitCode(!command, status, ERROR_NOT_ENOUGH_MEMORY);

    do {
        cchValueName = cchMaxValueLen + 1;
        cbData       = cbMaxDataLen + sizeof(WCHAR);

        //
        // Enumerate the commands, and execute them one after the other
        //
        status = RegEnumValueW(
            regKey,         // hKey
            index++,        // dwIndex
            valueName,      // lpValueName
            &cchValueName,  // lpcValueName
            NULL,           // lpReserved
            NULL,           // lpType
            (LPBYTE)data,   // lpData
            &cbData         // lpcbData
            );
        _AsrpErrExitCode((ERROR_NO_MORE_ITEMS == status), 
            status, 
            ERROR_SUCCESS
            );   // done with enum
        _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);

        //
        // Create a copy of the sif handle to pass to the app launched.
        // We clean-up close the handle after the app is done.
        //
        result = DuplicateHandle(
            processHandle,
            SifHandle,
            processHandle,
            &dupSifHandle,
            0L,
            TRUE,
            DUPLICATE_SAME_ACCESS
            );
        _AsrpErrExitCode((!result), status, GetLastError());

        //
        // Append the "/context=<duplicate-sif-handle>" to
        // the command line
        //
        swprintf(cmdLineSuffix, 
            ASR_COMMANDLINE_SUFFIX, 
            (ULONG64)(dupSifHandle)
            );
        wcscat(data, cmdLineSuffix);

        //
        // Expand any environment strings in the command line
        //
        cchReqd = ExpandEnvironmentStringsW(data, 
            command, 
            (cbCommand / sizeof(WCHAR))
            );
        _AsrpErrExitCode((!cchReqd), status, GetLastError());

        if ((cchReqd * sizeof(WCHAR)) > cbCommand) {
            //
            // Our "command" buffer wasn't big enough, re-allocate as needed
            //
            _AsrpHeapFree(command);
            cbCommand = ((cchReqd + 1) * sizeof(WCHAR));

            command = HeapAlloc(heapHandle, HEAP_ZERO_MEMORY, cbCommand);
            _AsrpErrExitCode(!command, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            // Try expanding the env strings again ...
            //
            cchReqd = ExpandEnvironmentStringsW(data, 
                command, 
                (cbCommand / sizeof(WCHAR))
                );
            _AsrpErrExitCode(
                ((!cchReqd) || (cchReqd * sizeof(WCHAR)) > cbCommand),
                status, 
                GetLastError()
                );
        }

        //
        // Create the environment block to be passed to the
        // process being launched.  The environment block
        // contains the entries:
        // _AsrCriticalVolumes=\??\Volume{Guid1};\??\Volume{Guid2}
        // _AsrContext=<duplicate-sif-handle>
        //
        // in addition to all the environment strings in the current process.
        //
        result = AsrpCreateEnvironmentBlock(CriticalVolumeList, 
            dupSifHandle, 
            &lpEnvBlock
            );
        _AsrpErrExitCode((!result), status, GetLastError());

        //
        // Execute the command as a separate process
        //
        memset(&startUpInfo, 0L, sizeof (startUpInfo));
        result = CreateProcessW(
            NULL,           // lpApplicationName
            command,        // lpCommandLine
            NULL,           // lpProcessAttributes
            NULL,           // lpThreadAttributes
            TRUE,           // bInheritHandles
            CREATE_UNICODE_ENVIRONMENT, // dwCreationFlags
            lpEnvBlock,           // new environment block
            NULL,           // current directory name (null=current dir)
            &startUpInfo,   // statup information
            &processInfo    // process information
            );
        _AsrpErrExitCode((!result), 
            status, 
            GetLastError()
            );    // process couldn't be launched

        //
        // Process was launched: start the timer countdown if a maximum 
        // timeout was specified in the registry.  Loop till either the 
        // process completes, or the timer expires
        //
        timeLeft = maxTimeOutValue; 
        if (timeLeft) {
            do {
                waitResult = WaitForSingleObject(processInfo.hProcess, 1000);   // 1000 ms = 1 sec
                --timeLeft;
            } while ((WAIT_TIMEOUT == waitResult) && (timeLeft));

            if (!timeLeft) {
                //
                // The process did not terminate in the allowed time. We treat 
                // this as a fatal error--terminate the process, and set its
                // error code to ERROR_TIMEOUT
                //
                TerminateProcess(processInfo.hProcess, ERROR_TIMEOUT);
            }
        }
        else {
            //
            // No timeout was specified in the registry, wait for process to
            // complete.
            //
            waitResult = WaitForSingleObject(processInfo.hProcess, INFINITE);

        }

        //
        // Check if the wait failed above.  If last error is something useful,
        // we don't want to destroy it--if it's ERROR_SUCCESS, we'll set it to
        // ERROR_TIMEOUT
        //
        status = GetLastError();
        _AsrpErrExitCode((WAIT_OBJECT_0!=waitResult), status, 
            (ERROR_SUCCESS == status ? ERROR_TIMEOUT : status));    // wait failed above

        //
        // Get the process's exit code: if it doesn't return ERROR_SUCCESS,
        // we exit the loop, set the last error to the error returned,
        // and return FALSE
        //
        GetExitCodeProcess(processInfo.hProcess, &status);
        _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);

        _AsrpCloseHandle(dupSifHandle);
        _AsrpHeapFree(lpEnvBlock);
    
    } while (ERROR_SUCCESS == status);


EXIT:
    //
    // Clean-up
    //
    if (regKey) {
        RegCloseKey(regKey);
        regKey = NULL;
    }
    
    _AsrpCloseHandle(dupSifHandle);
    _AsrpHeapFree(valueName);
    _AsrpHeapFree(data);
    _AsrpHeapFree(command);
    _AsrpHeapFree(lpEnvBlock);
    
    if (ERROR_SUCCESS != status) {
        SetLastError(status);
        return FALSE;
    }
    else {
        return TRUE;
    }
}


BOOL
AsrpIsSupportedConfiguration(
    IN CONST PASR_DISK_INFO   pDiskList,
    IN CONST PASR_SYSTEM_INFO pSystemInfo
    )

/*++

Routine Description:

    Checks if ASR backup can be performed on the system.  We do not support
    systems that have:
    -  PROCESSOR_ARCHITECTURE other than "x86", "amd64", or "ia64"
    -  any FT volumes present anywhere on the system

Arguments:

    pDiskList - The list of disks on the system.

    pSystemInfo - System information for this system.

Return Value:

    If we support this ASR configuration, the return value is non-zero.

    If this configuration is not supported, the return value is zero. 
            GetLastError() will return ERROR_NOT_SUPPORTED.

--*/

{

    PASR_DISK_INFO  pCurrentDisk         = pDiskList;
    ULONG           index;

    // 
    // 1. platform must be x86, amd64, or ia64
    //
    if (wcscmp(pSystemInfo->Platform, ASR_PLATFORM_X86) &&
        wcscmp(pSystemInfo->Platform, ASR_PLATFORM_AMD64) &&
        wcscmp(pSystemInfo->Platform, ASR_PLATFORM_IA64)) {

        SetLastError(ERROR_NOT_SUPPORTED);
        return FALSE;
    }

    // 
    // 2. System cannot any FT volumes.  All mirrors, stripes and so on are
    // expected to be LDM volumes on dynamic disks.
    //
    while (pCurrentDisk) {

        if (!(pCurrentDisk->pDriveLayoutEx) || !(pCurrentDisk->pDiskGeometry)) {
            MYASSERT(0);
            pCurrentDisk = pCurrentDisk->pNext;
            continue;
        }

        if (pCurrentDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_MBR) {

            for (index =0; index < pCurrentDisk->pDriveLayoutEx->PartitionCount; index++) {

                MYASSERT(pCurrentDisk->pDriveLayoutEx->PartitionEntry[index].PartitionStyle == PARTITION_STYLE_MBR);

                if (IsFTPartition(pCurrentDisk->pDriveLayoutEx->PartitionEntry[index].Mbr.PartitionType)) {

                    SetLastError(ERROR_NOT_SUPPORTED);
                    return FALSE;
                }

            }
        }
        else if (pCurrentDisk->pDriveLayoutEx->PartitionStyle == PARTITION_STYLE_GPT) {
            //
            // GPT disks can't have FT Mirrors.
            //
        }

        pCurrentDisk = pCurrentDisk->pNext;
    }

    return TRUE;
}



//
// -----
// The following routines are helpers for AsrAddSifEntry
// -----
//

BOOL
AsrpSifCheckSectionNameSyntax(
    IN  PCWSTR  lpSectionName
    )

/*++

Routine Description:

    Performs some basic validation of lpSectionName to make sure that
    it conforms to the expected format for a section header

Arguments:
    
    lpSectionName - The null-terminated string to be checked.

Return Value:

    If lpSectionName appears to be a valid section name, the return value is a
            nonzero value.

    If lpSectionName does not pass our basic validation, the return value is 
            zero.  Note that GetLastError will NOT return additional error
            information in this case.

--*/

{
    UINT    i   = 0;
    WCHAR   wch = 0;

    // 
    // Must be non-null
    //
    if (!lpSectionName) {
        return FALSE;
    }

    // 
    // Must have atleast 3 chars, ([.]) and at most ASR_SIF_ENTRY_MAX_CHARS 
    // chars
    //
    if ((ASR_SIF_ENTRY_MAX_CHARS < wcslen(lpSectionName)) ||
        3 > wcslen(lpSectionName)) {
        return FALSE;
    }

    // 
    // First char must be [, and last char must be ].
    //
    if (L'[' != lpSectionName[0]                     ||
        L']' != lpSectionName[wcslen(lpSectionName)-1]) {
        return FALSE;
    }

    // 
    // Check for illegal characters.  Legal set of chars: A-Z a-z . _
    //
    for (i = 1; i < wcslen(lpSectionName)-1; i++) {

        wch = lpSectionName[i];
        if ((wch < L'A' || wch > 'Z') &&
            (wch < L'a' || wch > 'z') &&
            (wch < L'0' || wch > '9') &&
            (wch != L'.') &&
            (wch != '_')) {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
AsrpSifCheckCommandsEntrySyntax(
    PCWSTR  pwszEntry
    )

/*++

Routine Description:

    Performs some basic validation of pwszEntry to make sure that it conforms 
    to the expected entry format for the Commands section

Arguments:
    
    pwszEntry - The null-terminated string to be checked.

Return Value:

    If pwszEntry appears to be a valid section name, the return value is a
            nonzero value.

    If pwszEntry does not pass our basic validation, the return value is 
            zero.  Note that GetLastError will NOT return additional error
            information in this case.

--*/

{
    BOOL fValid = FALSE;

    if (!pwszEntry) {
        return TRUE;    // NULL is okay
    }

    //
    // COMMANDS section entry format:
    // system-key,sequence-number,action-on-completion,"command","parameters"
    // system-key must be 1
    // 1000 <= sequence-number <= 4999
    // 0 <= action-on-completion <= 1
    // command:     no syntax check
    // parameters:  no syntax check
    //
    fValid = (
        // must be atleast 10 chars (1,0000,0,c)
        10    <= wcslen(pwszEntry) &&

        // system-key must be 1
        L'1' == pwszEntry[0] &&
        L',' == pwszEntry[1] &&

        // 1000 <= sequence-number <= 4999
        L'1' <= pwszEntry[2] &&
        L'4' >= pwszEntry[2] &&

        L'0' <= pwszEntry[3] &&
        L'9' >= pwszEntry[3] &&

        L'0' <= pwszEntry[4] &&
        L'9' >= pwszEntry[4] &&

        L'0' <= pwszEntry[5] &&
        L'9' >= pwszEntry[5] &&

        L',' == pwszEntry[6] &&

        // action-on-completion = [0|1]
        L'0' <= pwszEntry[7] &&
        L'1' >= pwszEntry[7]
        );

    return fValid;
}


INT
AsrpSkipMatchingQuotes(
    IN PCWSTR pwszEntry,
    IN const INT StartingOffset
    ) 

/*++

Routine Description:

    Checks if this entry starts with a quote.  If it does, it finds the ending
    quote, and returns the index of the char after the ending quote (usually 
    is a comma).

Arguments:

    pwszEntry - The null-terminated string to check.

    StartingOffset - The index of the starting-quote in pwszEntry.

Return Value:

    If the character at StartingOffset is a quote, this returns the index of
            the character after the next quote (the matching end-quote) in the
            string.  If a matching end-quote is not found, it returns -1.

    If the character at StartingOffset is not a quote, this returns
            StartingOffset.

    Essentially, this returns the position where we expect the next comma in 
            the sif entry to be.
    
--*/

{
    INT offset = StartingOffset;

    if (pwszEntry[offset] == L'"') {
        // 
        // Find the ending quote and make sure we don't go out of bounds.
        //
        while ( (pwszEntry[++offset]) &&
                (pwszEntry[offset] != L'\"')) {
            ;
        }

        if (!pwszEntry[offset]) {
            //
            // We didn't find the closing quotes--we went out of bounds
            //
            offset = -1;
        }
        else {
            //
            // Found closing quote
            //
            offset++;
        }
    }

    return offset;
}


BOOL
AsrpSifCheckInstallFilesEntrySyntax(
    IN PCWSTR   pwszEntry,
    OUT PINT    DestinationFilePathIndex OPTIONAL
    )

/*++

Routine Description:

    Performs some basic validation of pwszEntry to make sure that it conforms 
    to the expected entry format for the InstallFiles section

Arguments:
    
    pwszEntry - The null-terminated string to be checked.

    DestinationFilePathIndex - This receives the index at which the 
            destination-file-path field in the sif entry (pwszEntry) begins.

            This is an optional parameter.

Return Value:

    If pwszEntry appears to be a valid section name, the return value is a
            nonzero value.

    If pwszEntry does not pass our basic validation, the return value is 
            zero.  Note that GetLastError will NOT return additional error
            information in this case.

--*/

{

    INT offset = 0;

    if (ARGUMENT_PRESENT(DestinationFilePathIndex)) {
        *DestinationFilePathIndex = 0;
    }

    // 
    // NULL is okay
    //
    if (!pwszEntry) {
        return TRUE;
    }

    // 
    // INSTALLFILES section entry format:
    // system-key,source-media-label,source-device,
    //    source-file-path,destination-file-path,vendor-name,flags
    //
    // system-key must be 1
    //
    // must be atleast 10 chars (1,m,d,p,,v)
    //
    if (wcslen(pwszEntry) < 10) {
        return FALSE;
    }

    // 
    // system-key must be 1
    //
    if (L'1' != pwszEntry[0] || L',' != pwszEntry[1] || L'"' != pwszEntry[2]) {
        return FALSE;
    }

    offset = 2;

    //
    // source-media-label
    //
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // source-device
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // source-file-path, must be enclosed in quotes.
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // destination-file-path, must be enclosed in quotes.
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    if (ARGUMENT_PRESENT(DestinationFilePathIndex)) {
        *DestinationFilePathIndex = offset;
    }

    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if ((offset < 0) || L',' != pwszEntry[offset]) {
        return FALSE;
    }

    //
    // vendor-name, must be enclosed in quotes.
    //
    if (L'"' != pwszEntry[++offset]) {
        return FALSE;
    }
    offset = AsrpSkipMatchingQuotes(pwszEntry, offset);
    if (offset < 0) {
        return FALSE;
    }

    return TRUE;
}


BOOL
AsrpIsRunningOnPersonalSKU(
    VOID
    )

/*++
Routine Description:

    This function checks the system to see if we are running on the personal 
    version of the operating system.

    The personal version is denoted by the product id equal to WINNT, which is
    really workstation, and the product suite containing the personal suite 
    string.

    This is lifted from "IsRunningOnPersonal" by WesW.

Arguments:

    None.

Return Value:

    TRUE if we are running on personal, FALSE otherwise.

--*/

{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    return VerifyVersionInfo(&OsVer,
        VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask
        );
}


BOOL 
AsrpIsInGroup(
    IN CONST DWORD dwGroup
    )
/*++
Routine Description:

    This function checks to see if the specified SID is enabled
    in the primary access token for the current thread.

    This is based on a similar function in dmadmin.exe.

Arguments:

    dwGroup - The SID to be checked for

Return Value:

    TRUE if the specified SID is enabled, FALSE otherwise.

--*/
{

    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    
    PSID sidGroup = NULL;
        
    BOOL bResult = FALSE,
        bIsInGroup = TRUE;

    //
    //  Build the SID for the Administrators group
    //
        bResult = AllocateAndInitializeSid(&sidAuth, 
        2, 
        SECURITY_BUILTIN_DOMAIN_RID,
        dwGroup, 
        0, 
        0, 
        0, 
        0, 
        0, 
        0, 
        &sidGroup
        );
    if (!bResult) {
        return FALSE;
    }
                
        // 
    // Check the current thread token membership
    //
    bResult = CheckTokenMembership(NULL, sidGroup, &bIsInGroup);

    FreeSid(sidGroup);

    return (bResult && bIsInGroup);
}


BOOL
AsrpHasPrivilege(
    CONST PCWSTR szPrivilege
    )
/*++
Routine Description:

    This function checks to see if the specified privilege is enabled
    in the primary access token for the current thread.

    This is based on a similar function in dmadmin.exe.

Arguments:

    szPrivilege - The privilege to be checked for

Return Value:

    TRUE if the specified privilege is enabled, FALSE otherwise.

--*/
{
    LUID luidValue;     // LUID (locally unique ID) for the privilege

    BOOL bResult = FALSE, 
        bHasPrivilege = FALSE;

    HANDLE  hToken = NULL;
    
    PRIVILEGE_SET privilegeSet;

    //
    // Get the LUID for the privilege from the privilege name
    //
    bResult = LookupPrivilegeValue(
        NULL, 
        szPrivilege, 
        &luidValue
        );
    if (!bResult) {
        return FALSE;
    }

    //
    // We want to use the token for the current process
    //
    bResult = OpenProcessToken(GetCurrentProcess(),
        MAXIMUM_ALLOWED,
        &hToken
        );
    if (!bResult) {
        return FALSE;
    }

    //
    // And check for the privilege
    //
        privilegeSet.PrivilegeCount = 1;
        privilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
        privilegeSet.Privilege[0].Luid = luidValue;
        privilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
        
        bResult = PrivilegeCheck(hToken, &privilegeSet, &bHasPrivilege);

    CloseHandle(hToken);

    return (bResult && bHasPrivilege);
}



BOOL
AsrpCheckBackupPrivilege(
    VOID
    )
/*++
Routine Description:

    This function checks to see if the current process has the
    SE_BACKUP_NAME privilege enabled.

    This is based on a similar function in dmadmin.exe.

Arguments:

    None.

Return Value:

    TRUE if the SE_BACKUP_NAME privilege is enabled, FALSE otherwise.

--*/
{

    BOOL bHasPrivilege = FALSE;

    bHasPrivilege = AsrpHasPrivilege(SE_BACKUP_NAME);

/*
    //
    // Don't give up yet--check for the local administrator rights
    //
    if (!bHasPrivilege) {
        bHasPrivilege = AsrpIsInGroup(DOMAIN_ALIAS_RID_ADMINS);
    }
*/

    if (!bHasPrivilege) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
    }

    return bHasPrivilege;
}




//
// -------------------
// Public functions 
// -------------------
//
//  The functions below are for use by external backup and 
//  restore applications supporting ASR. 
//


//
//  ---- AsrCreateStateFile
//
BOOL
AsrCreateStateFileW(
    IN  PCWSTR      lpFilePath          OPTIONAL,
    IN  PCWSTR      lpProviderName      OPTIONAL,
    IN  CONST BOOL  bEnableAutoExtend,
    IN  PCWSTR      mszCriticalVolumes,
    OUT DWORD_PTR   *lpAsrContext
    )

/*--

Routine Description:

    AsrCreateStateFile creates an ASR state file with basic information about 
    the system, and launches third-party applications that have been 
    registered to be run as part of an ASR backup.

Arguments:

    lpFileName - Pointer to a null-terminated string that specifies the 
            full path where the ASR state-file is to be created.  If a file 
            already exists at the location pointed to by this parameter, it is
            over-written.

            This parameter can be NULL.  If it is NULL, the ASR state-file is 
            created at the default location (%systemroot%\repair\asr.sif). 

    lpProviderName - Pointer to a null-terminated string that specifies the 
            full name and version of the backup-and-restore application 
            calling AsrCreateStateFile.  There is a string size limit of 
            (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING) characters 
            for this parameter. 

            This parameter can be NULL.  If it is NULL, a "Provider=" entry is
            not created in the Version section of the ASR state file.

    bEnableAutoExtend - Indicates whether partitions are to be auto-extended 
            during an ASR restore.  If this parameter is TRUE, partitions will be 
            auto-extended during the ASR restore.  If this is FALSE, 
            partitions will not be extended.

    lpCriticalVolumes - Pointer to a multi-string containing volume-GUIDs for
            the critical volumes.  This list is used to obtain the list of 
            critical disks in the system that must be restored for a 
            successful ASR.

            The volume-GUID's must be in the NT-namespace, of the form
            \??\Volume{Guid}

            This parameter cannot be NULL.  

    lpAsrContext - Pointer to a variable receiving an ASR context. The 
            context returned should be used in calls to the other ASR API, 
            including AsrAddSifEntry.  The calling application must call 
            AsrFreeContext to free this context when it is no longer needed.

            This parameter cannot be NULL.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/

{
    BOOL    result          = FALSE;

    DWORD   status          = ERROR_SUCCESS,
            size            = 0;
    
    ULONG   maxDeviceNumber = 0;

    HANDLE  sifhandle       = NULL,
            heapHandle      = NULL;

    PWSTR   asrSifPath      = NULL,
            pnpSifPath      = NULL,
            tempPointer     = NULL;

    UINT    cchAsrSifPath = 0;

    char    UnicodeFlag[3];

    WCHAR   infstring[ASR_SIF_ENTRY_MAX_CHARS + 1];

    SECURITY_ATTRIBUTES saSecurityAttributes;
    SECURITY_DESCRIPTOR sdSecurityDescriptor;

    ASR_SYSTEM_INFO         SystemInfo;
    PASR_DISK_INFO          OriginalDiskList = NULL;

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    //
    // Check the IN parameters:
    //
#ifdef PRERELEASE
    //
    // Don't enforce "CriticalVolumes must be non-NULL" for test
    //
    if (!(lpAsrContext)) 
#else 
    if (!(lpAsrContext && mszCriticalVolumes)) 
#endif
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Set the OUT paramaters to known error values
    //
    *lpAsrContext = 0;

    // 
    // Guard ourselves against returning ERROR_SUCCESS if we encountered
    // an unexpected error.  We should never actually return this, since
    // we always SetLastError whereever we return FALSE from.
    //
    SetLastError(ERROR_CAN_NOT_COMPLETE); 

    //
    // Zero out structs
    //
    memset(&SystemInfo, 0L, sizeof (SYSTEM_INFO));

    heapHandle = GetProcessHeap();

    //
    // Determine the file-path.  If lpFilePath is provided, copy it over to 
    // locally allocated memory and use it, else use the default path.
    //
    if (ARGUMENT_PRESENT(lpFilePath)) {
        cchAsrSifPath = wcslen(lpFilePath);
        //
        // Do a sanity check:  we don't want to allow a file path
        // more than 4096 characters long.
        //
        if (cchAsrSifPath > ASR_SIF_ENTRY_MAX_CHARS) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        asrSifPath = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            ((cchAsrSifPath + 1) * sizeof(WCHAR))
            );
        _AsrpErrExitCode(!asrSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

        wcsncpy(asrSifPath, lpFilePath, cchAsrSifPath);

    }
    else {
        //
        // lpFilePath is NULL, form the default path (of the form
        // \\?\c:\windows\repair\asr.sif)
        //

        //
        // Try with a reasonably sized buffer to begin with.
        //
        asrSifPath = AsrpExpandEnvStrings(ASR_DEFAULT_SIF_PATH);
        _AsrpErrExitCode(!asrSifPath, status, ERROR_BAD_ENVIRONMENT);

        //
        // Set cchAsrSifPath to the size of the asrSif buffer, since we 
        // use this in determining the size of the pnpSif buffer below.
        //
        cchAsrSifPath = wcslen(asrSifPath);
    }

    //
    // Determine the file-path of the asrpnp.sif file, based on the location
    // of the asr.sif file.
    //
    pnpSifPath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        ((cchAsrSifPath + 1 + wcslen(ASRPNP_DEFAULT_SIF_NAME))* sizeof(WCHAR))
        );
    _AsrpErrExitCode(!pnpSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

    wcscpy(pnpSifPath, asrSifPath);

    tempPointer = pnpSifPath;
    while (*tempPointer) {
        tempPointer++;
    }
    while ((*tempPointer != L'\\') 
        && (*tempPointer != L':') 
        && (tempPointer >= pnpSifPath)
        ) {
        tempPointer--;
    }
    tempPointer++;
    wcscpy(tempPointer, ASRPNP_DEFAULT_SIF_NAME);

    //
    // We need to make the handle to asr.sif inheritable, since it will
    // be passed (in the guise of the "AsrContext") to apps that have 
    // registered to be run as part of ASR.
    //
    ZeroMemory(&sdSecurityDescriptor, sizeof(SECURITY_DESCRIPTOR));

    saSecurityAttributes.nLength              = sizeof (saSecurityAttributes);
    saSecurityAttributes.lpSecurityDescriptor = &sdSecurityDescriptor;
    saSecurityAttributes.bInheritHandle       = TRUE;

    if (!AsrpConstructSecurityAttributes(&saSecurityAttributes, esatFile, TRUE)) {
        _AsrpErrExitCode(TRUE, status, GetLastError());
    }

    //
    // Create the file. The handle will be closed by the calling backup-app.
    //
    sifhandle = CreateFileW(
        asrSifPath,                     // lpFileName
        GENERIC_WRITE | GENERIC_READ,   // dwDesiredAccess
        FILE_SHARE_READ,                // dwShareMode
        &saSecurityAttributes,          // lpSecurityAttributes
        CREATE_ALWAYS,                  // dwCreationFlags
        FILE_FLAG_BACKUP_SEMANTICS,     // dwFlagsAndAttributes
        NULL                            // hTemplateFile
        );
    if (!sifhandle || INVALID_HANDLE_VALUE == sifhandle) {
        // 
        // LastError is set by CreateFile
        //
        _AsrpErrExitCode(TRUE, status, GetLastError());
    }
    
    //
    // File was successfully created.  Add the unicode flag at the beginning
    // of the file, followed by comments.
    //
    sprintf(UnicodeFlag, "%c%c", 0xFF, 0xFE);
    result = WriteFile(sifhandle, UnicodeFlag, 
        strlen(UnicodeFlag)*sizeof(char), &size, NULL);
    _AsrpErrExitCode(!result, status, GetLastError());

    wcscpy(infstring, 
        L";\r\n; Microsoft Windows Automated System Recovery State Information File\r\n;\r\n");
    result = WriteFile(sifhandle, infstring, 
        wcslen(infstring)*sizeof(WCHAR), &size, NULL);
    _AsrpErrExitCode(!result, status, GetLastError());

    //
    // Beyond this point, we must zero out asr.sif on any failure.  Also, if 
    // there's any failure, we must be careful not to make further system 
    // calls that could change the error returned by GetLastError().
    //

    //
    // Since the function return values below are and-ed, if any of the calls 
    // fails, we won't execute the ones following it.
    //
    result = (
        //
        // Initialise the global structures
        //
        AsrpInitSystemInformation(&SystemInfo, bEnableAutoExtend)
        
        && AsrpInitDiskInformation(&OriginalDiskList)
        
        && AsrpInitLayoutInformation(&SystemInfo, 
            OriginalDiskList, 
            &maxDeviceNumber, 
            TRUE,
            FALSE
            )

        && AsrpInitClusterSharedDisks(OriginalDiskList)

        && AsrpFreeNonFixedMedia(&OriginalDiskList)

        && AsrpMarkCriticalDisks(OriginalDiskList, 
            mszCriticalVolumes, 
            maxDeviceNumber
            )

        //
        // Check if the system configuration is supported
        //
        && AsrpIsSupportedConfiguration(OriginalDiskList, &SystemInfo)

        //
        // Write the required sections to asr.sif
        //
        && AsrpWriteVersionSection(sifhandle, lpProviderName)
        && AsrpWriteSystemsSection(sifhandle, &SystemInfo)
        && AsrpWriteBusesSection(sifhandle, OriginalDiskList)
        && AsrpWriteMbrDisksSection(sifhandle, OriginalDiskList)
        && AsrpWriteGptDisksSection(sifhandle, OriginalDiskList)

        && AsrpWriteMbrPartitionsSection(sifhandle, 
            OriginalDiskList, 
            &SystemInfo
            )

        && AsrpWriteGptPartitionsSection(sifhandle, 
            OriginalDiskList, 
            &SystemInfo
            )

        && FlushFileBuffers(sifhandle)

        //
        // Create asrpnp.sif, containing entries needed to recover the PnP 
        // entries in the registry
        //
        && AsrCreatePnpStateFileW(pnpSifPath)

        );

    if (result) {
        // everything above succeeded

        //
        // Launch the apps registered to be run as part of ASR-backup.  If any
        // of these apps don't complete successfully, we'll fail the ASR-
        // backup.
        //
        result = (
            AsrpLaunchRegisteredCommands(sifhandle, mszCriticalVolumes)

            && FlushFileBuffers(sifhandle)
            );
            
    }

    if (!result) {
        //
        // One of the functions above failed--we'll make asr.sif zero-length
        // and return the error. CreateFileW or CloseHandle might over-write
        // the LastError, so we save our error now and set it at the end.
        //
        status = GetLastError();

#ifndef PRERELEASE

        //
        // On release versions, we  wipe out the asr.sif if we hit an error, 
        // so that the user doesn't unknowingly end up with an incomplete 
        // asr.sif
        //
        // We don't want to delete the incomplete asr.sif during test cycles,
        // though, since the sif may be useful for debugging.  
        //
        _AsrpCloseHandle(sifhandle);

        //
        // Delete asr.sif and create it again, so that we have a zero-length 
        // asr.sif
        //
        DeleteFileW(asrSifPath);
/*        sifhandle = CreateFileW(
            asrSifPath,             // lpFileName
            GENERIC_WRITE,          // dwDesiredAccess
            0,                      // dwShareMode
            &securityAttributes,    // lpSecurityAttributes
            CREATE_ALWAYS,          // dwCreationFlags
            FILE_ATTRIBUTE_NORMAL,  // dwFlagsAndAttributes
            NULL                    // hTemplateFile
            );

        _AsrpCloseHandle(sifhandle);
*/
#endif
        SetLastError(status);
    }


EXIT:
    //
    // Clean up
    //
    _AsrpHeapFree(asrSifPath);
    _AsrpHeapFree(pnpSifPath);

    AsrpCleanupSecurityAttributes(&saSecurityAttributes);
    AsrpFreeStateInformation(&OriginalDiskList, &SystemInfo);


    //
    // Set the OUT parameters
    //
    *lpAsrContext = (DWORD_PTR)sifhandle;
    
    if (ERROR_SUCCESS != status) {
        SetLastError(status);
    }

    if (!result) {
        if (ERROR_SUCCESS == GetLastError()) {
            //
            // We're going to return failure, but we haven't set the LastError to 
            // a failure code.  This is bad, since we have no clue what went wrong.
            //
            // We shouldn't ever get here, because the function returning FALSE above
            // should set the LastError as it sees fit.
            // 
            // But I've added this in just to be safe.  Let's set it to a generic
            // error.
            //
            MYASSERT(0 && L"Returning failure, but LastError is not set");
            SetLastError(ERROR_CAN_NOT_COMPLETE);
        }
    }

    return ((result) && (ERROR_SUCCESS == status));
}


BOOL
AsrCreateStateFileA(
    IN  LPCSTR      lpFilePath,
    IN  LPCSTR      lpProviderName,
    IN  CONST BOOL  bEnableAutoExtend,
    IN  LPCSTR      mszCriticalVolumes,
    OUT DWORD_PTR   *lpAsrContext
    )
/*++
Routine Description:

    This is the ANSI wrapper for AsrCreateStateFile.  Please see 
    AsrCreateStateFileW for a detailed description.

Arguments:
                                         

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
            information, call GetLastError().

--*/
{
    PWSTR   asrSifPath              = NULL,
            providerName            = NULL,
            lpwszCriticalVolumes    = NULL;

    DWORD   cchString               = 0,
            status                  = ERROR_SUCCESS;

    BOOL    result                  = FALSE;

    HANDLE  heapHandle              = GetProcessHeap();

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    //
    // Check the IN parameters
    //
#ifdef PRERELEASE
    //
    // Don't enforce "CriticalVolumes must be non-NULL" for test
    //
    if (!(lpAsrContext)) {
#else 
    if (!(lpAsrContext && mszCriticalVolumes)) {
#endif

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // if lpFilePath is not NULL, allocate a big enough buffer to hold 
    // it, and convert it to wide char
    //
    if (lpFilePath) {
        cchString = strlen(lpFilePath);
        //
        // Do a sanity check:  we don't want to allow a file path
        // more than 4096 characters long.
        //
        _AsrpErrExitCode(
            (cchString > ASR_SIF_ENTRY_MAX_CHARS),
            status,
            ERROR_INVALID_PARAMETER
            );

        //
        // Allocate a big enough buffer, and copy it over
        //
        asrSifPath = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            ((cchString + 1) * sizeof(WCHAR))
            );
        _AsrpErrExitCode(!asrSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

        result = MultiByteToWideChar(CP_ACP,    // CodePage
            0,                      // dwFlags
            lpFilePath,             // lpMultiByteStr
            -1,                     // cbMultiByte: -1 since lpMultiByteStr is null terminated
            asrSifPath,             // lpWideCharStr
            (cchString + 1)         // cchWideChar 
            );
        _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);
    }

    //
    // if lpProviderName is not NULL, make sure it isn't insanely long, 
    // and convert it to wide char 
    //
    if (lpProviderName) {
         cchString = strlen(lpProviderName);
        //
        // Do a sanity check:  we don't want to allow an entry
        // more than 4096 characters long.
        //
        _AsrpErrExitCode(
            (cchString > (ASR_SIF_ENTRY_MAX_CHARS - ASR_SIF_CCH_PROVIDER_STRING)),
            status,
            ERROR_INVALID_PARAMETER
            );
       
        // 
        // Allocate a big enough buffer, and copy it over
        //
        providerName = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            ((cchString + 1) * sizeof(WCHAR))
            );
        _AsrpErrExitCode(!providerName, status, ERROR_NOT_ENOUGH_MEMORY);

        //
        // Convert to wide string
        //
        result = MultiByteToWideChar(CP_ACP,
            0,
            lpProviderName,
            -1,
            providerName,
            cchString + 1
            );
        _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);

    }

    if (mszCriticalVolumes) {
        //
        // Find the total length of mszCriticalVolumes
        //
        LPCSTR lpVolume = mszCriticalVolumes;

        while (*lpVolume) {
            lpVolume += (strlen(lpVolume) + 1);
        }

        //
        //  Convert the string to wide-chars
        //
        cchString = (DWORD) (lpVolume - mszCriticalVolumes + 1);
        lpwszCriticalVolumes = (PWSTR) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            (cchString + 1) * sizeof(WCHAR)
            );
        _AsrpErrExitCode(!lpwszCriticalVolumes, status, ERROR_NOT_ENOUGH_MEMORY);

        result = MultiByteToWideChar(CP_ACP,
            0,
            mszCriticalVolumes,
            cchString,
            lpwszCriticalVolumes,
            cchString + 1
            );
        _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);
    }

    result = AsrCreateStateFileW(
        asrSifPath,
        providerName,
        bEnableAutoExtend,
        lpwszCriticalVolumes,
        lpAsrContext
        );

EXIT:
    _AsrpHeapFree(asrSifPath);
    _AsrpHeapFree(providerName);
    _AsrpHeapFree(lpwszCriticalVolumes);

    return ((result) && (ERROR_SUCCESS == status));
}


//
// ---- AsrAddSifEntry
//
BOOL
AsrAddSifEntryW(
    IN  DWORD_PTR   AsrContext,
    IN  PCWSTR      lpSectionName,
    IN  PCWSTR      lpSifEntry  OPTIONAL
    )
/*++

Routine Description:

    The AsrSifEntry function adds entries to the ASR state file.  It can be 
    used by applications that need to save application-specific information
    in the ASR state file.

Arguments:

    AsrContext - A valid ASR context.  See the notes for more information 
            about this parameter.

    lpSectionName - Pointer to a null-terminated string that specifies the 
            section name.  This parameter cannot be NULL.

            The section name has a string size limit of ASR_MAX_SIF_LINE 
            characters.  This limit is related to how the AsrAddSifEntry 
            function parses entries in the ASR state file.

            The section name is case-insensitive.  It is converted to all-caps
            before being added to the state file. The section name must not 
            contain spaces or non-printable characters.  The valid character 
            set for section name is limited to letters (A-Z, a-z), numbers 
            (0-9), and the following special characters: underscore ("_") 
            and period (".").  If the state file does not contain a section
            with the section name pointed to by lpSectionName, a new 
            section is created with this section name.

    lpSifEntry - Pointer to a null-terminated string that is to be added to 
            the state file in the specified section. If *lpSifEntry is a 
            valid entry, there is a string size limit of 
            ASR_SIF_ENTRY_MAX_CHARS characters.  This limit is related 
            to how the AsrAddSifEntry function parses entries in the 
            ASR state file.

            If lpSifEntry parameter is NULL, an empty section with the 
            section name pointed to by lpSectionName is created if it 
            doesn't already exist.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

Notes:

    The application calling AsrAddSifEntry obtains the ASR context by one of 
    two methods:
     -  If the application is the backup-and-restore application that creates 
        the ASR state file, it receives the context as a parameter returned by 
        AsrCreateStateFile.
     -  If the application is launched by AsrCreateStateFile as part of an ASR
        backup, it receives the context to the state file as the /context 
        command-line parameter.  The application is responsible for reading 
        this parameter to get the value of the context.

    AsrAddSifEntry will fail if the section name is that of a reserved section 
    that applications are not allowed to add entries to.  The following sections 
    in the ASR state file are reserved: 
     -  Version, System, Disks.Mbr, Disk.Gpt, Partitions.Mbr and Partitions.Gpt

    If the section name is recognised (Commands or InstallFiles), AsrAddSifEntry 
    will check the syntax of *lpSifEntry to ensure that it is in the proper 
    format.  In addition, AsrAddSifEntry will check to ensure that there are no 
    filename collisions for the InstallFiles section.  If a collision is 
    detected, the API returns ERROR_ALREADY_EXISTS. Applications must
    use the following pre-defined values to access the recognised sections:
     -  ASR_COMMANDS_SECTION_NAME_W for the Commands section, and
     -  ASR_INSTALLFILES_SECTION_NAME for the InstallFiles section.

--*/
{
    DWORD   status              = ERROR_SUCCESS,
            nextKey             = 0,
            fileOffset          = 0,
            size                = 0,
            fileSize            = 0,
            bufferSize          = 0,
            destFilePos         = 0;

    HANDLE  sifhandle           = NULL;

    WCHAR   sifstring[ASR_SIF_ENTRY_MAX_CHARS *2 + 1],
            ucaseSectionName[ASR_SIF_ENTRY_MAX_CHARS + 1]; // lpSectionName converted to upper case

    PWSTR   buffer              = NULL,
            sectionStart        = NULL,
            lastEqual           = NULL,
            nextSection         = NULL,
            nextChar            = NULL,
            sectionName         = NULL;

    BOOL    commandsSection     = FALSE,
            installFilesSection = FALSE,
            result              = FALSE;

    HANDLE  heapHandle          = NULL;

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    // Zero out local structs
    //
    memset(sifstring, 0, (ASR_SIF_ENTRY_MAX_CHARS *2 + 1) * sizeof(WCHAR));
    memset(ucaseSectionName, 0, (ASR_SIF_ENTRY_MAX_CHARS + 1) * (sizeof (WCHAR)));

    //
    // No OUT parameters
    //

    //
    // Check the IN parameters: The SectionName should meet
    // syntax requirements, SifEntry shouldn't be too long,
    // and the sifhandle should be valid.
    //
    if ((!AsrpSifCheckSectionNameSyntax(lpSectionName))            ||
        
        (ARGUMENT_PRESENT(lpSifEntry) 
            && (wcslen(lpSifEntry) > ASR_SIF_ENTRY_MAX_CHARS))      ||

        ((!AsrContext) || 
            (INVALID_HANDLE_VALUE == (HANDLE)AsrContext))

        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    while (lpSectionName[size]) {
        if ((lpSectionName[size] >= L'a') && (lpSectionName[size] <= L'z')) {
            ucaseSectionName[size] = lpSectionName[size] - L'a' + L'A';
        }
        else {
            ucaseSectionName[size] = lpSectionName[size];
        }
        size++;
    }

    //
    // If the section is a recognised section (COMMANDS or INSTALLFILES),
    // we check the format of the sif entry.
    //
    if (!wcscmp(ucaseSectionName, ASR_SIF_SECTION_COMMANDS_W)) {

        // COMMANDS section
        if (!AsrpSifCheckCommandsEntrySyntax(lpSifEntry)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        commandsSection = TRUE;
    }
    else if(!wcscmp(ucaseSectionName, ASR_SIF_SECTION_INSTALLFILES_W)) {

        // INSTALLFILES section
        if (!AsrpSifCheckInstallFilesEntrySyntax(lpSifEntry, &destFilePos)) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        installFilesSection = TRUE;
    }

    //
    // We do not allow anyone to write to reserved sections:
    // VERSION, SYSTEMS, DISKS.[MBR|GPT], PARTITIONS.[MBR|GPT]
    //
    else if (
        !wcscmp(ucaseSectionName, ASR_SIF_VERSION_SECTION_NAME) ||
        !wcscmp(ucaseSectionName, ASR_SIF_SYSTEM_SECTION_NAME) ||
        !wcscmp(ucaseSectionName, ASR_SIF_MBR_DISKS_SECTION_NAME)   ||
        !wcscmp(ucaseSectionName, ASR_SIF_GPT_DISKS_SECTION_NAME)   ||
        !wcscmp(ucaseSectionName, ASR_SIF_MBR_PARTITIONS_SECTION_NAME) ||
        !wcscmp(ucaseSectionName, ASR_SIF_GPT_PARTITIONS_SECTION_NAME)
        ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    }

    sectionName = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (wcslen(ucaseSectionName) + 5) * sizeof (WCHAR)
        );
    _AsrpErrExitCode(!sectionName, status, ERROR_NOT_ENOUGH_MEMORY);

    swprintf(sectionName, L"\r\n%ws\r\n", ucaseSectionName);

    sifhandle = (HANDLE) AsrContext;

    //
    // The algorithm to add to the middle of asr.sif is rather ugly
    // at the moment: we read the entire file into memory, make our
    // necessary changes, and write back the changed portion of the
    // file to disk.  This is inefficient, but it's okay for now since
    // we expect asr.sif to be about 5 or 6 KB at the most.
    //
    // We should revisit this if the performance is unacceptably poor.
    //

    //
    // Allocate memory for the file
    //
    fileSize = GetFileSize(sifhandle, NULL);
    GetLastError();
    _AsrpErrExitCode((fileSize == 0xFFFFFFFF), status, ERROR_INVALID_DATA);

    SetFilePointer(sifhandle, 0, NULL, FILE_BEGIN);

    buffer = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        fileSize + 2
        );
    _AsrpErrExitCode(!buffer, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // And read file into memory.
    //
    result = ReadFile(sifhandle, buffer, fileSize, &size, NULL);
    _AsrpErrExitCode(!result, status, GetLastError());

    //
    // Try to locate ucaseSectionName in the file
    //
    sectionStart = wcsstr(buffer, sectionName);

    if (!sectionStart) {

        //
        // sectionName was not found, ie the section does not exist
        // Add it at the end, and add the SifEntry right after it.
        //
        swprintf(sifstring,
            L"\r\n%ws\r\n%ws%ws\r\n",
            ucaseSectionName,
            ((commandsSection || installFilesSection) ? L"1=" : L""),
            (ARGUMENT_PRESENT(lpSifEntry) ? lpSifEntry : L"")
            );

        //
        // File pointer already points to the end (because of ReadFile above)
        //
        if (!WriteFile(sifhandle, sifstring, 
                wcslen(sifstring)*sizeof (WCHAR), &size, NULL)) {
            status = GetLastError();
        }

        // We're done

    }
    else {

        //
        // The section exists, if lpSifEntry is NULL, we're done
        //
        if (ARGUMENT_PRESENT(lpSifEntry)) {

            //
            // SifEntry is not NULL, we'll add it at the end of the section
            //
            nextChar = sectionStart + 4;    // Move pointer from \r to . in \r\n[.
            nextKey = 1;

            //
            // Find where this section ends--look either for the start
            // of the next section, or for the end of the file
            //
            while(*nextChar && *nextChar != L'[') {

                //
                // If this is a recognised section, we need to generate
                // the <key> to add the entry in a <key>=<entry> format.
                // We go through each line, and find the last key that
                // already exists.  The new key will be last key + 1.
                //
                if (commandsSection || installFilesSection) {

                    UINT    commaCount = 0;
                    BOOL    tracking = FALSE;
                    UINT    count = 0;
                    WCHAR   c1, c2;

                    while (*nextChar && (*nextChar != L'[') && (*nextChar != L'\n')) {

                        if (installFilesSection) {
                            if (*nextChar == L',') {
                                commaCount++;
                            }

                            if ((commaCount > 2) && (L'"' == *nextChar)) {
                                if (tracking) {
                                    // duplicate file name
                                    _AsrpErrExitCode((L'"'== lpSifEntry[destFilePos + count]), status, ERROR_ALREADY_EXISTS);
                                }
                                else {
                                    tracking = TRUE;
                                    count = 0;
                                }
                            }

                            if (tracking) {

                                c1 = *nextChar;
                                if (c1 >= L'a' && c1 <= L'z') {
                                    c1 = c1 - L'a' + L'A';
                                }

                                c2 = lpSifEntry[destFilePos + count];
                                if (c2 >= L'a' && c2 <= L'z') {
                                    c2 = c2 - L'a' + L'A';
                                }

                                if (c1 == c2) {
                                    count++;
                                }
                                else {
                                    tracking = FALSE;
                                }
                            }
                        }

                        nextChar++;
                    }

                    if (*nextChar == L'\n') {

                        ++nextChar;

                        if (*nextChar >= L'0' && *nextChar <= L'9') {
                            nextKey = 0;

                            while (*nextChar >= L'0' && *nextChar <= L'9') {
                                nextKey = nextKey*10 + (*nextChar - L'0');
                                nextChar++;
                            }

                            nextKey++;
                        }
                    }
                }
               else {
                   nextChar++;
               }
            }

            //
            // We save a pointer to the next section in the sif, since we
            // need to write it out to disk.
            //
            if (*nextChar) {
                nextSection = nextChar;
            }
            else {
                nextSection = NULL;
            }

            if (commandsSection || installFilesSection) {

                //
                // Form the <key>=<entry> string
                //
                swprintf(
                    sifstring,
                    L"%lu=%ws\r\n",
                    nextKey,
                    lpSifEntry
                    );
            }
            else {

                //
                // Not a recognised section: don't add the <key>=<entry>
                // format, keep the string exactly as passed in
                //
                wcscpy(sifstring, lpSifEntry);
                wcscat(sifstring, L"\r\n");
            }


            if (nextSection) {
                //
                // There are sections following the section we're adding to
                // We need to mark the point where the new entry is added.
                // While writing out to disk, we'll start from this point.
                //
                fileOffset = (DWORD) (((LPBYTE)nextSection) - ((LPBYTE)buffer) - sizeof(WCHAR)*2);
                             // section start      - file start       - "\r\n"
                SetFilePointer(sifhandle, fileOffset, NULL, FILE_BEGIN);
            }

            //
            // file pointer points to where the entry must be added
            //
            if (!WriteFile(sifhandle, sifstring, wcslen(sifstring)*sizeof(WCHAR), &size, NULL)) {
                status = GetLastError();
            }
            else  if (nextSection) {
                //
                // write out all sections following this entry
                //
                if (!WriteFile(
                    sifhandle,
                    ((LPBYTE)nextSection) - (sizeof(WCHAR)*2),
                    fileSize - fileOffset,
                    &size,
                    NULL
                    )) {
                    status = GetLastError();
                }
            }
        }
    }

EXIT:
    _AsrpHeapFree(sectionName);
    _AsrpHeapFree(buffer);

    return (BOOL) (ERROR_SUCCESS == status);
}


BOOL
AsrAddSifEntryA(
    IN  DWORD_PTR   AsrContext,
    IN  LPCSTR      lpSectionName,
    IN  LPCSTR      lpSifEntry OPTIONAL
    )
/*++

    This is the ANSI wrapper for AsrAddSifEntry.
    See AsrAddSifEntryW for a full description.

--*/
{
    WCHAR   wszSectionName[ASR_SIF_ENTRY_MAX_CHARS + 1];
    WCHAR   wszSifEntry[ASR_SIF_ENTRY_MAX_CHARS + 1];

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    if (!AsrpCheckBackupPrivilege()) {
        //
        // The caller needs to first acquire SE_BACKUP_NAME 
        //
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return FALSE;
    }

    memset(wszSectionName, 0L, ASR_SIF_ENTRY_MAX_CHARS + 1);
    memset(wszSifEntry, 0L, ASR_SIF_ENTRY_MAX_CHARS + 1);

    //
    // lpSectionName must be non-NULL
    //
    if ((!lpSectionName) || !(MultiByteToWideChar(
        CP_ACP,
        0,
        lpSectionName,
        -1,
        wszSectionName,
        ASR_SIF_ENTRY_MAX_CHARS + 1
        ))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // lpSifEntry is allowed to be NULL
    //
    if (ARGUMENT_PRESENT(lpSifEntry) && !(MultiByteToWideChar(
        CP_ACP,
        0,
        lpSifEntry,
        -1,
        wszSifEntry,
        ASR_SIF_ENTRY_MAX_CHARS + 1
        ))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return AsrAddSifEntryW(
        AsrContext,
        wszSectionName,
        wszSifEntry
        );
}


//
// ---- AsrFreeContext
//
BOOL
AsrFreeContext(
    IN OUT DWORD_PTR *lpAsrContext
    )

/*++

Routine Description:
  
    AsrFreeContext frees the Asr Context, and sets lpAsrContext 
    to NULL.

Arguments:

    lpAsrContext    This is the Asr context to be freed.  This argument must
                    not be NULL.

                    AsrFreeContext will set this value to NULL after freeing 
                    it, to prevent further unintended accesses to the freed 
                    object.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    BOOL result = FALSE;

    if (AsrpIsRunningOnPersonalSKU()) {
        //
        // ASR is not supported on the Personal SKU
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    //
    // Essentially, the lpAsrContext is just a file handle, and all we need
    // to do to free it is call CloseHandle.
    //
    if ((lpAsrContext) && 
        (*lpAsrContext) && 
        (INVALID_HANDLE_VALUE != (HANDLE)(*lpAsrContext))
        ) {
        result = CloseHandle((HANDLE)*lpAsrContext);
        *lpAsrContext = 0;
    }
    else {
        SetLastError(ERROR_INVALID_PARAMETER);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\asrclus.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asrclus.c

Abstract:

    This module contains ASR routines specifically
    implemented for clusters.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Environment:

    User-mode only.

Revision History:

    27-May-2000 guhans
        Moved cluster-related routines from asr.c to asrclus.c

    01-Mar-2000 guhans
        Initial implementation for cluster-specific routines
        in asr.c

--*/
#include "setupp.h"
#pragma hdrstop

#include <mountmgr.h>   // mountmgr ioctls
#include <clusstor.h>   // Cluster API's
#include <resapi.h>     // Cluster ResUtilEnumResources
#include <clusdisk.h>

#define THIS_MODULE 'C'
#include "asrpriv.h"    // Private ASR definitions and routines

//
// --------
// typedef's local to this module
// --------
//

//
// The cluster resource related typdefs
//
typedef DWORD (* PFN_CLUSTER_RESOURCE_CONTROL) (
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD lpcbBytesReturned
    );

typedef DWORD (* PFN_RES_UTIL_ENUM_RESOURCES) (
    IN HRESOURCE            hSelf,
    IN LPCWSTR              lpszResTypeName,
    IN LPRESOURCE_CALLBACK  pResCallBack,
    IN PVOID                pParameter
    );


//
// ---------
// global variables used within this module.
// --------
//
PFN_CLUSTER_RESOURCE_CONTROL pfnClusterResourceControl;


//
// ---------
// constants used within this module.
// --------
//
const WCHAR ASR_CLUSTER_PHYSICAL_DISK[] = L"Physical Disk";
const WCHAR ASR_CLUSTER_CLUSAPI_DLL_NAME[] = L"clusapi.dll";
const WCHAR ASR_CLUSTER_RESUTILS_DLL_NAME[] = L"resutils.dll";

//
// The following must be single-byte ansi chars
//
const CHAR ASR_CLUSTER_DLL_MODULE_NAME[]    = "%SystemRoot%\\system32\\syssetup.dll";
const CHAR ASR_CLUSTER_DLL_PROC_NAME[]      = "AsrpGetLocalDiskInfo";
const CHAR ASR_CLUSTER_CLUSAPI_PROC_NAME[] = "ClusterResourceControl";
const CHAR ASR_CLUSTER_RESUTILS_PROC_NAME[] = "ResUtilEnumResources";


//
// --------
// function implementations
// --------
//


//
// --- AsrpGetLocalVolumeInfo and related helper functions
//

//
// The disk info struct we get back from the remote nodes on the cluster will have
// offsets instead of pointers--we can convert this back to pointers by just adding
// back the base address.  We also mark that this struct is packed--so we should just
// free the entire struct instead of freeing each pointer in the struct.
//
BOOL
AsrpUnPackDiskInfo(
    IN PVOID InBuffer,
    IN CONST DWORD dwSizeBuffer
    )
{

    PASR_DISK_INFO pBuffer = (PASR_DISK_INFO) InBuffer;
    DWORD dwNextOffset = 0;

/*    if (!((pBuffer->pDriveLayoutEx) && (pBuffer->pDiskGeometry) && (pBuffer->pPartition0Ex))) {
        return FALSE;
    }
*/

    //
    // Do some sanity checks to ensure that the offsets in the structure make sense
    //
    if (pBuffer->pDriveLayoutEx) {
        //
        // Make sure the buffer is big enough to hold this struct, and
        // that the entire struct fits within the buffer
        //
        if ((dwSizeBuffer < sizeof(DRIVE_LAYOUT_INFORMATION_EX)) ||
            (PtrToUlong(pBuffer->pDriveLayoutEx) > (dwSizeBuffer - sizeof(DRIVE_LAYOUT_INFORMATION_EX)))) {
            return FALSE;
        }

        //
        // Set the minimum value for the next struct
        //
        dwNextOffset = PtrToUlong(pBuffer->pDriveLayoutEx) + sizeof(DRIVE_LAYOUT_INFORMATION_EX);
    }

    if (pBuffer->pDiskGeometry) {
        //
        // Make sure this struct doesn't overlap with the previous struct
        //
        if (PtrToUlong(pBuffer->pDiskGeometry) < dwNextOffset) {
            return FALSE;
        }

        //
        // Make sure we haven't run off the end
        //
        if (dwNextOffset > dwSizeBuffer) {
            return FALSE;
        }

        //
        // Make sure the rest of buffer is big enough to hold this struct, and
        // that the entire struct fits within the buffer
        //
        if (((dwSizeBuffer - dwNextOffset) < sizeof(DISK_GEOMETRY)) ||
            (PtrToUlong(pBuffer->pDiskGeometry) > (dwSizeBuffer  - sizeof(DISK_GEOMETRY)))) {
            return FALSE;
        }
        
        //
        // Set the minimum value for the next struct
        //
        dwNextOffset = PtrToUlong(pBuffer->pDiskGeometry) + sizeof(DISK_GEOMETRY);
    }

    if (pBuffer->pPartition0Ex) {
        //
        // Make sure this struct doesn't overlap with the previous struct
        //
        if (PtrToUlong(pBuffer->pPartition0Ex) < dwNextOffset) {
            return FALSE;
        }

        //
        // Make sure we haven't run off the end
        //
        if (dwNextOffset > dwSizeBuffer) {
            return FALSE;
        }

        //
        // Make sure the rest of buffer is big enough to hold this struct, and
        // that the entire struct fits within the buffer
        //
        if (((dwSizeBuffer - dwNextOffset) < sizeof(PARTITION_INFORMATION_EX)) ||
            (PtrToUlong(pBuffer->pPartition0Ex) > (dwSizeBuffer  - sizeof(PARTITION_INFORMATION_EX)))) {
            return FALSE;
        }

        //
        // Set the minimum value for the next struct
        //
        dwNextOffset = PtrToUlong(pBuffer->pPartition0Ex) + sizeof(PARTITION_INFORMATION_EX);
    }
        
    if (pBuffer->PartitionInfoTable) {
        //
        // Make sure this struct doesn't overlap with the previous struct
        //
        if (PtrToUlong(pBuffer->PartitionInfoTable) < dwNextOffset) {
            return FALSE;
        }

        //
        // Make sure we haven't run off the end
        //
        if (dwNextOffset > dwSizeBuffer) {
            return FALSE;
        }

        //
        // Make sure the rest of buffer is big enough to hold this struct, and
        // that the entire struct fits within the buffer
        //
        if (((dwSizeBuffer - dwNextOffset) < sizeof(ASR_PTN_INFO)) ||
            (PtrToUlong(pBuffer->PartitionInfoTable) > (dwSizeBuffer - sizeof(ASR_PTN_INFO)))) {
            return FALSE;
        }

        //
        // Set the minimum value for the next struct
        //
        dwNextOffset = PtrToUlong(pBuffer->PartitionInfoTable) + sizeof(ASR_PTN_INFO);
    }

    if (pBuffer->pScsiAddress) {
        //
        // Make sure this struct doesn't overlap with the previous struct
        //
        if (PtrToUlong(pBuffer->pScsiAddress) < dwNextOffset) {
            return FALSE;
        }

        //
        // Make sure we haven't run off the end
        //
        if (dwNextOffset > dwSizeBuffer) {
            return FALSE;
        }

        //
        // Make sure the rest of buffer is big enough to hold this struct, and
        // that the entire struct fits within the buffer
        //
        if (((dwSizeBuffer - dwNextOffset) < sizeof(SCSI_ADDRESS)) ||
            (PtrToUlong(pBuffer->pScsiAddress) > (dwSizeBuffer - sizeof(SCSI_ADDRESS)))) {
            return FALSE;
        }

        //
        // Set the minimum value for the next struct
        //
        dwNextOffset = PtrToUlong(pBuffer->pScsiAddress) + sizeof(SCSI_ADDRESS);
    }

    //
    // Make sure we haven't run off the end
    //
    if (dwNextOffset > dwSizeBuffer) {
        return FALSE;
    }

    pBuffer->IsPacked = TRUE;

    //
    // Convert the offsets to pointers
    //
    if (pBuffer->pDriveLayoutEx) {
        pBuffer->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->pDriveLayoutEx));
    }

    if (pBuffer->pDiskGeometry) {
        pBuffer->pDiskGeometry = (PDISK_GEOMETRY) ((LPBYTE)pBuffer +  PtrToUlong((LPBYTE)pBuffer->pDiskGeometry));
    }

    if (pBuffer->pPartition0Ex) {
        pBuffer->pPartition0Ex = (PPARTITION_INFORMATION_EX) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->pPartition0Ex));
    }

    if (pBuffer->PartitionInfoTable) {
        pBuffer->PartitionInfoTable = (PASR_PTN_INFO) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->PartitionInfoTable));
    }

    if (pBuffer->pScsiAddress) {
        pBuffer->pScsiAddress = (PSCSI_ADDRESS) ((LPBYTE)pBuffer + PtrToUlong(pBuffer->pScsiAddress));
    }

    return TRUE;
}


//
// Copies the info in pLocalDisk to a flat buffer pointed to by lpOutBuffer.
// The pointers are changed to offsets from the start of the buffer.
//
DWORD
AsrpPackDiskInfo(
    IN  PASR_DISK_INFO pLocalDisk,
    OUT PVOID lpOutBuffer,
    IN  DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
{

    DWORD reqdSize = 0;
    PASR_DISK_INFO pBuffer = NULL;
    DWORD offset = 0;

    MYASSERT(pLocalDisk);

    //
    // Calculate required size
    //
    reqdSize = sizeof (ASR_DISK_INFO) +
        pLocalDisk->sizeDriveLayoutEx +
        pLocalDisk->sizeDiskGeometry +
        pLocalDisk->sizePartition0Ex +
        pLocalDisk->sizePartitionInfoTable;

    if (pLocalDisk->pScsiAddress) {
        reqdSize += sizeof(SCSI_ADDRESS);
    }

    if (lpBytesReturned) {
        *lpBytesReturned = reqdSize;
    }

    if (reqdSize > nOutBufferSize) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the ASR_DISK_INFO struct over to outBuffer
    //
    memcpy(lpOutBuffer, pLocalDisk, sizeof(ASR_DISK_INFO));
    pBuffer = (PASR_DISK_INFO) lpOutBuffer;
    offset = sizeof(ASR_DISK_INFO); // offset where the next struct will be copied

    //
    // Now, we go through the buffer and convert all pointers to offsets,
    // and copy over the structs they were pointing to.
    //

    //
    // First pointer:  PWSTR DevicePath;
    // Since the DevicePath makes sense only in the context of the local node,
    // we return NULL to the remote node.
    //
    pBuffer->DevicePath = NULL;

    //
    // Next pointer:  PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx;
    //
    if (pLocalDisk->pDriveLayoutEx) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pDriveLayoutEx,
            pLocalDisk->sizeDriveLayoutEx
            );

        pBuffer->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) UlongToPtr(offset);
        offset += pLocalDisk->sizeDriveLayoutEx;
    }

    //
    // Next pointer:  PDISK_GEOMETRY pDiskGeometry;
    //
    if (pLocalDisk->pDiskGeometry) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pDiskGeometry,
            pLocalDisk->sizeDiskGeometry
            );

        pBuffer->pDiskGeometry = (PDISK_GEOMETRY) UlongToPtr(offset);
        offset += pLocalDisk->sizeDiskGeometry;
    }

    //
    // Next pointer:  PPARTITION_INFORMATION_EX pPartition0Ex;
    //
    if (pLocalDisk->pPartition0Ex) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pPartition0Ex,
            pLocalDisk->sizePartition0Ex
            );

        pBuffer->pPartition0Ex= (PPARTITION_INFORMATION_EX) UlongToPtr(offset);
        offset += pLocalDisk->sizePartition0Ex;
    }

    //
    // Next pointer:  PASR_PTN_INFO PartitionInfoTable;
    //
    if (pLocalDisk->PartitionInfoTable) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->PartitionInfoTable,
            pLocalDisk->sizePartitionInfoTable
            );

        pBuffer->PartitionInfoTable = (PASR_PTN_INFO) UlongToPtr(offset);
        offset += pLocalDisk->sizePartitionInfoTable;
    }

    //
    // Last pointer:  PSCSI_ADDRESS pScsiAddress;
    //
    if (pLocalDisk->pScsiAddress) {
        memcpy(((LPBYTE)lpOutBuffer + offset),
            pLocalDisk->pScsiAddress,
            sizeof(SCSI_ADDRESS)
            );

        pBuffer->pScsiAddress = (PSCSI_ADDRESS) UlongToPtr(offset);
        offset += sizeof(SCSI_ADDRESS);
    }

    MYASSERT(offset <= nOutBufferSize);

    return ERROR_SUCCESS;
}


DWORD
WINAPI
AsrpGetLocalDiskInfo(
    IN LPSTR lpszDeviceName,
    IN LPSTR lpszContextString,    // not used
    OUT PVOID lpOutBuffer,
    IN  DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
{
    PASR_DISK_INFO  pLocalDisk = NULL;
    HANDLE heapHandle = NULL;
    DWORD status = ERROR_SUCCESS;
    BOOL result = FALSE;
    ULONG MaxDeviceNumber = 0;
    DWORD cchReqdSize = 0;

    heapHandle = GetProcessHeap();

    //
    // Either the BytesReturned must be non-null (he's getting the required size),
    // or the lpOutBuffer must be non-null (he's getting the data).
    //
    _AsrpErrExitCode(!(lpOutBuffer || lpBytesReturned), status, ERROR_INVALID_PARAMETER);
    if (lpBytesReturned) {
        *lpBytesReturned = 0;
    }

    pLocalDisk = (PASR_DISK_INFO) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (ASR_DISK_INFO)
        );
    _AsrpErrExitCode(!pLocalDisk, status, ERROR_NOT_ENOUGH_MEMORY);

    cchReqdSize = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        NULL,
        0
        );

    pLocalDisk->DevicePath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (cchReqdSize + 1) * (sizeof(WCHAR))
        );
    _AsrpErrExitCode(!(pLocalDisk->DevicePath), status, ERROR_NOT_ENOUGH_MEMORY);

    result = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        pLocalDisk->DevicePath,
        (cchReqdSize + 1)
        );
    _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);

    //
    // Get the disk layout information
    //
    result = AsrpInitLayoutInformation(NULL, pLocalDisk, &MaxDeviceNumber, TRUE, TRUE);
    _AsrpErrExitCode(!result, status, GetLastError());
//    _AsrpErrExitCode(result && GetLastErr      what if createfile fails?

    result = AsrpFreeNonFixedMedia(&pLocalDisk);
    _AsrpErrExitCode(!result, status, GetLastError());
    _AsrpErrExitCode(!pLocalDisk, status, ERROR_SUCCESS);

    //
    // Copy it to the out buffer without any pointers
    //
    status = AsrpPackDiskInfo(pLocalDisk, lpOutBuffer, nOutBufferSize, lpBytesReturned);


EXIT:
    AsrpFreeStateInformation(&pLocalDisk, NULL);

    return status;
}



BOOL
AsrpIsOfflineClusteredDisk(
    IN CONST HANDLE hDisk
    )
/*++

Routine Description:
    
    Utility to check if the current disk is a shared cluster disk that's owned
    by a different node (and is hence inaccessible).

    Based on code-snippet graciously donated by SteveDz.
    
Arguments:

    hDisk - Supplies a handle (no access required) to the disk of interest.

Return Value:

    If the function succeeds and the disk is a shared cluster disk that is 
            offline on the current node, the return value is a nonzero value.

    If the function fails, or if the disk is not a shared cluster disk that
            is offline on the current node (ie, is a local unshared disk, or
            a shared disk that online to the current node) the return value 
            is zero. 

--*/
{
    BOOL result = FALSE;
    DWORD bytesReturned = 0;
    DiskState diskState = DiskOffline;

    if ((!hDisk) || (INVALID_HANDLE_VALUE == hDisk)) {
        //
        // We couldn't open the disk--let's assume that it's not an offline 
        // clustered disk.
        //
        return FALSE;
    }

    //
    // To get current disk state, don't specify input buffer.
    // Current disk state returned in output buffer.
    //
    result = DeviceIoControl(hDisk,
        IOCTL_DISK_CLUSTER_GET_STATE,
        NULL,
        0,
        &diskState,
        sizeof(DiskState),
        &bytesReturned,
        FALSE 
        );

    if ((result) && (DiskOffline == diskState)) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


//
// ---- AsrpInitClusterSharedDisks and related helper functions
//

BOOL
AsrpIsClusteredDiskSame(
    IN PASR_DISK_INFO currentDisk,
    IN PASR_DISK_INFO clusterDisk
    )
{

    if (!clusterDisk || !currentDisk) {
        MYASSERT(0 && L"Invalid parameter, Disk is NULL");
        return FALSE;
    }

    if (currentDisk->Style != clusterDisk->Style) {
        return FALSE;
    }

    if (PARTITION_STYLE_MBR == clusterDisk->Style) { // currently always true
        if (clusterDisk->pDriveLayoutEx) {
            if (currentDisk->pDriveLayoutEx) {
                return (currentDisk->pDriveLayoutEx->Mbr.Signature == clusterDisk->pDriveLayoutEx->Mbr.Signature);
            }
            else {
                return (currentDisk->TempSignature == clusterDisk->pDriveLayoutEx->Mbr.Signature);
            }
        }
        else {
            MYASSERT(0 && L"Cluster disk drive layout is NULL");
            return FALSE;
        }

    }
    else {
        if (clusterDisk->pDriveLayoutEx && currentDisk->pDriveLayoutEx) {
            return (IsEqualGUID(&(currentDisk->pDriveLayoutEx->Gpt.DiskId), &(clusterDisk->pDriveLayoutEx->Gpt.DiskId)));
        }
        else {
            return FALSE;
        }
    }

    return FALSE;
}


DWORD
AsrpResourceCallBack(
    RESOURCE_HANDLE hOriginal,
    RESOURCE_HANDLE hResource,
    PVOID lpParams
    )
{
    DISK_DLL_EXTENSION_INFO inBuffer;

    PBYTE outBuffer = NULL;

    DWORD sizeOutBuffer = 0,
        bytesReturned = 0;

    DWORD status = ERROR_SUCCESS;

    PASR_DISK_INFO currentDisk = (PASR_DISK_INFO) lpParams,
        clusterDisk = NULL,
        prevDisk = NULL;

    BOOL bResult = FALSE;

    HANDLE heapHandle = NULL;
    BOOL done = FALSE;

    if (!lpParams) {
        //
        // The system must have at least one disk that has been enumerated
        // already (the system disk, at least!), so our disk list shouldn't be NULL.
        //
        return ERROR_INVALID_PARAMETER;
    }

    heapHandle = GetProcessHeap();
    MYASSERT(heapHandle);

    //
    // Allocate a reasonably-sized memory for the out buffer.  If this isn't
    // big enough, we'll re-allocate.
    //
    sizeOutBuffer = ASR_BUFFER_SIZE;
    outBuffer = (PBYTE) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeOutBuffer
        );
    _AsrpErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // Call AsrpGetLocalDiskInfo on the node owning this disk resource
    //
    ZeroMemory(&inBuffer, sizeof(inBuffer));
    inBuffer.MajorVersion = NT5_MAJOR_VERSION;
    strcpy(inBuffer.DllModuleName, ASR_CLUSTER_DLL_MODULE_NAME);
    strcpy(inBuffer.DllProcName, ASR_CLUSTER_DLL_PROC_NAME);

    status = (pfnClusterResourceControl) (hResource,
        NULL,
        CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
        &inBuffer,
        sizeof(DISK_DLL_EXTENSION_INFO),
        (PVOID) outBuffer,
        sizeOutBuffer,
        &bytesReturned
        );

    if (ERROR_INSUFFICIENT_BUFFER == status) {
        //
        // The buffer wasn't big enough, re-allocate as needed
        //
        _AsrpHeapFree(outBuffer);

        sizeOutBuffer = bytesReturned;
        outBuffer = (PBYTE) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeOutBuffer
            );
        _AsrpErrExitCode(!outBuffer, status, ERROR_NOT_ENOUGH_MEMORY);

        status = (pfnClusterResourceControl) (
            hResource,
            NULL,
            CLUSCTL_RESOURCE_STORAGE_DLL_EXTENSION,
            &inBuffer,
            sizeof(DISK_DLL_EXTENSION_INFO),
            (PVOID) outBuffer,
            sizeOutBuffer,
            &bytesReturned
            );
    }
    _AsrpErrExitCode((ERROR_SUCCESS != status), status, status);

    //
    // outBuffer has a packed disk info struct (ie the pointers are offsets).
    //
    bResult = AsrpUnPackDiskInfo(outBuffer, sizeOutBuffer);
    _AsrpErrExitCode(!bResult, status, ERROR_INVALID_DATA);

    clusterDisk = (PASR_DISK_INFO) outBuffer;
    clusterDisk->IsClusterShared = TRUE;
    clusterDisk->IsPacked = TRUE;       // so that we free this properly

    //
    // Check if clusterDisk already has info in our list (ie is owned
    // locally)
    //
    // Note that for now, clusterDisk is always MBR (since clusters don't
    // support shared GPT disks).  We don't care here, we handle GPT as well.
    //
    done = FALSE;
    prevDisk = NULL;
    while (currentDisk && !done) {

        if (AsrpIsClusteredDiskSame(currentDisk, clusterDisk)) {

            if (currentDisk->pDriveLayoutEx) {
                //
                // This disk is owned by the local node (correct?), since
                // we would not have gotten the pDriveLayout otherwise
                //
                currentDisk->IsClusterShared = TRUE;
                currentDisk->IsPacked = FALSE;

                //
                // We don't need the info returned by clusterDisk, we have
                // it in currentDisk already.
                //
                _AsrpHeapFree(clusterDisk); // it's packed.

            }
            else {
                //
                // This disk is owned by a remote node.  So we add clusterDisk
                // in to our list now.  We'll remove currentDisk from our
                // list later (in RemoveNonFixedDevices).
                //
                // First though, we copy over DevicePath and DeviceNumber
                // from currentDisk, since these are relative to the local
                // machine
                //
                if (currentDisk->DevicePath) {

                    clusterDisk->DevicePath = (PWSTR) HeapAlloc(
                        heapHandle,
                        HEAP_ZERO_MEMORY,
                        sizeof(WCHAR) * (wcslen(currentDisk->DevicePath) + 1)
                        );

                    wcscpy(clusterDisk->DevicePath, currentDisk->DevicePath);
                }

                clusterDisk->DeviceNumber = currentDisk->DeviceNumber;
                //
                // Don't bother freeing currentDisk, it'll get taken care
                // of in RemoveNonFixedDevices.
                //
                clusterDisk->pNext = currentDisk->pNext;
                currentDisk->pNext = clusterDisk;

                currentDisk = clusterDisk;  // move forward by one (don't really need to since done will be set to TRUE and we'll get out of the loop)
            }

            done = TRUE;
        }

        prevDisk = currentDisk;
        currentDisk = currentDisk->pNext;
    }


    if (!done) {
        //
        // This disk was not found in our list (strange), let's add
        // it in at the end
        //
//        MYASSERT(0 && L"Clustered disk not found in OriginalDiskList, adding it to the end");
        clusterDisk->pNext = NULL;
        prevDisk->pNext = clusterDisk;
    }


EXIT:
    //
    // Free up outBuffer on failure.  On success, outBuffer shouldn't
    // be freed, it will either be part of OriginalDiskList or already
    // be freed.
    //
    if (ERROR_SUCCESS != status) {
        _AsrpHeapFree(outBuffer);
    }

    return status;
}


BOOL
AsrpInitClusterSharedDisks(
    IN PASR_DISK_INFO OriginalDiskList
    )
{
    DWORD status = ERROR_SUCCESS,
        dwOldError;

    HMODULE hClusApi = NULL,
        hResUtils = NULL;

    PFN_RES_UTIL_ENUM_RESOURCES pfnResUtilEnumResources = NULL;

    dwOldError = GetLastError();

    if (!OriginalDiskList)  {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    hClusApi = LoadLibraryW(ASR_CLUSTER_CLUSAPI_DLL_NAME);
    _AsrpErrExitCode(!hClusApi, status, GetLastError());

    pfnClusterResourceControl = (PFN_CLUSTER_RESOURCE_CONTROL) GetProcAddress(
        hClusApi,
        ASR_CLUSTER_CLUSAPI_PROC_NAME
        );
    _AsrpErrExitCode(!pfnClusterResourceControl, status, GetLastError());

    hResUtils = LoadLibraryW(ASR_CLUSTER_RESUTILS_DLL_NAME);
    _AsrpErrExitCode(!hResUtils, status, GetLastError());

    pfnResUtilEnumResources = (PFN_RES_UTIL_ENUM_RESOURCES) GetProcAddress(
        hResUtils,
        ASR_CLUSTER_RESUTILS_PROC_NAME
        );
    _AsrpErrExitCode(!pfnResUtilEnumResources, status, GetLastError());

    status = (pfnResUtilEnumResources) (NULL,
        ASR_CLUSTER_PHYSICAL_DISK,
        AsrpResourceCallBack,
        OriginalDiskList
        );

EXIT:
    if (hClusApi) {
        FreeLibrary(hClusApi);
    }

    if (hResUtils) {
        FreeLibrary(hResUtils);
    }

    // ResUtil will fail if we aren't on a cluster, but that's fine.
    SetLastError(dwOldError);
    return TRUE;
}


//
// --- AsrpGetLocalVolumeInfo and related helper functions
//

//
// The following two definitions are from asr_fmt:dr_state.cpp.  This MUST be
// kept in sync.
//
typedef struct _ASRFMT_CLUSTER_VOLUME_INFO {

    UINT driveType;

    DWORD PartitionNumber;

    ULONG FsNameOffset;
    USHORT FsNameLength;

    ULONG LabelOffset;
    USHORT LabelLength;

    ULONG SymbolicNamesOffset;
    USHORT SymbolicNamesLength;

    DWORD dwClusterSize;

} ASRFMT_CLUSTER_VOLUME_INFO, *PASRFMT_CLUSTER_VOLUME_INFO;


typedef struct _ASRFMT_CLUSTER_VOLUMES_TABLE {

    DWORD DiskSignature;

    DWORD NumberOfEntries;

    ASRFMT_CLUSTER_VOLUME_INFO VolumeInfoEntry[1];

} ASRFMT_CLUSTER_VOLUMES_TABLE, *PASRFMT_CLUSTER_VOLUMES_TABLE;


BOOL
AsrpFmtGetVolumeDetails(
    IN  PWSTR lpVolumeGuid,
    OUT PWSTR lpFsName,
    IN  DWORD cchFsName,
    OUT PWSTR lpVolumeLabel,
    IN  DWORD cchVolumeLabel,
    OUT LPDWORD lpClusterSize
    )
{
    DWORD dwFSFlags = 0,
        dwSectorsPerCluster = 0,
        dwBytesPerSector = 0,
        dwNumFreeClusters = 0,
        dwTotalNumClusters = 0;

    BOOL result1 = TRUE,
        result2 = TRUE;

    *lpFsName = 0;
    *lpVolumeLabel = 0;
    *lpClusterSize = 0;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    result1 = GetVolumeInformationW(lpVolumeGuid,
        lpVolumeLabel,
        cchVolumeLabel,
        NULL,   // no need for serial number
        NULL,   // max file name length
        &dwFSFlags, // !! we might need to store some of this ...
        lpFsName,
        cchFsName
        );

    result2 = GetDiskFreeSpaceW(lpVolumeGuid,
        &dwSectorsPerCluster,
        &dwBytesPerSector,
        &dwNumFreeClusters,
        &dwTotalNumClusters
        );

    *lpClusterSize = dwSectorsPerCluster * dwBytesPerSector;

    return (result1 && result2);
}


DWORD
WINAPI
AsrpGetLocalVolumeInfo(
    IN LPSTR lpszDeviceName,
    IN LPSTR lpszContextString,    // not used
    OUT PVOID lpOutBuffer,
    IN  DWORD nOutBufferSize,
    OUT LPDWORD lpBytesReturned
    )
{
    PASR_DISK_INFO  pLocalDisk = NULL;
    HANDLE heapHandle = NULL;
    DWORD status = ERROR_SUCCESS;
    BOOL result = FALSE;
    ULONG MaxDeviceNumber = 0;
    DWORD cchReqdSize = 0,
        cchGuid = 0,
        offset = 0,
        index = 0,
        i = 0;

    USHORT
        cbFsName = 0,
        cbLabel = 0,
        cbLinks = 0;

    PMOUNTMGR_MOUNT_POINTS mountPointsOut = NULL;

    WCHAR devicePath[MAX_PATH + 1];
    WCHAR volumeGuid[MAX_PATH + 1];
    WCHAR fileSystemName[MAX_PATH + 1];
    WCHAR volumeLabel[MAX_PATH + 1];
    UINT driveType = DRIVE_UNKNOWN;
    DWORD clusterSize = 0;

    BOOL bufferFull = FALSE,
        foundGuid = FALSE;

    PPARTITION_INFORMATION_EX  currentPartitionEx = NULL;
    PASRFMT_CLUSTER_VOLUMES_TABLE pTable = NULL;

    heapHandle = GetProcessHeap();

    //
    // Either the BytesReturned must be non-null (he's getting the required size),
    // or the lpOutBuffer must be non-null (he's getting the data).
    //
    _AsrpErrExitCode(!(lpOutBuffer || lpBytesReturned), status, ERROR_INVALID_PARAMETER);
    if (lpBytesReturned) {
        *lpBytesReturned = 0;
    }

    //
    // Zero the out buffer
    //
    if ((lpOutBuffer) && (nOutBufferSize > 0)) {
        ZeroMemory(lpOutBuffer, nOutBufferSize);
    }

    pLocalDisk = (PASR_DISK_INFO) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (ASR_DISK_INFO)
        );
    _AsrpErrExitCode(!pLocalDisk, status, ERROR_NOT_ENOUGH_MEMORY);

    cchReqdSize = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        NULL,
        0
        );

    pLocalDisk->DevicePath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        (cchReqdSize + 1) * (sizeof(WCHAR))
        );
    _AsrpErrExitCode(!(pLocalDisk->DevicePath), status, ERROR_NOT_ENOUGH_MEMORY);

    result = MultiByteToWideChar(CP_ACP,
        0,
        lpszDeviceName,
        -1,
        pLocalDisk->DevicePath,
        (cchReqdSize + 1)
        );
    _AsrpErrExitCode(!result, status, ERROR_INVALID_PARAMETER);

    //
    // Get the disk layout information
    //
    result = AsrpInitLayoutInformation(NULL, pLocalDisk, &MaxDeviceNumber, FALSE, FALSE); // basic info will suffice
    _AsrpErrExitCode(!result, status, GetLastError());
    _AsrpErrExitCode(!(pLocalDisk->pDriveLayoutEx), status, ERROR_SUCCESS);

    //
    //
    //
    offset = sizeof(ASRFMT_CLUSTER_VOLUMES_TABLE) +
        (sizeof(ASRFMT_CLUSTER_VOLUME_INFO) * (pLocalDisk->pDriveLayoutEx->PartitionCount - 1));
    pTable = (PASRFMT_CLUSTER_VOLUMES_TABLE) lpOutBuffer;

    if ((!lpOutBuffer) || (offset > nOutBufferSize)) {
        bufferFull = TRUE;
    }

    if (!bufferFull) {

        if (PARTITION_STYLE_MBR == pLocalDisk->pDriveLayoutEx->PartitionStyle) {
            pTable->DiskSignature = pLocalDisk->pDriveLayoutEx->Mbr.Signature;
        }
        else {
            //
            // At the moment, only MBR disks are cluster shared disks, and so
            // we don't handle GPT disks here.  If GPT disks are allowed to
            // be on a shared bus in a cluster, change this.
            //
            _AsrpErrExitCode(FALSE, status, ERROR_SUCCESS);
        }

        pTable->NumberOfEntries = pLocalDisk->pDriveLayoutEx->PartitionCount;
    }


    for (index = 0; index < pLocalDisk->pDriveLayoutEx->PartitionCount; index++) {

        currentPartitionEx = &(pLocalDisk->pDriveLayoutEx->PartitionEntry[index]);
        mountPointsOut = NULL;
        foundGuid = FALSE;

        //
        // For each partition, AsrpGetMountPoints gives a list of all mount points,
        // then use that to AsrpFmtGetVolumeDetails
        //

        // get the volumeGuid

        if (!(currentPartitionEx->PartitionNumber)) {
            //
            // Container partitions have partitionNumber = 0, and have no volume Guids.
            //
            continue;
        }

        memset(volumeGuid, 0, (MAX_PATH + 1) * sizeof(WCHAR));
        swprintf(devicePath,
            ASR_WSZ_DEVICE_PATH_FORMAT,
            pLocalDisk->DeviceNumber,
            currentPartitionEx->PartitionNumber
            );

        result = AsrpGetMountPoints(
            devicePath,
            (wcslen(devicePath) + 1)* sizeof(WCHAR),    // including \0, in bytes
            &mountPointsOut
            );
        if (!result || !(mountPointsOut)) {
            continue;
        }

        //
        // Go through the list of mount points, and pick out one that
        // looks like a volume Guid (starts with \??\Volume)
        //
        cbLinks = sizeof(WCHAR);  // \0 at the end
        for (i = 0; i < mountPointsOut->NumberOfMountPoints; i++) {

            PWSTR linkName = (PWSTR) (
                ((LPBYTE) mountPointsOut) +
                mountPointsOut->MountPoints[i].SymbolicLinkNameOffset
                );

            USHORT sizeLinkName = (UINT) (mountPointsOut->MountPoints[i].SymbolicLinkNameLength);

            if (!wcsncmp(ASR_WSZ_VOLUME_PREFIX, linkName, wcslen(ASR_WSZ_VOLUME_PREFIX)) &&
                !foundGuid) {
                wcsncpy(volumeGuid, linkName, sizeLinkName / sizeof(WCHAR));
                foundGuid = TRUE;
            }

            cbLinks += sizeLinkName + (USHORT) sizeof(WCHAR);
        }

        //
        // GetDriveType needs the volume guid in the dos-name-space, while the
        // mount manager gives the volume guid in the nt-name-space.  Convert
        // the name by changing the \??\ at the beginning to \\?\, and adding
        // a back-slash at the end.
        //
        cchGuid = wcslen(volumeGuid);
        volumeGuid[1] = L'\\';
        volumeGuid[cchGuid] = L'\\';    // Trailing back-slash
        volumeGuid[cchGuid+1] = L'\0';

        driveType = GetDriveTypeW(volumeGuid);
        //
        // Get the FS Label, cluster size, and so on.
        //
        result = AsrpFmtGetVolumeDetails(volumeGuid,
            fileSystemName,
            MAX_PATH + 1,
            volumeLabel,
            MAX_PATH + 1,
            &clusterSize
            );
        if (!result) {
            continue;
        }

        cbFsName = wcslen(fileSystemName) * sizeof(WCHAR);
        cbLabel = wcslen(volumeLabel) * sizeof(WCHAR);

        if (bufferFull) {
            offset += (cbFsName + cbLabel + cbLinks);
        }
        else {
            if (offset + cbFsName + cbLabel + cbLinks > nOutBufferSize) {
                bufferFull = TRUE;
            }
            else {

                if (cbFsName) {
                    CopyMemory(((LPBYTE)lpOutBuffer + offset),
                        fileSystemName,
                        cbFsName
                        );
                    pTable->VolumeInfoEntry[index].FsNameOffset = offset;
                    pTable->VolumeInfoEntry[index].FsNameLength = cbFsName;
                    offset += cbFsName;
                }

                if (cbLabel) {
                    CopyMemory(((LPBYTE)lpOutBuffer + offset),
                        volumeLabel,
                        cbLabel
                        );
                    pTable->VolumeInfoEntry[index].LabelOffset = offset;
                    pTable->VolumeInfoEntry[index].LabelLength = cbLabel;
                    offset += cbLabel;
                }

                //
                // Copy the symbolic links, separated by zeroes
                //
                if (mountPointsOut->NumberOfMountPoints > 0) {
                    pTable->VolumeInfoEntry[index].SymbolicNamesOffset = offset;
                }

                for (i = 0; i < mountPointsOut->NumberOfMountPoints; i++) {

                    PWSTR linkName = (PWSTR) (
                        ((LPBYTE) mountPointsOut) +
                        mountPointsOut->MountPoints[i].SymbolicLinkNameOffset
                        );

                    UINT sizeLinkName = (UINT) (mountPointsOut->MountPoints[i].SymbolicLinkNameLength);

                    CopyMemory(((LPBYTE)lpOutBuffer + offset),
                        linkName,
                        sizeLinkName
                        );
                    offset += (sizeLinkName + sizeof(WCHAR));
                }

                offset += sizeof(WCHAR);   // second \0 at the end
                pTable->VolumeInfoEntry[index].SymbolicNamesLength = cbLinks;

                pTable->VolumeInfoEntry[index].driveType = driveType;
                pTable->VolumeInfoEntry[index].PartitionNumber = currentPartitionEx->PartitionNumber;
                pTable->VolumeInfoEntry[index].dwClusterSize = clusterSize;
            }
        }

        _AsrpHeapFree(mountPointsOut);

    }

    if (lpBytesReturned) {
        *lpBytesReturned = offset;
    }

EXIT:
    AsrpFreeStateInformation(&pLocalDisk, NULL);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\asrpriv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

File Name:

    asrpriv.c

Abstract:

    Private header file containing definitions and function 
    prototypes for items used across the ASR Files.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Revision History:
    
    27-May-2000 guhans  
        Moved common items from asr.c to asrpriv.h


--*/


#ifndef _INC_ASRPRIV_H_
#define _INC_ASRPRIV_H_

#include <ntddscsi.h>   // PSCSI_ADDRESS


//
// --------
// #defines and constants common to the ASR modules.
// --------
//

//
// Size of temporary buffers used in ASR.
//
#define ASR_BUFFER_SIZE                 4096

//
// Maximum length of \??\Volume{Guid}
//
#define ASR_CCH_MAX_VOLUME_GUID         64

//
// Maximum length of \Device\Harddisk1234\Partition1234
//
#define ASR_CCH_DEVICE_PATH_FORMAT      60
extern const WCHAR ASR_WSZ_DEVICE_PATH_FORMAT[];

//
// \??\Volume{
//
extern const WCHAR ASR_WSZ_VOLUME_PREFIX[];

extern const WCHAR ASR_SIF_SYSTEM_SECTION[];
extern const WCHAR ASR_SIF_BUSES_SECTION[];
extern const WCHAR ASR_SIF_MBR_DISKS_SECTION[];
extern const WCHAR ASR_SIF_GPT_DISKS_SECTION[];
extern const WCHAR ASR_SIF_MBR_PARTITIONS_SECTION[];
extern const WCHAR ASR_SIF_GPT_PARTITIONS_SECTION[];

typedef enum _SecurityAttributeType
{
    esatUndefined = 0,
    esatMutex,
    esatSemaphore,
    esatEvent,
    esatFile
} SecurityAttributeType;




//
// --------
// typedefs common to the ASR modules.
// --------
//

typedef struct _ASR_PTN_INFO {

    //
    // The GUID of the volume on this partition.  For 0x42 parititions,
    // this value is a blank string.
    //
    WCHAR       szVolumeGuid[ASR_CCH_MAX_VOLUME_GUID];

    //
    // next pointer in chain sorted by starting offset
    //
    struct _ASR_PTN_INFO    *pOffsetNext;   

    // 
    // next pointer in chain sorted by partition length
    //
    struct _ASR_PTN_INFO    *pLengthNext;   

    // 
    // The index into the PartitionEntry[] array
    //
    DWORD       SlotIndex;                  


    DWORD       ClusterSize;

    //
    // Special flags for the partition that we're interested in.
    // Currently, the values defined are
    //  0: not interesting
    //  1: Boot partition
    //  2: System partition
    //
    // Care must be taken that this partition flag is in sync with
    // the partition flags defined in setupdd.sys
    //
    USHORT      PartitionFlags;

    //
    // FAT, FAT32, NTFS 
    //
    UCHAR       FileSystemType;

    UCHAR       Reserved;

    //
    // The partition table entry for this partition.
    //
    PARTITION_INFORMATION_EX PartitionInfo;


} ASR_PTN_INFO, *PASR_PTN_INFO;


typedef struct _ASR_PTN_INFO_LIST {

    //
    // This list is sorted by the starting offset of the partitions
    //
    PASR_PTN_INFO    pOffsetHead;
    PASR_PTN_INFO    pOffsetTail;

    //
    // This chain is through the same list, but is sorted by the
    // partition lengths.
    //
    PASR_PTN_INFO    pLengthHead;
    PASR_PTN_INFO    pLengthTail;

    DWORD       numTotalPtns;

    DWORD       numExtendedPtns;

} ASR_PTN_INFO_LIST, *PASR_PTN_INFO_LIST;


//
// Info about each disk on the system.  An ASR_DISK_INFO
// struct will exist for each physical disk that exists
// on the system.
//
typedef struct _ASR_DISK_INFO {

    struct _ASR_DISK_INFO       *pNext;

    //
    // Device Path used to open the Disk.
    // Obtained from SetupDiGetDeviceInterfaceDetail
    //
    PWSTR                       DevicePath;

    //
    // Partition layout information for partitions on the disk
    //
    PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx;

    //
    // Geometry: obtained from IOCTL_GET_DRIVE_GEOMETRY call
    //
    PDISK_GEOMETRY              pDiskGeometry;

    //
    //
    // Information about partition 0 = the entire disk
    //
    PPARTITION_INFORMATION_EX   pPartition0Ex;

    //
    // Additional Information about the partitions, including volume Guid, FS-Type, etc
    //
    PASR_PTN_INFO               PartitionInfoTable;

    PSCSI_ADDRESS               pScsiAddress;

    // For sif disks, this points to the physical disk they've been assigned
    // to, and vice versa.  Used only at restore time.
    //
    struct _ASR_DISK_INFO       *AssignedTo;

    DWORD                       sizeDriveLayoutEx;
    DWORD                       sizeDiskGeometry;
    DWORD                       sizePartition0Ex;
    DWORD                       sizePartitionInfoTable;

    //
    // Device number for disk, constant through sessions
    //
    ULONG                       DeviceNumber;

    ULONG                       SifDiskKey;


    ULONG                       SifBusKey;

    DEVINST                     ParentDevInst;

    //
    // Flag on whether this disk is Critical.  At backup time, the backup
    // app provides us with this info.  At restore time, the Critical disks
    // are expected to be restored by textmode Setup, before
    // RestoreNonCriticalDisks is called.  Critical disks are not
    // re-partitioned by RestoreNonCriticalDisks.
    //
    BOOL                        IsCritical;

    //
    // A flag set to TRUE (at restore time) if a disk has the same signature
    // (or DiskId, for GPT disks) as specified in asr.sif, and if all the
    // partitions specified in asr.sif exist.  Intact disks are not re-partitioned
    // by RestoreNonCriticalDisks.
    //
    BOOL                        IsIntact;

    //
    // If the struct is packed
    //
    BOOL                        IsPacked;

    BOOL                        IsClusterShared;

    BOOL                        IsAligned;

    //
    // This is needed at restore time, since the signature is read in before
    // the drive layout is created (and we need a temporary holding place).
    //
    DWORD                       TempSignature;

    WORD                        wReserved;
    //
    // Information about the bus this disk is on.  This is only
    // used to group all the disks on a bus together.
    //
    STORAGE_BUS_TYPE            BusType;

    //
    // GPT or MBR
    //
    PARTITION_STYLE             Style;


} ASR_DISK_INFO, *PASR_DISK_INFO;


//
// Info about the system--only one struct exists globally.
//
typedef struct _ASR_SYSTEM_INFO {
    //
    // Boot (Windows) Directory
    //
    PWSTR   BootDirectory;

    //
    // OsLoader Path
    //
    PWSTR   SystemPath;

    //
    // Platform = x86 or ia64
    //
    PWSTR   Platform;

    // Name of the backup app
    // Passed in by backup app
 //   PWSTR  Provider;

    PWSTR   pwReserved;

    //
    // Disk Auto-extension:
    // Passed in by backup app
    //
    BOOL AutoExtendEnabled;

    DWORD   sizeComputerName;
    //
    // Obtained from GetComputerName
    //
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    //
    // Obtained from GetOsVersionEx
    //
    OSVERSIONINFOEX   OsVersionEx;

    //
    // TimeZone info we save and restore
    //
    TIME_ZONE_INFORMATION TimeZoneInformation;


} ASR_SYSTEM_INFO, *PASR_SYSTEM_INFO;


//
// --------
// Macros common to the ASR modules.
// --------
//

//
//  Macro Description:
//      This macro wraps calls that are expected to return SUCCESS (retcode).
//      If ErrorCondition occurs, it sets the LocalStatus to the ErrorCode
//      passed in, calls SetLastError() to set the Last Error to ErrorCode,
//      and jumps to the EXIT label in the calling function
//
//  Arguments:
//      ErrorCondition    // Result of some function call or conditional expression.
//      LocalStatus       // Status variable in the calling function
//      LONG ErrorCode    // An ErrorCode specific to the error and calling function
//
#define _AsrpErrExitCode( ErrorCondition, LocalStatus, ErrorCode )  {   \
                                                                        \
    if ((BOOL) ErrorCondition) {                                        \
                                                                        \
        LocalStatus = (DWORD) ErrorCode;                                \
                                                                        \
        SetLastError((DWORD) ErrorCode);                                \
                                                                        \
        goto EXIT;                                                      \
    }                                                                   \
}


// 
// Simple macro to check a pointer, free it if non-NULL, and set it to NULL.
// 
#define _AsrpHeapFree( p )              \
    if ( p ) {                          \
        HeapFree(heapHandle, 0L, p);   \
        p = NULL;                       \
    }


//
// Simple macro to check if a handle is valid and close it
//
#define _AsrpCloseHandle( h )   \
    if ((h) && (INVALID_HANDLE_VALUE != h)) {   \
        CloseHandle(h);         \
        h = NULL;               \
    }


#define _AsrpIsVolumeGuid(data, numBytes)                                 \
    (                                                                   \
        ((96 == numBytes) || ((98 == numBytes) && data[48] == '\\')) &&     \
        (!_wcsnicmp(L"\\??\\Volume{", data, 11)) &&                     \
        L'-' == data[19] &&                                             \
        L'-' == data[24] &&                                             \
        L'-' == data[29] &&                                             \
        L'-' == data[34] &&                                             \
        L'}' == data[47]                                                \
    )



//
// --------
// debug #defines
// --------
//

#define _asrerror   THIS_MODULE, __LINE__, DPFLTR_ERROR_LEVEL
#define _asrwarn    THIS_MODULE, __LINE__, DPFLTR_WARNING_LEVEL
#define _asrlog     THIS_MODULE, __LINE__, DPFLTR_TRACE_LEVEL

//
// In pre-release mode, let's log everything so it's easier to debug
//
#ifdef PRERELEASE
#define _asrinfo    THIS_MODULE, __LINE__, DPFLTR_TRACE_LEVEL
#else
#define _asrinfo    THIS_MODULE, __LINE__, DPFLTR_INFO_LEVEL
#endif

//
// --------
// routines common to the ASR modules.
// --------
//

//
// Implemented in asrback.c
//

BOOL
AsrpConstructSecurityAttributes(
    PSECURITY_ATTRIBUTES  psaSecurityAttributes,
    SecurityAttributeType eSaType,
    BOOL                  bIncludeBackupOperator
    );

VOID 
AsrpCleanupSecurityAttributes(
    PSECURITY_ATTRIBUTES psaSecurityAttributes
    );

BOOL
AsrpGetMountPoints(
    IN PCWSTR       DeviceName,
    IN CONST DWORD  SizeDeviceName,
    PMOUNTMGR_MOUNT_POINTS  *pMountPointsOut        // caller must free this
    );
    
BOOL
AsrpInitLayoutInformation(
    IN CONST PASR_SYSTEM_INFO pSystemInfo,
    IN OUT PASR_DISK_INFO pDiskList,
    OUT PULONG MaxDeviceNumber OPTIONAL,
    IN BOOL AllDetailsForLocalDisks,
    IN BOOL AllDetailsForOfflineClusteredDisks
    );

BOOL
AsrpInitDiskInformation(
    OUT PASR_DISK_INFO   *ppDiskList
    );

BOOL
AsrpFreeNonFixedMedia(
    IN OUT PASR_DISK_INFO *ppDiskList
    );

VOID
AsrpFreeStateInformation(
    IN OUT PASR_DISK_INFO   *ppDiskList,
    IN OUT PASR_SYSTEM_INFO pSystemInfo
    );

VOID
AsrpFreePartitionList(
    IN OUT PASR_PTN_INFO_LIST *ppPtnList
    );


//
// Implemented in asrclus.c
//
BOOL
AsrpIsOfflineClusteredDisk(
    IN CONST HANDLE hDisk
    );

BOOL
AsrpInitClusterSharedDisks(
    IN PASR_DISK_INFO OriginalDiskList
    );


//
// Implemented in setupasr.c
//
PWSTR   // must be freed by caller
AsrpExpandEnvStrings(
    IN CONST PCWSTR OriginalString
    );

BOOL
AsrIsEnabled(VOID);

VOID
AsrpInitialiseLogFile();

VOID
AsrpInitialiseErrorFile();

VOID
AsrpPrintDbgMsg(
    IN CONST char Module,
    IN CONST ULONG Line,
    IN CONST ULONG MesgLevel,
    IN PCSTR FormatString,
    ...);

VOID
AsrpCloseLogFiles();


#endif  // _INC_ASRPRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\billbrd.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    billbrd.c

Abstract:

    Routines for displaying Windows that are static in nature.

Author:

    Ted Miller (tedm) 8-Jun-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop


//
// Define structure we pass around to describe a billboard.
//
typedef struct _BILLBOARD_PARAMS {
    UINT MessageId;
    va_list *arglist;
    HWND Owner;
    DWORD NotifyThreadId;
} BILLBOARD_PARAMS, *PBILLBOARD_PARAMS;

//
// Custom window messages
//
#define WMX_BILLBOARD_DISPLAYED     (WM_USER+243)
#define WMX_BILLBOARD_TERMINATE     (WM_USER+244)

#define ID_REBOOT_TIMER         10


//
// Import the entry point used to check whether setup is executing within an
// ASR context.
//

extern BOOL
AsrIsEnabled( VOID );


INT_PTR
BillboardDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    static BOOL Initializing;
    HWND Animation = GetDlgItem(hdlg,IDA_SETUPINIT);
    static HANDLE   hBitmap;
    static HCURSOR  hCursor;


    switch(msg) {

    case WM_INITDIALOG:
        {
            PBILLBOARD_PARAMS BillParams;
            PWSTR p;
            BOOL b;


            BillParams = (PBILLBOARD_PARAMS)lParam;

            if(BillParams->MessageId == MSG_INITIALIZING) {
                Initializing = TRUE;
                b = TRUE;
                hCursor = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
                ShowCursor( TRUE );
                Animate_Open(Animation,MAKEINTRESOURCE(IDA_SETUPINIT));
                if (ProductType == PRODUCT_WORKSTATION) 
                {
                    hBitmap = LoadBitmap (MyModuleHandle, MAKEINTRESOURCE(IDB_INIT_WORKSTATION));
                }
                else
                {
                    hBitmap = LoadBitmap (MyModuleHandle, MAKEINTRESOURCE(IDB_INIT_SERVER));
                }
                SendDlgItemMessage(hdlg,IDC_BITMAP,STM_SETIMAGE,IMAGE_BITMAP,(LPARAM)hBitmap);
            } else {
                Initializing = FALSE;
                if(p = RetrieveAndFormatMessageV(SETUPLOG_USE_MESSAGEID,
                    BillParams->MessageId,BillParams->arglist)) {

                    b = SetDlgItemText(hdlg,IDT_STATIC_1,p);
                    MyFree(p);
                } else {
                    b = FALSE;
                }
            }


            if(b) {
                //
                // Center the billboard relative to the window that owns it.
                //
                // if we have the BB window, do the positioning on that. 
                // MainWindowHandle point to that window
                //
                if (GetBBhwnd())
                    CenterWindowRelativeToWindow(hdlg, MainWindowHandle, FALSE);
                else
                    pSetupCenterWindowRelativeToParent(hdlg);
                //
                // Post ourselves a message that we won't get until we've been
                // actually displayed on the screen. Then when we process that message,
                // we inform the thread that created us that we're up. Note that
                // once that notification has been made, the BillParams we're using
                // now will go away since they are stored in local vars (see
                // DisplayBillboard()).
                //
                PostMessage(hdlg,WMX_BILLBOARD_DISPLAYED,0,(LPARAM)BillParams->NotifyThreadId);
                //
                // Tell Windows not to process this message.
                //
                return(FALSE);
            } else {
                //
                // We won't post the message, but returning -1 will get the
                // caller of DialogBox to post it for us.
                //
                EndDialog(hdlg,-1);
            }
        }
        break;

    case WMX_BILLBOARD_DISPLAYED:

        if(Initializing) {
            Animate_Play(Animation,0,-1,-1);
        }

        PostThreadMessage(
            (DWORD)lParam,
            WMX_BILLBOARD_DISPLAYED,
            TRUE,
            (LPARAM)hdlg
            );

        break;

    case WMX_BILLBOARD_TERMINATE:

        if(Initializing) {
            SetCursor( hCursor );
            ShowCursor( FALSE );
            Animate_Stop(Animation);
            Animate_Close(Animation);
            DeleteObject(hBitmap);
        }
        EndDialog(hdlg,0);
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}


DWORD
BillboardThread(
    IN PVOID ThreadParam
    )
{
    PBILLBOARD_PARAMS BillboardParams;
    INT_PTR i;

    BillboardParams = ThreadParam;

    //
    // For the "initializing" case, we use a different dialog.
    //
    if( AsrIsEnabled() ) {
        i = DialogBoxParam(
                        MyModuleHandle,
                        (BillboardParams->MessageId == MSG_INITIALIZING) ?
                        MAKEINTRESOURCE(IDD_SETUPINIT_ASR) :
                        MAKEINTRESOURCE(IDD_BILLBOARD1),
                        BillboardParams->Owner,
                        BillboardDlgProc,
                        (LPARAM)BillboardParams
                        );
    } else {
        i = DialogBoxParam(
                        MyModuleHandle,
                        (BillboardParams->MessageId == MSG_INITIALIZING) ?
                        MAKEINTRESOURCE(IDD_SETUPINIT) :
                        MAKEINTRESOURCE(IDD_BILLBOARD1),
                        BillboardParams->Owner,
                        BillboardDlgProc,
                        (LPARAM)BillboardParams
                        );
    }

    //
    // If the dialog box call failed, we have to tell the
    // main thread about it here. Otherwise the dialog proc
    // tells the main thread.
    //
    if(i == -1) {
        PostThreadMessage(
            BillboardParams->NotifyThreadId,
            WMX_BILLBOARD_DISPLAYED,
            FALSE,
            (LPARAM)NULL
            );
    }

    return(0);
}


HWND
DisplayBillboard(
    IN HWND Owner,
    IN UINT MessageId,
    ...
    )
{
    HANDLE ThreadHandle;
    DWORD ThreadId;
    BILLBOARD_PARAMS ThreadParams;
    va_list arglist;
    HWND hwnd;
    MSG msg;

    hwnd = NULL;
    // If we have a billboard, we should not need this. dialog.
    if (GetBBhwnd() == NULL)
    {
        va_start(arglist,MessageId);

        //
        // The billboard will exist in a separate thread so it will
        // always be responsive.
        //
        ThreadParams.MessageId = MessageId;
        ThreadParams.arglist = &arglist;
        ThreadParams.Owner = Owner;
        ThreadParams.NotifyThreadId = GetCurrentThreadId();

        ThreadHandle = CreateThread(
                            NULL,
                            0,
                            BillboardThread,
                            &ThreadParams,
                            0,
                            &ThreadId
                            );

        if(ThreadHandle) {
            //
            // Wait for the billboard to tell us its window handle
            // or that it failed to display the billboard dialog.
            //
            do {
                GetMessage(&msg,NULL,0,0);
                if(msg.message == WMX_BILLBOARD_DISPLAYED) {
                    if(msg.wParam) {
                        hwnd = (HWND)msg.lParam;
                        Sleep(1500);        // let the user see it even on fast machines
                    }
                } else {
                    DispatchMessage(&msg);
                }
            } while(msg.message != WMX_BILLBOARD_DISPLAYED);

            CloseHandle(ThreadHandle);
        }

        va_end(arglist);
    }
    else
    {
        // Start BB text
        StartStopBB(TRUE);
    }
    return(hwnd);
}


VOID
KillBillboard(
    IN HWND BillboardWindowHandle
    )
{
    if(BillboardWindowHandle && IsWindow(BillboardWindowHandle)) {
        PostMessage(BillboardWindowHandle,WMX_BILLBOARD_TERMINATE,0,0);
    }
}


INT_PTR
DoneDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    PWSTR p;
    static UINT Countdown;

    switch(msg) {

    case WM_INITDIALOG:

        // if we have the BB window, do the positioning on that. MainWindowHandle point to that window
        if (GetBBhwnd())
            CenterWindowRelativeToWindow(hdlg, MainWindowHandle, FALSE);
        else
            pSetupCenterWindowRelativeToParent(hdlg);

        SendDlgItemMessage(
            hdlg,
            IDOK,
            BM_SETIMAGE,
            0,
            (LPARAM)LoadBitmap(MyModuleHandle,MAKEINTRESOURCE(IDB_REBOOT))
            );

        if(p = RetrieveAndFormatMessage(NULL,(UINT)lParam)) {
            SetDlgItemText(hdlg,IDT_STATIC_1,p);
            MyFree(p);
        }

        Countdown = 15 * 10;
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETRANGE,0,MAKELONG(0,Countdown));
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETSTEP,1,0);
        SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_SETPOS,0,0);
        SetTimer(hdlg,ID_REBOOT_TIMER,100,NULL);

        SetFocus(GetDlgItem(hdlg,IDOK));
        return(FALSE);

    case WM_TIMER:

        Countdown--;

        if(Countdown) {
            SendDlgItemMessage(hdlg,IDC_PROGRESS1,PBM_STEPIT,0,0);
        } else {
            KillTimer(hdlg,ID_REBOOT_TIMER);
            DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));
            EndDialog(hdlg,0);
        }

        break;

    case WM_COMMAND:

        if((HIWORD(wParam) == BN_CLICKED) && (LOWORD(wParam) == IDOK)) {
            KillTimer(hdlg,ID_REBOOT_TIMER);
            DeleteObject((HGDIOBJ)SendDlgItemMessage(hdlg,IDOK,BM_GETIMAGE,0,0));
            EndDialog(hdlg,0);
        } else {
            return(FALSE);
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

typedef BOOL (CALLBACK *STOPBILLBOARD)();
typedef BOOL (CALLBACK *STARTBILLBOARD)();
typedef BOOL (WINAPI* SETTIMEESTIMATE)(LPCTSTR szText);
typedef BOOL (WINAPI* SETPROGRESSTEXT)(LPCTSTR szText);
typedef BOOL (WINAPI* SETINFOTEXT)(LPCTSTR szText);
typedef LRESULT (WINAPI* PROGRESSGAUGEMSG)(UINT msg, WPARAM wparam, LPARAM lparam);
typedef BOOL (WINAPI* SHOWPROGRESSGAUGEWINDOW)(UINT uiShow);

BOOL BB_ShowProgressGaugeWnd(UINT nCmdShow)
{
    static SHOWPROGRESSGAUGEWINDOW fpShowGauge = NULL;
    BOOL bRet = FALSE;

    if (fpShowGauge == NULL)
    {
        if (hinstBB)
        {
            fpShowGauge = (SHOWPROGRESSGAUGEWINDOW )GetProcAddress(hinstBB, "ShowProgressGaugeWindow");
        }
    }
    if (fpShowGauge != NULL)
    {
        bRet = fpShowGauge(nCmdShow);
    }
    return bRet;
}
LRESULT BB_ProgressGaugeMsg(UINT msg, WPARAM wparam, LPARAM lparam)
{
    static PROGRESSGAUGEMSG fpProgressGaugeMsg = NULL;
    LRESULT lresult = 0;

    if (fpProgressGaugeMsg == NULL)
    {
        if (hinstBB)
        {
            fpProgressGaugeMsg = (PROGRESSGAUGEMSG )GetProcAddress(hinstBB, "ProgressGaugeMsg");
        }
    }
    if (fpProgressGaugeMsg != NULL)
    {
        lresult = fpProgressGaugeMsg(msg, wparam, lparam);
    }
    return lresult;
}
void BB_SetProgressText(LPCTSTR szText)
{
    static SETPROGRESSTEXT fpSetProgressText = NULL;
    if (fpSetProgressText == NULL)
    {
        if (hinstBB)
        {
            fpSetProgressText = (SETPROGRESSTEXT )GetProcAddress(hinstBB, "SetProgressText");
        }
    }
    if (fpSetProgressText != NULL)
    {
        fpSetProgressText(szText);
    }
}
void BB_SetInfoText(LPTSTR szText)
{
    static SETINFOTEXT fpSetInfoText = NULL;
    if (fpSetInfoText == NULL)
    {
        if (hinstBB)
        {
            fpSetInfoText = (SETINFOTEXT )GetProcAddress(hinstBB, "SetInfoText");
        }
    }
    if (fpSetInfoText != NULL)
    {
        fpSetInfoText(szText);
    }
}
void BB_SetTimeEstimateText(LPTSTR szText)
{
    static SETTIMEESTIMATE fpSetTimeEstimate = NULL;
    if (fpSetTimeEstimate == NULL)
    {
        if (hinstBB)
        {
            fpSetTimeEstimate = (SETTIMEESTIMATE)GetProcAddress(hinstBB, "SetTimeEstimate");
        }
    }
    if (fpSetTimeEstimate != NULL)
    {
        fpSetTimeEstimate(szText);
    }
}

BOOL StartStopBB(BOOL bStart)
{
    static STARTBILLBOARD fpStart = NULL;
    static STOPBILLBOARD fpStop = NULL;
    BOOL bRet = FALSE;

    if ((fpStart == NULL) || (fpStop == NULL))
    {
        if (hinstBB)
        {
            fpStop = (STARTBILLBOARD )GetProcAddress(hinstBB, "StopBillBoard");
            fpStart = (STOPBILLBOARD )GetProcAddress(hinstBB, "StartBillBoard");
        }
    }
    if ((fpStart != NULL) && (fpStop != NULL))
    {
        if (bStart)
            bRet = fpStart();
        else
            bRet = fpStop();

    }
    return bRet;
}

LRESULT ProgressGaugeMsgWrapper(UINT msg, WPARAM wparam, LPARAM lparam)
{
    static DWORD MsecPerProcessTick;
    static DWORD PreviousRemainingTime = 0;
    static DWORD RemainungTimeMsecInThisPhase = 0;
    static int  iCurrentPos = 0;
    static int  iMaxPosition = 0;
    static int  iStepSize = 0;

    static UINT PreviousPhase = Phase_Unknown;
    static BOOL IgnoreSetRange = FALSE;
    static BOOL IgnoreSetPos  = FALSE;

    DWORD dwDeltaTicks = 0;
    switch (msg)
    {
        case WMX_PROGRESSTICKS:
            // If we get a WMX_PROGRESSTICKS before a PBM_SETRANGE, ignore the set range
            // This should be use if the progress bar only takes up x% of the whole bar.
            // In this case the phase sends PBM_SETRANGE and a PBM_SETPOS to setup the
            // progress values for it's part of the gauge.
            IgnoreSetRange = TRUE;
            if (PreviousPhase != CurrentPhase)
            {
                PreviousPhase = CurrentPhase;
                iCurrentPos = 0;
                iMaxPosition = (int)wparam;
                iStepSize = 10;

                MsecPerProcessTick = ((SetupPhase[CurrentPhase].Time*1000)/(iMaxPosition - iCurrentPos) )+ 1;
                RemainungTimeMsecInThisPhase = (SetupPhase[CurrentPhase].Time * 1000);
                PreviousRemainingTime = RemainungTimeMsecInThisPhase;
            }
            else
            {
                // what to do if the same phase send more then one set range.
                // don't change the remaining time, only recal the msecperprogresstick
                // 
                iCurrentPos = 0;
                iMaxPosition = (int)wparam;
                iStepSize = 10;
                MsecPerProcessTick = (RemainungTimeMsecInThisPhase /(iMaxPosition - iCurrentPos) )+ 1;
            }
            break;

        case PBM_SETPOS:
            {
                UINT uiCurrentPos;
                if (!IgnoreSetPos)
                {
                    int iDeltaPos = 0;
                    // Find out where the current position of the gasgauge is.
                    // The difference is the #ticks we use to reduce the time estimate
            
                    uiCurrentPos = (UINT)BB_ProgressGaugeMsg(PBM_GETPOS, 0, 0);
                    // See if there is a difference in the current position and the one 
                    // we think we are in.
                    // Only if the new position is greater then the current one 
                    // calc the difference and substract from remaining time.
                    if ((UINT)wparam > uiCurrentPos)
                    {
                        iDeltaPos = (UINT)wparam - uiCurrentPos;
                        iCurrentPos += iDeltaPos;
                        // Only substract if more time left
                        if ((iDeltaPos * MsecPerProcessTick) < RemainungTimeMsecInThisPhase)
                        {
                            RemainungTimeMsecInThisPhase -= (iDeltaPos * MsecPerProcessTick);
                        }
                        else
                        {
                            RemainungTimeMsecInThisPhase = 0;
                        }
                        UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
                    }
                }
                IgnoreSetPos = FALSE;
            }
            break;

        case PBM_SETRANGE:
        case PBM_SETRANGE32:
            // did the phase not send the private message above
            if (!IgnoreSetRange)
            {
                // Are we not in the same phase?
                if (PreviousPhase != CurrentPhase)
                {
                    PreviousPhase = CurrentPhase;
                    // Get the new start and max position
                    if (msg == PBM_SETRANGE32)
                    {
                        iCurrentPos = (int)wparam;
                        iMaxPosition = (int)lparam;
                    }
                    else
                    {
                        iCurrentPos = LOWORD(lparam);
                        iMaxPosition = HIWORD(lparam);
                    }
                    iStepSize = 10;

                    // Calc the msec per tick and msec in this phase
                    MsecPerProcessTick = ((SetupPhase[CurrentPhase].Time*1000)/(iMaxPosition - iCurrentPos) )+ 1;
                    RemainungTimeMsecInThisPhase = (SetupPhase[CurrentPhase].Time * 1000);
                    PreviousRemainingTime = RemainungTimeMsecInThisPhase;
                }
                else
                {
                    // the same phase send more then one set range.
                    // 1. don't change the remaining time, only recal the msecperprogresstick
                    // 2. Ignore the next PBM_SETPOS message.
                    // 
                    // Get the new start and max position
                    if (msg == PBM_SETRANGE32)
                    {
                        iCurrentPos = (int)wparam;
                        iMaxPosition = (int)lparam;
                    }
                    else
                    {
                        iCurrentPos = LOWORD(lparam);
                        iMaxPosition = HIWORD(lparam);
                    }
                    iStepSize = 10;
                    MsecPerProcessTick = (RemainungTimeMsecInThisPhase /(iMaxPosition - iCurrentPos) )+ 1;
                    IgnoreSetPos = TRUE;
                }
            }
            else
            {
                // If we ignored the setrange, also ignore the first set pos.
                IgnoreSetPos = TRUE;
            }
            IgnoreSetRange = FALSE;
            break;

        case PBM_DELTAPOS:
            {
                int iDeltaPos = 0;
                // wparam has the # of ticks to move the gas gauge
                // make sure we don't over shoot the max posistion
                if ((iCurrentPos + (int)wparam) > iMaxPosition)
                {
                    iDeltaPos = (iMaxPosition - iCurrentPos);
                }
                else
                {
                    iDeltaPos = (int)wparam;
                }

                iCurrentPos += iDeltaPos;
                if ((iDeltaPos * MsecPerProcessTick) < RemainungTimeMsecInThisPhase)
                {
                    RemainungTimeMsecInThisPhase -= (iDeltaPos * MsecPerProcessTick);
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            break;

        case PBM_STEPIT:
            {
                int iDeltaPos = 0;
                //  make sure we don't over shoot the max posistion
                if ((iCurrentPos + iStepSize) > iMaxPosition)
                {
                    iDeltaPos = (iMaxPosition - iCurrentPos);
                }
                else
                {
                    iDeltaPos = iStepSize;
                }
                iCurrentPos += iDeltaPos;
                if ((iDeltaPos * MsecPerProcessTick) < RemainungTimeMsecInThisPhase)
                {
                    RemainungTimeMsecInThisPhase -= (iDeltaPos * MsecPerProcessTick);
                }
                else
                {
                    RemainungTimeMsecInThisPhase = 0;
                }
                UpdateTimeString(RemainungTimeMsecInThisPhase, &PreviousRemainingTime);
            }
            break;

        case PBM_SETSTEP:
            iStepSize = (int)wparam;
            break;
    }
            
    return BB_ProgressGaugeMsg(msg, wparam, lparam);
}

void UpdateTimeString(DWORD RemainungTimeMsecInThisPhase, 
                      DWORD *PreviousRemainingTime)
{
    // If the previous displayed time is 1 minute old, update the time remaining.
    if ((*PreviousRemainingTime >= 60000) && ((*PreviousRemainingTime - 60000) > RemainungTimeMsecInThisPhase))
    {
        // Substract one minute.
        RemainingTime -= 60;
        *PreviousRemainingTime = RemainungTimeMsecInThisPhase;
        SetRemainingTime(RemainingTime);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\clasprop.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    clasprop.c

Abstract:

    Routines for the following 'built-in' class property page providers:

        LegacyDriver

Author:

    Lonny McMichael 15-May-1997

--*/


#include "setupp.h"
#pragma hdrstop
#include <help.h>
#include <strsafe.h>

//
// Help Ids for legacy driver property page
//
#define idh_devmgr_driver_hidden_servicename    2480
#define idh_devmgr_driver_hidden_displayname    2481
#define idh_devmgr_driver_hidden_status         2482
#define idh_devmgr_driver_hidden_startbut       2483
#define idh_devmgr_driver_hidden_stopbut        2484
#define idh_devmgr_driver_hidden_startup        2485
#define idh_devmgr_devdrv_details               400400
#define idh_devmgr_driver_copyright             106130
#define idh_devmgr_driver_driver_files          106100
#define idh_devmgr_driver_provider              106110
#define idh_devmgr_driver_file_version          106120

const DWORD LegacyDriver_HelpIDs[]=
{
    IDC_STATIC_SERVICE_NAME, idh_devmgr_driver_hidden_servicename, 
    IDC_EDIT_SERVICE_NAME, idh_devmgr_driver_hidden_servicename, 
    IDC_STATIC_DISPLAY_NAME, idh_devmgr_driver_hidden_displayname,
    IDC_EDIT_DISPLAY_NAME, idh_devmgr_driver_hidden_displayname,
    IDC_STATIC_CURRENT_STATUS_STATIC, idh_devmgr_driver_hidden_status,
    IDC_STATIC_CURRENT_STATUS, idh_devmgr_driver_hidden_status,
    IDC_BUTTON_START, idh_devmgr_driver_hidden_startbut,
    IDC_BUTTON_STOP, idh_devmgr_driver_hidden_stopbut,
    IDC_COMBO_STARTUP_TYPE, idh_devmgr_driver_hidden_startup,
    IDC_LEGACY_DETAILS, idh_devmgr_devdrv_details,
    IDC_PROP_LEGACY_ICON, NO_HELP,
    IDC_PROP_LEGACY_DESC, NO_HELP,
    IDC_GROUP_CURRENT_STATUS, NO_HELP,
    IDC_GROUP_STARTUP_TYPE, NO_HELP,
    0, 0
};

const DWORD DriverFiles_HelpIDs[]=
{
    IDC_DRIVERFILES_ICON,           NO_HELP,
    IDC_DRIVERFILES_DESC,           NO_HELP,
    IDC_DRIVERFILES_FILES,          NO_HELP,
    IDC_DRIVERFILES_FILELIST,       idh_devmgr_driver_driver_files,
    IDC_DRIVERFILES_TITLE_PROVIDER, idh_devmgr_driver_provider,
    IDC_DRIVERFILES_PROVIDER,       idh_devmgr_driver_provider,
    IDC_DRIVERFILES_TITLE_COPYRIGHT,idh_devmgr_driver_copyright,
    IDC_DRIVERFILES_COPYRIGHT,      idh_devmgr_driver_copyright,
    IDC_DRIVERFILES_TITLE_VERSION,  idh_devmgr_driver_file_version,
    IDC_DRIVERFILES_VERSION,        idh_devmgr_driver_file_version,
    0, 0
};

#define SERVICE_BUFFER_SIZE         4096
#define MAX_SECONDS_UNTIL_TIMEOUT   30
#define SERVICE_WAIT_TIME           500
#define WAIT_TIME_SLOT              1
#define TRIES_COUNT                 5
#define START_LEGACY_DEVICE         0
#define STOP_LEGACY_DEVICE          1

//
// The only reason we have the DiskPropPageProvider and TapePropPageProvider
// APIs are so that the classes can get their icon out of syssetup.dll.
//
BOOL
DiskPropPageProvider(
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    //
    // No property pages to add for now
    //
    UNREFERENCED_PARAMETER(PropPageRequest);
    UNREFERENCED_PARAMETER(lpfnAddPropSheetPageProc);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}


BOOL
TapePropPageProvider(
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    )
{
    //
    // No property pages to add for now
    //
    UNREFERENCED_PARAMETER(PropPageRequest);
    UNREFERENCED_PARAMETER(lpfnAddPropSheetPageProc);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
//
// Driver Files popup dialog
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _DRIVERFILES_INFO {
    HDEVINFO         DeviceInfoSet;
    PSP_DEVINFO_DATA DeviceInfoData;
} DRIVERFILES_INFO, * PDRIVERFILES_INFO;

const TCHAR*  tszStringFileInfo = TEXT("StringFileInfo\\%04X%04X\\");
const TCHAR*  tszFileVersion = TEXT("FileVersion");
const TCHAR*  tszLegalCopyright = TEXT("LegalCopyright");
const TCHAR*  tszCompanyName = TEXT("CompanyName");
const TCHAR*  tszTranslation = TEXT("VarFileInfo\\Translation");
const TCHAR*  tszStringFileInfoDefault = TEXT("StringFileInfo\\040904B0\\");

BOOL
GetVersionInfo(
    IN  PTSTR FullPathName,
    OUT PTSTR Provider,
    IN  ULONG CchProviderSize,
    OUT PTSTR Copyright,
    IN  ULONG CchCopyrightSize,
    OUT PTSTR Version,
    IN  ULONG CchVersionSize
    )
{
    DWORD Size, dwHandle;
    TCHAR str[MAX_PATH];
    TCHAR strStringFileInfo[MAX_PATH];
    PVOID pVerInfo;

    Size = GetFileVersionInfoSize((LPTSTR)(LPCTSTR)FullPathName, &dwHandle);
    
    if (!Size) {
    
        return FALSE;
    }

    if ((pVerInfo = malloc(Size)) != NULL) {

        if (GetFileVersionInfo((LPTSTR)(LPCTSTR)FullPathName, dwHandle, Size, pVerInfo)) {
        
            //
            // get VarFileInfo\Translation
            //
            PVOID pBuffer;
            UINT Len;
            
            if (!VerQueryValue(pVerInfo, (LPTSTR)tszTranslation, &pBuffer, &Len)) {

                StringCchCopy(strStringFileInfo, 
                              SIZECHARS(strStringFileInfo), 
                              tszStringFileInfoDefault);
            
            } else {

                StringCchPrintf(strStringFileInfo, 
                                SIZECHARS(strStringFileInfo), 
                                tszStringFileInfo, *((WORD*)pBuffer), *(((WORD*)pBuffer) + 1));
            }
            
            if (SUCCEEDED(StringCchCopy(str, SIZECHARS(str), strStringFileInfo)) &&
                SUCCEEDED(StringCchCat(str, SIZECHARS(str), tszFileVersion)) &&
                VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len)) {
            
                StringCchCopy(Version, CchVersionSize, (LPTSTR)pBuffer);

                if (SUCCEEDED(StringCchCopy(str, SIZECHARS(str), strStringFileInfo)) &&
                    SUCCEEDED(StringCchCat(str, SIZECHARS(str), tszLegalCopyright)) &&
                    VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len)) {
                
                    StringCchCopy(Copyright, CchCopyrightSize, (LPTSTR)pBuffer);
                    
                    if (SUCCEEDED(StringCchCopy(str, SIZECHARS(str), strStringFileInfo)) &&
                        SUCCEEDED(StringCchCat(str, SIZECHARS(str), tszCompanyName)) &&
                        VerQueryValue(pVerInfo, (LPTSTR)(LPCTSTR)str, &pBuffer, &Len)) {
                    
                        StringCchCopy(Provider, CchProviderSize, (LPTSTR)pBuffer);
                    }
                }
            }
        }

        free(pVerInfo);

    }
    
    return TRUE;
}

BOOL
pDriverFilesGetServiceFilePath(
    HDEVINFO DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData,
    PTSTR ServiceFilePath,
    ULONG CchServiceFileSize
    )
{
    BOOL bReturn = FALSE;
    TCHAR ServiceName[MAX_PATH];
    SC_HANDLE hSCManager = NULL;
    SC_HANDLE hSCService = NULL;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;
    DWORD dwBytesNeeded, Size;
    BOOL bComposePathNameFromServiceName = TRUE;

    ServiceFilePath[0] = TEXT('\0');

    if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_SERVICE,
                                         NULL,
                                         (PBYTE)ServiceName,
                                         sizeof(ServiceName),
                                         NULL)) {

        try {
            //
            // Open the Service Control Manager
            //
            if ((hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ)) != NULL) {
                //
                // Try to open the service's handle
                //
                if ((hSCService = OpenService(hSCManager, ServiceName, GENERIC_READ)) != NULL) {
                    //
                    // Now, attempt to get the configuration
                    //
                    if ((!QueryServiceConfig(hSCService, NULL, 0, &dwBytesNeeded)) &&
                        (ERROR_INSUFFICIENT_BUFFER == GetLastError())) {

                        if ((lpqscBuf = (LPQUERY_SERVICE_CONFIG)malloc(dwBytesNeeded)) != NULL) {

                            if ((QueryServiceConfig(hSCService, lpqscBuf, dwBytesNeeded, &Size)) &&
                                (lpqscBuf->lpBinaryPathName[0] != TEXT('\0'))) {

                                if (GetFileAttributes(lpqscBuf->lpBinaryPathName) != 0xFFFFFFFF) {

                                    bReturn = TRUE;
                                    StringCchCopy(ServiceFilePath, CchServiceFileSize, lpqscBuf->lpBinaryPathName);
                                    bComposePathNameFromServiceName = FALSE;
                                }                                    
                            }                                                    

                            free(lpqscBuf);
                        }
                    }

                    CloseServiceHandle(hSCService);
                }                    

                CloseServiceHandle(hSCManager);
            }

            //
            // If we could not get the path name from the service then we will attempt
            // to find it ourselves
            //
            if (bComposePathNameFromServiceName) {

                TCHAR FullPathName[MAX_PATH];
                
                if (GetSystemDirectory(FullPathName, SIZECHARS(FullPathName)) &&
                    SUCCEEDED(StringCchCat(FullPathName, SIZECHARS(FullPathName), TEXT("\\drivers\\"))) &&
                    SUCCEEDED(StringCchCat(FullPathName, SIZECHARS(FullPathName), ServiceName)) &&
                    SUCCEEDED(StringCchCat(FullPathName, SIZECHARS(FullPathName), TEXT(".sys")))) {
                    
                    if (GetFileAttributes(FullPathName) != 0xFFFFFFFF) {
    
                        bReturn = TRUE;
                        StringCchCopy(ServiceFilePath, CchServiceFileSize, FullPathName);
                    }
                }
            }
        
        } except (EXCEPTION_EXECUTE_HANDLER)  {
            ;
        }
    }                           

    return(bReturn);
}

void
DriverFiles_ShowFileDetail(
    HWND hDlg
    )
{
    TCHAR DriverFile[MAX_PATH];
    TCHAR Provider[MAX_PATH];
    TCHAR Copyright[MAX_PATH];
    TCHAR Version[MAX_PATH];
    DWORD_PTR Index;

    if ((Index = SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_GETCURSEL, 0, 0)) != LB_ERR) {

        SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_GETTEXT, Index, (LPARAM)DriverFile);
        
        Provider[0] = TEXT('\0');
        Copyright[0] = TEXT('\0');
        Version[0] = TEXT('\0');

        GetVersionInfo(DriverFile,
                       Provider,
                       SIZECHARS(Provider),
                       Copyright,
                       SIZECHARS(Copyright),
                       Version,
                       SIZECHARS(Version));

        if (Provider[0] != TEXT('\0')) {

            SetDlgItemText(hDlg, IDC_DRIVERFILES_PROVIDER, Provider);
        }

        if (Version[0] != TEXT('\0')) {

            SetDlgItemText(hDlg, IDC_DRIVERFILES_VERSION, Version);
        }

        if (Copyright[0] != TEXT('\0')) {

            SetDlgItemText(hDlg, IDC_DRIVERFILES_COPYRIGHT, Copyright);
        }
    }
}

BOOL
DriverFiles_OnInitDialog(
    HWND    hDlg,
    HWND    FocusHwnd,
    LPARAM  lParam
    )
{
    PDRIVERFILES_INFO dfi = (PDRIVERFILES_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
    HICON ClassIcon;
    HICON OldIcon;
    TCHAR DeviceDescription[MAX_DEVICE_ID_LEN];
    TCHAR DriverName[MAX_PATH];

    UNREFERENCED_PARAMETER(FocusHwnd);

    dfi = (PDRIVERFILES_INFO)lParam;
    SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)dfi);

    //
    // Draw the interface: first the icon
    //
    if (SetupDiLoadClassIcon(&dfi->DeviceInfoData->ClassGuid, &ClassIcon, NULL)) {

        OldIcon = (HICON)SendDlgItemMessage(hDlg,
                                            IDC_DRIVERFILES_ICON,
                                            STM_SETICON,
                                            (WPARAM)ClassIcon,
                                            0);
        if (OldIcon) {
        
            DestroyIcon(OldIcon);
        }
    }
    
    //
    // Then the device name
    //
    if (SetupDiGetDeviceRegistryProperty(dfi->DeviceInfoSet,
                                         dfi->DeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         NULL,
                                         (PBYTE)DeviceDescription,
                                         MAX_DEVICE_ID_LEN,
                                         NULL)) {
                                         
        SetDlgItemText(hDlg, IDC_DRIVERFILES_DESC, DeviceDescription);
    }

    if ((pDriverFilesGetServiceFilePath(dfi->DeviceInfoSet, dfi->DeviceInfoData, DriverName, SIZECHARS(DriverName))) &&
        (DriverName[0] != TEXT('\0'))) {
    
        SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_ADDSTRING, 0, (LPARAM)DriverName);
    }

    SendMessage(GetDlgItem(hDlg, IDC_DRIVERFILES_FILELIST), LB_SETCURSEL, 0, 0);
    DriverFiles_ShowFileDetail(hDlg);

    return TRUE;
}

BOOL
DriverFiles_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    UNREFERENCED_PARAMETER(Xpos);
    UNREFERENCED_PARAMETER(Ypos);

    WinHelp(HwndControl,
            L"devmgr.hlp",
            HELP_CONTEXTMENU,
            (ULONG_PTR) DriverFiles_HelpIDs);

    return FALSE;
}

void
DriverFiles_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    UNREFERENCED_PARAMETER(ParentHwnd);

    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                L"devmgr.hlp",
                HELP_WM_HELP,
                (ULONG_PTR) DriverFiles_HelpIDs);
    }
}

void
DriverFiles_OnCommand(
    HWND hDlg,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    UNREFERENCED_PARAMETER(ControlHwnd);
    UNREFERENCED_PARAMETER(NotifyCode);

    switch (ControlId) {

    case IDOK:
    case IDCANCEL:
        EndDialog(hDlg, 0);
        break;

    case IDC_DRIVERFILES_FILELIST:
        if (ControlId == LBN_SELCHANGE) {

            DriverFiles_ShowFileDetail(hDlg);
        }
        break;
    }
}

INT_PTR
APIENTRY
DriverFiles_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {

    case WM_INITDIALOG:
        return DriverFiles_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_COMMAND:
        DriverFiles_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_CLOSE:
        EndDialog(hDlg, 0);
        break;

    case WM_CONTEXTMENU:
        return DriverFiles_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        DriverFiles_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;
    }

    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////
//
// Legacy Devices property page provider
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _LEGACY_PAGE_INFO {
    HDEVINFO                DeviceInfoSet;
    PSP_DEVINFO_DATA        DeviceInfoData;

    SC_HANDLE               hSCManager;         // Handle to the SC Manager
    SC_HANDLE               hService;           // The handle to the service
    DWORD                   dwStartType;        // The start type
    SERVICE_STATUS          ServiceStatus;      // Tells us if the service is started
    TCHAR                   ServiceName[MAX_DEVICE_ID_LEN];
    TCHAR                   DisplayName[MAX_PATH];
    DWORD                   NumDependentServices;
    LPENUM_SERVICE_STATUS   pDependentServiceList;

} LEGACY_PAGE_INFO, * PLEGACY_PAGE_INFO;

BOOL
DependentServices_OnInitDialog(
    HWND    hDlg,
    HWND    FocusHwnd,
    LPARAM  lParam
    )
{
    PLEGACY_PAGE_INFO   lpi;
    HWND                hWndListBox;
    DWORD               i;
    HICON               hicon = NULL;

    UNREFERENCED_PARAMETER(FocusHwnd);

    lpi = (PLEGACY_PAGE_INFO)lParam;
    SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)lpi);
    
    hicon = LoadIcon(NULL, IDI_WARNING);
    if (hicon != NULL) {
        SendDlgItemMessage(hDlg, IDC_ICON_WARN_SERVICES, STM_SETICON, (WPARAM)hicon, 0L);
        DestroyIcon(hicon);
    }

    hWndListBox = GetDlgItem(hDlg, IDC_LIST_SERVICES);

    for (i=0; i<lpi->NumDependentServices; i++) {
        SendMessage(hWndListBox, 
                    LB_ADDSTRING, 
                    0,
                    (LPARAM) lpi->pDependentServiceList[i].lpDisplayName
                    );
    }

    return TRUE;
}

INT_PTR
APIENTRY
DependentServicesDlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch(uMessage) {

    case WM_INITDIALOG:
        return DependentServices_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, 0);
        break;
    }

    return FALSE;
}

int
pLegacyDriverMapStateToName(
    IN DWORD dwServiceState
    )
{
    switch(dwServiceState) {
    
    case SERVICE_STOPPED:
        return IDS_SVC_STATUS_STOPPED;

    case SERVICE_STOP_PENDING:
        return IDS_SVC_STATUS_STOPPING;

    case SERVICE_RUNNING:
         return IDS_SVC_STATUS_STARTED;
    
    case SERVICE_START_PENDING:
        return IDS_SVC_STATUS_STARTING;

    case SERVICE_PAUSED:
        return IDS_SVC_STATUS_PAUSED;

    case SERVICE_PAUSE_PENDING:
        return IDS_SVC_STATUS_PAUSING;

    case SERVICE_CONTINUE_PENDING:
        return IDS_SVC_STATUS_RESUMING;

    default:
        return IDS_SVC_STATUS_UNKNOWN;
    }
}

VOID
pLegacyDriverInitializeStartButtons(
    IN HWND             hDlg,
    IN LPSERVICE_STATUS ServiceStatus
    )  
{
    //
    // Decide how to paint the two start/stop buttons
    //
    TCHAR       szStatus[MAX_PATH];

    //
    // Set the status text
    //
    if (LoadString(MyModuleHandle,
                   pLegacyDriverMapStateToName(ServiceStatus->dwCurrentState),
                   szStatus,
                   MAX_PATH)) {

        SetDlgItemText(hDlg, IDC_STATIC_CURRENT_STATUS, szStatus);
    }

    //
    // Decide if the service is started or stopped
    //
    if ((ServiceStatus->dwCurrentState == SERVICE_STOPPED) ) {
    
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);
        
    } else {
    
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), FALSE);
    }

    //
    // If the service doesn't accept stops, grey the stop
    // button
    //
    if (!(ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP)) {

        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);
    }

    return;
}

VOID
pLegacyDriverSetPropertyPageState(
    IN  HWND                hDlg,
    IN  PLEGACY_PAGE_INFO   lpi,
    IN  BOOL                ReadOnly
    )
{
    DWORD_PTR Index;
    DWORD_PTR ServiceStartType;
    TCHAR    szStatus[MAX_PATH];

    if (ReadOnly) {

        //
        // Disable everything
        //
        EnableWindow(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);
        
        //
        // Set the status text
        //
        if (LoadString(MyModuleHandle,
                       pLegacyDriverMapStateToName(lpi->ServiceStatus.dwCurrentState),
                       szStatus,
                       MAX_PATH)) {

            SetDlgItemText(hDlg, IDC_STATIC_CURRENT_STATUS, szStatus);
        }

    } else {
    
        Index = 0;

        while ((ServiceStartType = SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), 
                CB_GETITEMDATA, Index, 0)) != CB_ERR) {

            if (ServiceStartType == lpi->dwStartType) {

                SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), CB_SETCURSEL, Index, 0);
                break;
            }

            Index++;
        }                

        SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), CB_GETCURSEL, 0, 0);

        //
        // If the start type is SERVICE_DISABLED then gray out both the start
        // and stop buttons.
        //
        if (lpi->dwStartType == SERVICE_DISABLED) {
            
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_START), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_STOP), FALSE);

            //
            // Set the status text
            //
            if (LoadString(MyModuleHandle,
                           pLegacyDriverMapStateToName(lpi->ServiceStatus.dwCurrentState),
                           szStatus,
                           MAX_PATH)) {

                SetDlgItemText(hDlg, IDC_STATIC_CURRENT_STATUS, szStatus);
            }

        } else {

            pLegacyDriverInitializeStartButtons(hDlg, &lpi->ServiceStatus);
        }

    }

    return;
}

BOOL
pLegacyDriverCheckServiceStatus(
    IN     SC_HANDLE        hService,
    IN OUT LPSERVICE_STATUS ServiceStatus,
    IN     USHORT           ControlType
    )  
{
    DWORD   dwIntendedState;
    DWORD   dwCummulateTimeSpent = 0;


    if ((ControlType != START_LEGACY_DEVICE) && 
        (ControlType != STOP_LEGACY_DEVICE)) {
        return TRUE;
    }
    
    if (ControlType == START_LEGACY_DEVICE) {
        dwIntendedState = SERVICE_RUNNING;
        
    } else {
        dwIntendedState = SERVICE_STOPPED;
    }


    if (!QueryServiceStatus(hService, ServiceStatus)) {
        return FALSE;
    }

    while (ServiceStatus->dwCurrentState != dwIntendedState) {

        //
        // Wait for the specified interval
        //
        Sleep(SERVICE_WAIT_TIME);

        //
        // Check the status again
        //
        if (!QueryServiceStatus(hService, ServiceStatus)) {
            return FALSE;
        }
        
        //
        // OK, add a (generous) timeout here
        //
        dwCummulateTimeSpent += SERVICE_WAIT_TIME;
        if (dwCummulateTimeSpent > 1000 * MAX_SECONDS_UNTIL_TIMEOUT) {
            SetLastError(ERROR_SERVICE_REQUEST_TIMEOUT);
            return FALSE;
        }
    }

    //
    // If we are here we can return only TRUE
    //
    return TRUE;
}

VOID
pLegacyDriverDisplayErrorMsgBox(
    IN HWND hWnd,
    IN LPTSTR ServiceName,
    IN int ResId,
    IN DWORD ErrorCode
    )
{
    TCHAR TextBuffer[MAX_PATH * 4];
    PTCHAR ErrorMsg;

    if (LoadString(MyModuleHandle, ResId, TextBuffer, SIZECHARS(TextBuffer))) {

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          ErrorCode,
                          0,
                          (LPTSTR)&ErrorMsg,
                          0,
                          NULL
                          )) {

            StringCchCat(TextBuffer, SIZECHARS(TextBuffer), ErrorMsg);
            MessageBox(hWnd, TextBuffer, ServiceName, MB_OK);

            LocalFree(ErrorMsg);
        }
    }
}

VOID
pLegacyDriverOnStart(
    IN HWND hDlg
    )  
{
    PLEGACY_PAGE_INFO   lpi;
    HCURSOR hOldCursor;

    //
    // Retrieve the device data structure first
    //
    lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    try {

        if (!StartService(lpi->hService,
                          0,
                          NULL)) {


            pLegacyDriverDisplayErrorMsgBox(hDlg,
                                            lpi->DisplayName,
                                            IDS_SVC_START_ERROR,
                                            GetLastError()
                                            );
            goto clean0;
        }
        pLegacyDriverCheckServiceStatus(lpi->hService,
                                        &lpi->ServiceStatus, 
                                        START_LEGACY_DEVICE
                                        );

        clean0:
        
        //
        // Repaint the status part
        //
        pLegacyDriverSetPropertyPageState(hDlg, lpi, FALSE);


    }except  (EXCEPTION_EXECUTE_HANDLER) {

        lpi = lpi;
    }

    SetCursor(hOldCursor);

    return;
}

VOID
pLegacyDriverOnStop(
    IN HWND hDlg
    )  
{
    BOOL                    bStopServices = TRUE;
    DWORD                   Err;
    PLEGACY_PAGE_INFO       lpi;
    HCURSOR                 hOldCursor;
    DWORD                   cbBytesNeeded;
    DWORD                   dwServicesReturned = 0;
    DWORD                   i;
    TCHAR                   DisplayName[MAX_PATH];
    SC_HANDLE               hService;
    SERVICE_STATUS          ServiceStatus;
    LPENUM_SERVICE_STATUS   pDependentServiceList = NULL;

    //
    // Retrieve the device data structure first
    //
    lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    MYASSERT (lpi);
    if (!lpi) {
        return;
    }

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    try {

        //
        // Find out if this device has any dependent services, and if so then
        // how many bytes are needed to enumerate the dependent services.
        //
        EnumDependentServices(lpi->hService,
                              SERVICE_ACTIVE,
                              NULL,
                              0,
                              &cbBytesNeeded,
                              &dwServicesReturned
                              );

        if (cbBytesNeeded > 0) {
            pDependentServiceList = (LPENUM_SERVICE_STATUS)malloc(cbBytesNeeded);

            if (pDependentServiceList) {
                EnumDependentServices(lpi->hService,
                                      SERVICE_ACTIVE,
                                      pDependentServiceList,
                                      cbBytesNeeded,
                                      &cbBytesNeeded,
                                      &dwServicesReturned
                                      );

                if (dwServicesReturned > 0) {
                    //
                    // Ask the user if they want to stop these dependet services.
                    //
                    lpi->NumDependentServices = dwServicesReturned;
                    lpi->pDependentServiceList = pDependentServiceList;

                    if (DialogBoxParam(MyModuleHandle, 
                                       MAKEINTRESOURCE(IDD_SERVICE_STOP_DEPENDENCIES), 
                                       hDlg, 
                                       DependentServicesDlgProc, 
                                       (LPARAM)lpi
                                       ) == IDCANCEL) {
                        bStopServices = FALSE;
                    }
                }
            }
        }

        //
        // Stop this service and all the dependent services if the user did 
        // not cancel out of the dialog box.
        //
        if (bStopServices) {

            Err = ERROR_SUCCESS;

            SetCursor(LoadCursor(NULL, IDC_WAIT));

            //
            // First stop all of the dependent services if their are any.
            //
            if (pDependentServiceList && (dwServicesReturned > 0)) {
                for (i=0; i<dwServicesReturned; i++) {
                    hService = OpenService(lpi->hSCManager,
                                           pDependentServiceList[i].lpServiceName,
                                           GENERIC_READ | SERVICE_STOP
                                           );

                    if (hService == NULL) {
                        //
                        // Just bail out if we encountered an error.  The reason
                        // is that if one of the services cannot be stopped
                        // then we won't be able to stop the selected service.
                        //
                        Err = GetLastError();
                        StringCchCopy(DisplayName, SIZECHARS(DisplayName), pDependentServiceList[i].lpServiceName);
                        break;
                    }

                    if (!ControlService(hService,
                                        SERVICE_CONTROL_STOP,
                                        &ServiceStatus
                                        )) {
                        Err = GetLastError();
                        StringCchCopy(DisplayName, SIZECHARS(DisplayName), pDependentServiceList[i].lpServiceName);
                        CloseServiceHandle(hService);
                        break;
                    }

                    //
                    // Wait for the service to actually stop.
                    //
                    if (!pLegacyDriverCheckServiceStatus(hService,
                                                         &ServiceStatus,
                                                         STOP_LEGACY_DEVICE
                                                         )) {
                        Err = GetLastError();
                        StringCchCopy(DisplayName, SIZECHARS(DisplayName), pDependentServiceList[i].lpServiceName);
                        CloseServiceHandle(hService);
                        break;
                    }

                    CloseServiceHandle(hService);
                }
            }

            //
            // Only attempt to stop the selected service if all of the dependent
            // services were stoped.
            //
            if (Err == ERROR_SUCCESS) {
                //
                // Tell the service to stop.
                //
                if (!ControlService(lpi->hService,
                                    SERVICE_CONTROL_STOP,
                                    &lpi->ServiceStatus)) {
                                
                    Err = GetLastError();
                    StringCchCopy(DisplayName, SIZECHARS(DisplayName), lpi->DisplayName);
                
                } else {
                    //
                    // Wait for the service to stop.
                    //
                    if (!pLegacyDriverCheckServiceStatus(lpi->hService,
                                                         &lpi->ServiceStatus,
                                                         STOP_LEGACY_DEVICE
                                                         )) {
                        Err = GetLastError();
                        StringCchCopy(DisplayName, SIZECHARS(DisplayName), lpi->DisplayName);
                    }
                }
            }

            if (Err != ERROR_SUCCESS) {
                pLegacyDriverDisplayErrorMsgBox(hDlg,
                                                DisplayName,
                                                IDS_SVC_STOP_ERROR,
                                                Err
                                                );
            }

            //
            // Repaint the status part
            //
            pLegacyDriverSetPropertyPageState(hDlg, lpi, FALSE);
        }

    }except  (EXCEPTION_EXECUTE_HANDLER) {
    
        pDependentServiceList = pDependentServiceList;
    }

    if (pDependentServiceList) {
        free(pDependentServiceList);
    }

    SetCursor(hOldCursor);

    return;            
}

PLEGACY_PAGE_INFO
LegacyDriver_CreatePageInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData)
{
    PLEGACY_PAGE_INFO lpi = (PLEGACY_PAGE_INFO) MyMalloc(sizeof(LEGACY_PAGE_INFO));

    if (!lpi) {
        return NULL;
    }

    lpi->DeviceInfoSet = DeviceInfoSet;
    lpi->DeviceInfoData = DeviceInfoData;

    return lpi;
}

VOID
LegacyDriver_OnApply(
    IN HWND    hDlg,
    IN DWORD   StartType
    )  
{
    PLEGACY_PAGE_INFO lpi;
    SC_LOCK sclLock = NULL;
    USHORT uCount = 0;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;
    LPQUERY_SERVICE_CONFIG lpqscTmp = NULL;
    DWORD dwBytesNeeded;

    //
    // Retrieve the device data structure first
    //
    lpi = (PLEGACY_PAGE_INFO)GetWindowLongPtr(hDlg, DWLP_USER);

    try {
    
        //
        // Decide if we need to make any changes
        //
        if ((StartType == lpi->dwStartType) && 
            (StartType != SERVICE_DEMAND_START)) {
            
            goto clean0;
        }

        //
        // I guess we need to make some changes here and there...
        // Get the database lock first.
        //
        do {
        
            sclLock = LockServiceDatabase(lpi->hSCManager);
            
            if (sclLock == NULL) {

                //
                // If there is another error then the database locked by
                // another process, bail out
                //
                if (GetLastError() != ERROR_SERVICE_DATABASE_LOCKED) {

                    goto clean0;
                    
                } else {
                
                    //
                    // (Busy) wait and try again
                    //
                    Sleep (1000 * WAIT_TIME_SLOT);
                    uCount++;
                }
            }

        } while ((uCount < TRIES_COUNT) && (sclLock == NULL));

        if (sclLock == NULL) {

            //
            // Bail out now, we waited enough
            //
            goto clean0;
        }
        
        //
        // I have the lock. Hurry and query, then change the config
        //
        //
        // Now, attempt to get the configuration
        //
        if ((lpqscBuf = (LPQUERY_SERVICE_CONFIG)malloc(SERVICE_BUFFER_SIZE)) == NULL) {
            
            //
            // We're out of here
            //
            goto clean0;

        }


        if (!QueryServiceConfig(lpi->hService,
                                lpqscBuf,
                                SERVICE_BUFFER_SIZE,
                                &dwBytesNeeded
                                )) {
                                
            //
            // Try again with a new buffer
            //
            if ((lpqscTmp = realloc(lpqscBuf, dwBytesNeeded)) != NULL) {
                
                //
                // Make sure the realloc doesn't leak...
                //
                lpqscBuf = lpqscTmp;
            }
            else {

                //
                // We're out of here
                //
                goto clean0;
            }
            
            if (!QueryServiceConfig(lpi->hService,
                                    lpqscBuf,
                                    SERVICE_BUFFER_SIZE,
                                    &dwBytesNeeded
                                    )) {
                                    
                goto clean0;
            }
        }
        
        //
        // Change tye service type (we needed the service name, too, 
        // that's why we're querying it first)
        //
        if (ChangeServiceConfig(lpi->hService,
                                 SERVICE_NO_CHANGE,
                                 StartType,
                                 SERVICE_NO_CHANGE,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL)) {
                                 
            //
            // We succesfully changed the status. 
            // Reflect in our page display
            //
            lpi->dwStartType = StartType;
        }

        //
        // Unlock the database
        //
        if (sclLock) {
        
            UnlockServiceDatabase(sclLock);
            sclLock = NULL;
        }


        //
        // We want to see something different on apply, so repaint
        // the whole stuff
        //
        pLegacyDriverSetPropertyPageState(hDlg,
                                          lpi,
                                          FALSE);  // if we managed to apply some changes
                                                   // we are not read-only
                              
        clean0:
        
        if (sclLock) {
        
            UnlockServiceDatabase(sclLock);
            sclLock = NULL;
        }
        
        if (lpqscBuf) {
        
            free(lpqscBuf);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
    
        lpi = lpi;
    }

    return;
}

BOOL
LegacyDriver_OnInitDialog(
    HWND    hDlg,
    HWND    FocusHwnd,
    LPARAM  lParam
    )
{
    PLEGACY_PAGE_INFO lpi = (PLEGACY_PAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);
    BOOL ReadOnly = FALSE;
    HICON ClassIcon;
    HICON OldIcon;
    TCHAR DeviceDescription[MAX_DEVICE_ID_LEN];
    TCHAR DriverName[MAX_PATH];
    TCHAR StartupType[MAX_PATH];
    DWORD dwBytesNeeded;
    LPQUERY_SERVICE_CONFIG lpqscBuf = NULL;
    LPQUERY_SERVICE_CONFIG lpqscTmp = NULL;
    DWORD_PTR index;
    HWND hCombo;

    UNREFERENCED_PARAMETER(FocusHwnd);

    lpi = (PLEGACY_PAGE_INFO) ((LPPROPSHEETPAGE)lParam)->lParam;
    SetWindowLongPtr(hDlg, DWLP_USER, (ULONG_PTR)lpi);


    //
    // First, open the Service Control Manager
    //
    lpi->hSCManager = OpenSCManager(NULL,
                                    NULL,
                                    GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE);
                                    
    if (!lpi->hSCManager && (GetLastError() == ERROR_ACCESS_DENIED)) {
    
        //
        // This is not fatal, attempt to open the database only
        // for read
        //
        ReadOnly = FALSE;

        lpi->hSCManager = OpenSCManager(NULL,
                                        NULL,
                                        GENERIC_READ);
                                        
        if (!lpi->hSCManager) {
        
            //
            // This is fatal
            //
            lpi->hSCManager = NULL;
        }
    }

    //
    // Now, get the service name
    //
    if (!SetupDiGetDeviceRegistryProperty(lpi->DeviceInfoSet,
                                          lpi->DeviceInfoData,
                                          SPDRP_SERVICE,
                                          NULL,
                                          (PBYTE)lpi->ServiceName,
                                          sizeof(lpi->ServiceName),
                                          NULL)
       ) {
       
        LoadString(MyModuleHandle, IDS_UNKNOWN, lpi->ServiceName, SIZECHARS(lpi->ServiceName));
        ReadOnly = TRUE;
        goto clean0;
    }

    //
    // Now we have a service name, try to open its handle
    //
    if (!ReadOnly) {
    
        lpi->hService = OpenService(lpi->hSCManager,
                                    lpi->ServiceName,
                                    GENERIC_WRITE | GENERIC_READ | 
                                    GENERIC_EXECUTE);
                                    
        if (!lpi->hService) {
        
            //
            // OK, let them try again
            //
            ReadOnly = TRUE;
        }
    }
    
    if (ReadOnly) {
    
        lpi->hService = OpenService(lpi->hSCManager,
                                    lpi->ServiceName,
                                    GENERIC_READ);
                                    
        if (!lpi->hService) {
        
            //
            // Sorry, this is fatal
            //
            ReadOnly = TRUE;
            goto clean0;
        }
    }

    //
    // Now, attempt to get the configuration
    //
    lpqscBuf = (LPQUERY_SERVICE_CONFIG)malloc(SERVICE_BUFFER_SIZE);
    if (!lpqscBuf) {
    
        ReadOnly = TRUE;
        goto clean0;
    }

    if (!QueryServiceConfig(lpi->hService,
                            lpqscBuf,
                            SERVICE_BUFFER_SIZE,
                            &dwBytesNeeded
                            )) {
        //
        // Try again with a new buffer
        //
        if ((lpqscTmp = realloc(lpqscBuf, dwBytesNeeded)) != NULL) {
            
            //
            // Make sure the realloc didn't leak...
            //
            lpqscBuf = lpqscTmp;
        }
        else {

            //
            // We're out of here
            //
            ReadOnly = TRUE;
            goto clean0;
        }

        if (!QueryServiceConfig(lpi->hService,
                                lpqscBuf,
                                SERVICE_BUFFER_SIZE,
                                &dwBytesNeeded
                                )) {
                                
            ReadOnly = TRUE;
            goto clean0;
        }
    }

    //
    // We have the buffer now, get the start type from it
    //
    lpi->dwStartType = lpqscBuf->dwStartType;

    if (!ControlService(lpi->hService,
                        SERVICE_CONTROL_INTERROGATE,
                        &lpi->ServiceStatus)) {
                        
        
        DWORD Err = GetLastError();

        //
        // If ControlService failed with one of the following errors then it is OK 
        // and the ServiceStatus was still filled in.
        //
        if ((Err != NO_ERROR) &&
            (Err != ERROR_SERVICE_NOT_ACTIVE)) {
        
            //
            // Bail out,
            //
            ReadOnly = TRUE;
            goto clean0;
        }
    }


    //
    // Add the startup types to the combo box
    //
    hCombo = GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_AUTOMATIC, StartupType, SIZECHARS(StartupType));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_AUTO_START);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_BOOT, StartupType, SIZECHARS(StartupType));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_BOOT_START);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_DEMAND, StartupType, SIZECHARS(StartupType));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_DEMAND_START);
    
    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_SYSTEM, StartupType, SIZECHARS(StartupType));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_SYSTEM_START);

    LoadString(MyModuleHandle, IDS_SERVICE_STARTUP_DISABLED, StartupType, SIZECHARS(StartupType));
    index = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM)StartupType);
    SendMessage(hCombo, CB_SETITEMDATA, index, (LPARAM)SERVICE_DISABLED);
    
clean0:

    //
    // Now draw the interface: first the icon
    //
    if (SetupDiLoadClassIcon(&lpi->DeviceInfoData->ClassGuid, &ClassIcon, NULL)) {

        OldIcon = (HICON)SendDlgItemMessage(hDlg,
                                            IDC_PROP_LEGACY_ICON,
                                            STM_SETICON,
                                            (WPARAM)ClassIcon,
                                            0);
        if (OldIcon) {
        
            DestroyIcon(OldIcon);
        }
    }
    
    //
    // Then the device name
    //
    if (SetupDiGetDeviceRegistryProperty(lpi->DeviceInfoSet,
                                         lpi->DeviceInfoData,
                                         SPDRP_DEVICEDESC,
                                         NULL,
                                         (PBYTE)DeviceDescription,
                                         MAX_DEVICE_ID_LEN,
                                         NULL)) {
                                         
        SetDlgItemText(hDlg, IDC_PROP_LEGACY_DESC, DeviceDescription);
    }

    SetDlgItemText(hDlg, IDC_EDIT_SERVICE_NAME, lpi->ServiceName);

    if (lpqscBuf && lpqscBuf->lpDisplayName) {
    
        SetDlgItemText(hDlg, IDC_EDIT_DISPLAY_NAME, lpqscBuf->lpDisplayName);
        StringCchCopy(lpi->DisplayName, SIZECHARS(lpi->DisplayName), lpqscBuf->lpDisplayName);

    } else {

        TCHAR Unknown[MAX_PATH];
        LoadString(MyModuleHandle, IDS_UNKNOWN, Unknown, SIZECHARS(Unknown));
        SetDlgItemText(hDlg, IDC_EDIT_DISPLAY_NAME, Unknown);
        StringCchCopy(lpi->DisplayName, SIZECHARS(lpi->DisplayName), Unknown);
    }

    pLegacyDriverSetPropertyPageState(hDlg, lpi, ReadOnly);

    //
    // Show/Gray the details button
    //
    EnableWindow(GetDlgItem(hDlg, IDC_LEGACY_DETAILS),
        (pDriverFilesGetServiceFilePath(lpi->DeviceInfoSet, lpi->DeviceInfoData, DriverName, SIZECHARS(DriverName))));


    if (lpqscBuf) {
    
        free(lpqscBuf);
    }

    return TRUE;
}

void
LegacyDriver_OnCommand(
    HWND hDlg,
    int  ControlId,
    HWND ControlHwnd,
    UINT NotifyCode
    )
{
    PLEGACY_PAGE_INFO lpi = (PLEGACY_PAGE_INFO) GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(ControlHwnd);

    if (NotifyCode == CBN_SELCHANGE) {

        PropSheet_Changed(GetParent(hDlg), hDlg);
    }
    
    else {

        switch (ControlId) {

        case IDC_BUTTON_START:
            pLegacyDriverOnStart(hDlg); 
            break;

        case IDC_BUTTON_STOP:
            pLegacyDriverOnStop(hDlg);
            break;

        case IDC_LEGACY_DETAILS:
        {
            DRIVERFILES_INFO dfi;
            ZeroMemory(&dfi, sizeof(DRIVERFILES_INFO));
            dfi.DeviceInfoSet = lpi->DeviceInfoSet;
            dfi.DeviceInfoData = lpi->DeviceInfoData;
            DialogBoxParam(MyModuleHandle, MAKEINTRESOURCE(IDD_DRIVERFILES), 
                    hDlg, DriverFiles_DlgProc, (LPARAM)&dfi);
        }
            break;

        default:
            break;
        }
    }
}

BOOL
LegacyDriver_OnNotify(
    HWND    hDlg,
    LPNMHDR NmHdr
    )
{
    DWORD StartType;
    DWORD_PTR Index;

    switch (NmHdr->code) {

        //
        // The user is about to change an up down control
        //
        case UDN_DELTAPOS:
            PropSheet_Changed(GetParent(hDlg), hDlg);
            return FALSE;

        //
        // Sent when the user clicks on Apply OR OK !!
        //
        case PSN_APPLY:
            if (CB_ERR != (Index = SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE),
                    CB_GETCURSEL, 0, 0))) {

                StartType = (DWORD)SendMessage(GetDlgItem(hDlg, IDC_COMBO_STARTUP_TYPE), CB_GETITEMDATA, Index, 0);
                                
                LegacyDriver_OnApply(hDlg, StartType);
            }
            
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL
LegacyDriver_OnContextMenu(
    HWND HwndControl,
    WORD Xpos,
    WORD Ypos
    )
{
    UNREFERENCED_PARAMETER(Xpos);
    UNREFERENCED_PARAMETER(Ypos);

    WinHelp(HwndControl,
            L"devmgr.hlp",
            HELP_CONTEXTMENU,
            (ULONG_PTR) LegacyDriver_HelpIDs);

    return FALSE;
}

void
LegacyDriver_OnHelp(
    HWND       ParentHwnd,
    LPHELPINFO HelpInfo
    )
{
    UNREFERENCED_PARAMETER(ParentHwnd);

    if (HelpInfo->iContextType == HELPINFO_WINDOW) {
        WinHelp((HWND) HelpInfo->hItemHandle,
                L"devmgr.hlp",
                HELP_WM_HELP,
                (ULONG_PTR) LegacyDriver_HelpIDs);
    }
}

INT_PTR
APIENTRY
LegacyDriver_DlgProc(
    IN HWND   hDlg,
    IN UINT   uMessage,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    HICON hicon;

    switch(uMessage) {

    case WM_COMMAND:
        LegacyDriver_OnCommand(hDlg, (int) LOWORD(wParam), (HWND)lParam, (UINT)HIWORD(wParam));
        break;

    case WM_INITDIALOG:
        return LegacyDriver_OnInitDialog(hDlg, (HWND)wParam, lParam);

    case WM_NOTIFY:
        return LegacyDriver_OnNotify(hDlg,  (NMHDR *)lParam);

    case WM_CONTEXTMENU:
        return LegacyDriver_OnContextMenu((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_HELP:
        LegacyDriver_OnHelp(hDlg, (LPHELPINFO) lParam);
        break;

    case WM_DESTROY:
        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_PROP_LEGACY_ICON, STM_GETICON, 0, 0);
        if (hicon) {
            DestroyIcon(hicon);
        }
    }

    return FALSE;
}

void
LegacyDriver_DestroyPageInfo(
    PLEGACY_PAGE_INFO lpi
    )
{
    try {
        //
        // Close the service handle
        //
        if (lpi->hService) {

            CloseServiceHandle(lpi->hService);
        }

        //
        // Close the service manager handle
        //
        if (lpi->hSCManager) {

            CloseServiceHandle(lpi->hSCManager);
        }

    } except (EXCEPTION_EXECUTE_HANDLER)  {

        //
        // Access a variable, so that the compiler will respect our statement
        // order w.r.t. assignment.
        //
        lpi = lpi;
    }

    MyFree(lpi);
}

UINT CALLBACK
LegacyDriver_PropPageCallback(
    HWND            Hwnd,
    UINT            Message,
    LPPROPSHEETPAGE PropSheetPage
    )
{
    PLEGACY_PAGE_INFO lpi;

    UNREFERENCED_PARAMETER(Hwnd);
    
    switch (Message) {
    
    case PSPCB_CREATE:
        return TRUE;    // return TRUE to continue with creation of page

    case PSPCB_RELEASE:
        lpi = (PLEGACY_PAGE_INFO) PropSheetPage->lParam;
        LegacyDriver_DestroyPageInfo(lpi);
        return 0;       // return value ignored

    default:
        break;
    }

    return TRUE;
}

HPROPSHEETPAGE
LegacyDriver_CreatePropertyPage(
    PROPSHEETPAGE *  PropSheetPage,
    PLEGACY_PAGE_INFO lpi
    )
{
    //
    // Add the Port Settings property page
    //
    PropSheetPage->dwSize      = sizeof(PROPSHEETPAGE);
    PropSheetPage->dwFlags     = PSP_USECALLBACK;
    PropSheetPage->dwFlags     = PSP_DEFAULT;
    PropSheetPage->hInstance   = MyModuleHandle;
    PropSheetPage->pszTemplate = MAKEINTRESOURCE(IDD_PROP_LEGACY_SERVICE);

    //
    // following points to the dlg window proc
    //
    PropSheetPage->pfnDlgProc = LegacyDriver_DlgProc;
    PropSheetPage->lParam     = (LPARAM)lpi;

    //
    // Following points to the control callback of the dlg window proc.
    // The callback gets called before creation/after destruction of the page
    //
    PropSheetPage->pfnCallback = LegacyDriver_PropPageCallback;

    //
    // Allocate the actual page
    //
    return CreatePropertySheetPage(PropSheetPage);
}

BOOL
LegacyDriverPropPageProvider(
    LPVOID Info,
    LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    LPARAM lParam
    )
{
    SP_DEVINSTALL_PARAMS DevInstallParams;
    PSP_PROPSHEETPAGE_REQUEST PropPageRequest;
    PROPSHEETPAGE    psp;
    HPROPSHEETPAGE   hpsp;
    PLEGACY_PAGE_INFO lpi;

    PropPageRequest = (PSP_PROPSHEETPAGE_REQUEST) Info;

    if (PropPageRequest->PageRequested == SPPSR_ENUM_ADV_DEVICE_PROPERTIES) {

        lpi = LegacyDriver_CreatePageInfo(PropPageRequest->DeviceInfoSet, PropPageRequest->DeviceInfoData);

        if (!lpi) {

            return FALSE;
        }

        hpsp = LegacyDriver_CreatePropertyPage(&psp, lpi);

        if (!hpsp) {

            return FALSE;
        }

        if (!lpfnAddPropSheetPageProc(hpsp, lParam)) {
        
            DestroyPropertySheetPage(hpsp);
            return FALSE;
        }

        //
        // Tell device manager that we will display our own Driver tab for legacy device
        //
        ZeroMemory(&DevInstallParams, sizeof(DevInstallParams));
        DevInstallParams.cbSize = sizeof(DevInstallParams);
        
        SetupDiGetDeviceInstallParams(lpi->DeviceInfoSet, lpi->DeviceInfoData, &DevInstallParams);
        
        DevInstallParams.Flags |= DI_DRIVERPAGE_ADDED;

        SetupDiSetDeviceInstallParams(lpi->DeviceInfoSet, lpi->DeviceInfoData, &DevInstallParams);
   }

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\clasinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    clasinst.c

Abstract:

    Routines for the following 'built-in' class installers:

        Keyboard
        Mouse
        NtApm
        DeviceBay

Author:

    Lonny McMichael 26-February-1996

Revision History:


    28-Aug-96               Andy Thornton (andrewth)

        Added DisableService, IsOnlyKeyboardDriver, RetrieveDriversStatus,
        CountDevicesControlled & pSetupAcquireSCMLock routines and modified the
        keyboard & mouse class installers to disable the old driver services
        under certain circumstances.  This is part of a fix for bug R56351 for
        NT 4.0 SP1.

    09-Apr-97               Lonny McMichael (lonnym)

        Moved pSetupAcquireSCMLock to setupapi and exposed it as a private export.


    19-Jun-97               Jim Cavalaris (t-jcaval)

        Added CriticalDeviceCoInstaller co-installer to store the ServiceName
        used by devices considered critical to getting the system up into
        user mode.

    25-Sep-98               Bryan Willman (bryanwi)

        Added apm support.

    11-May-01               Lonny McMichael (lonnym)

        Removed support for legacy INFs.

--*/


#include "setupp.h"
#pragma hdrstop

//
// include common INF strings headerfile.
//
#include <infstr.h>

//
// instantiate device class GUIDs.
//
#include <initguid.h>
#include <devguid.h>

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>
#include <strsafe.h>

//
// Just to make sure no one is trying to use this obsolete string definition.
//
#ifdef IDS_DEVINSTALL_ERROR
    #undef IDS_DEVINSTALL_ERROR
#endif

//
// Some debugging aids for us kernel types
//

//#define CHKPRINT 1
#define CHKPRINT 0

#if CHKPRINT
#define ChkPrintEx(_x_) DbgPrint _x_   // use:  ChkPrintEx(( "%x", var, ... ));
#define ChkBreak()    DbgBreakPoint()
#else
#define ChkPrintEx(_x_)
#define ChkBreak()
#endif

//
// Declare a string containing the character representation of the Display class GUID.
//
CONST WCHAR szDisplayClassGuid[] = L"{4D36E968-E325-11CE-BFC1-08002BE10318}";

//
// Define a string for the service install section suffix.
//
#define SVCINSTALL_SECTION_SUFFIX  (TEXT(".") INFSTR_SUBKEY_SERVICES)

//
// Define the size (in characters) of a GUID string, including terminating NULL.
//
#define GUID_STRING_LEN (39)

//
// Define the string for the load order group for keyboards
//
#define SZ_KEYBOARD_LOAD_ORDER_GROUP TEXT("Keyboard Port")

//
// Define a structure for specifying what Plug&Play driver node is used to install
// a particular service.
//
typedef struct _SERVICE_NODE {

    struct _SERVICE_NODE *Next;

    WCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    DWORD DriverNodeIndex;

} SERVICE_NODE, *PSERVICE_NODE;

//
// Define a structure for specifying a legacy INF that is included in a class driver list.
//
typedef struct _LEGACYINF_NODE {

    struct _LEGACYINF_NODE *Next;

    WCHAR InfFileName[MAX_PATH];

} LEGACYINF_NODE, *PLEGACYINF_NODE;

//
// Define the context structure used by the critical device co-installer
//
typedef struct _CDC_CONTEXT {

    TCHAR OldMatchingDevId[MAX_DEVICE_ID_LEN];  // previous matching device id
    TCHAR OldServiceName[MAX_SERVICE_NAME_LEN]; // previous controlling service
                                                // or empty string if none.
} CDC_CONTEXT, *PCDC_CONTEXT;

//
// Strings used in ntapm detection
//
WCHAR rgzMultiFunctionAdapter[] =
    L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";

WCHAR rgzGoodBadKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Biosinfo\\APM";
WCHAR rgzGoodBadValue[] =
    L"Attributes";

WCHAR rgzAcpiKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ACPI\\Enum";
WCHAR rgzAcpiCount[] =
    L"Count";

WCHAR rgzApmLegalHalKey[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ApmLegalHal";
WCHAR rgzApmHalPresent[] =
    L"Present";

//
// Internal function prototypes.
//
DWORD
DrvTagToFrontOfGroupOrderList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

BOOL
UserBalksAtSharedDrvMsg(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams
    );

VOID
CopyFixedUpDeviceId(
      OUT LPWSTR  DestinationString,
      IN  LPCWSTR SourceString,
      IN  DWORD   SourceStringLen
      );

VOID
MigrateLegacyDisplayDevices(
    IN HDEVINFO hDevInfo
    );

DWORD
DisableService(
    IN LPTSTR       ServiceName
    );

DWORD
IsKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    );

DWORD
IsOnlyKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    );

DWORD
GetServiceStartType(
    IN PCWSTR       ServiceName
    );

LONG
CountDevicesControlled(
    IN LPTSTR       ServiceName
    );

DWORD
InstallNtApm(
    IN     HDEVINFO                DevInfoHandle,
    IN     BOOLEAN                 InstallDisabled
    );

DWORD
AllowInstallNtApm(
    IN     HDEVINFO         DevInfoHandle,
    IN     PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    );

#define NTAPM_NOWORK        0
#define NTAPM_INST_DISABLED 1
#define NTAPM_INST_ENABLED  2

DWORD
DecideNtApm(
    VOID
    );

#define APM_NOT_PRESENT             0
#define APM_PRESENT_BUT_NOT_USABLE  1
#define APM_ON_GOOD_LIST            2
#define APM_NEUTRAL                 3
#define APM_ON_BAD_LIST             4

BOOL
IsProductTypeApmLegal(
    VOID
    );


DWORD
IsApmPresent(
    VOID
    );

BOOL
IsAcpiMachine(
    VOID
    );

BOOL
IsApmLegalHalMachine(
    VOID
    );

HKEY
OpenCDDRegistryKey(
    IN PCTSTR DeviceId,
    IN BOOL   Create
    );


//
// Function definitions
//
BOOL
pInGUISetup(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SP_DEVINSTALL_PARAMS dip;

    ZeroMemory(&dip, sizeof(SP_DEVINSTALL_PARAMS));
    dip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &dip)) {
        if ((dip.Flags & DI_QUIETINSTALL) ||
            (dip.FlagsEx & DI_FLAGSEX_IN_SYSTEM_SETUP)) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }
    else {
        return FALSE;
    }
}

BOOLEAN
MigrateToDevnode(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine will look for a section in the inf that describes what service's
    values to migrate up to the new device's devnode.  The section's name is
    %DecoratedInstallName%.MigrateToDevnode.  Under this section the following
    entry is looked for:

    service-name=value-name[,value-name]...

    Each of the value-nanmes are read from
    ...\CurrentControlSet\service-name\Parameters and written to the devnode

    The primary use of this function is that all of the user modified values are
    propagated during upgrade.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully migrates the values listed, it returns TRUE.

    If this function cannot successfully migrate the values, then it returns
    FALSE.

    If this function is being run on a devnode that has already been migrated,
    then it returns TRUE.

--*/
{
    HKEY                    hDestination = (HKEY) INVALID_HANDLE_VALUE,
                            hSource = (HKEY) INVALID_HANDLE_VALUE;
    SP_DRVINFO_DETAIL_DATA  didd;
    SP_DRVINFO_DATA         did;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              infContext;
    TCHAR                   szSectionName[LINE_LEN];
    PTCHAR                  szService = NULL, szServicePath = NULL,
                            szValueNames = NULL, szCurrentName = NULL;
    DWORD                   dwSize, res, regDataType, regSize, migrated;
    BOOLEAN                 success = FALSE;
    PBYTE                   buffer = NULL;
    TCHAR                   szMigrated[] = L"Migrated";
    TCHAR                   szRegServices[]  = L"System\\CurrentControlSet\\Services\\";
    TCHAR                   szParameters[]  = L"\\Parameters";
    TCHAR                   szMigrateToDevnode[]  = L".MigrateToDevnode";

#define DEFAULT_BUFFER_SIZE 100

    if ((hDestination = SetupDiCreateDevRegKey(DeviceInfoSet,
                                               DeviceInfoData,
                                               DICS_FLAG_GLOBAL,
                                               0,
                                               DIREG_DEV,
                                               NULL,
                                               NULL)) == INVALID_HANDLE_VALUE) {
        goto cleanup;
    }

    dwSize = sizeof(DWORD);
    migrated = 0;
    if (RegQueryValueEx(hDestination,
                        szMigrated,
                        0,
                        &regDataType,
                        (PBYTE) &migrated,
                        &dwSize) == ERROR_SUCCESS &&
        regDataType == REG_DWORD &&
        migrated != 0) {
        //
        // We have migrated to the devnode before (ie a previous upgrade) and
        // the user might have changed the respective values, just quit.
        //
        success = TRUE;
        goto cleanup;
    }
    else {
        migrated = TRUE;
        RegSetValueEx(hDestination,
                      szMigrated,
                      0,
                      REG_DWORD,
                      (PBYTE) &migrated,
                      sizeof(DWORD));
    }

    //
    // Retrieve information about the driver node selected for this device.
    //
    did.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &did)) {
        goto cleanup;
    }

    didd.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &did,
                                    &didd,
                                    sizeof(didd),
                                    NULL)
        && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        //
        // For some reason we couldn't get detail data--this should never happen.
        //
        goto cleanup;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the AddReg
    // entries in its install section.
    //
    hInf = SetupOpenInfFile(didd.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //
        goto cleanup;
    }

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          didd.SectionName,
                                          szSectionName,
                                          sizeof(szSectionName) / sizeof(TCHAR),
                                          NULL,
                                          NULL
                                          ) ||
        FAILED(StringCchCat(szSectionName, SIZECHARS(szSectionName), szMigrateToDevnode)) ||
        (!SetupFindFirstLine(hInf,
                            szSectionName,
                            NULL,
                            &infContext))) {
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetStringField(&infContext, 0, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szService = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));

        if (!szService ||
            !SetupGetStringField(&infContext, 0, szService, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    dwSize = wcslen(szRegServices)+wcslen(szService)+wcslen(szParameters)+1;
    dwSize *= sizeof(TCHAR);
    szServicePath = (PTCHAR) LocalAlloc(LPTR, dwSize);
    if (!szServicePath) {
        res = GetLastError();
        goto cleanup;
    }

    if (FAILED(StringCbCopy(szServicePath, dwSize, szRegServices)) ||
        FAILED(StringCbCat(szServicePath, dwSize, szService)) ||
        FAILED(StringCbCat(szServicePath, dwSize, szParameters)) ||
        (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szServicePath,
                      0,
                      KEY_ALL_ACCESS,
                      &hSource) != ERROR_SUCCESS)) {
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetMultiSzField(&infContext, 1, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szValueNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
        if (!szValueNames ||
            !SetupGetMultiSzField(&infContext, 1, szValueNames, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    regSize = dwSize = DEFAULT_BUFFER_SIZE;
    buffer = (PBYTE) LocalAlloc(LPTR, regSize);
    if (!buffer) {
        goto cleanup;
    }

    for (szCurrentName = szValueNames;
         *szCurrentName;
         regSize = dwSize, szCurrentName += wcslen(szCurrentName) + 1) {
getbits:
        res = RegQueryValueEx(hSource,
                              szCurrentName,
                              0,
                              &regDataType,
                              (PBYTE) buffer,
                              &regSize);
        if (res == ERROR_MORE_DATA) {
            //
            // regSize contains new buffer size, free and reallocate
            //
            dwSize = regSize;
            LocalFree(buffer);
            buffer = LocalAlloc(LPTR, dwSize);
            if (buffer) {
                goto getbits;
            }
            else {
                goto cleanup;
            }
        }
        else if (res == ERROR_SUCCESS) {
            RegSetValueEx(hDestination,
                          szCurrentName,
                          0,
                          regDataType,
                          buffer,
                          regSize);
        }
    }

    success = TRUE;

cleanup:
    //
    // Clean up and leave
    //

    if (hInf != (HKEY) INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if (hDestination != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(hDestination);
    }
    if (hSource != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(hSource);
    }
    if (buffer) {
        LocalFree(buffer);
    }
    if (szService) {
        LocalFree(szService);
    }
    if (szServicePath) {
        LocalFree(szServicePath);
    }
    if (szValueNames) {
        LocalFree(szValueNames);
    }

    return success;
}

void
MarkDriverNodesBad(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    )
{
    SP_DRVINSTALL_PARAMS drvInstallParams;
    SP_DRVINFO_DATA      drvData;
    ULONG                index = 0;

    //
    // Only mark driver nodes as bad during gui setup
    //
    if (!pInGUISetup(DeviceInfoSet, DeviceInfoData)) {
        return;
    }

    if (SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, DriverType))
    {
        ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
        drvData.cbSize = sizeof(SP_DRVINFO_DATA);

        while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                     DeviceInfoData,
                                     DriverType,
                                     index++,
                                     &drvData)) {

            if (drvData.DriverVersion == 0) {
                ZeroMemory(&drvInstallParams, sizeof(SP_DRVINSTALL_PARAMS));
                drvInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
                if (SetupDiGetDriverInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &drvData,
                                                  &drvInstallParams))
                {
                    drvInstallParams.Flags |=  DNF_BAD_DRIVER;

                    SetupDiSetDriverInstallParams(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  &drvData,
                                                  &drvInstallParams);
                }
            }

            ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
            drvData.cbSize = sizeof(SP_DRVINFO_DATA);
        }
    }
}

DWORD
ConfirmWHQLInputRequirements(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN LPTSTR           Services,
    IN LPCTSTR          CompatInfName,
    IN DI_FUNCTION      InstallFunction
    )
/*++

Routine Description:

    This function enforces the WHQL requirements that a 3rd party vendor or OEM
    cannot replace the ImagePath of the input drivers (mouclass.sys for instance).
    This does not stop the OEMs from disabling  our drivers and installing their
    own services though.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Services - A multi-sz of service names to check

    CompatInfName - name of the system inf to set the match to if we detect an
                    an INF that is actually trying to replace an image

    InstallFunction - The InstallFunction for which this function was called for.
        The function does different things if InstallFunction is equal to
        DIF_SELECTBESTCOMPATDRV.

Return Value:

    If this function determines that the INF in question matches the WHQL
        requirement, returns ERROR_DI_DO_DEFAULT

    If the default determines that the INF violates the requirements and we find
        a match, returns NO_ERROR

    If the default determines that the INF violates the requirements and we
        don't find a match or the InstallFunction is not select best compat drv,
        returns ERROR_DI_DONT_INSTALL.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned (via GetLastError)

--*/
{
    HINF                    hInf;
    SP_DRVINFO_DATA         drvData;
    SP_DRVINFO_DETAIL_DATA  drvDetData;
    DWORD                   dwSize;
    TCHAR                   szSection[LINE_LEN],
                            szNewService[LINE_LEN],
                            szBinary[LINE_LEN],
                            szServiceInstallSection[LINE_LEN];
    LPTSTR                  szCurrentService;
    INFCONTEXT              infContext, infContextService;
    DWORD                   ret = ERROR_DI_DO_DEFAULT;
    BOOLEAN                 badServiceEntry = FALSE;

    if (InstallFunction == DIF_SELECTBESTCOMPATDRV) {
        MarkDriverNodesBad(DeviceInfoSet, DeviceInfoData, SPDIT_COMPATDRIVER);

        if (!SetupDiSelectBestCompatDrv(DeviceInfoSet, DeviceInfoData)) {
            return GetLastError();
        }
    }

    ZeroMemory(&drvData, sizeof(SP_DRVINFO_DATA));
    drvData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &drvData)) {
        return GetLastError();
    }

    ZeroMemory(&drvDetData, sizeof(SP_DRVINFO_DETAIL_DATA));
    drvDetData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &drvData,
                                    &drvDetData,
                                    drvDetData.cbSize,
                                    &dwSize) &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return GetLastError();
    }

    hInf = SetupOpenInfFile(drvDetData.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        return ERROR_DI_DO_DEFAULT;
    }

    //
    // Get the actual section name so we can find the .Services section
    //
    if (!SetupDiGetActualSectionToInstall(hInf,
                                          drvDetData.SectionName,
                                          szSection,
                                          sizeof(szSection) / sizeof(TCHAR),
                                          NULL,
                                          NULL)) {
        ret = GetLastError();
        goto Done;
    }

    if (FAILED(StringCchCat(szSection, SIZECHARS(szSection), SVCINSTALL_SECTION_SUFFIX))) {
        ret = ERROR_INSUFFICIENT_BUFFER;
        goto Done;
    }

    if (SetupFindFirstLine(hInf, szSection, TEXT("AddService"), &infContext)) {
        do {
            //
            // Get the name of the service to install
            //
            dwSize = LINE_LEN;
            if (!SetupGetStringField(&infContext,
                                     1,
                                     szNewService,
                                     dwSize,
                                     &dwSize)) {
                continue;
            }
            _tcsupr(szNewService);

            for (szCurrentService = Services;
                 *szCurrentService;
                 szCurrentService += lstrlen(szCurrentService) + 1) {

                if (lstrcmp(szCurrentService, szNewService) != 0) {
                    continue;
                }

                dwSize = LINE_LEN;
                if (!SetupGetStringField(&infContext,
                                         3,
                                         szServiceInstallSection,
                                         dwSize,
                                         &dwSize)) {
                    continue;
                }

                if (!SetupFindFirstLine(hInf,
                                        szServiceInstallSection,
                                        TEXT("ServiceBinary"),
                                        &infContextService)) {
                    //
                    // If no ServiceBinary is present, the system looks for a .sys with the
                    // same name as the service so we are OK
                    //
                    continue;
                }

                //
                // Get the actual binary's image name
                //
                dwSize = LINE_LEN;
                if (!SetupGetStringField(&infContextService,
                                         1,
                                         szBinary,
                                         dwSize,
                                         &dwSize)) {
                    //
                    // couldn't get the name, assume the worst
                    //
                    badServiceEntry = TRUE;
                }
                else {
                    _tcsupr(szBinary);
                    if (_tcsstr(szBinary, szNewService) == NULL) {
                        //
                        // The service name is NOT the same as the binary's name
                        //
                        badServiceEntry = TRUE;
                    }
                }

                //
                // No need to continue searching the list, we already found our
                // match
                //
                break;
            }

            if (badServiceEntry) {
                SP_DRVINFO_DATA         drvDataAlt;
                SP_DRVINFO_DETAIL_DATA  drvDetDataAlt;
                TCHAR                   szFmt[256];
                TCHAR                   szMsgTxt[256];

                int                     i = 0;

                ret = ERROR_DI_DONT_INSTALL;

                SetupOpenLog(FALSE);

                if (InstallFunction != DIF_SELECTBESTCOMPATDRV) {
                    //
                    // We will try to pick a better one if we find new hardware,
                    // but for the update driver / manual install case,
                    // fail it!
                    //
                    LoadString(MyModuleHandle,
                               IDS_FAIL_INPUT_WHQL_REQS,
                               szFmt,
                               SIZECHARS(szFmt));
                    StringCchPrintf(szMsgTxt,
                                    SIZECHARS(szMsgTxt), 
                                    szFmt, 
                                    drvDetData.InfFileName, 
                                    szNewService);
                    SetupLogError(szMsgTxt, LogSevError);
                    SetupCloseLog();

                    break;
                }

                //
                // We should have a match in the system provided inf
                //
                drvDataAlt.cbSize = sizeof(SP_DRVINFO_DATA);
                while (SetupDiEnumDriverInfo(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDIT_COMPATDRIVER,
                                             i++,
                                             &drvDataAlt)) {

                    PCTSTR name;

                    drvDetDataAlt.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    &drvDataAlt,
                                                    &drvDetDataAlt,
                                                    drvDetDataAlt.cbSize,
                                                    &dwSize) &&
                        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
                        //
                        // Do something here!
                        //
                        // return GetLastError();
                    }

                    //
                    // Find just the inf file name w/out the path
                    //
                    name = pSetupGetFileTitle(drvDetDataAlt.InfFileName);

                    if (lstrcmpi(name, CompatInfName) == 0) {
                        //
                        // Set the known good entry as the selected device
                        //
                        SetupDiSetSelectedDriver(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 &drvDataAlt);
                        ret = ERROR_SUCCESS;
                        break;
                    }
                }

                if (ret == ERROR_SUCCESS) {
                    LoadString(MyModuleHandle,
                               IDS_FAIL_INPUT_WHQL_REQS_AVERTED,
                               szFmt,
                               SIZECHARS(szFmt));
                    StringCchPrintf(szMsgTxt,
                                    SIZECHARS(szMsgTxt), 
                                    szFmt, 
                                    drvDetData.InfFileName,
                                    szNewService, 
                                    CompatInfName);
                }
                else {
                    LoadString(MyModuleHandle,
                               IDS_FAIL_INPUT_WHQL_REQS_NO_ALT,
                               szFmt,
                               SIZECHARS(szFmt));
                    StringCchPrintf(szMsgTxt,
                                    SIZECHARS(szMsgTxt),
                                    szFmt,
                                    drvDetData.InfFileName,
                                    szNewService, 
                                    CompatInfName);
                }

                SetupLogError(szMsgTxt, LogSevWarning);
                SetupCloseLog();

                break;
            }

        } while (SetupFindNextMatchLine(&infContext, TEXT("AddService"), &infContext));
    }

Done:
    SetupCloseInfFile(hInf);

    return ret;
}

#define InputClassOpenLog()   SetupOpenLog(FALSE)
#define InputClassCloseLog()  SetupCloseLog()

BOOL CDECL
InputClassLogError(
    LogSeverity Severity,
    TCHAR *MsgFormat,
    ...
    )
/*++

Outputs a message to the setup log.  Prepends "Input Install: " to the
strings and appends the correct newline chars (\r\n)

--*/
{
    int cch;
    TCHAR ach[MAX_PATH+4];    // Largest path plus extra
    va_list vArgs;
    BOOL result;

    InputClassOpenLog();

    *ach = 0;
    StringCchPrintf(ach, SIZECHARS(ach), TEXT("Input Install: "));

    cch = lstrlen(ach);
    va_start(vArgs, MsgFormat);
    wvnsprintf(&ach[cch], MAX_PATH-cch, MsgFormat, vArgs);
    StringCchCat(ach, SIZECHARS(ach), TEXT("\r\n"));
    va_end(vArgs);

    result = SetupLogError(ach, Severity);

    InputClassCloseLog();

    return result;
}

TCHAR szPS2Driver[] = TEXT("i8042prt");

VOID
FixUpPS2Mouse(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN LPCTSTR          NewServiceName
    )
{
    HKEY                    hDevnode, hKeySystem;
    DWORD                   dwSize, dwDetect = 0, dwType;
    TCHAR                   szDetect[] = TEXT("EnableWheelDetection");
    TCHAR                   szBadBios[] = TEXT("PS2_Inst.NoInterruptInit.Bioses");
    TCHAR                   szSection[] = TEXT("PS2_Inst.NoInterruptInit");
    TCHAR                   szDescSystem[] = TEXT("HARDWARE\\DESCRIPTION\\SYSTEM");
    TCHAR                   szSystemBiosVersion[] = TEXT("SystemBiosVersion");
    PTCHAR                  szBadBiosNames = NULL,
                            szCurrentBadName,
                            szBiosNames = NULL,
                            szCurrentBiosName;
    SP_DRVINFO_DETAIL_DATA  didd;
    SP_DRVINFO_DATA         did;
    BOOL                    bad;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              infContext;

    if (lstrcmpi(NewServiceName, szPS2Driver) != 0) {
        InputClassLogError(LogSevInformation, TEXT("Not a PS2 device."));
        return;
    }

    hDevnode = SetupDiOpenDevRegKey(DeviceInfoSet,
                                    DeviceInfoData,
                                    DICS_FLAG_GLOBAL,
                                    0,
                                    DIREG_DEV,
                                    KEY_ALL_ACCESS);

    if (hDevnode == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // We are forcing the wheel detection to assume wheel is present for i8042prt.
    // If we get negative feedback from this, we will remove this code, other-
    // wise this will save us the hassle of OEM wheel mice that we
    // can't detect at all.
    //
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(hDevnode,
                        szDetect,
                        NULL,
                        NULL,
                        (PBYTE) &dwDetect,
                        &dwSize) != ERROR_SUCCESS || dwDetect == 1) {
        dwDetect = 2;
        RegSetValueEx(hDevnode,
                      szDetect,
                      0,
                      REG_DWORD,
                      (PBYTE) &dwDetect,
                      sizeof(DWORD));
    }

    //
    // See if this system can't handle init via the interrupt
    //

    //
    // Get the system bios description (a multi sz)
    //
    dwSize = 0;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szDescSystem,
                     0,
                     KEY_READ,
                     &hKeySystem) != ERROR_SUCCESS ||
        RegQueryValueEx(hKeySystem,
                        szSystemBiosVersion,
                        NULL,
                        NULL,
                        NULL,
                        &dwSize) != ERROR_SUCCESS || dwSize == 0) {
        goto finished;
    }


    dwSize++;
    szBiosNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
    dwType = 0;
    if (!szBiosNames ||
        RegQueryValueEx(hKeySystem,
                        szSystemBiosVersion,
                        NULL,
                        &dwType,
                        (PBYTE) szBiosNames,
                        &dwSize) != ERROR_SUCCESS || dwType != REG_MULTI_SZ) {
        goto finished;
    }

    //
    // Retrieve information about the driver node selected for this device.
    //
    did.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &did)) {
        goto finished;
    }

    didd.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &did,
                                    &didd,
                                    sizeof(didd),
                                    NULL)
        && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        //
        // For some reason we couldn't get detail data--this should never happen.
        //
        InputClassLogError(LogSevInformation, TEXT("Couldn't get driver info detail."));
        goto finished;
    }

    //
    // Open the INF that installs this driver node, so we can 'pre-run' the AddReg
    // entries in its install section.
    //
    hInf = SetupOpenInfFile(didd.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL);

    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //
        InputClassLogError(LogSevInformation, TEXT("Couldn't open inf."));
        goto finished;
    }

    dwSize = 0;
    if (!SetupFindFirstLine(hInf, szBadBios, NULL, &infContext) ||
        !SetupGetMultiSzField(&infContext, 1, NULL, 0, &dwSize)) {
        goto finished;
    }

    //
    // Increment the count to hold the null and alloc.  The count returned
    // is the number of characters in the strings, NOT the number of bytes
    // needed.
    //
    dwSize++;
    szBadBiosNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
    if (!szBadBiosNames ||
        !SetupGetMultiSzField(&infContext, 1, szBadBiosNames, dwSize, &dwSize)) {
        goto finished;
    }

    bad = FALSE;
    for (szCurrentBadName = szBadBiosNames;
         *szCurrentBadName;
         szCurrentBadName += wcslen(szCurrentBadName) + 1) {

        _tcsupr(szCurrentBadName);

        for (szCurrentBiosName = szBiosNames;
             *szCurrentBiosName;
             szCurrentBiosName += wcslen(szCurrentBiosName) + 1) {

            if (szCurrentBadName == szBadBiosNames) {
                _tcsupr(szCurrentBiosName);
            }

            if (_tcsstr(szCurrentBiosName, szCurrentBadName)) {
                bad =
                SetupInstallFromInfSection(NULL,
                                           hInf,
                                           szSection,
                                           SPINST_REGISTRY,
                                           hDevnode,
                                           NULL,
                                           0,
                                           NULL,
                                           NULL,
                                           DeviceInfoSet,
                                           DeviceInfoData);

                break;
            }
        }

        if (bad) {
            break;
        }
    }

finished:
    if (szBiosNames) {
        LocalFree(szBiosNames);
        szBiosNames = NULL;
    }
    if (szBadBiosNames) {
        LocalFree(szBadBiosNames);
        szBadBiosNames = NULL;
    }
    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    }
    if (hDevnode != INVALID_HANDLE_VALUE) {
        RegCloseKey(hDevnode);
        hDevnode = INVALID_HANDLE_VALUE;
    }
    if (hKeySystem != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeySystem);
        hKeySystem = INVALID_HANDLE_VALUE;
    }
}


TCHAR szMouclassParameters[] = TEXT("System\\CurrentControlSet\\Services\\Mouclass\\Parameters");
TCHAR szNativeMouseInf[] = TEXT("msmouse.inf");
TCHAR szNativeMouseServices[] =
    TEXT("MOUCLASS\0")
    TEXT("I8042PRT\0")
    TEXT("SERMOUSE\0")
    TEXT("MOUHID\0")
    TEXT("INPORT\0")
    TEXT("\0");

typedef struct _MULTI_SZ {
    LPTSTR String;
    DWORD Size;
} MULTI_SZ, *PMULTI_SZ;

typedef struct _FILTERS {
    MULTI_SZ Lower;
    MULTI_SZ Upper;
} FILTERS, *PFILTERS;

void GetFilterInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Property,
    OUT PMULTI_SZ       MultiSz
    )
{
    BOOL res;

    ZeroMemory(MultiSz, sizeof(MULTI_SZ));

    //
    // Will return FALSE and set the last error to insufficient buffer if
    // this property is present.
    //
    res = SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           NULL,
                                           NULL,
                                           0,
                                           &MultiSz->Size);

    if (res == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        MultiSz->Size > 0) {
        MultiSz->String = (LPTSTR) LocalAlloc(LPTR, MultiSz->Size);
        if (MultiSz->String) {
            if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                  DeviceInfoData,
                                                  Property,
                                                  NULL,
                                                  (PBYTE) MultiSz->String,
                                                  MultiSz->Size,
                                                  NULL)) {
                LocalFree(MultiSz->String);
                MultiSz->String = NULL;
            }
            else {
                //
                // Blow away the values.  If there is failure, RestoreDeviceFilters
                // will set the values back.  If this functions fails, there is
                // not much we can do!
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 Property,
                                                 NULL,
                                                 0);
            }
        }
    }
}

void
GetDeviceFilters(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    OUT PFILTERS        Filters
    )
{
    GetFilterInfo(DeviceInfoSet, DeviceInfoData, SPDRP_LOWERFILTERS, &Filters->Lower);
    GetFilterInfo(DeviceInfoSet, DeviceInfoData, SPDRP_UPPERFILTERS, &Filters->Upper);
}

void
FreeDeviceFilters(
    OUT PFILTERS Filters
    )
{
    if (Filters->Lower.String) {
        LocalFree(Filters->Lower.String);
        ZeroMemory(&Filters->Lower, sizeof(MULTI_SZ));
    }

    if (Filters->Upper.String) {
        LocalFree(Filters->Upper.String);
        ZeroMemory(&Filters->Upper, sizeof(MULTI_SZ));
    }
}

void
RestoreDeviceFilters(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    OUT PFILTERS        Filters
    )
{
    if (Filters->Lower.String) {
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_LOWERFILTERS,
                                         (CONST PBYTE) Filters->Lower.String,
                                         Filters->Lower.Size);
    }

    if (Filters->Upper.String) {
        SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_UPPERFILTERS,
                                         (CONST PBYTE) Filters->Upper.String,
                                         Filters->Upper.Size);
    }

    FreeDeviceFilters(Filters);
}

DWORD
MouseClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for Mouse devices.  In general,
    the default behavior is all that is required for mice.  The exceptions are:

    1.  For DIF_INSTALLDEVICE, we first check to see if this driver also controls
        other devices that we should warn the user about (e.g., PS/2 mouse driver
        also controls i8042 port).  Unless the user cancels out at that point, we
        then do the default behavior of calling SetupDiInstallDevice.  Next, we
        delete the FriendlyName property, then move the GroupOrderList tag to the
        front of the list, to ensure that the driver controlling this device loads
        before any other drivers in this load order group.

    2.  For DIF_ALLOW_INSTALL, we make sure that the driver node selected by the
        user has a service install section.  If not, then we assume it's a
        Win95-only INF, and return ERROR_NON_WINDOWS_NT_DRIVER.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD Err;
    TCHAR DeviceDescription[LINE_LEN];
    DWORD DeviceDescriptionLen;
    TCHAR NewServiceName[MAX_SERVICE_NAME_LEN], OldServiceName[MAX_SERVICE_NAME_LEN];
    BOOL  IsKbdDriver, IsOnlyKbdDriver;
    ULONG DevsControlled;
    FILTERS filters;
    ULONG DevStatus, DevProblem;
    CONFIGRET Result;
    BOOLEAN bDisableService;

    switch(InstallFunction) {

        case DIF_SELECTBESTCOMPATDRV:

            //
            // First, retrieve the device install parameters to see whether or not this is a
            // silent install.  If so, then we don't prompt the user during DIF_ALLOW_INSTALL.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)NULL;
            if(SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)DeviceInstallParams.Flags;
                SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
            }
            return ConfirmWHQLInputRequirements(DeviceInfoSet,
                                                DeviceInfoData,
                                                szNativeMouseServices,
                                                szNativeMouseInf,
                                                InstallFunction);

        case DIF_ALLOW_INSTALL :

            //
            // Check to make sure the selected driver node supports NT.
            //
            Err = ConfirmWHQLInputRequirements(DeviceInfoSet,
                                               DeviceInfoData,
                                               szNativeMouseServices,
                                               szNativeMouseInf,
                                               InstallFunction);

            if (Err == ERROR_DI_DO_DEFAULT || Err == ERROR_SUCCESS) {
                if (DriverNodeSupportsNT(DeviceInfoSet, DeviceInfoData)) {
                    Err = NO_ERROR;
                    if (UserBalksAtSharedDrvMsg(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                        Err = ERROR_DI_DONT_INSTALL;
                    }
                }
                else {
                    Err = ERROR_NON_WINDOWS_NT_DRIVER;
                }
            }

            return Err;

        case DIF_INSTALLDEVICE :

            //
            // Retrieve and cache the name of the service that's controlling this device.
            //
            if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_SERVICE,
                                                 NULL,
                                                 (PBYTE)OldServiceName,
                                                 sizeof(OldServiceName),
                                                 NULL)) {
                //
                // We could not determine the old service - assume it is a null driver
                //
                OldServiceName[0] = (TCHAR) 0;
            }

            //
            // Retrieve the status of this device instance.
            //
            Result = CM_Get_DevNode_Status(&DevStatus,
                                           &DevProblem,
                                           DeviceInfoData->DevInst,
                                           0);

            if ((Result == CR_SUCCESS) &&
                (DevStatus & DN_HAS_PROBLEM) &&
                (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                InputClassLogError(LogSevInformation, TEXT("Mouse service is disabled, so will be disabling."));
                bDisableService = TRUE;
            }
            else {
                bDisableService = FALSE;
            }

            //
            // Before we do anything, migrate the values from the services key
            // up to the devnode
            //
            MigrateToDevnode(DeviceInfoSet, DeviceInfoData);

            GetDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);

            //
            // We first want to perform the default behavior of calling
            // SetupDiInstallDevice.
            //
            if(SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData)) {


                //
                // Retrieve the name of the service which will now control the device
                //
                if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_SERVICE,
                                                     NULL,
                                                     (PBYTE)NewServiceName,
                                                     sizeof(NewServiceName),
                                                     NULL)) {
                    InputClassLogError(LogSevInformation, TEXT("Couldn't get service name."));
                    //
                    // We must have the name of this service - fail if we can't find it
                    //
                    return GetLastError();
                }

                FixUpPS2Mouse(DeviceInfoSet, DeviceInfoData, NewServiceName);

                //
                // Only consider disabling the service if it has changed and we know the old service name
                //
                if (lstrcmpi(OldServiceName, NewServiceName) && OldServiceName[0] != (TCHAR)0) {

                    if ((Err = IsKeyboardDriver(OldServiceName, &IsKbdDriver)) != NO_ERROR) {
                        InputClassLogError(LogSevInformation, TEXT("Couldn't tell if keyboard or not."));
                        RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
                        return Err;
                    }

                    if ((DevsControlled = CountDevicesControlled(OldServiceName)) != -1) {
                    // Disable the old driver service if:
                    // - it controls a keyboard, and a total of <= 2 devices (ie kbd & mouse) and it is not the
                    //   only keyboard driver
                    // - it is just a mouse driver controling one device (it the mouse) and
                    //    doesn't dynamically load

                        if (IsKbdDriver) {
                            InputClassLogError(LogSevInformation, TEXT("This is a keyboard driver."));
                            if((Err = IsOnlyKeyboardDriver(OldServiceName,&IsOnlyKbdDriver)) != NO_ERROR) {
                                InputClassLogError(LogSevInformation, TEXT("Couldn't tell if this is only keyboard."));
                                RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
                                return Err;
                            }
                            if (DevsControlled <= 2 && !IsOnlyKbdDriver) {
                                InputClassLogError(LogSevInformation, TEXT("Not the only keyboard. Disabling."));
                                DisableService(OldServiceName);
                            }
                        } else {
                            if(DevsControlled == 1 &&
                               GetServiceStartType(OldServiceName) != SERVICE_DEMAND_START) {
                                InputClassLogError(LogSevInformation, TEXT("Only controls one mouse device and not demand start."));
                                DisableService(OldServiceName);
                            }

                        }
                    }

                    //
                    // If the driver service has changed we need to move the tag for this driver to the front
                    // of its group order list.
                    //
                    DrvTagToFrontOfGroupOrderList(DeviceInfoSet, DeviceInfoData);
                }
                Err = NO_ERROR;


                //
                // We may have previously had an 'unknown' driver controlling
                // this device, with a FriendlyName generated by the user-mode
                // PnP Manager.  Delete this FriendlyName, since it's no longer
                // applicable (the DeviceDescription will be used from now on
                // in referring to this device).
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_FRIENDLYNAME, NULL, 0);

                //
                // Only disable the PS2 driver, all the other OEM driver replacements
                // will not work becuase of PNP.  This is especially true for
                // serial mice.
                //
                if (bDisableService &&
                    lstrcmpi(NewServiceName, szPS2Driver) == 0) {
                    InputClassLogError(LogSevInformation, TEXT("Disabling mouse."));
                    Err = DisableService(NewServiceName);
                }

                FreeDeviceFilters(&filters);

                return NO_ERROR;

            } else {

                Err = GetLastError();
                InputClassLogError(LogSevInformation, TEXT("SetupDiInstallDevice failed with status %x."), Err);
                if(Err != ERROR_CANCELLED) {
                    //
                    // If the error was for anything other than a user cancel, then bail now.
                    //
                    return Err;
                }

                //
                // Is there a driver installed for this device?  If so, then the user started to
                // change the driver, then changed their mind.  We don't want to do anything special
                // in this case.
                //
                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_SERVICE,
                                                    NULL,
                                                    (PBYTE)DeviceDescription,
                                                    sizeof(DeviceDescription),
                                                    NULL))
                {
                    return ERROR_CANCELLED;
                }

                //
                // The user cancelled out of the installation.  There are two scenarios where
                // this could happen:
                //
                //     1.  There really was a mouse to be installed, but the user changed their
                //         mind, didn't have the source media, etc.
                //     2.  There wasn't really a mouse.  This happens with certain modems that
                //         fool ntdetect into thinking that they're really mice.  The poor user
                //         doesn't get a chance to nip this in the bud earlier, because umpnpmgr
                //         generates an ID that yields a rank-0 match.
                //
                // Scenario (2) is particularly annoying, because the user will get the popup
                // again and again, until they finally agree to install the sermouse driver (even
                // though they don't have a serial mouse).
                //
                // To work around this problem, we special case the user-cancel scenario by going
                // ahead and installing the NULL driver for this device.  This will keep the user
                // from getting any more popups.  However, it doesn't mess up the user who cancelled
                // because of scenario (1).  That's because this device is still of class "Mouse",
                // and thus will show up in the mouse cpl.  We write out a friendly name for it that
                // has the text " (no driver)" at the end, to indicate that this device currently has
                // the NULL driver installed.  That way, if the user really experienced scenario (1),
                // they can later go to the Mouse cpl, select the no-driver device, and click the
                // "Change" button to install the correct driver for it.
                //
                if (SetupDiSetSelectedDriver(DeviceInfoSet, DeviceInfoData, NULL)) {
                    SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);
                }

                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_DEVICEDESC,
                                                    NULL,
                                                    (PBYTE)DeviceDescription,
                                                    sizeof(DeviceDescription),
                                                    &DeviceDescriptionLen))
                {
                    //
                    // Need length in characters, not bytes.
                    //
                    DeviceDescriptionLen /= sizeof(TCHAR);
                    //
                    // Don't count trailing NULL.
                    //
                    DeviceDescriptionLen--;

                } else {
                    //
                    // We couldn't get the device description--fall back to our default description.
                    //
                    DeviceDescriptionLen = LoadString(MyModuleHandle,
                                                      IDS_DEVNAME_UNK,
                                                      DeviceDescription,
                                                      SIZECHARS(DeviceDescription)
                                                     );
                }

                //
                // Now, append our " (no driver)" text.
                //
                LoadString(MyModuleHandle,
                           IDS_NODRIVER,
                           &(DeviceDescription[DeviceDescriptionLen]),
                           SIZECHARS(DeviceDescription) - DeviceDescriptionLen
                          );

                //
                // And, finally, set the friendly name for this device to be the description we
                // just generated.
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_FRIENDLYNAME,
                                                 (PBYTE)DeviceDescription,
                                                 (lstrlen(DeviceDescription) + 1) * sizeof(TCHAR)
                                                );

                RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);

                return ERROR_CANCELLED;
            }

       case DIF_ADDPROPERTYPAGE_ADVANCED:

            if (DeviceInfoData) {
                //
                // Retrieve the status of this device instance.
                //
                Result = CM_Get_DevNode_Status(&DevStatus,
                                               &DevProblem,
                                               DeviceInfoData->DevInst,
                                               0);

                if ((Result == CR_SUCCESS) &&
                    (DevStatus & DN_HAS_PROBLEM) &&
                    (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                    //
                    // If the controlling service has been disabled, this device
                    // is most likely under the control of a legacy driver.  We
                    // should not let device manager display the standard
                    // driver, resource, or power property pages by claiming to
                    // have added them here.
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    if (SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                                      DeviceInfoData,
                                                      &DeviceInstallParams)) {
    
                        DeviceInstallParams.Flags   |= (DI_DRIVERPAGE_ADDED | DI_RESOURCEPAGE_ADDED);
                        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_POWERPAGE_ADDED;
    
                        SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                      DeviceInfoData,
                                                      &DeviceInstallParams);
                    }

                    return NO_ERROR;
                }
            }
            return ERROR_DI_DO_DEFAULT;

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}

typedef struct _VALUE_INFORMATION {
    DWORD dwSize;
    DWORD dwType;
    PVOID pData;
    PTCHAR szName;
} VALUE_INFORMATION, *PVALUE_INFORMATION;

BOOL
KeyboardClassInstallDevice(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    PVALUE_INFORMATION      values = NULL, currentValue;
    ULONG                   numValues = 0;
    HKEY                    hSource = (HKEY) INVALID_HANDLE_VALUE;
    SP_DRVINFO_DETAIL_DATA  didd;
    SP_DRVINFO_DATA         did;
    HINF                    hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT              infContext;
    DWORD                   dwSize;
    TCHAR                   szSectionName[LINE_LEN];
    PTCHAR                  szService = NULL, szServicePath = NULL,
                            szValueNames = NULL, szCurrentName = NULL;
    BOOL                    success = FALSE;
    TCHAR                   szRegServices[]  = TEXT("System\\CurrentControlSet\\Services\\");
    TCHAR                   szParameters[]  = TEXT("\\Parameters");
    TCHAR                   szMaintain[]  = TEXT(".KeepValues");
    BOOL                    installedDevice = FALSE;
    FILTERS                 filters;

    //
    // Only save the values if we are in gui mode setup
    //
    if (!pInGUISetup(DeviceInfoSet, DeviceInfoData)) {
        goto cleanup;
    }

    //
    // Retrieve information about the driver node selected for this device.
    //
    did.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &did)) {
        InputClassLogError(LogSevInformation, TEXT("SetupDiGetSelectedDriver failed."));
        goto cleanup;
    }

    didd.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &did,
                                    &didd,
                                    sizeof(didd),
                                    NULL)
        && (GetLastError() != ERROR_INSUFFICIENT_BUFFER)) {
        InputClassLogError(LogSevInformation, TEXT("Couldn't get driver details."));
        //
        // For some reason we couldn't get detail data--this should never happen.
        //
        goto cleanup;
    }

    //
    // Open the INF that installs this driver node
    //
    hInf = SetupOpenInfFile(didd.InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason we couldn't open the INF--this should never happen.
        //
        goto cleanup;
    }

    if (!SetupDiGetActualSectionToInstall(hInf,
                                          didd.SectionName,
                                          szSectionName,
                                          sizeof(szSectionName) / sizeof(TCHAR),
                                          NULL,
                                          NULL
                                          ) ||
        FAILED(StringCchCat(szSectionName, SIZECHARS(szSectionName), szMaintain)) ||
        (!SetupFindFirstLine(hInf,
                             szSectionName,
                             NULL,
                             &infContext))) {
        //
        // No such section, just install the device and return
        //
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetStringField(&infContext, 0, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szService = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));

        if (!szService ||
            !SetupGetStringField(&infContext, 0, szService, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    dwSize = wcslen(szRegServices)+wcslen(szService)+wcslen(szParameters)+1;
    dwSize *= sizeof(TCHAR);
    szServicePath = (PTCHAR) LocalAlloc(LPTR, dwSize);
    if (!szServicePath) {
        goto cleanup;
    }

    if (FAILED(StringCbCopy(szServicePath, dwSize, szRegServices)) ||
        FAILED(StringCbCat(szServicePath, dwSize, szService)) ||
        FAILED(StringCbCat(szServicePath, dwSize, szParameters)) ||
        (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                      szServicePath,
                      0,
                      KEY_ALL_ACCESS,
                      &hSource) != ERROR_SUCCESS)) {
        goto cleanup;
    }

    dwSize = 0;
    if (SetupGetMultiSzField(&infContext, 1, NULL, 0, &dwSize)) {
        //
        // Increment the count to hold the null and alloc.  The count returned
        // is the number of characters in the strings, NOT the number of bytes
        // needed.
        //
        dwSize++;
        szValueNames = (PTCHAR) LocalAlloc(LPTR, dwSize * sizeof(TCHAR));
        if (!szValueNames ||
            !SetupGetMultiSzField(&infContext, 1, szValueNames, dwSize, &dwSize)) {
            goto cleanup;
        }
    }
    else {
        goto cleanup;
    }

    numValues = SetupGetFieldCount(&infContext);
    values = (PVALUE_INFORMATION)
        LocalAlloc(LPTR, (numValues + 1) * sizeof(VALUE_INFORMATION));

    if (!values) {
        goto cleanup;
    }

    currentValue = values;

    for (szCurrentName = szValueNames;
         *szCurrentName;
         szCurrentName += wcslen(szCurrentName) + 1) {

        if (RegQueryValueEx(hSource,
                            szCurrentName,
                            0,
                            &currentValue->dwType,
                            (PBYTE) NULL,
                            &currentValue->dwSize) == ERROR_SUCCESS) {

            currentValue->szName = szCurrentName;

            currentValue->pData = LocalAlloc(LPTR, currentValue->dwSize);
            if (!currentValue->pData) {
                ZeroMemory(currentValue, sizeof(VALUE_INFORMATION));
                continue;
            }

            if (RegQueryValueEx(hSource,
                                currentValue->szName,
                                0,
                                &currentValue->dwType,
                                (PBYTE) currentValue->pData,
                                &currentValue->dwSize) == ERROR_SUCCESS) {
                currentValue++;
            }
            else {
                ZeroMemory(currentValue, sizeof(VALUE_INFORMATION));
            }
        }
    }

    GetDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
    installedDevice = TRUE;
    success = SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);

    for (currentValue = values; ; currentValue++) {
        if (currentValue->pData) {
            if (success) {
                RegSetValueEx(hSource,
                              currentValue->szName,
                              0,
                              currentValue->dwType,
                              (PBYTE) currentValue->pData,
                              currentValue->dwSize);
            }
            LocalFree(currentValue->pData);
        }
        else {
            //
            // if currentValue->pData is blank, no other entries exist
            //
            break;
        }
    }

    LocalFree(values);

cleanup:
    //
    // Clean up and leave
    //
    if (hInf != (HKEY) INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if (hSource != (HKEY) INVALID_HANDLE_VALUE) {
        RegCloseKey(hSource);
    }
    if (szService) {
        LocalFree(szService);
    }
    if (szServicePath) {
        LocalFree(szServicePath);
    }
    if (szValueNames) {
        LocalFree(szValueNames);
    }

    if (!installedDevice) {
        GetDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
        success = SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData);
    }

    if (success) {
        FreeDeviceFilters(&filters);
    }
    else {
        RestoreDeviceFilters(DeviceInfoSet, DeviceInfoData, &filters);
    }

    return success;
}

TCHAR szKbdclassParameters[] = TEXT("System\\CurrentControlSet\\Services\\Kbdclass\\Parameters");
TCHAR szNativeKeyboardInf[] = TEXT("keyboard.inf");
TCHAR szNativeKeyboardServices[] =
    TEXT("KBDCLASS\0")
    TEXT("I8042PRT\0")
    TEXT("KBDHID\0")
    TEXT("\0");

DWORD
KeyboardClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for Keyboard devices.  In general,
    the default behavior is all that is required for keyboards.  The exceptions are:

    1.  For DIF_INSTALLDEVICE, we first check to see if this driver also controls
        other devices that we should warn the user about (e.g., i8042 keyboard driver
        also controls PS/2 mouse port).  Unless the user cancels out at that point, we
        then do the default behavior of calling SetupDiInstallDevice.  Next, we
        delete the FriendlyName property, then move the GroupOrderList tag to the
        front of the list, to ensure that the driver controlling this device loads
        before any other drivers in this load order group.

    2.  For DIF_ALLOW_INSTALL, we make sure that the driver node selected by the
        user has a service install section.  If not, then we assume it's a
        Win95-only INF, and return ERROR_NON_WINDOWS_NT_DRIVER.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    TCHAR OldServiceName[MAX_SERVICE_NAME_LEN], NewServiceName[MAX_SERVICE_NAME_LEN];
    DWORD Err;
    ULONG DevStatus, DevProblem;
    CONFIGRET Result;
    BOOLEAN bDisableService;

    switch(InstallFunction) {

        case DIF_SELECTBESTCOMPATDRV:

            //
            // First, retrieve the device install parameters to see whether or not this is a
            // silent install.  If so, then we don't prompt the user during DIF_ALLOW_INSTALL.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)NULL;
            if(SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                DeviceInstallParams.ClassInstallReserved = (ULONG_PTR)DeviceInstallParams.Flags;
                SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams);
            }
            return ConfirmWHQLInputRequirements(DeviceInfoSet,
                                                DeviceInfoData,
                                                szNativeKeyboardServices,
                                                szNativeKeyboardInf,
                                                InstallFunction);

        case DIF_ALLOW_INSTALL :

            //
            // Check to make sure the selected driver node supports NT.
            //
            Err = ConfirmWHQLInputRequirements(DeviceInfoSet,
                                               DeviceInfoData,
                                               szNativeKeyboardServices,
                                               szNativeKeyboardInf,
                                               InstallFunction);

            if (Err == ERROR_DI_DO_DEFAULT || Err == ERROR_SUCCESS) {
                if (DriverNodeSupportsNT(DeviceInfoSet, DeviceInfoData)) {
                    Err = NO_ERROR;
                    if (UserBalksAtSharedDrvMsg(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
                        Err = ERROR_DI_DONT_INSTALL;
                    }
                }
                else {
                    Err = ERROR_NON_WINDOWS_NT_DRIVER;
                }
            }

            return Err;

        case DIF_INSTALLDEVICE :

            //
            // Retrieve and cache the name of the service that's controlling this device.
            //
            if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_SERVICE,
                                                 NULL,
                                                 (PBYTE)OldServiceName,
                                                 sizeof(OldServiceName),
                                                 NULL)) {
                //
                // We could not determine the old service - assume it is a null driver
                //
                OldServiceName[0] = (TCHAR) 0;
            }

            //
            // Before we do anything, migrate the values from the services key
            // up to the devnode
            //
            MigrateToDevnode(DeviceInfoSet, DeviceInfoData);

            //
            // Retrieve the status of this device instance.
            //
            Result = CM_Get_DevNode_Status(&DevStatus,
                                           &DevProblem,
                                           DeviceInfoData->DevInst,
                                           0);

            if ((Result == CR_SUCCESS) &&
                (DevStatus & DN_HAS_PROBLEM) &&
                (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                InputClassLogError(LogSevInformation, TEXT("Keyboard is disabled, so will disable."));
                bDisableService = TRUE;
            }
            else {
                bDisableService = FALSE;
            }

            //
            // Perform the default behavior of calling SetupDiInstallDevice.
            //
            if(KeyboardClassInstallDevice(DeviceInfoSet, DeviceInfoData)) {
                //
                // Retrieve the name of the service which will now control the device
                //
                if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_SERVICE,
                                                     NULL,
                                                     (PBYTE)NewServiceName,
                                                     sizeof(NewServiceName),
                                                     NULL)) {
                    return GetLastError();
                }

                //
                // Only consider disabling the service if it has changed and we know the old service name
                //
                if(lstrcmpi(OldServiceName, NewServiceName) && OldServiceName[0] != (TCHAR)0) {

                    //
                    // Disable the old service that was controlling the device
                    //
                    InputClassLogError(LogSevInformation, TEXT("Disabling old service to start new one."));
                    if((Err = DisableService(OldServiceName)) != NO_ERROR) {
                        return Err;
                    }

                    //
                    // If the driver service has changed we need to move the tag for this driver to the front
                    // of its group order list.
                    //
                    DrvTagToFrontOfGroupOrderList(DeviceInfoSet, DeviceInfoData);
                }

                Err = NO_ERROR;

                //
                // We may have previously had an 'unknown' driver controlling
                // this device, with a FriendlyName generated by the user-mode
                // PnP Manager.  Delete this FriendlyName, since it's no longer
                // applicable (the DeviceDescription will be used from now on
                // in referring to this device).
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet, DeviceInfoData, SPDRP_FRIENDLYNAME, NULL, 0);

                if (bDisableService &&
                    lstrcmpi(NewServiceName, szPS2Driver) == 0) {
                    InputClassLogError(LogSevInformation, TEXT("Disabling PS2 keyboard."));
                    Err = DisableService(NewServiceName);
                }

                return Err;
            } else {
                InputClassLogError(LogSevInformation, TEXT("KeyboardClassInstallDevice failed."));
                return GetLastError();
            }

       case DIF_ADDPROPERTYPAGE_ADVANCED:

            if (DeviceInfoData) {
                //
                // Retrieve the status of this device instance.
                //
                Result = CM_Get_DevNode_Status(&DevStatus,
                                               &DevProblem,
                                               DeviceInfoData->DevInst,
                                               0);

                if ((Result == CR_SUCCESS) &&
                    (DevStatus & DN_HAS_PROBLEM) &&
                    (DevProblem == CM_PROB_DISABLED_SERVICE)) {
                    //
                    // If the controlling service has been disabled, this device
                    // is most likely under the control of a legacy driver.  We
                    // should not let device manager display the standard
                    // driver, resource, or power property pages by claiming to
                    // have added them here.
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    if (SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                                      DeviceInfoData,
                                                      &DeviceInstallParams)) {
    
                        DeviceInstallParams.Flags   |= (DI_DRIVERPAGE_ADDED | DI_RESOURCEPAGE_ADDED);
                        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_POWERPAGE_ADDED;
    
                        SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                      DeviceInfoData,
                                                      &DeviceInstallParams);
                    }

                    return NO_ERROR;
                }
            }
            return ERROR_DI_DO_DEFAULT;

        default :
            //
            // Just do the default action.
            //
            return ERROR_DI_DO_DEFAULT;
    }
}


DWORD
DrvTagToFrontOfGroupOrderList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )

/*++

Routine Description:

    This routine moves the tag value for the specified device's driver to the
    front of its corresponding GroupOrderList entry.

    ********** We don't do the following any more *************************
    It also marks the device's service with a PlugPlayServiceType value of
    0x2 (PlugPlayServicePeripheral), so that we won't attempt to generate a
    legacy device instance for this service in the future.
    ***********************************************************************

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device whose driver is being modified.

    DeviceInfoData - Supplies the address of a device information element whose
        driver is being modified.

Return Value:

    If the function is successful, the return value is NO_ERROR.
    If the function fails, the return value is a Win32 error code.

--*/

{
    TCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    SC_HANDLE SCMHandle = NULL, ServiceHandle = NULL;
    DWORD Err;
    LPQUERY_SERVICE_CONFIG ServiceConfig;

    //
    // Retrieve the name of the service that's controlling this device.
    //
    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                         DeviceInfoData,
                                         SPDRP_SERVICE,
                                         NULL,
                                         (PBYTE)ServiceName,
                                         sizeof(ServiceName),
                                         NULL)) {
        return GetLastError();
    }

    //
    // Now open this service, and call some private Setup API helper routines to
    // retrieve the tag, and move it to the front of the GroupOrderList.
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        return GetLastError();
    }

    if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }

    if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig)) != NO_ERROR) {
        goto clean0;
    }

    //
    // Only do this if this is a kernel or filesystem driver, and it's a member of
    // a load group (with a tag assigned).  This should always be the case for keyboard
    // and mouse drivers, but this is just to be safe.
    //
    if(ServiceConfig->lpLoadOrderGroup && *(ServiceConfig->lpLoadOrderGroup) &&
       (ServiceConfig->dwServiceType & (SERVICE_KERNEL_DRIVER | SERVICE_FILE_SYSTEM_DRIVER))) {
        //
        // This driver meets all the criteria--it better have a tag!!!
        //
        MYASSERT(ServiceConfig->dwTagId);

        //
        // Move the tag to the front of the list.
        //
        Err = pSetupAddTagToGroupOrderListEntry(ServiceConfig->lpLoadOrderGroup,
                                          ServiceConfig->dwTagId,
                                          TRUE
                                         );
    }

    MyFree(ServiceConfig);

clean0:
    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }

    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    return Err;
}


BOOL
UserBalksAtSharedDrvMsg(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams
    )

/*++

Routine Description:

    This routine finds out if there are any other devices affected by the impending
    device installation, and if so, warns the user about it (unless this is a quiet
    installation).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device whose driver is being modified.

    DeviceInfoData - Supplies the address of a device information element whose
        driver is being modified.

    DeviceInstallParams - Supplies the address of a device install parameters structure
        to be used in this routine.  Since callers of this routine always have this
        structure 'laying around', they provide it to this routine to be used as a
        workspace.

Return Value:

    If the user decides not to go through with it, the return value is TRUE, otherwise
    it is FALSE.

--*/

{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    BOOL b, result;
    INFCONTEXT InfContext;
    PCTSTR SectionName, AffectedComponentsString;

    //
    // First, retrieve the device install parameters to see whether or not this is a
    // silent install.  If so, then we don't prompt the user. We saved away these
    // params during DIF_SELECTBESTCOMPATDRV, so check this first.
    //
    DeviceInstallParams->cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, DeviceInstallParams)) {
        if((DeviceInstallParams->Flags & DI_QUIETINSTALL) ||
           (DeviceInstallParams->ClassInstallReserved & DI_QUIETINSTALL)) {
            InputClassLogError(LogSevInformation, TEXT("Quiet install requested."));
            return FALSE;
        }
    } else {
        //
        // Couldn't retrieve the device install params--initialize the parent window handle
        // to NULL, in case we need it later for the user prompt dialog.
        //
        DeviceInstallParams->hwndParent = NULL;
    }

    //
    // Retrieve the currently-selected driver we're about to install.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet,
                                 DeviceInfoData,
                                 &DriverInfoData)) {
        return FALSE;
    }

    //
    // Retrieve information about the INF install section for the selected driver.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL)
       && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        //
        // Then we failed, and it wasn't simply because we didn't provide the extra
        // space for hardware/compatible IDs.
        //
        return FALSE;
    }

    //
    // Open the associated INF file.
    //
    if((hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                                NULL,
                                INF_STYLE_WIN4,
                                NULL)) == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // Now look through the [ControlFlags] section at all 'SharedDriver' entries, to
    // see if any of them reference an install section that matches what we're about
    // to install.
    //
    for(b = SetupFindFirstLine(hInf, INFSTR_CONTROLFLAGS_SECTION, TEXT("SharedDriver"), &InfContext);
        b;
        b = SetupFindNextMatchLine(&InfContext, TEXT("SharedDriver"), &InfContext))
    {
        //
        // The format of the line is SharedDriver=<InstallSection>,<AffectedComponentsString>
        //
        if((SectionName = pSetupGetField(&InfContext, 1)) &&
           !lstrcmpi(SectionName, DriverInfoDetailData.SectionName)) {
            //
            // We found a match--now retrieve the string describing the other component(s) that
            // are affected by this installation.
            //
            if(AffectedComponentsString = pSetupGetField(&InfContext, 2)) {
                break;
            }
        }
    }

    if(!b) {
        //
        // Then we never found a match.
        //
        result = FALSE;
    }
    else {
        //
        // We need to popup a message box to the user--retrieve the parent window handle for this
        // device information element.
        //
        result = (IDNO == MessageBoxFromMessage(DeviceInstallParams->hwndParent,
                                                MSG_CONFIRM_SHAREDDRV_INSTALL,
                                                NULL,
                                                IDS_CONFIRM_DEVINSTALL,
                                                MB_ICONWARNING | MB_YESNO,
                                                AffectedComponentsString));
    }

    SetupCloseInfFile(hInf);

    return result;
}


VOID
CopyFixedUpDeviceId(
      OUT LPWSTR  DestinationString,
      IN  LPCWSTR SourceString,
      IN  DWORD   SourceStringLen
      )
/*++

Routine Description:

    This routine copies a device id, fixing it up as it does the copy.
    'Fixing up' means that the string is made upper-case, and that the
    following character ranges are turned into underscores (_):

    c <= 0x20 (' ')
    c >  0x7F
    c == 0x2C (',')

    (NOTE: This algorithm is also implemented in the Config Manager APIs,
    and must be kept in sync with that routine. To maintain device identifier
    compatibility, these routines must work the same as Win95.)

Arguments:

    DestinationString - Supplies a pointer to the destination string buffer
        where the fixed-up device id is to be copied.  This buffer must
        be large enough to hold a copy of the source string (including
        terminating NULL).

    SourceString - Supplies a pointer to the (null-terminated) source
        string to be fixed up.

    SourceStringLen - Supplies the length, in characters, of the source
        string (not including terminating NULL).

Return Value:

    None.  If an exception occurs during processing, the DestinationString will
    be empty upon return.

--*/
{
    PWCHAR p;

     try {

       CopyMemory(DestinationString,
                  SourceString,
                  (SourceStringLen + 1) * sizeof(TCHAR)
                 );

       CharUpperBuff(DestinationString, SourceStringLen);

       for(p = DestinationString; *p; p++) {

          if((*p <= TEXT(' '))  || (*p > (WCHAR)0x7F) || (*p == TEXT(','))) {

             *p = TEXT('_');
          }
       }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        *DestinationString = TEXT('\0');
    }
}

DWORD
PnPInitializationThread(
    IN PVOID ThreadParam
    )
/*++

Routine Description:

    This routine handles the PnP operations that go on asynchronously to the rest of the
    system installation.  This thread operates silently, and the only clue the user will
    have that it's running is that their disk will be working (precompiling INFs, etc.),
    while they're interacting with the UI.

Arguments:

    ThreadParam - ignored.

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

    No one cares about this thread's success or failure (yet).

--*/
{
    DWORD Err = NO_ERROR;
    HDEVINFO hDevInfo;
    DWORD i;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DEVINSTALL_PARAMS DevInstallParams;

    UNREFERENCED_PARAMETER(ThreadParam);

    //
    // Retrieve a list of all devices of unknown class.  We will process the device information
    // elements in this list to do the migration.
    //
    if((hDevInfo = SetupDiGetClassDevs((LPGUID)&GUID_DEVCLASS_LEGACYDRIVER,
                                       L"Root",
                                       NULL,
                                       0)) != INVALID_HANDLE_VALUE) {
        //
        // First, migrate any display devices.  (As a side effect, every device instance that
        // this routine doesn't migrate is returned with its ClassInstallReserved field set to
        // point to the corresponding service's configuration information.)
        //
        MigrateLegacyDisplayDevices(hDevInfo);

        //
        // Enumerate each device information element in the set, freeing any remaining service
        // configs.
        //
        DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        for(i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &DeviceInfoData); i++) {

            if(SetupDiGetDeviceInstallParams(hDevInfo, &DeviceInfoData, &DevInstallParams)) {
                //
                // A non-zero ClassInstallReserved field means we have to free the associated
                // service config.
                //
                if(DevInstallParams.ClassInstallReserved) {
                    MyFree((PVOID)(DevInstallParams.ClassInstallReserved));
                }
            }
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

    return Err;
}


VOID
MigrateLegacyDisplayDevices(
    IN HDEVINFO hDevInfo
    )
/*++

Routine Description:

    This routine examines each device in the supplied device information set,
    looking for elements controlled by a driver that is a member of the "Video"
    load order group.  For any such elements that it finds, it converts the
    element to be of class "Display".  If the device is not found to be of
    class "Display", then the service configuration (which we retrieved to make
    the determination), is stored away in the device install params as the
    ClassInstallReserved value.  This may be used by the caller for other
    migration purposes, although presently it is not used.  After calling this
    routine, it is the caller's responsibility to loop through all devices in
    this hDevInfo set, and free the ClassInstallReserved data (via MyFree) for
    each device that has a non-zero value.

Arguments:

    hDevInfo - Supplies a handle to the device information set containing all
        devices of class "Unknown".

Return Value:

    None.

--*/
{
    SC_HANDLE SCMHandle, ServiceHandle;
    DWORD i;
    SP_DEVINFO_DATA DevInfoData, DisplayDevInfoData;
    WCHAR ServiceName[MAX_SERVICE_NAME_LEN];
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    HDEVINFO TempDevInfoSet = INVALID_HANDLE_VALUE;
    WCHAR DevInstId[MAX_DEVICE_ID_LEN];
    SP_DEVINSTALL_PARAMS DevInstallParams;

    //
    // First, open a handle to the Service Controller.
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        //
        // If this fails, there's nothing we can do.
        //
        return;
    }

    DevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    for(i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &DevInfoData); i++) {
        //
        // Retrieve the name of the controlling service for this device instance.
        //
        if(!SetupDiGetDeviceRegistryProperty(hDevInfo,
                                             &DevInfoData,
                                             SPDRP_SERVICE,
                                             NULL,
                                             (PBYTE)ServiceName,
                                             sizeof(ServiceName),
                                             NULL)) {
            //
            // No controlling service listed--just skip this element and continue
            // with the next one.
            //
            continue;
        }

        //
        // Open a handle to this service.
        //
        if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_ALL_ACCESS))) {
            continue;
        }

        //
        // Now retrieve the service's configuration information.
        //
        if(pSetupRetrieveServiceConfig(ServiceHandle, &ServiceConfig) == NO_ERROR) {
            //
            // If this is a SERVICE_KERNEL_DRIVER that is a member of the "Video" load order
            // group, then we have ourselves a display device.
            //
            if((ServiceConfig->dwServiceType == SERVICE_KERNEL_DRIVER) &&
               ServiceConfig->lpLoadOrderGroup &&
               !lstrcmpi(ServiceConfig->lpLoadOrderGroup, L"Video")) {
                //
                // If we haven't already done so, create a new device information set without
                // an associated class, to hold our element while we munge it.
                //
                if(TempDevInfoSet == INVALID_HANDLE_VALUE) {
                    TempDevInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
                }

                if(TempDevInfoSet != INVALID_HANDLE_VALUE) {
                    //
                    // OK, we have a working space to hold this element while we change its class.
                    // Retrieve the name of this device instance.
                    //
                    if(!SetupDiGetDeviceInstanceId(hDevInfo,
                                                   &DevInfoData,
                                                   DevInstId,
                                                   SIZECHARS(DevInstId),
                                                   NULL)) {
                        *DevInstId = L'\0';
                    }

                    //
                    // Now open this element in our new, class-agnostic set.
                    //
                    DisplayDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
                    if(SetupDiOpenDeviceInfo(TempDevInfoSet,
                                             DevInstId,
                                             NULL,
                                             0,
                                             &DisplayDevInfoData)) {
                        //
                        // Now set the device's ClassGUID property to the Display class GUID.  The
                        // API will take care of cleaning up the old driver keys, etc.
                        //
                        SetupDiSetDeviceRegistryProperty(TempDevInfoSet,
                                                         &DisplayDevInfoData,
                                                         SPDRP_CLASSGUID,
                                                         (PBYTE)szDisplayClassGuid,
                                                         sizeof(szDisplayClassGuid)
                                                        );
                    }
                }

                MyFree(ServiceConfig);

            } else {
                //
                // This device information element isn't a Display device.  If
                // the service isn't disabled, then store the service
                // configuration information away in the device install params,
                // for use later.
                //
                if((ServiceConfig->dwStartType != SERVICE_DISABLED) &&
                   SetupDiGetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams)) {

                    DevInstallParams.ClassInstallReserved = (ULONG_PTR)ServiceConfig;
                    if(SetupDiSetDeviceInstallParams(hDevInfo, &DevInfoData, &DevInstallParams)) {
                        //
                        // We successfully stored a pointer to the
                        // ServiceConfig information.  Set our pointer to NULL,
                        // so we won't try to free the buffer.
                        //
                        ServiceConfig = NULL;
                    }
                }

                //
                // If we get to here, and ServiceConfig isn't NULL, then we
                // need to free it.
                //
                if(ServiceConfig) {
                    MyFree(ServiceConfig);
                }
            }
        }

        CloseServiceHandle(ServiceHandle);
    }

    CloseServiceHandle(SCMHandle);

    if(TempDevInfoSet != INVALID_HANDLE_VALUE) {
        SetupDiDestroyDeviceInfoList(TempDevInfoSet);
    }
}


BOOL
DriverNodeSupportsNT(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine determines whether the driver node selected for the specified parameters
    support Windows NT.  This determination is made based on whether or not the driver node
    has a service install section.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set

    DeviceInfoData - Optionally, supplies the address of the device information element
        within the set for which a driver node is selected.  If this parameter is not
        specified, then the driver node selected from the global class driver list will
        be used instead.

Return Value:

    If the driver node supports NT, the return value is TRUE, otherwise, it is FALSE (if
    any errors are encountered, FALSE is also returned).

--*/
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF hInf;
    WCHAR ActualSectionName[255];   // real max. section length as defined in ..\setupapi\inf.h
    LONG LineCount = -1;

    //
    // First, retrieve the selected driver node.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if(!SetupDiGetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        return FALSE;
    }

    //
    // Now, find out what INF it came from.
    //
    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData,
                                   &DriverInfoDetailData,
                                   sizeof(DriverInfoDetailData),
                                   NULL) &&
       (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
        return FALSE;
    }

    //
    // Open the associated INF file.
    //
    if((hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                                NULL,
                                INF_STYLE_WIN4,
                                NULL)) == INVALID_HANDLE_VALUE) {
        return TRUE;
    }

    //
    // Retrieve the actual name of the install section to be used for this driver node.
    //
    if (SetupDiGetActualSectionToInstall(hInf,
                                         DriverInfoDetailData.SectionName,
                                         ActualSectionName,
                                         SIZECHARS(ActualSectionName),
                                         NULL,
                                         NULL
                                         ) &&
        SUCCEEDED(StringCchCat(ActualSectionName,
                               SIZECHARS(ActualSectionName),
                               SVCINSTALL_SECTION_SUFFIX
                               ))) {
    
        LineCount = SetupGetLineCount(hInf, ActualSectionName);
    
        SetupCloseInfFile(hInf);
    }

    return (LineCount != -1);
}


DWORD
DisableService(
    IN LPTSTR       ServiceName
    )
/*++

Routine Description:

    This routine sets the start configuration setting of the named service to disabled

Arguments:

    ServiceName - the name of the service to disable

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    This operation will fail if the SCM database remains locked for a long period (see
    pSetupAcquireSCMLock for detail)

--*/
{
    DWORD Err = NO_ERROR;
    SC_HANDLE SCMHandle = NULL, ServiceHandle = NULL;
    SC_LOCK SCMLock = NULL;

    //
    // Open a handle to Service Control Manager
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Lock the SCM database
    //
    SetupDebugPrint1(L"LegacyDriver_OnApply: Locking ServiceDatabase for service %s", ServiceName);
    if((Err = pSetupAcquireSCMLock(SCMHandle, &SCMLock)) != NO_ERROR) {
        goto clean0;
    }

    //
    // Open a handle to this service
    //
    if(!(ServiceHandle = OpenService(SCMHandle, ServiceName, SERVICE_CHANGE_CONFIG))) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Perform change service config
    //
    if(!ChangeServiceConfig(ServiceHandle,
                            SERVICE_NO_CHANGE,
                            SERVICE_DISABLED,
                            SERVICE_NO_CHANGE,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL)) {

        Err = GetLastError();
    }

clean0:
    //
    // Close handle to service
    //
    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }

    //
    // Unlock the SCM database
    //
    if (SCMLock) {
        UnlockServiceDatabase(SCMLock);
        SetupDebugPrint1(L"LegacyDriver_OnApply: Unlocked ServiceDatabase for service %s", ServiceName);
    }

    //
    // Close handle to Service Control Manager
    //
    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    return Err;
}


DWORD
RetrieveDriversStatus(
    IN  SC_HANDLE               SCMHandle,
    OUT LPENUM_SERVICE_STATUS   *ppServices,
    OUT LPDWORD                 pServicesCount
    )
/*++

Routine Description:

    This routine allocates a buffer to hold the status information for all the driver
    services in the specified SCM database and retrieves that information into the
    buffer.  The caller is responsible for freeing the buffer.

Arguments:

    SCMHandle - supplies a handle to the service control manager

    ppServices - supplies the address of an ENUM_SERVICE_STATUS pointer that receives
    the address of the allocated buffer containing the requested information.

    pServicesCount - supplies the address of a variable that receives the number of elements
        in the returned ppServices array

  Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code.

Remarks:

    The pointer whose address is contained in ppServices is guaranteed to be NULL upon
    return if any error occurred.

--*/
{

    DWORD CurrentSize = 0, BytesNeeded = 0, ResumeHandle = 0, Err = NO_ERROR;
    LPENUM_SERVICE_STATUS Buffer = NULL;

    *ppServices = NULL;
    *pServicesCount = 0;

    while(!EnumServicesStatus(SCMHandle,
                       SERVICE_DRIVER,
                       SERVICE_ACTIVE | SERVICE_INACTIVE,
                       Buffer,
                       CurrentSize,
                       &BytesNeeded,
                       pServicesCount,
                       &ResumeHandle)) {
        if((Err = GetLastError()) == ERROR_MORE_DATA) {
            //
            // Resize the buffer
            //
            if(!(Buffer = MyRealloc(Buffer, BytesNeeded))) {
                //
                // Can't resize buffer - free resources and report error
                //
                if( *ppServices ) {
                    MyFree(*ppServices);
                    *ppServices = NULL;
                }
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            *ppServices = Buffer;
            CurrentSize = BytesNeeded;

        } else {
            //
            // An error we can't handle
            //
            if( *ppServices ) {
                MyFree(*ppServices);
                *ppServices = NULL;
            }

            return Err;
        }
    }

    return NO_ERROR;
}


DWORD
IsOnlyKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    )
/*++

Routine Description:

    This routines examines all the drivers in the system and determines if the named
    driver service is the only one that controls the keyboard
Arguments:

    ServiceName - supplies the name of the driver service

    pResult - pointer to a boolean value that receives the result

Return Value:

    NO_ERROR is the routine succedes, otherwise a Win32 error code

Remarks:

    The test to determine if another keyboard driver is available is based on membership
    of the keyboard load order group.  All members of this group are assumed to be capable of
    controling the keyboard.

--*/


{

    SC_HANDLE               SCMHandle = NULL, ServiceHandle;
    LPENUM_SERVICE_STATUS   pServices = NULL;
    DWORD                   ServicesCount, Count, Err = NO_ERROR;
    LPQUERY_SERVICE_CONFIG  pServiceConfig;

    MYASSERT(pResult);

    *pResult = TRUE;

    //
    // Open a handle to Service Control Manager
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }


    //
    // Get a list of all the driver services and their stati
    //
    if((Err = RetrieveDriversStatus(SCMHandle, &pServices, &ServicesCount)) != NO_ERROR) {
        goto clean0;
    }

    MYASSERT(pServices);

    //
    // Examine the configuration of each service
    //
    for(Count=0; Count < ServicesCount; Count++) {

        //
        // Check this is not our new service
        //
        if(lstrcmpi(pServices[Count].lpServiceName, ServiceName)) {

            //
            // Open a handle to this service
            //
            if(!(ServiceHandle = OpenService(SCMHandle,
                                             pServices[Count].lpServiceName,
                                             SERVICE_QUERY_CONFIG))) {
                //
                // We can't open a service handle then record the error and continue
                //
                Err = GetLastError();
                continue;
            }

            //
            // Get this services configuration data
            //
            pServiceConfig = NULL;

            if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &pServiceConfig)) != NO_ERROR) {
                //
                // We can't get service config then free any buffer, close the service
                // handle and continue, the error has been recorded
                //
                MyFree(pServiceConfig);
                CloseServiceHandle(ServiceHandle);
                continue;
            }

            MYASSERT(pServiceConfig);

            //
            // Check if it is in the keyboard load order group and it has a start of
            // SERVICE_BOOT_START OR SERVICE_SYSTEM_START.  Do the start compare first as
            // it is less expensive
            //
            if((pServiceConfig->dwStartType == SERVICE_BOOT_START
                || pServiceConfig->dwStartType == SERVICE_SYSTEM_START)
              && !lstrcmpi(pServiceConfig->lpLoadOrderGroup, SZ_KEYBOARD_LOAD_ORDER_GROUP)) {
                *pResult = FALSE;
            }

            //
            // Release the buffer
            //
            MyFree(pServiceConfig);

            //
            // Close the service handle
            //
            CloseServiceHandle(ServiceHandle);

            //
            // If we have found another keyboard driver then break out of the loop
            //
            if(!*pResult) {
                break;
            }
        }
    }

    //
    // Deallocate the buffer allocated by RetrieveDriversStatus
    //
    MyFree(pServices);

clean0:
    //
    // Close handle to Service Control Manager
    //
    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    //
    // If an error occured in the loop - ie we didn't check all the services - but we did
    // find another keyboard driver in those we did check then we can ignore the error
    // otherwise we must report it
    //
    if(NO_ERROR != Err && FALSE == *pResult) {
        Err = NO_ERROR;
    }

    return Err;
}


DWORD
GetServiceStartType(
    IN PCWSTR       ServiceName
    )
/*++

Routine Description:

    This routines examines all the drivers in the system and determines if the named
    driver service is the only one that controls the keyboard
Arguments:

    ServiceName - supplies the name of the driver service

    pResult - pointer to a boolean value that receives the result

Return Value:

    NO_ERROR is the routine succedes, otherwise a Win32 error code

Remarks:

    The test to determine if another keyboard driver is available is based on membership
    of the keyboard load order group.  All members of this group are assumed to be capable of
    controling the keyboard.

--*/

{
    SC_HANDLE               SCMHandle = NULL, ServiceHandle = NULL;
    DWORD                   dwStartType = (DWORD)-1;
    LPQUERY_SERVICE_CONFIG  pServiceConfig = NULL;

    //
    // Open a handle to Service Control Manager
    //
    if (!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        goto clean0;
    }

    //
    // Open a handle to this service
    //
    if (!(ServiceHandle = OpenService(SCMHandle,
                                     ServiceName,
                                     SERVICE_QUERY_CONFIG))) {
        goto clean0;
    }

    //
    // Get this services configuration data
    //
    if (pSetupRetrieveServiceConfig(ServiceHandle, &pServiceConfig) != NO_ERROR) {
        goto clean0;
    }

    MYASSERT(pServiceConfig);

    if( !pServiceConfig ) {
        goto clean0;
    }

    //
    // store the start type, clean up, and exit
    //
    dwStartType = pServiceConfig->dwStartType;

clean0:
    if (pServiceConfig) {
        MyFree(pServiceConfig);
    }

    //
    // Close the service handle
    //
    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }

    //
    // Close handle to Service Control Manager
    //
    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    return dwStartType;
}

LONG
CountDevicesControlled(
    IN LPTSTR       ServiceName
    )
/*++

 Routine Description:

    This routine return the number of devices controlled by a given device service
    based on information from the configuration manager

Arguments:

    ServiceName - supplies the name of the driver service

Return Value:

    The number of devices controlled by ServiceName

Remarks:

    When an error occurs the value 0 is returned - as the only place this routine is used
    is in a test for one driver installed or not this is legitimate.  This is because the
    configuration manager returns its own errors which are cannot be returned as Win32
    error codes. A mapping of config manager to Win32 errors would resolve this.

--*/
{
    ULONG BufferSize=1024;
    LONG DeviceCount=-1;
    CONFIGRET Err;
    PTSTR pBuffer = NULL, pNext;

    //
    // Allocate a 1k buffer as a first attempt
    //
    if(!(pBuffer = MyMalloc(BufferSize))) {
        goto clean0;
    }

    while((Err = CM_Get_Device_ID_List(ServiceName,
                                       pBuffer,
                                       BufferSize,
                                       CM_GETIDLIST_FILTER_SERVICE)) != CR_SUCCESS) {
        if(Err == CR_BUFFER_SMALL) {
            //
            // Find out how large a buffer is required
            //
            if(CM_Get_Device_ID_List_Size(&BufferSize,
                                          ServiceName,
                                          CM_GETIDLIST_FILTER_SERVICE) != CR_SUCCESS) {
                //
                // We can't calculate the size of the buffer required therefore we can't complete
                //
                goto clean0;
            }
            //
            // Deallocate any old buffer
            //
            MyFree(pBuffer);

            //
            // Allocate new buffer
            //
            if(!(pBuffer = MyMalloc(BufferSize))) {
                goto clean0;
            }
        } else {
            //
            // An error we can't handle - free up resources and return
            //
            goto clean0;
        }
    }


    //
    // Traverse the buffer counting the number of strings encountered
    //

    pNext = pBuffer;
    DeviceCount = 0;

    while(*pNext != (TCHAR)0) {
        DeviceCount++;
        pNext += lstrlen(pNext)+1;
    }

clean0:
    //
    // Deallocate the buffer
    //
    if (pBuffer) {
        MyFree(pBuffer);
    }

    return DeviceCount;

}


DWORD
IsKeyboardDriver(
    IN PCWSTR       ServiceName,
    OUT PBOOL       pResult
    )
/*++

Routine Description:

    This routine examines all the drivers in the system and determines if the named
    driver service is the only one that controls the keyboard.

Arguments:

    ServiceName - supplies the name of the driver service

    pResult - pointer to a boolean value that receives the result

Return Value:

    NO_ERROR is the routine succedes, otherwise a Win32 error code

Remarks:

    The test to determine if another keyboard driver is available is based on membership
    of the keyboard load order group.  All members of this group are assumed to be capable of
    controling the keyboard.

--*/
{

    SC_HANDLE               SCMHandle = NULL, ServiceHandle = NULL;
    DWORD                   Err = NO_ERROR;
    LPQUERY_SERVICE_CONFIG  pServiceConfig;

    MYASSERT(pResult);

    //
    // Open a handle to Service Control Manager
    //
    if(!(SCMHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS))) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Open a handle to this service
    //
    if(!(ServiceHandle = OpenService(SCMHandle,
                                     ServiceName,
                                     SERVICE_QUERY_CONFIG))) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Get this services configuration data
    //
    pServiceConfig = NULL;

    if((Err = pSetupRetrieveServiceConfig(ServiceHandle, &pServiceConfig)) != NO_ERROR) {
        goto clean0;
    }

    MYASSERT(pServiceConfig);

    if( !pServiceConfig ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Check if it is in the keyboard load order group and it has a start of
    // SERVICE_BOOT_START OR SERVICE_SYSTEM_START.  Do the start compare first as
    // it is less expensive
    //
    *pResult = (pServiceConfig->dwStartType == SERVICE_BOOT_START
                 || pServiceConfig->dwStartType == SERVICE_SYSTEM_START)
              && !lstrcmpi(pServiceConfig->lpLoadOrderGroup, SZ_KEYBOARD_LOAD_ORDER_GROUP);

    //
    // Release the buffer
    //
    MyFree(pServiceConfig);

clean0:
    //
    // Close the service handle
    //
    if (ServiceHandle) {
        CloseServiceHandle(ServiceHandle);
    }

    //
    // Close handle to Service Control Manager
    //
    if (SCMHandle) {
        CloseServiceHandle(SCMHandle);
    }

    return Err;
}

VOID
ReplaceSlashWithHash(
    IN PWSTR Str
    )
/*++

Routine Description:

   Replaces all backslash chars with hash chars so that the string can be used
   as a key name in the registry

--*/
{
    for ( ; *Str ; Str++) {
        if (*Str == L'\\') {
            *Str = L'#';
        }
    }
}

HANDLE
UtilpGetDeviceHandle(
    HDEVINFO DevInfo,
    PSP_DEVINFO_DATA DevInfoData,
    LPGUID ClassGuid,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    gets a handle for a device

Arguments:

    the name of the device to open

Return Value:

    handle to the device opened, which must be later closed by the caller.

Notes:

    this function is also in storage proppage (storprop.dll)
    so please propogate fixes there as well

--*/
{
    BOOL status;
    ULONG i;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;


    SP_DEVICE_INTERFACE_DATA deviceInterfaceData;

    HDEVINFO devInfoWithInterface = NULL;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceInterfaceDetailData = NULL;
    PTSTR deviceInstanceId = NULL;
    TCHAR * devicePath = NULL;

    ULONG deviceInterfaceDetailDataSize;
    ULONG deviceInstanceIdSize;


    //
    // get the ID for this device
    //

    for (i=deviceInstanceIdSize=0; i<2; i++) {

        if (deviceInstanceIdSize != 0) {

            deviceInstanceId =
                LocalAlloc(LPTR, deviceInstanceIdSize * sizeof(TCHAR));

            if (deviceInstanceId == NULL) {
                ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to "
                            "allocate for deviceInstanceId\n"));
                goto cleanup;
            }


        }

        status = SetupDiGetDeviceInstanceId(DevInfo,
                                            DevInfoData,
                                            deviceInstanceId,
                                            deviceInstanceIdSize,
                                            &deviceInstanceIdSize
                                            );
    }

    if (!status) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "Device IDs\n"));
        goto cleanup;
    }

    //
    // Get all the cdroms in the system
    //

    devInfoWithInterface = SetupDiGetClassDevs(ClassGuid,
                                               deviceInstanceId,
                                               NULL,
                                               DIGCF_DEVICEINTERFACE
                                               );

    if (devInfoWithInterface == NULL) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "list of CdRom's in system\n"));
        goto cleanup;
    }


    memset(&deviceInterfaceData, 0, sizeof(SP_DEVICE_INTERFACE_DATA));
    deviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    status = SetupDiEnumDeviceInterfaces(devInfoWithInterface,
                                         NULL,
                                         ClassGuid,
                                         0,
                                         &deviceInterfaceData
                                         );

    if (!status) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "SP_DEVICE_INTERFACE_DATA\n"));
        goto cleanup;
    }


    for (i=deviceInterfaceDetailDataSize=0; i<2; i++) {

        if (deviceInterfaceDetailDataSize != 0) {

            deviceInterfaceDetailData =
                LocalAlloc (LPTR, deviceInterfaceDetailDataSize);

            if (deviceInterfaceDetailData == NULL) {
                ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to "
                            "allocate for deviceInterfaceDetailData\n"));
                goto cleanup;
            }

            deviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        }

        status = SetupDiGetDeviceInterfaceDetail(devInfoWithInterface,
                                                 &deviceInterfaceData,
                                                 deviceInterfaceDetailData,
                                                 deviceInterfaceDetailDataSize,
                                                 &deviceInterfaceDetailDataSize,
                                                 NULL);
    }

    if (!status) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to get "
                    "DeviceInterfaceDetail\n"));
        goto cleanup;
    }

    devicePath = LocalAlloc(LPTR, deviceInterfaceDetailDataSize);
    if (devicePath == NULL) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Unable to alloc %x "
                    "bytes for devicePath\n"));
        goto cleanup;
    }

    memcpy (devicePath,
            deviceInterfaceDetailData->DevicePath,
            deviceInterfaceDetailDataSize);

    fileHandle = CreateFile(devicePath,
                            DesiredAccess,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);

    if (fileHandle == INVALID_HANDLE_VALUE) {
        ChkPrintEx(("SysSetup.GetDeviceHandle => Final CreateFile() "
                    "failed\n"));
        goto cleanup;
    }

    ChkPrintEx(("SysSetup.GetDeviceHandle => handle %x opened\n",
                fileHandle));


cleanup:

    if (devInfoWithInterface != NULL) {
        SetupDiDestroyDeviceInfoList(devInfoWithInterface);
    }

    if (deviceInterfaceDetailData != NULL) {
        LocalFree (deviceInterfaceDetailData);
    }

    if (devicePath != NULL) {
        LocalFree (devicePath);
    }

    return fileHandle;
}


DWORD
CriticalDeviceCoInstaller(
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,  OPTIONAL
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )

/*++

Routine Description:

    This routine acts as a co-installer for critical devices.  It is presently
    registered (via hivesys.inf) for CDROM, DiskDrive, System, Scsi, Hdc, and
    Keyboard classes.

    The purpose of this co-installer is to save away the services used by these
    classes of device into the CriticalDeviceDatabase registry key.  The reason
    for this is so that we can determine what drivers should be used for new
    critical devices that are found while the system is booting, and enable
    them at that time.  This solves the problem that arises when a device that
    is critical to getting the system up and running (such as the boot device),
    is moved to a new location.  When we find a new critical device for which
    we know what service to start, we can start the device and continue to boot
    without failure.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

    Context - Supplies the installation context that is per-install request and
        per-coinstaller.

Return Value:

    For pre-processing, this function only cares about DIF_INSTALLDEVICE.  For
    all other DIF requests, it returns NO_ERROR.  For DIF_INSTALLDEVICE, it
    will request post-processing by returning ERROR_DI_POSTPROCESSING_REQUIRED
    (or catastrophic error such as ERROR_NOT_ENOUGH_MEMORY).

    For post-processing, this function will always propagate the install result
    passed in to it via the co-installer Context structure.

--*/

{
    HKEY   hkDrv, hkCDD;
    DWORD  matchingDeviceIdSize, serviceNameSize, classGUIDSize, lowerFiltersSize,
           upperFiltersSize, Err, driverSize, devtype, exclusive, characteristics,
           securitySize;
    TCHAR  serviceName[MAX_SERVICE_NAME_LEN],
           classGUID[GUID_STRING_LEN],
           matchingDeviceId[MAX_DEVICE_ID_LEN];
    PCTSTR driverMatch = TEXT("\\Driver");
    PTSTR  lowerFilters, upperFilters;
    BOOL   foundService, foundClassGUID, foundLowerFilters, foundUpperFilters,
           foundSecurity, foundDevtype, foundExclusive, foundCharacteristics;
    PCDC_CONTEXT CDCContext;
    PBYTE security;

    switch(InstallFunction) {
        //
        // We only care about DIF_INSTALLDEVICE...
        //
        case DIF_INSTALLDEVICE :

            DbgPrintEx(DPFLTR_SETUP_ID,
                       DPFLTR_INFO_LEVEL,
                       "CriticalDeviceCoInstaller: DIF_INSTALLDEVICE called\n");

            if(Context->PostProcessing) {
                //
                // Track whether or not we've populated the critical device
                // database with the newly-installed settings.
                //
                BOOL CDDPopulated = FALSE;

                //
                // We're 'on the way out' of an installation.  We may have some
                // data squirrelled away for us while we were "on the way in".
                //
                CDCContext = (PCDC_CONTEXT)(Context->PrivateData);

                //
                // Make sure that the matchingDeviceId buffer is initialized to
                // an empty string.
                //
                *matchingDeviceId = TEXT('\0');

                //
                // Initialize our lowerFilters and upperFilters buffer pointers
                // to NULL, so we can track whether or not we've allocated
                // memory that must be freed.
                //
                upperFilters = lowerFilters = NULL;
                security = NULL;


                if (Context->InstallResult != NO_ERROR) {
                    //
                    //  If an error occurred prior to this call, abort and
                    //  propagate that error.
                    //
                    goto InstallDevPostProcExit;
                }

                //
                // Get the serviceName for this device.
                //
                foundService = SetupDiGetDeviceRegistryProperty(
                    DeviceInfoSet,
                    DeviceInfoData,
                    SPDRP_SERVICE,
                    NULL,
                    (PBYTE)serviceName,
                    sizeof(serviceName),
                    &serviceNameSize);

                if (foundService) {
                    //
                    // Make sure the service name isn't something like \Driver\PCI_HAL
                    //
                    driverSize = wcslen(driverMatch);
                    if (wcslen(serviceName) >= driverSize &&
                        _wcsnicmp(serviceName, driverMatch, driverSize) == 0) {

                        goto InstallDevPostProcExit;
                    }
                }

                foundClassGUID = SetupDiGetDeviceRegistryProperty(
                    DeviceInfoSet,
                    DeviceInfoData,
                    SPDRP_CLASSGUID,
                    NULL,
                    (PBYTE)classGUID,
                    sizeof(classGUID),
                    &classGUIDSize);

                //
                // The LowerFilters and UpperFilters properties are variable-
                // length, so we must dynamically size buffers to accommodate
                // their contents.
                //
                foundLowerFilters =
                    (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                       DeviceInfoData,
                                                       SPDRP_LOWERFILTERS,
                                                       NULL,
                                                       NULL,
                                                       0,
                                                       &lowerFiltersSize)
                     && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                     && (lowerFiltersSize > sizeof(TCHAR)));

                if(foundLowerFilters) {

                    lowerFilters = MyMalloc(lowerFiltersSize);

                    if(!lowerFilters) {
                        goto InstallDevPostProcExit;
                    }

                    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         SPDRP_LOWERFILTERS,
                                                         NULL,
                                                         (PBYTE)lowerFilters,
                                                         lowerFiltersSize,
                                                         NULL)) {
                        //
                        // This shouldn't happen--we know we have a big enough
                        // buffer.
                        //
                        goto InstallDevPostProcExit;
                    }
                }

                foundUpperFilters =
                    (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                       DeviceInfoData,
                                                       SPDRP_UPPERFILTERS,
                                                       NULL,
                                                       NULL,
                                                       0,
                                                       &upperFiltersSize)
                     && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                     && (upperFiltersSize > sizeof(TCHAR)));

                if(foundUpperFilters) {

                    upperFilters = MyMalloc(upperFiltersSize);

                    if(!upperFilters) {
                        goto InstallDevPostProcExit;
                    }

                    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         SPDRP_UPPERFILTERS,
                                                         NULL,
                                                         (PBYTE)upperFilters,
                                                         upperFiltersSize,
                                                         NULL)) {
                        //
                        // This shouldn't happen--we know we have a big enough
                        // buffer.
                        //
                        goto InstallDevPostProcExit;
                    }
                }

                //
                // Open Driver information key
                //
                if((hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 DICS_FLAG_GLOBAL,
                                                 0,
                                                 DIREG_DRV,
                                                 KEY_READ)) == INVALID_HANDLE_VALUE) {

                    goto InstallDevPostProcExit;

                } else {
                    //
                    // Get matchingDeviceId
                    //
                    matchingDeviceIdSize = sizeof(matchingDeviceId);
                    Err = RegQueryValueEx(hkDrv,
                                          REGSTR_VAL_MATCHINGDEVID,
                                          NULL,
                                          NULL,
                                          (PBYTE)matchingDeviceId,
                                          &matchingDeviceIdSize);
                    RegCloseKey(hkDrv);

                    if(Err != ERROR_SUCCESS) {
                        //
                        // Ensure that matchingDeviceId is still an empty string
                        //
                        *matchingDeviceId = TEXT('\0');
                        goto InstallDevPostProcExit;
                    }
                }

                foundDevtype = SetupDiGetDeviceRegistryProperty(
                                DeviceInfoSet,
                                DeviceInfoData,
                                SPDRP_DEVTYPE,
                                NULL,
                                (PBYTE)&devtype,
                                sizeof(DWORD),
                                NULL);
                    
                foundExclusive = SetupDiGetDeviceRegistryProperty(
                                    DeviceInfoSet,
                                    DeviceInfoData,
                                    SPDRP_EXCLUSIVE,
                                    NULL,
                                    (PBYTE)&exclusive,
                                    sizeof(DWORD),
                                    NULL);

                foundCharacteristics = SetupDiGetDeviceRegistryProperty(
                                        DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_CHARACTERISTICS,
                                        NULL,
                                        (PBYTE)&characteristics,
                                        sizeof(DWORD),
                                        NULL);

                foundSecurity =
                    (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                       DeviceInfoData,
                                                       SPDRP_SECURITY,
                                                       NULL,
                                                       NULL,
                                                       0,
                                                       &securitySize)
                     && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                     && (securitySize > 0));

                if(foundSecurity) {

                    security = MyMalloc(securitySize);

                    if(!security) {
                        goto InstallDevPostProcExit;
                    }

                    if(!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                         DeviceInfoData,
                                                         SPDRP_SECURITY,
                                                         NULL,
                                                         (PBYTE)security,
                                                         securitySize,
                                                         NULL)) {
                        //
                        // This shouldn't happen--we know we have a big enough
                        // buffer.
                        //
                        goto InstallDevPostProcExit;
                    }
                }


                hkCDD = OpenCDDRegistryKey(matchingDeviceId, TRUE);

                if(hkCDD != INVALID_HANDLE_VALUE) {
                    //
                    // Store all the values (service, classguid, lower and upper
                    // filters, deleting any that aren't present in the newly installed
                    // device (which might have been present from a previous install)
                    //
                    if (foundService) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_SERVICE,
                                      0,
                                      REG_SZ,
                                      (PBYTE)&serviceName,
                                      serviceNameSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_SERVICE);
                    }

                    if (foundClassGUID) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_CLASSGUID,
                                      0,
                                      REG_SZ,
                                      (PBYTE)&classGUID,
                                      classGUIDSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_CLASSGUID);
                    }

                    if (foundLowerFilters) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_LOWERFILTERS,
                                      0,
                                      REG_MULTI_SZ,
                                      (PBYTE)lowerFilters,
                                      lowerFiltersSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_LOWERFILTERS);
                    }

                    if (foundUpperFilters) {
                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_UPPERFILTERS,
                                      0,
                                      REG_MULTI_SZ,
                                      (PBYTE)upperFilters,
                                      upperFiltersSize);
                    }
                    else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_UPPERFILTERS);
                    }

                    if (foundDevtype) {
                        DbgPrintEx(DPFLTR_SETUP_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "CriticalDeviceCoInstaller: Found devtype %x for %ws\n",
                                   devtype,
                                   matchingDeviceId);

                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_DEVICE_TYPE,
                                      0,
                                      REG_DWORD,
                                      (PBYTE)&devtype,
                                      sizeof(DWORD));
                    } else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_DEVICE_TYPE);
                    }

                    if (foundExclusive) {
                        DbgPrintEx(DPFLTR_SETUP_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "CriticalDeviceCoInstaller: Found exclusive %x for %ws\n",
                                   exclusive,
                                   matchingDeviceId);

                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_DEVICE_EXCLUSIVE,
                                      0,
                                      REG_DWORD,
                                      (PBYTE)&exclusive,
                                      sizeof(DWORD));
                    } else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_DEVICE_EXCLUSIVE);
                    }

                    if (foundCharacteristics) {
                        DbgPrintEx(DPFLTR_SETUP_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "CriticalDeviceCoInstaller: Found characteristics %x for %ws\n",
                                   characteristics,
                                   matchingDeviceId);

                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_DEVICE_CHARACTERISTICS,
                                      0,
                                      REG_DWORD,
                                      (PBYTE)&characteristics,
                                      sizeof(DWORD));
                    } else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_DEVICE_CHARACTERISTICS);
                    }

                    if (foundSecurity) {
                        DbgPrintEx(DPFLTR_SETUP_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "CriticalDeviceCoInstaller: Found security %x for %ws\n",
                                   security,
                                   matchingDeviceId);

                        RegSetValueEx(hkCDD,
                                      REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR,
                                      0,
                                      REG_BINARY,
                                      (PBYTE)security,
                                      securitySize);
                    } else {
                        RegDeleteValue(hkCDD, REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR);
                    }

                    RegCloseKey(hkCDD);

                    CDDPopulated = TRUE;
                }

InstallDevPostProcExit:

                if(lowerFilters) {
                    MyFree(lowerFilters);
                }

                if(upperFilters) {
                    MyFree(upperFilters);
                }
                if (security) {
                    MyFree(security);
                }

                if(CDCContext) {
                    //
                    // If we have a private context, that means that the device
                    // was installed previously, and that it had a CDD entry.
                    // We want to restore the previous controlling service
                    // stored in this CDD entry in the following two scenarios:
                    //
                    //   1. The CDD entry for the new installation is different
                    //      than the old one.
                    //   2. We didn't end up populating the CDD entry with the
                    //      newly-installed settings (probably because the
                    //      InstallResult we were handed indicated that the
                    //      install failed.
                    //
                    if(lstrcmpi(matchingDeviceId, CDCContext->OldMatchingDevId)
                       || !CDDPopulated) {

                        hkCDD = OpenCDDRegistryKey(CDCContext->OldMatchingDevId,
                                                   FALSE
                                                  );

                        if(hkCDD != INVALID_HANDLE_VALUE) {

                            if(*(CDCContext->OldServiceName)) {
                                RegSetValueEx(hkCDD,
                                              REGSTR_VAL_SERVICE,
                                              0,
                                              REG_SZ,
                                              (PBYTE)(CDCContext->OldServiceName),
                                              (lstrlen(CDCContext->OldServiceName) + 1) * sizeof(TCHAR)
                                             );
                            } else {
                                RegDeleteValue(hkCDD, REGSTR_VAL_SERVICE);
                            }

                            RegCloseKey(hkCDD);
                        }
                    }

                    MyFree(CDCContext);
                }

                //
                // Regardless of success or failure, we always want to propagate
                // the existing install result.  In other words, any failure we
                // encounter in post-processing isn't considered critical.
                //
                return Context->InstallResult;

            } else {
                //
                // We're "on the way in".  We need to check and see if this
                // device already has a critical device database entry
                // associated with it.  If so, then we want to remember the
                // controlling service currently listed in the CDD (in case we
                // need to restore it in post-processing if the install fails).
                // We then clear this entry out of the CDD, so that, if a null
                // driver install is taking place, that we won't try to re-apply
                // the now-bogus CDD entry.  This can get us into a nasty
                // infinite loop in GUI setup where we keep finding the device
                // because it's marked as finish-install, yet every time we
                // install it, the (bogus) CDD entry gets re-applied, and the
                // devnode gets marked yet again with finish-install.
                //
                // NTRAID #59238 1999/09/01 lonnym
                // This fix is reliant upon the current
                // (somewhat broken) behavior of the kernel-mode PnP manager's
                // IopProcessCriticalDeviceRoutine.  That routine will skip any
                // CDD entries it finds that don't specify a controlling
                // service.  For NT5.1, we should remove this co-installer hack
                // and fix the kernel-mode CDD functionality so that it is only
                // applied when the devnode has a problem of not-configured (as
                // opposed to its present behavior of attempting CDD
                // application whenever there's no controlling service).
                //

                //
                // First, open driver key to retrieve the current (i.e., pre-
                // update) matching device ID.
                //
                if((hkDrv = SetupDiOpenDevRegKey(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 DICS_FLAG_GLOBAL,
                                                 0,
                                                 DIREG_DRV,
                                                 KEY_READ)) == INVALID_HANDLE_VALUE) {
                    //
                    // No need to allocate a private data structure to hand off
                    // to post-processing.
                    //
                    return ERROR_DI_POSTPROCESSING_REQUIRED;

                } else {
                    //
                    // Get matchingDeviceId
                    //
                    matchingDeviceIdSize = sizeof(matchingDeviceId);
                    Err = RegQueryValueEx(hkDrv,
                                          REGSTR_VAL_MATCHINGDEVID,
                                          NULL,
                                          NULL,
                                          (PBYTE)matchingDeviceId,
                                          &matchingDeviceIdSize);
                    RegCloseKey(hkDrv);

                    if (Err != ERROR_SUCCESS) {
                        //
                        // In this case as well, we've no need for private data
                        // during post-processing
                        //
                        return ERROR_DI_POSTPROCESSING_REQUIRED;
                    }
                }

                //
                // If we get to here, then we've retrieved a "MatchingDeviceId"
                // string from the device's driver key.  Now let's see if there
                // is a critical device entry for this ID...
                //
                hkCDD = OpenCDDRegistryKey(matchingDeviceId, FALSE);

                if(hkCDD == INVALID_HANDLE_VALUE) {
                    //
                    // No existing CDD entry for this device, hence no need for
                    // private data to be passed off to post-processing.
                    //
                    return ERROR_DI_POSTPROCESSING_REQUIRED;
                }

                //
                // If we get to here, we know that the device has been
                // previously installed, and that there exists a CDD entry for
                // that installation.  We need to allocate a private data
                // context structure to hand off to post-processing that
                // contains (a) the currently in-effect matching device id, and
                // (b) the currently in-effect controlling service (if any).
                //
                CDCContext = MyMalloc(sizeof(CDC_CONTEXT));
                if(!CDCContext) {
                    //
                    // Can't allocate memory for our structure!
                    //
                    RegCloseKey(hkCDD);

                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                StringCchCopy(CDCContext->OldMatchingDevId,
                              SIZECHARS(CDCContext->OldMatchingDevId), 
                              matchingDeviceId);

                serviceNameSize = sizeof(CDCContext->OldServiceName);
                Err = RegQueryValueEx(hkCDD,
                                      REGSTR_VAL_SERVICE,
                                      NULL,
                                      NULL,
                                      (PBYTE)(CDCContext->OldServiceName),
                                      &serviceNameSize
                                     );

                if(Err == ERROR_SUCCESS) {
                    //
                    // Successfully retrieved the controlling service name--now
                    // delete the value entry.
                    //
                    RegDeleteValue(hkCDD, REGSTR_VAL_SERVICE);

                } else {
                    //
                    // Couldn't retrieve controlling service name (most likely
                    // because there is none).  Set OldServiceName to empty
                    // string.
                    //
                    *(CDCContext->OldServiceName) = TEXT('\0');
                }

                RegCloseKey(hkCDD);

                Context->PrivateData = CDCContext;

                return ERROR_DI_POSTPROCESSING_REQUIRED;
            }

        default :
            //
            // We should always be 'on the way in', since we never request
            // postprocessing except for DIF_INSTALLDEVICE.
            //
            MYASSERT(!Context->PostProcessing);
            return NO_ERROR;
    }
}


HKEY
OpenCDDRegistryKey(
    IN PCTSTR DeviceId,
    IN BOOL   Create
    )
/*++

Routine Description:

    This routine opens (and optionally, creates if necessary) a critical device
    registry key entry for a specified device ID.

Arguments:

    DeviceId - supplies the device ID identifying the desired critical device
        database entry (registry key)

    Create - if non-zero, the registry key will be created if it doesn't
        already exist.

Return Value:

    If successful, the return value is a handle to the requested registry key.
    If failure, the return value is INVALID_HANDLE_VALUE.

--*/
{
    TCHAR MungedDeviceId[MAX_DEVICE_ID_LEN];
    HKEY hkParent, hkRet;

    //
    // Open or create for read/write access to key under
    // HKLM\System\CurrentControlSet\Control\CriticalDeviceDatabase
    //
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       REGSTR_PATH_CRITICALDEVICEDATABASE,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE,
                       NULL,
                       &hkParent,
                       NULL) != ERROR_SUCCESS) {
        return INVALID_HANDLE_VALUE;
    }

    //
    // Make a copy of the caller-supplied device ID so we can munge it.
    //
    StringCchCopy(MungedDeviceId, SIZECHARS(MungedDeviceId), DeviceId);

    ReplaceSlashWithHash(MungedDeviceId);

    if(Create) {
        if(RegCreateKeyEx(hkParent,
                          MungedDeviceId,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_READ | KEY_WRITE,
                          NULL,
                          &hkRet,
                          NULL) != ERROR_SUCCESS) {

            hkRet = INVALID_HANDLE_VALUE;
        }
    } else {
        if(RegOpenKeyEx(hkParent,
                        MungedDeviceId,
                        0,
                        KEY_READ | KEY_WRITE,
                        &hkRet) != ERROR_SUCCESS) {

            hkRet = INVALID_HANDLE_VALUE;
        }
    }

    RegCloseKey(hkParent);

    return hkRet;
}

DWORD
NtApmClassInstaller(
    IN DI_FUNCTION      DiFunction,
    IN HDEVINFO         DevInfoHandle,
    IN PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )
/*++

Routine Description:

NOTE:   When does Susan's clean up code run?  When does the win0x
        migration code run?  Do we need to call off to either of
        them in here?

NOTE:   Be sure that this works at initial install AND when the
        user does detect new hardare.

    This is the class installer for nt apm support.

    This routine installs, or thwarts installation, of the NT5 apm solution,
    depending on whether the machine is an APCI machine, is an APM machine,
    and has a good, bad, or unknown apm bios.

    This version is copied directly from the battery class driver.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    DWORD                   status, worktype;
    BOOLEAN                 InstallDisabled;


    ChkPrintEx(("syssetup: NtApmClassInstaller:"));
    ChkPrintEx(("DiFunction %08lx\n", DiFunction));

    //
    // Dispatch the InstallFunction
    //
    InstallDisabled = FALSE;

    switch (DiFunction) {
        ChkPrintEx(("syssetup: NtApmClassInstaller: DiFunction = %08lx\n",
                    DiFunction));
        case DIF_FIRSTTIMESETUP:
        case DIF_DETECT:

            worktype = DecideNtApm();

            //
            // NOTE:    We assume that if we say "do default" and we
            //          have not created a device info structure for
            //          ntapm, the installer will do *nothing*.
            //
            if (worktype == NTAPM_NOWORK) {
                ChkPrintEx(("syssetup: NtApmClassInstaller returning ERROR_DI_DO_DEFAULT"));
                return ERROR_DI_DO_DEFAULT;
            }

            if (worktype == NTAPM_INST_DISABLED) {
                InstallDisabled = TRUE;
            }

            ChkPrintEx(("syssetup: NtApmClassInstaller: calling InstallNtApm\n"));
            status = InstallNtApm(DevInfoHandle, InstallDisabled);
            ChkPrintEx(("syssetup: NtApmClassInstaller: InstallNtApm returned "
                        "%08lx\n", status));

            if (status == ERROR_SUCCESS) {
                //
                // Let the default device installer actually install ntapm.
                //
                status = ERROR_DI_DO_DEFAULT;
            }
            break;

        case DIF_ALLOW_INSTALL:

            //
            // NOTE:    If we are here, it means that either DIF_FIRSTIMESETUP
            //          has installed apm (either enabled or disabled) OR
            //          this is an upgrad of a machine where it was installed
            //          in the past.  So all we want to do is make sure
            //          that if apm is currently disabled, it stays disabled.
            //

            ChkPrintEx(("syssetup: NtApmClassIntaller: DIF_ALLOW_INSTALL\n"));

            return AllowInstallNtApm(DevInfoHandle, DevInfoData);
            break;


        case DIF_TROUBLESHOOTER:
            ChkPrintEx(("syssetup: NtApmClassInstaller: DIF_TROUBLESHOOTER\n"));
            return NO_ERROR;
            break;

        default:
            //
            // NOTE: We assume that if we say "do default" and we
            //       have not created a device info structure for ntapm,
            //       the installer will do *nothing*.
            //
            ChkPrintEx(("syssetup: NtApmClassInstaller: default:\n"));
            status = ERROR_DI_DO_DEFAULT;
            break;
    }
    ChkPrintEx(("syssetup: NtApmClassInstaller returning %08lx\n", status));
    return status;
}

DWORD
DecideNtApm(
    VOID
    )
/*++

Routine Description:

    This function decides if NtApm should be installed on the machine,
    and if it should, whether it should be installed enabled or disabled.

    This little bit of code is isolated here to make it easy to change
    policies.

Arguments:

Return Value:

    NTAPM_NOWORK - ACPI machine or no usable APM  - do nothing

    NTAPM_INST_DISABLED - APM machine, on neutral list, install disabled

    NTAPM_INST_ENABLED - APM machine, on validated good list, install enabled

--*/
{
    DWORD   BiosType;


    //
    // NOTE: The following two tests are somewhat redundent.
    //       (In theory, you cannot be ApmLegalHal AND Acpi
    //       at the same time.)  But, this belt and suspenders
    //       approach is very cheap, and will insure we do the
    //       right thing in certain upgrade and reinstall scenarios.
    //       So we leave both in.
    //

    ChkPrintEx(("syssetup: DecideNtApm: entered\n"));

    if ( ! IsProductTypeApmLegal()) {
        // it's not a workstation, so do nothing.
        return NTAPM_NOWORK;
    }

    if (IsAcpiMachine()) {

        //
        // It's an ACPI machine, so do nothing
        //
        ChkPrintEx(("syssetup: DecideNtApm: acpi box, return NTAPM_NOWORK\n"));
        return NTAPM_NOWORK;

    }

    if (IsApmLegalHalMachine() == FALSE) {

        //
        // It's NOT a standard Hal machine as required
        // by ntapm, so do nothing.
        //
        ChkPrintEx(("syssetup: DecideNtApm: not apm legal, return NTAPM_NOWORK\n"));
        return NTAPM_NOWORK;

    }


    BiosType = IsApmPresent();

    if (BiosType == APM_ON_GOOD_LIST) {

        ChkPrintEx(("syssetup: DecideNtApm: return NTAPM_INST_ENABLED\n"));
        return NTAPM_INST_ENABLED;

    } else if (BiosType == APM_NEUTRAL) {

        ChkPrintEx(("syssetup: DecideNtApm: return NTAPM_INST_DISABLED\n"));
        return NTAPM_INST_DISABLED;

    } else {

        ChkPrintEx(("syssetup: DecideNtApm: return NTAPM_NOWORK\n"));
        return NTAPM_NOWORK;

    }
}


DWORD
InstallNtApm(
    IN     HDEVINFO                DevInfoHandle,
    IN     BOOLEAN                 InstallDisabled
    )
/*++

Routine Description:

    This function installs the composite battery if it hasn't already been
    installed.

Arguments:

    DevInfoHandle       - Handle to a device information set

    InstallDisabled     - TRUE if caller wants us to install disabled

Return Value:

--*/
{
    DWORD                   status;
    SP_DRVINFO_DATA         driverInfoData;
    TCHAR                   tmpBuffer[100];
    DWORD                   bufferLen;
    PSP_DEVINFO_DATA        DevInfoData;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    ChkPrintEx(("syssetup: InstallNtApm: DevInfoHandle = %08lx   installdisabled = %08lx\n", DevInfoHandle, InstallDisabled));
    DevInfoData = LocalAlloc(LPTR, sizeof(SP_DEVINFO_DATA));
    if ( ! DevInfoData) {
        status = GetLastError();
        goto clean0;
    }
    DevInfoData->cbSize = sizeof(SP_DEVINFO_DATA);
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    //
    // Attempt to manufacture a new device information element for the root enumerated
    // ntapm device.
    //

    if(!SetupDiCreateDeviceInfo(DevInfoHandle,
                                TEXT("ROOT\\NTAPM\\0000"),
                                (LPGUID)&GUID_DEVCLASS_APMSUPPORT,
                                TEXT("NT Apm Legacy Support"),
                                NULL,
                                0,
                                DevInfoData))
    {
        status = GetLastError();

        if (status == ERROR_DEVINST_ALREADY_EXISTS) {
            //
            // NtApm is already installed.
            //
            ChkPrintEx(("ntapm Already Installed\n"));
            status = ERROR_SUCCESS;
            goto clean1;
        } else {
            ChkPrintEx(("Error creating ntapm devinfo - %x\n", status));
            goto clean1;
        }
    }

    //
    // Set device to Install Disabled if the caller wants that
    //
    if (InstallDisabled) {

        if (!SetupDiGetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
            status = GetLastError();
            goto clean1;
        }
        DevInstallParams.Flags |= DI_INSTALLDISABLED;
        if (!SetupDiSetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
            status = GetLastError();
            goto clean1;
       }
    }


    //
    // Register the device so it is not a phantom anymore
    //
    if (!SetupDiRegisterDeviceInfo(DevInfoHandle, DevInfoData, 0, NULL, NULL, NULL)) {
        status = GetLastError();
        SetupDebugPrint1(L"Couldn't register device - %x\n", status);
        goto clean3;
    }


    //
    // Set the hardware ID.  "NTAPM"
    //
    memset (tmpBuffer, 0, sizeof(tmpBuffer));
    StringCchCopy (tmpBuffer, SIZECHARS(tmpBuffer), TEXT("NTAPM"));

    bufferLen = (lstrlen(tmpBuffer) + 1) * sizeof(TCHAR);
    //SetupDebugPrint2(L"tmpBuffer - %ws\n with strlen = %x\n", tmpBuffer, bufferLen);
    //SetupDebugPrint1(L"tmpBuffer@ = %08lx\n", tmpBuffer);

    status = SetupDiSetDeviceRegistryProperty (
                        DevInfoHandle,
                        DevInfoData,
                        SPDRP_HARDWAREID,
                        (PBYTE)tmpBuffer,
                        bufferLen
                        );

    if (!status) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't set the HardwareID - %x\n", status);
        goto clean3;
    }


    //
    // Build a compatible driver list for this new device...
    //

    if(!SetupDiBuildDriverInfoList(DevInfoHandle, DevInfoData, SPDIT_COMPATDRIVER)) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't build class driver list - %x\n", status);
        goto clean3;
    }


    //
    // Select the first driver in the list as this will be the most compatible
    //

    driverInfoData.cbSize = sizeof (SP_DRVINFO_DATA);
    if (!SetupDiEnumDriverInfo(DevInfoHandle, DevInfoData, SPDIT_COMPATDRIVER, 0, &driverInfoData)) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't get driver list - %x\n", status);
        goto clean3;

    } else {


        //SetupDebugPrint4(L"Driver info - \n"
        //       L"------------- DriverType     %x\n"
        //       L"------------- Description    %s\n"
        //       L"------------- MfgName        %s\n"
        //       L"------------- ProviderName   %s\n\n",
        //       driverInfoData.DriverType,
        //       driverInfoData.Description,
        //       driverInfoData.MfgName,
        //       driverInfoData.ProviderName);
        if (!SetupDiSetSelectedDriver(DevInfoHandle, DevInfoData, &driverInfoData)) {
            status = GetLastError();
            //SetupDebugPrint1(L"Couldn't select driver - %x\n", status);
            goto clean3;
        }
    }



    if (!SetupDiInstallDevice (DevInfoHandle, DevInfoData)) {
        status = GetLastError();
        //SetupDebugPrint1(L"Couldn't install device - %x\n", status);
        goto clean3;
    }


    //
    // If we got here we were successful
    //

    status = ERROR_SUCCESS;
    SetLastError (status);
    goto clean1;


clean3:
    SetupDiDeleteDeviceInfo (DevInfoHandle, DevInfoData);

clean1:
    LocalFree (DevInfoData);

clean0:
   return status;

}


DWORD
AllowInstallNtApm(
    IN     HDEVINFO         DevInfoHandle,
    IN     PSP_DEVINFO_DATA DevInfoData     OPTIONAL
    )
/*++

Routine Description:

    This function decides whether to allow install (which will do
    an enabled install at least in the upgrade case) or force
    an install disbled.

Arguments:

    DevInfoHandle       - Handle to a device information set

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.
        N.B. If this is null, we have a problem.

Return Value:

    status.

--*/
{
    ULONG   DevStatus;
    ULONG   DevProblem;
    SP_DEVINSTALL_PARAMS DevInstallParams = {0};

    CONFIGRET   Result;

    ChkPrintEx(("syssetup: AllowInstallNtApm: entered\n"));

    if ( ! IsProductTypeApmLegal()) {
        // it's not a workstation, so disallow install
        ChkPrintEx(("syssetup: AllowInstallNtApm #0: not a work station => return ERROR_DI_DONT_INSTALL\n"));
        return ERROR_DI_DONT_INSTALL;
    }

    if (! DevInfoData) {
        //
        // If DevInfoData is null, we don't actually know
        // what is going on, so say "OK" and hope for the best
        //
        ChkPrintEx(("sysetup: AllowInstallNtApm #1: no DevInfoData => return ERROR_DI_DO_DEFAULT\n"));
        return ERROR_DI_DO_DEFAULT;
    }

    //
    // Call the CM and ask it what it knows about this devinst
    //
    Result = CM_Get_DevNode_Status(&DevStatus, &DevProblem, DevInfoData->DevInst, 0);
    ChkPrintEx(("syssetup: AllowInstallNtApm #2: DevStatus = %08lx\n", DevStatus));
    ChkPrintEx(("syssetup: AllowInstallNtApm #3: DevProblem = %08lx\n", DevProblem));
    if (Result != CR_SUCCESS) {
        ChkPrintEx(("syssetup: AllowInstallNtApm #4: return ERROR_DI_DONT_INSTALL\n"));
        return ERROR_DI_DONT_INSTALL;
    }

    if (DevStatus & DN_HAS_PROBLEM) {
        if (DevProblem == CM_PROB_DISABLED) {

            //
            // it's supposed to be disabled
            //

            DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (!SetupDiGetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
                ChkPrintEx(("syssetup: AllowInstallNtApm #5: return ERROR_DI_DONT_INSTALL\n"));
                return ERROR_DI_DONT_INSTALL;
            }
            DevInstallParams.Flags |= DI_INSTALLDISABLED;
            if (!SetupDiSetDeviceInstallParams(DevInfoHandle, DevInfoData, &DevInstallParams)) {
                ChkPrintEx(("syssetup: AllowInstallNtApm #6: return ERROR_DI_DONT_INSTALL\n"));
                return ERROR_DI_DONT_INSTALL;
            }
        }
    }
    ChkPrintEx(("syssetup: AllowInstallNtApm #7: return ERROR_DI_DO_DEFAULT\n"));
    return ERROR_DI_DO_DEFAULT;
}


BOOL
IsProductTypeApmLegal()
/*++

Routine Description:

    Determines if we are running on workstation (win2000 pro) or not.
    If we are, return TRUE. else return FALSE.
    This is used to overcome weirdness in setup AND to prevent people from
    getting themselves into trouble by allowing apm to run on a server.

Return Value:

    TRUE - it's workstation, it's OK to run APM

    FALSE - it's server, DON'T let APM run

--*/
{
    OSVERSIONINFOEX OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OsVersionInfo);

    if (!GetVersionEx((OSVERSIONINFO *) &OsVersionInfo)) {
        ChkPrintEx(("GetVersionEx failed, return server (FALSE)\n"));
        return FALSE;
    }

    if  (OsVersionInfo.wProductType == VER_NT_WORKSTATION) {
        return TRUE;
    }
    return FALSE;
}


//
// Ideally these would be defined in a header file somewhere,
// but that's hard to do becuase they are set up in an INF.
// SO - simply be sure that they match up with these lines in
// biosinfo.inf:
//
// For KNOWN_BAD:
// [DisableApmAddReg]
// HKLM,System\CurrentControlSet\Control\Biosinfo\APM,Attributes,0x00010001,00000002
//
// For KNOWN_GOOD:
// [AutoEnableApmAddReg]
// HKLM,System\CurrentControlSet\Control\Biosinfo\APM,Attributes,0x00010001,00000001
//
#define APM_BIOS_KNOWN_GOOD 0x00000001
#define APM_BIOS_KNOWN_BAD  0x00000002

DWORD
IsApmPresent()
/*++

Routine Description:

    IsApmPresent runs the same code as ntapm.sys does to decide
    if ntdetect has found and reported a usable APM bios.

    It then checks to see what, if any, bios lists this machine
    and bios are one.

    It factors this data together to report the existence/non-existence
    of apm on the machine, and its usability and suitability.

Return Value:

    APM_NOT_PRESENT - apm does not appear to be present on this machine

    APM_PRESENT_BUT_NOT_USABLE - there appears to be an apm bios, but
        it did not allow connection correctly (version or api support problem)

    APM_ON_GOOD_LIST - there is a bios and it's on the good bios list

    APM_NEUTRAL - there is a bios, it appears to be usable,
        it is not on the good bios list, but it's also not
        on the bad bios list.

    APM_ON_BAD_LIST - there is a bios, but it's on the bad bios list.

--*/
{
    //
    // first part of this code is copied from ...\ntos\dd\ntapm\i386\apm.c
    // keep it in sync with that code
    //
    UNICODE_STRING unicodeString, ConfigName, IdentName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus, hGoodBad;
    NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    PCM_FULL_RESOURCE_DESCRIPTOR Desc;
    PKEY_VALUE_FULL_INFORMATION ValueInfo;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    PAPM_REGISTRY_INFO ApmEntry;
    UCHAR buffer [sizeof(APM_REGISTRY_INFO) + 99];
    WCHAR wstr[8];
    ULONG i, junk;
    PWSTR p;
    PULONG  pdw;
    DWORD   BiosType;



    // ----------------------------------------------------------------------
    //
    // First Part - See if ntdetect.com found APM....
    //
    // ----------------------------------------------------------------------

    //
    // Look in the registery for the "APM bus" data
    //

    RtlInitUnicodeString(&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = NtOpenKey(&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return APM_NOT_PRESENT;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString(&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString(&IdentName, rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0;; i++) {
        RtlIntegerToUnicodeString(i, 10, &unicodeString);
        InitializeObjectAttributes(
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL
            );

        status = NtOpenKey(&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            NtClose(hMFunc);
            return APM_NOT_PRESENT;
        }

        //
        // Check the Indentifier to see if this is a APM entry
        //

        status = NtQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            NtClose(hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'A' || p[1] != L'P' || p[2] != L'M' || p[3] != 0) {
            NtClose (hBus);
            continue;
        }

        status = NtQueryValueKey(
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        NtClose(hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {
            // got it..
            ApmEntry = (PAPM_REGISTRY_INFO) (PDesc+1);
            break;
        }
    }
    NtClose(hMFunc);

    if ( (ApmEntry->Signature[0] != 'A') ||
         (ApmEntry->Signature[1] != 'P') ||
         (ApmEntry->Signature[2] != 'M') )
    {
        return APM_NOT_PRESENT;
    }

    if (ApmEntry->Valid != 1) {
        return APM_PRESENT_BUT_NOT_USABLE;
    }

    // --------------------------------------------------------------------
    //
    // Second Part - what sort of APM bios is it?
    //
    // --------------------------------------------------------------------

    //
    // If we get this far, then we think there is an APM bios present
    // on the machine, and ntdetect thinks it's usable.
    // This means we found it, and it has a version we like, and claims
    // to support the interfaces we like.
    // But we still don't know if its good, bad, or neutral.
    // Find Out.
    //

    //
    // The machine/bios good/bad list code will leave a flag in the
    // registry for us to check to see if it is a known good or known bad
    // apm bios.
    //

    RtlInitUnicodeString(&unicodeString, rgzGoodBadKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(&hGoodBad, KEY_READ, &objectAttributes);
    if (! NT_SUCCESS(status)) {
        return APM_NEUTRAL;
    }

    RtlInitUnicodeString(&IdentName, rgzGoodBadValue);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = NtQueryValueKey(
                hGoodBad,
                &IdentName,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    NtClose(hGoodBad);
    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        BiosType = *pdw;
    } else {
        return APM_NEUTRAL;
    }

    if (BiosType & APM_BIOS_KNOWN_GOOD) {
        return APM_ON_GOOD_LIST;
    } else if (BiosType & APM_BIOS_KNOWN_BAD) {
        return APM_ON_BAD_LIST;
    } else {
        return APM_NEUTRAL;
    }
}

BOOL
IsAcpiMachine(
    VOID
    )
/*++

Routine Description:

    IsAcpiMachine reports whether the OS thinks this is an ACPI
    machine or not.

Return Value:

    FALSE - this is NOT an acpi machine

    TRUE - this IS an acpi machine

--*/
{
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD)+1];
    ULONG junk;
    PULONG  pdw;

    ChkPrintEx(("syssetup: IsAcpiMachine: entered\n"));
    RtlInitUnicodeString(&unicodeString, rgzAcpiKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(&hKey, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        ChkPrintEx(("syssetup: IsAcpiMachine: returning FALSE, no key\n"));
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeString, rgzAcpiCount);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = NtQueryValueKey(
                hKey,
                &unicodeString,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        if (*pdw) {
            NtClose(hKey);
            ChkPrintEx(("syssetup: IsAcpiMachine: returning TRUE\n"));
            return TRUE;
        }
    }

    NtClose(hKey);
    ChkPrintEx(("syssetup: IsAcpiMachine: returning FALSE, no match\n"));
    return FALSE;
}

BOOL
IsApmLegalHalMachine(
    VOID
    )
/*++

Routine Description:

    IsApmLegalHalMachine reports whether setup claims to have
    installed the standard halx86 Hal that APM requires to function.

Return Value:

    TRUE - this IS an ApmLegalHal machine, apm install may proceed.

    FALSE - this is NOT an ApmLegalHal machine, do not install APM.

--*/
{
    UNICODE_STRING unicodeString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hKey;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION pvpi;
    UCHAR buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)+sizeof(DWORD)+1];
    ULONG junk;
    PULONG  pdw;

    ChkPrintEx(("syssetup: IsApmLegalHalMAchine: entered\n"));
    RtlInitUnicodeString(&unicodeString, rgzApmLegalHalKey);
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = NtOpenKey(&hKey, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        ChkPrintEx(("syssetup: IsApmLegalHalMAchine: returning FALSE, no key\n"));
        return FALSE;
    }

    RtlInitUnicodeString(&unicodeString, rgzApmHalPresent);
    pvpi = (PKEY_VALUE_PARTIAL_INFORMATION)buffer;
    status = NtQueryValueKey(
                hKey,
                &unicodeString,
                KeyValuePartialInformation,
                pvpi,
                sizeof(buffer),
                &junk
                );

    if ( (NT_SUCCESS(status)) &&
         (pvpi->Type == REG_DWORD) &&
         (pvpi->DataLength == sizeof(ULONG)) )
    {
        pdw = (PULONG)&(pvpi->Data[0]);
        if (*pdw == 1) {
            NtClose(hKey);
            ChkPrintEx(("syssetup: IsApmLegalHalMAchine: returning TRUE\n"));
            return TRUE;
        }
    }

    NtClose(hKey);
    ChkPrintEx(("syssetup: IsApmLegalHalMAchine: returning FALSE, no match\n"));
    return FALSE;
}

typedef
BOOL
(*PRESTART_DEVICE) (
    IN HDEVINFO             DeviceInfoSet,
    IN PSP_DEVINFO_DATA     DeviceInfoData
    );

BOOL
IsUSBController(
    IN HDEVINFO             DeviceInfoSet,
    IN PSP_DEVINFO_DATA     DeviceInfoData
    )
{
    HKEY    hKey;
    TCHAR   szController[] = TEXT("Controller");
    DWORD   dwType, dwSize;
    BYTE    data;

    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ);

    //
    // Check for a REG_BINARY (1-byte) 'Controller' value entry set to 0.
    //
    dwSize = sizeof(data);
    if (RegQueryValueEx(hKey,
                        szController,
                        NULL,
                        &dwType,
                        &data,
                        &dwSize) != ERROR_SUCCESS ||
        dwSize != sizeof(BYTE)                    ||
        dwType != REG_BINARY) {
        data = 0;
    }

    RegCloseKey(hKey);

    return data;
}

void
DeviceBayRestartDevices(
    CONST GUID *    Guid,
    PRESTART_DEVICE RestartDevice
    )
{
    HDEVINFO                hDevInfo;
    SP_DEVINFO_DATA         did;
    SP_DEVINSTALL_PARAMS    dip;
    int                     i;

    hDevInfo = SetupDiGetClassDevs(Guid, NULL, NULL, 0);

    if (hDevInfo != INVALID_HANDLE_VALUE) {

        ZeroMemory(&did, sizeof(SP_DEVINFO_DATA));
        did.cbSize = sizeof(SP_DEVINFO_DATA);

        for (i = 0; SetupDiEnumDeviceInfo(hDevInfo, i, &did); i++) {
            if (!RestartDevice || RestartDevice(hDevInfo, &did)) {
                //
                // restart the controller so that the filter driver is in
                // place
                //
                ZeroMemory(&dip, sizeof(SP_DEVINSTALL_PARAMS));
                dip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if (SetupDiGetDeviceInstallParams(hDevInfo, &did, &dip)) {
                    dip.Flags |= DI_PROPERTIES_CHANGE;
                    SetupDiSetDeviceInstallParams(hDevInfo, &did, &dip);
                }
            }
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
}

BOOLEAN
AddDeviceBayFilter(
    HKEY ClassKey
    )
{
    DWORD   dwType, dwSize;
    ULONG   res,
            filterLength,
            length;
    BOOLEAN added = FALSE,
            addFilter;
    TCHAR   szFilter[] = TEXT("dbfilter\0");
    PTCHAR  szCurrentFilter, szOffset, szUpperFilters;

    filterLength = lstrlen(szFilter);

    dwSize = 0;
    res = RegQueryValueEx(ClassKey,
                          REGSTR_VAL_UPPERFILTERS,
                          NULL,
                          &dwType,
                          NULL,
                          &dwSize);

    if (res == ERROR_FILE_NOT_FOUND || dwType != REG_MULTI_SZ) {
        //
        // Value isn't there,
        //
        RegSetValueEx(ClassKey,
                      REGSTR_VAL_UPPERFILTERS,
                      0,
                      REG_MULTI_SZ,
                      (PBYTE) szFilter,
                      (filterLength + 2) * sizeof(TCHAR) );

        added = TRUE;
    }
    else if (res == ERROR_SUCCESS) {

        szUpperFilters = (PTCHAR)
            LocalAlloc(LPTR, dwSize + (filterLength + 1) * sizeof(TCHAR));

        if (!szUpperFilters) {
            return FALSE;
        }

        szOffset = szUpperFilters + filterLength + 1;

        res = RegQueryValueEx(ClassKey,
                              REGSTR_VAL_UPPERFILTERS,
                              NULL,
                              &dwType,
                              (PBYTE) szOffset,
                              &dwSize);

        if (res == ERROR_SUCCESS) {

            addFilter = TRUE;
            for (szCurrentFilter = szOffset; *szCurrentFilter; ) {

                length = lstrlen(szCurrentFilter);
                if (lstrcmpi(szFilter, szCurrentFilter) == 0) {
                    addFilter = FALSE;
                    break;
                }

                szCurrentFilter += (length + 1);
            }

            if (addFilter) {

                length = (filterLength + 1) * sizeof(TCHAR);
                memcpy(szUpperFilters, szFilter, length);

                dwSize += length;
                res = RegSetValueEx(ClassKey,
                                    REGSTR_VAL_UPPERFILTERS,
                                    0,
                                    REG_MULTI_SZ,
                                    (PBYTE) szUpperFilters,
                                    dwSize);

                added = (BOOLEAN)(res == ERROR_SUCCESS);
            }
        }

        LocalFree(szUpperFilters);
    }

    return added;
}

DWORD
DeviceBayClassInstaller(
    IN  DI_FUNCTION         InstallFunction,
    IN  HDEVINFO            DeviceInfoSet,
    IN  PSP_DEVINFO_DATA    DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine is the class installer function for storage volumes.

Arguments:

    InstallFunction - Supplies the install function.

    DeviceInfoSet   - Supplies the device info set.

    DeviceInfoData  - Supplies the device info data.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/

{
    HKEY hKeyClass;

    switch (InstallFunction) {

    case DIF_INSTALLDEVICE:

        if (!SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData)) {
            return GetLastError();
        }

        hKeyClass = SetupDiOpenClassRegKey(&GUID_DEVCLASS_USB, KEY_ALL_ACCESS);
        if (hKeyClass != INVALID_HANDLE_VALUE) {
            if (AddDeviceBayFilter(hKeyClass)) {
                //
                // Restart all the USB devices
                //
                DeviceBayRestartDevices(&GUID_DEVCLASS_USB,
                                        IsUSBController);
            }
            RegCloseKey(hKeyClass);
        }

        hKeyClass = SetupDiOpenClassRegKey(&GUID_DEVCLASS_1394, KEY_ALL_ACCESS);
        if (hKeyClass != INVALID_HANDLE_VALUE) {
            if (AddDeviceBayFilter(hKeyClass)) {
                //
                // Restart all the 1394 controllers
                //
                DeviceBayRestartDevices(&GUID_DEVCLASS_1394, NULL);
            }
            RegCloseKey(hKeyClass);
        }

        //
        // We might want to do something with the friendly name in the future...
        //
        return NO_ERROR;
    }

    return ERROR_DI_DO_DEFAULT;
}

DWORD
EisaUpHalCoInstaller(
    IN DI_FUNCTION                      InstallFunction,
    IN HDEVINFO                         DeviceInfoSet,
    IN PSP_DEVINFO_DATA                 DeviceInfoData  OPTIONAL,
    IN OUT PCOINSTALLER_CONTEXT_DATA    Context
    )
{
#if defined(_AMD64_) || defined(_X86_)
    return PciHalCoInstaller(InstallFunction, DeviceInfoSet, DeviceInfoData, Context);
#else
    return NO_ERROR;
#endif
}

DWORD
ComputerClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )

/*++

Routine Description:

    This routine acts as the class installer for Computer class (HAL) devices.

Arguments:

    InstallFunction - Specifies the device installer function code indicating
        the action being performed.

    DeviceInfoSet - Supplies a handle to the device information set being
        acted upon by this install action.

    DeviceInfoData - Optionally, supplies the address of a device information
        element being acted upon by this install action.

Return Value:

    If this function successfully completed the requested action, the return
        value is NO_ERROR.

    If the default behavior is to be performed for the requested action, the
        return value is ERROR_DI_DO_DEFAULT.

    If an error occurred while attempting to perform the requested action, a
        Win32 error code is returned.

--*/
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    switch(InstallFunction) {

    case DIF_SELECTDEVICE:
        DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

        if (SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERSIMILARDRIVERS;

            SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                          DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        //
        // We are not returning an error here because we want to break out and
        // return ERROR_DI_DO_DEFAULT.
        //
        break;
    }

    return ERROR_DI_DO_DEFAULT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\cmdline.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

    Routines to fetch parameters passed to us by text mode
    and deal with uniquness criteria.

Author:

    Stephane Plante (t-stepl) 16-Oct-1995

Revision History:

    06-Mar-1996 (tedm) massive cleanup, and uniqueness stuff

--*/

#include "setupp.h"
#pragma hdrstop

#ifdef UNICODE
#define _UNICODE
#endif
#include <tchar.h>
#include <ntdsadef.h>
#include "hwlog.h"

//
// These get filled in when we call SetUpProcessorNaming().
// They are used for legacy purposes.
//
// PlatformName - a name that indicates the processor platform type;
//                one of AMD64, I386, or ia64
//
// ProcessorName - a description of the type of processor. This varies
//                 depending on PlatformName.
//
// PrinterPlatform - name of platform-specific part of subdirectory
//                   used in printing architecture. One of w32amd64,
//                   w32x86, or w32ia64.
//
PCWSTR PlatformName = L"";
PCWSTR ProcessorName = L"";
PCWSTR PrinterPlatform = L"";
GUID DriverVerifyGuid = DRIVER_ACTION_VERIFY;

//
// Source path used for legacy operations. This is the regular
// source path with a platform-specific piece appended to it.
// This is how legacy infs expect it.
//
WCHAR LegacySourcePath[MAX_PATH];

//
// Policy values (ignore, warn, or block) for driver and non-driver signing.
// These are the policy values that are in effect post-setup (i.e., they are
// applied when setup is finished by calling InitializeCodeSigningPolicies with
// FALSE).
//
BYTE DrvSignPolicy;
BYTE NonDrvSignPolicy;

//
// Flags indicating whether the driver and non-driver signing policies came
// from the answerfile.  (If so, then those values are in effect after GUI-mode
// setup as well, thus DrvSignPolicy and NonDrvSignPolicy values are ignored.)
//
BOOL AFDrvSignPolicySpecified = FALSE;
BOOL AFNonDrvSignPolicySpecified = FALSE;

//
// Flag indicating if we're installing from a CD.
//
BOOL gInstallingFromCD = FALSE;

//
// Cryptographically secure codesigning policies
//
DWORD PnpSeed = 0;

//
// Define maximum parameter (from answer file) length
//
#define MAX_PARAM_LEN 256

#define FILEUTIL_HORRIBLE_PATHNAME (_T("system32\\CatRoot\\{F750E6C3-38EE-11D1-85E5-00C04FC295EE}\\"))

BOOL
SpSetupProcessSourcePath(
    IN  PCWSTR  NtPath,
    OUT PWSTR  *DosPath
    );

NTSTATUS
SpSetupLocateSourceCdRom(
    OUT PWSTR NtPath
    );

VOID
SetUpProcessorNaming(
    VOID
    );

BOOL
IntegrateUniquenessInfo(
    IN PCWSTR DatabaseFile,
    IN PCWSTR UniqueId
    );

BOOL
ProcessOneUniquenessSection(
    IN HINF   Database,
    IN PCWSTR SectionName,
    IN PCWSTR UniqueId
    );

DWORD
InstallProductCatalogs(
    OUT SetupapiVerifyProblem *Problem,
    OUT LPWSTR                 ProblemFile,
    IN  LPCWSTR                DescriptionForError OPTIONAL
    );


DWORD
DeleteOldCatalogs(
    VOID
    );

VOID
InstallPrivateFiles(
    IN HWND Billboard
    );

DWORD
PrepDllCache(
    VOID
    );

VOID
SpUninstallExcepPackCatalogs(
    IN HCATADMIN CatAdminHandle OPTIONAL
    );


BOOL
SpSetupLoadParameter(
    IN  PCWSTR Param,
    OUT PWSTR  Answer,
    IN  UINT   AnswerBufLen
    )

/*++

Routine Description:

    Load a single parameter out of the [Data] section of the
    setup parameters file. If the datum is not found there then
    look in the [SetupParams] and [Unattended] sections also.

Arguments:

    Param - supplies name of parameter, which is passed to the profile APIs.

    Answer - receives the value of the parameter, if successful.

    AnswerBufLen - supplies the size in characters of the buffer
        pointed to by Answer.

Return Value:

    Boolean value indicating success or failure.

--*/
{
    if(!AnswerFile[0]) {
       //
       // We haven't calculated the path to $winnt$.inf yet
       //
       GetSystemDirectory(AnswerFile,MAX_PATH);
       pSetupConcatenatePaths(AnswerFile,WINNT_GUI_FILE,MAX_PATH,NULL);

       
       if(!FileExists(AnswerFile,NULL)) {
           //
           // Don't log this error message in mini-setup. Mini-setup may delete 
           // the answer file and later, if someone asks for it, and it is not found
           // we don't want to log this as a failure.  OOBE pretends to be mini-setup
           // so make sure that we log this error if we're running in OOBE and
           // we're missing the answer file.
           //
           if (!MiniSetup || OobeSetup) {
               SetuplogError(
                   LogSevError,
                   SETUPLOG_USE_MESSAGEID,
                   MSG_LOG_SYSINFBAD,
                   AnswerFile,
                   NULL,NULL);
           }
           return FALSE;
       }
    }

    if(!GetPrivateProfileString(pwData,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
        //
        // If answer isn't in the DATA section then it could
        // conceivably be in the SETUPPARAMS section as a user
        // specified (command line) option
        //
        if(!GetPrivateProfileString(pwSetupParams,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
            //
            // Now check the UNATTENDED section.
            //
            if(!GetPrivateProfileString(pwUnattended,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
                //
                // Now check the ACCESSIBILITY section.
                //
                if(!GetPrivateProfileString(pwAccessibility,Param,pwNull,Answer,AnswerBufLen,AnswerFile)) {
                    //
                    // We haven't found the answer here so it probably doesn't exist.
                    // This is an error situation so notify our caller of that.
                    //
                    SetupDebugPrint1(L"SETUP: SpSetupLoadParameter was unable to find %ws.", Param);
                    return(FALSE);
                }
            }
        }
    }

    //
    // Success.
    //
    return(TRUE);
}


BOOL
SpSetProductTypeFromParameters(
    VOID
    )
/*++

Routine Description:

    Reads the Product Type from the parameters files and sets up
    the ProductType global variable.

Arguments:

    None

Returns:

    Boolean value indicating outcome.

--*/
{
    WCHAR p[MAX_PARAM_LEN];

    //
    // Determine the product type. If we can't resolve this
    // then the installation is in a lot of trouble
    //
    if( !MiniSetup ) {
        if( !SpSetupLoadParameter(pwProduct,p,sizeof(p)/sizeof(p[0]))) {
            return( FALSE );
        }
    } else {
    DWORD   rc, d, Type;
    HKEY    hKey;

        //
        // If we're doing a minisetup then we need to go pull the
        // product string out of the registry.
        //

        //
        // Open the key.
        //
        rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                           0,
                           KEY_READ,
                           &hKey );

        if( rc != NO_ERROR ) {
            SetLastError( rc );
            SetupDebugPrint1( L"Setup: Failed to open ProductOptions key (gle %u) \n", rc );
            return( FALSE );
        }


        //
        // Get the size of the ProductType entry.
        //
        rc = RegQueryValueEx( hKey,
                              L"ProductType",
                              NULL,
                              &Type,
                              NULL,
                              &d );

        if( rc != NO_ERROR ) {
            SetLastError( rc );
            SetupDebugPrint1( L"Setup: Failed to query size of ProductType key (gle %u) \n", rc );
            return( FALSE );
        }

        //
        // Get the ProductType entry.
        //
        rc = RegQueryValueEx( hKey,
                              L"ProductType",
                              NULL,
                              &Type,
                              (LPBYTE)p,
                              &d );

        if( rc != NO_ERROR ) {
            SetLastError( rc );
            SetupDebugPrint1( L"Setup: Failed to query ProductType key (gle %u) \n", rc );
            return( FALSE );
        }

    }

    //
    // We managed to find an entry in the parameters file
    // so we *should* be able to decode it
    //
    if(!lstrcmpi(p,pwWinNt)) {
        //
        // We have a WINNT product
        //
        ProductType = PRODUCT_WORKSTATION;

    } else if(!lstrcmpi(p,pwLanmanNt)) {
        //
        // We have a PRIMARY SERVER product
        //
        ProductType = PRODUCT_SERVER_PRIMARY;

    } else if(!lstrcmpi(p,pwServerNt)) {
        //
        // We have a STANDALONE SERVER product
        // NOTE: this case can currently never occur, since text mode
        // always sets WINNT_D_PRODUCT to lanmannt or winnt.
        //
        ProductType = PRODUCT_SERVER_STANDALONE;

    } else {
        //
        // We can't determine what we are, so fail
        //
        return (FALSE);
    }

    return (TRUE);
}


BOOL
SpSetUnattendModeFromParameters(
    VOID
    )
/*++

Routine Description:

    Reads the Unattended Mode from the parameters files and sets up
    the UnattendMode global variable.

Arguments:

    None

Returns:

    Boolean value indicating outcome.

--*/
{
    WCHAR p[MAX_PARAM_LEN];


    //
    // If we're not running unattended, don't bother to look up the mode.
    //
    if(!Unattended) {
        UnattendMode = UAM_GUIATTENDED;
        TextmodeEula = TRUE;
        return TRUE;
    }

    if (SpSetupLoadParameter(pwWaitForReboot, p, sizeof(p)/sizeof(p[0]))) {
        if (!lstrcmpi(p, pwYes)) {
            UnattendWaitForReboot = TRUE;
        }
    }

    if(SpSetupLoadParameter(pwUnattendMode,p,sizeof(p)/sizeof(p[0]))) {
        //
        // We managed to find an entry in the parameters file
        // so we *should* be able to decode it
        //
        if(!lstrcmpi(p,pwGuiAttended)) {
            //
            // GUI mode will be fully attended.
            //
            UnattendMode = UAM_GUIATTENDED;
            Unattended = FALSE;

        } else if(!lstrcmpi(p,pwProvideDefault)) {
            //
            // Answers are defaults and can be changed.
            //
            UnattendMode = UAM_PROVIDEDEFAULT;

        } else if(!lstrcmpi(p,pwDefaultHide)) {
            //
            // Answers are defaults, but a page with all answers supplied is
            // not shown.
            //
            UnattendMode = UAM_DEFAULTHIDE;

        } else if(!lstrcmpi(p,pwReadOnly)) {
            //
            // All supplied answers are read-only.  If a page has all its
            // answers supplied, then it is not shown.
            //
            UnattendMode = UAM_READONLY;

        } else if(!lstrcmpi(p,pwFullUnattended)) {
            //
            // Setup is fully unattended.  If we have to ask the user for an
            // answer, we put up an error dialog.
            //
            UnattendMode = UAM_FULLUNATTENDED;

        } else {
            //
            // We can't determine what we are, so use a default
            //
            UnattendMode = UAM_DEFAULTHIDE;
            SetupDebugPrint1(
                L"SETUP: SpSetUnattendModeFromParameters did not recognize %ls",
                p
                );
        }

    } else {
        //
        // Use default mode since none was specified.
        //
        UnattendMode = UAM_DEFAULTHIDE;
    }

    return TRUE;
}

BOOL
SpIsSetupSourceMediaPresent(
    OUT PWSTR NtSourceCdRomPath
    )
/*++

Routine Description:

     Check to see if the CDROM is present.

Arguments:

    NtSourceCdRomPath  -  Nt Path for the CD-Rom that has the source media.
    
Returns:

    Appropriate BOOL code.

--*/
{    
    NTSTATUS Status = STATUS_UNSUCCESSFUL ;    
    //
    // Verify media only if we have started setup from a CDROM.
    //
    if (gInstallingFromCD) {

        PWSTR Message;

        if (Message = RetrieveAndFormatMessage( NULL,
                                                MSG_CDROM_MEDIA_ERROR)){

            
            Status = SpSetupLocateSourceCdRom(NtSourceCdRomPath);
            
            while (!NT_SUCCESS(Status)){
               
                switch (MessageBoxFromMessage(MainWindowHandle,
                                   MSG_CDROM_MEDIA_ERROR,
                                   NULL,
                                   IDS_ERROR,
                                   MB_ICONERROR | 
                                   MB_RETRYCANCEL |
                                   MB_SYSTEMMODAL)){

                      case IDRETRY:{
                        
                        //
                        // If the media was replaced or if we are successful 
                        // in reading the media then proceed.
                        //
                        Status = SpSetupLocateSourceCdRom(NtSourceCdRomPath);
                        break;
                        
                      }

                      case IDCANCEL:{
                        //
                        // User chose to exit setup and reboot the system
                        // Log the error.
                        //
                        SetuplogError(LogSevFatalError,Message,0,NULL,NULL);
                        
                        MyFree(Message);
                        return(FALSE);

                      }                       
                }
            }
            
            MyFree(Message);
        }
    
    }
    return NT_SUCCESS(Status);
}

HRESULT
WaitForDSStartUp(
    VOID
    )
/*++

Routine Description:
            Wait for DS to start.
            Required as the reindexing of database may take a long time.

Arguments:

Returns:    NO_ERROR - waited for ds to start successfully
            ERROR_DS_UNAVAILABLE - ds did not start

--*/
{
    const DWORD dwMaxWaitForDS = 6*60*60*1000;
    HRESULT hrSamStatus;
    PVOID p = NULL;

    SetupDebugPrint(TEXT("Inside Wait for Active Directory."));
    if( !Upgrade || !ISDC(ProductType)) {
        return( S_OK);
    }

    SetupDebugPrint(TEXT("Waiting for Active Directory to start."));
    if(p = MyLoadString(IDS_DS_STARTUP)) {
        BB_SetTimeEstimateText(p);
        MyFree(p);
    }

    //
    // Wait for SAM to service to start.

    if ( S_OK != (hrSamStatus = WaitForSamService(dwMaxWaitForDS)) ) {
            SetuplogError(LogSevError,
                SETUPLOG_USE_MESSAGEID,
                MSG_LOG_SAM_WAIT_ERROR, 
                hrSamStatus,
                NULL,
                NULL
                );
    }

    //Restore orginal text - same remaining time before entering this wait.
    RemainingTime = CalcTimeRemaining(Phase_Initialize);
    SetRemainingTime(RemainingTime);

    SetupDebugPrint(TEXT("Done waiting for Active Directory to start."));
    return hrSamStatus;
}


VOID
SpInitSxsContext(
    VOID
    )
{
    BOOL b3;

    //
    // Everyone done and happy?  Good, now go and create the default
    // context based on whatever DU and the original media installed.
    //
    b3 = SideBySideCreateSyssetupContext();
    
    if ( !b3 ) {                
        WCHAR szErrorBuffer[128];
        DWORD dwLastError = GetLastError();

        szErrorBuffer[0] = 0;
        if (FormatMessageW(
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwLastError,
                0,
                szErrorBuffer,
                RTL_NUMBER_OF(szErrorBuffer),
                NULL) == 0) {
            _snwprintf(szErrorBuffer, RTL_NUMBER_OF(szErrorBuffer), L"Untranslatable message, Win32LastError is %lu\r\n", dwLastError);
            szErrorBuffer[RTL_NUMBER_OF(szErrorBuffer) - 1] = 0;
        }

        if ((dwLastError == ERROR_CRC) || (dwLastError == ERROR_SWAPERROR)) 
        {
            // for CD media error
            FatalError(MSG_LOG_SIDE_BY_SIDE_IO_ERROR, szErrorBuffer, 0, 0);

        }else
        {
            FatalError(MSG_LOG_SIDE_BY_SIDE, szErrorBuffer, 0, 0);
        }

    }
}

BOOL
SpInitCommonControls(
    VOID
    )
{
    INITCOMMONCONTROLSEX ControlInit;

    //
    // We must not use comctl32.dll until after SideBySide install completes.
    // It is delayloaded, using the linker feature.
    //
    // But, actually, it get's loaded by winntbb before us, and that is ok, it
    // still gets redirected for uses from syssetup.dll, oc manager, etc.
    //
    //ASSERT(GetModuleHandleW(L"comctl32.dll") == NULL);

    ControlInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
    ControlInit.dwICC = ICC_LISTVIEW_CLASSES    |
                        ICC_TREEVIEW_CLASSES    |
                        ICC_BAR_CLASSES         |
                        ICC_TAB_CLASSES         |
                        ICC_UPDOWN_CLASS        |
                        ICC_PROGRESS_CLASS      |
                        ICC_HOTKEY_CLASS        |
                        ICC_ANIMATE_CLASS       |
                        ICC_WIN95_CLASSES       |
                        ICC_DATE_CLASSES        |
                        ICC_USEREX_CLASSES      |
                        ICC_COOL_CLASSES
#if (_WIN32_IE >= 0x0400)
                        |
                        ICC_INTERNET_CLASSES    |
                        ICC_PAGESCROLLER_CLASS
#endif
                        ;

    return InitCommonControlsEx( &ControlInit );
}

BOOL
SpSetupProcessParameters(
    IN OUT HWND *Billboard
    )
/*++

Routine Description:

    Reads in parameters passed in from TextMode Setup

Arguments:

    Billboard - on input supplies window handle of "Setup is Initializing"
        billboard. On ouput receives new window handle if we had to
        display our own ui (in which case we would have killed and then
        redisplayed the billboard).

Returns:

    Boolean value indicating outcome.

--*/
{
    BOOL  b = TRUE;
    PWSTR q;
    WCHAR p[MAX_PARAM_LEN];
    WCHAR Num[24];
    UINT Type;
    WCHAR c;
    WCHAR TitleStringBuffer[1024];
    DWORD Err;
    SetupapiVerifyProblem Problem;
    WCHAR ProblemFile[MAX_PATH];

    if(!SpSetProductTypeFromParameters()) {
        return(FALSE);
    }

    //
    // Is winnt/winnt32-based?
    //
    if((b = SpSetupLoadParameter(pwMsDos,p,MAX_PARAM_LEN))
    && (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        WinntBased = TRUE;

#if defined(_AMD64_) || defined(_X86_)
        //
        // Get Floppyless boot path, which is given if
        // pwBootPath is not set to NO
        //
        FloppylessBootPath[0] = 0;
        if((b = SpSetupLoadParameter(pwBootPath,p,MAX_PARAM_LEN)) && lstrcmpi(p,pwNo)) {

            if(q = NtFullPathToDosPath(p)) {

                lstrcpyn(
                    FloppylessBootPath,
                    q,
                    sizeof(FloppylessBootPath)/sizeof(FloppylessBootPath[0])
                    );

                MyFree(q);
            }
        }
#endif
    } else {
        WinntBased = FALSE;
    }

    //
    // Win3.1 or Win95 upgrade?
    //
    Win31Upgrade = (b && (b = SpSetupLoadParameter(pwWin31Upgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes));
    Win95Upgrade = (b && (b = SpSetupLoadParameter(pwWin95Upgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes));

    //
    // NT Upgrade?
    //
    Upgrade = (b && (b = SpSetupLoadParameter(pwNtUpgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes));
    SetEnvironmentVariable( L"Upgrade", Upgrade ? L"True" : L"False" );

    //
    // If this is a an upgrade of or to a standalone server,
    // change the product type to standalone server.
    //
    // If this is not an upgrade and the product type is lanmannt,
    // change to standalone server. This makes the default server type
    // non-dc.
    //
    if(b && ((!Upgrade && (ProductType != PRODUCT_WORKSTATION)) || ((b = SpSetupLoadParameter(pwServerUpgrade,p,MAX_PARAM_LEN)) && !lstrcmpi(p,pwYes)))) {
        MYASSERT(ISDC(ProductType));
        ProductType = PRODUCT_SERVER_STANDALONE;
    }

    if( ProductType == PRODUCT_WORKSTATION) {
        if( GetProductFlavor() == 4) {
            SetupTitleStringId = Upgrade ? IDS_TITLE_UPGRADE_P : IDS_TITLE_INSTALL_P;
        }
        else {
            SetupTitleStringId = Upgrade ? IDS_TITLE_UPGRADE_W : IDS_TITLE_INSTALL_W;
        }
    }
    else
    {
        SetupTitleStringId = Upgrade ? IDS_TITLE_UPGRADE_S : IDS_TITLE_INSTALL_S;
    }


    //
    // Fetch the source directory and convert it to DOS-style path
    //
    if(b && (b = SpSetupLoadParameter(pwSrcDir,p,MAX_PARAM_LEN))) {
        //
        // Remember that setupdll.dll does all sorts of checking on the
        // source path. We need todo the same checks here. Note that
        // we will *write* back the checked path into $winnt$.inf as a
        // logical step to take
        //
        if(SpSetupProcessSourcePath(p,&q)) {

            lstrcpyn(SourcePath,q,sizeof(SourcePath)/sizeof(SourcePath[0]));
            MyFree(q);

            //
            // Attempt to write the path to the parameters file.
            // This changes it from an nt-style path to a dos-style path there.
            //
            b = WritePrivateProfileString(pwData,pwDosDir,SourcePath,AnswerFile);
            if(!b) {
                SetupDebugPrint( L"SETUP: WritePrivateProfileString failed in SpSetupProcessParameters." );
            }

        } else {
        
            if (gInstallingFromCD){
                
                //
                // User decide to cancel the setup;
                //
                return FALSE;
            }
                b = FALSE;
                SetupDebugPrint( L"SETUP: SpSetupProcessSourcePath failed in SpSetupProcessParameters." );

            
        }

        //
        // Set up globals for platform-specific info
        //
        SetUpProcessorNaming();

        //
        // Construct legacy source path.
        //
        if(b) {
            lstrcpyn(LegacySourcePath,SourcePath,MAX_PATH);
            pSetupConcatenatePaths(LegacySourcePath,PlatformName,MAX_PATH,NULL);
        }
    }

    //
    // Unattended Mode?
    //
    Unattended = (b &&
        (b = SpSetupLoadParameter(pwInstall,p,MAX_PARAM_LEN)) &&
        !lstrcmpi(p,pwYes));

    if(b) {
        if( !(b = SpSetUnattendModeFromParameters()) ) {
            SetupDebugPrint( L"SETUP: SpSetUnattendModeFromParameters failed in SpSetupProcessParameters." );
        }
    }

    SetupDebugPrint1(L"SETUP: Upgrade=%d.", Upgrade);
    SetupDebugPrint1(L"SETUP: Unattended=%d.", Unattended);

    //
    // We can get into unattended mode in several ways, so we also check whether
    // the "/unattend" switch was explicitly specified.
    //
    UnattendSwitch = (b &&
        SpSetupLoadParameter(pwUnattendSwitch,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne)));

    //
    // Should we force OOBE to run?
    //
    ForceRunOobe = (b &&
        SpSetupLoadParameter(pwRunOobe,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne)));

    //
    // Flag indicating whether we are in a special mode for OEM's to use on the
    // factory floor.
    //
    ReferenceMachine = (b &&
        SpSetupLoadParameter(pwReferenceMachine,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne)));

    //
    // Eula already displayed?
    //
    if(b && SpSetupLoadParameter(pwEulaDone,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {
        EulaComplete = TRUE;
    } else {
        EulaComplete = FALSE;
    }

    //
    // Do uniqueness stuff now. We do this here so we don't have to
    // reinitialize anything. All the stuff above is not subject to change
    // via uniquenss.
    //
    InitializeUniqueness(Billboard);

    //
    // Initialize unattended operation now.
    //
    UnattendInitialize();

    //
    // Setup shell special folders (e.g., "Program Files", etc.) in registry
    // prior to loading any INFs with setupapi.  That's because it's possible
    // that an INF can have DIRIDs that refer to these special directories.
    // (In addition to setupapi's potential need for this, OCM definitely needs
    // it.)
    //
    if(b) {
        if( !(b = SetProgramFilesDirInRegistry()) ) {
            SetupDebugPrint( L"SETUP: SetProgramFilesDirInRegistry failed in SpSetupProcessParameters." );
        }
    }

    //
    // Also, let setupapi know where the source path is...
    //
    // note that the servicepack sourcepath is the same as the system source
    // path in this case since we can only be dealing with a slipstreamed
    // build in this case
    //
    if(b) {
        if( !(b = pSetupSetSystemSourcePath( SourcePath, SourcePath )) ) {
            SetupDebugPrint( L"SETUP: pSetupSetSystemSourcePath failed in SpSetupProcessParameters." );
        }
    }

    if(b && SpSetupLoadParameter(pwIncludeCatalog,p,MAX_PARAM_LEN) && *p) {
        IncludeCatalog = pSetupDuplicateString(p);
        if(!IncludeCatalog) {
            b = FALSE;
            SetupDebugPrint( L"SETUP: IncludeCatalog failed in SpSetupProcessParameters." );
        }
    }

    if(b) {

        //
        // Load the system setup (win95-style!) infs.
        //
        SyssetupInf = SetupOpenInfFile(L"syssetup.inf",NULL,INF_STYLE_WIN4,NULL);

        if(SyssetupInf == INVALID_HANDLE_VALUE) {
            KillBillboard(*Billboard);
            FatalError(MSG_LOG_SYSINFBAD,L"syssetup.inf",0,0);
        }
        //
        // syssetup.inf opened successfully, now append-load any layout INFs
        // it references.
        //
        if(!SetupOpenAppendInfFile(NULL,SyssetupInf,NULL)) {
            KillBillboard(*Billboard);
            FatalError(MSG_LOG_SYSINFBAD,L"(syssetup.inf layout)",0,0);
        }

        //
        // write some information about the hardware configuration to setupact.log
        //
        //
        if( !OobeSetup ) {
            SP_LOG_HARDWARE_IN LogHardwareIn = { 0 };

            LogHardwareIn.SetuplogError = SetuplogError;
            SpLogHardware(&LogHardwareIn);
        }

        if (!MiniSetup && !OobeSetup) {
            DuInitialize ();
        }

        //
        // install side by side assemblies (fusion)
        //
        if( !OobeSetup ) {
            SIDE_BY_SIDE SideBySide = {0};
            BOOL b1 = FALSE;
            BOOL b2 = FALSE;
            BOOL b3 = FALSE;

            b1 = SideBySidePopulateCopyQueue(&SideBySide, NULL, NULL);
            b2 = SideBySideFinish(&SideBySide, b1);
            if (!b1 || !b2) {                
                WCHAR szErrorBuffer[128];
                DWORD dwLastError = GetLastError();

                szErrorBuffer[0] = 0;
                if (FormatMessageW(
                        FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwLastError,
                        0,
                        szErrorBuffer,
                        RTL_NUMBER_OF(szErrorBuffer),
                        NULL) == 0) {
                    _snwprintf(szErrorBuffer, RTL_NUMBER_OF(szErrorBuffer), L"Untranslatable message, Win32LastError is %lu\r\n", dwLastError);
                    szErrorBuffer[RTL_NUMBER_OF(szErrorBuffer) - 1] = 0;
                }

                if ((dwLastError == ERROR_CRC) || (dwLastError == ERROR_SWAPERROR)) 
                {
                    // for CD media error
                    FatalError(MSG_LOG_SIDE_BY_SIDE_IO_ERROR, szErrorBuffer, 0, 0);

                }else
                {
                    FatalError(MSG_LOG_SIDE_BY_SIDE, szErrorBuffer, 0, 0);
                }
            }

            //
            // install additional assemblies downloaded from WU
            // ignore any errors; logging occurs inside the called function
            //
            // Meta-issue: Perhaps this should use the SideBySide context
            // created above, rather than generating its own thing?
            // That would allow even more "goodness" by piggybacking on the
            // existing structures, reduce memory usage by not creating
            // another context, and then chain all the copy calls (if/when
            // SxS uses the real copy queue functionality) into a single
            // SideBySideFinish.
            //
            if (!MiniSetup && !OobeSetup) {
                DuInstallDuAsms ();
            }

            SpInitSxsContext();
        }

        SpInitCommonControls();


        // We need to wait for ds to start up before registering initpki.dll inside InstallOrUpgradeCapi.
        WaitForDSStartUp();

        //
        // We're about to go off and install the catalogs that will be used for
        // digital signature verification of the product files.  First, however,
        // we need to make sure all the CAPI stuff is setup.  (Errors here are
        // not considered fatal.)
        //
        if(!InstallOrUpgradeCapi()) {
            SetupDebugPrint(L"Setup: (non-critical error) Failed call InstallOrUpgradeCapi().\n");
        }

        //
        // Now go install the product catalog files, validating syssetup.inf
        // (and any append-loaded INFs) against the 'primary' catalog.
        //
        // NOTE: No file/INF operations using setupapi should be done until after
        // the product catalogs are installed!
        //
        if(!LoadString(MyModuleHandle, SetupTitleStringId, TitleStringBuffer, SIZECHARS(TitleStringBuffer))) {
            *TitleStringBuffer = L'\0';
        }

        //
        // delete old catalogs that we don't want anymore before we install
        // our product catalogs
        //
        DeleteOldCatalogs();

        Err = InstallProductCatalogs(&Problem,
                                     ProblemFile,
                                     (*TitleStringBuffer ? TitleStringBuffer : NULL)
                                    );

        if(Err == NO_ERROR) {

            if (!MiniSetup && !OobeSetup) {

                Err = DuInstallCatalogs (
                            &Problem,
                            ProblemFile,
                            (*TitleStringBuffer ? TitleStringBuffer : NULL)
                            );

                if (Err != NO_ERROR) {
                    //
                    // We couldn't install updates. However, there's not
                    // a whole lot we can do about it.  We'll just log an error for this
                    //
                    SetuplogError(
                            LogSevError,
                            SETUPLOG_USE_MESSAGEID,
                            MSG_LOG_SYSSETUP_UPDATES_FAILED,
                            (*TitleStringBuffer ? TitleStringBuffer : ProblemFile),
                            Err,
                            ProblemFile,
                            NULL,
                            NULL
                            );
                    //
                    // Also, add an entry about this failure to setupapi's PSS exception
                    // logfile.
                    //
                    pSetupHandleFailedVerification (
                            MainWindowHandle,
                            Problem,
                            ProblemFile,
                            (*TitleStringBuffer ? TitleStringBuffer : NULL),
                            pSetupGetCurrentDriverSigningPolicy(FALSE),
                            TRUE,  // no UI!
                            Err,
                            NULL,
                            NULL,
                            NULL
                            );
                }
            }
        }

        PnpSeed = GetSeed();

        //
        // At this point setupapi can verify files/INFs.
        //
        pSetupSetGlobalFlags(pSetupGetGlobalFlags()&~PSPGF_NO_VERIFY_INF);

        //
        // Now that we can use crypto, we initialize our codesigning policy
        // values.  (We have to do this here, because we're about to retrieve
        // policy in the error handling code below.)
        //
        InitializeCodeSigningPolicies(TRUE);

        if(Err != NO_ERROR) {
            //
            // We couldn't install the product catalogs (or syssetup.inf
            // couldn't be verified using that catalog).  However, there's not
            // a whole lot we can do about it.  We'll just log an error for
            // this, and components that need to be verified later on will
            // (based on policy) generate signature verification failure popups.
            //

                if( Err == CERT_E_EXPIRED)
                {
                    SetuplogError(LogSevError,
                                  SETUPLOG_USE_MESSAGEID,
                                  MSG_LOG_SYSSETUP_CERT_EXPIRED,
                                  Err,
                                  NULL,
                                  NULL
                                 );
                }
                else
                {
                    SetuplogError(LogSevError,
                                  SETUPLOG_USE_MESSAGEID,
                                  MSG_LOG_SYSSETUP_VERIFY_FAILED,
                                  (*TitleStringBuffer ? TitleStringBuffer : ProblemFile),
                                  Err,
                                  NULL,
                                  SETUPLOG_USE_MESSAGEID,
                                  Err,
                                  NULL,
                                  NULL
                                 );

                }
            //
            // Also, add an entry about this failure to setupapi's PSS exception
            // logfile.
            //
            pSetupHandleFailedVerification(MainWindowHandle,
                                     Problem,
                                     ProblemFile,
                                     (*TitleStringBuffer ? TitleStringBuffer : NULL),
                                     pSetupGetCurrentDriverSigningPolicy(FALSE),
                                     TRUE,  // no UI!
                                     Err,
                                     NULL,   // log context
                                     NULL,    //optional flags
                                     NULL
                                    );

            KillBillboard(*Billboard);
            FatalError(MSG_LOG_SYSSETUP_CATALOGS_NOT_INSTALLED,0,0);

        }

        //
        // make sure to install the private files (specified with /m)
        // BEFORE calling DuInstallUpdates ()
        //
        InstallPrivateFiles(*Billboard);

        if (!MiniSetup && !OobeSetup) {
            //
            // install any updated files, previously
            // downloaded and preprocessed by winnt32
            // if it fails, it already logged the reason
            //
            DuInstallUpdates ();
        }

        if( (Err=PrepDllCache()) != NO_ERROR ){

            SetuplogError(LogSevError,
                          SETUPLOG_USE_MESSAGEID,
                          MSG_LOG_MAKEDLLCACHE_CATALOGS_FAILED,
                          Err,
                          NULL,
                          SETUPLOG_USE_MESSAGEID,
                          Err,
                          NULL,
                          NULL
                         );


        }
    }

    //
    // Accessibility Utilities
    //
    AccessibleSetup = FALSE;

    if(SpSetupLoadParameter(pwAccMagnifier,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        AccessibleSetup = TRUE;
        Magnifier = TRUE;
    } else {
        Magnifier = FALSE;
    }

    if(SpSetupLoadParameter(pwAccReader,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        AccessibleSetup = TRUE;
        ScreenReader = TRUE;
    } else {
        ScreenReader = FALSE;
    }

    if(SpSetupLoadParameter(pwAccKeyboard,p,MAX_PARAM_LEN) &&
        (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {

        AccessibleSetup = TRUE;
        OnScreenKeyboard = TRUE;
    } else {
        OnScreenKeyboard = FALSE;
    }

    //
    // Fetch original source path and source path type.
    // We either deal with network or CD-ROM.
    //
    if(b) {

        Type = DRIVE_CDROM;
        lstrcpy(p,L"A:\\");
        lstrcat(p,PlatformName);

        if(SpSetupLoadParameter(WINNT_D_ORI_SRCPATH,p,MAX_PARAM_LEN)
        && SpSetupLoadParameter(WINNT_D_ORI_SRCTYPE,Num,sizeof(Num)/sizeof(Num[0]))) {
            Type = wcstoul(Num,NULL,10);
            if(Type != DRIVE_REMOTE && Type != DRIVE_FIXED) {
                Type = DRIVE_CDROM;
            }
        }

        if(Type == DRIVE_CDROM) {
            //
            // Make sure the drive is a CD-ROM, as the drive letters
            // may be different then when winnt/winnt32 was run.
            //
            if(MyGetDriveType(p[0]) != DRIVE_CDROM) {
                for(c=L'A'; c<=L'Z'; c++) {
                    if(MyGetDriveType(c) == DRIVE_CDROM) {
                        p[0] = c;
                        break;
                    }
                }

                if(MyGetDriveType(p[0]) != DRIVE_CDROM) {
                    //
                    // No CD-ROM drives. Change to A:.
                    //
                    lstrcpy(p,L"A:\\");
                    lstrcat(p,PlatformName);
                }
            }
        }

        //
        // Root paths should be like x:\ and not just x:.
        //
        if(p[0] && (p[1] == L':') && !p[2]) {
            p[2] = L'\\';
            p[3] = 0;
        }

        OriginalSourcePath = pSetupDuplicateString(p);
        if(!OriginalSourcePath) {
            b = FALSE;
            SetupDebugPrint( L"SETUP: pSetupDuplicateString failed in SpSetupProcessParameters." );
        }
    }

    //
    // The following parameters are optional.
    // - Any optional dirs to copy over?
    // - User specified command to execute
    // - Skip Missing Files?
    //
    if(b && SpSetupLoadParameter(pwOptionalDirs,p,MAX_PARAM_LEN) && *p) {
        OptionalDirSpec = pSetupDuplicateString(p);
        if(!OptionalDirSpec) {
            b=FALSE;
        }
    }
    if(b && SpSetupLoadParameter(pwUXC,p,MAX_PARAM_LEN) && *p) {
        UserExecuteCmd = pSetupDuplicateString(p);
        if(!UserExecuteCmd) {
            b = FALSE;
            SetupDebugPrint( L"SETUP: pSetupDuplicateString failed in SpSetupProcessParameters." );
        }
    }
    if(b && SpSetupLoadParameter(pwSkipMissing,p,MAX_PARAM_LEN)
    && (!lstrcmpi(p,pwYes) || !lstrcmpi(p,pwOne))) {
        SkipMissingFiles = TRUE;
    }

    return(b);
}


NTSTATUS
SpSetupLocateSourceCdRom(
    OUT PWSTR NtPath
    )
/*++

Routine Description:

    Searches all the available CD-ROM devices for source media and
    returns the NT device name for the first CD-ROM that has the
    source media. Currently we use tag file name to validate the 
    source media.

Arguments:

    NtPath - Place holder for receiving NT device name for CD-ROM
             that has the source media.

Returns:

    Appropriate NTSTATUS code.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if (NtPath) {
        WCHAR   LayoutInf[MAX_PATH];        

        if (GetWindowsDirectory(LayoutInf, ARRAYSIZE(LayoutInf))) {
            WCHAR TagFileName[MAX_PATH];
            
            pSetupConcatenatePaths(LayoutInf, 
                TEXT("\\inf\\layout.inf"), 
                ARRAYSIZE(TagFileName),
                NULL);

            if (GetPrivateProfileString(TEXT("strings"),
                    TEXT("cdtagfile"),
                    TEXT(""),
                    TagFileName,
                    ARRAYSIZE(TagFileName),
                    LayoutInf)) {

                SYSTEM_DEVICE_INFORMATION SysDeviceInfo = {0};

                Status = NtQuerySystemInformation(SystemDeviceInformation,
                            &SysDeviceInfo,
                            sizeof(SYSTEM_DEVICE_INFORMATION),
                            NULL);                

                if (NT_SUCCESS(Status) && (0 == SysDeviceInfo.NumberOfCdRoms)) {
                    Status = STATUS_OBJECT_NAME_NOT_FOUND;
                }
 
                if (NT_SUCCESS(Status)) {
                    ULONG   Index;
                    WCHAR   TagFilePathName[MAX_PATH];
                    WCHAR   SourceCdRomPath[MAX_PATH];
                    UNICODE_STRING UnicodeString;
                    OBJECT_ATTRIBUTES ObjectAttributes;
                    IO_STATUS_BLOCK StatusBlock;
                    HANDLE FileHandle;
                    UINT OldMode;

                    for (Index = 0; Index < SysDeviceInfo.NumberOfCdRoms; Index++) {
                        
                        wsprintf(SourceCdRomPath, TEXT("\\device\\cdrom%d\\"), Index);
                        wcscpy(TagFilePathName, SourceCdRomPath);

                        pSetupConcatenatePaths(TagFilePathName,
                            TagFileName,
                            ARRAYSIZE(TagFilePathName),
                            NULL);
                        
                        //
                        // See if the NT source path exists.
                        //
                        RtlInitUnicodeString(&UnicodeString, TagFilePathName);
                        
                        InitializeObjectAttributes(&ObjectAttributes,
                            &UnicodeString,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

                        OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                        Status = NtCreateFile(&FileHandle,
                                    FILE_GENERIC_READ,
                                    &ObjectAttributes,
                                    &StatusBlock,
                                    NULL,
                                    FILE_ATTRIBUTE_NORMAL,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_ALERT,
                                    NULL,
                                    0);

                        SetErrorMode(OldMode);

                        if(NT_SUCCESS(Status)) {
                            CloseHandle(FileHandle);

                            //
                            // The tag file is present which indicates
                            // the current CD-ROM is this is source CD-ROM
                            //
                            wcscpy(NtPath, SourceCdRomPath);
                            
                            break;
                        }
                    }
                }
            }                    
        }
    }

    return Status;
}


BOOL
SpSetupProcessSourcePath(
    IN  PCWSTR  NtPath,
    OUT PWSTR  *DosPath
    )
{
    WCHAR ntPath[MAX_PATH];
    BOOL NtPathIsCd;
    PWCHAR PathPart;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    HANDLE Handle;
    IO_STATUS_BLOCK StatusBlock;
    UINT OldMode;
    WCHAR Drive;
    WCHAR PossibleDosPath[MAX_PATH];
    UINT Type;
    BOOL b;
    WCHAR   LayoutInf[MAX_PATH];        

    #define CDDEVPATH L"\\DEVICE\\CDROM"
    #define CDDEVPATHLEN ((sizeof(CDDEVPATH)/sizeof(WCHAR))-1)

    #define RDRDEVPATH L"\\DEVICE\\LANMANREDIRECTOR"
    #define RDRDEVPATHLEN ((sizeof(RDRDEVPATH)/sizeof(WCHAR))-1)
    
    if (!(NtPath && DosPath)){

        SetupDebugPrint( L"SETUP: SpSetupProcessSourcePath Invalid parameters passed to SpSetupProcessSourcepath." );
        return FALSE;
    }
    
    //
    // Determine the source media type based on the nt path
    //
    lstrcpyn(ntPath,NtPath,MAX_PATH);
    CharUpper(ntPath);

    PathPart = NULL;
    NtPathIsCd = FALSE;
    if(wcsstr(ntPath,L"\\DEVICE\\HARDDISK")) {
        //
        // Looks like a hard drive; make sure it's really valid.
        //
        if(PathPart = wcsstr(ntPath,L"\\PARTITION")) {
            if(PathPart = wcschr(PathPart+1,L'\\')) {
                PathPart++;
            }
        }

    } else {
        if(!memcmp(ntPath,CDDEVPATH,CDDEVPATHLEN*sizeof(WCHAR))) {

            NtPathIsCd = TRUE;

            if(PathPart = wcschr(ntPath+CDDEVPATHLEN,L'\\')) {
                PathPart++;
            } else {
                PathPart = wcschr(ntPath,0);
            }
        }
    }


    //
    // Set a global here so we can always know if we're installing from
    // CD.
    //
    gInstallingFromCD = NtPathIsCd;


    //
    // If the case where we don't recognize the device type, just try to
    // convert it to a DOS path and return.
    //
    if(!PathPart) {

        if (memcmp(ntPath,RDRDEVPATH,RDRDEVPATHLEN*sizeof(WCHAR)) == 0) {

            //
            // Special case for \Device\LanmanRedirector: convert to UNC path.
            //
            *DosPath = MyMalloc((lstrlen(ntPath) - RDRDEVPATHLEN + 2)*sizeof(WCHAR));
            if (*DosPath != NULL) {
                wcscpy(*DosPath, L"\\");
                wcscat(*DosPath, ntPath + RDRDEVPATHLEN);
            }

            //
            // Set RemoteBootSetup to indicate that we're doing a remote boot
            // setup. Set BaseCopyStyle to indicate that single-instance store
            // links should be created instead of copying files.
            //
            RemoteBootSetup = TRUE;
            BaseCopyStyle = SP_COPY_SOURCE_SIS_MASTER;

        } else {
            *DosPath = NtFullPathToDosPath(ntPath);
        }
        return(*DosPath != NULL);
    }

    //
    // See if the NT source path exists for CDROM.
    //

    if (GetWindowsDirectory(LayoutInf, ARRAYSIZE(LayoutInf))) {
        WCHAR TagFileName[MAX_PATH];
        
        pSetupConcatenatePaths(LayoutInf, 
            TEXT("\\inf\\layout.inf"), 
            ARRAYSIZE(LayoutInf),
            NULL);

        //
        // Get the name of the cd tag file name from layout.inf file
        //
        if (GetPrivateProfileString(TEXT("strings"),
                                    TEXT("cdtagfile"),
                                    TEXT(""),
                                    TagFileName,
                                    ARRAYSIZE(TagFileName),
                                    LayoutInf)) {

                WCHAR   TagFilePathName[MAX_PATH];
                HANDLE FileHandle;

                wcscpy(TagFilePathName, ntPath);

                pSetupConcatenatePaths( TagFilePathName,
                                    TagFileName,
                                    ARRAYSIZE(TagFilePathName),
                                    NULL);

                //
                // Check if the tag file exists in the CDROM media 
                // corresponding to the NtPath passed to us from the 
                // Text mode setup. 
                // It could have changed, if there are more than one CDROM 
                // drives on the computer and more than one contain media 
                // as the order in which they get detected in GUI mode setup
                // can be different than in Text mode Setup.
                //
                RtlInitUnicodeString(&UnicodeString, TagFilePathName);

                InitializeObjectAttributes(&ObjectAttributes,
                    &UnicodeString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL);

                OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

                Status = NtCreateFile(&FileHandle,
                            FILE_GENERIC_READ,
                            &ObjectAttributes,
                            &StatusBlock,
                            NULL,
                            FILE_ATTRIBUTE_NORMAL,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            FILE_OPEN,
                            FILE_SYNCHRONOUS_IO_ALERT,
                            NULL,
                            0);

                SetErrorMode(OldMode);

                //
                // Tag file exists in the CDROM media represented by NtPath.
                //
                if(NT_SUCCESS(Status)) {
                    CloseHandle(FileHandle);

                    //
                    // The tag file is present which indicates
                    // the current CD-ROM is this is source CD-ROM
                    //
                    *DosPath = NtFullPathToDosPath(ntPath);
                    return(*DosPath != NULL);
                    
                 }
           }
    }
    

    //
    // Scan for source CD-ROM among available CD-ROM devices.
    // If media not present prompt user so that he can retry or cancel setup.
    //
    if (NtPathIsCd) {
        WCHAR   NtSourceCdRomPath[MAX_PATH] = {0};        
        BOOL    MediaPresent = SpIsSetupSourceMediaPresent(NtSourceCdRomPath);

        if (MediaPresent) {
            *DosPath = NtFullPathToDosPath(NtSourceCdRomPath);

            if (*DosPath) {
                return TRUE;
            }                
        }else{
            return FALSE;
        }
    }

    //
    // The directory does not exist as-is. Look through all dos drives
    // to attempt to find the source path. Match the drive types as well.
    //
    // When we get here PathPart points past the initial \ in the
    // part of the nt device path past the device name. Note that this
    // may be a nul char.
    //
    for(Drive = L'A'; Drive <= L'Z'; Drive++) {

        PossibleDosPath[0] = Drive;
        PossibleDosPath[1] = L':';
        PossibleDosPath[2] = L'\\';
        PossibleDosPath[3] = 0;

        //
        // NOTE: Removable hard drives and floppies both come back
        // as DRIVE_REMOVABLE.
        //
        Type = GetDriveType(PossibleDosPath);

        if(((Type == DRIVE_CDROM) && NtPathIsCd)
        || (((Type == DRIVE_REMOVABLE) || (Type == DRIVE_FIXED)) && !NtPathIsCd)) {
            //
            // See whether the path exists. If we're looking for
            // the root path (such as when installing from a CD,
            // in which case the ntPath was something like
            // \Device\CdRom0\) then we can't use FileExists
            // since that relies on FindFirstFile which fails
            // on root paths.
            //
            if(*PathPart) {
                lstrcpy(PossibleDosPath+3,PathPart);
                b = FileExists(PossibleDosPath,NULL);
            } else {
                b = GetVolumeInformation(
                        PossibleDosPath,
                        NULL,0,             // vol name buffer and size
                        NULL,               // serial #
                        NULL,               // max comp len
                        NULL,               // fs flags
                        NULL,0              // fs name buffer and size
                        );
            }

            if(b) {
                *DosPath = pSetupDuplicateString(PossibleDosPath);
                return(*DosPath != NULL);
            }
        }
    }

    //
    // Couldn't find it. Try a fall-back.
    //
    *DosPath = NtFullPathToDosPath(ntPath);
    return(*DosPath != NULL);
}


VOID
SetUpProcessorNaming(
    VOID
    )

/*++

Routine Description:

    Determines strings which corresponds to the platform name,
    processor name and printer platform. For backwards compat.
    Sets global variables

    PlatformName - a name that indicates the processor platform type;
        one of AMD64, I386, or ia64.

    ProcessorName - a description of the type of processor. This varies
        depending on PlatformName.

    PrinterPlatform - name of platform-specific part of subdirectory
        used in printing architecture. One of w32amd64, w32ia64, or w32x86.

Arguments:

    None

Returns:

    None. Global vars filled in as described above.

--*/

{
    SYSTEM_INFO SystemInfo;

    GetSystemInfo(&SystemInfo);

    switch(SystemInfo.wProcessorArchitecture) {

    case PROCESSOR_ARCHITECTURE_AMD64:
        ProcessorName = L"AMD64";
        PlatformName = L"AMD64";
        PrinterPlatform = L"w32amd64";
        break;

    case PROCESSOR_ARCHITECTURE_INTEL:
        switch(SystemInfo.wProcessorLevel) {
        case 3:
            ProcessorName = (!IsNEC_98) ? L"I386" : L"nec98"; //NEC98
            break;
        case 4:
            ProcessorName = L"I486";
            break;
        case 6:
            ProcessorName = L"I686";
            break;
        case 5:
        default:
            ProcessorName = L"I586";
            break;
        }

        PlatformName = (!IsNEC_98) ? L"I386" : L"nec98"; //NEC98

        PrinterPlatform = L"w32x86";
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        ProcessorName = L"Merced";
        PlatformName = L"IA64";
        PrinterPlatform = L"w32ia64";
        break;
    }

    //
    // In default case the vars stay "" which is what they are
    // statically initialized to.
    //
}


VOID
InitializeUniqueness(
    IN OUT HWND *Billboard
    )

/*++

Routine Description:

    Initialize uniquess by looking in a database file and overwriting the
    parameters file with information found in it, based in a unique identifier
    passed along to us from text mode (and originally winnt/winnt32).

    There are 2 options: the database was copied into the source path by winnt/
    winnt32, or we need to prompt the user to insert a floppy from his admin
    that contains the database.

    The user may elect to cancel, which means setup will continue, but the
    machine will probably not be configured properly.

Arguments:

    Billboard - on input contains handle of currently displayed "Setup is
        Initializing" billboard. On output contains new handle if this routine
        had to display UI. We pass this around to avoid annoying flashing of
        the billboard.

Returns:

    None.

--*/

{
    PWCHAR p;
    WCHAR UniquenessId[MAX_PARAM_LEN];
    WCHAR DatabaseFile[MAX_PATH];
    BOOL Prompt;
    int i;
    UINT OldMode;
    BOOL NeedNewBillboard;

    //
    // Determine whether uniqueness is even important by looking
    // for a uniqueness spec in the parameters file.
    // If the id ends with a * then we expect the uniqueness database file
    // to be in the source, with a reserved name. Otherwise we need to
    // prompt for it on a floppy.
    //
    if(SpSetupLoadParameter(WINNT_D_UNIQUENESS,UniquenessId,MAX_PARAM_LEN)) {
        if(p = wcschr(UniquenessId,L'*')) {
            *p = 0;
            Prompt = FALSE;
        } else {
            Prompt = TRUE;
        }
    } else {
        //
        // We don't care about uniqueness.
        //
        return;
    }

    //
    // If the file is already in the source, attempt to make use of it now.
    // If this fails tell the user and fall through to the floppy prompt case.
    //
    if(!Prompt) {
        lstrcpy(DatabaseFile,SourcePath);
        pSetupConcatenatePaths(DatabaseFile,WINNT_UNIQUENESS_DB,MAX_PATH,NULL);

        if(IntegrateUniquenessInfo(DatabaseFile,UniquenessId)) {
            return;
        }

        MessageBoxFromMessage(
            MainWindowHandle,
            MSG_UNIQUENESS_DB_BAD_1,
            NULL,
            IDS_WINNT_SETUP,
            MB_OK | MB_ICONERROR,
            UniquenessId
            );

        Prompt = TRUE;
    }

    lstrcpy(DatabaseFile,L"A:\\");
    lstrcat(DatabaseFile,WINNT_UNIQUENESS_DB);

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    if(Prompt) {
        KillBillboard(*Billboard);
        NeedNewBillboard = TRUE;
    } else {
        NeedNewBillboard = FALSE;
    }

    while(Prompt) {

        i = MessageBoxFromMessage(
                MainWindowHandle,
                MSG_UNIQUENESS_DB_PROMPT,
                NULL,
                IDS_WINNT_SETUP,
                MB_OKCANCEL
                );

        if(i == IDOK) {
            //
            // User thinks he provided a floppy with the database floppy on it.
            //
            if(IntegrateUniquenessInfo(DatabaseFile,UniquenessId)) {
                Prompt = FALSE;
            } else {
                MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_UNIQUENESS_DB_BAD_2,
                    NULL,
                    IDS_WINNT_SETUP,
                    MB_OK | MB_ICONERROR,
                    UniquenessId
                    );
            }

        } else {
            //
            // User cancelled -- verify.
            //
            i = MessageBoxFromMessage(
                    MainWindowHandle,
                    MSG_UNIQUENESS_DB_VERIFYCANCEL,
                    NULL,
                    IDS_WINNT_SETUP,
                    MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION
                    );

            Prompt = (i != IDYES);
        }
    }

    if(NeedNewBillboard) {
        *Billboard = DisplayBillboard(MainWindowHandle,MSG_INITIALIZING);
    }

    SetErrorMode(OldMode);
}


BOOL
IntegrateUniquenessInfo(
    IN PCWSTR DatabaseFile,
    IN PCWSTR UniqueId
    )

/*++

Routine Description:

    Apply uniqueness data from a database, based on a unique identifier.
    The unique identifier is looked up in the [UniqueIds] section of
    the database file. Each field on the line is the name of a section.
    Each section's data overwrites existing data in the unattend.txt file.

    [UniqueIds]
    Id1 = foo,bar

    [foo]
    a = ...
    b = ...

    [bar]
    y = ...

    etc.

Arguments:

    Database - supplies the name of the uniqueness database (which is
        opened as a legacy inf for simplicity in parsing).

    UniqueId - supplies the unique id for this computer.

Returns:

    Boolean value indicating outcome.

--*/

{
    HINF Database;
    INFCONTEXT InfLine;
    DWORD SectionCount;
    PCWSTR SectionName;
    DWORD i;
    BOOL b;

    //
    // Load the database file as a legacy inf. This makes processing it
    // a little easier.
    //
    Database = SetupOpenInfFile(DatabaseFile,NULL,INF_STYLE_OLDNT,NULL);
    if(Database == INVALID_HANDLE_VALUE) {
        b = FALSE;
        goto c0;
    }

    //
    // Look in the [UniqueIds] section to grab a list of sections
    // we need to overwrite for this user. If the unique id does not appear
    // in the database, bail now. If the id exists but there are no sections,
    // exit with success.
    //
    if(!SetupFindFirstLine(Database,L"UniqueIds",UniqueId,&InfLine)) {
        b = FALSE;
        goto c1;
    }

    SectionCount = SetupGetFieldCount(&InfLine);
    if(!SectionCount) {
        b = TRUE;
        goto c1;
    }

    //
    // Now process each section.
    //
    for(b=TRUE,i=0; b && (i<SectionCount); i++) {

        if(SectionName = pSetupGetField(&InfLine,i+1)) {

            b = ProcessOneUniquenessSection(Database,SectionName,UniqueId);

        } else {
            //
            // Strange case -- the field is there but we can't get at it.
            //
            b = FALSE;
            goto c1;
        }
    }

c1:
    SetupCloseInfFile(Database);
c0:
    return(b);
}


BOOL
ProcessOneUniquenessSection(
    IN HINF   Database,
    IN PCWSTR SectionName,
    IN PCWSTR UniqueId
    )

/*++

Routine Description:

    Within the uniqueness database, process a single section whose contents
    are to be merged into the unattend file. The contents of the section are
    read, key by key, and then written into the unattend file via profile APIs.

    Before looking for the given section, we try to look for a section whose
    name is composed of the unique id and the section name like so

        [someid:sectionname]

    If this section is not found then we look for

        [sectionname]

Arguments:

    Database - supplies handle to profile file (opened as a legacy inf)
        containing the uniqueness database.

    SectionName - supplies the name of the section to be merged into
        unattend.txt.

    UniqueId - supplies the unique id for this computer.

Returns:

    Boolean value indicating outcome.

--*/

{
    BOOL b;
    PWSTR OtherSection;
    PCWSTR section;
    LONG Count;
    DWORD FieldCount;
    DWORD j;
    LONG i;
    INFCONTEXT InfLine;
    PWCHAR Buffer;
    PWCHAR p;
    PCWSTR Key;

    Buffer = MyMalloc(MAX_INF_STRING_LENGTH * sizeof(WCHAR));
    if(!Buffer) {
        return(FALSE);
    }

    //
    // Form the name of the unique section.
    //
    if(OtherSection = MyMalloc((lstrlen(SectionName) + lstrlen(UniqueId) + 2) * sizeof(WCHAR))) {

        b = TRUE;

        lstrcpy(OtherSection,UniqueId);
        lstrcat(OtherSection,L":");
        lstrcat(OtherSection,SectionName);

        //
        // See whether this unique section exists and if not whether
        // the section name exists as given.
        //
        if((Count = SetupGetLineCount(Database,OtherSection)) == -1) {
            Count = SetupGetLineCount(Database,SectionName);
            section = (Count == -1) ? NULL : SectionName;
        } else {
            section = OtherSection;
        }

        if(section) {
            //
            // Process each line in the section. If a line doesn't have a key,
            // ignore it. If a line has only a key, delete the line in the target.
            //
            for(i=0; i<Count; i++) {

                SetupGetLineByIndex(Database,section,i,&InfLine);
                if(Key = pSetupGetField(&InfLine,0)) {
                    if(FieldCount = SetupGetFieldCount(&InfLine)) {

                        Buffer[0] = 0;

                        for(j=0; j<FieldCount; j++) {

                            if(j) {
                                lstrcat(Buffer,L",");
                            }

                            lstrcat(Buffer,L"\"");
                            lstrcat(Buffer,pSetupGetField(&InfLine,j+1));
                            lstrcat(Buffer,L"\"");
                        }

                        p = Buffer;

                    } else {

                        p = NULL;
                    }

                    if(!WritePrivateProfileString(SectionName,Key,p,AnswerFile)) {
                        //
                        // Failure, but keep trying in case others might work.
                        //
                        b = FALSE;
                    }
                }
            }

        } else {
            //
            // Unable to find a matching section. Bail.
            //
            b = FALSE;
        }

        MyFree(OtherSection);
    } else {
        b = FALSE;
    }

    MyFree(Buffer);
    return(b);
}


DWORD
InstallProductCatalogs(
    OUT SetupapiVerifyProblem *Problem,
    OUT LPWSTR                 ProblemFile,
    IN  LPCWSTR                DescriptionForError OPTIONAL
    )
/*++

Routine Description:

    This routine installs all catalog files specified in the
    [ProductCatalogsToInstall] section of syssetup.inf, and validates
    syssetup.inf (and any other INFs append-loaded into its HINF) against the
    catalog that's marked with a non-zero value in the second field of the line.

Arguments:

    Problem - Supplies the address of a variable that receives the type of
        verification error that occurred,  This is only valid if the routine
        returns failure.

    ProblemFile - Supplies a buffer of at least MAX_PATH characters that
        receives the name of the file that caused the verification failure.
        This is only valid if the routine returns failure.

    DescriptionForError - Optionally, supplies descriptive text to be used in a
        call to pSetupHandleFailedVerification() in case an error is encountered.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of the failure.  The Problem and ProblemFile
    parameters may be used in that case to provide more specific information
    about why the failure occurred.

--*/
{
    HINF hInf;
    LONG LineCount, LineNo;
    DWORD RequiredSize;
    WCHAR SyssetupInfName[MAX_PATH], DecompressedName[MAX_PATH];
    WCHAR TrustedCertFolder[MAX_PATH];
    WCHAR TrustedCertPath[MAX_PATH];
    PSP_INF_INFORMATION InfInfoBuffer;
    INFCONTEXT InfContext;
    PCWSTR  SectionName = L"ProductCatalogsToInstall";
    PCWSTR  InfFileName;
    WCHAR CatToInstall[MAX_PATH], PromptPath[MAX_PATH];
    INT CatForInfVerify;
    DWORD Err = NO_ERROR, ret = NO_ERROR;
    UINT ErrorMessageId;
    BOOL PrimaryCatalogProcessed = FALSE;
    UINT i, SourceId;
    WCHAR TempBuffer[MAX_PATH];
    BOOL DeltaCatPresent=FALSE;
    BOOL OemTestSigned=FALSE;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFindFile;
    PWSTR CertFilenameStart;

    //
    // We open up syssetup.inf (and append load any layout INFs) here, just so
    // we can install the catalogs and verify the syssetup.inf and friends
    // against the 'primary' catalog.  Note that this isn't the global
    // SyssetupInf handle--that gets opened up later.  We can't open the global
    // HINF here, since there's stuff that gets done after this routine is
    // called that could potentially change the way we process the INF
    //

    //
    // Retrieve an INF information context containing information about all
    // append-loaded INFs in our syssetup.inf handle.  These INFs will all be
    // validated against our 'primary' catalog file once we discover it.
    //
    if(SetupGetInfInformation(SyssetupInf,
                              INFINFO_INF_SPEC_IS_HINF,
                              NULL,
                              0,
                              &RequiredSize)) {

        MYASSERT(RequiredSize >= sizeof(SP_INF_INFORMATION));

        if(InfInfoBuffer = MyMalloc(RequiredSize)) {

            if(!SetupGetInfInformation(SyssetupInf,
                                       INFINFO_INF_SPEC_IS_HINF,
                                       InfInfoBuffer,
                                       RequiredSize,
                                       NULL)) {
                //
                // This should never fail!
                //
                Err = GetLastError();
                MYASSERT(0);

            }

        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
        }

    } else {
        Err = GetLastError();
        InfInfoBuffer = NULL;
    }

    //
    // If we encountered an error, then we couldn't retrieve information about
    // the loaded INFs in syssetup.inf's HINF--this should never happen
    // (barring an out-of-memory condition), but if it does, just bail.
    //
    if(Err != NO_ERROR) {
        *Problem = SetupapiVerifyInfProblem;
        lstrcpy(ProblemFile, L"syssetup.inf");
        goto clean0;
    }

    //
    // If there's a [SourceDisksFiles] entry for testroot.cer in one of the
    // append-loaded INFs in syssetup.inf's HINF (specifically, from
    // layout.inf), then we will go and install that test certificate in the
    // root store so that the test signatures used for this internal-release-only
    // build will be verified.  We will also install a test root certificate if
    // one is specified in unattend.txt in the "TestCert" entry in the
    // [unattended] section.
    //
    // If testroot.cer isn't listed in one of the two aforementioned locations,
    // then we know the files in this build were signed for real, so we want to
    // delete the test certificate(s), in case we're updating an installation
    // that was installed previously using a test-signed build.
    //
    if(SetupGetSourceFileLocation(SyssetupInf, NULL, L"testroot.cer", &SourceId, NULL, 0, NULL)) {
        //
        // Testroot.cer must exist (possibly compressed) in the source
        // directory. (Regardless of whether testroot.cer is compressed, use
        // the DecompressedName buffer to temporarily hold this filename.)
        //
        lstrcpy(DecompressedName, L"testroot.cer");

    } else {

        GetSystemDirectory(TempBuffer, MAX_PATH);
        pSetupConcatenatePaths(TempBuffer, WINNT_GUI_FILE, MAX_PATH, NULL);

        if(GetPrivateProfileString(WINNT_UNATTENDED,
                                   WINNT_U_TESTCERT,
                                   pwNull,
                                   DecompressedName,
                                   MAX_PATH,
                                   TempBuffer)) {

            OemTestSigned = TRUE;
        }
    }

    if(*DecompressedName) {

        Err = SetupAddOrRemoveTestCertificate(
                  DecompressedName,
                  (OemTestSigned ? INVALID_HANDLE_VALUE : SyssetupInf)
                 );

        if(Err != NO_ERROR) {
            SetupDebugPrint2(L"SETUP: SetupAddOrRemoveTestCertificate(%ls) failed. Error = %d \n", DecompressedName, Err );
            //
            // This is considered a critial failure--as we could bugcheck post - setup.
            //

            SetuplogError(LogSevError,
                          SETUPLOG_USE_MESSAGEID,
                          MSG_LOG_SYSSETUP_CERT_NOT_INSTALLED,
                          DecompressedName,
                          Err,
                          NULL,
                          SETUPLOG_USE_MESSAGEID,
                          Err,
                          NULL,
                          NULL
                         );

            //
            // If this was an internal test-signed build, then point the
            // accusing finger at syssetup.inf.
            //
            if(!OemTestSigned) {
                *Problem = SetupapiVerifyInfProblem;
                lstrcpy(ProblemFile, L"syssetup.inf");
            } else {
                *Problem = SetupapiVerifyCatalogProblem;
                lstrcpy(ProblemFile, DecompressedName);
            }

            if(InfInfoBuffer)
                    MyFree(InfInfoBuffer);

            return Err;


        }

    } else {
        //
        // testroot.cer isn't listed--remove it from the installation in case
        // we're upgrading over an internal-release-only test build.
        //
        MYASSERT(GetLastError() == ERROR_LINE_NOT_FOUND);
        Err = SetupAddOrRemoveTestCertificate(NULL,NULL);
        if(Err != NO_ERROR) {
            SetupDebugPrint1(L"SETUP: SetupAddOrRemoveTestCertificate(NULL) failed. Error = %d \n", Err );
            //
            // This is not considered a critial failure.
            //
            Err = NO_ERROR;
        }
    }

    //
    // Install into the "TrustedPublisher" certificate store any certificates 
    // for publishers of Authenticode signed catalogs who are to be 
    // automatically trusted (i.e., no user prompting) when installing driver
    // packages that don't fall under one of the WHQL logo-able classes.
    //
    // A directory containing certificates to be installed (*.cer files) may be
    // specified by an "TrustedPublisherCertificates" entry in the
    // [Unattended] section of unattend.txt.
    //
    GetSystemDirectory(TempBuffer, MAX_PATH);
    pSetupConcatenatePaths(TempBuffer, WINNT_GUI_FILE, MAX_PATH, NULL);

    if(GetPrivateProfileString(WINNT_UNATTENDED,
                               WINNT_U_TRUSTEDPUBLISHERCERTIFICATES,
                               pwNull,
                               TrustedCertFolder,
                               MAX_PATH,
                               TempBuffer)) {
        //
        // The directory specified must be relative to %SystemDrive%...
        //
        StringCchCopy(TrustedCertPath, MAX_PATH, L"%SystemDrive%");
        pSetupConcatenatePaths(TrustedCertPath, TrustedCertFolder, MAX_PATH, NULL);

        //
        // Now expand the environment string to get the actual path...
        //
        ExpandEnvironmentStrings(TrustedCertPath, TrustedCertFolder, MAX_PATH);

        //
        // Iterate through the *.cer files contained in this directory,
        // installing each one in the TrustedPublisher certificate store.
        //
        pSetupConcatenatePaths(TrustedCertFolder, L"*.cer", MAX_PATH, NULL);

        hFindFile = FindFirstFile(TrustedCertFolder, &FindFileData);

        //
        // Find the location where the filename starts, so we can replace
        // it with each file we find.
        //
        CertFilenameStart = (PWSTR)pSetupGetFileTitle(TrustedCertFolder);

        if(hFindFile != INVALID_HANDLE_VALUE) {

            do {

                if(SUCCEEDED(StringCchCopy(CertFilenameStart,
                                           MAX_PATH - (CertFilenameStart - TrustedCertFolder),
                                           FindFileData.cFileName))) {

                    Err = SetupInstallTrustedCertificate(TrustedCertFolder);

                    if(Err == NO_ERROR) {
                        //
                        // Certificate successfully "transferred" into the
                        // TrustedPublisher store.  Delete the certificate
                        // file.
                        //
                        DeleteFile(TrustedCertFolder);

                    } else {
                        //
                        // This error is not considered critical.
                        //
                        SetupDebugPrint2(L"SETUP: SetupInstallTrustedCertificate(%ls) failed. Error = %d \n", TrustedCertFolder, Err );

                        SetuplogError(LogSevWarning,
                                      SETUPLOG_USE_MESSAGEID,
                                      MSG_LOG_SYSSETUP_TRUSTED_CERT_NOT_INSTALLED,
                                      TrustedCertFolder,
                                      Err,
                                      NULL,
                                      SETUPLOG_USE_MESSAGEID,
                                      Err,
                                      NULL,
                                      NULL
                                     );
                        //
                        // We don't delete the file, which will cause us t
                        // leave the certificate directory on the user's
                        // harddisk in the case of any failure encountered (at
                        // least they'll still have the certificates in their
                        // original form).
                        //
                    }
                }

            } while(FindNextFile(hFindFile, &FindFileData));

            FindClose(hFindFile);
        }

        //
        // Delete the directory housing the certificates.  If one or more
        // certificates failed to install (or if there are other 
        // non-certificate files in the directory, then this will fail, and
        // we'll leave the directory alone.
        //
        *CertFilenameStart = L'\0';

        RemoveDirectory(TrustedCertFolder);
    }

    //
    // Loop through all the lines in the ProductCatalogsToInstall section,
    // verifying and installing each one.
    //
    LineCount = SetupGetLineCount(SyssetupInf, SectionName);
    for(LineNo=0; LineNo<LineCount+1; LineNo++) {

        if(LineNo==LineCount){
            if(IncludeCatalog && *IncludeCatalog ){
                DeltaCatPresent = TRUE;             // This indicates presence as well as says that we
            }else                                   // are looking at delta.cat in this iteration.
                break;


        }

        if((SetupGetLineByIndex(SyssetupInf, SectionName, LineNo, &InfContext)
           && (InfFileName = pSetupGetField(&InfContext,1))) || DeltaCatPresent ) {

            if( DeltaCatPresent )
                InfFileName = IncludeCatalog;

            //
            // This .CAT file might be compressed (e.g., .CA_), so decompress it
            // into a temporary file in the windows directory.  (Use CatToInstall
            // temporarily as a holding space for the windows directory in
            // preparation for a call to GetTempFileName).
            //
            if(!GetWindowsDirectory(CatToInstall, SIZECHARS(CatToInstall)) ||
               !GetTempFileName(CatToInstall, L"SETP", 0, DecompressedName)) {

                Err = GetLastError();
                if(InfInfoBuffer)
                    MyFree(InfInfoBuffer);

                return Err;
            }

            //
            // The catalog file will be in the (platform-specific) source
            // directory...
            //
            BuildPathToInstallationFile (InfFileName, CatToInstall, SIZECHARS(CatToInstall));

            //
            // If the 2nd field of this line has a non-zero value, then this is
            // the catalog against which the members of the HINF must be
            // verified.
            //
            if(!DeltaCatPresent && !SetupGetIntField(&InfContext, 2, &CatForInfVerify)) {
                CatForInfVerify = 0;
            }



            //
            // Get necessary strings and source ID for UI if needed.
            //

            if( DeltaCatPresent ){

                Err = SetupDecompressOrCopyFile(CatToInstall,
                                                DecompressedName,
                                                NULL);

            }else{



                SetupGetSourceFileLocation(
                            SyssetupInf,
                            NULL,
                            InfFileName,
                            &SourceId,   //re-using
                            NULL,
                            0,
                            NULL
                            );

                SetupGetSourceInfo(
                            SyssetupInf,
                            SourceId,
                            SRCINFO_DESCRIPTION,
                            TempBuffer,
                            sizeof(TempBuffer)/sizeof(WCHAR),
                            NULL
                            );

                //
                // This .CAT file might be compressed (e.g., .CA_), so decompress it
                // into a temporary file in the windows directory.
                //


                do{

                    Err = DuSetupPromptForDisk (
                                MainWindowHandle,
                                NULL,
                                TempBuffer,
                                LegacySourcePath,
                                InfFileName,
                                NULL,
                                IDF_CHECKFIRST | IDF_NODETAILS | IDF_NOBROWSE,
                                PromptPath,
                                MAX_PATH,
                                NULL
                                );


                    if( Err == DPROMPT_SUCCESS ){

                        lstrcpy( CatToInstall, PromptPath );
                        pSetupConcatenatePaths(CatToInstall, InfFileName, SIZECHARS(CatToInstall), NULL);

                        Err = SetupDecompressOrCopyFile(CatToInstall,
                                                        DecompressedName,
                                                        NULL);
                    }




                }while( Err == ERROR_NOT_READY );
            }

            if(Err != NO_ERROR){

                if( lstrcmpi(InfFileName, L"NT5.CAT") && !CatForInfVerify ){
                    SetuplogError(LogSevError,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SYSSETUP_CATFILE_SKIPPED,
                              CatToInstall,
                              NULL,
                              SETUPLOG_USE_MESSAGEID,
                              Err,
                              NULL,
                              NULL
                             );
                    Err = NO_ERROR;
                    continue;
                }
                else{
                    SetuplogError(LogSevError,
                              SETUPLOG_USE_MESSAGEID,
                              MSG_LOG_SYSSETUP_CATFILE_NOT_FOUND,
                              CatToInstall,
                              Err,
                              NULL,
                              SETUPLOG_USE_MESSAGEID,
                              Err,
                              NULL,
                              NULL
                             );
                }

                if(InfInfoBuffer)
                        MyFree(InfInfoBuffer);

                return Err;                //Fatal (NT5.cat or NT5INF.cat)- must fail as we could bugcheck later
            }



            if(CatForInfVerify) {

                PrimaryCatalogProcessed = TRUE;

                //
                // Verify all INFs in syssetup.inf's HINF using this catalog.
                //
                for(i = 0;
                    ((Err == NO_ERROR) && (i < InfInfoBuffer->InfCount));
                    i++)
                {
                    if(!SetupQueryInfFileInformation(InfInfoBuffer,
                                                     i,
                                                     SyssetupInfName,
                                                     SIZECHARS(SyssetupInfName),
                                                     NULL)) {
                        //
                        // This should never fail!
                        //
                        MYASSERT(0);
                        //
                        // Just use syssetup.inf's simple name so there'll
                        // be some clue as to what blew up.
                        //
                        lstrcpy(ProblemFile, L"syssetup.inf");
                        *Problem = SetupapiVerifyInfProblem;
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        break;
                    }

                    Err = pSetupVerifyFile(NULL,
                                     DecompressedName,
                                     NULL,
                                     0,
                                     pSetupGetFileTitle(SyssetupInfName),
                                     SyssetupInfName,
                                     Problem,
                                     ProblemFile,
                                     FALSE,
                                     NULL,
                                     NULL,
                                     NULL
                                    );
                }

                if(Err != NO_ERROR) {
                    //
                    // Just return the error--the caller will deal with it.
                    //
                    if(*Problem == SetupapiVerifyCatalogProblem) {
                        //
                        // Use the catalog's original name, not our temporary
                        // filename.
                        //
                        lstrcpy(ProblemFile, CatToInstall);
                    } else {
                        //
                        // pSetupVerifyCatalogFile didn't know we were asking it to verify an
                        // INF, but we do.
                        //
                        *Problem = SetupapiVerifyInfProblem;
                    }
                    DeleteFile(DecompressedName);
                    goto clean0;
                }

                //
                // OK, catalog and INF both verify--now install the catalog.
                //

                Err = pSetupInstallCatalog(DecompressedName, InfFileName, NULL);

                if(Err != NO_ERROR) {
                    //
                    // Fill out problem information about the catalog we couldn't
                    // install, and return this error to the caller.
                    //
                    *Problem = SetupapiVerifyCatalogProblem;
                    lstrcpy(ProblemFile, CatToInstall);
                    DeleteFile(DecompressedName);
                    goto clean0;
                }

            } else {


                //
                // Just verify the catalog, and if it's OK, then install it.
                // (If we encounter any errors here, we'll log an event about it.
                //

                Err = pSetupVerifyCatalogFile(DecompressedName);


                if(Err == NO_ERROR) {
                    Err = pSetupInstallCatalog(DecompressedName, InfFileName, NULL);
                    if(Err != NO_ERROR) {
                        ErrorMessageId = MSG_LOG_SYSSETUP_CATINSTALL_FAILED;
                    }
                } else {
                    ErrorMessageId = MSG_LOG_SYSSETUP_VERIFY_FAILED;
                }

                if(Err != NO_ERROR) {
                    DWORD DontCare;

                    SetuplogError(LogSevError,
                                  SETUPLOG_USE_MESSAGEID,
                                  ErrorMessageId,
                                  CatToInstall,
                                  Err,
                                  NULL,
                                  SETUPLOG_USE_MESSAGEID,
                                  Err,
                                  NULL,
                                  NULL
                                 );

                    //
                    // Also, add an entry about this failure to setupapi's PSS
                    // exception logfile.
                    //
                    pSetupHandleFailedVerification(MainWindowHandle,
                                             SetupapiVerifyCatalogProblem,
                                             CatToInstall,
                                             DescriptionForError,
                                             pSetupGetCurrentDriverSigningPolicy(FALSE),
                                             TRUE,  // no UI!
                                             Err,
                                             NULL,  // log context
                                             NULL, // optional flags
                                             NULL
                                            );


                    if( !lstrcmpi(InfFileName, L"NT5.CAT") ){      //Special case NT5.CAT as critical failure
                        *Problem = SetupapiVerifyCatalogProblem;   //Otherwise just log it and move on
                        lstrcpy(ProblemFile, CatToInstall);
                        DeleteFile(DecompressedName);
                        goto clean0;
                    }else
                        Err = NO_ERROR;


                }
            }

            //
            // Delete the temporary file we created to hold the decompressed
            // catalog during verification/installation.
            //

            DeleteFile(DecompressedName);
        }
    }

clean0:

    if(!PrimaryCatalogProcessed) {
        //
        // Then we didn't find a line in our ProductCatalogsToInstall section
        // that was marked as the 'primary' catalog.  Point the accusing finger
        // at syssetup.inf.
        //
        if(!SetupQueryInfFileInformation(InfInfoBuffer,
                                         0,
                                         ProblemFile,
                                         MAX_PATH,
                                         NULL)) {
            //
            // This should never fail!
            //
            MYASSERT(0);
            //
            // Just use syssetup.inf's simple name so there'll be some clue as
            // to what blew up.
            //
            lstrcpy(ProblemFile, L"syssetup.inf");
        }

        *Problem = SetupapiVerifyInfProblem;
        Err = ERROR_LINE_NOT_FOUND;
    }

    if(InfInfoBuffer) {
        MyFree(InfInfoBuffer);
    }

    return Err;
}

DWORD
SetupInstallCatalog(
    IN LPCWSTR DecompressedName
    )
{
    PCWSTR  InfFileName = pSetupGetFileTitle(DecompressedName);
    DWORD   Err;
    UINT    ErrorMessageId;

    Err = pSetupVerifyCatalogFile(DecompressedName);

    if(Err == NO_ERROR) {
        Err = pSetupInstallCatalog(DecompressedName, InfFileName, NULL);
        if(Err != NO_ERROR) {
            ErrorMessageId = MSG_LOG_SYSSETUP_CATINSTALL_FAILED;
        }
    } else {
        ErrorMessageId = MSG_LOG_SYSSETUP_VERIFY_FAILED;
    }

    if(Err != NO_ERROR) {

        SetuplogError(LogSevError,
                      SETUPLOG_USE_MESSAGEID,
                      ErrorMessageId,
                      DecompressedName,
                      Err,
                      NULL,
                      SETUPLOG_USE_MESSAGEID,
                      Err,
                      NULL,
                      NULL
                     );
    }

    return Err;
}

VOID
InitializeCodeSigningPolicies(
    IN BOOL ForGuiSetup
    )
/*++

Routine Description:

    Sets up the system-default policy values for driver and non-driver signing.
    These policies control what action is taken when a digital signature
    verification failure is encountered.  The possible values are:

    Ignore (0) -- suppress any UI and continue with the operation (we do still
                  log the error, however)
    Warn (1)   -- warn the user, giving them the option of continuing in spite
                  of the verification failure
    Block (2)  -- inform the user of the failure, and do not allow them to
                  continue with the operation

    The registry path for driver signing policy is:

        HKLM\Software\Microsoft\Driver Signing

    and the registry path for non-driver signing policy is:

        HKLM\Software\Microsoft\Non-Driver Signing

    In both cases, the value entry is called "Policy".  For Win98 compatibility,
    this value is a REG_BINARY (length 1).  However, when the codesigning stuff
    was first checked in on NT, it was implemented as a REG_DWORD.  At that
    time, the default policy was ignore.  We now want the default to be warn for
    both driver and non-driver signing during GUI-mode setup, while dropping the
    non-driver signing policy back to ignore once GUI-mode setup is completed.
    (If answerfile values are specified for either of these policies, those
    values are in effect for GUI-mode setup and thereafter.)

    When upgrading from previous builds (in the absence of answerfile entries),
    we want to preserve the existing policy settings once GUI-mode setup is
    completed.  However, we'd like to raise the policy level to warn post-setup
    for upgrades from older builds (like beta 2).  We use the aforementioned
    difference between the present REG_BINARY type and the old REG_DWORD type to
    accomplish this.  If we retrieve the existing driver signing policy and its
    data type is REG_DWORD, then we update it to be set to warn (unless it's
    already set to block, in which case we leave it alone).

Arguments:

    ForGuiSetup - if non-zero (TRUE), then we're entering GUI-mode setup, and
        we'll apply the answerfile policies, if provided.  Otherwise, we'll use
        the same default values that are in-place post-setup.  (Presently, this
        is Warn for driver signing, and Ignore for non-driver signing.)

        If zero (FALSE), we're leaving GUI-mode setup, and we want to restore
        the policies that were in effect when we entered setup.  If there
        weren't any (i.e., a fresh install) then they were initialized to warn
        and ignore for driver and non-driver signing, respectively.  See
        discussion above for how we raise driver signing policy from its old
        default of ignore to the present default of warn.

Return Value:

    None

--*/
{
    WCHAR p[MAX_PARAM_LEN];
    BYTE SpDrvSignPolicy, SpNonDrvSignPolicy;
    LONG Err;

    if(ForGuiSetup) {

        //
        // Default in GUI-mode setup is that driver signing policy is set to
        // warn, and non-driver signing policy is set to ignore.
        //
        SpDrvSignPolicy = DRIVERSIGN_WARNING;
        SpNonDrvSignPolicy = DRIVERSIGN_NONE;

        //
        // Retrieve the (optional) system-default policy for driver signing.
        //
        if(SpSetupLoadParameter(pwDrvSignPol,p,MAX_PARAM_LEN)) {
            if(!lstrcmpi(p, pwIgnore)) {
                AFDrvSignPolicySpecified = TRUE;
                SpDrvSignPolicy = DRIVERSIGN_NONE;
            } else if(!lstrcmpi(p, pwWarn)) {
                AFDrvSignPolicySpecified = TRUE;
                SpDrvSignPolicy = DRIVERSIGN_WARNING;
            } else if(!lstrcmpi(p, pwBlock)) {
                AFDrvSignPolicySpecified = TRUE;
                SpDrvSignPolicy = DRIVERSIGN_BLOCKING;
            }
        }

        SetCodeSigningPolicy(PolicyTypeDriverSigning,
                             SpDrvSignPolicy,
                             (AFDrvSignPolicySpecified
                                 ? NULL
                                 : &DrvSignPolicy)
                            );

        //
        // Now retrieve the (optional) system-default policy for non-driver
        // signing.
        //
        if(SpSetupLoadParameter(pwNonDrvSignPol,p,MAX_PARAM_LEN)) {
            if(!lstrcmpi(p, pwIgnore)) {
                AFNonDrvSignPolicySpecified = TRUE;
                SpNonDrvSignPolicy = DRIVERSIGN_NONE;
            } else if(!lstrcmpi(p, pwWarn)) {
                AFNonDrvSignPolicySpecified = TRUE;
                SpNonDrvSignPolicy = DRIVERSIGN_WARNING;
            } else if(!lstrcmpi(p, pwBlock)) {
                AFNonDrvSignPolicySpecified = TRUE;
                SpNonDrvSignPolicy = DRIVERSIGN_BLOCKING;
            }
        }

        SetCodeSigningPolicy(PolicyTypeNonDriverSigning,
                             SpNonDrvSignPolicy,
                             (AFNonDrvSignPolicySpecified
                                 ? NULL
                                 : &NonDrvSignPolicy)
                            );

    } else {
        //
        // We're setting up the policies to be in effect after GUI-mode setup.
        // If the answer file specified a policy, then we'll leave that in
        // effect (i.e., it's applicable both during GUI-mode setup and
        // thereafter).
        //
        if(!AFDrvSignPolicySpecified) {
            SetCodeSigningPolicy(PolicyTypeDriverSigning, DrvSignPolicy, NULL);
        }

        if(!AFNonDrvSignPolicySpecified) {
            SetCodeSigningPolicy(PolicyTypeNonDriverSigning, NonDrvSignPolicy, NULL);
        }
    }
}


VOID
InstallPrivateFiles(
    IN HWND Billboard
    )
/*
    Routine to make sure that files in delta.inf (winnt32 /m private files that live inside the cab)
    are copied to the driver cache directory so that setupapi finds them instead of the ones in the
    cab.

*/
{
    WCHAR DeltaPath[MAX_PATH];
    HINF DeltaInf;
    HSPFILEQ FileQueue;
    PVOID QContext;
    BOOL b=TRUE;
    BYTE PrevPolicy;
    BOOL ResetPolicy = TRUE;

    //
    // Unless the default non-driver signing policy was overridden via an
    // answerfile entry, then we want to temporarily turn down the policy level
    // to ignore while we copy optional directories.  Of course, setupapi log
    // entries will still be generated for any unsigned files copied during
    // this time, but there'll be no UI.
    //



    if(!AFNonDrvSignPolicySpecified) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, DRIVERSIGN_NONE, &PrevPolicy);
        ResetPolicy = TRUE;
    }

    BuildPathToInstallationFileEx (L"delta.inf", DeltaPath, MAX_PATH, FALSE);

    FileQueue = SetupOpenFileQueue();
    b = b && (FileQueue != INVALID_HANDLE_VALUE);
    b = b && FileExists( DeltaPath, NULL );

    if(b){

        DeltaInf = SetupOpenInfFile(DeltaPath,NULL,INF_STYLE_WIN4,NULL);
        if(DeltaInf && (DeltaInf != INVALID_HANDLE_VALUE)) {

            SetupInstallFilesFromInfSection(
                DeltaInf,
                NULL,
                FileQueue,
                L"InstallSection",
                LegacySourcePath,
                SP_COPY_NEWER
                );

            SetupCloseInfFile(DeltaInf);
        } else {
            b = FALSE;
        }
    }
    if( b ){

        QContext = InitSysSetupQueueCallbackEx(
                    Billboard,
                    INVALID_HANDLE_VALUE,
                    0,0,NULL);
        if (QContext) {

            b = SetupCommitFileQueue(
                    Billboard,
                    FileQueue,
                    SysSetupQueueCallback,
                    QContext
                    );

            TermSysSetupQueueCallback(QContext);
        } else {
            b = FALSE;
        }
    }

    if(FileQueue != INVALID_HANDLE_VALUE)
        SetupCloseFileQueue(FileQueue);

    //
    // Now crank the non-driver signing policy back up to what it was prior to
    // entering this routine.
    //

    if(ResetPolicy) {
        SetCodeSigningPolicy(PolicyTypeNonDriverSigning, PrevPolicy, NULL);
    }

    return;

}

BOOL
IsCatalogPresent(
    IN PCWSTR CatalogName
    )
{
    WCHAR FileBuffer[MAX_PATH];

    ExpandEnvironmentStrings( L"%systemroot%", FileBuffer, sizeof(FileBuffer)/sizeof(WCHAR));
    pSetupConcatenatePaths( FileBuffer, FILEUTIL_HORRIBLE_PATHNAME, MAX_PATH, NULL );
    pSetupConcatenatePaths( FileBuffer, CatalogName, MAX_PATH, NULL );

    return (FileExists( FileBuffer, NULL));
}

BOOL
CALLBACK 
CatalogListCallback(
    IN PCWSTR Directory OPTIONAL, 
    IN PCWSTR FilePath
    )
/*++

Routine Description:

    This is the callback function for enumerating catalogs in a directory.

Arguments:

    Directory - If not NULL or empty, it will be prepended to FilePath to build the file path
    FilePath -  Path (including file name) to the file to verify

Return value:

    TRUE if the file is a catalog, FALSE otherwise.

--*/
{
    BOOL bRet = FALSE;
    PWSTR szPath = NULL;
    DWORD Error;

    if(NULL == FilePath || 0 == FilePath[0]) {
        goto exit;
    }

    if(Directory != NULL && Directory[0] != 0) {
        szPath = MyMalloc(MAX_PATH * sizeof(WCHAR));

        if(NULL == szPath) {
            goto exit;
        }

        wcsncpy(szPath, Directory, MAX_PATH - 1);
        szPath[MAX_PATH - 1] = 0;
        
        if(!pSetupConcatenatePaths(szPath, FilePath, MAX_PATH, NULL)) {
            goto exit;
        }

        FilePath = szPath;
    }

    bRet = IsCatalogFile(INVALID_HANDLE_VALUE, (PWSTR) FilePath);

exit:
    if(szPath != NULL) {
        MyFree(szPath);
    }

    return bRet;
}

DWORD
DeleteOldCatalogs(
    VOID
    )
/*++

Routine Description:

    This routine deletes the catalogs specified by the ProductCatalogsToUninstall section of syssetup.inf.
    It does not delete any system catalogs (i.e. specified by the ProductCatalogsToInstall section of the same inf) since
    they will be installed after this function completes.

Arguments:

    None.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/
{
    DWORD Error = NO_ERROR;
    HINF hInf = INVALID_HANDLE_VALUE;
    HCATADMIN hCatAdmin = NULL;
    PTSTR szCatPath = NULL;
    LIST_ENTRY InstalledCatalogsList;
    LONG lLines;
    LONG i;
    PCWSTR szInstallSection = L"ProductCatalogsToInstall";
    PCWSTR szUninstallSection = L"ProductCatalogsToUninstall";
    InitializeListHead(&InstalledCatalogsList);

    if(!CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        Error = GetLastError();
        goto exit;
    }

    //
    // Uninstall exception package catalogs first; this could cleanup the list of installed catalogs a bit
    //
    SpUninstallExcepPackCatalogs(hCatAdmin);
    szCatPath = (PTSTR) MyMalloc(MAX_PATH * sizeof(TCHAR));

    if(NULL == szCatPath) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Build the list of installed catalogs
    //
    GetWindowsDirectory(szCatPath, MAX_PATH);

    if(!pSetupConcatenatePaths(szCatPath, FILEUTIL_HORRIBLE_PATHNAME, MAX_PATH, NULL)) {
        Error = ERROR_BAD_PATHNAME;
        goto exit;
    }

    Error = BuildFileListFromDir(szCatPath, NULL, 0, FILE_ATTRIBUTE_DIRECTORY, CatalogListCallback, &InstalledCatalogsList);

    if(Error != ERROR_SUCCESS) {
        goto exit;
    }

    //
    // Remove the system catalogs from the installed catalogs list since we don't want to delete them
    //
    hInf = SetupOpenInfFile(L"syssetup.inf", NULL, INF_STYLE_WIN4, NULL);

    if(INVALID_HANDLE_VALUE == hInf) {
        Error = GetLastError();
        goto exit;
    }

    lLines = SetupGetLineCount(hInf, szInstallSection);

    for(i = 0; i < lLines; ++i) {
        INFCONTEXT ctx;
        PCWSTR szCatName;
        PSTRING_LIST_ENTRY pString;
        
        if(!SetupGetLineByIndex(hInf, szInstallSection, i, &ctx)) {
            Error = GetLastError();
            goto exit;
        }

        szCatName = pSetupGetField(&ctx, 1);

        if(NULL == szCatName) {
            Error = GetLastError();
            goto exit;
        }

        pString = SearchStringInList(&InstalledCatalogsList, szCatName, FALSE);

        if(pString != NULL) {
            RemoveEntryList(&pString->Entry);
            FreeStringEntry(&pString->Entry, TRUE);
        }
    }

    if(InstalledCatalogsList.Flink == &InstalledCatalogsList) {
        //
        // No catalogs left
        //
        goto exit;
    }
    //
    // Uninstall every catalog in the uninstall list
    //
    lLines = SetupGetLineCount(hInf, szUninstallSection);

    for(i = 0; i < lLines; ++i) {
        INFCONTEXT ctx;
        PCWSTR szCatName;
        PCWSTR szAttribName;
        PCWSTR szAttribValue;
        
        if(!SetupGetLineByIndex(hInf, szUninstallSection, i, &ctx)) {
            Error = GetLastError();
            goto exit;
        }

        szCatName = pSetupGetField(&ctx, 1);

        if(NULL == szCatName) {
            Error = GetLastError();
            goto exit;
        }

        szAttribName = pSetupGetField(&ctx, 2);
        szAttribValue = pSetupGetField(&ctx, 3);

        if(0 == szCatName[0]) {
            PLIST_ENTRY pEntry;

            //
            // If the name is not specified, an attribute or a value must be specified
            //
            if((NULL == szAttribName || 0 == szAttribName[0]) && (NULL == szAttribValue || 0 == szAttribValue[0])) {
                Error = ERROR_INVALID_DATA;
                goto exit;
            }

            //
            // Uninstall every catalog with the attribute name/value specified
            //
            pEntry = InstalledCatalogsList.Flink;

            while(pEntry != &InstalledCatalogsList) {
                //
                // Save Flink since SpUninstallCatalog might destroy pEntry
                //
                PLIST_ENTRY Flink = pEntry->Flink;
                PSTRING_LIST_ENTRY pString = CONTAINING_RECORD(pEntry, STRING_LIST_ENTRY, Entry);
                SpUninstallCatalog(hCatAdmin, pString->String, szCatPath, szAttribName, szAttribValue, &InstalledCatalogsList);
                pEntry = Flink;
            }
        } else {
            SpUninstallCatalog(hCatAdmin, szCatName, szCatPath, szAttribName, szAttribValue, &InstalledCatalogsList);
        }
    }

exit:
    FreeStringList(&InstalledCatalogsList);
    
    if(szCatPath != NULL) {
        MyFree(szCatPath);
    }

    if(NULL != hCatAdmin) {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return Error;
}

VOID
GetDllCacheFolder(
    OUT LPWSTR CacheDir,
    IN DWORD cbCacheDir
    )
{
    DWORD retval;
    DWORD Type,Length;
    PWSTR RegData;

    if ((retval = QueryValueInHKLM(
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
            L"SFCDllCacheDir",
            &Type,
            (PVOID)&RegData,
            &Length)) != NO_ERROR) {
        ExpandEnvironmentStrings(
                            L"%systemroot%\\system32\\dllcache",
                            CacheDir,
                            cbCacheDir );
    } else {
        ExpandEnvironmentStrings(
                            RegData,
                            CacheDir,
                            cbCacheDir );
        MyFree(RegData);
    }
}


DWORD
CleanOutDllCache(
    VOID
    )
/*++

Routine Description:

    This routine cleans out the current dllcache contents.

Arguments:

    None.

Return Value:

    Win32 error code indicating outcome.

--*/
{
    DWORD retval = ERROR_SUCCESS, DeleteError = ERROR_SUCCESS;
    WIN32_FIND_DATA FindFileData;
    WCHAR CacheDir[MAX_PATH];
    HANDLE hFind;
    PWSTR p;

    GetDllCacheFolder(CacheDir, MAX_PATH);



    MYASSERT(*CacheDir != L'\0');

    pSetupConcatenatePaths( CacheDir, L"*", MAX_PATH, NULL );

    //
    // save pointer to directory
    //
    p = wcsrchr( CacheDir, L'\\' );
    if (!p) {
        ASSERT(FALSE);
        retval = ERROR_INVALID_DATA;
        goto exit;
    }

    p += 1;

    hFind = FindFirstFile( CacheDir, &FindFileData );
    if (hFind == INVALID_HANDLE_VALUE) {
        retval = GetLastError();
        goto exit;
    }

    do {
        if ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
            wcscpy( p, FindFileData.cFileName );
            SetFileAttributes( CacheDir, FILE_ATTRIBUTE_NORMAL );
            if (!DeleteFile( CacheDir )) {
                DeleteError = GetLastError();
            }
        }
    } while(FindNextFile( hFind, &FindFileData ));

    FindClose( hFind );

    retval = DeleteError;

exit:
    return(retval);

}


DWORD
PrepDllCache(
    VOID
    )
/*++

Routine Description:

    This routine prepares the dllcache for later on in setup.  It cleans out
    the current dllcache contents and copies in a copy of the system catalog
    files.

Arguments:

    None.

Return Value:

    If successful, the return value is NO_ERROR, otherwise it is a Win32 error
    code indicating the cause of the failure.

--*/
{
    DWORD retval = ERROR_SUCCESS;
    WCHAR CacheDir[MAX_PATH];
    HANDLE h;
    USHORT Compression = COMPRESSION_FORMAT_DEFAULT;
    DWORD Attributes;
    BOOL b = FALSE;

    PWSTR RegData;
    DWORD Type,Length;
    HSPFILEQ hFileQ = INVALID_HANDLE_VALUE;
    PVOID Context;
    DWORD Count,i;

    if (MiniSetup) {
        retval = ERROR_SUCCESS;
        goto e0;
    }

    //
    // clean out old dllcache
    //
    CleanOutDllCache();

    //
    // Configure the registry for the DllCache.
    //
    ConfigureSystemFileProtection();

    //
    // get the path to the dllcache.
    //
    if ((retval = QueryValueInHKLM(
                        L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                        L"SFCDllCacheDir",
                        &Type,
                        (PVOID)&RegData,
                        &Length)) != NO_ERROR) {
        ExpandEnvironmentStrings(
                            L"%systemroot%\\system32\\dllcache",
                            CacheDir,
                            MAX_PATH );
    } else {
        ExpandEnvironmentStrings(
                            RegData,
                            CacheDir,
                            MAX_PATH );
        MyFree(RegData);
    }

    //
    // set attributes on dllcache (hidden, system, compressed...)
    //
    Attributes = GetFileAttributes(CacheDir);


    if (Attributes == 0xffffffff) {
        CreateDirectory( CacheDir, NULL );
        Attributes = GetFileAttributes(CacheDir);
    }

    if (!(Attributes & FILE_ATTRIBUTE_COMPRESSED)) {

        Attributes = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM;
        SetFileAttributes( CacheDir, FILE_ATTRIBUTE_NORMAL );

        h = CreateFile(
            CacheDir,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
            INVALID_HANDLE_VALUE
            );

        if (h == INVALID_HANDLE_VALUE) {
            SetFileAttributes( CacheDir, Attributes );
            retval = GetLastError();
            goto e0;
        }

        DeviceIoControl(
                h,
                FSCTL_SET_COMPRESSION,
                &Compression,
                sizeof(Compression),
                NULL,
                0,
                &retval,
                NULL
                );

        CloseHandle( h );
        SetFileAttributes( CacheDir, Attributes );

    }

    //
    // copy system catalogs into the dllcache
    //
    MYASSERT( SyssetupInf != NULL );

    hFileQ = SetupOpenFileQueue();
    if (hFileQ == INVALID_HANDLE_VALUE) {
        retval = GetLastError();
        goto e0;
    }

    Context = InitSysSetupQueueCallbackEx(
                                MainWindowHandle,
                                INVALID_HANDLE_VALUE,
                                0,
                                0,
                                NULL);
    if (!Context) {
        retval = GetLastError();
        goto e1;
    }

    Count = SetupGetLineCount( SyssetupInf, L"ProductCatalogsToInstall");
    for (i = 0; i < Count; i++) {

        INFCONTEXT InfContext;
        WCHAR CatalogName[MAX_PATH];
        BOOL SuccessfullyValidatedOrRestoredACatalog = FALSE;
        if(SetupGetLineByIndex(
                        SyssetupInf,
                        L"ProductCatalogsToInstall",
                        i,
                        &InfContext) &&
           (SetupGetStringField(
                        &InfContext,
                        1,
                        CatalogName,
                        sizeof(CatalogName)/sizeof(WCHAR),
                        NULL))) {
                if (!SetupQueueCopy(
                            hFileQ,
                            DuDoesUpdatedFileExist (CatalogName) ? DuGetUpdatesPath () : LegacySourcePath,
                            NULL,
                            CatalogName,
                            NULL,
                            NULL,
                            CacheDir,
                            NULL,
                            0
                            )) {
                retval = GetLastError();
                goto e2;
            }
        }
    }

    if (!SetupCommitFileQueue(
                MainWindowHandle,
                hFileQ,
                SysSetupQueueCallback,
                Context)) {
        retval = GetLastError();
        goto e2;
    }

    retval = ERROR_SUCCESS;

e2:
    TermSysSetupQueueCallback(Context);
e1:
    SetupCloseFileQueue( hFileQ );
e0:
    return(retval);
}

DWORD
SpUninstallCatalog(
    IN HCATADMIN CatAdminHandle OPTIONAL,
    IN PCWSTR CatFileName,
    IN PCWSTR CatFilePath OPTIONAL,
    IN PCWSTR AttributeName OPTIONAL,
    IN PCWSTR AttributeValue OPTIONAL,
    IN OUT PLIST_ENTRY InstalledCatalogsList OPTIONAL
    )
/*++

Routine Description:

    This function uninstalls the specified catalog based on a list of installed catalogs and a pair of attribute name/value.

Arguments:

    CatAdminHandle -        Handle to crypto context. If NULL, the function will open a context and close it upon exit.
    CatFileName -           Name of the catalog (without any path) to be uninstalled.
    CatFilePath -           If specified, specifies the path to CatFileName.
    AttributeName -         See AttributeValue.
    AttributeValue -        If AttributeName and AttributeValue are not specified, the catalog is always uninstalled. 
                            If AttributeName is specified and AttributeValue isn't, the catalog will be uninstalled only if it has an 
                            attribute with AttributeName name, regardess of its value. If AttributeName is not specified and AttributeValue is, 
                            the catalog will be uninstalled only if it has an attribute with AttributeValue value, regardless of its 
                            name. If both AttributeName and AttributeValue are specified, the catalog is uninstalled only if it 
                            has an attribute with AttributeName name and AttributeValue value.
    InstalledCatalogsList - If not NULL, contains the list of catalogs installed on the system. If the catalog is not on the list,
                            it is not uninstalled. If the catalog is on the list, it is uninstalled and removed from the list. If NULL, 
                            the catalog is always uninstalled.

Return value:

    NO_ERROR on success, otherwise a Win32 error code.

--*/
{
    DWORD dwError = NO_ERROR;
    HCATADMIN hCatAdmin = CatAdminHandle;
    PSTRING_LIST_ENTRY pEntry = NULL;

    if(NULL == CatFileName || 0 == CatFileName[0]) {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if(NULL == CatAdminHandle && !CryptCATAdminAcquireContext(&hCatAdmin, &DriverVerifyGuid, 0)) {
        dwError = GetLastError();
        goto exit;
    }

    if(NULL == InstalledCatalogsList || NULL != (pEntry = SearchStringInList(InstalledCatalogsList, CatFileName, FALSE))) {
        BOOL bFound;
        dwError = LookupCatalogAttribute(CatFileName, CatFilePath, AttributeName, AttributeValue, &bFound);

        if(dwError != ERROR_SUCCESS) {
            goto exit;
        }

        if(bFound) {
            if(CryptCATAdminRemoveCatalog(hCatAdmin, (PWCHAR) CatFileName, 0)) {
                if(pEntry != NULL) {
                    RemoveEntryList(&pEntry->Entry);
                    FreeStringEntry(&pEntry->Entry, TRUE);
                }
            } else {
                dwError = GetLastError();

                SetuplogError(
                    LogSevInformation,
                    SETUPLOG_USE_MESSAGEID,
                    MSG_LOG_SYSSETUP_CATALOG_NOT_DELETED,
                    CatFileName,
                    NULL,
                    NULL
                    );
            }
        }
    }

exit:
    if(NULL == CatAdminHandle && hCatAdmin != NULL) {
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    return dwError;
}

typedef struct _UNINSTALL_EXCEPPACK_CATALOG_CONTEXT {
    HCATADMIN CatAdminHandle;
} UNINSTALL_EXCEPPACK_CATALOG_CONTEXT, * PUNINSTALL_EXCEPPACK_CATALOG_CONTEXT;


BOOL
CALLBACK
SpUninstallExcepPackCatalogsCallback(
    IN const PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData,
    IN OUT DWORD_PTR Context
    )
/*++

Routine Description:

    This is the callback function for the SetupEnumerateRegisteredOsComponents call in SpUninstallExcepPackCatalogs.
    It uninstalls the catalog specified by SetupOsExceptionData->CatalogFileName.

Arguments:

    SetupOsComponentData - component data
    SetupOsExceptionData - exception pack data
    Context - pointer to an UNINSTALL_EXCEPPACK_CATALOG_CONTEXT struct

Return value:

    TRUE to continue the enumeration

--*/
{
    PUNINSTALL_EXCEPPACK_CATALOG_CONTEXT pContext;
    PCWSTR szCatName;

    ASSERT(Context != 0);
    pContext = (PUNINSTALL_EXCEPPACK_CATALOG_CONTEXT) Context;
    szCatName = wcsrchr(SetupOsExceptionData->CatalogFileName, L'\\');
    ASSERT(szCatName != NULL);

    if(szCatName != NULL) {
        DWORD dwError = SpUninstallCatalog(pContext->CatAdminHandle, szCatName + 1, NULL, NULL, NULL, NULL);

        if(dwError != NO_ERROR) {
            SetupDebugPrint1(L"SETUP: SpUninstallCatalog returned 0x%08x.", dwError);
        }
    }

    return TRUE;
}

VOID
SpUninstallExcepPackCatalogs(
    IN HCATADMIN CatAdminHandle OPTIONAL
    )
/*++

Routine Description:

    This function uninstalls all exception package catalogs.

Arguments:

    CatAdminHandle - a handle to crypto catalog admin; may be NULL

Return value:

    none

--*/
{
    UNINSTALL_EXCEPPACK_CATALOG_CONTEXT Context;
    Context.CatAdminHandle = CatAdminHandle;
    SetupEnumerateRegisteredOsComponents(SpUninstallExcepPackCatalogsCallback, (DWORD_PTR) &Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\crypto.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    crypto.c

Abstract:

    Module to install/upgrade cryptography (CAPI).

Author:

    Ted Miller (tedm) 4-Aug-1995

Revision History:

    Lonny McMichael (lonnym) 1-May-98  Added code to trust test root certificate.

--*/

#include "setupp.h"
#pragma hdrstop

//
// Default post-setup system policies for driver signing and non-driver signing
//
#define DEFAULT_DRVSIGN_POLICY    DRIVERSIGN_WARNING
#define DEFAULT_NONDRVSIGN_POLICY DRIVERSIGN_NONE


//
// Define name of default microsoft capi provider and signature file
//
#define MS_DEF_SIG   L"RSABASE.SIG"
#define MS_DEF_DLL   L"RSABASE.DLL"

#define MS_REG_KEY1  L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\" MS_DEF_PROV
#define MS_REG_KEY2  L"SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type 001"

//
// Items that get set up in registry for ms provider.
// Do not change the order of these without also changing the code in
// RsaSigToRegistry().
//
#if 0   // no longer needed

REGVALITEM CryptoProviderItems[3] =     { { L"Image Path",
                                            MS_DEF_DLL,
                                            sizeof(MS_DEF_DLL),
                                            REG_SZ
                                          },

                                          { L"Type",
                                            NULL,
                                            sizeof(DWORD),
                                            REG_DWORD
                                          },

                                          { L"Signature",
                                            NULL,
                                            0,
                                            REG_BINARY
                                          }
                                        };

REGVALITEM CryptoProviderTypeItems[1] = { { L"Name",
                                            MS_DEF_PROV,
                                            sizeof(MS_DEF_PROV),
                                            REG_SZ
                                          }
                                        };
#endif  // no longer needed


#if 0   // obsolete routine
DWORD
RsaSigToRegistry(
    VOID
    )

/*++

Routine Description:

    This routine transfers the contents of the rsa signature file
    (%systemroot%\system32\rsabase.sig) into the registry,
    then deletes the signature file.

Arguments:

    None.

Returns:

    Win32 error code indicating outcome.

--*/

{
    WCHAR SigFile[MAX_PATH];
    DWORD FileSize;
    HANDLE FileHandle;
    HANDLE MapHandle;
    DWORD d;
    PVOID p;
    DWORD One;

    //
    // Form name of signature file.
    //
    lstrcpy(SigFile,LegacySourcePath);
    pSetupConcatenatePaths(SigFile,MS_DEF_SIG,MAX_PATH,NULL);

    //
    // Open and map signature file.
    //
    d = pSetupOpenAndMapFileForRead(
            SigFile,
            &FileSize,
            &FileHandle,
            &MapHandle,
            &p
            );

    if(d == NO_ERROR) {

        //
        // Type gets set to 1.
        //
        One = 1;
        CryptoProviderItems[1].Data = &One;

        //
        // Set up binary data.
        //
        CryptoProviderItems[2].Data = p;
        CryptoProviderItems[2].Size = FileSize;

        //
        // Transfer data to registry. Gaurd w/try/except in case of
        // in-page errors.
        //
        try {
            d = (DWORD)SetGroupOfValues(HKEY_LOCAL_MACHINE,MS_REG_KEY1,CryptoProviderItems,3);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_READ_FAULT;
        }

        //
        // Set additional piece of registry data.
        //
        if(d == NO_ERROR) {

            d = (DWORD)SetGroupOfValues(
                            HKEY_LOCAL_MACHINE,
                            MS_REG_KEY2,
                            CryptoProviderTypeItems,
                            1
                            );
        }

        //
        // Clean up file mapping.
        //
        pSetupUnmapAndCloseFile(FileHandle,MapHandle,p);
    }

    return(d);
}
#endif  // obsolete routine


BOOL
InstallOrUpgradeCapi(
    VOID
    )
{
#if 1

    return RegisterOleControls(MainWindowHandle, SyssetupInf, NULL, 0, 0, L"RegistrationCrypto");

#else // obsolete code

    DWORD d;

    d = RsaSigToRegistry();

    if(d != NO_ERROR) {
        SetuplogError(
            LogSevError,
            SETUPLOG_USE_MESSAGEID,
            MSG_LOG_CRYPTO_1,
            d,NULL,NULL);
    }

    return(d == NO_ERROR);

#endif // obsolete code
}


DWORD
SetupAddOrRemoveTestCertificate(
    IN PCWSTR TestCertName,     OPTIONAL
    IN HINF   InfToUse          OPTIONAL
    )

/*++

Routine Description:

    This routine adds the test certificate into the root certificate store, or
    removes the test certificate from the root store.

Arguments:

    TestCertName - Optionally, supplies the name of the test certificate to be
        added.  If this parameter is not specified, then the test certificates
        (both old and new) will be removed from the root store, if they exist.

    InfToUse - Optionally, supplies the INF to be used in retrieving source
        media information for the test certificate.  If this parameter is not
        supplied (i.e., is NULL or INVALID_HANDLE_VALUE), then TestCertName is
        assumed to exist (a) in the platform-specific source path (if it's a
        simple filename) or (b) in the specified location (if it contains path
        information).

        This argument is ignored if TestCertName is NULL.

Returns:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    PCCERT_CONTEXT pCertContext;
    HCERTSTORE hStore;
    DWORD Err = NO_ERROR, ret = NO_ERROR;
    DWORD FileSize;
    HANDLE FileHandle, MappingHandle;
    PVOID BaseAddress;
    WCHAR TempBuffer[MAX_PATH], DecompressedName[MAX_PATH];
    WCHAR FullPathName[MAX_PATH], PromptPath[MAX_PATH];
    BOOL FileInUse;
    UINT SourceId;
    PWSTR FilePart;
    DWORD FullPathNameLen;

    if(TestCertName) {

        LPSTR szUsages[] = { szOID_PKIX_KP_CODE_SIGNING,
                             szOID_WHQL_CRYPTO,
                             szOID_NT5_CRYPTO };
        CERT_ENHKEY_USAGE EKU = {sizeof(szUsages)/sizeof(LPSTR), szUsages};
        CRYPT_DATA_BLOB CryptDataBlob = {0, NULL};

        //
        // The file may be compressed (i.e., testroot.ce_), so decompress it
        // into a temporary file in the windows directory.
        //
        if(!GetWindowsDirectory(TempBuffer, SIZECHARS(TempBuffer)) ||
           !GetTempFileName(TempBuffer, L"SETP", 0, DecompressedName)) {

            return GetLastError();
        }

        if(InfToUse && (InfToUse != INVALID_HANDLE_VALUE)) {
            //
            // We were passed a simple filename (e.g., "testroot.cer") which
            // exists in the platform-specific source path.
            //
            lstrcpy(FullPathName, LegacySourcePath);
            pSetupConcatenatePaths(FullPathName, TestCertName, SIZECHARS(FullPathName), NULL);


            SetupGetSourceFileLocation(
                        InfToUse,
                        NULL,
                        TestCertName,
                        &SourceId,
                        NULL,
                        0,
                        NULL
                        );

            SetupGetSourceInfo(
                        InfToUse,
                        SourceId,
                        SRCINFO_DESCRIPTION,
                        TempBuffer,
                        sizeof(TempBuffer)/sizeof(WCHAR),
                        NULL
                        );


            do{


                Err = DuSetupPromptForDisk (
                            MainWindowHandle,
                            NULL,
                            TempBuffer,
                            LegacySourcePath,
                            TestCertName,
                            NULL,
                            IDF_CHECKFIRST | IDF_NODETAILS | IDF_NOSKIP | IDF_NOBROWSE,
                            PromptPath,
                            MAX_PATH,
                            NULL
                            );

                if( Err == DPROMPT_SUCCESS ){

                    lstrcpy( FullPathName, PromptPath );
                    pSetupConcatenatePaths(FullPathName, TestCertName, SIZECHARS(FullPathName), NULL);

                    Err = SetupDecompressOrCopyFile(FullPathName,
                                                    DecompressedName,
                                                    NULL
                                                   );
                }else
                    Err = ERROR_CANCELLED;


            } while( Err == ERROR_NOT_READY );

        } else {
            //
            // If the filename is a simple filename, then assume it exists in
            // the platform-specific source path.  Otherwise, assume it is a
            // fully-qualified path.
            //
            if(TestCertName == pSetupGetFileTitle(TestCertName)) {

                if (BuildPathToInstallationFile (TestCertName, FullPathName, SIZECHARS(FullPathName))) {
                    Err = NO_ERROR;
                } else {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                }

            } else {
                //
                // The filename includes path information--look for the file in
                // the specified path.
                //
                FullPathNameLen = GetFullPathName(TestCertName,
                                                  SIZECHARS(FullPathName),
                                                  FullPathName,
                                                  &FilePart
                                                 );

                if(!FullPathNameLen) {
                    Err = GetLastError();
                } else if(FullPathNameLen > SIZECHARS(FullPathName)) {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    Err = NO_ERROR;
                }
            }

            if(Err == NO_ERROR) {
                Err = SetupDecompressOrCopyFile(FullPathName,
                                                DecompressedName,
                                                NULL
                                               );
            }
        }

        if(Err != NO_ERROR) {
            return Err;
        }


        //
        // Map the specified .cer file into memory
        //
        Err = pSetupOpenAndMapFileForRead(DecompressedName,
                                    &FileSize,
                                    &FileHandle,
                                    &MappingHandle,
                                    &BaseAddress
                                   );
        if(Err != NO_ERROR) {
            DeleteFile(DecompressedName);
            return Err;
        }

        //
        // Create a cert context from an encoded blob (what we read from the
        // .cer file)
        //
        pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    BaseAddress,
                                                    FileSize
                                                   );
        if(!pCertContext) {
            //
            // Get the last error before we potentially blow it away by
            // unmapping/closing our certificate file below...
            //
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        }

        //
        // We can unmap and close the test cert file now--we don't need it
        // anymore.
        //
        pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);
        DeleteFile(DecompressedName);

        if(!pCertContext) {
            goto clean0;
        }

        //
        // to open the root store in HKLM
        //
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                               X509_ASN_ENCODING,
                               (HCRYPTPROV)NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               L"ROOT"
                              );

        if(!hStore) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        } else {
            //
            // Call CryptEncodeObject once to get the size of buffer required...
            //
            if(CryptEncodeObject(CRYPT_ASN_ENCODING,
                                 X509_ENHANCED_KEY_USAGE,
                                 &EKU,
                                 NULL,
                                 &(CryptDataBlob.cbData))) {

                MYASSERT(CryptDataBlob.cbData);

                //
                // OK, now we can allocate a buffer of the required size and
                // try again.
                //
                CryptDataBlob.pbData = MyMalloc(CryptDataBlob.cbData);

                if(CryptDataBlob.pbData) {

                    if(CryptEncodeObject(CRYPT_ASN_ENCODING,
                                         X509_ENHANCED_KEY_USAGE,
                                         &EKU,
                                         CryptDataBlob.pbData,
                                         &(CryptDataBlob.cbData))) {
                        Err = NO_ERROR;

                    } else {
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        if(Err == NO_ERROR) {
                            Err = ERROR_INVALID_DATA;
                        }
                    }

                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                }

            } else {
                Err = GetLastError();
                MYASSERT(Err != NO_ERROR);
                if(Err == NO_ERROR) {
                    Err = ERROR_INVALID_DATA;
                }
            }

            if(Err == NO_ERROR) {
                if(!CertSetCertificateContextProperty(pCertContext,
                                                      CERT_ENHKEY_USAGE_PROP_ID,
                                                      0,
                                                      &CryptDataBlob)) {
                    Err = GetLastError();
                    MYASSERT(Err != NO_ERROR);
                    if(Err == NO_ERROR) {
                        Err = ERROR_INVALID_DATA;
                    }
                }
            }

            //
            // to add cert to store
            //
            if(Err == NO_ERROR) {
                if(!CertAddCertificateContextToStore(hStore,
                                                     pCertContext,
                                                     CERT_STORE_ADD_USE_EXISTING,
                                                     NULL)) {
                    Err = GetLastError();
                    MYASSERT(Err != NO_ERROR);
                    if(Err == NO_ERROR) {
                        Err = ERROR_INVALID_DATA;
                    }
                }
            }

            CertCloseStore(hStore, 0);
        }

        CertFreeCertificateContext(pCertContext);

        if(CryptDataBlob.pbData) {
            MyFree(CryptDataBlob.pbData);
        }

    } else {
        //
        // deleting a cert
        // to open the root store in HKLM
        //
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                               X509_ASN_ENCODING,
                               (HCRYPTPROV)NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               L"ROOT"
                              );
        if(!hStore) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_INVALID_DATA;
            }
        } else {
            //
            // test root(s) sha1 hash
            //
            DWORD i;
            BYTE arHashData[2][20] = { {0x30, 0x0B, 0x97, 0x1A, 0x74, 0xF9, 0x7E, 0x09, 0x8B, 0x67, 0xA4, 0xFC, 0xEB, 0xBB, 0xF6, 0xB9, 0xAE, 0x2F, 0x40, 0x4C},   // old beta testroot.cer (used until just prior to RC3)
                                       {0x2B, 0xD6, 0x3D, 0x28, 0xD7, 0xBC, 0xD0, 0xE2, 0x51, 0x19, 0x5A, 0xEB, 0x51, 0x92, 0x43, 0xC1, 0x31, 0x42, 0xEB, 0xC3} }; // current beta testroot.cer (also used for OEM testsigning)
            CRYPT_HASH_BLOB hash;

            hash.cbData = sizeof(arHashData[0]);

            for(i = 0; i < 2; i++) {

                hash.pbData = arHashData[i];

                pCertContext = CertFindCertificateInStore(hStore,
                                                          X509_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_HASH,
                                                          &hash,
                                                          NULL
                                                         );

                if(pCertContext) {
                    //
                    // We found the certificate, so we want to delete it.
                    //
                    if(!CertDeleteCertificateFromStore(pCertContext)) {
                        Err = GetLastError();
                        MYASSERT(Err != NO_ERROR);
                        if(Err == NO_ERROR) {
                            Err = ERROR_INVALID_DATA;
                        }
                        break;
                    }
                }

                //
                // do not free context--the delete did it (even if it failed).
                //
            }

            CertCloseStore(hStore, 0);
        }
    }

clean0:

    return Err;
}

VOID
pSetupGetRealSystemTime(
    OUT LPSYSTEMTIME RealSystemTime
    );

VOID
SetCodeSigningPolicy(
    IN  CODESIGNING_POLICY_TYPE PolicyType,
    IN  BYTE                    NewPolicy,
    OUT PBYTE                   OldPolicy  OPTIONAL
    )
/*++

Routine Description:

    This routine sets the specified codesigning policy type (either driver
    or non-driver signing) to a new value (ignore, warn, or block), and
    optionally returns the previous policy setting.

Arguments:

    PolicyType - specifies what policy is to be set.  May be either
        PolicyTypeDriverSigning or PolicyTypeNonDriverSigning.

    NewPolicy - specifies the new policy to be used.  May be DRIVERSIGN_NONE,
        DRIVERSIGN_WARNING, or DRIVERSIGN_BLOCKING.

    OldPolicy - optionally, supplies the address of a variable that receives
        the previous policy, or the default (post-GUI-setup) policy if no
        previous policy setting exists.  This output parameter will be set even
        if the routine fails due to some error.

Return Value:

    none

--*/
{
    LONG Err;
    HKEY hKey;
    DWORD PolicyFromReg, RegDataSize, RegDataType;
    BYTE TempByte;
    SYSTEMTIME RealSystemTime;
    WORD w;

    //
    // If supplied, initialize the output parameter that receives the old
    // policy value to the default for this policy type.
    //
    if(OldPolicy) {

        *OldPolicy = (PolicyType == PolicyTypeDriverSigning)
                         ? DEFAULT_DRVSIGN_POLICY
                         : DEFAULT_NONDRVSIGN_POLICY;

        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           (PolicyType == PolicyTypeDriverSigning
                               ? REGSTR_PATH_DRIVERSIGN
                               : REGSTR_PATH_NONDRIVERSIGN),
                           0,
                           KEY_READ,
                           &hKey
                          );

        if(Err == ERROR_SUCCESS) {

            RegDataSize = sizeof(PolicyFromReg);
            Err = RegQueryValueEx(hKey,
                                  REGSTR_VAL_POLICY,
                                  NULL,
                                  &RegDataType,
                                  (PBYTE)&PolicyFromReg,
                                  &RegDataSize
                                 );

            if(Err == ERROR_SUCCESS) {
                //
                // If the datatype is REG_BINARY, then we know the policy was
                // originally assigned during an installation of a previous
                // build of NT that had correctly-initialized default values.
                // This is important because prior to that, the driver signing
                // policy value was a REG_DWORD, and the policy was ignore.  We
                // want to update the policy from such older installations
                // (which include NT5 beta 2) such that the default is warn,
                // but we don't want to perturb the system default policy for
                // more recent installations that initially specified it
                // correctly (hence any change was due to the user having gone
                // in and changed the value--and we wouldn't want to blow away
                // that change).
                //
                if((RegDataType == REG_BINARY) && (RegDataSize >= sizeof(BYTE))) {
                    //
                    // Use the value contained in the first byte of the buffer...
                    //
                    TempByte = *((PBYTE)&PolicyFromReg);
                    //
                    // ...and make sure the value is valid.
                    //
                    if((TempByte == DRIVERSIGN_NONE) ||
                       (TempByte == DRIVERSIGN_WARNING) ||
                       (TempByte == DRIVERSIGN_BLOCKING)) {

                        *OldPolicy = TempByte;
                    }

                } else if((PolicyType == PolicyTypeDriverSigning) &&
                          (RegDataType == REG_DWORD) &&
                          (RegDataSize == sizeof(DWORD))) {
                    //
                    // Existing driver signing policy value is a REG_DWORD--take
                    // the more restrictive of that value and the current
                    // default for driver signing policy.
                    //
                    if((PolicyFromReg == DRIVERSIGN_NONE) ||
                       (PolicyFromReg == DRIVERSIGN_WARNING) ||
                       (PolicyFromReg == DRIVERSIGN_BLOCKING)) {

                        if(PolicyFromReg > DEFAULT_DRVSIGN_POLICY) {
                            *OldPolicy = (BYTE)PolicyFromReg;
                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    w = (PolicyType == PolicyTypeDriverSigning)?1:0;
    RealSystemTime.wDayOfWeek = (LOWORD(&hKey)&~4)|(w<<2);
    RealSystemTime.wMinute = LOWORD(PnpSeed);
    RealSystemTime.wYear = HIWORD(PnpSeed);
    RealSystemTime.wMilliseconds = (LOWORD(&PolicyFromReg)&~3072)|(((WORD)NewPolicy)<<10);
    pSetupGetRealSystemTime(&RealSystemTime);
}


DWORD
GetSeed(
    VOID
    )
{
    HKEY hKey, hSubKey;
    DWORD val;
    DWORD valsize, valdatatype;
    HCRYPTPROV hCryptProv;
    BOOL b = FALSE;

    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                       L"System\\WPA",
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_READ | KEY_WRITE,
                                       NULL,
                                       &hKey,
                                       NULL)) {

        if(ERROR_SUCCESS == RegCreateKeyEx(hKey,
                                           L"PnP",
                                           0,
                                           NULL,
                                           REG_OPTION_NON_VOLATILE,
                                           KEY_READ | KEY_WRITE,
                                           NULL,
                                           &hSubKey,
                                           NULL)) {

            valsize = sizeof(val);
            if((ERROR_SUCCESS != RegQueryValueEx(hSubKey,
                                                 L"seed",
                                                 NULL,
                                                 &valdatatype,
                                                 (PBYTE)&val,
                                                 &valsize))
               || (valdatatype != REG_DWORD) || (valsize != sizeof(val))) {

                if(CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {

                    if(CryptGenRandom(hCryptProv, sizeof(val), (PBYTE)&val)) {

                        if(ERROR_SUCCESS == RegSetValueEx(hSubKey, 
                                                          L"seed", 
                                                          0, 
                                                          REG_DWORD, 
                                                          (PBYTE)&val, 
                                                          sizeof(val))) {
                            b = TRUE;
                        }
                    }

                    CryptReleaseContext(hCryptProv, 0);
                }

            } else {
                b = TRUE;
            }

            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    return b ? val : 0;
}


DWORD
SetupInstallTrustedCertificate(
    IN PCWSTR CertPath
    )

/*++

Routine Description:

    This routine installs the specified certificate in the TrustedPublisher
    certificate store.

Arguments:

    CertPath - supplies the full path of the certificate file to be installed.

Returns:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    the failure.

--*/

{
    PCCERT_CONTEXT pCertContext;
    HCERTSTORE hStore;
    DWORD Err = NO_ERROR;
    DWORD FileSize;
    HANDLE FileHandle, MappingHandle;
    PVOID BaseAddress;

    //
    // Map the specified .cer file into memory
    //
    Err = pSetupOpenAndMapFileForRead(CertPath,
                                      &FileSize,
                                      &FileHandle,
                                      &MappingHandle,
                                      &BaseAddress
                                     );
    if(Err != NO_ERROR) {
        return Err;
    }

    //
    // Create a cert context from an encoded blob (what we read from the
    // .cer file)
    //
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                BaseAddress,
                                                FileSize
                                               );
    if(!pCertContext) {
        //
        // Get the last error before we potentially blow it away by
        // unmapping/closing our certificate file below...
        //
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_UNIDENTIFIED_ERROR;
        }
    }

    //
    // We can unmap and close the test cert file now--we don't need it
    // anymore.
    //
    pSetupUnmapAndCloseFile(FileHandle, MappingHandle, BaseAddress);

    if(!pCertContext) {
        return Err;
    }

    //
    // to open the root store in HKLM
    //
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                           0,
                           (HCRYPTPROV)NULL,
                           CERT_SYSTEM_STORE_LOCAL_MACHINE,
                           (const void *) L"TrustedPublisher"
                          );

    if(!hStore) {
        Err = GetLastError();
        MYASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_UNIDENTIFIED_ERROR;
        }
    } else {
        //
        // add cert to store
        //
        if(!CertAddCertificateContextToStore(hStore,
                                             pCertContext,
                                             CERT_STORE_ADD_USE_EXISTING,
                                             NULL)) {
            Err = GetLastError();
            MYASSERT(Err != NO_ERROR);
            if(Err == NO_ERROR) {
                Err = ERROR_UNIDENTIFIED_ERROR;
            }
        }

        CertCloseStore(hStore, 0);
    }

    CertFreeCertificateContext(pCertContext);

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\asrrest.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    asrrest.c

Abstract:

    This module contains the following ASR routine:
        AsrRestoreNonCriticalDisks{A|W}

    This routine is called in GUI mode ASR, to reconfigure
    the non-critical storage devices on the target machine.

Notes:

    Naming conventions:
        _AsrpXXX    private ASR Macros
        AsrpXXX     private ASR routines
        AsrXXX      Publically defined and documented routines

Author:

    Guhan Suriyanarayanan (guhans)  27-May-2000

Environment:

    User-mode only.

Revision History:
    
    27-May-2000 guhans  
        Moved AsrRestoreNonCriticalDisks and other restore-time 
        routines from asr.c to asrrest.c

    01-Jan-2000 guhans
        Initial implementation for AsrRestoreNonCriticalDisks
        in asr.c

--*/
#include "setupp.h"
#pragma hdrstop


#include <diskguid.h>   // GPT partition type guids
#include <mountmgr.h>   // mountmgr ioctls
#include <winasr.h>     // ASR public routines

#define THIS_MODULE 'R'
#include "asrpriv.h"    // Private ASR definitions and routines


//
// --------
// typedefs and constants used within this module
// --------
//
typedef enum _ASR_SORT_ORDER {
    SortByLength,
    SortByStartingOffset
} ASR_SORT_ORDER;


typedef struct _ASR_REGION_INFO {

    struct _ASR_REGION_INFO *pNext;
    
    LONGLONG    StartingOffset;
    LONGLONG    RegionLength;
    DWORD       Index;

} ASR_REGION_INFO, *PASR_REGION_INFO;

#define ASR_AUTO_EXTEND_MAX_FREE_SPACE_IGNORED (1024 * 1024 * 16)


//
// --------
// function implementations
// --------
//

LONGLONG
AsrpRoundUp(
    IN CONST LONGLONG Number,
    IN CONST LONGLONG Base
    )

/*++

Routine Description:

    Helper function to round-up a number to a multiple of a given base.

Arguments:

    Number - The number to be rounded up.

    Base - The base using which Number is to be rounded-up.

Return Value:

    The first multiple of Base that is greater than or equal to Number.

--*/

{
    if (Number % Base) {
        return (Number + Base - (Number % Base));
    }
    else {
        return Number;        // already a multiple of Base.
    }
}


VOID
AsrpCreatePartitionTable(
    IN OUT PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx,
    IN PASR_PTN_INFO_LIST pPtnInfoList,
    IN DWORD BytesPerSector
    )

/*++

Routine Description:

    This creates a partition table based on the partition information 
    (pPtnInfoList) passed in 

Arguments:

          // needed to convert between sector count and byte offset

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    DWORD index = 0,
        NumEntries = 0;

    PPARTITION_INFORMATION_EX currentPtn = NULL;
    PASR_PTN_INFO               pPtnInfo = NULL;

    MYASSERT(pDriveLayoutEx);
    if (!pDriveLayoutEx || !pPtnInfoList || !(pPtnInfoList->pOffsetHead)) {
        return;
    }

    if (PARTITION_STYLE_GPT == pDriveLayoutEx->PartitionStyle) {
        NumEntries = pDriveLayoutEx->Gpt.MaxPartitionCount;
    }
    else if (PARTITION_STYLE_MBR == pDriveLayoutEx->PartitionStyle) {
        NumEntries = pDriveLayoutEx->PartitionCount;
    }
    else {
        MYASSERT(0 && L"Unrecognised partitioning style (neither MBR nor GPT)");
        return;
    }

    //
    // Zero out the entire partition table first
    //
    for (index = 0; index < NumEntries; index++) {

        currentPtn = &(pDriveLayoutEx->PartitionEntry[index]);

        currentPtn->StartingOffset.QuadPart = 0;
        currentPtn->PartitionLength.QuadPart = 0;

    }

    //
    // Now go through each of the partitions in the list, and add their entry
    // to the partition table (at index = SlotIndex)
    //
    pPtnInfo = pPtnInfoList->pOffsetHead;

    while (pPtnInfo) {

        //
        // For GPT partitions, SlotIndex is 0-based without holes
        //
        currentPtn = &(pDriveLayoutEx->PartitionEntry[pPtnInfo->SlotIndex]);

        MYASSERT(0 == currentPtn->StartingOffset.QuadPart);        // this entry better be empty

        //
        // Convert the StartSector and SectorCount to BYTE-Offset and BYTE-Count ...
        //
        pPtnInfo->PartitionInfo.StartingOffset.QuadPart *= BytesPerSector;
        pPtnInfo->PartitionInfo.PartitionLength.QuadPart *= BytesPerSector;

        //
        // Copy the partition-information struct over
        //
        memcpy(currentPtn, &(pPtnInfo->PartitionInfo), sizeof(PARTITION_INFORMATION_EX));

        currentPtn->RewritePartition = TRUE;
        currentPtn->PartitionStyle = pDriveLayoutEx->PartitionStyle;

        pPtnInfo = pPtnInfo->pOffsetNext;
    }
}


//
//
//
ULONG64
AsrpStringToULong64(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    ULONG64 result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;

    if (!String) {
        return 0;
    }

    if (L'-' == *String) {  // But this is ULONG!
        negative = TRUE;
        String++;
    }

    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }

    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }

    if (negative) {
        result = 0 - result;
    }

    return result;
}


LONGLONG
AsrpStringToLongLong(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    LONGLONG result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;

    if (!String) {
        return 0;
    }

    if (L'-' == *String) {
        negative = TRUE;
        String++;
    }

    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }

    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }

    if (negative) {
        result = 0 - result;
    }

    return result;
}


DWORD
AsrpStringToDword(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    DWORD result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;
    if (!String) {
        return 0;
    }
    if (L'-' == *String) {  // but this is unsigned!
        negative = TRUE;
        String++;
    }
    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }
    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }
    if (negative) {
        result = 0 - result;
    }
    return result;
}


ULONG
AsrpStringToULong(
    IN PWSTR String
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    ULONG result = 0, base = 10;
    BOOL negative = FALSE, done = FALSE;
    if (!String) {
        return 0;
    }
    if (L'-' == *String) {  // but this is unsigned!
        negative = TRUE;
        String++;
    }
    if (L'0' == *String &&
        (L'x' ==  *(String + 1) || L'X' == *(String + 1))
        ) {
        // Hex
        base = 16;
        String += 2;
    }
    while (!done) {
        done = TRUE;

        if (L'0' <= *String && L'9' >= *String) {
            result = result*base + (*String - L'0');
            String++;
            done = FALSE;
        }
        else if (16==base) {
            if (L'a' <= *String && L'f' >= *String) {
                result = result*base + (*String - L'a') + 10;
                String++;
                done = FALSE;

            }
            else if (L'A' <= *String && L'F' >= *String) {
                result = result*base + (*String - L'A') + 10;
                String++;
                done = FALSE;
            }
        }
    }
    if (negative) {
        result = 0 - result;
    }
    return result;
}


VOID
AsrpInsertSortedPartitionLengthOrder(
    IN PASR_PTN_INFO_LIST pPtnInfoList,
    IN PASR_PTN_INFO    pPtnInfo
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    PASR_PTN_INFO pPreviousPtn = NULL,
        pCurrentPtn = NULL;


    //
    // Insert this in the sorted PartitionLength order ...
    //
    pCurrentPtn = pPtnInfoList->pLengthHead;
    if (!pCurrentPtn) {
        //
        // First item in the list
        //
        pPtnInfoList->pLengthHead = pPtnInfo;
        pPtnInfoList->pLengthTail = pPtnInfo;
    }
    else {

        while (pCurrentPtn) {

             if (pCurrentPtn->PartitionInfo.PartitionLength.QuadPart
                <= pPtnInfo->PartitionInfo.PartitionLength.QuadPart) {

                pPreviousPtn = pCurrentPtn;
                pCurrentPtn = pCurrentPtn->pLengthNext;
            }

            else {
                //
                // We found the spot, let's add it in.
                //
                if (!pPreviousPtn) {
                    //
                    // This is the first node
                    //
                    pPtnInfoList->pLengthHead = pPtnInfo;
                }
                else {
                    pPreviousPtn->pLengthNext = pPtnInfo;
                }
                pPtnInfo->pLengthNext = pCurrentPtn;
                break;
            }

        }

        if (!pCurrentPtn) {
            //
            // We reached the end and didn't add this node in.
            //
            MYASSERT(pPtnInfoList->pLengthTail == pPreviousPtn);
            pPtnInfoList->pLengthTail = pPtnInfo;
            pPreviousPtn->pLengthNext = pPtnInfo;
        }
    }
}


VOID
AsrpInsertSortedPartitionStartOrder(
    IN PASR_PTN_INFO_LIST pPtnInfoList,
    IN PASR_PTN_INFO    pPtnInfo
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    None
   
--*/

{

    PASR_PTN_INFO pPreviousPtn = NULL,
        pCurrentPtn = NULL;


    //
    // Insert this in the sorted Start-Sector order ...
    //
    pCurrentPtn = pPtnInfoList->pOffsetHead;
    if (!pCurrentPtn) {
        //
        // First item in the list
        //
        pPtnInfoList->pOffsetHead = pPtnInfo;
        pPtnInfoList->pOffsetTail = pPtnInfo;
    }
    else {

        while (pCurrentPtn) {

             if (pCurrentPtn->PartitionInfo.StartingOffset.QuadPart
                <= pPtnInfo->PartitionInfo.StartingOffset.QuadPart) {

                pPreviousPtn = pCurrentPtn;
                pCurrentPtn = pCurrentPtn->pOffsetNext;
            }

            else {
                //
                // We found the spot, let's add it in.
                //
                if (!pPreviousPtn) {
                    //
                    // This is the first node
                    //
                    pPtnInfoList->pOffsetHead = pPtnInfo;
                }
                else {
                    pPreviousPtn->pOffsetNext = pPtnInfo;
                }
                pPtnInfo->pOffsetNext = pCurrentPtn;
                break;
            }

        }

        if (!pCurrentPtn) {
            //
            // We reached the end and didn't add this node in.
            //
            MYASSERT(pPtnInfoList->pOffsetTail == pPreviousPtn);
            pPtnInfoList->pOffsetTail = pPtnInfo;
            pPreviousPtn->pOffsetNext = pPtnInfo;
        }
    }
}


//
// Build the original MBR disk info from the sif file
//
BOOL
AsrpBuildMbrSifDiskList(
    IN  PCWSTR              sifPath,
    OUT PASR_DISK_INFO      *ppSifDiskList,
    OUT PASR_PTN_INFO_LIST  *ppSifMbrPtnList,
    OUT BOOL                *lpAutoExtend
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    HINF hSif = NULL;
    
    INFCONTEXT infSystemContext,
        infDiskContext,
        infBusContext,
        infPtnContext;

    BOOL result = FALSE;

    DWORD reqdSize = 0,
        diskCount = 0,
        status = ERROR_SUCCESS;

    INT tempInt = 0;

    UINT errorLine = 0;

    PASR_DISK_INFO pNewSifDisk = NULL,
        currentDisk = NULL;
    
    PASR_PTN_INFO_LIST pMbrPtnList = NULL;
    
    PASR_PTN_INFO pPtnInfo = NULL;
    
    HANDLE  heapHandle = GetProcessHeap();

    WCHAR tempBuffer[ASR_SIF_ENTRY_MAX_CHARS + 1];

    ZeroMemory(&infSystemContext, sizeof(INFCONTEXT));
    ZeroMemory(&infDiskContext, sizeof(INFCONTEXT));
    ZeroMemory(&infBusContext, sizeof(INFCONTEXT));
    ZeroMemory(&infPtnContext, sizeof(INFCONTEXT));
    ZeroMemory(tempBuffer, sizeof(WCHAR)*(ASR_SIF_ENTRY_MAX_CHARS+1));

    //    *ppSifDiskList = NULL;

    //
    // Open the sif
    //
    hSif = SetupOpenInfFileW(sifPath, NULL, INF_STYLE_WIN4, &errorLine);
    if (NULL == hSif || INVALID_HANDLE_VALUE == hSif) {

        AsrpPrintDbgMsg(_asrerror, 
            "The ASR state file \"%ws\" could not be opened.  Error:%lu.  Line: %lu.\r\n",
            sifPath,
            GetLastError(), 
            errorLine
            );
        
        return FALSE;       // sif file couldn't be opened
    }

    *lpAutoExtend = TRUE; // enable by default
    //
    // Get the AutoExtend value
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_SYSTEM_SECTION, NULL, &infSystemContext);
    if (!result) {

        AsrpPrintDbgMsg(_asrerror, 
            "The ASR state file \"%ws\" is corrupt (section %ws not be found).\r\n",
            sifPath,
            ASR_SIF_SYSTEM_SECTION
            );
        
        return FALSE;        // no system section
    }
    result = SetupGetIntField(&infSystemContext, 5, (PINT) (lpAutoExtend));
    if (!result) {
        *lpAutoExtend = TRUE;        // TRUE by default
    }

    result = SetupFindFirstLineW(hSif, ASR_SIF_MBR_DISKS_SECTION, NULL, &infDiskContext);
    if (!result) {

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming no MBR disks.\r\n", 
            ASR_SIF_MBR_DISKS_SECTION
            );

        return TRUE;        // no mbr disks section
    }

    //
    // First, we go through the [DISKS.MBR] section.  At the end of this loop,
    // we'll have a list of all MBR sif-disks.  (*ppSifDiskList will point to
    // a linked list of ASR_DISK_INFO's, one for each disk).
    //
    do {
        ++diskCount;
        //
        // Create a new sif disk for this entry
        //
        pNewSifDisk = (PASR_DISK_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_DISK_INFO)
            );
        _AsrpErrExitCode(!pNewSifDisk, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pNext = *ppSifDiskList;
        *ppSifDiskList = pNewSifDisk;

        //
        // Now fill in the fields in the struct.  Since we zeroed the struct while
        // allocating mem, all pointers in the struct are NULL by default, and
        // all flags in the struct are FALSE.
        //
        pNewSifDisk->pDiskGeometry = (PDISK_GEOMETRY) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(DISK_GEOMETRY)
            );
        _AsrpErrExitCode(!pNewSifDisk->pDiskGeometry, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pPartition0Ex = (PPARTITION_INFORMATION_EX) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(PARTITION_INFORMATION_EX)
            );
        _AsrpErrExitCode(!pNewSifDisk->pPartition0Ex, status, ERROR_NOT_ENOUGH_MEMORY);

        // This is an MBR disk
        pNewSifDisk->Style = PARTITION_STYLE_MBR;

        //
        // Index 0 is the key to the left of the = sign
        //
        result = SetupGetIntField(&infDiskContext, 0, (PINT) &(pNewSifDisk->SifDiskKey));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        //
        // Index 1 is the system key, it must be 1.  We ignore it.
        // Index 2 - 6 are the bus key, critical flag, signature,
        //      bytes-per-sector, sector-count
        //
        result = SetupGetIntField(&infDiskContext, 2, (PINT) &(pNewSifDisk->SifBusKey));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infDiskContext, 3, (PINT) &(tempInt));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->IsCritical = (tempInt ? TRUE: FALSE);

        result = SetupGetStringFieldW(&infDiskContext, 4, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        
        pNewSifDisk->TempSignature = AsrpStringToDword(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 5, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        
        pNewSifDisk->pDiskGeometry->BytesPerSector = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 6, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pDiskGeometry->SectorsPerTrack = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 7, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pDiskGeometry->TracksPerCylinder = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 8, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

        // convert from sector count to byte count
        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart *= pNewSifDisk->pDiskGeometry->BytesPerSector;

        //
        // Get the bus-type related to this disk.  LineByIndex is 0 based, our bus key is 1-based.
        //
        result = SetupGetLineByIndexW(hSif, ASR_SIF_BUSES_SECTION, pNewSifDisk->SifBusKey - 1, &infBusContext);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infBusContext, 2, (PINT) &(pNewSifDisk->BusType));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupFindNextLine(&infDiskContext, &infDiskContext);

    } while (result);


    AsrpPrintDbgMsg(_asrinfo, 
        "Found %lu records in section [%ws].\r\n", 
        diskCount,
        ASR_SIF_MBR_DISKS_SECTION
        );

    //
    // Now, enumerate all the [PARTITIONS.MBR] section.  This will give us a list
    // of all the partitions (all) the MBR disks contained.
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_MBR_PARTITIONS_SECTION, NULL, &infPtnContext);
    if (result) {

        DWORD   diskKey = 0;
        //
        // Init the table of partion lists.
        //
        pMbrPtnList = (PASR_PTN_INFO_LIST) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_PTN_INFO_LIST) * (diskCount + 1)
            );
        _AsrpErrExitCode(!pMbrPtnList, status, ERROR_NOT_ENOUGH_MEMORY);

        // hack.
        // The 0'th entry of our table is not used, since the disk indices
        // begin with 1.  Since we have no other way of keeping track of
        // how big this table is (so that we can free it properly), we can
        // use the 0th entry to store this.
        //
        pMbrPtnList[0].numTotalPtns = diskCount + 1;       // size of table

        do {

            pPtnInfo = (PASR_PTN_INFO) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(ASR_PTN_INFO)
                );
            _AsrpErrExitCode(!pPtnInfo, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            //  Read in the information.  The format of this section is:
            //
            //  [PARTITIONS.MBR]
            //  0.partition-key = 1.disk-key, 2.slot-index, 3.boot-sys-flag,
            //                  4."volume-guid", 5.active-flag, 6.partition-type,
            //                  7.file-system-type, 8.start-sector, 9.sector-count
            //
            result = SetupGetIntField(&infPtnContext, 1, &diskKey);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 2, (PINT) &(pPtnInfo->SlotIndex));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 3, (PINT) &(pPtnInfo->PartitionFlags));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetStringFieldW(&infPtnContext, 4, pPtnInfo->szVolumeGuid, ASR_CCH_MAX_VOLUME_GUID, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 5, (PINT) &tempInt);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.Mbr.BootIndicator = (tempInt ? TRUE: FALSE);

                // converting from int to uchar
            result = SetupGetIntField(&infPtnContext, 6, (PINT) &(pPtnInfo->PartitionInfo.Mbr.PartitionType));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 7, (PINT) &(pPtnInfo->FileSystemType));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            //
            // Note, we read in the start SECTOR and SECTOR count.  We'll convert these to
            // their byte values later (in AsrpCreatePartitionTable)
            //
            result = SetupGetStringFieldW(&infPtnContext, 8, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.StartingOffset.QuadPart = AsrpStringToLongLong(tempBuffer);

            result = SetupGetStringFieldW(&infPtnContext, 9, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

            //
            // Add this in the sorted starting-offset order.
            //
            AsrpInsertSortedPartitionStartOrder(&(pMbrPtnList[diskKey]), pPtnInfo);

            //
            // Add this in the sorted partition length order as well.  This isn't really used for
            // MBR disks at present, only for GPT disks.
            //
            AsrpInsertSortedPartitionLengthOrder(&(pMbrPtnList[diskKey]), pPtnInfo);

            (pMbrPtnList[diskKey].numTotalPtns)++;

            if (IsContainerPartition(pPtnInfo->PartitionInfo.Mbr.PartitionType)) {
                (pMbrPtnList[diskKey].numExtendedPtns)++;
            }

            result = SetupFindNextLine(&infPtnContext, &infPtnContext);

        } while (result);

        //
        // Now, we have the table of all the MBR partition lists, and a list of
        // all MBR disks.  The next step is to "assign" the partitions to their respective
        // disks--and update the DriveLayoutEx struct for the disks.
        //
        currentDisk = *(ppSifDiskList);

        while (currentDisk) {
            DWORD           PartitionCount  = 0,
                            count           = 0;

            if (PARTITION_STYLE_MBR != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }

            PartitionCount = ((pMbrPtnList[currentDisk->SifDiskKey].numExtendedPtns) * 4) + 4;
            currentDisk->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX)*(PartitionCount-1));

            currentDisk->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                currentDisk->sizeDriveLayoutEx
                );
            _AsrpErrExitCode(!currentDisk->pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            // Initialise the DriveLayout struct.
            //
            currentDisk->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
            currentDisk->pDriveLayoutEx->PartitionCount = PartitionCount;
            currentDisk->pDriveLayoutEx->Mbr.Signature = currentDisk->TempSignature;

            AsrpCreatePartitionTable(currentDisk->pDriveLayoutEx,
                &(pMbrPtnList[currentDisk->SifDiskKey]),
                currentDisk->pDiskGeometry->BytesPerSector
                );

            currentDisk = currentDisk->pNext;
        }
    }
    else {

        DWORD count = 0;

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming MBR disks have no partitions.\r\n", 
            ASR_SIF_MBR_PARTITIONS_SECTION
            );

        //
        // The partitions section is empty.  Initialise each disk's drive layout
        // accordingly
        //
        currentDisk = *ppSifDiskList;

        while (currentDisk) {

            if (PARTITION_STYLE_MBR != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }

            currentDisk->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * 3);
            currentDisk->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                currentDisk->sizeDriveLayoutEx
                );
            _AsrpErrExitCode(!currentDisk->pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

            currentDisk->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;
            currentDisk->pDriveLayoutEx->PartitionCount = 4;
            currentDisk->pDriveLayoutEx->Mbr.Signature = currentDisk->TempSignature;

            for (count = 0; count < currentDisk->pDriveLayoutEx->PartitionCount ; count++) {
                currentDisk->pDriveLayoutEx->PartitionEntry[count].PartitionStyle = PARTITION_STYLE_MBR;
                currentDisk->pDriveLayoutEx->PartitionEntry[count].RewritePartition = TRUE;

            }

            currentDisk = currentDisk->pNext;
        }
    }

EXIT:

    *ppSifMbrPtnList = pMbrPtnList;

    if ((hSif) && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
        hSif = NULL;
    }

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Build the original disk info for GPT disks from the sif file
//
BOOL
AsrpBuildGptSifDiskList(
    IN  PCWSTR              sifPath,
    OUT PASR_DISK_INFO      *ppSifDiskList,
    OUT PASR_PTN_INFO_LIST  *ppSifGptPtnList
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    HINF hSif = NULL;

    BOOL result = FALSE;

    DWORD reqdSize = 0,
        diskCount = 0,
        status = ERROR_SUCCESS;

    INFCONTEXT infDiskContext,
        infBusContext,
        infPtnContext;

    INT tempInt = 0;

    UINT errorLine = 0;

    PASR_DISK_INFO pNewSifDisk = NULL,
        currentDisk = NULL;

    HANDLE heapHandle = NULL;

    PASR_PTN_INFO pPtnInfo = NULL;

    RPC_STATUS rpcStatus = RPC_S_OK;

    PASR_PTN_INFO_LIST pGptPtnList = NULL;

    WCHAR tempBuffer[ASR_SIF_ENTRY_MAX_CHARS+1];

    heapHandle = GetProcessHeap();

    ZeroMemory(&infDiskContext, sizeof(INFCONTEXT));
    ZeroMemory(&infBusContext, sizeof(INFCONTEXT));
    ZeroMemory(&infPtnContext, sizeof(INFCONTEXT));
    ZeroMemory(tempBuffer, sizeof(WCHAR)*(ASR_SIF_ENTRY_MAX_CHARS+1));

    //
    // Open the sif
    //
    hSif = SetupOpenInfFileW(sifPath, NULL, INF_STYLE_WIN4, &errorLine);
    if (NULL == hSif || INVALID_HANDLE_VALUE == hSif) {
        
        AsrpPrintDbgMsg(_asrerror, 
            "The ASR state file \"%ws\" could not be opened.  Error:%lu.  Line: %lu.\r\n",
            sifPath,
            GetLastError(), 
            errorLine
            );

        return FALSE;       // sif file couldn't be opened
    }

    result = SetupFindFirstLineW(hSif, ASR_SIF_GPT_DISKS_SECTION, NULL, &infDiskContext);
    if (!result) {

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming no GPT disks.\r\n", 
            ASR_SIF_GPT_DISKS_SECTION
            );

        return TRUE;        // no disks section
    }

    //
    // First, we go through the [DISKS.GPT] section.  At the end of this loop,
    // we'll have a list of all GPT sif-disks.  (*ppSifDiskList will point to
    // a linked list of ASR_DISK_INFO's, one for each disk).
    //
    do {

        ++diskCount;

        //
        // Create a new sif disk for this entry
        //
        pNewSifDisk = (PASR_DISK_INFO) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_DISK_INFO)
            );
        _AsrpErrExitCode(!pNewSifDisk, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pNext = *ppSifDiskList;
        *ppSifDiskList = pNewSifDisk;

        //
        // Now fill in the fields in the struct.  Since we zeroed the struct while
        // allocating mem, all pointers in the struct are NULL by default, and
        // all flags in the struct are FALSE.
        //
        pNewSifDisk->pDiskGeometry = (PDISK_GEOMETRY) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(DISK_GEOMETRY)
            );
        _AsrpErrExitCode(!pNewSifDisk->pDiskGeometry, status, ERROR_NOT_ENOUGH_MEMORY);

        pNewSifDisk->pPartition0Ex = (PPARTITION_INFORMATION_EX) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(PARTITION_INFORMATION_EX)
            );
        _AsrpErrExitCode(!pNewSifDisk->pPartition0Ex, status, ERROR_NOT_ENOUGH_MEMORY);

        // This is a GPT disk
        pNewSifDisk->Style = PARTITION_STYLE_GPT;

        //
        // Index 0 is the key to the left of the = sign
        //
        result = SetupGetIntField(&infDiskContext, 0, (PINT) &(pNewSifDisk->SifDiskKey));
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        //
        // Index 1 is the system key, it must be 1.  We ignore it.
        // Index 2 - 7 are:
        //  2: bus key
        //  3: critical flag
        //  4: disk-guid
        //  5: max-partition-count
        //  6: bytes-per-sector
        //  7: sector-count
        //
        result = SetupGetIntField(&infDiskContext, 2, (PINT) &(pNewSifDisk->SifBusKey)); // BusKey
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infDiskContext, 3, (PINT) &(tempInt));                // IsCritical
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->IsCritical = (tempInt ? TRUE: FALSE);

        result = SetupGetStringFieldW(&infDiskContext, 4, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize); // DiskGuid
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infDiskContext, 5, (PINT) &(tempInt));    // MaxPartitionCount
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        //
        //  Allocate a drive layout struct, now that we know the max partition count
        //
        pNewSifDisk->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX)*(tempInt-1));

        pNewSifDisk->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            pNewSifDisk->sizeDriveLayoutEx
            );
        _AsrpErrExitCode(!pNewSifDisk->pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

        // This is a GPT disk
        pNewSifDisk->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_GPT;

        //
        // Set the MaxPartitionCount and DiskGuid fields
        //
        pNewSifDisk->pDriveLayoutEx->Gpt.MaxPartitionCount = tempInt;
        rpcStatus = UuidFromStringW(tempBuffer, &(pNewSifDisk->pDriveLayoutEx->Gpt.DiskId));
        _AsrpErrExitCode((RPC_S_OK != rpcStatus), status, rpcStatus);


        result = SetupGetStringFieldW(&infDiskContext, 6, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        pNewSifDisk->pDiskGeometry->BytesPerSector = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 7, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        pNewSifDisk->pDiskGeometry->SectorsPerTrack = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 8, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        pNewSifDisk->pDiskGeometry->TracksPerCylinder = AsrpStringToULong(tempBuffer);

        result = SetupGetStringFieldW(&infDiskContext, 9, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

        // convert from sector count to byte count
        pNewSifDisk->pPartition0Ex->PartitionLength.QuadPart *= pNewSifDisk->pDiskGeometry->BytesPerSector; // TotalBytes

        //
        // Get the bus-type related to this disk.  LineByIndex is 0 based, our bus key is 1-based.
        //
        result = SetupGetLineByIndexW(hSif, ASR_SIF_BUSES_SECTION, pNewSifDisk->SifBusKey - 1, &infBusContext);
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupGetIntField(&infBusContext, 2, (PINT) &(pNewSifDisk->BusType)); // bus type
        _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

        result = SetupFindNextLine(&infDiskContext, &infDiskContext);

    } while(result);

    AsrpPrintDbgMsg(_asrinfo, 
        "Found %lu records in section [%ws].\r\n", 
        diskCount,
        ASR_SIF_MBR_DISKS_SECTION
        );


    //
    // Now, enumerate all the [PARTITIONS.GPT] section.  This will give us a list
    // of all the partitions (all) the GPT disks contained.
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_GPT_PARTITIONS_SECTION, NULL, &infPtnContext);
    if (result) {
        DWORD   diskKey = 0;
        //
        // Init the table of partion lists.
        //
        pGptPtnList = (PASR_PTN_INFO_LIST) HeapAlloc(
            heapHandle,
            HEAP_ZERO_MEMORY,
            sizeof(ASR_PTN_INFO_LIST) * (diskCount + 1)
            );
        _AsrpErrExitCode(!pGptPtnList, status, ERROR_NOT_ENOUGH_MEMORY);

        // hack.
        // The 0'th entry of our table is not used, since the disk indices
        // begin with 1.  Since we have no other way of keeping track of
        // how big this table is (so that we can free it properly), we can
        // use the 0th entry to store this.
        //
        pGptPtnList[0].numTotalPtns = diskCount + 1;       // size of table

        do {

            pPtnInfo = (PASR_PTN_INFO) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(ASR_PTN_INFO)
                );
            _AsrpErrExitCode(!pPtnInfo, status, ERROR_NOT_ENOUGH_MEMORY);
            //
            // This is a GPT partition
            //
            pPtnInfo->PartitionInfo.PartitionStyle = PARTITION_STYLE_GPT;

            //
            // Read in the values.  The format of this section is:
            //
            // [PARTITIONS.GPT]
            // 0.partition-key = 1.disk-key, 2.slot-index, 3.boot-sys-flag,
            //      4."volume-guid", 5."partition-type-guid", 6."partition-id-guid"
            //      7.gpt-attributes, 8."partition-name", 9.file-system-type,
            //      10.start-sector, 11.sector-count
            //
            result = SetupGetIntField(&infPtnContext, 1, &diskKey);  // 1. disk-key
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 2, (PINT) &(pPtnInfo->SlotIndex));     // 2. slot-index
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 3, (PINT) &(pPtnInfo->PartitionFlags));   // 3. boot-sys-flag
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetStringFieldW(&infPtnContext, 4, pPtnInfo->szVolumeGuid, ASR_CCH_MAX_VOLUME_GUID, &reqdSize); // volume-guid
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetStringFieldW(&infPtnContext, 5, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS + 1, &reqdSize);   // partition-type-guid
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            rpcStatus = UuidFromStringW(tempBuffer, &(pPtnInfo->PartitionInfo.Gpt.PartitionType));
            _AsrpErrExitCode((RPC_S_OK != rpcStatus), status, rpcStatus);

            result = SetupGetStringFieldW(&infPtnContext, 6, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS + 1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            rpcStatus = UuidFromStringW(tempBuffer, &(pPtnInfo->PartitionInfo.Gpt.PartitionId));
            _AsrpErrExitCode((RPC_S_OK != rpcStatus), status, rpcStatus);

            //
            // Note, we read in the start SECTOR and SECTOR count.  We'll convert these to
            // their byte values later (in AsrpCreatePartitionTable)
            //
            result = SetupGetStringFieldW(&infPtnContext, 7, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            pPtnInfo->PartitionInfo.Gpt.Attributes = AsrpStringToULong64(tempBuffer);

            result = SetupGetStringFieldW(&infPtnContext, 8,  pPtnInfo->PartitionInfo.Gpt.Name, 36, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            result = SetupGetIntField(&infPtnContext, 9, (PINT) &(pPtnInfo->FileSystemType));
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

            //
            // Note, we read in the start SECTOR and SECTOR count.  We'll convert it to the
            // BYTE offset and BYTE length later (in AsrpCreatePartitionTable)
            //
            result = SetupGetStringFieldW(&infPtnContext, 10, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
            pPtnInfo->PartitionInfo.StartingOffset.QuadPart = AsrpStringToLongLong(tempBuffer);

            result = SetupGetStringFieldW(&infPtnContext, 11, tempBuffer, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
            _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?
            pPtnInfo->PartitionInfo.PartitionLength.QuadPart = AsrpStringToLongLong(tempBuffer);

            //
            // Add this in the sorted partition starting-offset order.
            //
            AsrpInsertSortedPartitionStartOrder(&(pGptPtnList[diskKey]), pPtnInfo);

            //
            // Add this in the sorted partition length order as well.  This is useful
            // later when we try to fit in the partitions on the disk.
            //
            AsrpInsertSortedPartitionLengthOrder(&(pGptPtnList[diskKey]), pPtnInfo);

            (pGptPtnList[diskKey].numTotalPtns)++;

            result = SetupFindNextLine(&infPtnContext, &infPtnContext);

        } while (result);

        //
        // Now, we have the table of all the partition lists, and a list of
        // all disks.  The next task is to update the DriveLayoutEx struct for
        // the disks.
        //
        currentDisk = *(ppSifDiskList);

        while (currentDisk) {

            if (PARTITION_STYLE_GPT != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }
            //
            // Initialise the DriveLayoutEx struct.
            //
            currentDisk->pDriveLayoutEx->PartitionCount = pGptPtnList[currentDisk->SifDiskKey].numTotalPtns;

            AsrpCreatePartitionTable(currentDisk->pDriveLayoutEx,
                &(pGptPtnList[currentDisk->SifDiskKey]),
                currentDisk->pDiskGeometry->BytesPerSector
                );

            currentDisk = currentDisk->pNext;
        }
    }
    else {

        DWORD count = 0;

        AsrpPrintDbgMsg(_asrinfo, 
            "Section [%ws] is empty.  Assuming GPT disks have no partitions.\r\n", 
            ASR_SIF_GPT_PARTITIONS_SECTION
            );

        //
        // The partitions section is empty.  Initialise each disk's drive layout
        // accordingly
        //
        currentDisk = *ppSifDiskList;

        while (currentDisk) {

            if (PARTITION_STYLE_GPT != currentDisk->Style) {
                currentDisk = currentDisk->pNext;
                continue;
            }

            currentDisk->pDriveLayoutEx->PartitionCount = 0;

            for (count = 0; count < currentDisk->pDriveLayoutEx->Gpt.MaxPartitionCount ; count++) {
                currentDisk->pDriveLayoutEx->PartitionEntry[count].PartitionStyle = PARTITION_STYLE_GPT;
                currentDisk->pDriveLayoutEx->PartitionEntry[count].RewritePartition = TRUE;

            }
            currentDisk = currentDisk->pNext;
        }
    }

EXIT:

    *ppSifGptPtnList = pGptPtnList;

    if ((hSif) && (INVALID_HANDLE_VALUE != hSif)) {
        SetupCloseInfFile(hSif);
        hSif = NULL;
    }

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Returns
//  TRUE    if pSifDisk and pPhysicalDisk have the exact same partition layout,
//  FALSE   otherwise
//
BOOL
AsrpIsDiskIntact(
    IN PASR_DISK_INFO pSifDisk,
    IN PASR_DISK_INFO pPhysicalDisk
    ) 

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    ULONG index = 0,
        physicalIndex = 0;
    PPARTITION_INFORMATION_EX pSifPtnEx = NULL,
        pPhysicalPtnEx = NULL;

    if (pSifDisk->Style != pPhysicalDisk->Style) {
        return FALSE;           // different partitioning styles
    }

    if (PARTITION_STYLE_MBR == pSifDisk->Style) {
        //
        // For MBR disks, we expect to find the same number of partitions,
        // and the starting-offset and partition-length for each of those
        // partitions must be the same as they were in the sif
        //
        if (pSifDisk->pDriveLayoutEx->Mbr.Signature 
            != pPhysicalDisk->pDriveLayoutEx->Mbr.Signature) {
            return FALSE;       // different signatures
        }

        if (pSifDisk->pDriveLayoutEx->PartitionCount
            != pPhysicalDisk->pDriveLayoutEx->PartitionCount) {
            return FALSE;       // different partition counts
        }


        for (index =0; index < pSifDisk->pDriveLayoutEx->PartitionCount; index++) {

            pSifPtnEx      = &(pSifDisk->pDriveLayoutEx->PartitionEntry[index]);
            pPhysicalPtnEx = &(pPhysicalDisk->pDriveLayoutEx->PartitionEntry[index]);

            if ((pSifPtnEx->StartingOffset.QuadPart != pPhysicalPtnEx->StartingOffset.QuadPart) ||
                (pSifPtnEx->PartitionLength.QuadPart != pPhysicalPtnEx->PartitionLength.QuadPart)
                ) {
                //
                // The partition offset or length didn't match, ie the disk
                // isn't intact
                //
                return FALSE;
            }
        } // for
    }
    else if (PARTITION_STYLE_GPT == pSifDisk->Style) {
        BOOL found = FALSE;
        //
        // For GPT disks, the partitions must have the same partition-Id's, in
        // addition to the start sector and sector count.  We can't rely on their
        // partition table entry order being the same, though--so we have to go
        // through all the partition entries from the beginning ...
        //
        for (index = 0; index < pSifDisk->pDriveLayoutEx->PartitionCount; index++) {

            pSifPtnEx = &(pSifDisk->pDriveLayoutEx->PartitionEntry[index]);

            found = FALSE;
            for (physicalIndex = 0;
                (physicalIndex < pPhysicalDisk->pDriveLayoutEx->PartitionCount)
//                    && (pSifPtnEx->StartingOffset.QuadPart >= pPhysicalDisk->pDriveLayoutEx->PartitionEntry[physicalIndex].StartingOffset.QuadPart) // entries are in ascending order
                    && (!found);
                physicalIndex++) {

                pPhysicalPtnEx = &(pPhysicalDisk->pDriveLayoutEx->PartitionEntry[physicalIndex]);

                if (IsEqualGUID(&(pSifPtnEx->Gpt.PartitionId), &(pPhysicalPtnEx->Gpt.PartitionId)) &&
                    (pSifPtnEx->StartingOffset.QuadPart == pPhysicalPtnEx->StartingOffset.QuadPart) &&
                    (pSifPtnEx->PartitionLength.QuadPart == pPhysicalPtnEx->PartitionLength.QuadPart)
                    ) {
                    //
                    // The partition GUID, offset and length matched, this partition exists
                    //
                    found = TRUE;
                }
            } // for

            if (!found) {
                //
                // At least one partition wasn't found
                //
                return FALSE;
            }
        }
    }

    return TRUE;
}


LONGLONG
AsrpCylinderAlignMbrPartitions(
    IN PASR_DISK_INFO   pSifDisk,
    IN PDRIVE_LAYOUT_INFORMATION_EX pAlignedLayoutEx,
    IN DWORD            StartIndex,      // index in the partitionEntry table to start at
    IN LONGLONG         StartingOffset,
    IN PDISK_GEOMETRY   pPhysicalDiskGeometry
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    LONGLONG nextEnd = 0,
        endingOffset = 0,
        bytesPerTrack = 0,
        bytesPerCylinder = 0,
        currentMax = 0,
        maxEndingOffset = 0;

    DWORD   index = 0,
        tempIndex = 0,
        tempIndex2 = 0;

    PPARTITION_INFORMATION_EX alignedPtn = NULL,
        sifPtn = NULL,
        tempPtn = NULL;

    if (PARTITION_STYLE_MBR != pSifDisk->Style) {
        //
        // This routine only supports MBR disks.  For GPT disks, we don't need to
        // cylinder-align partitions, so this routine shouldn't be called.
        //
        return -1;
    }

    if (0 == pSifDisk->pDriveLayoutEx->PartitionCount) {
        //
        //  (boundary case) No partitions on disk to align
        //
        return 0;
    }

    MYASSERT(AsrpRoundUp(StartIndex,4) == StartIndex);
    MYASSERT(pSifDisk && pAlignedLayoutEx);
    if (!pSifDisk || !pAlignedLayoutEx) {
        return -1;
    }

    bytesPerTrack = pPhysicalDiskGeometry->BytesPerSector * pPhysicalDiskGeometry->SectorsPerTrack;
    bytesPerCylinder = bytesPerTrack * (pPhysicalDiskGeometry->TracksPerCylinder);

    //
    // The first partition entry in each MBR/EBR always starts at the 
    // cylinder-boundary plus one track.  So, add one track to the starting 
    // offset.
    //
    // The exception (there had to be one, of course) is if the first 
    // partition entry in the MBR/EBR itself is a container partition (0x05 or
    // 0x0f), then it starts on the next cylinder.
    //
    if (IsContainerPartition(pSifDisk->pDriveLayoutEx->PartitionEntry[StartIndex].Mbr.PartitionType)) {
        StartingOffset += (bytesPerCylinder);
    }
    else {
        StartingOffset += (bytesPerTrack);
    }


    for (index = 0; index < 4; index++) {

        alignedPtn = &(pAlignedLayoutEx->PartitionEntry[index + StartIndex]);
        sifPtn = &(pSifDisk->pDriveLayoutEx->PartitionEntry[index + StartIndex]);

        MYASSERT(PARTITION_STYLE_MBR == sifPtn->PartitionStyle);
        //
        // Set the fields of interest
        //
        alignedPtn->PartitionStyle = PARTITION_STYLE_MBR;
        alignedPtn->RewritePartition = TRUE;

        alignedPtn->Mbr.PartitionType = sifPtn->Mbr.PartitionType;
        alignedPtn->Mbr.BootIndicator = sifPtn->Mbr.BootIndicator;
        alignedPtn->Mbr.RecognizedPartition = sifPtn->Mbr.RecognizedPartition;

        if (PARTITION_ENTRY_UNUSED != sifPtn->Mbr.PartitionType)  {

            alignedPtn->StartingOffset.QuadPart = StartingOffset;
            endingOffset = AsrpRoundUp(sifPtn->PartitionLength.QuadPart + StartingOffset, bytesPerCylinder);

            alignedPtn->PartitionLength.QuadPart = endingOffset - StartingOffset;

            if (IsContainerPartition(alignedPtn->Mbr.PartitionType)) {
                //
                // This is a container partition (0x5 or 0xf), so we have to try and
                // fit the logical drives inside this partition to get the
                // required size of this partition.
                //
                nextEnd = AsrpCylinderAlignMbrPartitions(pSifDisk,
                    pAlignedLayoutEx,
                    StartIndex + 4,
                    StartingOffset,
                    pPhysicalDiskGeometry
                    );

                if (-1 == nextEnd) {
                    //
                    // Propogate error upwards
                    //
                    return nextEnd;
                }

                if (StartIndex < 4) {
                    //
                    // We're dealing with the primary container partition
                    //
                    if (nextEnd > endingOffset) {
                        MYASSERT(AsrpRoundUp(nextEnd, bytesPerCylinder) == nextEnd);
                        alignedPtn->PartitionLength.QuadPart = nextEnd - StartingOffset;
                        endingOffset = nextEnd;
                    }

                    //
                    // If the primary container partition ends beyond cylinder 
                    // 1024, it should be of type 0xf, else it should be of
                    // type 0x5.
                    //
                    if (endingOffset > (1024 * bytesPerCylinder)) {
                        alignedPtn->Mbr.PartitionType = PARTITION_XINT13_EXTENDED;
                    }
                    else {
                        alignedPtn->Mbr.PartitionType = PARTITION_EXTENDED;
                    }
                }
                else {
                    //
                    // We're dealing with a secondary container.  This 
                    // container should only be big enough to hold the
                    // next logical drive.
                    //
                    alignedPtn->Mbr.PartitionType = PARTITION_EXTENDED;

                    tempIndex = (DWORD) AsrpRoundUp((StartIndex + index), 4);
                    currentMax = 0;

                    for (tempIndex2 = 0; tempIndex2 < 4; tempIndex2++) {

                        tempPtn = &(pSifDisk->pDriveLayoutEx->PartitionEntry[tempIndex + tempIndex2]);

                        if ((PARTITION_ENTRY_UNUSED != tempPtn->Mbr.PartitionType) &&
                            !IsContainerPartition(tempPtn->Mbr.PartitionType)
                            ) {
                            
                            if (tempPtn->StartingOffset.QuadPart + tempPtn->PartitionLength.QuadPart
                                > currentMax
                                ) {
                                currentMax = tempPtn->StartingOffset.QuadPart + tempPtn->PartitionLength.QuadPart;
                            }
                        }
                    }

                    if (currentMax > endingOffset) {
                        MYASSERT(AsrpRoundUp(currentMax, bytesPerCylinder) == currentMax);
                        alignedPtn->PartitionLength.QuadPart = currentMax - StartingOffset;
                        endingOffset = currentMax;
                    }

                }

                if (nextEnd > maxEndingOffset) {
                    maxEndingOffset = nextEnd;
                }
            }

            if (endingOffset > maxEndingOffset) {
                maxEndingOffset = endingOffset;
            }

            StartingOffset += (alignedPtn->PartitionLength.QuadPart);
        }
        else {
            alignedPtn->StartingOffset.QuadPart = 0;
            alignedPtn->PartitionLength.QuadPart = 0;
        }
    }

    return maxEndingOffset;
}


VOID
AsrpFreeRegionInfo(
    IN PASR_REGION_INFO RegionInfo
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO temp = RegionInfo;
    HANDLE heapHandle = GetProcessHeap();

    while (temp) {
        RegionInfo = temp->pNext;
        _AsrpHeapFree(temp);
        temp = RegionInfo;
    }
}


BOOL
AsrpIsOkayToErasePartition(
    IN PPARTITION_INFORMATION_EX pPartitionInfoEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    GUID typeGuid = pPartitionInfoEx->Gpt.PartitionType;

    //
    // For now, this checks the partition type against all the known ("recognised")
    // partition types.  If the partition type is recognised (except the system partition),
    // it's okay to erase it.
    //
    if (IsEqualGUID(&(typeGuid), &(PARTITION_ENTRY_UNUSED_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_SYSTEM_GUID))) {
        return FALSE; // Cannot erase EFI system partition.
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_MSFT_RESERVED_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_BASIC_DATA_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_LDM_METADATA_GUID))) {
        return TRUE;
    }

    if (IsEqualGUID(&(typeGuid), &(PARTITION_LDM_DATA_GUID))) {
        return TRUE;
    }

    //
    // It is okay to erase other, unrecognised partitions.
    //
    return TRUE;
}


//
// Checks if it's okay to erase all the partitions on a disk.  Returns TRUE for MBR disks.
// Returns TRUE for GPT disks if all the partitions on it are erasable.  A partition that
// we don't recognise  (including OEM partitions, ESP, etc) is considered non-erasable.
//
BOOL
AsrpIsOkayToEraseDisk(
    IN PASR_DISK_INFO pPhysicalDisk
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    DWORD index;

    if (PARTITION_STYLE_GPT != pPhysicalDisk->pDriveLayoutEx->PartitionStyle) {
        return TRUE;
    }

    for (index = 0; index < pPhysicalDisk->pDriveLayoutEx->PartitionCount; index++) {
        if (!AsrpIsOkayToErasePartition(&(pPhysicalDisk->pDriveLayoutEx->PartitionEntry[index]))) {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL
AsrpInsertSortedRegion(
    IN OUT PASR_REGION_INFO *Head,
    IN LONGLONG StartingOffset,
    IN LONGLONG RegionLength,
    IN DWORD Index,
    IN LONGLONG MaxLength,          // 0 == don't care
    IN ASR_SORT_ORDER SortBy
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO previousRegion = NULL,
        newRegion = NULL,
        currentRegion = *Head;

    if (RegionLength < (1024*1024)) {
        return TRUE;
    }
    //
    // Alloc mem for the new region and set the fields of interest
    //
    newRegion = (PASR_REGION_INFO) HeapAlloc(
        GetProcessHeap(),
        HEAP_ZERO_MEMORY,
        sizeof(ASR_REGION_INFO)
        );
    if (!newRegion) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    newRegion->StartingOffset = StartingOffset;
    newRegion->RegionLength = RegionLength;
    newRegion->Index = Index;
    newRegion->pNext = NULL;

    if (!currentRegion) {
        //
        // First item in the list
        //
        *Head = newRegion;
    }
    else {

        while (currentRegion) {

             if (((SortByLength == SortBy) && (currentRegion->RegionLength <= RegionLength))
                || ((SortByStartingOffset == SortBy) && (currentRegion->StartingOffset <= StartingOffset))
                ) {

                previousRegion = currentRegion;
                currentRegion = currentRegion->pNext;
            }

            else {
                //
                // We found the spot, let's add it in.
                //

                //
                // If this is sorted based on start sectors, make sure there's
                // enough space to add this region in, ie that the regions don't overlap.
                //
                if (SortByStartingOffset == SortBy) {
                    //
                    // Make sure this is after the end of the previous sector
                    //
                    if (previousRegion) {
                        if ((previousRegion->StartingOffset + previousRegion->RegionLength) > StartingOffset) {
                            return FALSE;
                        }
                    }

                    //
                    // And that this ends before the next sector starts
                    //
                    if ((StartingOffset + RegionLength) > (currentRegion->StartingOffset)) {
                        return FALSE;
                    }
                }


                if (!previousRegion) {
                    //
                    // This is the first node
                    //
                    *Head = newRegion;
                }
                else {
                    previousRegion->pNext = newRegion;
                }

                newRegion->pNext = currentRegion;
                break;
            }

        }

        if (!currentRegion) {
            //
            // We reached the end and didn't add this node in.
            //
            MYASSERT(NULL == previousRegion->pNext);

            //
            // Make sure this is after the end of the previous sector
            //
            if (previousRegion && (MaxLength > 0)) {
                if ((previousRegion->StartingOffset + previousRegion->RegionLength) > MaxLength) {
                    return FALSE;
                }
            }

            previousRegion->pNext = newRegion;
        }
    }

    return TRUE;
}


BOOL
AsrpBuildFreeRegionList(
    IN PASR_REGION_INFO PartitionList,
    OUT PASR_REGION_INFO *FreeList,
    IN LONGLONG UsableStartingOffset,
    IN LONGLONG UsableLength
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO currentRegion = PartitionList,
        previousRegion = NULL;
    LONGLONG previousEnd = UsableStartingOffset;

    while (currentRegion) {

        if (!AsrpInsertSortedRegion(FreeList,
            previousEnd,                // free region start offset
            currentRegion->StartingOffset - previousEnd,  // free region length,
            0,                          // index--not meaningful for this list
            0,
            SortByLength
            ) ) {

            return FALSE;
        }

        previousEnd = currentRegion->StartingOffset + currentRegion->RegionLength;
        currentRegion = currentRegion->pNext;
    }

    //
    // Add space after the last partition till the end of the disk to
    // our free regions list
    //
    return AsrpInsertSortedRegion(FreeList, // list head
        previousEnd,  // free region start offset
        UsableStartingOffset + UsableLength - previousEnd, // free region length
        0, // slot index in the partition entry table--not meaningful for this list
        0,
        SortByLength
        );
}


//
// Both partitions and regions are sorted by sizes
//
BOOL
AsrpFitPartitionToFreeRegion(
    IN PASR_REGION_INFO PartitionList,
    IN PASR_REGION_INFO FreeRegionList
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO partition = PartitionList,
        hole = FreeRegionList;

    while (partition) {

        while (hole && (partition->RegionLength > hole->RegionLength)) {
            hole = hole->pNext;
        }

        if (!hole) {
            //
            // We ran out of holes and have unassigned partitions
            //
            return FALSE;
        }

        partition->StartingOffset = hole->StartingOffset;

        hole->RegionLength -= partition->RegionLength;
        hole->StartingOffset += partition->RegionLength;

        partition = partition->pNext;
    }

    return TRUE;
}


//
// For optimisation purposes, this routine should only be called if:
// PhysicalDisk and SifDisk are both GPT
// PhysicalDisk is bigger than SifDisk
// PhysicalDisk has non-erasable partitions
//
BOOL
AsrpFitGptPartitionsToRegions(
    IN PASR_DISK_INFO SifDisk,
    IN PASR_DISK_INFO PhysicalDisk,
    IN BOOL Commit
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_REGION_INFO partitionList = NULL,
        collisionList = NULL,
        freeRegionList = NULL;

    LONGLONG StartingUsableOffset = 0,
        UsableLength = 0;

    DWORD index = 0;

    BOOL result = TRUE;

    if ((PARTITION_STYLE_GPT != SifDisk->Style) || (PARTITION_STYLE_GPT != PhysicalDisk->Style)) {
        return TRUE;
    }

    StartingUsableOffset = PhysicalDisk->pDriveLayoutEx->Gpt.StartingUsableOffset.QuadPart;
    UsableLength = PhysicalDisk->pDriveLayoutEx->Gpt.UsableLength.QuadPart;

    //
    // First, go through the existing non-erasable partitions, and add them to our list
    // sorted by start sectors.
    //
    for (index = 0; index < PhysicalDisk->pDriveLayoutEx->PartitionCount; index++) {
        if (!AsrpIsOkayToErasePartition(&(PhysicalDisk->pDriveLayoutEx->PartitionEntry[index]))) {

            PPARTITION_INFORMATION_EX currentPtn = &(PhysicalDisk->pDriveLayoutEx->PartitionEntry[index]);

            if (!AsrpInsertSortedRegion(&partitionList,
                currentPtn->StartingOffset.QuadPart,
                currentPtn->PartitionLength.QuadPart,
                index,
                (StartingUsableOffset + UsableLength),
                SortByStartingOffset
                )) {
                result = FALSE;
                break;
            }
        }
    }

    if (partitionList && result) {
        //
        // Then, go through the sif partitions, and add them to a list, sorted by start sectors.
        // For partitions that cannot be added, add them to another list sorted by sizes
        //
        for (index = 0; index < SifDisk->pDriveLayoutEx->PartitionCount; index++) {
            PPARTITION_INFORMATION_EX currentPtn = &(SifDisk->pDriveLayoutEx->PartitionEntry[index]);

            if (!AsrpInsertSortedRegion(&partitionList,
                currentPtn->StartingOffset.QuadPart,
                currentPtn->PartitionLength.QuadPart,
                index,
                (StartingUsableOffset + UsableLength),
                SortByStartingOffset
                )) {

                if (!AsrpInsertSortedRegion(&collisionList,
                    currentPtn->StartingOffset.QuadPart,
                    currentPtn->PartitionLength.QuadPart,
                    index,
                    0,
                    SortByLength
                    )) {

                    result = FALSE;
                    break;
                }
            }
        }
    }

    if (collisionList && result) {
        //
        // Go through first list and come up with a list of free regions, sorted by sizes
        //
        result = AsrpBuildFreeRegionList(partitionList, &freeRegionList, StartingUsableOffset, UsableLength);

    }


    if (collisionList && result) {
        //
        // Try adding partitions from list 2 to regions from list 3.  If any
        // are left over, return FALSE.
        //
        result = AsrpFitPartitionToFreeRegion(collisionList, freeRegionList);

        if (Commit && result) {
            PASR_REGION_INFO pCurrentRegion = collisionList;
            //
            // Go through the collision list, and update the start sectors of the
            // PartitionEntries in DriveLayoutEx's table.
            //
            while (pCurrentRegion) {

                MYASSERT(SifDisk->pDriveLayoutEx->PartitionEntry[pCurrentRegion->Index].PartitionLength.QuadPart == pCurrentRegion->RegionLength);

                SifDisk->pDriveLayoutEx->PartitionEntry[pCurrentRegion->Index].StartingOffset.QuadPart =
                    pCurrentRegion->StartingOffset;

                pCurrentRegion = pCurrentRegion->pNext;
            }
        }

    }

    AsrpFreeRegionInfo(partitionList);
    AsrpFreeRegionInfo(collisionList);
    AsrpFreeRegionInfo(freeRegionList);

    return result;
}


BOOL
AsrpIsThisDiskABetterFit(
    IN PASR_DISK_INFO CurrentBest,
    IN PASR_DISK_INFO PhysicalDisk,
    IN PASR_DISK_INFO SifDisk,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx,
    OUT BOOL *IsAligned
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    LONGLONG endingOffset;

    if (ARGUMENT_PRESENT(IsAligned)) {
        *IsAligned = FALSE;
    }

    //
    // Make sure the bytes-per-sector values match
    //
    if (PhysicalDisk->pDiskGeometry->BytesPerSector != SifDisk->pDiskGeometry->BytesPerSector) {
        return FALSE;
    }

    if (PhysicalDisk->pPartition0Ex->PartitionLength.QuadPart >=
        SifDisk->pPartition0Ex->PartitionLength.QuadPart) {

        if ((!CurrentBest) ||
            (PhysicalDisk->pPartition0Ex->PartitionLength.QuadPart <
            CurrentBest->pPartition0Ex->PartitionLength.QuadPart)) {

            //
            // This disk is smaller than our current best (or we don't have a 
            // current best).  Now try laying out the partitions to see if 
            // they fit.
            //

            if (PARTITION_STYLE_GPT == SifDisk->Style) {
                //
                // If the disk has no partitions that need to be preserved,
                // we can use all of it.
                if (AsrpIsOkayToEraseDisk(PhysicalDisk)) {
                    return TRUE;
                }
                else {
                    //
                    // This disk has some regions that need to be preserved.  So
                    // we try to fit our partitions in the holes
                    //
                    return AsrpFitGptPartitionsToRegions(SifDisk, PhysicalDisk, FALSE); // No commmit
                }
            }
            else if (PARTITION_STYLE_MBR == SifDisk->Style) {

                if (!pTempDriveLayoutEx) {
                    //
                    // Caller doesn't want to try cylinder-aligning partitions
                    //
                    return TRUE;
                }
                    
                //
                // For MBR disks, the partitions have to be cylinder aligned
                //
                // AsrpCylinderAlignMbrPartitions(,,0,,) returns the ending offset (bytes)
                // of the entries in the MBR.
                //
                endingOffset = AsrpCylinderAlignMbrPartitions(SifDisk,
                    pTempDriveLayoutEx,
                    0,      // starting index--0 for the MBR
                    0,      // starting offset, assume the partitions begin at the start of the disk
                    PhysicalDisk->pDiskGeometry
                    );

                if ((endingOffset != -1) &&
                    (endingOffset <= SifDisk->pPartition0Ex->PartitionLength.QuadPart)
                    ) {

                    if (ARGUMENT_PRESENT(IsAligned)) {
                        *IsAligned = TRUE;
                    }

                    return TRUE;

                }
                else {

                    //
                    // We couldn't fit the partitions on to the disk when we 
                    // tried to cylinder align them.  If the disk geometries
                    // are the same, this may still be okay.
                    //

                    if ((SifDisk->pDiskGeometry->BytesPerSector == PhysicalDisk->pDiskGeometry->BytesPerSector) &&
                        (SifDisk->pDiskGeometry->SectorsPerTrack == PhysicalDisk->pDiskGeometry->SectorsPerTrack) &&
                        (SifDisk->pDiskGeometry->TracksPerCylinder == PhysicalDisk->pDiskGeometry->TracksPerCylinder)
                        ) {

                        return TRUE;
                    }

                    else {
                        return FALSE;
                    }
                }
            }
            else {
                MYASSERT(0 && L"Unrecognised partitioning style (neither MBR nor GPT)");
            }
        }
    }

    return FALSE;
}


//
// Assigns sif-disks to physical disks with matching signatures, if
// any exist.  If the disk is critical, or the partition-layout matches,
// the disk is marked as intact.
//
// Returns
//  FALSE   if a critical disk is absent
//  TRUE    if all critical disks are present
//
BOOL
AsrpAssignBySignature(
    IN OUT PASR_DISK_INFO   pSifDiskList,
    IN OUT PASR_DISK_INFO   pPhysicalDiskList,
    OUT    PULONG           pMaxPartitionCount
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    BOOL    result  = TRUE,
            done    = FALSE,
            found   = FALSE,
            isAligned = FALSE;

    PASR_DISK_INFO  sifDisk          = pSifDiskList,
                    physicalDisk     = pPhysicalDiskList;

    PDRIVE_LAYOUT_INFORMATION_EX pAlignedLayoutTemp = NULL;

    ULONG   tableSize = 128;    // start off at a reasonably high size

    HANDLE heapHandle = GetProcessHeap();

    pAlignedLayoutTemp = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof(DRIVE_LAYOUT_INFORMATION) + (tableSize * sizeof(PARTITION_INFORMATION_EX))
        );
    if (!pAlignedLayoutTemp) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        result = FALSE;
        goto EXIT;
    }


    *pMaxPartitionCount = 0;

    //
    // For now, this is O(n-squared), since both lists are unsorted.
    //
    while (sifDisk && !done) {

        if (!(sifDisk->pDriveLayoutEx) || !(sifDisk->pDriveLayoutEx->Mbr.Signature)) {
            //
            // we won't assign disks with no signature here
            //
            sifDisk = sifDisk->pNext;
            continue;
        }


        if (sifDisk->pDriveLayoutEx->PartitionCount > *pMaxPartitionCount) {
            *pMaxPartitionCount = sifDisk->pDriveLayoutEx->PartitionCount;
        }

        if (sifDisk->pDriveLayoutEx->PartitionCount > tableSize) {
            tableSize = sifDisk->pDriveLayoutEx->PartitionCount + 128;

            _AsrpHeapFree(pAlignedLayoutTemp);
            pAlignedLayoutTemp = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeof(DRIVE_LAYOUT_INFORMATION) + (tableSize * sizeof(PARTITION_INFORMATION_EX))
                );
            if (!pAlignedLayoutTemp) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                result = FALSE;
                goto EXIT;
            }
        }

        found = FALSE;
        physicalDisk = pPhysicalDiskList;

        while (physicalDisk && !found) {
            //
            // For MBR disks, we use the signature
            // For GPT disks, we use the disk ID
            //
            if (sifDisk->Style == physicalDisk->Style) {

                if ((PARTITION_STYLE_MBR == sifDisk->Style) &&
                    (physicalDisk->pDriveLayoutEx->Mbr.Signature == sifDisk->pDriveLayoutEx->Mbr.Signature)
                    ) {
                    //
                    // MBR disks, signatures match
                    //
                    found = TRUE;

                    AsrpPrintDbgMsg(_asrlog, 
                        "Harddisk %lu matched disk %lu in section [%ws] of the ASR state file.  (MBR signatures 0x%x match).\r\n", 
                        physicalDisk->DeviceNumber, 
                        sifDisk->SifDiskKey,
                        ASR_SIF_MBR_DISKS_SECTION,
                        sifDisk->pDriveLayoutEx->Mbr.Signature
                        );


                }
                else if (
                    (PARTITION_STYLE_GPT == sifDisk->Style) &&
                    IsEqualGUID(&(sifDisk->pDriveLayoutEx->Gpt.DiskId), &(physicalDisk->pDriveLayoutEx->Gpt.DiskId))
                    ) {

                    found = TRUE;

                    AsrpPrintDbgMsg(_asrlog, 
                        "Harddisk %lu matched disk %lu in section [%ws] of the ASR state file.  (GPT Disk-ID's match).\r\n", 
                        physicalDisk->DeviceNumber, 
                        sifDisk->SifDiskKey,
                        ASR_SIF_GPT_DISKS_SECTION
                        );

                }
                else {
                    physicalDisk = physicalDisk->pNext;
                }

            }
            else {
                physicalDisk = physicalDisk->pNext;
            }
        }

        if (sifDisk->IsCritical) {
            if (found) {

                sifDisk->AssignedTo = physicalDisk;
                physicalDisk->AssignedTo = sifDisk;
                
                //
                // We don't check the partition layout on critical disks since they
                // may have been repartitioned in text-mode Setup.
                //
                sifDisk->IsIntact = TRUE;
                sifDisk->AssignedTo->IsIntact = TRUE;
            }
            else {
                //
                // Critical disk was not found.  Fatal error.
                //
                SetLastError(ERROR_DEVICE_NOT_CONNECTED);
                result = FALSE;
                done = TRUE;

                AsrpPrintDbgMsg(_asrerror, 
                    "Critical disk not found (Entry %lu in section [%ws]).\r\n", 
                    sifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                    );

            }
        }
        else {
            if (found) {
                //
                // We found a disk with matching signature.  Now let's just 
                // make sure that the partitions actually fit on the disk
                // before assigning it
                //
                isAligned = FALSE;
                if ((sifDisk->pDriveLayoutEx->PartitionCount == 0) ||           // disk has no partitions
                    AsrpIsThisDiskABetterFit(NULL, physicalDisk, sifDisk, pAlignedLayoutTemp, &isAligned) // partitions fit on disk
                    ) {

                    sifDisk->AssignedTo = physicalDisk;
                    physicalDisk->AssignedTo = sifDisk;

                    sifDisk->IsAligned = isAligned;
                    physicalDisk->IsAligned = isAligned;

                    if (AsrpIsDiskIntact(sifDisk, physicalDisk)) {
                        sifDisk->IsIntact = TRUE;
                        sifDisk->AssignedTo->IsIntact = TRUE;
                    }
                }
                else {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Harddisk %lu is not big enough to contain the partitions on disk %lu in section [%ws] of the ASR state file.\r\n", 
                        physicalDisk->DeviceNumber, 
                        sifDisk->SifDiskKey,
                        ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                        );

                }
            }
        }

        sifDisk = sifDisk->pNext;

    }   // while


EXIT:
    _AsrpHeapFree(pAlignedLayoutTemp);

   return result;
}


//
// Attempts to assign remaining sif disks to physical disks that
// are on the same bus as the sif disk originally was (ie if
// any other disk on that bus has been assigned, this tries to assign
// this disk to the same bus)
//
BOOL
AsrpAssignByBus(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    PASR_DISK_INFO  sifDisk = pSifDiskList,
        physicalDisk = NULL,
        currentBest = NULL,
        tempSifDisk = NULL;

    BOOL done = FALSE,
        isAligned = FALSE,
        isAlignedTemp = FALSE;

    ULONG  targetBusId = 0;

    while (sifDisk) {
        //
        // Skip disks that have already found a home, and disks for which
        // we didn't have any bus/group info even on the original system
        //
        if ((NULL != sifDisk->AssignedTo) ||    // already assigned
            (0 == sifDisk->SifBusKey)           // this disk couldn't be grouped
            ) {
           sifDisk = sifDisk->pNext;
           continue;
        }

        //
        // Find another (sif) disk that used to be on the same (sif) bus,
        // and has already been assigned to a physical disk.
        //
        targetBusId = 0;
        tempSifDisk = pSifDiskList;
        done = FALSE;

        while (tempSifDisk && !done) {

            if ((tempSifDisk->SifBusKey == sifDisk->SifBusKey) &&   // same bus
                (tempSifDisk->AssignedTo != NULL)                   // assigned
                ) {
                targetBusId = tempSifDisk->AssignedTo->SifBusKey;   // the physical bus

                //
                // If this physical disk is on an unknown bus,
                // (target id = sifbuskey = 0) then we want to try and look
                // for another disk on the same (sif) bus.  Hence done is
                // TRUE only if targetId != 0
                //
                if (targetBusId) {
                    done = TRUE;
                }
            }

            tempSifDisk = tempSifDisk->pNext;

        }   // while


        if (targetBusId) {      // we found another disk on the same bus
            //
            // Go through the physical disks on the same bus, and try to
            // find the best fit for this disk.  Best fit is the smallest
            // disk on the bus that's big enough for us.
            //
            physicalDisk = pPhysicalDiskList;
            currentBest  = NULL;

            while (physicalDisk) {

                if ((NULL == physicalDisk->AssignedTo) &&       // not assigned
                    (physicalDisk->SifBusKey == targetBusId) && // same bus
                    (AsrpIsThisDiskABetterFit(currentBest, physicalDisk, sifDisk, pTempDriveLayoutEx, &isAlignedTemp))
                    ) {

                    isAligned = isAlignedTemp;
                    currentBest = physicalDisk;
                }

                physicalDisk = physicalDisk->pNext;
            }   // while

            sifDisk->AssignedTo = currentBest;  // may be null if no match was found
            sifDisk->IsAligned = isAligned;

            if (currentBest) {

                currentBest->AssignedTo = sifDisk;
                currentBest->IsAligned = isAligned;

                AsrpPrintDbgMsg(_asrlog, 
                    "Harddisk %lu assigned to disk %lu in section [%ws] of the ASR state file.  (Based on storage bus).\r\n", 
                    currentBest->DeviceNumber, 
                    sifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                    );

            }
       }

        sifDisk = sifDisk->pNext;
    }   // while sifdisk

    return TRUE;

}


//
// Attempts to assign remaining sif disks to physical disks that
// are on any bus of the same type (SCSI, IDE, etc) as the sif disk
// originally was
//
BOOL
AsrpAssignByBusType(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_DISK_INFO  sifDisk = pSifDiskList,
        physicalDisk = NULL,
        currentBest = NULL;

    STORAGE_BUS_TYPE targetBusType;

    BOOL isAligned = FALSE,
        isAlignedTemp = FALSE;

    while (sifDisk) {
        //
        // Skip disks that have already found a home, and disks for which
        // we didn't have any bus/group info even on the original system
        //
        if ((NULL != sifDisk->AssignedTo) ||     // already assigned
            (BusTypeUnknown == sifDisk->BusType) // this disk couldn't be grouped
            ) {
           sifDisk = sifDisk->pNext;
           continue;
        }

        //
        // Go through the physical disks, and try to
        // find the best fit for this disk.  Best fit is the smallest
        // disk on any bus of the same bus type that's big enough for us.
        //
        physicalDisk = pPhysicalDiskList;
        currentBest  = NULL;

        while (physicalDisk) {

            if ((NULL == physicalDisk->AssignedTo) &&       // not assigned
                (physicalDisk->BusType == sifDisk->BusType) && // same bus type
                (AsrpIsThisDiskABetterFit(currentBest, physicalDisk, sifDisk, pTempDriveLayoutEx, &isAlignedTemp))
                ) {

                isAligned = isAlignedTemp;
                currentBest = physicalDisk;
            }

            physicalDisk = physicalDisk->pNext;
        }   // while

        sifDisk->AssignedTo = currentBest;  // may be null if no match was found
        sifDisk->IsAligned = isAligned;

        if (currentBest) {
            currentBest->AssignedTo = sifDisk;
            currentBest->IsAligned = isAligned;


            AsrpPrintDbgMsg(_asrlog, 
                "Harddisk %lu assigned to disk %lu in section [%ws] of the ASR state file.  (Based on storage bus type).\r\n", 
                currentBest->DeviceNumber, 
                sifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            AsrpAssignByBus(pSifDiskList, pPhysicalDiskList, pTempDriveLayoutEx);
        }

        sifDisk = sifDisk->pNext;
    }   // while sifdisk

    return TRUE;

}


//
// Okay, so by now we've tried putting disks on the same bus, and
// the same bus type.  For disks that didn't fit using either of those
// rules (or for which we didn't have any bus info at all), let's just
// try to fit them where ever possible on the system.
//
BOOL
AsrpAssignRemaining(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PDRIVE_LAYOUT_INFORMATION_EX pTempDriveLayoutEx
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PASR_DISK_INFO  sifDisk = pSifDiskList,
        physicalDisk = NULL,
        currentBest = NULL;

    BOOL isAligned = FALSE,
        isAlignedTemp = FALSE;

    while (sifDisk) {
        //
        // Skip disks that have already found a home
        //
        if (NULL != sifDisk->AssignedTo) {
           sifDisk = sifDisk->pNext;
           continue;
        }

        //
        // Go through the physical disks, and try to find the best
        // fit for this disk.  Best fit is the smallest disk anywhere
        // on the system that's big enough for us.
        //
        physicalDisk = pPhysicalDiskList;
        currentBest  = NULL;

        while (physicalDisk) {

            if ((NULL == physicalDisk->AssignedTo) &&       // not assigned
                (AsrpIsThisDiskABetterFit(currentBest, physicalDisk, sifDisk, pTempDriveLayoutEx, &isAlignedTemp))
                ) {

                isAligned = isAlignedTemp;
                currentBest = physicalDisk;
            }

            physicalDisk = physicalDisk->pNext;
        }   // while

        sifDisk->AssignedTo = currentBest;  // may be null if no match was found
        sifDisk->IsAligned = isAligned;

        if (currentBest) {
            currentBest->AssignedTo = sifDisk;
            currentBest->IsAligned = isAligned;

            AsrpPrintDbgMsg(_asrlog, 
                "Harddisk %lu assigned to disk %lu in section [%ws] of the ASR state file.  (Based on size).\r\n", 
                currentBest->DeviceNumber, 
                sifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            AsrpAssignByBus(pSifDiskList, pPhysicalDiskList, pTempDriveLayoutEx);
            AsrpAssignByBusType(pSifDiskList, pPhysicalDiskList, pTempDriveLayoutEx);
        }

        sifDisk = sifDisk->pNext;
    }   // while sifdisk

    return TRUE;

}


BOOL
AsrpIsPartitionExtendible(
    IN CONST UCHAR PartitionType
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    switch (PartitionType) {
    case PARTITION_EXTENDED:

    case PARTITION_IFS:
    
    case PARTITION_XINT13:
    case PARTITION_XINT13_EXTENDED:

        return TRUE;

    default:
        return FALSE;
    }

    return FALSE;

}


BOOL
AsrpAutoExtendMbrPartitions(
    IN PASR_DISK_INFO pSifDisk,
    IN PASR_DISK_INFO pPhysicalDisk,
    IN LONGLONG LastUsedPhysicalDiskOffset
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    PDISK_GEOMETRY physicalGeometry = NULL;

    IN PDRIVE_LAYOUT_INFORMATION_EX sifLayout = NULL,
        physicalLayout = NULL;

    LONGLONG MaxSifDiskOffset = 0,
        MaxPhysicalDiskOffset = 0,
        LastUsedSifDiskOffset = 0;

    DWORD count = 0;

    BOOL madeAChange = FALSE;

    //
    // Find the last sector of the disk
    //
    MaxSifDiskOffset = pSifDisk->pPartition0Ex->PartitionLength.QuadPart;

    physicalGeometry = pPhysicalDisk->pDiskGeometry;
    MaxPhysicalDiskOffset = (physicalGeometry->BytesPerSector) *
        (physicalGeometry->SectorsPerTrack) * 
        (physicalGeometry->TracksPerCylinder) *
        (physicalGeometry->Cylinders.QuadPart);

    //
    // Did the old disk have empty space at the end?
    //
    sifLayout = pSifDisk->pDriveLayoutEx;
    for (count = 0; count < sifLayout->PartitionCount; count++) {

        if (((sifLayout->PartitionEntry[count].StartingOffset.QuadPart) + 
                (sifLayout->PartitionEntry[count].PartitionLength.QuadPart))
            > LastUsedSifDiskOffset) {

            LastUsedSifDiskOffset = (sifLayout->PartitionEntry[count].StartingOffset.QuadPart + 
                sifLayout->PartitionEntry[count].PartitionLength.QuadPart);
        }
    }

    if ((LastUsedSifDiskOffset + ASR_AUTO_EXTEND_MAX_FREE_SPACE_IGNORED) >= MaxSifDiskOffset) {
        //
        // No, it didn't.  Extend the last partition.
        //
        physicalLayout = pPhysicalDisk->pDriveLayoutEx;
        for (count = 0; count < physicalLayout->PartitionCount; count++) {

            if (((physicalLayout->PartitionEntry[count].StartingOffset.QuadPart) + 
                    (physicalLayout->PartitionEntry[count].PartitionLength.QuadPart))
                == LastUsedPhysicalDiskOffset
                ) {
                if (AsrpIsPartitionExtendible(physicalLayout->PartitionEntry[count].Mbr.PartitionType)) {

                    physicalLayout->PartitionEntry[count].PartitionLength.QuadPart += 
                        (MaxPhysicalDiskOffset - LastUsedPhysicalDiskOffset);
                    madeAChange = TRUE;
                }
            }
        }
    }

    if (madeAChange) {
        AsrpPrintDbgMsg(_asrlog, 
            "Extended partitions on Harddisk %lu (assigned to disk %lu in section [%ws]).\r\n", 
            pPhysicalDisk->DeviceNumber, 
            pSifDisk->SifDiskKey,
            ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
            );
    }
    else {
        AsrpPrintDbgMsg(_asrinfo, 
            "Did not extend partitions on Harddisk %lu (assigned to disk %lu in section [%ws]).\r\n", 
            pPhysicalDisk->DeviceNumber, 
            pSifDisk->SifDiskKey,
            ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
            );
    }

    return madeAChange;

}

//
// Try to determine which sif disks end up on which physical disk.
//
BOOL
AsrpAssignDisks(
    IN OUT PASR_DISK_INFO pSifDiskList,
    IN OUT PASR_DISK_INFO pPhysicalDiskList,
    IN PASR_PTN_INFO_LIST pSifMbrPtnList,
    IN PASR_PTN_INFO_LIST pSifGptPtnList,
    IN BOOL AllOrNothing,
    IN BOOL AllowAutoExtend
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    ULONG maxSifPartitionCount = 0;
    PDRIVE_LAYOUT_INFORMATION_EX pAlignedLayoutTemp = NULL;
    LONGLONG endingOffset = 0;
    BOOL reAlloc = TRUE;
    HANDLE heapHandle = GetProcessHeap();
    PASR_DISK_INFO sifDisk = NULL;
    PASR_PTN_INFO pCurrentPtn = NULL;
    PPARTITION_INFORMATION_EX pCurrentEntry = NULL;
    DWORD index = 0, preserveIndex = 0;

    if (!AsrpAssignBySignature(pSifDiskList, pPhysicalDiskList, &maxSifPartitionCount)) {
        //
        // Critical disks were not found
        //
        return FALSE;
    }

    pAlignedLayoutTemp = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof(DRIVE_LAYOUT_INFORMATION) + (maxSifPartitionCount * sizeof(PARTITION_INFORMATION_EX))
        );
    if (!pAlignedLayoutTemp) {
        return FALSE;
    }

    AsrpAssignByBus(pSifDiskList, pPhysicalDiskList, pAlignedLayoutTemp);

    AsrpAssignByBusType(pSifDiskList, pPhysicalDiskList, pAlignedLayoutTemp);

    AsrpAssignRemaining(pSifDiskList, pPhysicalDiskList, pAlignedLayoutTemp);

    _AsrpHeapFree(pAlignedLayoutTemp);

    //
    // All disks should be assigned by now, we now cylinder-snap
    // the partition boundaries.  If AllOrNothing is TRUE,
    // we return false if any sif-disk couldn't be assigned.
    //
    sifDisk = pSifDiskList;

    while (sifDisk) {

        if (sifDisk->IsIntact || sifDisk->IsCritical) {
            //
            // We won't be re-partitioning critical disks or disks that are 
            // intact, so it's no point trying to cylinder-align them.
            //
            sifDisk = sifDisk->pNext;
            continue;
        }

        if (NULL == sifDisk->AssignedTo) {

            AsrpPrintDbgMsg(_asrlog, 
                "Disk %lu in section [%ws] could not be restored (no matching disks found).\r\n", 
                sifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == sifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            //
            // This disk couldn't be assigned.  If AllOrNothing is set, we return
            // FALSE, since we couldn't assign All.
            //
            if (AllOrNothing) {
                SetLastError(ERROR_NOT_FOUND);
                return FALSE;
            }
            else {
                sifDisk = sifDisk->pNext;
                continue;
            }
        }


        if (PARTITION_STYLE_MBR == sifDisk->Style) {
            //
            // Assume that we need to re-allocate mem for the physical disk's
            // partition table.
            //
            reAlloc = TRUE;

            if (sifDisk->AssignedTo->pDriveLayoutEx) {
                if (sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount ==
                    sifDisk->pDriveLayoutEx->PartitionCount) {
                    //
                    // If the physical drive happened to have the same number of
                    // partitions, the drive layout struct is exactly the right
                    // size, so we don't have to re-allocate it.
                    //
                    reAlloc = FALSE;

                    //
                    // consistency check.  If the partition counts are
                    // the same, the size of the drive layout stucts must be the same, too.
                    //
                    MYASSERT(sifDisk->AssignedTo->sizeDriveLayoutEx == sifDisk->sizeDriveLayoutEx);
                }
            }

            if (reAlloc) {
                //
                //  The partition tables are of different sizes
                //
                _AsrpHeapFree(sifDisk->AssignedTo->pDriveLayoutEx);

                sifDisk->AssignedTo->pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                        ((sifDisk->pDriveLayoutEx->PartitionCount - 1) * sizeof(PARTITION_INFORMATION_EX))
                    );
                if (!sifDisk->AssignedTo->pDriveLayoutEx) {

                    AsrpPrintDbgMsg(_asrerror, "Out of memory.\r\n");
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
            }

            //
            // Set the fields of interest
            //
            sifDisk->AssignedTo->sizeDriveLayoutEx = sifDisk->sizeDriveLayoutEx;
            sifDisk->AssignedTo->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_MBR;

            if (sifDisk->IsAligned) {
                sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount = sifDisk->pDriveLayoutEx->PartitionCount;
                sifDisk->AssignedTo->pDriveLayoutEx->Mbr.Signature = sifDisk->pDriveLayoutEx->Mbr.Signature;

                //
                // Cylinder-snap the partition boundaries
                //
                endingOffset = AsrpCylinderAlignMbrPartitions(
                    sifDisk,
                    sifDisk->AssignedTo->pDriveLayoutEx,
                    0,      // starting index--0 for the MBR
                    0,      // starting offset, assume the partitions begin at the start of the disk
                    sifDisk->AssignedTo->pDiskGeometry
                    );

                MYASSERT(endingOffset != -1);
                if (-1 == endingOffset) {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Partitions on disk %lu in section [%ws] could not be restored.\r\n", 
                        sifDisk->SifDiskKey,
                        ASR_SIF_MBR_DISKS_SECTION
                        );

                    if (AllOrNothing) {
                        SetLastError(ERROR_HANDLE_DISK_FULL);
                        return FALSE;
                    }
                    else {
                        sifDisk = sifDisk->pNext;
                        continue;
                    }

                }

                MYASSERT(endingOffset <= sifDisk->AssignedTo->pPartition0Ex->PartitionLength.QuadPart);
                if ((endingOffset) > (sifDisk->AssignedTo->pPartition0Ex->PartitionLength.QuadPart)) {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Partitions on disk %lu in section [%ws] could not be restored.\r\n", 
                        sifDisk->SifDiskKey,
                        ASR_SIF_MBR_DISKS_SECTION
                        );
 
                    if (AllOrNothing) {
                        SetLastError(ERROR_HANDLE_DISK_FULL);
                        return FALSE;
                    }
                    else {
                        sifDisk = sifDisk->pNext;
                        continue;
                    }

                }

                if (AllowAutoExtend) {
                    AsrpAutoExtendMbrPartitions(sifDisk, sifDisk->AssignedTo, endingOffset);
                }

                //
                // Now, we need to go through our partition list, and update the start sector
                // for the partitions in that list.  This is needed since we use the start
                // sector later to assign the volume guids to the partitions.
                //
                pCurrentPtn = pSifMbrPtnList[sifDisk->SifDiskKey].pOffsetHead;
                while (pCurrentPtn) {

                    pCurrentPtn->PartitionInfo.StartingOffset.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].StartingOffset.QuadPart;

                    pCurrentPtn->PartitionInfo.PartitionLength.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].PartitionLength.QuadPart;

                    pCurrentPtn = pCurrentPtn->pOffsetNext;
                }
            }
            else {
                //
                // The partitions didn't fit when we cylinder-aligned them.  
                // However, the current disk geometry is identical to the 
                // original disk geometry, so we can recreate the partitions
                // exactly the way they were before.  Let's just copy over
                // the partition layout.
                //
                CopyMemory(sifDisk->AssignedTo->pDriveLayoutEx, 
                    sifDisk->pDriveLayoutEx, 
                    sifDisk->sizeDriveLayoutEx
                    );

                for (index = 0; index < sifDisk->pDriveLayoutEx->PartitionCount; index++) {

                    sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[index].RewritePartition = TRUE;

                }
            }

        }
        else if (PARTITION_STYLE_GPT == sifDisk->Style) {
            DWORD sizeNewDriveLayoutEx = 0;
            PDRIVE_LAYOUT_INFORMATION_EX pNewDriveLayoutEx = NULL;

/*

            The MaxPartitionCount values are different for the two disks.  We can't do
            much here, so we'll just ignore it.
          
            if ((PARTITION_STYLE_GPT == sifDisk->AssignedTo->Style) &&
                (sifDisk->pDriveLayoutEx->Gpt.MaxPartitionCount
                > sifDisk->AssignedTo->pDriveLayoutEx->Gpt.MaxPartitionCount)) {

                MYASSERT(0 && L"Not yet implemented: sifdisk MaxPartitionCount > physicalDisk->MaxPartitionCount");
                sifDisk = sifDisk->pNext;
                continue;
            }
*/
            //
            // Allocate a pDriveLayoutEx struct large enough to hold all the partitions on both
            // the sif disk and the physical disk.
            //
            sizeNewDriveLayoutEx =  sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
                (sizeof(PARTITION_INFORMATION_EX) *
                (sifDisk->pDriveLayoutEx->PartitionCount +
                sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount - 1 )
                );

            pNewDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                sizeNewDriveLayoutEx
                );
            if (!pNewDriveLayoutEx) {
                return FALSE;
            }

            preserveIndex = 0;
            if (!sifDisk->IsIntact && !AsrpIsOkayToEraseDisk(sifDisk->AssignedTo)) {

                //
                // This disk is not intact, but it has partitions that must be preserved.
                //
                if (!AsrpFitGptPartitionsToRegions(sifDisk, sifDisk->AssignedTo, TRUE)) {

                    AsrpPrintDbgMsg(_asrlog, 
                        "Partitions on disk %lu in section [%ws] could not be restored.\r\n", 
                        sifDisk->SifDiskKey,
                        ASR_SIF_GPT_DISKS_SECTION
                        );
 
                    MYASSERT(0 && L"AsrpFitGptPartitionsToRegions failed for assigned disk");

                    if (AllOrNothing) {
                        SetLastError(ERROR_HANDLE_DISK_FULL);
                        return FALSE;
                    }
                    else {
                        sifDisk = sifDisk->pNext;
                        continue;
                    }

                 }

                //
                // Now, we need to go through our partition list, and update the start sector
                // for the partitions in that list.  This is needed since we use the start
                // sector later to assign the volume guids to the partitions.
                //
                // The start sectors could've changed because the physical disk may have had
                // un-erasable partitions.
                //
                pCurrentPtn = pSifGptPtnList[sifDisk->SifDiskKey].pOffsetHead;
                while (pCurrentPtn) {

                    pCurrentPtn->PartitionInfo.StartingOffset.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].StartingOffset.QuadPart;

                    pCurrentPtn->PartitionInfo.PartitionLength.QuadPart =
                        sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[pCurrentPtn->SlotIndex].PartitionLength.QuadPart;

                    pCurrentPtn = pCurrentPtn->pOffsetNext;

                }


                //
                // Move the non-erasable partitions on the physical disks up to the beginning.
                //
                for (index = 0; index < sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount; index++) {

                    pCurrentEntry = &(sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[index]);

                    if (!AsrpIsOkayToErasePartition(pCurrentEntry)) {

                        if (preserveIndex == index) {
                            preserveIndex++;
                            continue;
                        }

                        memmove(&(pNewDriveLayoutEx->PartitionEntry[preserveIndex]),
                            &(sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[index]),
                            sizeof(PARTITION_INFORMATION_EX)
                            );
                        preserveIndex++;

                    }
                    else {
                        //
                        // This partition can be erased.
                        //
                        pCurrentEntry->StartingOffset.QuadPart = 0;
                        pCurrentEntry->PartitionLength.QuadPart = 0;
                    }
                }   // for

            }  // if !IsIntact

            //
            // Now that we've copied over entries of interest to the new
            // drivelayoutex struct, we can get rid of the old one.
            //
            _AsrpHeapFree(sifDisk->AssignedTo->pDriveLayoutEx);
            sifDisk->AssignedTo->sizeDriveLayoutEx = sizeNewDriveLayoutEx;
            sifDisk->AssignedTo->pDriveLayoutEx = pNewDriveLayoutEx;

            //
            // Copy over the sif partition table to the physicalDisk
            //
            memcpy(&(sifDisk->AssignedTo->pDriveLayoutEx->PartitionEntry[preserveIndex]),
                &(sifDisk->pDriveLayoutEx->PartitionEntry[0]),
                sizeof(PARTITION_INFORMATION_EX) * (sifDisk->pDriveLayoutEx->PartitionCount)
                );

            sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount = sifDisk->pDriveLayoutEx->PartitionCount + preserveIndex;
            sifDisk->AssignedTo->sizeDriveLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * (sifDisk->AssignedTo->pDriveLayoutEx->PartitionCount - 1));

            sifDisk->AssignedTo->pDriveLayoutEx->PartitionStyle = PARTITION_STYLE_GPT;

            memcpy(&(sifDisk->AssignedTo->pDriveLayoutEx->Gpt.DiskId),
                &(sifDisk->pDriveLayoutEx->Gpt.DiskId),
                sizeof(GUID)
                );

        }
        else {
            MYASSERT(0 && L"Unrecognised partitioning style (neither MBR nor GPT)");
        }

        sifDisk = sifDisk->pNext;
    }

    return TRUE;
}


BOOL
AsrpCreateMountPoint(
    IN DWORD DiskNumber,
    IN DWORD PartitionNumber,
    IN PCWSTR szVolumeGuid
    )


/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PMOUNTMGR_CREATE_POINT_INPUT inputCreatePoint = NULL;
    PMOUNTMGR_MOUNT_POINT inputDeletePoint = NULL;
    PMOUNTMGR_MOUNT_POINTS outputDeletePoint = NULL;
    WCHAR deviceName[ASR_CCH_DEVICE_PATH_FORMAT];
    PMOUNTMGR_MOUNT_POINTS  mountPointsOut  = NULL;

    INT attempt = 0;
    
    DWORD cbName = 0;
    PWSTR lpName = NULL;
    DWORD cbDeletePoint = 0;

    USHORT sizeGuid = 0,
        sizeDeviceName = 0;

    DWORD bytes = 0, index = 0,
        status = ERROR_SUCCESS;

    HANDLE mpHandle = NULL,
        heapHandle = GetProcessHeap();

    BOOL result = TRUE;

    if (!szVolumeGuid || !wcslen(szVolumeGuid)) {
        return TRUE;
    }

    //
    // Open the mount manager
    //
    mpHandle = CreateFileW(
        (PCWSTR) MOUNTMGR_DOS_DEVICE_NAME,      // lpFileName
        GENERIC_READ | GENERIC_WRITE,           // dwDesiredAccess
        FILE_SHARE_READ | FILE_SHARE_WRITE,     // dwShareMode
        NULL,                       // lpSecurityAttributes
        OPEN_EXISTING,              // dwCreationFlags
        FILE_ATTRIBUTE_NORMAL,      // dwFlagsAndAttributes
        INVALID_HANDLE_VALUE        // hTemplateFile
        );
    _AsrpErrExitCode((!mpHandle || INVALID_HANDLE_VALUE == mpHandle), status, GetLastError());

    swprintf(deviceName, ASR_WSZ_DEVICE_PATH_FORMAT, DiskNumber, PartitionNumber);
    
    sizeDeviceName = wcslen(deviceName) * sizeof(WCHAR);
    sizeGuid = wcslen(szVolumeGuid) * sizeof(WCHAR);


    //
    // There is a small window after a partition is created in which the 
    // device-path to it (\Device\HarddiskX\PartitionY) doesn't exist, and
    // a small window in which the device-path is actually pointing to 
    // the wrong object.  (Partmgr first creates the path, <small window>,
    // assigns it to the correct object)
    // 
    // Since this will cause CREATE_POINT to fail later with FILE_NOT_FOUND,
    // lets wait till mountmgr sees the device object.
    //
    result = FALSE;
    while ((!result) && (++attempt < 120)) {

        result = AsrpGetMountPoints(deviceName, sizeDeviceName + sizeof(WCHAR), &mountPointsOut);
        if (!result) {
            Sleep(500);
        }
    }

    outputDeletePoint = (PMOUNTMGR_MOUNT_POINTS) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        ASR_BUFFER_SIZE
        );
    _AsrpErrExitCode(!outputDeletePoint, status, ERROR_NOT_ENOUGH_MEMORY);

    //
    // The mountmgr assigns a volume-GUID symbolic link (\??\Volume{Guid}) to
    // a basic partition as soon as it's created.  In addition, we will re-
    // create the symbolic link that the partition originally used to have 
    // (as stored in asr.sif).
    //
    // This will lead to the partition having two volume-GUID's at the end.
    // This is wasteful, but generally harmless to the system--however, the 
    // ASR test verification scripts get numerous false hits because of the
    // additional GUID.
    //
    // To fix this, we delete the new mountmgr assigned-GUID before restoring 
    // the original GUID for the partition from asr.sif.  
    //
    if ((result) && (mountPointsOut)) {

        for (index = 0; index < mountPointsOut->NumberOfMountPoints; index++) {

            lpName = (PWSTR) (((LPBYTE)mountPointsOut) + mountPointsOut->MountPoints[index].SymbolicLinkNameOffset);
            cbName = (DWORD) mountPointsOut->MountPoints[index].SymbolicLinkNameLength;

            if (!_AsrpIsVolumeGuid(lpName, cbName)) {
                continue;
            }

            //
            // We found a link that looks like a volume GUID 
            //
            cbDeletePoint = sizeof(MOUNTMGR_MOUNT_POINT) +
                mountPointsOut->MountPoints[index].SymbolicLinkNameLength +
                mountPointsOut->MountPoints[index].UniqueIdLength +
                mountPointsOut->MountPoints[index].DeviceNameLength;

            inputDeletePoint = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
                heapHandle,
                HEAP_ZERO_MEMORY,
                cbDeletePoint
                );
            _AsrpErrExitCode(!inputDeletePoint, status, ERROR_NOT_ENOUGH_MEMORY);

            //
            // Set the fields to match the current link
            //
            inputDeletePoint->SymbolicLinkNameOffset = 
                sizeof(MOUNTMGR_MOUNT_POINT);
            inputDeletePoint->SymbolicLinkNameLength = 
                mountPointsOut->MountPoints[index].SymbolicLinkNameLength;
            CopyMemory(
                ((LPBYTE)inputDeletePoint) + 
                    inputDeletePoint->SymbolicLinkNameOffset,
                ((LPBYTE)mountPointsOut) + 
                    mountPointsOut->MountPoints[index].SymbolicLinkNameOffset,
                inputDeletePoint->SymbolicLinkNameLength);

            inputDeletePoint->UniqueIdOffset = 
                inputDeletePoint->SymbolicLinkNameOffset + 
                inputDeletePoint->SymbolicLinkNameLength;
            inputDeletePoint->UniqueIdLength = 
                mountPointsOut->MountPoints[index].UniqueIdLength;
            CopyMemory(
                ((LPBYTE)inputDeletePoint) + 
                    inputDeletePoint->UniqueIdOffset,
                ((LPBYTE)mountPointsOut) + 
                    mountPointsOut->MountPoints[index].UniqueIdOffset,
                inputDeletePoint->UniqueIdLength);

            inputDeletePoint->DeviceNameOffset = 
                inputDeletePoint->UniqueIdOffset +
                inputDeletePoint->UniqueIdLength;
            inputDeletePoint->DeviceNameLength = 
                mountPointsOut->MountPoints[index].DeviceNameLength;
            CopyMemory((
                (LPBYTE)inputDeletePoint) + 
                    inputDeletePoint->DeviceNameOffset,
                ((LPBYTE)mountPointsOut) + 
                    mountPointsOut->MountPoints[index].DeviceNameOffset,
                inputDeletePoint->DeviceNameLength);

            //
            // And delete this link ...
            //
            result = DeviceIoControl(
                mpHandle,
                IOCTL_MOUNTMGR_DELETE_POINTS,
                inputDeletePoint,
                cbDeletePoint,
                outputDeletePoint,
                ASR_BUFFER_SIZE,
                &bytes,
                NULL
                );
            //
            // It's okay if the delete fails.
            //

            GetLastError();     // for debug

            _AsrpHeapFree(inputDeletePoint);
        }
    }


    //
    // Alloc the MountMgr points we need
    //
    inputCreatePoint = (PMOUNTMGR_CREATE_POINT_INPUT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof (MOUNTMGR_CREATE_POINT_INPUT) + sizeDeviceName + sizeGuid
        );
    _AsrpErrExitCode(!inputCreatePoint, status, ERROR_NOT_ENOUGH_MEMORY);

    inputDeletePoint = (PMOUNTMGR_MOUNT_POINT) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeof(MOUNTMGR_MOUNT_POINT) + sizeGuid
        );
    _AsrpErrExitCode(!inputDeletePoint, status, ERROR_NOT_ENOUGH_MEMORY);


    //
    // We should delete this volume guid if some other partition
    // already has it, else we'll get an ALREADY_EXISTS error
    // when we try to create it.
    //
    inputDeletePoint->DeviceNameOffset = 0;
    inputDeletePoint->DeviceNameLength = 0;

    inputDeletePoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    inputDeletePoint->SymbolicLinkNameLength = sizeGuid;

    CopyMemory((((LPBYTE)inputDeletePoint) + inputDeletePoint->SymbolicLinkNameOffset),
        ((LPBYTE)szVolumeGuid), 
        inputDeletePoint->SymbolicLinkNameLength
        );

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_DELETE_POINTS,
        inputDeletePoint,
        sizeof (MOUNTMGR_MOUNT_POINT) + sizeGuid,
        outputDeletePoint,
        ASR_BUFFER_SIZE,
        &bytes,
        NULL
        );
    //
    // It's okay if this fails.
    //
//    _AsrpErrExitCode(!result, status, GetLastError());

    GetLastError();     // for Debug

    //
    // Call IOCTL_MOUNTMGR_CREATE_POINT
    //
    inputCreatePoint->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    inputCreatePoint->SymbolicLinkNameLength = sizeGuid;

    inputCreatePoint->DeviceNameOffset = inputCreatePoint->SymbolicLinkNameOffset + inputCreatePoint->SymbolicLinkNameLength;
    inputCreatePoint->DeviceNameLength = sizeDeviceName;

    CopyMemory(((LPBYTE)inputCreatePoint) + inputCreatePoint->SymbolicLinkNameOffset,
               szVolumeGuid, inputCreatePoint->SymbolicLinkNameLength);

    CopyMemory(((LPBYTE)inputCreatePoint) + inputCreatePoint->DeviceNameOffset,
               deviceName, inputCreatePoint->DeviceNameLength);

    result = DeviceIoControl(
        mpHandle,
        IOCTL_MOUNTMGR_CREATE_POINT,
        inputCreatePoint,
        sizeof (MOUNTMGR_CREATE_POINT_INPUT) + sizeDeviceName + sizeGuid,
        NULL,
        0,
        &bytes,
        NULL
        );
    _AsrpErrExitCode(!result, status, GetLastError());

    //
    // We're done.
    //

EXIT:
    _AsrpCloseHandle(mpHandle);
    _AsrpHeapFree(mountPointsOut);
    _AsrpHeapFree(inputCreatePoint);
    _AsrpHeapFree(inputDeletePoint);
    _AsrpHeapFree(outputDeletePoint);

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Assigns the volume guid's stored in the partition-list to partitions
// on the physical disk, based on the start sectors
//
BOOL
AsrpAssignVolumeGuids(
    IN PASR_DISK_INFO  pPhysicalDisk,
    IN HANDLE          hDisk,           // open handle to the physical disk
    IN PASR_PTN_INFO   pPtnInfo         // list of partitions--with vol guids ...
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{
    PDRIVE_LAYOUT_INFORMATION_EX pDriveLayoutEx = NULL;
    DWORD sizeDriveLayoutEx = pPhysicalDisk->sizeDriveLayoutEx;

    DWORD index = 0,
        status = ERROR_SUCCESS,
        bytes = 0;

    BOOL result = FALSE,
        found = FALSE;

    PASR_PTN_INFO currentPtn = NULL;

    HANDLE heapHandle = GetProcessHeap();

    //
    // Get the new layout for the physical disk.
    //
    pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        sizeDriveLayoutEx
        );
    _AsrpErrExitCode(!pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);

    while (!result) {

        result = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
            NULL,
            0L,
            pDriveLayoutEx,
            sizeDriveLayoutEx,
            &bytes,
            NULL
            );

        if (!result) {
            status = GetLastError();

            _AsrpHeapFree(pDriveLayoutEx);

            // 
            // If the buffer is of insufficient size, resize the buffer.
            //
            if ((ERROR_MORE_DATA == status) || (ERROR_INSUFFICIENT_BUFFER == status)) {

                status = ERROR_SUCCESS;
                sizeDriveLayoutEx += sizeof(PARTITION_INFORMATION_EX) * 4;

                pDriveLayoutEx = (PDRIVE_LAYOUT_INFORMATION_EX) HeapAlloc(
                    heapHandle,
                    HEAP_ZERO_MEMORY,
                    sizeDriveLayoutEx
                    );
                _AsrpErrExitCode(!pDriveLayoutEx, status, ERROR_NOT_ENOUGH_MEMORY);
            }
            else {

                AsrpPrintDbgMsg(_asrlog, 
                    "The drive layout on Harddisk %lu (%ws) could not be determined (%lu).  The volumes on this disk may not be restored completely.\r\n", 
                    pPhysicalDisk->DeviceNumber,
                    pPhysicalDisk->DevicePath,
                    GetLastError()
                    );

                _AsrpErrExitCode(status, status, GetLastError());
            }
        }
    }

    //
    // We have the drive layout.  Now each partition in our list should have
    // an entry in the partition table.  We use the mount manager to set it's
    // volume guid.
    //
    currentPtn = pPtnInfo;
    result = TRUE;
    while (currentPtn) {

        //
        // We only care about partitions that have a volume-guid
        //
        if ((currentPtn->szVolumeGuid) && 
            (wcslen(currentPtn->szVolumeGuid) > 0)
            ) {
        
            //
            // Go through all the partitions on the disk, and find one that 
            // starts at the offset we expect it to.
            //
            found = FALSE;
            index = 0;

            while (!found && (index < pDriveLayoutEx->PartitionCount)) {

                if (pDriveLayoutEx->PartitionEntry[index].StartingOffset.QuadPart
                    == currentPtn->PartitionInfo.StartingOffset.QuadPart) {
                    //
                    // We found the partition, let's set its GUID now
                    //
                    AsrpCreateMountPoint(
                        pPhysicalDisk->DeviceNumber,    // disk number
                        pDriveLayoutEx->PartitionEntry[index].PartitionNumber, // partition number
                        currentPtn->szVolumeGuid    // volumeGuid
                        );

                    found = TRUE;
                }
                else {
                    index++;
                }
            }

            if (!found) {
                result = FALSE;
            }

        }

        currentPtn = currentPtn->pOffsetNext;
    }

    if (!result) {
        //
        // We didn't find a partition
        //

        AsrpPrintDbgMsg(_asrlog, 
            "One or more partitions on Harddisk %lu (%ws) could not be recreated.  The volumes on this disk may not be restored completely.\r\n", 
            pPhysicalDisk->DeviceNumber,
            pPhysicalDisk->DevicePath
            );

        _AsrpErrExitCode(status, status, ERROR_BAD_DEVICE);
    }


EXIT:
    _AsrpHeapFree(pDriveLayoutEx);

    return (BOOL) (ERROR_SUCCESS == status);
}


//
// Re-partitions the disks
//
BOOL
AsrpRecreateDisks(
    IN PASR_DISK_INFO pSifDiskList,
    IN PASR_PTN_INFO_LIST pSifMbrPtnList,
    IN PASR_PTN_INFO_LIST pSifGptPtnList,
    IN BOOL AllOrNothing
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{


    PASR_DISK_INFO  pSifDisk        = pSifDiskList;

    DWORD           bytesReturned   = 0,
                    status          = ERROR_SUCCESS;

    HANDLE          hDisk           = NULL;

    BOOL            result          = TRUE;

    //
    // For each sif disk that isn't intact, go to the physical
    // disk it's assigned to, and recreate that disk
    //
    while (pSifDisk) {

        if (!(pSifDisk->AssignedTo)) {

            AsrpPrintDbgMsg(_asrinfo, 
                "Not recreating disk %lu in section [%ws] (no matching disk found).\r\n", 
                pSifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            if (AllOrNothing) {
                return FALSE;
            }
            else {
                pSifDisk = pSifDisk->pNext;
                continue;
            }
        }

        if ((pSifDisk->IsCritical) ||
            (pSifDisk->AssignedTo->IsCritical)) {

            AsrpPrintDbgMsg(_asrinfo, 
                "Not recreating Harddisk %lu (disk %lu in section [%ws]) (critical disk).\r\n", 
                pSifDisk->AssignedTo->DeviceNumber,
                pSifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION)
                );

            pSifDisk = pSifDisk->pNext;
            continue;
        }

        //
        // Open physical disk
        //
        hDisk = CreateFileW(
            pSifDisk->AssignedTo->DevicePath,   // lpFileName
            GENERIC_WRITE | GENERIC_READ,       // dwDesiredAccess
            FILE_SHARE_READ | FILE_SHARE_WRITE, // dwShareMode
            NULL,           // lpSecurityAttributes
            OPEN_EXISTING,  // dwCreationFlags
            0,              // dwFlagsAndAttributes
            NULL            // hTemplateFile
            );
        if ((!hDisk) || (INVALID_HANDLE_VALUE == hDisk)) {
            //
            // We couldn't open the disk.
            //

            AsrpPrintDbgMsg(_asrlog, 
                "Unable to open Harddisk %lu (%ws) (disk %lu in section [%ws]) (0%lu).\r\n", 
                pSifDisk->AssignedTo->DeviceNumber,
                pSifDisk->AssignedTo->DevicePath,
                pSifDisk->SifDiskKey,
                ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                GetLastError()
                );

            if (AllOrNothing) {
                return FALSE;
            }
            else {
                pSifDisk = pSifDisk->pNext;
                continue;
            }
        }


        if (!(pSifDisk->IsIntact) &&            // disk is not intact
            (pSifDisk->AssignedTo) &&           // matching physical disk was found
            ((PARTITION_STYLE_MBR == pSifDisk->Style) || (PARTITION_STYLE_GPT == pSifDisk->Style))    // not recognised partitioning style
            ) {

            //
            // Delete the old drive layout
            //
            result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_DELETE_DRIVE_LAYOUT,
                NULL,
                0L,
                NULL,
                0L,
                &bytesReturned,
                NULL
                );
            if (!result) {

                AsrpPrintDbgMsg(_asrlog, 
                    "Unable to delete layout on Harddisk %lu (%ws) (disk %lu in section [%ws]) (%lu).\r\n", 
                    pSifDisk->AssignedTo->DeviceNumber,
                    pSifDisk->AssignedTo->DevicePath,
                    pSifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                    GetLastError()
                    );

                GetLastError();
            }

            //
            //  If we're converting an MBR to a GPT, then we need to call
            //  IOCTL_DISK_CREATE_DISK first
            //

            if ((PARTITION_STYLE_GPT == pSifDisk->Style) &&
                (PARTITION_STYLE_MBR == pSifDisk->AssignedTo->Style)) {

                CREATE_DISK CreateDisk;

                CreateDisk.PartitionStyle = PARTITION_STYLE_GPT;
                memcpy(&(CreateDisk.Gpt.DiskId), &(pSifDisk->pDriveLayoutEx->Gpt.DiskId), sizeof(GUID));
                CreateDisk.Gpt.MaxPartitionCount =  pSifDisk->pDriveLayoutEx->Gpt.MaxPartitionCount;

                result = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_CREATE_DISK,
                    &(CreateDisk),
                    sizeof(CREATE_DISK),
                    NULL,
                    0L,
                    &bytesReturned,
                    NULL
                    );

                if (!result) {
                    //
                    // CREATE_DISK failed
                    //

                    status = GetLastError();
                    AsrpPrintDbgMsg(_asrlog, 
                        "Unable to initialize disk layout on Harddisk %lu (%ws) (disk %lu in section [%ws]) (0%lu).\r\n", 
                        pSifDisk->AssignedTo->DeviceNumber,
                        pSifDisk->AssignedTo->DevicePath,
                        pSifDisk->SifDiskKey,
                        ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                        GetLastError()
                        );

                    _AsrpCloseHandle(hDisk);
                    SetLastError(status);

                    if (AllOrNothing) {
                        return FALSE;
                    }
                    else {
                        pSifDisk = pSifDisk->pNext;
                        continue;
                    }
                }
            }

            //
            // Set the new drive layout
            //
            result = DeviceIoControl(
                hDisk,
                IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
                pSifDisk->AssignedTo->pDriveLayoutEx,
                pSifDisk->AssignedTo->sizeDriveLayoutEx,
                NULL,
                0L,
                &bytesReturned,
                NULL
                );

            if (!result) {
                //
                // SET_DRIVE_LAYOUT failed
                //
                status = GetLastError();
                AsrpPrintDbgMsg(_asrlog, 
                    "Unable to set drive layout on Harddisk %lu (%ws) (disk %lu in section [%ws]) (0%lu).\r\n", 
                    pSifDisk->AssignedTo->DeviceNumber,
                    pSifDisk->AssignedTo->DevicePath,
                    pSifDisk->SifDiskKey,
                    ((PARTITION_STYLE_MBR == pSifDisk->Style) ? ASR_SIF_MBR_DISKS_SECTION : ASR_SIF_GPT_DISKS_SECTION),
                    GetLastError()
                    );

                _AsrpCloseHandle(hDisk);
                SetLastError(status);

                if (AllOrNothing) {
                    return FALSE;
                }
                else {
                    pSifDisk = pSifDisk->pNext;
                    continue;
                }
            }
        }

        //
        // Now we need to recreate the volumeGuids for each partition
        //
        result = AsrpAssignVolumeGuids(
            pSifDisk->AssignedTo,
            hDisk,
            ((PARTITION_STYLE_MBR == pSifDisk->Style) ?
                (pSifMbrPtnList[pSifDisk->SifDiskKey].pOffsetHead) :
                (pSifGptPtnList[pSifDisk->SifDiskKey].pOffsetHead))
            );

        //
        // We don't care about the result ...
        //
        MYASSERT(result && L"AsrpAssignVolumeGuids failed");

        _AsrpCloseHandle(hDisk);

        //
        // Get the next drive from the drive list.
        //
        pSifDisk = pSifDisk->pNext;
    }

    return TRUE;
}


//
//  Restore Non Critical Disks
//
//
BOOL
AsrpRestoreNonCriticalDisksW(
    IN PCWSTR   lpSifPath,
    IN BOOL     bAllOrNothing
    )

/*++

Routine Description:

    

Arguments:

    

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    BOOL    result = FALSE;

    PWSTR   asrSifPath      = NULL;

    //
    // We have two lists of disks--one of all the physical disks
    // currently on the system, and the other constructed from the
    // sif file.  The goal is to reconfigure non-critical disks in
    // the pPhysicalDiskList to match the pSifDiskList
    //
    PASR_DISK_INFO pSifDiskList = NULL,
        pPhysicalDiskList = NULL;

    PASR_PTN_INFO_LIST  pSifMbrPtnList = NULL,
        pSifGptPtnList = NULL;

    DWORD  cchAsrSifPath = 0,
        MaxDeviceNumber = 0,     // not used
        status = ERROR_SUCCESS;

    BOOL    bAutoExtend = FALSE,
        allOrNothing = FALSE;

    HANDLE  heapHandle = GetProcessHeap();

    SetLastError(ERROR_CAN_NOT_COMPLETE);

    if (!AsrIsEnabled()) {
        //
        // If we're not in GUI-mode ASR, we need to open the log files first
        //
        AsrpInitialiseErrorFile();
        AsrpInitialiseLogFile();
    }

    AsrpPrintDbgMsg(_asrlog, "Attempting to restore non-critical disks.\r\n");

    if (!lpSifPath) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EXIT;
    }

    cchAsrSifPath = wcslen(lpSifPath);
    //
    // Do a sanity check:  we don't want to allow a file path
    // more than 4096 characters long.
    //
    if (cchAsrSifPath > ASR_SIF_ENTRY_MAX_CHARS) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto EXIT;
    }

    asrSifPath = (PWSTR) HeapAlloc(
        heapHandle,
        HEAP_ZERO_MEMORY,
        ((cchAsrSifPath + 1) * sizeof(WCHAR))
        );
    _AsrpErrExitCode(!asrSifPath, status, ERROR_NOT_ENOUGH_MEMORY);

    wcsncpy(asrSifPath, lpSifPath, cchAsrSifPath);

    allOrNothing = bAllOrNothing;

    AsrpPrintDbgMsg(_asrlog, "ASR state file: \"%ws\".  AllOrNothing: %lu\r\n",
        asrSifPath, allOrNothing);

    //
    // The function calls are AND'ed below, hence if one fails, the
    // calls after it will not be executed (exactly the behaviour we
    // want).
    //
    result = (

        //
        // Build the original disk info from the sif file
        //
        AsrpBuildMbrSifDiskList(asrSifPath, &pSifDiskList, &pSifMbrPtnList, &bAutoExtend)

        && AsrpBuildGptSifDiskList(asrSifPath, &pSifDiskList, &pSifGptPtnList)

        //
        // Build the list of current disks present on the target machine
        //
        && AsrpInitDiskInformation(&pPhysicalDiskList)

        //
        // Fill in the partition info for the fixed disks on the target machine
        // and remove non-fixed devices
        //
        && AsrpInitLayoutInformation(NULL, pPhysicalDiskList, &MaxDeviceNumber, TRUE, FALSE)

        && AsrpFreeNonFixedMedia(&pPhysicalDiskList)

        //
        // Try to determine which sif disk should end up on which physical disk.
        //
        && AsrpAssignDisks(pSifDiskList, pPhysicalDiskList, pSifMbrPtnList, pSifGptPtnList, allOrNothing, bAutoExtend)

        //
        // Finally, repartition the disks and assign the volume guids
        //
        && AsrpRecreateDisks(pSifDiskList, pSifMbrPtnList, pSifGptPtnList, allOrNothing)
    );

    status = GetLastError();
    AsrpFreeStateInformation(&pSifDiskList, NULL);
    AsrpFreeStateInformation(&pPhysicalDiskList, NULL);
    AsrpFreePartitionList(&pSifMbrPtnList);
    AsrpFreePartitionList(&pSifGptPtnList);
    SetLastError(status);

EXIT:

    status = GetLastError();

    if (result) {
        AsrpPrintDbgMsg(_asrinfo, "Done restoring non-critical disks.\r\n");
    }
    else {
        
        AsrpPrintDbgMsg(_asrerror, "Error restoring non-critical disks.  (0x%x)\r\n", status);
        
        if (ERROR_SUCCESS == status) {
            //
            // We're going to return failure, but we haven't set the LastError to 
            // a failure code.  This is bad, since we have no clue what went wrong.
            //
            // We shouldn't ever get here, because the function returning FALSE above
            // should set the LastError as it sees fit.
            // 
            // But I've added this in just to be safe.  Let's set it to a generic
            // error.
            //
            MYASSERT(0 && L"Returning failure, but LastError is not set");
            status = ERROR_CAN_NOT_COMPLETE;
        }
    }

    if (!AsrIsEnabled()) {
        AsrpCloseLogFiles();
    }

    _AsrpHeapFree(asrSifPath);

    SetLastError(status);
    return result;
}


BOOL
AsrpRestoreTimeZoneInformation(
    IN PCWSTR   lpSifPath
    )
/*++

Routine Description:

    Sets the current time-zone, based on the information stored in the SYSTEMS
    section of the ASR state file.

Arguments:

    lpSifPath - Null-terminated string containing the full path to the ASR
            state file (including file name).

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero. To get extended error 
        information, call GetLastError().

--*/

{

    HINF hSif = NULL;

    BOOL result = FALSE;

    DWORD reqdSize = 0,
        status = ERROR_SUCCESS;

    INFCONTEXT infSystemContext;

    TIME_ZONE_INFORMATION TimeZoneInformation;

    WCHAR szTimeZoneInfo[ASR_SIF_ENTRY_MAX_CHARS+1];

    ZeroMemory(&infSystemContext, sizeof(INFCONTEXT));
    ZeroMemory(&TimeZoneInformation, sizeof(TIME_ZONE_INFORMATION));
    ZeroMemory(&szTimeZoneInfo, sizeof(WCHAR)*(ASR_SIF_ENTRY_MAX_CHARS+1));

    //
    // Open the sif
    //
    hSif = SetupOpenInfFileW(lpSifPath, NULL, INF_STYLE_WIN4, NULL);
    if (NULL == hSif || INVALID_HANDLE_VALUE == hSif) {
        return FALSE;       // sif file couldn't be opened
    }

    //
    // Get the TimeZone strings value
    //
    result = SetupFindFirstLineW(hSif, ASR_SIF_SYSTEM_SECTION, NULL, &infSystemContext);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // no system section: corrupt asr.sif?
 
    result = SetupGetStringFieldW(&infSystemContext, 7, szTimeZoneInfo, ASR_SIF_ENTRY_MAX_CHARS+1, &reqdSize);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

    swscanf(szTimeZoneInfo,
        L"%ld %ld %ld %hd-%hd-%hd-%hd %hd:%hd:%hd.%hd %hd-%hd-%hd-%hd %hd:%hd:%hd.%hd",
        &(TimeZoneInformation.Bias),
        &(TimeZoneInformation.StandardBias),
        &(TimeZoneInformation.DaylightBias),

        &(TimeZoneInformation.StandardDate.wYear),
        &(TimeZoneInformation.StandardDate.wMonth),
        &(TimeZoneInformation.StandardDate.wDayOfWeek),
        &(TimeZoneInformation.StandardDate.wDay),

        &(TimeZoneInformation.StandardDate.wHour),
        &(TimeZoneInformation.StandardDate.wMinute),
        &(TimeZoneInformation.StandardDate.wSecond),
        &(TimeZoneInformation.StandardDate.wMilliseconds),

        &(TimeZoneInformation.DaylightDate.wYear),
        &(TimeZoneInformation.DaylightDate.wMonth),
        &(TimeZoneInformation.DaylightDate.wDayOfWeek),
        &(TimeZoneInformation.DaylightDate.wDay),

        &(TimeZoneInformation.DaylightDate.wHour),
        &(TimeZoneInformation.DaylightDate.wMinute),
        &(TimeZoneInformation.DaylightDate.wSecond),
        &(TimeZoneInformation.DaylightDate.wMilliseconds)
        );

    result = SetupGetStringFieldW(&infSystemContext, 8, TimeZoneInformation.StandardName, 32, &reqdSize);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

    result = SetupGetStringFieldW(&infSystemContext, 9, TimeZoneInformation.DaylightName, 32, &reqdSize);
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

    result = SetTimeZoneInformation(&TimeZoneInformation);
    if (!result) {
        GetLastError();
    }
    _AsrpErrExitCode(!result, status, ERROR_INVALID_DATA);      // corrupt asr.sif?

EXIT:

    if (ERROR_SUCCESS != status) {
        SetLastError(status);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\copy.c ===
#include "setupp.h"
#pragma hdrstop

#if 0 // This function appears to never be used.
BOOL
EnqueueFileCopies(
    IN HINF     hInf,
    IN HSPFILEQ FileQ,
    IN PCWSTR   Section,
    IN PCWSTR   TargetRoot
    )
{
    INFCONTEXT InfContext;
    BOOL LineExists;
    WCHAR System32Dir[MAX_PATH];
    PCWSTR SourceFilename,TargetFilename;
    BOOL b;

    GetSystemDirectory(System32Dir,MAX_PATH);
    LineExists = SetupFindFirstLine(hInf,Section,NULL,&InfContext);
    while(LineExists) {

        //
        // Fetch source and target filenames.
        //
        TargetFilename = pSetupGetField(&InfContext,1);
        if(!TargetFilename) {
            return(FALSE);
        }

        SourceFilename = pSetupGetField(&InfContext,2);
        if(!SourceFilename) {
            SourceFilename = TargetFilename;
        }

        //
        // Enqueue the file for copy.
        //
        b = SetupQueueCopy(
                FileQ,
                System32Dir,
                NULL,
                SourceFilename,
                NULL,
                NULL,
                TargetRoot,
                TargetFilename,
                BaseCopyStyle
                );

        if(!b) {
            return(FALSE);
        }
        LineExists = SetupFindNextLine(&InfContext,&InfContext);
    }

    return(TRUE);
}
#endif

BOOL
SideBySidePopulateCopyQueue(
    SIDE_BY_SIDE*     Sxs,
    HSPFILEQ          FileQ,                    OPTIONAL
    PCWSTR            AssembliesRootSource      OPTIONAL
    )
{
    BOOL                    Success = FALSE;
    UINT                    SourceId = 0;
    WCHAR                   DiskNameBuffer[MAX_PATH];
    WCHAR                   PromptForSetupPath[MAX_PATH];
    WCHAR                   AssembliesRootDirectoryFound[MAX_PATH];
    DWORD                   cchAssembliesRootDirectoryFound = sizeof(AssembliesRootDirectoryFound);
    DWORD                   Err;
    WCHAR                   AssembliesRootDirectory[MAX_PATH];
    PCWSTR                  InfField = NULL;
    INFCONTEXT              InfContext = {0};
    BOOL                    LineExists = FALSE;
    SXS_INSTALLW            InstallData;
    SXS_INSTALL_REFERENCEW  InstallReference;
    ASSERT(Sxs != NULL);

    //
    // we depend on these having been initialized, and we are not supposed to
    // be called in MiniSetup or OobeSetup
    //
    ASSERT(SourcePath[0] != 0);
    ASSERT(SyssetupInf != NULL);
    ASSERT(SyssetupInf != INVALID_HANDLE_VALUE);
    ASSERT(!MiniSetup);
    ASSERT(!OobeSetup);

    //
    // first, don't fail to give safe values, since we always try to cleanup
    //
    Sxs->Dll = NULL;
    Sxs->BeginAssemblyInstall = NULL;
    Sxs->EndAssemblyInstall = NULL;
    Sxs->InstallW = NULL;
    Sxs->Context = NULL;

    //
    // then commence with initialization that can fail
    //
    if (!(Sxs->Dll = LoadLibraryW(SXS_DLL_NAME_W))) {
        goto Exit;
    }
    if (!(Sxs->BeginAssemblyInstall = (PSXS_BEGIN_ASSEMBLY_INSTALL)GetProcAddress(Sxs->Dll, SXS_BEGIN_ASSEMBLY_INSTALL))) {
        goto Exit;
    }
    if (!(Sxs->EndAssemblyInstall = (PSXS_END_ASSEMBLY_INSTALL)GetProcAddress(Sxs->Dll, SXS_END_ASSEMBLY_INSTALL))) {
        goto Exit;
    }
    if (!(Sxs->InstallW = (PSXS_INSTALL_W)GetProcAddress(Sxs->Dll, SXS_INSTALL_W))) {
        goto Exit;
    }

    if (!Sxs->BeginAssemblyInstall(
        SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NOT_TRANSACTIONAL
        | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_NO_VERIFY
        | SXS_BEGIN_ASSEMBLY_INSTALL_FLAG_REPLACE_EXISTING,
        (FileQ != NULL) ? SXS_INSTALLATION_FILE_COPY_CALLBACK_SETUP_COPY_QUEUE : NULL,
        FileQ, // callback context
        NULL, // impersonation callback
        NULL, // impersonation context
        &Sxs->Context
        )) {
        goto Exit;
    }

    //
    // Set up the reference data to indicate that all of these are OS-installed
    // assemblies.
    //
    ZeroMemory(&InstallReference, sizeof(InstallReference));
    InstallReference.cbSize = sizeof(InstallReference);
    InstallReference.dwFlags = 0;
    InstallReference.guidScheme = SXS_INSTALL_REFERENCE_SCHEME_OSINSTALL;

    //
    // Let's get the source disk name of this assembly - we'll need it to
    // pass around as the prompt.
    //
    if ( !SetupGetSourceFileLocation(
        SyssetupInf,
        NULL,
        L"shell32.dll",
        &SourceId,
        NULL,
        0,
        NULL
    ) )
        goto Exit;

    if ( !SetupGetSourceInfo(
        SyssetupInf,
        SourceId,
        SRCINFO_DESCRIPTION,
        DiskNameBuffer,
        sizeof(DiskNameBuffer)/sizeof(WCHAR),
        NULL
    ) )
        goto Exit;


    if (AssembliesRootSource) {

        //
        // Set up the structure to call off to the installer
        //
        memset(&InstallData, 0, sizeof(InstallData));
        InstallData.cbSize = sizeof(InstallData);
        InstallData.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY | 
            SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | 
            SXS_INSTALL_FLAG_REFERENCE_VALID | 
            SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
            SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
            SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
            SXS_INSTALL_FLAG_CODEBASE_URL_VALID;
            
        InstallData.lpReference = &InstallReference;
        InstallData.lpRefreshPrompt = DiskNameBuffer;
        InstallData.pvInstallCookie = Sxs->Context;
        InstallData.lpCodebaseURL = AssembliesRootSource;
        InstallData.lpManifestPath = AssembliesRootSource;

        if (!Sxs->InstallW(&InstallData)) {
            // abort call will be made in SideBySideFinish
            goto Exit;
        }
        
    } else {

        //
        // Now let's install any asms dirs left over.  These are no longer required, as
        // the payload of assemblies should be mostly carried in the cab files
        // used above.  Hence, the checks to ensure the directories are there has been
        // removed.
        //
        LineExists = SetupFindFirstLine(SyssetupInf, SXS_INF_ASSEMBLY_DIRECTORIES_SECTION_NAME_W, NULL, &InfContext);
        while(LineExists) {
            DWORD  FileAttributes = 0;
            //
            // convention introduced specifically for side by side, so that
            // x86 files on ia64 might come from \i386\asms instead of \ia64\asms\i386,
            // depending on what dosnet.inf and syssetup.inf say:
            //   a path that does not start with a slash is appended to \$win_nt$.~ls\processor;
            //   a path that does     start with a slash is appended to \$win_nt$.~ls
            //
            InfField = pSetupGetField(&InfContext, 0);
            if(InfField == NULL) {
                break;
            }

            // c:\$win_nt$.~ls
            lstrcpyn(AssembliesRootDirectory, SourcePath, MAX_PATH);
            if (InfField[0] == '\\' || InfField[0] == '/') {
                InfField += 1;
            } else {
                 // c:\$win_nt$.~ls\i386
                if (!pSetupConcatenatePaths(AssembliesRootDirectory, PlatformName, MAX_PATH, NULL)) {
                    goto Exit;
                }
            }

            // stash this away for a little bit
            lstrcpyn( PromptForSetupPath, AssembliesRootDirectory, MAX_PATH );
#if 0
            //
            // For now, while "staging", we allow the directory to not exist, and to be
            // empty (emptiness is silently handled elsewhere by common code), but
            // comctl32 will be in an assembly, so assemblies will be mandatory
            // for the system to boot to Explorer.exe.
            //
            // 11/09/2000 (jonwis) If we can't find the assemblies root directory, prompt
            //      for the installation media.  This is ripped straight from the headlines
            //      of crypto.c and cmdline.c.
            //
            for (;;) {

                Err = SetupPromptForDisk(
                    MainWindowHandle,           // Main window handle
                    NULL,                       // Dialog title (defaulted)
                    DiskNameBuffer,             // Name of the disk to request
                    PromptForSetupPath,         // Full path of the asms root
                    InfField,                   // We look to see if the dir is there
                    NULL,                       // No tag file
                    IDF_CHECKFIRST | IDF_NOSKIP | IDF_NODETAILS | IDF_NOBROWSE,
                    AssembliesRootDirectoryFound,       // What we'll use to install
                    cchAssembliesRootDirectoryFound,    // How long is that buffer?
                    NULL
                );

                // See if what we got back from the prompt is success - if so, is the directory
                // really there? We might assume that it is if we get back _SUCCESS...
                if ( Err == DPROMPT_SUCCESS ) {
                    FileAttributes = GetFileAttributes(AssembliesRootDirectoryFound);
                    if ((FileAttributes != 0xFFFFFFFF) && (FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                        // copy out the asms directory location that was found, and
                        // stop looking.
                        lstrcpyn(AssembliesRootDirectory, AssembliesRootDirectoryFound, MAX_PATH);
                        break;
                    }
                } else {
                    break;
                }

            };

            // c:\$win_nt$.~ls\i386\asms
            if (!pSetupConcatenatePaths(AssembliesRootDirectory, InfField, MAX_PATH, NULL)) {
                goto Exit;
            }

            //
            // If we didn't get a success (ie: we broke out of the loop), fail the
            // installation.  Heinous, but MarianT (setup dev) suggests this is the
            // best method.
            //
            if ( Err != DPROMPT_SUCCESS )
                goto Exit;
#else

            if (!pSetupConcatenatePaths(AssembliesRootDirectory, InfField, MAX_PATH, NULL))
                goto Exit;
                
            FileAttributes = GetFileAttributes(AssembliesRootDirectory);

            // If the path isn't a directory, or doesn't exist, then continue on to the next
            // entry in the inf.
            if ((FileAttributes == INVALID_FILE_ATTRIBUTES) ||
                ((FileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
            {
                LineExists = SetupFindNextLine(&InfContext, &InfContext);
                continue;
            }

#endif
            //
            // Set up this structure to call off into SXS to do the installation 
            // for us.
            //
            ZeroMemory(&InstallData, sizeof(InstallData));
            InstallData.cbSize = sizeof(InstallData);
            InstallData.dwFlags = SXS_INSTALL_FLAG_FROM_DIRECTORY | 
                SXS_INSTALL_FLAG_FROM_DIRECTORY_RECURSIVE | 
                SXS_INSTALL_FLAG_REFERENCE_VALID | 
                SXS_INSTALL_FLAG_REFRESH_PROMPT_VALID |
                SXS_INSTALL_FLAG_INSTALL_COOKIE_VALID |
                SXS_INSTALL_FLAG_INSTALLED_BY_OSSETUP |
                SXS_INSTALL_FLAG_CODEBASE_URL_VALID;

            InstallData.lpManifestPath = AssembliesRootDirectory;
            InstallData.lpReference = &InstallReference;
            InstallData.lpRefreshPrompt = DiskNameBuffer;
            InstallData.pvInstallCookie = Sxs->Context;
            InstallData.lpCodebaseURL = SourcePath;
            
            if (!Sxs->InstallW( &InstallData )) {
                // abort call will be made in SideBySideFinish
                goto Exit;
            }

            LineExists = SetupFindNextLine(&InfContext, &InfContext);
        }
    }

    Success = TRUE;
Exit:
    return Success;
}

BOOL
SideBySideFinish(
    SIDE_BY_SIDE*     Sxs,
    BOOL              fSuccess
    )
{
#define FUNCTION L"SideBySideFinish"
    DWORD dwLastError = NO_ERROR;
    ASSERT(Sxs != NULL);
    //
    // failure to load the .dll or get entry points implies lack of success
    //
    ASSERT(Sxs->Dll != NULL || !fSuccess);
    ASSERT(Sxs->EndAssemblyInstall != NULL || !fSuccess);

    if (!fSuccess) {
        dwLastError = GetLastError();
    }
    if (Sxs->Context != NULL) {
        if (Sxs->EndAssemblyInstall != NULL) {
            if (!Sxs->EndAssemblyInstall(
                    Sxs->Context,
                    fSuccess ? SXS_END_ASSEMBLY_INSTALL_FLAG_COMMIT : SXS_END_ASSEMBLY_INSTALL_FLAG_ABORT,
                    NULL // reserved out DWORD
                    )) {
                if (fSuccess) {
                    fSuccess = FALSE;
                    dwLastError = GetLastError();
                }
            }
        }
        Sxs->Context = NULL;
    }
    if (Sxs->Dll != NULL) {
        if (!FreeLibrary(Sxs->Dll)) {
            if (fSuccess) {
                fSuccess = FALSE;
                dwLastError = GetLastError();
            }
        }
        Sxs->Dll = NULL;
    }

    if (!fSuccess) {
        SetLastError(dwLastError);
    }

    return fSuccess;
#undef FUNCTION    
}


BOOL
SideBySideCreateSyssetupContext(
    VOID
    )
{
#define FUNCTION L"SideBySideCreateSyssetupContext"

    BOOL fSuccess = FALSE;
    ACTCTXW CreateActCtxParams;
    HANDLE  ActCtxHandle;

    CreateActCtxParams.cbSize = sizeof(CreateActCtxParams);
    CreateActCtxParams.dwFlags = (ACTCTX_FLAG_RESOURCE_NAME_VALID | ACTCTX_FLAG_SET_PROCESS_DEFAULT);
    CreateActCtxParams.lpResourceName = SXS_MANIFEST_RESOURCE_ID;
    ASSERT(MyModuleFileName[0] != 0);
    CreateActCtxParams.lpSource = MyModuleFileName;
    //
    // The error value is INVALID_HANDLE_VALUE.
    // ACTCTX_FLAG_SET_PROCESS_DEFAULT has nothing to return upon success, so it returns NULL.
    // There is nothing to cleanup upon ACTCTX_FLAG_SET_PROCESS_DEFAULT success, the data
    // is referenced in the PEB, and lasts till process shutdown.
    //
    ActCtxHandle = CreateActCtxW(&CreateActCtxParams);
    if (ActCtxHandle == INVALID_HANDLE_VALUE) {
        fSuccess = FALSE;
        SetupDebugPrint1(L"SETUP: CreateActCtxW failed in " FUNCTION L", LastError is %d\n", GetLastError());
        goto Exit;
    }
    ASSERT(ActCtxHandle == NULL);

    fSuccess = TRUE;
Exit:
    return fSuccess;
#undef FUNCTION
}

BOOL
CopySystemFiles(
    VOID
    )
{
    BOOL b;
    HINF hInf;
    HSPFILEQ FileQ;
    PVOID Context;
    WCHAR Dir[MAX_PATH];
    DWORD ScanQueueResult;

    b = FALSE;
    //hInf = SetupOpenInfFile(L"filelist.inf",NULL,INF_STYLE_WIN4,NULL);
    hInf = SyssetupInf;
    if(hInf != INVALID_HANDLE_VALUE) {

        FileQ = SetupOpenFileQueue();
        if(FileQ != INVALID_HANDLE_VALUE) {

            b =  SetupInstallFilesFromInfSection(
                     SyssetupInf,
                     NULL,
                     FileQ,
                     Win31Upgrade
                      ? L"Files.Install.CleanInstall.Win31"
                      : L"Files.Install.CleanInstall",
                     NULL,
                     BaseCopyStyle
                     );
            //
            //  Do the installation of class installers
            //  We do this here because the installation of class intallers may involve
            //  file copy. And in this case we can use the existing progress bar.
            //
            InstallPnpClassInstallers( MainWindowHandle,
                                                hInf,
                                                FileQ );

#if 0

            //
            // This feature is going away, because we're going to
            // build the delete file list using rules
            //

            if(Win95Upgrade) {
                b = b && SetupQueueDeleteSectionW(
                             FileQ,
                             hInf,
                             0,
                             L"Files.DeleteWin9x.System"
                             );

                b = b && SetupQueueDeleteSectionW(
                             FileQ,
                             hInf,
                             0,
                             L"Files.DeleteWin9x.Sysroot"
                             );

            }
#endif

            if(b) {
                b = FALSE;
                if(Context = InitSysSetupQueueCallbackEx(MainWindowHandle,
                    INVALID_HANDLE_VALUE,0,0,NULL)) {

                    if(!SetupScanFileQueue(
                           FileQ,
                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                           MainWindowHandle,
                           NULL,
                           NULL,
                           &ScanQueueResult)) {
                            //
                            // SetupScanFileQueue should really never
                            // fail when you don't ask it to call a
                            // callback routine, but if it does, just
                            // go ahead and commit the queue.
                            //
                            ScanQueueResult = 0;
                        }


                    if( ScanQueueResult != 1 ){
                        b = SetupCommitFileQueue(MainWindowHandle,FileQ,SysSetupQueueCallback,Context);
                    }

                    TermSysSetupQueueCallback(Context);
                }
            }

            SetupCloseFileQueue(FileQ);
        }

        //SetupCloseInfFile(hInf);
    }

    return(b);
}


BOOL
UpgradeSystemFiles(
    VOID
    )
{
    BOOL b;
    HINF hInf;
    HSPFILEQ FileQ;
    PVOID Context;
    WCHAR Dir[MAX_PATH];
    DWORD ScanQueueResult;

    b = FALSE;
    //hInf = SetupOpenInfFile(L"filelist.inf",NULL,INF_STYLE_WIN4,NULL);
    hInf = SyssetupInf;
    if(hInf != INVALID_HANDLE_VALUE) {

        FileQ = SetupOpenFileQueue();
        if(FileQ != INVALID_HANDLE_VALUE) {

            b =  SetupInstallFilesFromInfSection(
                                 SyssetupInf,
                                 NULL,
                                 FileQ,
                                 Win31Upgrade
                                  ? L"Files.Install.Upgrade.Win31"
                                  : L"Files.Install.Upgrade",
                                 NULL,
                                 BaseCopyStyle
                                 );

            //
            //  Do the installation of class installers
            //  We do this here because the installation of class intallers may involve
            //  file copy. And in this case we can use the existing progress bar.
            //
            InstallPnpClassInstallers( MainWindowHandle,
                                                hInf,
                                                FileQ );

            if(b) {
                b = FALSE;
                if(Context = InitSysSetupQueueCallbackEx(MainWindowHandle,
                    INVALID_HANDLE_VALUE,0,0,NULL)) {

                    if(!SetupScanFileQueue(
                           FileQ,
                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                           MainWindowHandle,
                           NULL,
                           NULL,
                           &ScanQueueResult)) {
                            //
                            // SetupScanFileQueue should really never
                            // fail when you don't ask it to call a
                            // callback routine, but if it does, just
                            // go ahead and commit the queue.
                            //
                            ScanQueueResult = 0;
                        }


                    if( ScanQueueResult != 1 ){
                        b = SetupCommitFileQueue(MainWindowHandle,FileQ,SysSetupQueueCallback,Context);
                    }

                    TermSysSetupQueueCallback(Context);
                }
            }

            SetupCloseFileQueue(FileQ);
        }

        //SetupCloseInfFile(hInf);
    }

    return(b);
}

VOID
MarkFilesReadOnly(
    VOID
    )
{
    WCHAR       OldCurrentDir[MAX_PATH];
    WCHAR       System32Dir[MAX_PATH];
    LPCTSTR     SectionName;
    LONG        LineCount;
    LONG        ItemNo;
    INFCONTEXT  InfContext;
    BOOL        b;


    ASSERT( SyssetupInf != INVALID_HANDLE_VALUE );

    //
    // Set current directory to system32.
    // Preserve current directory to minimize side-effects.
    //
    if(!GetCurrentDirectory(MAX_PATH,OldCurrentDir)) {
        OldCurrentDir[0] = 0;
    }
    GetSystemDirectory(System32Dir,MAX_PATH);
    SetCurrentDirectory(System32Dir);

    //
    // Now go through the list of files.
    //
    SectionName = L"Files.MarkReadOnly";
    LineCount = SetupGetLineCount( SyssetupInf, SectionName );
    for( ItemNo=0; ItemNo<LineCount; ItemNo++ ) {
        if( SetupGetLineByIndex( SyssetupInf, SectionName, ItemNo, &InfContext )) {

            b = SetFileAttributes(
                pSetupGetField( &InfContext, 0 ),
                FILE_ATTRIBUTE_READONLY );

            if (b) {
                SetupDebugPrint1( L"SETUP: Marked file %ls read-only",
                    pSetupGetField( &InfContext, 0 ) );
            } else {
                SetupDebugPrint1( L"SETUP: Could not mark file %ls read-only",
                    pSetupGetField( &InfContext, 0 ) );
            }
        }
    }

    //
    // Reset current directory and return.
    //
    if(OldCurrentDir[0]) {
        SetCurrentDirectory(OldCurrentDir);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\debug.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Diagnositc/debug routines for Windows NT Setup module.

Author:

    Ted Miller (tedm) 31-Mar-1995

Revision History:

--*/

#include "setupp.h"
#pragma hdrstop

//
// This can be turned on in the debugger so that we get debug spew on free builds.
//
bWriteDebugSpew = FALSE;

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(MyModuleHandle,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}


#endif


VOID
pSetupDebugPrint(
    PWSTR FileName,
    ULONG LineNumber,
    PWSTR TagStr,
    PWSTR FormatStr,
    ...
    )
{
    static WCHAR buf[4096];
    static HANDLE hFile = NULL;
    va_list arg_ptr;
    ULONG Bytes;
    PWSTR s,p;
    PSTR str;
    SYSTEMTIME CurrTime;
    DWORD Result;


    //
    // Note: If hFile is NULL, that means it's the first time we've been called,
    // and we may want to open the log file.  If we set hFile to
    // INVALID_HANDLE_VALUE, that means we've decided not to write to the file.
    //

#if DBG
    {
        //
        // If OobeSetup is FALSE when we are first called, and becomes TRUE at
        // some later point, logging doesn't work.  This ASSERT makes sure that
        // doesn't happen.
        //
        static BOOL OobeSetOnFirstCall = FALSE;
        if ( hFile == NULL ) {
            OobeSetOnFirstCall = OobeSetup;
        }
        MYASSERT( OobeSetOnFirstCall == OobeSetup );
    }
#endif

    GetLocalTime( &CurrTime );

    if (hFile == NULL) {
        if ( IsSetup || OobeSetup ) {
            Result = GetWindowsDirectory( buf, sizeof(buf)/sizeof(WCHAR) );
            if(Result == 0) {
                MYASSERT(FALSE);
                return;
            }
            pSetupConcatenatePaths( buf, L"setuplog.txt", sizeof(buf)/sizeof(WCHAR), NULL );

            //
            // If we're in OOBE, we want to append to the file that already exists
            //
            hFile = CreateFile(
                buf,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OobeSetup ? OPEN_ALWAYS : CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH,
                NULL
                );
            if (hFile != INVALID_HANDLE_VALUE)
            {
                if (OobeSetup) {
                    SetFilePointer (hFile, 0, NULL, FILE_END);
                }
                swprintf(buf, L"Time,File,Line,Tag,Message\r\n");
                Bytes = wcslen(buf) + 4;
                
#if defined(_ENABLE_SAC_CHANNEL_LOGGING_)
                if (SacChannelGuiModeDebugEnabled) {
                    SacChannelUnicodeWrite(
                        SacChannelGuiModeDebugHandle, 
                        (PCWSTR)buf
                        );
                }
#endif

                str =  MyMalloc(Bytes);
                if (str != NULL)
                {
                    WideCharToMultiByte(
                        CP_ACP,
                        0,
                        buf,
                        -1,
                        str,
                        Bytes,
                        NULL,
                        NULL
                        );
                    WriteFile(
                        hFile,
                        str,
                        wcslen(buf),
                        &Bytes,
                        NULL
                        );

                    MyFree( str );

                }
                buf[0] = '\0';
            }
        } else {    // !IsSetup

            //
            // Don't write to file, just do DbgPrintEx
            //
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    _try {
        p = buf;
        *p = 0;
        swprintf( p, L"%02d/%02d/%04d %02d:%02d:%02d,%s,%d,%s,",
            CurrTime.wMonth,
            CurrTime.wDay,
            CurrTime.wYear,
            CurrTime.wHour,
            CurrTime.wMinute,
            CurrTime.wSecond,
            (NULL != FileName) ? FileName : L"",
            LineNumber,
            (NULL != TagStr) ? TagStr : L""
            );
        p += wcslen(p);
        va_start( arg_ptr, FormatStr );
        _vsnwprintf( p, 2048, FormatStr, arg_ptr );
        va_end( arg_ptr );
        p += wcslen(p);
        wcscat( p, L"\r\n" );
    } except(EXCEPTION_EXECUTE_HANDLER) {
        buf[0] = 0;
    }

    if (buf[0] == 0) {
        return;
    }

    Bytes = (wcslen( buf )*2) + 4;

    str = MyMalloc( Bytes );
    if (str == NULL) {
        return;
    }

    WideCharToMultiByte(
        CP_ACP,
        0,
        buf,
        -1,
        str,
        Bytes,
        NULL,
        NULL
        );

    //
    // Write out the string to the debugger if the process is being debugged, or the
    // debug filter allows it.
    //
    if ( bWriteDebugSpew ) {

        OutputDebugString( buf );

    } else {

#if DBG
        DbgPrintEx( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, str );
#endif

    }

#if defined(_ENABLE_SAC_CHANNEL_LOGGING_)
    if (SacChannelGuiModeDebugEnabled) {
        SacChannelUnicodeWrite(
            SacChannelGuiModeDebugHandle, 
            (PCWSTR)buf
            );
    }
#endif
    
    if (hFile == INVALID_HANDLE_VALUE) {
        MyFree( str );
        return;
    }

    WriteFile(
        hFile,
        str,
        wcslen(buf),
        &Bytes,
        NULL
        );

    MyFree( str );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\ntsetup\syssetup\ctls.c ===
#include "setupp.h"
#pragma hdrstop


////////////////////////////////////////////
//
// Action item list control
//
////////////////////////////////////////////

//
// Define locations in extra window storage
//
#define AIL_FONT        (0)
#define AIL_BOLDFONT    (AIL_FONT + sizeof(PVOID))
#define AIL_TEXT        (AIL_BOLDFONT + sizeof(PVOID))
#define AIL_BOLDITEM    (AIL_TEXT + sizeof(PVOID))
#define AIL_LINECOUNT   (AIL_BOLDITEM + sizeof(LONG))
#define AIL_FREEFONTS   (AIL_LINECOUNT + sizeof(LONG))

#define AIL_EXTRA       ((3 * sizeof(PVOID)) + (3 * sizeof(LONG)))

PCWSTR szActionItemListClassName = L"$$$ActionItemList";

VOID
ActionItemListPaint(
    IN HWND hwnd
    )
{

    PAINTSTRUCT PaintStruct;
    PWSTR p,Text;
    UINT LineCount;
    HFONT OldFont,Font,BoldFont;
    UINT HighlightedItem;
    UINT i;
    int Length;
    int y;
    int yDelta;
    HBITMAP Bitmap,OldBitmap;
    BITMAP bitmap;
    HDC MemoryDC;
    SIZE Size;
    RECT rect;
    int Spacing;
    int oldmode;
    #define BORDER 3

    if(!BeginPaint(hwnd,&PaintStruct)) {
        return;
    }

    //
    // If no text, nothing to do.
    //
    if(Text = (PWSTR)GetWindowLongPtr(hwnd,AIL_TEXT)) {
        LineCount = (UINT)GetWindowLong(hwnd,AIL_LINECOUNT);
    }

    if(!Text || !LineCount) {
        return;
    }

    //
    // Get value indicating which item is to be bolded.
    //
    HighlightedItem = (UINT)GetWindowLong(hwnd,AIL_BOLDITEM);

    //
    // Get font handles.
    //
    Font = (HFONT)GetWindowLongPtr(hwnd,AIL_FONT);
    BoldFont = (HFONT)GetWindowLongPtr(hwnd,AIL_BOLDFONT);

    //
    // Select the non-boldface font to get the handle of
    // the currently selected font.
    //
    OldFont = SelectObject(PaintStruct.hdc,Font);

    oldmode = SetBkMode(PaintStruct.hdc,TRANSPARENT);

    //
    // Load the little triangle bitmap and create a compatible DC for it.
    //
    Bitmap = LoadBitmap(NULL,MAKEINTRESOURCE(OBM_MNARROW));

    if(MemoryDC = CreateCompatibleDC(PaintStruct.hdc)) {

        OldBitmap = SelectObject(MemoryDC,Bitmap);
        GetObject(Bitmap,sizeof(BITMAP),&bitmap);
    }

    Spacing = GetSystemMetrics(SM_CXICON) / 2;

    //
    // Treat the text as a series of lines and draw each one.
    //
    p = Text;
    y = 0;
    for(i=0; i<LineCount; i++) {

        SetBkColor(PaintStruct.hdc,GetSysColor(COLOR_3DFACE));

        //
        // Calculate the line's height based on the boldface font.
        // This is used to get to the y coord of the next line.
        //
        SelectObject(PaintStruct.hdc,BoldFont);

        GetClientRect(hwnd,&rect);
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = 0;

        DrawText(PaintStruct.hdc,p,lstrlen(p),&rect,DT_CALCRECT|DT_WORDBREAK);

        yDelta = rect.bottom + (2*BORDER);

        //
        // Change font to non-boldface for this line if necessary.
        //
        if(i != HighlightedItem) {
            SelectObject(PaintStruct.hdc,Font);
        }

        rect.top = y + BORDER;
        rect.left = (2 * BORDER) + Spacing;
        rect.bottom = rect.top + yDelta;

        //
        // Draw the line's text.
        //
        Length = lstrlen(p);
        DrawText(PaintStruct.hdc,p,Length,&rect,DT_WORDBREAK);

        //
        // Draw the little triangle thing if necessary.
        //
        if((i == HighlightedItem) && Bitmap && MemoryDC) {

            GetTextExtentPoint(PaintStruct.hdc,L"WWWWW",5,&Size);

            //
            // The arrow bitmap is monochrome. When blitted, 1-bits in the source
            // are converted to the text color in the destination DC and 0-bits
            // are converted to the background color. The effect we want to achieve
            // is to turn off in the destination bits that are 1 in the bitmap
            // and leave alone in the destination bits that are 0 in the bitmap.
            // Set the text color to all 0s and the background color to all 1s.
            // x AND 1 = x so background pixels stay undisturbed, and x AND 0 = 0
            // so foreground pixels get turned off.
            //
            SetBkColor(PaintStruct.hdc,RGB(255,255,255));

            BitBlt(
                PaintStruct.hdc,
                BORDER,
                y + ((Size.cy - bitmap.bmHeight) / 2) + BORDER,
                bitmap.bmWidth,
                bitmap.bmHeight,
                MemoryDC,
                0,0,
                SRCAND
                );
        }

        //
        // Point to next line's text.
        //
        p += Length + 1;
        y += yDelta;
    }

    //
    // Clean up.
    //
    SetBkMode(PaintStruct.hdc,oldmode);

    if(OldFont) {
        SelectObject(PaintStruct.hdc,OldFont);
    }

    if(MemoryDC) {
        if(OldBitmap) {
            SelectObject(MemoryDC,OldBitmap);
        }
        if(Bitmap) {
            DeleteObject(Bitmap);
        }
        DeleteDC(MemoryDC);
    }

    EndPaint(hwnd,&PaintStruct);
}


LRESULT
ActionItemListWndProc(
    IN HWND   hwnd,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    LRESULT rc;
    HFONT OldFont,Font,BoldFont;
    LOGFONT LogFont;
    PWSTR Text;
    PWSTR p;
    UINT LineCount;
    BOOL FreeFont,FreeBoldFont;

    switch(msg) {

    case WM_CREATE:

        //
        // Create fonts.
        //
        OldFont = (HFONT)SendMessage(GetParent(hwnd),WM_GETFONT,0,0);
        if(!OldFont) {
            //
            // Using system font.
            //
            OldFont = GetStockObject(DEFAULT_GUI_FONT);
        }

        FreeFont = TRUE;
        FreeBoldFont = TRUE;
        if(OldFont && GetObject(OldFont,sizeof(LOGFONT),&LogFont)) {

            LogFont.lfWeight = 400;
            Font = CreateFontIndirect(&LogFont);
            if(!Font) {
                Font = GetStockObject(DEFAULT_GUI_FONT);
                FreeFont = FALSE;
            }

            LogFont.lfWeight = 700;
            BoldFont = CreateFontIndirect(&LogFont);
            if(!BoldFont) {
                BoldFont = Font;
                FreeBoldFont = FALSE;
            }
        }

        SetWindowLongPtr(hwnd,AIL_FONT,(LONG_PTR)Font);
        SetWindowLongPtr(hwnd,AIL_BOLDFONT,(LONG_PTR)BoldFont);
        SetWindowLong(hwnd,AIL_BOLDITEM,0);
        SetWindowLongPtr(hwnd,AIL_TEXT,0);
        SetWindowLong(hwnd,AIL_LINECOUNT,0);
        SetWindowLong(hwnd,AIL_FREEFONTS,MAKELONG(FreeFont,FreeBoldFont));

        rc = 0;
        break;

    case WM_DESTROY:
        //
        // Get rid of fonts we created if necessary.
        //
        FreeFont = (BOOL)GetWindowLong(hwnd,AIL_FREEFONTS);
        FreeBoldFont = HIWORD(FreeFont);
        FreeFont = LOWORD(FreeFont);

        if(FreeFont && (Font = (HFONT)GetWindowLongPtr(hwnd,AIL_FONT))) {
            DeleteObject(Font);
        }

        if(FreeBoldFont && (BoldFont = (HFONT)GetWindowLongPtr(hwnd,AIL_BOLDFONT))) {
            DeleteObject(BoldFont);
        }

        if(Text = (PWSTR)GetWindowLongPtr(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }
        rc = 0;
        break;

    case WM_SETTEXT:
        //
        // Free old text and remember new text.
        //
        if(Text = (PWSTR)GetWindowLongPtr(hwnd,AIL_TEXT)) {
            MyFree(Text);
        }

        LineCount = 0;
        if(Text = pSetupDuplicateString((PVOID)lParam)) {
            //
            // Count lines in the text. This is equal to the number of
            // newlines. We require that the last line have a newline
            // to be counted.
            //
            for(LineCount=0,p=Text; *p; p++) {

                if(*p == L'\r') {
                    *p = L' ';
                } else {
                    if(*p == L'\n') {
                        *p = 0;
                        LineCount++;
                    }
                }
            }
        }

        //
        // Cheat a little: we expect wParam to be the 0-based index
        // of the boldfaced line. Callers will have to use SendMessage
        // instead of SetWindowText().
        //
        SetWindowLong(hwnd,AIL_BOLDITEM,(LONG)wParam);
        SetWindowLong(hwnd,AIL_LINECOUNT,LineCount);
        SetWindowLongPtr(hwnd,AIL_TEXT,(LONG_PTR)Text);

        rc = (Text != NULL);
        break;

    case WM_ERASEBKGND:
        //
        // Indicate that the background was erased successfully to prevent
        // any further processing. This allows us to lay text transparently
        // over any background bitmap on the dialog.
        //
        rc = TRUE;
        break;

    case WM_PAINT:

        ActionItemListPaint(hwnd);
        rc = 0;
        break;

    default:
        rc = DefWindowProc(hwnd,msg,wParam,lParam);
        break;
    }

    return(rc);
}


BOOL
RegisterActionItemListControl(
    IN BOOL Init
    )
{
    WNDCLASS wc;
    BOOL b;
    static BOOL Registered;

    if(Init) {
        if(Registered) {
            b = TRUE;
        } else {
            wc.style = CS_PARENTDC;
            wc.lpfnWndProc = ActionItemListWndProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = AIL_EXTRA;
            wc.hInstance = MyModuleHandle;
            wc.hIcon = NULL;
            wc.hCursor = LoadCursor(NULL,IDC_ARROW);
            wc.hbrBackground = NU