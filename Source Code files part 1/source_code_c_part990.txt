));
        return WBEM_E_CRITICAL_ERROR;
    }

    // Pre-load default namespace
    // ==========================

    LoadActiveNamespaces(pRoot, lFlags == WMIESS_INIT_REPOSITORY_RECOVERED );
    CTemporaryHeap::Compact();

#ifdef __WHISTLER_UNCUT
    //
    // Now that all the namespaces have been initialized, initiate recovery
    // of guaranteed delivery queues.
    //

    hres = InitiateRecovery();

    if ( FAILED(hres) )
    {
        ERRORTRACE((LOG_ESS, 
         "Unable to initiate recovery of guaranteed delivery queues: 0x%X\n",
          hres));
        return WBEM_E_CRITICAL_ERROR;
    }
#endif
    
#ifdef __DUMP_STATISTICS
#pragma message("Statistics dump in effect")
    DWORD dw;
    CloseHandle(CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)DumpThread,
        this, 0, &dw));
#endif

    //
    // Initialize the quotas.
    //

    g_quotas.Init(this);

    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}
    
void CEss::NotifyActiveNamespaceInitComplete()
{
    _DBG_ASSERT( m_lOutstandingActiveNamespaceInit > 0 );

    if ( InterlockedDecrement( &m_lOutstandingActiveNamespaceInit ) == 0 )
    {
        if ( SetEvent( m_hReadyEvent ) )
        {
            DEBUGTRACE((LOG_ESS,"ESS is now open for business.\n"));
        }
        else
        {
            ERRORTRACE((LOG_ESS,"ESS could not set ready event. res=%d\n",
                        GetLastError() ));
        }
    }
}
            
HRESULT CEss::CreateNamespaceObject( LPCWSTR wszNormName,
                                     CEssNamespace** ppNamespace )
{
    HRESULT hr;
    *ppNamespace = NULL;

    CWbemPtr<CEssNamespace> pNamespace = NULL;

    try
    {
        pNamespace = new CEssNamespace(this);
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if( pNamespace == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pNamespace->PreInitialize( wszNormName );

    if ( FAILED(hr) )
    {
        return hr;
    }

    try
    {
        m_mapNamespaces[wszNormName] = pNamespace;   
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pNamespace->AddRef(); // for the map

    pNamespace->AddRef();
    *ppNamespace = pNamespace;

    return WBEM_S_NO_ERROR;
}


HRESULT CEss::GetNamespaceObject( LPCWSTR wszName, 
                                  BOOL bEnsureActivation,
                                  CEssNamespace** ppNamespace)
{
    HRESULT hres;
    *ppNamespace = NULL;
 
    CWbemPtr<CEssNamespace> pNamespace;

    //
    // need to normalize namespace name
    // 

    LPWSTR wszNormName = NormalizeNamespaceString( wszName );

    if ( wszNormName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> dmwszNormName( wszNormName );

    {
        CInCritSec ics(&m_cs);    

        //
        // Search the map
        //
        TNamespaceIterator it;
        try
        {
            it = m_mapNamespaces.find(wszNormName);
        } 
        catch (CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        };
        
        if(it != m_mapNamespaces.end())
        {
            // Found it
            // ========
            
            pNamespace = it->second;    
        }
        else
        {
            // Not found --- create a new one
            // ==============================
            
            hres = CreateNamespaceObject( wszNormName, &pNamespace );
            
            if ( FAILED(hres) )
            {
                return hres;
            }
        }
    }

    //
    // ensure that initialization is pending if necessary
    // 

    if ( bEnsureActivation && pNamespace->MarkAsInitPendingIfQuiet() )
    {
        //
        // kick off initialization for this namespace on another thread.
        // 

        CNamespaceInitRequest* pReq;
        pReq = new CNamespaceInitRequest( pNamespace, FALSE );

        if ( pReq == NULL )
        {
            pNamespace->MarkAsInitialized( WBEM_E_OUT_OF_MEMORY );
            return WBEM_E_OUT_OF_MEMORY;
        }

        hres = ScheduleNamespaceInitialize( pReq );

        if ( FAILED(hres) )
        {
            delete pReq;
            pNamespace->MarkAsInitialized( WBEM_E_OUT_OF_MEMORY );
            return hres;
        }
    }

    pNamespace->AddRef();
    *ppNamespace = pNamespace;

    return WBEM_S_NO_ERROR;
}

//
// Creates a namespace object for the specified namespace and adds it 
// to the request object.
// 
HRESULT CEss::PrepareNamespaceInitRequest( LPCWSTR wszNamespace, 
                                    CInitActiveNamespacesRequest* pRequest )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    DEBUGTRACE((LOG_ESS,
                "Preparing a namespace init request for active namespace %S\n",
                wszNamespace ));

    CWbemPtr<CEssNamespace> pNamespace;

    LPWSTR wszNormName = NormalizeNamespaceString( wszNamespace );

    if ( wszNormName != NULL )
    {
        hr = CreateNamespaceObject( wszNormName, &pNamespace );

        if ( SUCCEEDED(hr) )
        {
            hr = pRequest->Add( pNamespace );

            //
            // make sure to tell the namespace that init is pending. 
            //

            BOOL bIsPending = pNamespace->MarkAsInitPendingIfQuiet();

            _DBG_ASSERT( bIsPending );
        }

        delete [] wszNormName;
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred when preparing active "
                    "namespace %S for initialization \n", hr, wszNamespace ));
    }

    return hr;
}

//
// This method prepares a request object that will initialize the specified 
// namespace and all descendent namespaces as if they were all active dependant
// namespaces.  This is useful when the Active namespace information could not 
// be obtained from the last shutdown. 
//
HRESULT CEss::RecursivePrepareNamespaceInitRequests(
                                       LPCWSTR wszNamespace,
                                       IWbemServices* pSvc, 
                                       CInitActiveNamespacesRequest* pRequest )
{
    HRESULT hr;

    hr = PrepareNamespaceInitRequest( wszNamespace, pRequest );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Enumerate all child namespaces and make recursive call for each
    //

    CWbemPtr<IEnumWbemClassObject> penumChildren;

    hr = pSvc->CreateInstanceEnum( L"__NAMESPACE", 
                                   0, 
                                   GetCurrentEssContext(), 
                                   &penumChildren ); 
    if( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred enumerating child "
            "namespaces of namespace %S. Some child namespaces may not be "
            "active\n", hr, wszNamespace ));

        //
        // don't treat this as error, since this namespace was created and 
        // added to the request.  Just no more work to do here. 
        //

        return WBEM_S_NO_ERROR;
    }

    DWORD dwRead;
    IWbemClassObject* pChildObj;

    while((hr=penumChildren->Next(INFINITE, 1, &pChildObj, &dwRead)) == S_OK)
    {
        VARIANT vName;
        VariantInit(&vName);
        CClearMe cm1(&vName);
        
        hr = pChildObj->Get( L"Name", 0, &vName, NULL, NULL );
        pChildObj->Release();
        
        if( FAILED(hr) )
        {
            return hr;
        }
        
        if ( V_VT(&vName) != VT_BSTR )
        {
            return WBEM_E_CRITICAL_ERROR;
        }

        //
        // form the full name of the namespace
        // 
        
        WString wsFullName;

        try
        {
            wsFullName = wszNamespace;
            wsFullName += L"\\";
            wsFullName += V_BSTR(&vName);
        }
        catch( CX_MemoryException )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // get the svc ptr for the namespace. Must be repository only. 
        //

        CWbemPtr<IWbemServices> pChildSvc;
        long lFlags = WMICORE_FLAG_REPOSITORY | WMICORE_CLIENT_TYPE_ESS;

        hr = m_pCoreServices->GetServices( wsFullName,NULL,NULL,
                                           lFlags,
                                           IID_IWbemServices, 
                                           (void**)&pChildSvc );
        if ( SUCCEEDED(hr) )
        {
            //
            // make the recursive call.
            // 
            
            RecursivePrepareNamespaceInitRequests( wsFullName, 
                                                   pChildSvc, 
                                                   pRequest );
        }
        else
        {
            ERRORTRACE((LOG_ESS, 
                        "Failed to open child namespace %S in %S: 0x%x\n",
                        V_BSTR(&vName), wszNamespace, hr));
        }
    }

    return WBEM_S_NO_ERROR;
}

//
// This method prepares namespace init requests for active namespaces.  It 
// uses persisted information to determine the active namespaces.  Each 
// ActiveNamespaceInit request may contain multiple namespaces.  This allows 
// dependent namespaces to be initialized together.  For now, all active 
// namespaces are treated as inter-dependent - so only one request will be 
// added to the list.  If there is no persisted information about active 
// namespaces, then all existing namespaces are treated as active dependent 
// ones.
//
HRESULT CEss::PrepareNamespaceInitRequests( IWbemServices* pRoot,
                                            BOOL bRediscover,
                                            InitActiveNsRequestList& aRequests)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CInitActiveNamespacesRequest* pReq;
    
    pReq = new CInitActiveNamespacesRequest(this);
    
    if ( pReq == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Get the list of active namespaces from the registry
    // 
    
    LONG lRes;
    DWORD dwDisp;
    HKEY hkeyEss, hkeyNamespace;

    lRes = RegCreateKeyExW( HKEY_LOCAL_MACHINE, 
                            WBEM_REG_ESS,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkeyEss,
                            &dwDisp );

    if ( lRes == ERROR_SUCCESS )
    {
        if ( !bRediscover )
        {
            FILETIME ft;
            DWORD dwIndex = 0;
            DWORD dwBuffSize = 256;
            LPWSTR wszName = new WCHAR[dwBuffSize];
            DWORD cName = dwBuffSize;

            if ( wszName == NULL )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
            }

            while( SUCCEEDED(hr) && (lRes=RegEnumKeyExW( hkeyEss, dwIndex, 
                                                         wszName, &cName, NULL,
                                                         NULL, NULL, &ft ) )
                  != ERROR_NO_MORE_ITEMS )
            {
                if ( lRes == ERROR_SUCCESS )
                {
                    hr = PrepareNamespaceInitRequest( wszName, pReq );
                    dwIndex++;                
                }
                else if ( lRes == ERROR_MORE_DATA )
                {
                    dwBuffSize += 256;
                    delete [] wszName;
                    wszName = new WCHAR[dwBuffSize];
                    
                    if ( wszName == NULL )
                    {
                        hr = WBEM_E_OUT_OF_MEMORY;
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32( lRes ); 
                }

                cName = dwBuffSize;
            }

            delete [] wszName;
    
            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"Failed enumerating active namespaces. "
                          "Treating all namespaces as active. HR=0x%x\n", hr));

                //
                // reset our registry data.  We'll rediscover it again. 
                //
                RegDeleteSubKeysW( hkeyEss );

                //
                // Also need to reset request object to clear any requests 
                // that were added on this enumeration.
                // 
                pReq->Reset();
            }
        }
        else
        {
            //
            // reset our registry data.  We'll rediscover it again.
            //
            RegDeleteSubKeysW( hkeyEss );

            hr = WBEM_S_FALSE;
        }

        RegCloseKey( hkeyEss );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( lRes ); 
    }

    //
    // If there was any problem or we just created the key for the 
    // first time or we are simply told to rediscover, then we have to recurse 
    // namespaces and discover.
    // 

    if ( hr != WBEM_S_NO_ERROR || dwDisp != REG_OPENED_EXISTING_KEY )
    {
        DEBUGTRACE((LOG_ESS,"ESS Treating all namespaces as active during "
                    "Initialize\n"));

        //
        // recurse namespaces from root
        //

        RecursivePrepareNamespaceInitRequests( L"root", pRoot, pReq );
    }

    if ( aRequests.Add( pReq ) < 0 )
    {
        delete pReq;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

//
// This method schedules all active namespaces for initialization.
//
HRESULT CEss::LoadActiveNamespaces( IWbemServices* pRoot, BOOL bRediscover )
{
    HRESULT hr;

    InitActiveNsRequestList aRequests;

    hr = PrepareNamespaceInitRequests( pRoot, bRediscover, aRequests );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // hold an active namespace init count while we schedule requests.
    // this will keep ess from transitioning to ready until it has 
    // scheduled all requests.
    //

    m_lOutstandingActiveNamespaceInit = 1;

    for( int i=0; i < aRequests.GetSize(); i++ )
    {
        int cNamespaces = aRequests[i]->GetNumNamespaces();

        if ( cNamespaces > 0 )
        {
            InterlockedExchangeAdd( &m_lOutstandingActiveNamespaceInit, 
                                    cNamespaces ); 
        }

        hr = ScheduleNamespaceInitialize( aRequests[i] );

        if ( FAILED(hr) )
        {
            InterlockedExchangeAdd( &m_lOutstandingActiveNamespaceInit,
                                    0-cNamespaces );
            delete aRequests[i];
        }
    }

    NotifyActiveNamespaceInitComplete();

    return WBEM_S_NO_ERROR;
}

//
// This method schedules a namespace init request.  It handles deferring 
// initialization if the machine is currently booting.  If the request 
// is known to only initialize inactive namespaces, then we do not defer
// initialization even in the boot phase.  This is so we don't cause events 
// in inactive namespaces to be queued up while we're waiting for the deferred
// initialization to complete.  
//
HRESULT CEss::ScheduleNamespaceInitialize( CExecRequest* pRequest )
{
    DWORD dwTickCount = GetTickCount();

    if ( dwTickCount >= BOOT_PHASE_MS )
    {
        HRESULT hres = Enqueue(pRequest);
    
        if( FAILED(hres) )
        {
            return hres;
        }

        return WBEM_S_NO_ERROR;
    }

    if ( m_hExitBootPhaseTimer == NULL )
    {
        //
        // cause a timer to be fired that will activate the thread queue
        // after we're out of the boot phase.
        //
        
        if ( !CreateTimerQueueTimer( &m_hExitBootPhaseTimer,
                                    NULL,
                                    ExitBootPhaseCallback,
                                    this,
                                    BOOT_PHASE_MS-dwTickCount,
                                    0,
                                    WT_EXECUTEINTIMERTHREAD ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }

    if ( m_aDeferredNSInitRequests.Add( pRequest ) < 0 )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_FALSE;
}

void CALLBACK CEss::ExitBootPhaseCallback( LPVOID pvThis, BOOLEAN )
{
    DEBUGTRACE((LOG_ESS, "Exiting Boot Phase.\n" ));
    ((CEss*)pvThis)->ExecuteDeferredNSInitRequests();
}

void CEss::ExecuteDeferredNSInitRequests()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );

    for( int i=0; i < m_aDeferredNSInitRequests.GetSize(); i++ )
    {
        hr = Enqueue( m_aDeferredNSInitRequests[i] );
        
        if ( FAILED(hr) )
        {
            ERRORTRACE((LOG_ESS, "Critical Error. Could not enqueue "
                        "deferred namespace init requests\n"));
            delete m_aDeferredNSInitRequests[i];
        }
    }

    m_aDeferredNSInitRequests.RemoveAll();
}

void CEss::TriggerDeferredInitialization()
{
    if ( GetTickCount() >= BOOT_PHASE_MS )
    {
        //
        // avoid calling execute() if possible since it grabs an ess wide cs.
        // 
        return;
    }

    DEBUGTRACE((LOG_ESS, "Triggering ESS Namespace Requests "
                         "during Boot phase\n" ));

    ExecuteDeferredNSInitRequests();
}
    
HRESULT CEss::GetNamespacePointer( LPCWSTR wszNamespace,
                                   BOOL bRepositoryOnly,
                                   RELEASE_ME IWbemServices** ppNamespace )
{
    HRESULT hres;

    if( m_pLocator == NULL )
    {
        if( m_pCoreServices != NULL )
        {
            long lFlags = WMICORE_CLIENT_TYPE_ESS;
            
            if ( bRepositoryOnly ) 
            {
                lFlags |= WMICORE_FLAG_REPOSITORY;
            }
            
            hres = m_pCoreServices->GetServices( wszNamespace, NULL,NULL,
                                                 lFlags, 
                                                 IID_IWbemServices, 
                                                 (void**)ppNamespace );
        }
        else
        {
            hres = WBEM_E_CRITICAL_ERROR;
        }
    }
    else
    {   
        BSTR strNamespace = SysAllocString(wszNamespace);

        hres = m_pLocator->ConnectServer( strNamespace, NULL, NULL, 0, 0, NULL,
                                          NULL, ppNamespace);
        SysFreeString(strNamespace);

        if ( SUCCEEDED(hres) )
        {
            hres = WBEM_S_FALSE;
        }
    }

    return hres;
}

HRESULT CEss::ReloadProvider( long lFlags, 
                              LPCWSTR wszNamespace, 
                              LPCWSTR wszProvider )
{
    HRESULT hr;

    try
    {
        CInObjectCount ioc(this);

        CWbemPtr<CEssNamespace> pNamespace;
        hr = GetNamespaceObject( wszNamespace, FALSE, &pNamespace);
        
        if ( SUCCEEDED(hr) )
        {
            DEBUGTRACE((LOG_ESS,"Reloading Provider %S in namespace %S at "
                        "request of external subsystem\n ",
                        wszProvider, wszNamespace ));

            hr = pNamespace->ReloadProvider( lFlags, wszProvider );
        }
    }
    catch( CX_MemoryException )
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }
        
    return hr;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEss::ProcessEvent(READ_ONLY CEventRepresentation& Event, long lFlags)
{
    HRESULT hres;
 
    try
    {
        CInObjectCount ioc(this);

        // Find the right namespace object
        // ===============================

        CEssNamespace* pNamespace = NULL;
        hres = GetNamespaceObject(Event.wsz1, FALSE, &pNamespace);
        if(FAILED(hres))
            return hres;
        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        // Get it to process the event
        // ===========================
        
        return pNamespace->ProcessEvent(Event, lFlags);
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}


HRESULT CEss::ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event )
{
    HRESULT hres;
 
    try
    {
        CInObjectCount ioc(this);

        //
        // Find the right namespace object
        // 

        CEssNamespace* pNamespace = NULL;

        hres = GetNamespaceObject(Event.wsz1, FALSE, &pNamespace);

        if( FAILED( hres ) )
        {
            return hres;
        }

        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        //
        // Get it to process the event
        // 
        
        return pNamespace->ProcessQueryObjectSinkEvent( Event );
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}


HRESULT CEss::VerifyInternalEvent(READ_ONLY CEventRepresentation& Event)
{
    HRESULT hres;

    try
    {
        CInObjectCount ioc(this);

        // Find the right namespace object
        // ===============================

        CEssNamespace* pNamespace = NULL;
        hres = GetNamespaceObject(Event.wsz1, FALSE, &pNamespace);
        if(FAILED(hres))
            return hres;
        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        // Get it to process the event
        // ===========================
        
        return pNamespace->ValidateSystemEvent(Event);
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CEss::RegisterNotificationSink( WBEM_CWSTR wszNamespace, 
                                        WBEM_CWSTR wszQueryLanguage, 
                                        WBEM_CWSTR wszQuery, 
                                        long lFlags, 
                                        IWbemContext* pContext, 
                                        IWbemObjectSink* pSink )
{
    HRESULT hres;

    try
    {
        if(_wcsicmp(wszQueryLanguage, L"WQL"))
            return WBEM_E_INVALID_QUERY_TYPE;

        CInObjectCount ioc(this);

        // Find the right namespace object
        // ===============================

        CEssNamespace* pNamespace = NULL;
        hres = GetNamespaceObject(wszNamespace, FALSE, &pNamespace);
        if(FAILED(hres))
            return hres;
        CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

        // Get the object to do it
        // =======================

        HRESULT hr;
        
        hr = pNamespace->RegisterNotificationSink( wszQueryLanguage, 
                                                   wszQuery,
                                                   lFlags, 
                                                   WMIMSG_FLAG_QOS_EXPRESS, 
                                                   pContext, 
                                                   pSink );

        return hr;

    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CEss::RemoveNotificationSink(IWbemObjectSink* pSink)
{
    HRESULT hres;
    try
    {
        CInObjectCount ioc(this);
        
        // Create a list of AddRefed namespace objects that we can use
        // ===========================================================

        CRefedPointerArray<CEssNamespace> apNamespaces;

        {
            CInCritSec ics(&m_cs);

            for(TNamespaceIterator it = m_mapNamespaces.begin();
                it != m_mapNamespaces.end();
                it++)
            {
                if(apNamespaces.Add(it->second) < 0)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }

        // Get all of them to remove this sink
        // ===================================
        
        HRESULT hresGlobal = WBEM_E_NOT_FOUND;
        
        for(int i = 0; i < apNamespaces.GetSize(); i++)
        {
            hres = apNamespaces[i]->RemoveNotificationSink(pSink);
            if(FAILED(hres))
            {
                if(hres != WBEM_E_NOT_FOUND)
                {
                    // Actual error --- take note
                    // ==========================
                    
                    hresGlobal = hres;
                }
            }
            else
            {
                // Found some
                // ==========
                
                if(hresGlobal == WBEM_E_NOT_FOUND)
                    hresGlobal = WBEM_S_NO_ERROR;
            }
        }
        
        return hresGlobal;
    }
    catch(...)
    {
        throw;
        return WBEM_E_OUT_OF_MEMORY;
    }
}

HRESULT CEss::PurgeNamespace(LPCWSTR wszNamespace)
{
    LPWSTR wszNormName = NormalizeNamespaceString( wszNamespace );

    if ( wszNormName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> dmwszNormName( wszNormName );
 
    CEssNamespace* pNamespace = NULL;
    {
        CInCritSec ics(&m_cs);

        // Purge it from the timer generator
        // =================================

        m_TimerGenerator.Remove(wszNormName);

        // Find it in the map
        // ==================

        TNamespaceIterator it;
        try
        {
            it = m_mapNamespaces.find(wszNormName);
        } 
        catch (CX_MemoryException &)
        {
            return WBEM_E_OUT_OF_MEMORY;
        };
        
        if(it == m_mapNamespaces.end())
            return WBEM_S_FALSE;

        // Keep it for later
        // =================

        pNamespace = it->second;

        // Remove it from the map
        // ======================

        m_mapNamespaces.erase(it);
    }

    // Wait for initialization to complete
    // ===================================

    pNamespace->Shutdown();
    pNamespace->Release();    
    return WBEM_S_NO_ERROR;
}

HRESULT CEss::DecorateObject(IWbemClassObject* pObj, LPCWSTR wszNamespace)
{
    return CEventRepresentation::mstatic_pDecorator->DecorateObject(pObj, 
                                                      (LPWSTR)wszNamespace);
}

HRESULT CEss::AddSleepCharge(DWORD dwSleep)
{
    if(dwSleep)
        Sleep(dwSleep);
    return S_OK;
}

HRESULT CEss::AddCache()
{
    return m_LimitControl.AddMember();
}

HRESULT CEss::RemoveCache()
{
    return m_LimitControl.RemoveMember();
}

HRESULT CEss::AddToCache(DWORD dwAdd, DWORD dwMemberTotal, DWORD* pdwSleep)
{
    DWORD dwSleep;
    HRESULT hres = m_LimitControl.Add(dwAdd, dwMemberTotal, &dwSleep);

    if(SUCCEEDED(hres))
    {
        if(pdwSleep)
            *pdwSleep = dwSleep;
        else
            AddSleepCharge(dwSleep);
    }
    return hres;
}

HRESULT CEss::RemoveFromCache(DWORD dwRemove)
{
    return m_LimitControl.Remove(dwRemove);
}


void CEss::IncrementObjectCount()
{
    InterlockedIncrement(&m_lObjectCount);
    if(m_pLifeControl)
        m_pLifeControl->AddRefCore();
}

void CEss::DecrementObjectCount()
{
    if(InterlockedDecrement(&m_lObjectCount) == 0)
    {
        // No need to purge the cache --- David knows I am ready to unload
    }

    if(m_pLifeControl)
        m_pLifeControl->ReleaseCore();
}

HRESULT CEss::InitializeTimerGenerator(LPCWSTR wszNamespace, 
                    IWbemServices* pNamespace)
{
    return GetTimerGenerator().LoadTimerEventQueue(wszNamespace, pNamespace);
}

HRESULT CEss::EnqueueDeliver(CQueueingEventSink* pDest)
{
    return m_Queue.EnqueueDeliver(pDest);
}

HRESULT CEss::Enqueue(CExecRequest* pReq)
{
    return m_Queue.Enqueue(pReq);
}

HRESULT CEss::GetToken(PSID pSid, IWbemToken** ppToken)
{
    return m_pTokenCache->GetToken((BYTE*)pSid, ppToken);
}

void CEss::DumpStatistics(FILE* f, long lFlags)
{
    CInCritSec ics(&m_cs);

    time_t t;
    time(&t);
    struct tm* ptm = localtime(&t);
    fprintf(f, "Statistics at %s", asctime(ptm));
    time(&t);
    ptm = localtime(&t);
    fprintf(f, "Commence at %s", asctime(ptm));

    for(TNamespaceIterator it = m_mapNamespaces.begin();
            it != m_mapNamespaces.end(); it++)
    {
        it->second->DumpStatistics(f, lFlags);
    }

    time(&t);
    ptm = localtime(&t);
    fprintf(f, "Done at %s\n", asctime(ptm));
}

HRESULT CEss::GetProviderFactory( LPCWSTR wszNamespaceName,
                                  IWbemServices* pNamespace,
                                  RELEASE_ME _IWmiProviderFactory** ppFactory )
{
    HRESULT hres;

    *ppFactory = NULL;

    if ( m_pProvSS == NULL )
    {
        ERRORTRACE((LOG_ESS, "Trying to get Provider Factory, but "
                    "No provider subsystem!!\n"));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Get IWbemServicesEx, just for Steve
    //

    IWbemServicesEx* pEx;
    hres = pNamespace->QueryInterface(IID_IWbemServicesEx, (void**)&pEx);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "No Ex interface: 0x%X\n", hres));
        return hres;
    }
    CReleaseMe rm1(pEx);
        
    //
    // Get Provider factory
    //

    hres = m_pProvSS->Create( pEx, 
                              0, 
                              GetCurrentEssContext(), 
                              wszNamespaceName,
                              IID__IWmiProviderFactory, 
                              (void**)ppFactory );
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "No provider factory: 0x%X\n", hres));
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\essself.h ===
#ifndef __WMI_ESSSELF__H_
#define __WMI_ESSSELF__H_

#include <selfinst.h>

// BUGBUG
#define WMIESS_REPORT(X)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\essmain.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESSMAIN.CPP
//
//  Defines COM DLL entry points and CFactory implementation.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include <wbemidl.h>
#include <wbemcomn.h>
#include "esssink.h"
#include <commain.h>
#include <clsfac.h>

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_WbemEventSubsystem, 
                        _new CClassFactory<CEssObjectSink>(GetLifeControl()), 
                        __TEXT("Event Subsystem"),
                        TRUE);
        AddClassInfo(CLSID_WmiESS, 
                        _new CClassFactory<CEssObjectSink>(GetLifeControl()), 
                        __TEXT("New Event Subsystem"),
                        TRUE);

        return S_OK;
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\essutils.cpp ===
//******************************************************************************
//
//  ESSUTILS.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "essutils.h"
#include <tls.h>

CTLS g_tlsContext;

long g_lNumExternalThreadObjects = 0;

INTERNAL CEssThreadObject* GetCurrentEssThreadObject()
{
    CEssThreadObject* pObj = (CEssThreadObject*)g_tlsContext.Get();
    
    if ( pObj != NULL )
    {
        //
        // mark the fact that we are handing the thread object to the 
        // outside world.  We use this later on when checking 
        // thread object leaks.
        //        
        pObj->SetReferencedExternally();
    }

    return pObj;
}

void SetCurrentEssThreadObject(IWbemContext* pContext)
{
    //
    // make sure we're not overwriting an existing internal thread object.
    // if its externally referenced, we really can't tell if this would 
    // be a leak or not.
    //
    CEssThreadObject* pOldObj = (CEssThreadObject*)g_tlsContext.Get();
    _DBG_ASSERT( pOldObj == NULL || pOldObj->IsReferencedExternally() );

    CEssThreadObject* pObj = new CEssThreadObject(pContext);
    g_tlsContext.Set((void*)pObj);
}

void SetConstructedEssThreadObject(CEssThreadObject* pObj)
{
    //
    // make sure we're not overwriting an existing internal thread object.
    // if its externally referenced, we really can't tell if this would 
    // be a leak or not.
    //
    CEssThreadObject* pOldObj = (CEssThreadObject*)g_tlsContext.Get();
    _DBG_ASSERT( pOldObj == NULL || pOldObj->IsReferencedExternally() );

    //
    // since this object was passed in from the outside world, then 
    // mark it as externally referenced.
    //
    if ( pObj != NULL )
    {
        pObj->SetReferencedExternally();
    }

    g_tlsContext.Set((void*)pObj);
}

void ClearCurrentEssThreadObject()
{
    //
    // make sure we're not overwriting an existing internal thread object.
    // if its externally referenced, we really can't tell if this would 
    // be a leak or not.
    //
    CEssThreadObject* pObj = (CEssThreadObject*)g_tlsContext.Get();
    _DBG_ASSERT( pObj == NULL || pObj->IsReferencedExternally() );    
    
    g_tlsContext.Set(NULL);
}

INTERNAL IWbemContext* GetCurrentEssContext()
{
    CEssThreadObject* pThreadObj = (CEssThreadObject*)g_tlsContext.Get();
    if(pThreadObj)
        return pThreadObj->m_pContext;
    else
        return NULL;
}

INTERNAL CPostponedList* GetCurrentPostponedList()
{
    CEssThreadObject* pThreadObj = (CEssThreadObject*)g_tlsContext.Get();
    if(pThreadObj)
        return &pThreadObj->m_PostponedList;
    else
        return NULL;
}

INTERNAL CPostponedList* GetCurrentPostponedEventList()
{
    CEssThreadObject* pThreadObj = (CEssThreadObject*)g_tlsContext.Get();
    if(pThreadObj)
        return &pThreadObj->m_PostponedEventList;
    else
        return NULL;
}
    
CEssThreadObject::CEssThreadObject( IWbemContext* pContext )
: m_bReferencedExternally( FALSE )
{
    m_pContext = pContext;
    
    if( m_pContext == NULL )
    {
        m_pContext = GetSpecialContext();
    }

    if ( m_pContext != NULL )
    {
        m_pContext->AddRef();
    }
}

void CEssThreadObject::SetReferencedExternally()
{
    if ( !m_bReferencedExternally )
    {
        g_lNumExternalThreadObjects++;
        m_bReferencedExternally = TRUE;
    }
}

IWbemContext* CEssThreadObject::mstatic_pSpecialContext = NULL;

INTERNAL IWbemContext* CEssThreadObject::GetSpecialContext()
{
    // Create a "special" context object that will make sure that our 
    // calls back into CIMOM are not blocked
    // ==============================================================

    if(mstatic_pSpecialContext == NULL)
    {
        IWbemCausalityAccess* pCause = NULL;
        HRESULT hres = CoCreateInstance(CLSID_WbemContext, NULL, 
            CLSCTX_INPROC_SERVER, IID_IWbemCausalityAccess, 
            (void**)&pCause);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to create special context object: "
                "0x%X.  Danger of deadlock\n", hres));
            return NULL;
        }

        CReleaseMe rm1(pCause);

        hres = pCause->MakeSpecial();
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to make the context special: "
                "0x%X.  Danger of deadlock\n", hres));
            return NULL;
        }

        IWbemContext* pContext = NULL;
        hres = pCause->QueryInterface(IID_IWbemContext, (void**)&pContext);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Internal error: invalid context (0x%X)\n",
                hres));
            return NULL;
        }

        if(mstatic_pSpecialContext == NULL) // tiny window for a one-time leak
            mstatic_pSpecialContext = pContext;
        else
            pContext->Release();
    }
    return mstatic_pSpecialContext;
}

CEssThreadObject::~CEssThreadObject()
{
    if ( m_bReferencedExternally )
    {
        g_lNumExternalThreadObjects--;

        //
        // since ClearCurrentEssThreadObject() can reference the 
        // thread object ( for leak checking ) and because we previously 
        // supported the thread object being deleted before
        // CurrentThreadEssThreadObject(), make sure that we perform the 
        // Clear if the current thread object matches this one.  This only 
        // can happen when the thread object is referenced externally.
        //

        CEssThreadObject* pObj = (CEssThreadObject*)g_tlsContext.Get();

        if ( pObj == this )
        {
            ClearCurrentEssThreadObject();
        }
    }

    _DBG_ASSERT( m_PostponedList.IsEmpty() );

    if ( m_pContext != NULL )
    {
        m_pContext->Release();
    }
}

void /*static*/ CEssThreadObject::ClearSpecialContext()
{
    // Call only when no other work can be taking place, e.g. in DllCanUnloadNow
    // =========================================================================

    if(mstatic_pSpecialContext)
        mstatic_pSpecialContext->Release();
    mstatic_pSpecialContext = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\esssink.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESSSINK.H
//
//  This files defines the class that implements IWbemObjectSink for the ESS.
//
//  Classes defined:
//
//      CEssObjectSink
//
//  History:
//
//  11/27/96    a-levn      Compiles
//
//=============================================================================

#ifndef __ESSSINK__H_
#define __ESSSINK__H_

#include <wbemidl.h>
#include <wbemint.h>
#include <unk.h>
#include <comutl.h>
#include "parmdefs.h"
#include "essutils.h"

//*****************************************************************************
//
//  class CEssObjectSink
//
//  This class implements IWbemObjectSink interface for ESS, including the 
//  automation part. A pointer to this object is given to WinMgmt at startup
//  and it serves as the only communication port into the ESS.
//
//*****************************************************************************

class CEss;
class CEssObjectSink : public CUnk
{
private:
    CEss* m_pEss;
    BOOL m_bShutdown;
    CEssSharedLock m_Lock;
    _IWmiCoreServices* m_pCoreServices;
    
protected:
    typedef CImpl<IWbemEventSubsystem_m4, CEssObjectSink> TImplESS;
    class XESS : public TImplESS
    {
    public:
        XESS(CEssObjectSink* pObject) : TImplESS(pObject)
        {}

        STDMETHOD(ProcessInternalEvent)(long lSendType, LPCWSTR str1, LPCWSTR str2, 
            LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
            _IWmiObject** apObjects, IWbemContext* pContext);

        STDMETHOD(VerifyInternalEvent)(long lSendType, LPCWSTR str1, LPCWSTR str2, 
            LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
            _IWmiObject** apObjects, IWbemContext* pContext);

        STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*)
        {return WBEM_S_NO_ERROR;}

        STDMETHOD(RegisterNotificationSink)(LPCWSTR wszNamespace, 
            LPCWSTR wszQueryLanguage, LPCWSTR wszQuery, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink);

        STDMETHOD(RemoveNotificationSink)(IWbemObjectSink* pSink);
    
        STDMETHOD(GetNamespaceSink)(LPCWSTR wszNamespace, 
            IWbemObjectSink** ppSink);
        STDMETHOD(Initialize)(LPCWSTR wszServer, IWbemLocator* pAdminLocator,
                                IUnknown* pServices);
        STDMETHOD(Shutdown)();
        STDMETHOD(LastCallForCore)(LONG lSystemShutDown);
    } m_XESS;
    friend XESS;

    typedef CImpl<_IWmiESS, CEssObjectSink> TImplNewESS;
    class XNewESS : public TImplNewESS
    {
    public:
        XNewESS(CEssObjectSink* pObject) : TImplNewESS(pObject)
        {}

        STDMETHOD(Initialize)(long lFlags, IWbemContext* pCtx, 
                    _IWmiCoreServices* pServices);

        STDMETHOD(ExecNotificationQuery)(LPCWSTR wszNamespace, 
            LPCWSTR wszQueryText, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink);

        STDMETHOD(CancelAsyncCall)(IWbemObjectSink* pSink);
    
        STDMETHOD(QueryObjectSink)(LPCWSTR wszNamespace, 
            IWbemObjectSink** ppSink);
    } m_XNewESS;
    friend XNewESS;

    typedef CImpl<IWbemShutdown, CEssObjectSink> TImplShutdown;

    class XShutdown : public TImplShutdown
    {
    public:
        XShutdown(CEssObjectSink* pObject) : TImplShutdown(pObject)
        {}

        STDMETHOD(Shutdown)( long lFlags,
                             ULONG uMaxMilliseconds, 
                             IWbemContext* pCtx );
    } m_XShutdown;
    friend XShutdown;

    typedef CImpl<_IWmiCoreWriteHook, CEssObjectSink> TImplHook;

    class XHook : public TImplHook
    {
    public:
        XHook(CEssObjectSink* pObject) : TImplHook(pObject)
        {}

        STDMETHOD(PrePut)(long lFlags, long lUserFlags, IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pCopy);
        STDMETHOD(PostPut)(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pNew, 
                            _IWmiObject* pOld);
        STDMETHOD(PreDelete)(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass);
        STDMETHOD(PostDelete)(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pOld);
    } m_XHook;
    friend XHook;

public:
    CEssObjectSink(CLifeControl* pControl, IUnknown* pOuter = NULL);
    ~CEssObjectSink();
    void* GetInterface(REFIID riid);
};

class CEssNamespaceSink : public CUnk
{
    CEss* m_pEss;
    BSTR m_strNamespace;
protected:
    typedef CImpl<IWbemObjectSink, CEssNamespaceSink> TImplSink;
    class XSink : public TImplSink
    {
    public:
        XSink(CEssNamespaceSink* pObject) : TImplSink(pObject){}

        STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
        STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*)
        {return WBEM_S_NO_ERROR;}
    } m_XSink;
    friend XSink;

public:
    CEssNamespaceSink(CEss* pEss, CLifeControl* pControl, 
                            IUnknown* pOuter = NULL);
    HRESULT Initialize(LPCWSTR wszNamespace);
    ~CEssNamespaceSink();
    void* GetInterface(REFIID riid);
};

/****************************************************************************
  
  CEssInternalOperationSink

  This sink handles the setting up of a new ess thread object and then 
  delegates calls to the specified sink.  The purpose of this is so that 
  internal ess operations can be performed asynchronously.  For example, 
  for class change notifications we register a sink that reactivates the 
  associated filter. In order to actually perform the reactivation, the 
  calling thread must be set up appropriately.  

*****************************************************************************/
 
class CEssInternalOperationSink 
: public CUnkBase< IWbemObjectSink, &IID_IWbemObjectSink >
{
    CWbemPtr<IWbemObjectSink> m_pSink;

public:

    CEssInternalOperationSink( IWbemObjectSink* pSink ) : m_pSink( pSink ) {} 
    STDMETHOD(Indicate)( long cObjects, IWbemClassObject** ppObjs ); 
    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\eventrep.h ===
//*****************************************************************************
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EVENTREP.H
//
//  This file contains basic definitions and classes for event representation.
//
//  Classes defined:
//
//      CEventRepresentation
//
//  History:
//
//      11/27/96    a-levn      Compiles.
//
//*****************************************************************************

#ifndef __EVENT_REP__H_
#define __EVENT_REP__H_

#include <wbemidl.h>
#include <wbemint.h>
#include "parmdefs.h"
#include <wbemcomn.h>

// Class and property names of the schema objects related to event subsystem
// =========================================================================

#define SECURITY_DESCRIPTOR_PROPNAME            L"SECURITY_DESCRIPTOR"

#define EVENT_PROVIDER_REGISTRATION_CLASS       L"__EventProviderRegistration"
#define PROVIDER_CLASS                          L"__Provider"
#define EVENT_FILTER_CLASS                      L"__EventFilter"
#define BASE_STANDARD_FILTER_CLASS              L"__BaseStandardEventFilter"
#define CONSUMER_CLASS                          L"__EventConsumer"
#define BINDING_CLASS                           L"__FilterToConsumerBinding"
#define GENERATOR_CLASS                         L"__EventGenerator"
#define GENERATOR_BINDING_CLASS                 L"__GeneratorToConsumerBinding"
#define TIMER_BASE_CLASS                        L"__TimerInstruction"
#define TIMER_ABSOLUTE_CLASS                    L"__AbsoluteTimerInstruction"
#define TIMER_INTERVAL_CLASS                    L"__IntervalTimerInstruction"
#define WIN32_PROVIDER_CLASS                    L"__Win32Provider"
#define CONSUMER_PROVIDER_REGISTRATION_CLASS \
                                          L"__EventConsumerProviderRegistration"
#define EVENT_DROP_CLASS                        L"__EventDroppedEvent"
#define QUEUE_OVERFLOW_CLASS                    L"__EventQueueOverflowEvent"
#define CONSUMER_FAILURE_CLASS                  L"__ConsumerFailureEvent"
#define QOS_FAILURE_CLASS                  L"__QoSFailureEvent"

#define OWNER_SID_PROPNAME                      L"CreatorSID"

#define FILTER_ROLE_NAME                        L"Filter"
#define CONSUMER_ROLE_NAME                      L"Consumer"
#define BINDING_QOS_PROPNAME                    L"DeliveryQoS"
#define BINDING_SYNCHRONICITY_PROPNAME          L"DeliverSynchronously"
#define BINDING_SECURE_PROPNAME                 L"MaintainSecurityContext"
#define BINDING_SLOWDOWN_PROPNAME               L"SlowDownProviders"
#define TIMER_ID_PROPNAME                       L"TimerID"
#define FILTER_KEY_PROPNAME                     L"Name"
#define FILTER_QUERY_PROPNAME                   L"Query"
#define FILTER_LANGUAGE_PROPNAME                L"QueryLanguage"
#define FILTER_EVENTNAMESPACE_PROPNAME          L"EventNamespace"
#define FILTER_EVENTACCESS_PROPNAME             L"EventAccess"
#define FILTER_GUARDNAMESPACE_PROPNAME          L"ConditionNamespace"
#define FILTER_GUARD_PROPNAME                   L"Condition"
#define FILTER_GUARDLANG_PROPNAME               L"ConditionLanguage"
#define CONSUMER_MACHINE_NAME_PROPNAME          L"MachineName"
#define CONSUMER_MAXQUEUESIZE_PROPNAME          L"MaximumQueueSize"
#define PROVIDER_CLSID_PROPNAME                 L"Clsid"
#define PROVIDER_NAME_PROPNAME                  L"Name"
#define EVPROVREG_PROVIDER_REF_PROPNAME         L"Provider"
#define EVPROVREG_QUERY_LIST_PROPNAME           L"EventQueryList"
#define CONSPROV_PROVIDER_REF_PROPNAME          L"Provider"
#define CONSPROV_CLSID_PROPNAME                 L"CLSID"

#define TARGET_NAMESPACE_PROPNAME               L"TargetNamespace"
#define PREVIOUS_NAMESPACE_PROPNAME             L"PreviousNamespace"
#define TARGET_CLASS_PROPNAME                   L"TargetClass"
#define PREVIOUS_CLASS_PROPNAME                 L"PreviousCLass"
#define TARGET_INSTANCE_PROPNAME                L"TargetInstance"
#define PREVIOUS_INSTANCE_PROPNAME              L"PreviousInstance"
#define EVENT_DROP_EVENT_PROPNAME               L"Event"
#define EVENT_DROP_CONSUMER_PROPNAME            L"IntendedConsumer"
#define CONSUMER_FAILURE_ERROR_PROPNAME         L"ErrorCode"
#define CONSUMER_FAILURE_ERROROBJ_PROPNAME      L"ErrorObject"
#define QOS_FAILURE_ERROR_PROPNAME              L"ErrorCode"
#define QUEUE_OVERFLOW_SIZE_PROPNAME            L"CurrentQueueSize"

#define MONITOR_BASE_EVENT_CLASS                L"__MonitorEvent"
#define MONITOR_DATA_EVENT_CLASS                L"__MonitorDataEvent"
#define ASSERT_EVENT_CLASS                      L"__MonitorAssertEvent"
#define RETRACT_EVENT_CLASS                     L"__MonitorRetractEvent"
#define GOINGUP_EVENT_CLASS                     L"__MonitorUpEvent"
#define GOINGDOWN_EVENT_CLASS                   L"__MonitorDownEvent"
#define MONITORERROR_EVENT_CLASS                L"__MonitorErrorEvent"
#define MONITOR_CLASS                           L"__MonitorInstruction"

#define MONITORNAME_EVENT_PROPNAME              L"MonitorName"
#define MONITOROBJECT_EVENT_PROPNAME            L"RowObject"
#define MONITORCOUNT_EVENT_PROPNAME             L"TotalObjects"
#define MONITORNEW_EVENT_PROPNAME               L"GuaranteedNew"

#define MONITOR_NAME_PROPNAME                   L"Name"
#define MONITOR_QUERY_PROPNAME                  L"Query"
#define MONITOR_QUERYLANG_PROPNAME              L"QueryLanguage"
#define MONITOR_NAMESPACE_PROPNAME              L"TargetNamespace"

#define E_NOTFOUND WBEM_E_NOT_FOUND

typedef IWbemClassObject IWbemEvent;

// Helper functions
// ================

inline DELETE_ME LPWSTR CloneWstr(READ_ONLY LPCWSTR wsz)
{
    LPWSTR wszNew = new WCHAR[wcslen(wsz)+1];
    if(wszNew == NULL)
        return NULL;
    wcscpy(wszNew, wsz);
    return wszNew;
}

// Event types. These are used in IndicateEx calls, as well as internally.
// =======================================================================

typedef enum{
    e_EventTypeInvalid = WBEM_EVENTTYPE_Invalid,
    e_EventTypeExtrinsic = WBEM_EVENTTYPE_Extrinsic,
    e_EventTypeTimer = WBEM_EVENTTYPE_Timer,
    e_EventTypeNamespaceCreation = WBEM_EVENTTYPE_NamespaceCreation,
    e_EventTypeNamespaceDeletion = WBEM_EVENTTYPE_NamespaceDeletion,
    e_EventTypeNamespaceModification = WBEM_EVENTTYPE_NamespaceModification,
    e_EventTypeClassCreation = WBEM_EVENTTYPE_ClassCreation,
    e_EventTypeClassDeletion = WBEM_EVENTTYPE_ClassDeletion,
    e_EventTypeClassModification = WBEM_EVENTTYPE_ClassModification,
    e_EventTypeInstanceCreation = WBEM_EVENTTYPE_InstanceCreation,
    e_EventTypeInstanceDeletion = WBEM_EVENTTYPE_InstanceDeletion,
    e_EventTypeInstanceModification = WBEM_EVENTTYPE_InstanceModification,
    e_EventTypeSystem = WBEM_EVENTTYPE_System
} EEventType;

#define INTRINSIC_EVENTS_MASK (~(1<<e_EventTypeExtrinsic))

#define INSTANCE_EVENTS_MASK ( \
            (1<<e_EventTypeInstanceCreation) | \
            (1<<e_EventTypeInstanceDeletion) | \
            (1<<e_EventTypeInstanceModification))

#define CLASS_EVENTS_MASK ( \
            (1<<e_EventTypeClassCreation) | \
            (1<<e_EventTypeClassDeletion) | \
            (1<<e_EventTypeClassModification))

#define NAMESPACE_EVENTS_MASK ( \
            (1<<e_EventTypeNamespaceCreation) | \
            (1<<e_EventTypeNamespaceDeletion) | \
            (1<<e_EventTypeNamespaceModification))

#define DATA_EVENTS_MASK \
            (INSTANCE_EVENTS_MASK | CLASS_EVENTS_MASK | NAMESPACE_EVENTS_MASK)

//*****************************************************************************
//
//  class CEventRepresentation
//
//  This class represents an event that ESS receives. It has public datafields
//  corresponding to the parameters of the IndicateEx call and that is 
//  precisely what is stored in it. 
//
//  This class has two types of existence: allocated and not allocated. Non
//  allocated state is the default. In it, CEventRepresentation string fields 
//  contain pointers to data that does not 'belong' to this class, and is not
//  deleted in the destructor.
//
//  The other, allocated, state is entered when a new copy of this object is
//  created using MakePermanentCopy(). In this state, all string fields contain
//  allocated data which is deleted on destruct.
//
//  CEventRepresentation also contains a table mapping event types into event 
//  class names and event filter class names.
//
//  Finally, CEventRepresentation is derived from CPropertySource and provides
//  property values (taken from the first included IWbemClassObject) to the
//  SQL1 query evaluator.
//
//*****************************************************************************
//
//  MakePermanentCopy
//
//  This function produces a new copy of the event, which can survive complete
//  destruction of the original object. All strings are reallocated and all 
//  IWbemClassObjects are Clone'ed. The reason for that is that WinMgmt core may
//  call ESS with temporary (non-OLE) objects, and if ESS needs to keep them 
//  after it returns from the call, it needs to make a complete copy.
//
//  Returns:
//
//      CEventRepresentation*   pointing to the new object, Must be deleted
//                              by the called.
//
//*****************************************************************************
//
//  MakeWbemObject
//
//  This function creates an IWbemClassObject representation of the event for 
//  clients that do not accept NotifyEx calls. The object will be of the class
//  determined by the type of the event and will contain all the properties 
//  appropriate for that class (with values taken from CEventRepresentation
//  properties).
//
//  Parameters:
//
//      IWbemClassObject** ppEventObject     Destination for the newely created
//                                          object. Caller must Release it when
//                                          done.
//  Returns:
//
//      S_OK        on success
//      S_FALSE     if event is extrinsic. When extrinsic events are specified
//                      in IndicateEx, the first object IS the class object for
//                      the event, and so no additional object creation is
//                      necessary for Indicate.
//      
//      Any CoCreateInstance error.
//      Any IWbemClassObject::Put error.
//
//*****************************************************************************
//
//  static GetEventName
//
//  Retreives the name of the event class corresponding to a given 
//  event type.
//
//  Parameters:
//      
//      EEventType type
//
//  Returns:
//
//      LPCWSTR containing the event class name. This pointer is internal and
//                  may NOT be modified or deleted.
//
//*****************************************************************************
//
//  static GetTypeFromName
//
//  Retreives the type of the event given the name of the event class.
//
//  Parameters:
//      
//      LPCWSTR wszEventName    The name of the event class.
//
//  Returns:
//
//      EEventType
//
//*****************************************************************************
//
//  Get
//
//  Retrives the value of a property, as required by CPropertySource class.
//  This implementation uses the first included object (apObjects[0]) to
//  get the values. Access to other objects is not available.
//
//  Parameters:
//
//      LPCWSTR wszPropName     The same name as in IWbemClassObject
//      VARIANT* pValue         Destination for the value. The caller must
//                              initialize and clear this value.
//  Returns:
//
//      S_OK    on success
//      Any IWbemClassObject::Get error code
//
//*****************************************************************************


class CEssNamespace;
class CEss;
class CEventRepresentation
{
protected:
    BOOL m_bAllocated;
    IWbemClassObject* m_pCachedObject;
public:
    long type;
    DWORD dw1;
    DWORD dw2;
    LPWSTR wsz1;
    LPWSTR wsz2;
    LPWSTR wsz3;
    int nObjects;
    IWbemClassObject** apObjects;

public:
    CEventRepresentation()
        : m_bAllocated(FALSE), 
          m_pCachedObject(NULL),
          wsz1( NULL ),
          wsz2( NULL ),
          wsz3( NULL ),
          apObjects( NULL )
      {
           // uninitialized for speed
      }
    
    ~CEventRepresentation();

    STDMETHOD_(ULONG, AddRef)() {return 1;}
    STDMETHOD_(ULONG, Release)() {return 1;}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {*ppv = this; return S_OK;}

    STDMETHOD(GetPropertyValue)(WBEM_PROPERTY_NAME* pName, long lFlags,
                WBEM_WSTR* pwszCimType, WBEM_VARIANT* pvValue);
    STDMETHOD(InheritsFrom)(WBEM_WSTR wszName);


    inline EEventType GetEventType() {return (EEventType)type;}

    DELETE_ME CEventRepresentation* MakePermanentCopy();
    HRESULT MakeWbemObject(CEssNamespace* pNamespace,
                            RELEASE_ME IWbemClassObject** ppEventObj);
    HRESULT CreateFromObject(IWbemClassObject* pEvent, LPWSTR wszNamespace);

    HRESULT Get(READ_ONLY LPCWSTR wszPropName, 
                INIT_AND_CLEAR_ME VARIANT* pValue);

    inline BOOL IsInstanceEvent();
    inline BOOL IsClassEvent();

    static HRESULT Initialize(IWbemServices* pNamespace, 
                                IWbemDecorator* pDecorator);
    static HRESULT Shutdown();

    static INTERNAL LPCWSTR GetEventName(EEventType type);
    static DWORD GetTypeMaskFromName(READ_ONLY LPCWSTR wszEventName);
    static EEventType GetTypeFromName(READ_ONLY LPCWSTR wszEventName);
    static INTERNAL IWbemClassObject* GetEventClass(CEssNamespace* pNamespace, 
                                                        EEventType type);
    static INTERNAL IWbemClassObject* GetEventClass(CEss* pNamespace, 
                                                        EEventType type);

protected:
    static HRESULT GetObjectPropertyValue(IWbemClassObject* pObj, 
                                WBEM_PROPERTY_NAME* pName,
                                long lFlags, WBEM_WSTR* pwszCimType, 
                                VARIANT* pvValue);
    struct CEventTypeData
    {
        EEventType type;
        LPWSTR wszEventName;
        IWbemClassObject* pEventClass;
    };

    static CEventTypeData staticTypes[];
    static int NumEventTypes();
    static IWbemDecorator* mstatic_pDecorator;

    friend class CEss;
};

#define CLASS_OF(EVENT) (EVENT.wsz2)
#define NAMESPACE_OF(EVENT) (EVENT.wsz1)
#define OBJECT_OF(EVENT) (EVENT.apObjects[0])
#define OTHER_OBJECT_OF(EVENT) (EVENT.apObjects[1])

inline BOOL CEventRepresentation::IsInstanceEvent()
{
    return (type == e_EventTypeInstanceCreation || 
            type == e_EventTypeInstanceModification ||  
            type == e_EventTypeInstanceDeletion);
}

inline BOOL CEventRepresentation::IsClassEvent()
{
    return (type == e_EventTypeClassCreation || 
            type == e_EventTypeClassModification ||  
            type == e_EventTypeClassDeletion);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\essutils.h ===
//******************************************************************************
//
//  ESSUTILS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#ifndef __ESS_UTILS__H_
#define __ESS_UTILS__H_

#include <postpone.h>
#include <wbemutil.h>

struct CEssThreadObject
{
    BOOL m_bReferencedExternally;
    IWbemContext* m_pContext;
    CPostponedList m_PostponedList;
    CPostponedList m_PostponedEventList;

    static IWbemContext* mstatic_pSpecialContext;

protected:
    INTERNAL IWbemContext* GetSpecialContext();
    
public:
    CEssThreadObject(IWbemContext* pContext);
    ~CEssThreadObject();

    BOOL IsReferencedExternally() { return m_bReferencedExternally; }
    void SetReferencedExternally();

    void static ClearSpecialContext();
};

INTERNAL IWbemContext* GetCurrentEssContext();
INTERNAL CEssThreadObject* GetCurrentEssThreadObject();
void SetCurrentEssThreadObject(IWbemContext* pContext);
void SetConstructedEssThreadObject(CEssThreadObject* pObject);
void ClearCurrentEssThreadObject();
INTERNAL CPostponedList* GetCurrentPostponedList();
INTERNAL CPostponedList* GetCurrentPostponedEventList();

#define WBEM_REG_ESS WBEM_REG_WBEM L"\\ESS"

/****************************************************************************
  CEssSharedLock
*****************************************************************************/

class CEssSharedLock
{
    int m_nMode;
    int m_cWaitingExclusive;
    CRITICAL_SECTION m_cs;
    HANDLE m_hOkShared;
    HANDLE m_hOkExclusive;

public:
    
    CEssSharedLock() : m_nMode(0), m_cWaitingExclusive(0), 
                       m_hOkShared(NULL), m_hOkExclusive(NULL) {}

    BOOL Initialize()
    {
        _DBG_ASSERT( m_hOkShared == NULL && m_hOkExclusive == NULL );
        m_hOkShared = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( m_hOkShared != NULL )
        {
            m_hOkExclusive = CreateEvent( NULL, FALSE, FALSE, NULL );    
            if ( m_hOkExclusive != NULL )
            {
                try
                {
                    InitializeCriticalSection( &m_cs );
                }
                catch(...)
                {
                    return FALSE;
                }
            }    
        }
        return m_hOkExclusive != NULL;
    }
    
    ~CEssSharedLock() 
    {
        if ( m_hOkShared != NULL )
        {
            CloseHandle( m_hOkShared );
            if ( m_hOkExclusive != NULL )
            {
                CloseHandle( m_hOkExclusive );
                DeleteCriticalSection( &m_cs );
            }
        }
    }

    void EnterShared()
    {
        _DBG_ASSERT( m_hOkShared != NULL );

        EnterCriticalSection( &m_cs );
        while( m_nMode < 0 || m_cWaitingExclusive > 0 )
        {
            LeaveCriticalSection( &m_cs );
            WaitForSingleObject( m_hOkShared, INFINITE );
            EnterCriticalSection( &m_cs );
        }
        m_nMode++;
        ResetEvent( m_hOkExclusive );
        LeaveCriticalSection( &m_cs );
    }

    void EnterExclusive()
    {
        _DBG_ASSERT( m_hOkExclusive != NULL );

        EnterCriticalSection( &m_cs );
        while( m_nMode != 0 )
        {
            m_cWaitingExclusive++;
            LeaveCriticalSection( &m_cs );
            WaitForSingleObject( m_hOkExclusive, INFINITE );
            EnterCriticalSection( &m_cs );
            m_cWaitingExclusive--;
        }
        m_nMode = -1;
        ResetEvent( m_hOkShared );
        LeaveCriticalSection( &m_cs );
    }

    void Leave()
    {
        _DBG_ASSERT( m_nMode != 0 );
        BOOL bSignalExclusive = FALSE;
        BOOL bSignalShared = FALSE;
        
        EnterCriticalSection( &m_cs );
        if ( m_nMode > 0 )
        {
            if ( --m_nMode == 0 && m_cWaitingExclusive > 0 )
                bSignalExclusive = TRUE;
        }
        else
        {
            _DBG_ASSERT( m_nMode == -1 );
            if ( m_cWaitingExclusive > 0 )
                bSignalExclusive = TRUE;
            else
                bSignalShared = TRUE;
            m_nMode = 0;
        }    
        LeaveCriticalSection( &m_cs );

        if ( bSignalExclusive )
            SetEvent( m_hOkExclusive );
        else if ( bSignalShared )
            SetEvent( m_hOkShared );
    }
};

class CInEssSharedLock
{
    CEssSharedLock* m_pLock;

public:
    CInEssSharedLock( CEssSharedLock* pLock, BOOL bExclusive ) 
    : m_pLock(pLock)
    {
        if ( !bExclusive )
            pLock->EnterShared();
        else
            pLock->EnterExclusive();
    }
    ~CInEssSharedLock()
    {
        m_pLock->Leave();
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\eventrep.cpp ===
//*****************************************************************************
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  EVENTREP.CPP
//
//  This file implements basic classes for event representation.
//
//  See eventrep.h for documentation.
//
//  History:
//
//      11/27/96    a-levn      Compiles.
//
//*****************************************************************************
#include "precomp.h"
#include <stdio.h>
#include <ess.h>

CEventRepresentation::CEventTypeData CEventRepresentation::staticTypes[] = 
{
    {e_EventTypeExtrinsic, L"__ExtrinsicEvent", NULL},
    {e_EventTypeNamespaceCreation, L"__NamespaceCreationEvent", NULL},
    {e_EventTypeNamespaceDeletion, L"__NamespaceDeletionEvent", NULL},
    {e_EventTypeNamespaceModification, L"__NamespaceModificationEvent", NULL},
    {e_EventTypeClassCreation, L"__ClassCreationEvent", NULL},
    {e_EventTypeClassDeletion, L"__ClassDeletionEvent", NULL},
    {e_EventTypeClassModification, L"__ClassModificationEvent", NULL},
    {e_EventTypeInstanceCreation, L"__InstanceCreationEvent", NULL},
    {e_EventTypeInstanceDeletion, L"__InstanceDeletionEvent", NULL},
    {e_EventTypeInstanceModification, L"__InstanceModificationEvent", NULL},
    {e_EventTypeTimer, L"__TimerEvent", NULL}
};

IWbemDecorator* CEventRepresentation::mstatic_pDecorator = NULL;

//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************

int CEventRepresentation::NumEventTypes() 
{
    return sizeof(staticTypes) / sizeof CEventTypeData;
}


//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************
HRESULT CEventRepresentation::Initialize(IWbemServices* pNamespace, 
                                         IWbemDecorator* pDecorator)
{
    mstatic_pDecorator = pDecorator;
    pDecorator->AddRef();

    return WBEM_S_NO_ERROR;
}


HRESULT CEventRepresentation::Shutdown()
{
    if(mstatic_pDecorator)
    {
        mstatic_pDecorator->Release();
        mstatic_pDecorator = NULL;
    }

    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(staticTypes[i].pEventClass != NULL)
        {
            staticTypes[i].pEventClass->Release();
            staticTypes[i].pEventClass = NULL;
        }
    }
    return WBEM_S_NO_ERROR;
}
        
//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************
CEventRepresentation::~CEventRepresentation()
{
    if(m_bAllocated)
    {
        // All fields have been allocated, and need to be deleted
        // ======================================================

        delete wsz1;
        delete wsz2;
        delete wsz3;

        for(int i = 0; i < nObjects; i++)
        {
            (apObjects[i])->Release();
        }
        delete [] apObjects;
    }

    if(m_pCachedObject)
        m_pCachedObject->Release();
}


//******************************************************************************
//  public
//
//  See eventrep.h for documentation
//
//******************************************************************************
DELETE_ME CEventRepresentation* CEventRepresentation::MakePermanentCopy()
{
    // Allocate a new event structure and set flags to "allocated"
    // ===========================================================

    CEventRepresentation* pCopy = _new CEventRepresentation;
    if(pCopy == NULL)
        return NULL;

    pCopy->m_bAllocated = TRUE;

    pCopy->type = type;
    pCopy->dw1 = dw1;
    pCopy->dw2 = dw2;

    if(wsz1)
    {
        pCopy->wsz1 = _new WCHAR[wcslen(wsz1)+1];
        if(pCopy->wsz1 == NULL)
        {
            delete pCopy;
            return NULL;
        }
        wcscpy(pCopy->wsz1, wsz1);
    }
    else pCopy->wsz1 = NULL;

    if(wsz2)
    {
        pCopy->wsz2 = _new WCHAR[wcslen(wsz2)+1];
        if(pCopy->wsz2 == NULL)
        {
            delete pCopy;
            return NULL;
        }
        wcscpy(pCopy->wsz2, wsz2);
    }
    else pCopy->wsz2 = NULL;

    if(wsz3)
    {
        pCopy->wsz3 = _new WCHAR[wcslen(wsz3)+1];
        if(pCopy->wsz3 == NULL)
        {
            delete pCopy;
            return NULL;
        }
        wcscpy(pCopy->wsz3, wsz3);
    }
    else pCopy->wsz3 = NULL;

    pCopy->nObjects = nObjects;
    pCopy->apObjects = _new IWbemClassObject*[nObjects];
    if(pCopy->apObjects == NULL)
    {
        delete pCopy;
        return NULL;
    }

    // Make fresh copies of all objects
    // ================================
    // TBD: more effecient solutions may be possible here!

    for(int i = 0; i < nObjects; i++)
    {
        HRESULT hres = apObjects[i]->Clone(pCopy->apObjects + i);
        if(FAILED(hres)) 
        {
            // Abort
            pCopy->nObjects = i; // successfully copied
            delete pCopy;
            return NULL;
        }
    }

    return pCopy;
}


//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
INTERNAL LPCWSTR CEventRepresentation::GetEventName(EEventType type)
{
    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(staticTypes[i].type == type) return staticTypes[i].wszEventName;
    }
    return NULL;
}


//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
INTERNAL IWbemClassObject* CEventRepresentation::GetEventClass(
                            CEssNamespace* pNamespace, EEventType type)
{
    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(staticTypes[i].type == type) 
        {
            if(staticTypes[i].pEventClass == NULL)
            {
                _IWmiObject* pClass = NULL;
                HRESULT hres = pNamespace->GetClass(staticTypes[i].wszEventName,
                                                &pClass);
                if(FAILED(hres))
                    return NULL;

                staticTypes[i].pEventClass = pClass;
            }

            return staticTypes[i].pEventClass;
        }
    }
    return NULL;
}

INTERNAL IWbemClassObject* CEventRepresentation::GetEventClass(CEss* pEss,
                                                        EEventType type)
{
    CEssNamespace* pNamespace = NULL;
    HRESULT hres = pEss->GetNamespaceObject( L"root", FALSE, &pNamespace);
    if(FAILED(hres))
        return NULL;

    IWbemClassObject* pClass = GetEventClass(pNamespace, type);
    pNamespace->Release();
    return pClass;
}
    

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
DWORD CEventRepresentation::GetTypeMaskFromName(READ_ONLY LPCWSTR wszEventName)
{
    if(wszEventName[0] != '_')
        return 1 << e_EventTypeExtrinsic;

    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(!wbem_wcsicmp(staticTypes[i].wszEventName, wszEventName))
            return (1 << staticTypes[i].type);
    }

    if(!wbem_wcsicmp(wszEventName, L"__Event"))
    {
        return 0xFFFFFFFF;
    } 

    if(!wbem_wcsicmp(wszEventName, L"__NamespaceOperationEvent"))
    {
        return (1 << e_EventTypeNamespaceCreation) |
               (1 << e_EventTypeNamespaceDeletion) |
               (1 << e_EventTypeNamespaceModification);
    }
    if(!wbem_wcsicmp(wszEventName, L"__ClassOperationEvent"))
    {
        return (1 << e_EventTypeClassCreation) |
               (1 << e_EventTypeClassDeletion) |
               (1 << e_EventTypeClassModification);
    }
    if(!wbem_wcsicmp(wszEventName, L"__InstanceOperationEvent"))
    {
        return (1 << e_EventTypeInstanceCreation) |
               (1 << e_EventTypeInstanceDeletion) |
               (1 << e_EventTypeInstanceModification);
    }

    if(!wbem_wcsicmp(wszEventName, EVENT_DROP_CLASS) ||
        !wbem_wcsicmp(wszEventName, QUEUE_OVERFLOW_CLASS) ||
        !wbem_wcsicmp(wszEventName, CONSUMER_FAILURE_CLASS))
    {
        return (1 << e_EventTypeSystem);
    }

    return 1 << e_EventTypeExtrinsic;
}


//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
EEventType CEventRepresentation::GetTypeFromName(READ_ONLY LPCWSTR wszEventName)
{
    for(int i = 0; i < NumEventTypes(); i++)
    {
        if(!_wcsicmp(staticTypes[i].wszEventName, wszEventName))
            return staticTypes[i].type;
    }

    return e_EventTypeExtrinsic;
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
HRESULT CEventRepresentation::MakeWbemObject(
                                       CEssNamespace* pNamespace,
                                       RELEASE_ME IWbemClassObject** ppEventObj)
{
    HRESULT hres;

    // Check if we have a cached copy
    // ==============================

    if(m_pCachedObject != NULL)
    {
        *ppEventObj = m_pCachedObject;
        m_pCachedObject->AddRef();
        return S_OK;
    }

    if(type == e_EventTypeExtrinsic || type == e_EventTypeTimer || 
        type == e_EventTypeSystem)
    {
        *ppEventObj = apObjects[0];
        (*ppEventObj)->AddRef();
        return S_OK;
    }
    
    // Create an instance
    // ==================

    IWbemClassObject* pClass = GetEventClass(pNamespace, (EEventType)type);
    if(pClass == NULL)
    {
        return WBEM_E_NOT_FOUND;
    }

    IWbemClassObject* pEventObj = NULL;
    if(FAILED(pClass->SpawnInstance(0, &pEventObj)))
    {
        return WBEM_E_FAILED;
    }
    CReleaseMe rm1(pEventObj);

    // Set event-dependent properties
    // ==============================

    VARIANT vFirst, vSecond;
    VariantInit(&vFirst);
    VariantInit(&vSecond);
    CClearMe cm1(&vFirst);
    CClearMe cm2(&vSecond);

    if(nObjects > 0)
    {
        V_VT(&vFirst) = VT_EMBEDDED_OBJECT;
        V_EMBEDDED_OBJECT(&vFirst) = apObjects[0];
        apObjects[0]->AddRef();
    }

    if(nObjects > 1)
    {
        V_VT(&vSecond) = VT_EMBEDDED_OBJECT;
        V_EMBEDDED_OBJECT(&vSecond) = apObjects[1];
        if(apObjects[1])
            apObjects[1]->AddRef();
        else
            V_VT(&vSecond) = VT_NULL; // no previous!
    }
    
    LPCWSTR wszFirstProp = NULL, wszSecondProp = NULL;

    hres = WBEM_E_CRITICAL_ERROR;
    switch(type)
    {
        case e_EventTypeInstanceCreation:
            hres = pEventObj->Put(TARGET_INSTANCE_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeInstanceDeletion:
            hres = pEventObj->Put(TARGET_INSTANCE_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeInstanceModification:
            hres = pEventObj->Put(TARGET_INSTANCE_PROPNAME, 0, &vFirst, 0); 
            if(SUCCEEDED(hres))
                hres = pEventObj->Put(PREVIOUS_INSTANCE_PROPNAME, 0, 
                                                &vSecond, 0); 
            break;

        case e_EventTypeClassCreation:
            hres = pEventObj->Put(TARGET_CLASS_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeClassDeletion:
            hres = pEventObj->Put(TARGET_CLASS_PROPNAME, 0, &vFirst, 0); 
            break;
        case e_EventTypeClassModification:
            hres = pEventObj->Put(TARGET_CLASS_PROPNAME, 0, &vFirst, 0); 
            if(SUCCEEDED(hres))
                hres = pEventObj->Put(PREVIOUS_CLASS_PROPNAME, 0, &vSecond, 
                                            0); 
            break;

        case e_EventTypeNamespaceCreation:
            hres = pEventObj->Put(TARGET_NAMESPACE_PROPNAME, 0, &vFirst, 0);
            break;
        case e_EventTypeNamespaceDeletion:
            hres = pEventObj->Put(TARGET_NAMESPACE_PROPNAME, 0, &vFirst, 0);
            break;
        case e_EventTypeNamespaceModification:
            hres = pEventObj->Put(TARGET_NAMESPACE_PROPNAME, 0, &vFirst, 0);
            if(SUCCEEDED(hres))
                hres = pEventObj->Put(PREVIOUS_NAMESPACE_PROPNAME, 0, 
                                            &vSecond, 0); 
            break;
    }

    if(FAILED(hres))
        return hres;

    // Decorate it
    // ===========

    if(mstatic_pDecorator)
    {
        hres = mstatic_pDecorator->DecorateObject(pEventObj, wsz1);
        if(FAILED(hres))
            return hres;
    }

    // Store it in our cache
    // =====================

    m_pCachedObject = pEventObj;
    m_pCachedObject->AddRef();

    *ppEventObj = pEventObj;
    (*ppEventObj)->AddRef();

    return S_OK;
}

HRESULT CEventRepresentation::CreateFromObject(IWbemClassObject* pEvent,
                                                LPWSTR wszNamespace)
{
    HRESULT hres;

    // Get the class of the event
    // ==========================

    VARIANT vClass;
    VariantInit(&vClass);
    pEvent->Get(L"__CLASS", 0, &vClass, NULL, NULL);

    type = GetTypeFromName(V_BSTR(&vClass));
    dw1 = 0;
    dw2 = 0;
    wsz1 = _new WCHAR[wcslen(wszNamespace)+1];
    wcscpy(wsz1, wszNamespace);
    wsz2 = NULL;
    wsz3 = NULL;
    nObjects = 1;
    m_bAllocated = TRUE;

    IWbemClassObject** aEmbedded = new IWbemClassObject*[2];
    apObjects = (IWbemClassObject**)aEmbedded;
    aEmbedded[0] = pEvent;
    pEvent->AddRef();

    VariantClear(&vClass);

    // If the event is an intrinsic one, get the class of the target object
    // ====================================================================

    VARIANT vEmbed;
    VariantInit(&vEmbed);

#define SET_FIRST_OBJECT \
        { \
            pEvent->Release(); \
            aEmbedded[0] = (IWbemClassObject*)V_EMBEDDED_OBJECT(&vEmbed); \
            aEmbedded[0]->AddRef(); \
            aEmbedded[0]->Get(L"__CLASS", 0, &vClass, NULL, NULL); \
            wsz2 = _new WCHAR[wcslen(V_BSTR(&vClass))+1]; \
            wcscpy(wsz2, V_BSTR(&vClass)); \
            VariantClear(&vEmbed); \
        }

#define SET_SECOND_OBJECT \
        {  \
            nObjects = 2; \
            aEmbedded[1] = (IWbemClassObject*)V_EMBEDDED_OBJECT(&vEmbed); \
            aEmbedded[1]->AddRef(); \
            VariantClear(&vEmbed); \
        }

    switch(type)
    {
    case e_EventTypeClassModification:
        hres = pEvent->Get(PREVIOUS_CLASS_PROPNAME, 0, &vEmbed, NULL, NULL);
        if(SUCCEEDED(hres))
            SET_SECOND_OBJECT;

    case e_EventTypeClassCreation:
    case e_EventTypeClassDeletion:
        hres = pEvent->Get(TARGET_CLASS_PROPNAME, 0, &vEmbed, NULL, NULL);
        if(SUCCEEDED(hres))
            SET_FIRST_OBJECT
        break;

    case e_EventTypeInstanceModification:
        hres = pEvent->Get(PREVIOUS_INSTANCE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_SECOND_OBJECT;
    case e_EventTypeInstanceCreation:
    case e_EventTypeInstanceDeletion:
        hres = pEvent->Get(TARGET_INSTANCE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_FIRST_OBJECT;
        break;
            
    case e_EventTypeNamespaceModification:
        hres = pEvent->Get(PREVIOUS_NAMESPACE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_SECOND_OBJECT;
    case e_EventTypeNamespaceCreation:
    case e_EventTypeNamespaceDeletion:
        hres = pEvent->Get(TARGET_NAMESPACE_PROPNAME, 0, &vEmbed, 
                            NULL, NULL);
        if(SUCCEEDED(hres))
            SET_FIRST_OBJECT;
        break;
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
HRESULT CEventRepresentation::Get(READ_ONLY LPCWSTR wszPropName, 
                                  INIT_AND_CLEAR_ME VARIANT* pValue)
{
    // Get the property from the first object
    // ======================================

    return apObjects[0]->Get((LPWSTR)wszPropName, 0, pValue, NULL, NULL);
}

STDMETHODIMP CEventRepresentation::GetPropertyValue(WBEM_PROPERTY_NAME* pName, 
                long lFlags, WBEM_WSTR* pwszCimType, WBEM_VARIANT* pvValue)
{
    if(type == e_EventTypeExtrinsic || type == e_EventTypeTimer)
    {
        return GetObjectPropertyValue(apObjects[0], pName, lFlags, 
                                        pwszCimType, pvValue);
    }
    
    if(pName->m_lNumElements == 0 || 
        pName->m_aElements[0].m_nType != WBEM_NAME_ELEMENT_TYPE_PROPERTY)
    {
        return WBEM_E_NOT_FOUND;
    }

    // Check if it is a system property
    // ================================

    WBEM_WSTR wszFirst = pName->m_aElements[0].Element.m_wszPropertyName;
    if(wszFirst[0] == L'_')
    {
        if(pwszCimType) 
            *pwszCimType = NULL;

        if(!_wcsicmp(wszFirst, L"__CLASS"))
        {
            V_VT(pvValue) = VT_BSTR;
            V_BSTR(pvValue) = SysAllocString(GetEventName((EEventType)type));
            if(V_BSTR(pvValue) == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
        else if(!_wcsicmp(wszFirst, L"__SUPERCLASS"))
        {
            LPCWSTR wszClass = GetEventName((EEventType)type);
            if(wszClass == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            V_VT(pvValue) = VT_BSTR;
            if(wszClass[2] == 'N')
            {
                V_BSTR(pvValue) = SysAllocString(L"__NamespaceOperationEvent");
                if(V_BSTR(pvValue) == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            if(wszClass[2] == 'C')
            {
                V_BSTR(pvValue) = SysAllocString(L"__ClassOperationEvent");
                if(V_BSTR(pvValue) == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            if(wszClass[2] == 'I')
            {
                V_BSTR(pvValue) = SysAllocString(L"__InstanceOperationEvent");
                if(V_BSTR(pvValue) == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
            {
                V_BSTR(pvValue) = SysAllocString(L"__Event");
                if(V_BSTR(pvValue) == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else if(!_wcsicmp(wszFirst, L"__DYNASTY"))
        {
            V_VT(pvValue) = VT_BSTR;
            V_BSTR(pvValue) = SysAllocString(L"__SystemClass");
            if(V_BSTR(pvValue) == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            return WBEM_E_NOT_FOUND;
        }

        return WBEM_S_NO_ERROR;
    }

    // Remove the first segment
    // ========================

    WBEM_PROPERTY_NAME Rest;
    Rest.m_lNumElements = pName->m_lNumElements - 1;
    Rest.m_aElements = pName->m_aElements + 1;

    IWbemClassObject* pObj = NULL;

    switch(type)
    {
        case e_EventTypeInstanceCreation:
        case e_EventTypeInstanceDeletion:
            if(!_wcsicmp(wszFirst, TARGET_INSTANCE_PROPNAME))
                pObj = apObjects[0];
            break;
        case e_EventTypeInstanceModification:
            if(!_wcsicmp(wszFirst, TARGET_INSTANCE_PROPNAME))
                pObj = apObjects[0];
            else if(!_wcsicmp(wszFirst, PREVIOUS_INSTANCE_PROPNAME))
                pObj = apObjects[1];
            break;

        case e_EventTypeClassCreation:
        case e_EventTypeClassDeletion:
            if(!_wcsicmp(wszFirst, TARGET_CLASS_PROPNAME))
                pObj = apObjects[0];
            break;
        case e_EventTypeClassModification:
            if(!_wcsicmp(wszFirst, TARGET_CLASS_PROPNAME))
                pObj = apObjects[0];
            else if(!_wcsicmp(wszFirst, PREVIOUS_CLASS_PROPNAME))
                pObj = apObjects[1];
            break;

        case e_EventTypeNamespaceCreation:
        case e_EventTypeNamespaceDeletion:
            if(!_wcsicmp(wszFirst, TARGET_NAMESPACE_PROPNAME))
                pObj = apObjects[0];
            break;
        case e_EventTypeNamespaceModification:
            if(!_wcsicmp(wszFirst, TARGET_NAMESPACE_PROPNAME))
                pObj = apObjects[0];
            else if(!_wcsicmp(wszFirst, PREVIOUS_NAMESPACE_PROPNAME))
                pObj = apObjects[1];
            break;
    }

    if(pObj == NULL)
        return WBEM_E_NOT_FOUND;
    
    return GetObjectPropertyValue(pObj, &Rest, lFlags, pwszCimType, pvValue);
}

STDMETHODIMP CEventRepresentation::InheritsFrom(WBEM_WSTR wszName)
{
    if(type == e_EventTypeExtrinsic)
        return apObjects[0]->InheritsFrom(wszName);

    LPCWSTR wszEventName = GetEventName((EEventType)type);
    if(wszEventName == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if(!_wcsicmp(wszName, wszEventName))
        return S_OK;
    if(!_wcsicmp(wszName, L"__IndicationRelated"))
        return S_OK;
    if(!_wcsicmp(wszName, L"__Event"))
        return S_OK;
    if(!_wcsicmp(wszName, L"__NamespaceOperationEvent") && 
            wcsstr(wszEventName, L"Namespace"))
        return S_OK;
    if(!_wcsicmp(wszName, L"__ClassOperationEvent") && 
            wcsstr(wszEventName, L"Class"))
        return S_OK;
    if(!_wcsicmp(wszName, L"__InstanceOperationEvent") && 
            wcsstr(wszEventName, L"Instance"))
        return S_OK;

    return S_FALSE;
}

HRESULT CEventRepresentation::GetObjectPropertyValue(
                                IWbemClassObject* pObj, WBEM_PROPERTY_NAME* pName,
                                long lFlags, WBEM_WSTR* pwszCimType, 
                                VARIANT* pvValue)
{
    // Check if there is no name
    // =========================

    if(pName->m_lNumElements == 0)
    {
        // Return ourselves in a variant
        // =============================

        if(pwszCimType)
            *pwszCimType = WbemStringCopy(L"object");
        V_VT(pvValue) = VT_EMBEDDED_OBJECT;
        V_EMBEDDED_OBJECT(pvValue) = (I_EMBEDDED_OBJECT*)pObj;
        return S_OK;
    }

    IWbemPropertySource* pSource;
    if(FAILED(pObj->QueryInterface(IID_IWbemPropertySource, (void**)&pSource)))
    {
        return WBEM_E_CRITICAL_ERROR;
    }
    HRESULT hres = pSource->GetPropertyValue(pName, lFlags, pwszCimType, 
                                                pvValue);
    pSource->Release();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\esssink.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  ESSSINK.CPP
//
//  This files implements the class that implements IWbemObjectSink for the ESS.
//
//  See esssink.h for documentation.
//
//  History:
//
//  11/27/96    a-levn      Compiles
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "esssink.h"

#define IN_ESS_OPERATION \
    CInEssSharedLock isl( &m_pObject->m_Lock, FALSE ); \
    if ( m_pObject->m_pEss == NULL ) \
        return WBEM_E_INVALID_OPERATION; \
    if ( m_pObject->m_bShutdown ) \
        return WBEM_E_SHUTTING_DOWN;

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
CEssObjectSink::CEssObjectSink(CLifeControl* pControl, IUnknown* pOuter)
 : CUnk(pControl, pOuter), m_XESS(this), m_XNewESS(this), m_XShutdown(this),
   m_XHook(this), m_bShutdown(FALSE), m_pEss(NULL), m_pCoreServices(NULL)
{
}

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
CEssObjectSink::~CEssObjectSink()
{
    if( m_pCoreServices )
    {
        m_pCoreServices->Release();
    }
}

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
void* CEssObjectSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventSubsystem_m4)
        return &m_XESS;
    else if(riid == IID_IWbemShutdown)
        return &m_XShutdown;
    else if(riid == IID__IWmiESS)
        return &m_XNewESS;
    else if(riid == IID__IWmiCoreWriteHook)
        return &m_XHook;
    
    return NULL;
}

//*****************************************************************************
//  public
//
//  See esssink.h for documentation
//
//*****************************************************************************
STDMETHODIMP CEssObjectSink::XESS::ProcessInternalEvent(long lSendType, 
        LPCWSTR str1, LPCWSTR str2, 
        LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
        _IWmiObject** apObjects, IWbemContext* pContext)
{
    IN_ESS_OPERATION

    CEventRepresentation Event;
    Event.type = lSendType;
    Event.dw1 = dw1;
    Event.dw2 = dw2;
    Event.wsz1 = (LPWSTR)str1;
    Event.wsz2 = (LPWSTR)str2;
    Event.wsz3 = (LPWSTR)str3;
    Event.nObjects = (int)dwObjectCount;
    Event.apObjects = (IWbemClassObject**)apObjects;

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(pContext);

    //
    // we must remove the client's security context from the thread because
    // it is really winmgmt raising these events, not the client.
    // 

    IUnknown *pGarb, *pCtx = NULL;
    CoSwitchCallContext( NULL, &pCtx );

    // Do the actual processing
    // ========================

    HRESULT hres = m_pObject->m_pEss->ProcessEvent(Event, (long)dw2);

    // Restore the context
    // ===================

    CoSwitchCallContext( pCtx, &pGarb );
 
    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }
    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::VerifyInternalEvent(long lSendType, 
        LPCWSTR str1, LPCWSTR str2, 
        LPCWSTR str3, DWORD dw1, DWORD dw2, DWORD dwObjectCount, 
        _IWmiObject** apObjects, IWbemContext* pContext)
{
    IN_ESS_OPERATION

    CEventRepresentation Event;
    Event.type = lSendType;
    Event.dw1 = dw1;
    Event.dw2 = dw2;
    Event.wsz1 = (LPWSTR)str1;
    Event.wsz2 = (LPWSTR)str2;
    Event.wsz3 = (LPWSTR)str3;
    Event.nObjects = (int)dwObjectCount;
    Event.apObjects = (IWbemClassObject**)apObjects;

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(pContext);

    // Do the actual processing
    // ========================

    HRESULT hres = m_pObject->m_pEss->VerifyInternalEvent(Event);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }
    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::RegisterNotificationSink(
            LPCWSTR wszNamespace, 
            LPCWSTR wszQueryLanguage, LPCWSTR wszQuery, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink)
{
    IN_ESS_OPERATION

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(pContext);

    // Do the actual processing
    // ========================

    HRESULT hres = m_pObject->m_pEss->RegisterNotificationSink(wszNamespace, 
        wszQueryLanguage, wszQuery, lFlags, pContext, pSink);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }

    // Return
    // ======

    if(FAILED(hres))
    {
        pSink->SetStatus(0, hres, NULL, NULL);
    }
    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::RemoveNotificationSink(
                                                      IWbemObjectSink* pSink)
{
    IN_ESS_OPERATION

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(NULL);

    // Do the actual processing
    // ========================

    HRESULT hres = m_pObject->m_pEss->RemoveNotificationSink(pSink);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }

    return hres;
}

    
STDMETHODIMP CEssObjectSink::XESS::GetNamespaceSink(LPCWSTR wszNamespace, 
            IWbemObjectSink** ppSink)
{
    IN_ESS_OPERATION

    CEssNamespaceSink* pSink = _new CEssNamespaceSink(m_pObject->m_pEss,
                                                        m_pObject->m_pControl);
    if(pSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = pSink->Initialize(wszNamespace);
    if(FAILED(hres))
    {
        delete pSink;
        return hres;
    }

    return pSink->QueryInterface(IID_IWbemObjectSink, (void**)ppSink);
}

STDMETHODIMP CEssObjectSink::XNewESS::Initialize( long lFlags, 
                                                  IWbemContext* pCtx,
                                                  _IWmiCoreServices* pServices)
{
    //
    // This function is not multi-thread safe by design. We do not support 
    // concurrent operations while in this function.  The expectation is that 
    // the user will call this method and THEN introduce the object into
    // an environment where it can be called concurrently. 
    //

    //
    // This object will not support being called after a failed initialization.
    // The user must deallocate the object and then allocate a new one.
    // 

    HRESULT hres;

    if ( m_pObject->m_pEss != NULL )
    {
        return WBEM_S_FALSE;
    }

    if ( m_pObject->m_bShutdown )
    {
        return WBEM_E_INVALID_OPERATION;
    }

    if ( !m_pObject->m_Lock.Initialize() )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // set shutdown to true in case we exit prematurely. This will prevent 
    // any future calls to this function after a failed init.
    // 
    m_pObject->m_bShutdown = TRUE;

    //
    // Get current machine name --- core is not giving it to us anymore
    //

    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH+1;
    if(!GetComputerNameW(wszComputerName, &dwSize))
    {
        ERRORTRACE((LOG_ESS, "Cannot retrieve computer name: %d\n", 
                GetLastError()));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Get the decorator from core services
    //

    CWbemPtr<IWbemDecorator> pDecor;
    hres = pServices->GetDecorator(0, &pDecor);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Cannot retrieve decorator: 0x%X\n", hres));   
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Hook all core write operations
    //

    m_pObject->m_pCoreServices = pServices;
    m_pObject->m_pCoreServices->AddRef();

    hres = m_pObject->m_pCoreServices->RegisterWriteHook(WBEM_FLAG_INST_PUT|WBEM_FLAG_INST_DELETE, 
                                        &m_pObject->m_XHook);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to hook core write operations: 0x%X\n", 
            hres));
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Initialize for real
    //

    CEss* pEss = NULL;
    try
    {
        pEss = new CEss();
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( pEss == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // create a context object that will be passed around with all work that
    // is done on behalf of ess init.
    //  

    CWbemPtr<IWbemContext> pContext;

    hres = CoCreateInstance( CLSID_WbemContext, 
                             NULL, 
                             CLSCTX_INPROC_SERVER,
                             IID_IWbemContext,
                             (void**)&pContext );
    
    if ( SUCCEEDED(hres) )
    {
        //
        // set the context to be an init context object.
        //

        VARIANT vInit;
        V_VT(&vInit) = VT_BOOL;
        V_BOOL(&vInit) = VARIANT_TRUE;
        hres = pContext->SetValue( L"__EssInInitialize", 0, &vInit ); 
    }

    if ( SUCCEEDED(hres) )
    {
        //
        // attach the init context to the thread
        // 
        
        SetCurrentEssThreadObject( pContext ); 

        if ( GetCurrentEssThreadObject() == NULL )
        {
            hres = WBEM_E_OUT_OF_MEMORY;
        }
    }

    if ( FAILED(hres) )
    {  
        ERRORTRACE(( LOG_ESS, "Error creating ess context object during init"
                     "HR=0x%x\n", hres ));
        return hres;
    }

    hres = pEss->Initialize( wszComputerName, lFlags, pServices, pDecor );

    //
    // Restore the context
    //

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;
    ClearCurrentEssThreadObject();

    if ( FAILED(hres) )
    {
        delete pEss;
        return hres;
    }

    m_pObject->m_pEss = pEss;
    m_pObject->m_bShutdown = FALSE;

    return hres;
}
    
STDMETHODIMP CEssObjectSink::XNewESS::ExecNotificationQuery(
            LPCWSTR wszNamespace, LPCWSTR wszQueryText, long lFlags, 
            IWbemContext* pContext, IWbemObjectSink* pSink)
{ 
    return m_pObject->m_XESS.RegisterNotificationSink(wszNamespace,
                                L"WQL", wszQueryText, lFlags, pContext, pSink);
}
                
STDMETHODIMP CEssObjectSink::XNewESS::CancelAsyncCall(IWbemObjectSink* pSink)
{
    return m_pObject->m_XESS.RemoveNotificationSink(pSink);
}

STDMETHODIMP CEssObjectSink::XNewESS::QueryObjectSink(LPCWSTR wszNamespace, 
    IWbemObjectSink** ppSink)
{
    return m_pObject->m_XESS.GetNamespaceSink(wszNamespace, ppSink);
}
        
STDMETHODIMP CEssObjectSink::XESS::Initialize(LPCWSTR wszServer,
                                                IWbemLocator* pAdminLocator,
                                                IUnknown* pServices)
{
    //
    // Use the _IWmiESS version.
    //
    return WBEM_E_NOT_SUPPORTED;
}


STDMETHODIMP CEssObjectSink::XShutdown::Shutdown( LONG uReason,
                                                  ULONG uMaxMilliseconds,
                                                  IWbemContext* pCtx )
{

    // uMaxMilliseconds == 0 means system shutdown
    if (0 == uMaxMilliseconds)
        return WBEM_S_NO_ERROR;

    {
        //
        // wait for all current operations to complete. Lock will prevent 
        // any new operations from getting through.
        // 

        CInEssSharedLock isl( &m_pObject->m_Lock, TRUE );
       
        if ( m_pObject->m_bShutdown )
        {
            return WBEM_S_FALSE;
        }

        m_pObject->m_bShutdown = TRUE;
    }

    HRESULT hres;

    //
    // Unhook all core write operations
    //


    
	hres = m_pObject->m_pCoreServices->UnregisterWriteHook(
	                                            &m_pObject->m_XHook);
	if(FAILED(hres))
	{
	    ERRORTRACE((LOG_ESS, "Unable to unhook core write operations: 0x%X\n", 
	        hres));
	}

	SetCurrentEssThreadObject(NULL);
    
    hres = m_pObject->m_pEss->Shutdown((0 == uMaxMilliseconds)?TRUE:FALSE);


    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;
    ClearCurrentEssThreadObject();

    if ( m_pObject->m_pEss != NULL )
    {
        delete m_pObject->m_pEss;
        m_pObject->m_pEss = NULL;
    }

    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::Shutdown()
{
    HRESULT hres;

    {
        //
        // wait for all current operations to complete. Lock will prevent 
        // any new operations from getting through.
        // 

        CInEssSharedLock isl( &m_pObject->m_Lock, TRUE );
       
        if ( m_pObject->m_bShutdown )
        {
            return WBEM_S_FALSE;
        }

        m_pObject->m_bShutdown = TRUE;
    }


    SetCurrentEssThreadObject(NULL);

    hres = m_pObject->m_pEss->Shutdown(FALSE); // no system shutdown

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;
    ClearCurrentEssThreadObject();

    return hres;
}

STDMETHODIMP CEssObjectSink::XESS::LastCallForCore(LONG bIsSystemShutdown)
{
    IN_ESS_OPERATION

    return m_pObject->m_pEss->LastCallForCore(bIsSystemShutdown);
}

//*********************** NAMESPACE SINK **************************************

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
CEssNamespaceSink::CEssNamespaceSink(CEss* pEss,
                                     CLifeControl* pControl, IUnknown* pOuter) :
            CUnk(pControl, pOuter), m_XSink(this), 
            m_pEss(pEss)
{
}

HRESULT CEssNamespaceSink::Initialize(LPCWSTR wszNamespace)
{
    m_strNamespace = SysAllocString(wszNamespace);
    if(m_strNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
CEssNamespaceSink::~CEssNamespaceSink()
{
    SysFreeString(m_strNamespace);
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
void* CEssNamespaceSink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemObjectSink || riid == IID_IUnknown)
    {
        return &m_XSink;
    }
    return NULL;
}

//******************************************************************************
//  public
//
//  See esssink.h for documentation
//
//******************************************************************************
STDMETHODIMP CEssNamespaceSink::XSink::Indicate(long lObjectCount, 
                                      IWbemClassObject** apObjArray)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    for(int i = 0; i < lObjectCount; i++)
    {
        IWbemClassObject* pEvent = apObjArray[0];

        CEventRepresentation Event;
        Event.CreateFromObject(pEvent, m_pObject->m_strNamespace);

        hres = m_pObject->m_pEss->ProcessQueryObjectSinkEvent( Event );
    }

    return hres;
}


STDMETHODIMP CEssObjectSink::XHook::PrePut(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pCopy)
{
    HRESULT hres;

    IN_ESS_OPERATION

    //
    // Construct the old CEventRepresentation --- simplest route
    //

    CEventRepresentation Event;

    //
    // Determine whether a class or an instance is being put
    //

    if(pCopy->IsObjectInstance() == S_OK)
        Event.type = e_EventTypeInstanceCreation;
    else
        Event.type = e_EventTypeClassCreation;
    Event.dw1 = 0;
    Event.dw2 = 0;
    Event.wsz1 = (LPWSTR)wszNamespace;
    Event.wsz2 = (LPWSTR)wszClass;
    Event.wsz3 = NULL;
    Event.nObjects = 1;
    Event.apObjects = (IWbemClassObject**)&pCopy;

    // Store the old context value for the future
    // ==========================================

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    // Set it to the current one
    // =========================

    SetCurrentEssThreadObject(pContext);

    // Do the actual processing
    // ========================

    hres = m_pObject->m_pEss->VerifyInternalEvent(Event);

    // Restore the context
    // ===================

    CEssThreadObject* pNewThreadObject = GetCurrentEssThreadObject();
    delete pNewThreadObject;

    if(pOldThreadObject)
    {
        SetConstructedEssThreadObject(pOldThreadObject);
    }
    else
    {
        ClearCurrentEssThreadObject();
    }
    return hres;
}
    
STDMETHODIMP CEssObjectSink::XHook::PostPut(long lFlags, HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pNew, 
                            _IWmiObject* pOld)
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CEssObjectSink::XHook::PreDelete(long lFlags, long lUserFlags, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass)
{
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CEssObjectSink::XHook::PostDelete(long lFlags, 
                            HRESULT hApiResult, 
                            IWbemContext* pContext,
                            IWbemPath* pPath, LPCWSTR wszNamespace, 
                            LPCWSTR wszClass, _IWmiObject* pOld)
{
    return WBEM_S_NO_ERROR;
}

/****************************************************************************
  CEssInternalOperationSink
*****************************************************************************/

STDMETHODIMP CEssInternalOperationSink::Indicate( long cObjs, 
                                                  IWbemClassObject** ppObjs )
{
    HRESULT hr;

    //
    // if the calling thread already has a thread object, leave it.
    // 

    CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();

    if ( pOldThreadObject == NULL )
    {
        //
        // set up a new thread object.
        // 

        SetCurrentEssThreadObject(NULL);

        if ( GetCurrentEssThreadObject() == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    hr = m_pSink->Indicate( cObjs, ppObjs );

    //
    // delete the thread object if necessary 
    // 

    if ( pOldThreadObject == NULL )
    {
        delete GetCurrentEssThreadObject();
        ClearCurrentEssThreadObject();
    }

    return hr;
}

STDMETHODIMP CEssInternalOperationSink::SetStatus( long lFlags, 
                                                   HRESULT hres, 
                                                   BSTR bstr, 
                                                   IWbemClassObject* pObj )
{
    //
    // simply delegate ( for now )
    // 
    return m_pSink->SetStatus( lFlags, hres, bstr, pObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\evsink.cpp ===
//******************************************************************************
//
//  EVSINK.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <genutils.h>
#include <cominit.h>
#include "ess.h"
#include "evsink.h"

//****************************** CONTEXT **********************************//

CEventContext::~CEventContext()
{
    if( m_bOwning )
    {
        delete [] m_pSD;
    }
}

BOOL CEventContext::SetSD( long lSDLength, BYTE* pSD, BOOL bMakeCopy )
{
    BOOL bRes = TRUE;

    if ( m_bOwning )
    {
        delete [] m_pSD;
        m_bOwning = false;
    }

    m_lSDLength = lSDLength;
       
    if ( m_lSDLength > 0 )
    {
        if ( !bMakeCopy )
        {
            m_pSD = pSD;
            m_bOwning = false;
        }
        else
        {
            m_pSD = new BYTE[m_lSDLength];
            
            if ( m_pSD != NULL )
            {
                memcpy( m_pSD, pSD, m_lSDLength );
                m_bOwning = true;
            }
            else
            {
                bRes = FALSE;
            }
        }
    }
    else
    {
        m_pSD = NULL;
    }

    return bRes;
}

CReuseMemoryManager CEventContext::mstatic_Manager(sizeof CEventContext);

void *CEventContext::operator new(size_t nBlock)
{
    return mstatic_Manager.Allocate();
}
void CEventContext::operator delete(void* p)
{
    mstatic_Manager.Free(p);
}

/*
void* CEventContext::operator new(size_t nSize)
{
    return CTemporaryHeap::Alloc(nSize);
}
void CEventContext::operator delete(void* p)
{
    CTemporaryHeap::Free(p, sizeof(CEventContext));
}
*/

//*************************** ABSTRTACT EVENT SINK *************************//

STDMETHODIMP CAbstractEventSink::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink )
    {
        *ppv = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    else
        return E_NOINTERFACE;
}

STDMETHODIMP CAbstractEventSink::SetStatus(long, long, BSTR, IWbemClassObject*)
{
    return E_NOTIMPL;
}

HRESULT CAbstractEventSink::Indicate(long lNumEvemts, IWbemEvent** apEvents, 
                    CEventContext* pContext)
{
    return WBEM_E_CRITICAL_ERROR; // if not implemented, but called
}

STDMETHODIMP CAbstractEventSink::Indicate(long lNumEvents, 
                                         IWbemClassObject** apEvents)
{
    //
    // Event is being raised without security --- send it along with an empty
    // context
    //

    return Indicate(lNumEvents, apEvents, NULL);
}
                                        
STDMETHODIMP CAbstractEventSink::IndicateWithSD(long lNumEvents, 
                                         IUnknown** apEvents,
                                         long lSDLength, BYTE* pSD)
{
    HRESULT hres;

    //
    // Event is being raised with security -- send it along with that SD in the
    // context
    //

    CEventContext Context;
    Context.SetSD( lSDLength, pSD, FALSE );
    
    //
    // Allocate a stack buffer to cast the pointers
    //

    IWbemClassObject** apCast = NULL;

    try
    {
        apCast = (IWbemClassObject**)_alloca(sizeof(IUnknown*) * lNumEvents);
    }
    catch(...)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    for(int i = 0; i < lNumEvents; i++)
    {
        hres = apEvents[i]->QueryInterface( IID_IWbemClassObject, 
                                            (void**)&apCast[i] );
        if ( FAILED(hres) )
        {
            return hres;
        }
    }

    return Indicate(lNumEvents, apCast, &Context);
}

//*************************** OBJECT SINK *************************//

STDMETHODIMP CObjectSink::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
    {
        *ppv = (IWbemObjectSink*)this;
        AddRef();
        return S_OK;
    }
    // Hack to idenitfy ourselves to the core as a trusted component
    else if(riid == CLSID_WbemLocator)
    return S_OK;
    else
    return E_NOINTERFACE;
}

STDMETHODIMP CObjectSink::SetStatus(long, long, BSTR, IWbemClassObject*)
{
    return E_NOTIMPL;
}

ULONG STDMETHODCALLTYPE CObjectSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CObjectSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    delete this;
    return lRef;
}

//*************************** EVENT SINK *************************//

ULONG STDMETHODCALLTYPE CEventSink::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CEventSink::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    delete this;
    return lRef;
}

//*************************** OWNED EVENT SINK *************************//

COwnedEventSink::COwnedEventSink(CAbstractEventSink* pOwner) 
: m_pOwner(pOwner), m_lRef(0), m_bReleasing(false)
{
}

ULONG STDMETHODCALLTYPE COwnedEventSink::AddRef()
{
    CInCritSec ics(&m_cs);

    // 
    // Increment our ref count, as well as that of our putative owner
    //

    m_lRef++;
    if(m_pOwner)
    m_pOwner->AddRef();
    return m_lRef;
}

ULONG STDMETHODCALLTYPE COwnedEventSink::Release()
{
    bool bDelete = false;
    {
        CInCritSec ics(&m_cs);

        m_bReleasing = true;
        
        m_lRef--;

        // 
        // Propagate release to our owner.  This may cause Disconnect to be 
        // called, but it will know not to self-destruct because of 
        // m_bReleasing
        // 

        if(m_pOwner)
        m_pOwner->Release();    

        // 
        // Determine whether self-destruct is called for
        //
        
        if(m_lRef == 0 && m_pOwner == NULL)
        {    
            bDelete = true;
        }

        m_bReleasing = false;
    }

    if(bDelete)
    delete this;

    return 1;
}

void COwnedEventSink::Disconnect()
{
    bool bDelete = false;

    {
        CInCritSec ics(&m_cs);
        
        if(m_pOwner == NULL)
        return;
        
        // 
        // Release all the ref-counts that the owner has received through us
        //
        
        for(int i = 0; i < m_lRef; i++)
        m_pOwner->Release();
        
        //
        // Forget about the owner.  Once we have been released by externals, 
        // we go away
        //
        
        m_pOwner = NULL;

        // 
        // Check if we are already fully released by externals
        //

        if(m_lRef == 0 && !m_bReleasing)
        bDelete = true;
    }

    if(bDelete)
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\evsink.h ===
//******************************************************************************
//
//  EVSINK.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_SINKS__H_
#define __WMI_ESS_SINKS__H_

#include "eventrep.h"
#include <sync.h>
#include <unk.h>
#include <newnew.h>
#include <comutl.h>

class CEventContext
{
protected:
    long m_lSDLength;
    BYTE* m_pSD; 
    bool m_bOwning;

    static CReuseMemoryManager mstatic_Manager;

    CEventContext( const CEventContext& rOther );
    CEventContext& operator= ( const CEventContext& rOther );

public:
    CEventContext() : m_lSDLength(0), m_pSD(NULL), m_bOwning(false) {}
    ~CEventContext();

    BOOL SetSD( long lSDLength, BYTE* pSD, BOOL bMakeCopy );
    const SECURITY_DESCRIPTOR* GetSD() const    
        {return (SECURITY_DESCRIPTOR*)m_pSD;}
    long GetSDLength() const {return m_lSDLength;}

    void* operator new(size_t nSize);
    void operator delete(void* p);
};    
    
class CEssNamespace;
class CEventFilter;
class CAbstractEventSink : public IWbemObjectSink
{
public:
    CAbstractEventSink(){}
    virtual ~CAbstractEventSink(){}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);
    STDMETHOD(Indicate)(long lNumEvents, IWbemEvent** apEvents);
    STDMETHOD(IndicateWithSD)(long lNumEvents, IUnknown** apEvents,
                                long lSDLength, BYTE* pSD);

    virtual HRESULT Indicate(long lNumEvemts, IWbemEvent** apEvents, 
                                CEventContext* pContext) = 0;
    virtual INTERNAL CEventFilter* GetEventFilter() {return NULL;}
};

class CEventSink : public CAbstractEventSink
{
protected:
    long m_lRef;

public:
    CEventSink() : m_lRef(0){}
    virtual ~CEventSink(){}
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext) = 0;

    virtual INTERNAL CEventFilter* GetEventFilter() {return NULL;}
};

class CObjectSink : public IWbemObjectSink
{
protected:
    long m_lRef;

public:
    CObjectSink() : m_lRef(0){}
    virtual ~CObjectSink(){}
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD(Indicate)(long lNumEvents, IWbemEvent** apEvents) = 0;
    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*);
};

template <class TOuter, class TBase>
class CEmbeddedSink : public TBase
{
protected:
    TOuter* m_pOuter;

public:
    CEmbeddedSink(TOuter* pOuter) : m_pOuter(pOuter){}
    virtual ~CEmbeddedSink(){}
    ULONG STDMETHODCALLTYPE AddRef() {return m_pOuter->AddRef();}
    ULONG STDMETHODCALLTYPE Release() {return m_pOuter->Release();}

    STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
    {
        if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        {
            *ppv = (IWbemObjectSink*)this;
            AddRef();
            return S_OK;
        }
        // Hack to idenitfy ourselves to the core as a trusted component
        else if(riid == CLSID_WbemLocator)
            return S_OK;
        else
            return E_NOINTERFACE;
    }
    STDMETHOD(SetStatus)(long, long, BSTR, IWbemClassObject*)
    {
        return E_NOTIMPL;
    }
};

template <class TOuter>
class CEmbeddedObjectSink : public CEmbeddedSink<TOuter, IWbemObjectSink>
{
public:
    CEmbeddedObjectSink(TOuter* pOuter) 
        : CEmbeddedSink<TOuter, IWbemObjectSink>(pOuter)
    {}
};

template <class TOuter>
class CEmbeddedEventSink : public CEmbeddedSink<TOuter, CAbstractEventSink>
{
public:
    CEmbeddedEventSink(TOuter* pOuter) 
        : CEmbeddedSink<TOuter, CAbstractEventSink>(pOuter)
    {}
};
    
class COwnedEventSink : public CAbstractEventSink
{
protected:
    CAbstractEventSink* m_pOwner;
    CCritSec m_cs;
    long m_lRef;
    bool m_bReleasing;

public:
    COwnedEventSink(CAbstractEventSink* pOwner);
    ~COwnedEventSink(){}

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    void Disconnect();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\guard.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <ess.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\guard.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __WMI_ESS_GUARD__H_
#define __WMI_ESS_GUARD__H_

class CGuardable
{
protected:
    bool m_bDeactivatedByGuard;

public:
    CGuardable(bool bActive) : m_bDeactivatedByGuard(!bActive){}

    virtual HRESULT ActivateByGuard() = 0;
    virtual HRESULT DeactivateByGuard() = 0;
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\filter.h ===
//******************************************************************************
//
//  FILTER.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_ESS_FILTER__H_
#define __WBEM_ESS_FILTER__H_

#include "binding.h"
#include "aggreg.h"
#include <evaltree.h>


class CEventProjectingSink;
class CGenericFilter : public CEventFilter
{
protected:
    DWORD m_dwTypeMask; // immutable after creatioin
    
    CEvalTree* m_pTree;
    CEventAggregator* m_pAggregator;
    CEventProjectingSink* m_pProjector;

protected:
    HRESULT TestQuery(IWbemEvent* pEvent);

    class CNonFilteringSink : public CAbstractEventSink
    {
    protected:
        CGenericFilter* m_pOwner;
    
    public:
        CNonFilteringSink(CGenericFilter* pOwner) : m_pOwner(pOwner){}

        ULONG STDMETHODCALLTYPE AddRef() {return m_pOwner->AddRef();}
        ULONG STDMETHODCALLTYPE Release() {return m_pOwner->Release();}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents,
                            CEventContext* pContext);

        INTERNAL CEventFilter* GetEventFilter() {return m_pOwner;}
    } m_NonFilteringSink; // immutable

    friend CNonFilteringSink;


    HRESULT NonFilterIndicate(long lNumEvents, IWbemEvent** apEvents, 
                CEventContext* pContext);
    HRESULT Prepare(CContextMetaData* pMeta, QL_LEVEL_1_RPN_EXPRESSION** ppExp);
public:
    CGenericFilter(CEssNamespace* pNamespace);
    virtual ~CGenericFilter();

    HRESULT Create(LPCWSTR wszLanguage, LPCWSTR wszQuery);

    BOOL DoesNeedType(int nType) NOCS {return (m_dwTypeMask & (1 << nType));}
    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                        CEventContext* pContext);

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp) = 0;

    HRESULT GetReady(LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp);
    HRESULT GetReadyToFilter();

    CAbstractEventSink* GetNonFilteringSink() {return &m_NonFilteringSink;}
};

class CEventProjectingSink : public COwnedEventSink
{
protected:
    CWbemPtr<_IWmiObject> m_pLimitedClass;

public:
    CEventProjectingSink(CAbstractEventSink* pOwner) : 
        COwnedEventSink(pOwner){}
    HRESULT Initialize(_IWmiObject* pClass, QL_LEVEL_1_RPN_EXPRESSION* pExpr);
    ~CEventProjectingSink(){}

    HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    INTERNAL CEventFilter* GetEventFilter();

protected:

    HRESULT AddProperty( IWbemClassObject* pClassDef, CWStringArray& awsPropList, 
                            CPropertyName& PropName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\evtools.h ===
//******************************************************************************
//
//  EVTOOLS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TOOLS__H_
#define __WMI_ESS_TOOLS__H_

#include <sync.h>
#include <deque>
#include <malloc.h>
#include <newnew.h>
#include <eventrep.h>
#include <wstlallc.h>

class CUpdateLockable
{
public:
    virtual HRESULT LockForUpdate() = 0;
    virtual HRESULT UnlockForUpdate() = 0;
};

class CInUpdate
{
protected:
    CUpdateLockable* m_p;
public:
    CInUpdate(CUpdateLockable* p) : m_p(p)
    {
        p->LockForUpdate();
    }
    ~CInUpdate()
    {
        m_p->UnlockForUpdate();
    }
};

template<class TLockable>
class CInLock
{
protected:
    TLockable* m_p;
public:
    CInLock(TLockable* p) : m_p(p)
    {
        //
        // Do not return until the lock is held!
        //

        while(FAILED(m_p->Lock())) Sleep(1000);
    }
    ~CInLock()
    {
        m_p->Unlock();
    }
};

class CExecLine
{
public:
    class CTurn;

    CExecLine();
    virtual ~CExecLine();

    CTurn* GetInLine();
    DWORD WaitForTurn(CTurn* pTurn, DWORD dwTimeout = INFINITE);
    BOOL EndTurn(ACQUIRE CTurn* pTurn);
    BOOL DiscardTurn(ACQUIRE CTurn* pTurn);

public:
    class CTurn
    {
    public:
    protected:
        long m_lRef;
        HANDLE m_hEvent;
        DWORD m_dwOwningThreadId; 

    protected:
        CTurn();
        ~CTurn();
        long AddRef();
        long Release();
        BOOL Init();

        INTERNAL HANDLE GetEvent() {return m_hEvent;}
        void* operator new(size_t nSize);
        void operator delete(void* p);
        
        friend CExecLine;
    };

    class CInTurn
    {
    protected:
        CExecLine* m_pLine;
        CTurn* m_pTurn;

    public:
        CInTurn(CExecLine* pLine, CTurn* pTurn) : m_pLine(pLine), m_pTurn(pTurn)
        {
            m_pLine->WaitForTurn(m_pTurn);
        }
        ~CInTurn()
        {
            m_pLine->EndTurn(m_pTurn);
        }
    };


protected:
    CCritSec m_cs;
    std::deque<CTurn*,wbem_allocator<CTurn*> > m_qTurns;
    typedef std::deque<CTurn*,wbem_allocator<CTurn*> >::iterator TTurnIterator;
    CTurn* m_pCurrentTurn;
    CTurn* m_pLastIssuedTurn;
    DWORD m_dwLastIssuedTurnThreadId;

protected:
    BOOL ReleaseFirst();
};

/*
class CTemporaryHeap
{
public:
    class CHeapHandle
    {
    protected:
        HANDLE m_hHeap;
    
    public:
        CHeapHandle();
        ~CHeapHandle();

        HANDLE GetHandle() {return m_hHeap;}
        void* Alloc(int nSize) {return HeapAlloc(m_hHeap, 0, nSize);}
        void Free(void* p) {HeapFree(m_hHeap, 0, p);}
        void Compact() {HeapCompact(m_hHeap, 0);}
    };
protected:

    static CHeapHandle mstatic_HeapHandle;

public:
    static void* Alloc(int nSize) {return mstatic_HeapHandle.Alloc(nSize);}
    static void Free(void* p) {mstatic_HeapHandle.Free(p);}
    static void Compact() {mstatic_HeapHandle.Compact();}
};
*/

class CTemporaryHeap
{
protected:

    static CTempMemoryManager mstatic_Manager;

public:
    static void* Alloc(int nSize) {return mstatic_Manager.Allocate(nSize);}
    static void Free(void* p, int nSize) {mstatic_Manager.Free(p, nSize);}
    static void Compact() {}
};

INTERNAL const SECURITY_DESCRIPTOR* GetSD(IWbemEvent* pEvent, ULONG* pcEvent);
HRESULT SetSD(IWbemEvent* pEvent, const SECURITY_DESCRIPTOR* pSD);
        
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\localloc.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\filter.cpp ===
//******************************************************************************
//
//  FILTER.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "filter.h"

CGenericFilter::CGenericFilter(CEssNamespace* pNamespace) 
    : CEventFilter(pNamespace), m_pTree(NULL), m_pAggregator(NULL),
        m_pProjector(NULL), m_NonFilteringSink(this)
{
}

//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
HRESULT CGenericFilter::Create(LPCWSTR wszLanguage, LPCWSTR wszQuery)
{
    if(wbem_wcsicmp(wszLanguage, L"WQL"))
    {
        ERRORTRACE((LOG_ESS, "Unable to construct event filter with unknown "
            "query language '%S'.  The filter is not active\n", wszLanguage));
        return WBEM_E_INVALID_QUERY_TYPE;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CGenericFilter::Prepare(CContextMetaData* pMeta, 
                                QL_LEVEL_1_RPN_EXPRESSION** ppExp)
{
    HRESULT hres;

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    if(*ppExp == NULL)
    {
        // Get the query text
        // ==================
    
        LPWSTR wszQuery, wszQueryLanguage;
        BOOL bExact;

        hres = GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, &pExp);
        if(FAILED(hres))
            return hres;
    
        if(!bExact)
            return WBEM_E_NOT_SUPPORTED;

        if(wbem_wcsicmp(wszQueryLanguage, L"WQL"))
            return WBEM_E_INVALID_QUERY_TYPE;
        delete [] wszQuery;
        delete [] wszQueryLanguage;
    }
    else
    {
        pExp = *ppExp;
    }

    // Figure out what types of events we eat
    // ======================================

    m_dwTypeMask = 
        CEventRepresentation::GetTypeMaskFromName(pExp->bsClassName);
    if(m_dwTypeMask == 0)
    {
        ERRORTRACE((LOG_ESS, "Unable to construct event filter with invalid "
            "class name '%S'.  The filter is not active\n", 
            pExp->bsClassName));
        return WBEM_E_INVALID_CLASS;
    }

    // Perform a cursory validity check
    // ================================

    _IWmiObject* pClass;
    hres = pMeta->GetClass(pExp->bsClassName, &pClass);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to activate event filter with invalid "
            "class name '%S' (error %X).  The filter is not active\n", 
            pExp->bsClassName, hres));
        if(*ppExp == NULL)
            delete pExp;

        if(hres == WBEM_E_NOT_FOUND)
            hres = WBEM_E_INVALID_CLASS;

        return hres;
    }
    CReleaseMe rm1(pClass);

    hres = pClass->InheritsFrom(L"__Event");
    if(hres != WBEM_S_NO_ERROR)
    {
        ERRORTRACE((LOG_ESS, "Unable to activate event filter with invalid "
            "class name '%S' --- it is not an Event Class.  The filter is not "
            "active\n", pExp->bsClassName));
        if(*ppExp == NULL)
            delete pExp;
        return WBEM_E_NOT_EVENT_CLASS;
    }

    *ppExp = pExp;
    
    return WBEM_S_NO_ERROR;
}
    

HRESULT CGenericFilter::GetReadyToFilter()
{
    HRESULT hres;
    CInUpdate iu(this);

    // Create meta data
    // ================

    CEssMetaData* pRawMeta = new CEssMetaData(m_pNamespace);
    if(pRawMeta == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CContextMetaData Meta(pRawMeta, GetCurrentEssContext());

    // Prepare
    // =======

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    hres = Prepare(&Meta, &pExp);
    if(FAILED(hres))
    {
        MarkAsTemporarilyInvalid(hres);
        return hres;
    }

    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm3(pExp);
    
    // Create new evaluator
    // ====================

    CEvalTree* pTree = new CEvalTree;
    if(pTree == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = pTree->CreateFromQuery(&Meta, pExp, 0, 0x7FFFFFFF);
    if(FAILED(hres))
    {
        LPWSTR wszQuery = pExp->GetText();
        ERRORTRACE((LOG_ESS, "Unable to activate event filter with invalid "
            "query '%S' (error %X).  The filter is not active\n", 
            wszQuery, hres));
        delete [] wszQuery;
        delete pTree;
        MarkAsTemporarilyInvalid(hres);
        return hres;
    }

    // Now, replace the originals with the newely created ones. This is done in
    // the inner critical section, blocking event delivery
    // ========================================================================

    CEvalTree* pTreeToDelete = NULL;
    {
        CInCritSec ics(&m_cs);
    
        pTreeToDelete = m_pTree;
        m_pTree = pTree;
    }
    
    // Delete the old versions
    // =======================
        
    delete pTreeToDelete;
    return WBEM_S_NO_ERROR;
}

HRESULT CGenericFilter::GetReady(LPCWSTR wszQuery, 
                                    QL_LEVEL_1_RPN_EXPRESSION* pExp)
{
    HRESULT hres;
    CInUpdate iu(this);

    // Create meta data
    // ================

    CEssMetaData* pRawMeta = new CEssMetaData(m_pNamespace);
    if(pRawMeta == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CContextMetaData Meta(pRawMeta, GetCurrentEssContext());

    // Prepare
    // =======

    hres = Prepare(&Meta, &pExp);
    if(FAILED(hres))
    {
        MarkAsTemporarilyInvalid(hres);
        return hres;
    }

    // Compute the aggregator
    // ======================

    CEventAggregator* pAggreg = NULL;
    if(pExp->bAggregated)
    {
        // Create new aggregator
        // =====================
    
        pAggreg = new CEventAggregator(m_pNamespace, &m_ForwardingSink);
        if(pAggreg == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        hres = pAggreg->SetQueryExpression(&Meta, pExp);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to activate aggregator for filter with"
                " invalid aggregation query (error %X).  The filter is not"
                " active\n", hres));
            delete pAggreg;
            MarkAsTemporarilyInvalid(hres);
            return hres;
        }
    }

    // Compute the projector
    // =====================

    CEventProjectingSink* pProjector = NULL;
    if(!pExp->bStar)
    {
        // Get the class definition
        // ========================

        _IWmiObject* pClass = NULL;
        hres = Meta.GetClass(pExp->bsClassName, &pClass);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Invalid class %S in event filter!\n", 
                pExp->bsClassName));
            delete pAggreg;

            if(hres == WBEM_E_NOT_FOUND)
                hres = WBEM_E_INVALID_CLASS;

            MarkAsTemporarilyInvalid(hres);
            return hres;
        }
        CReleaseMe rm1( pClass );
            
        // Create new projector, pointing it either to the aggregator or, if 
        // not aggregating, our forwarding sink
        // =================================================================

        CAbstractEventSink* pProjDest = NULL;
        if(pAggreg)
            pProjDest = pAggreg;
        else
            pProjDest = &m_ForwardingSink;

        pProjector = new CEventProjectingSink(pProjDest);
        if(pProjector == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        hres = pProjector->Initialize( pClass, pExp );
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to activate projector for filter with"
                " invalid query (error %X).  The filter is not active\n", 
                hres));
            delete pAggreg;
            delete pProjector;
            MarkAsTemporarilyInvalid(hres);
            return hres;
        }
    }

    // Now, replace the originals with the newely created ones. This is done in
    // the inner critical section, blocking event delivery
    // ========================================================================

    CEventAggregator* pAggregToDelete = NULL;
    CEventProjectingSink* pProjectorToDelete = NULL;
    {
        CInCritSec ics(&m_cs);
        
        //
        // TBD: do we want to copy the state (buckets) that were there in the
        // previous aggregator?  Well, if we do that, we should take care of
        // two things:
        // 1) What if the types of the variables have changed (class change)?
        // 2) Preserving the state of the bucket-emptying timer instructions. 
        //      Right now, we are not set up to do that, since those
        //      instructions mention the aggregator by name
        //
        // if(pAggreg && m_pAggregator)
        //     m_pAggregator->CopyStateTo(pAggreg); // no CS

        pAggregToDelete = m_pAggregator;
        m_pAggregator = pAggreg;

        pProjectorToDelete = m_pProjector;
        m_pProjector = pProjector;
    }
    
    // Delete the old versions
    // =======================
    
    if(pAggregToDelete)
        pAggregToDelete->Deactivate(true); // fire what's there
    if(pProjectorToDelete)
        pProjectorToDelete->Disconnect();

    MarkAsValid();
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
CGenericFilter::~CGenericFilter()
{
    if(m_pAggregator)
        m_pAggregator->Deactivate(false);
    if(m_pProjector)
        m_pProjector->Disconnect();

    delete m_pTree;
}

HRESULT CGenericFilter::Indicate(long lNumEvents, IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hres;

    // Parse and ready the tree
    // ========================

    hres = GetReadyToFilter();
    if(FAILED(hres))
        return hres;
    
    // Construct an array into which the matching events will be placed
    // ================================================================

    CTempArray<IWbemEvent*> apMatchingEvents;
    if(!INIT_TEMP_ARRAY(apMatchingEvents, lNumEvents))
        return WBEM_E_OUT_OF_MEMORY;

    long lMatchingCount = 0;

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < lNumEvents; i++)
    {
        hres = TestQuery(apEvents[i]);
        if(FAILED(hres))
        {
            // Hard failure: already logged
            // ============================

            hresGlobal = hres;
        }
        else if(hres == S_OK)
        {
            // Match
            // =====

            apMatchingEvents[lMatchingCount++] = apEvents[i];
        }
    }            

    // Deliver the new array either into the aggregator or the forwarder
    // =================================================================

    if(lMatchingCount > 0)
    {
        hres = NonFilterIndicate(lMatchingCount, apMatchingEvents, pContext);
        if(FAILED(hres))
            hresGlobal = hres;
    }

    return hresGlobal;
}

//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
HRESULT CGenericFilter::TestQuery(IWbemEvent* pEvent)
{
    HRESULT hres;
    CInCritSec ics(&m_cs);

    if(m_pTree == NULL)
        return S_FALSE;

    // Get its efficient interface
    // ===========================

    IWbemObjectAccess* pEventAccess = NULL;
    hres = pEvent->QueryInterface(IID_IWbemObjectAccess, (void**)&pEventAccess);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm2(pEventAccess);
    
    // Run it through the evaluator
    // ============================
    
    CSortedArray aTrues;
    hres = m_pTree->Evaluate(pEventAccess, aTrues);
    if(FAILED(hres))
        return hres;

    if(aTrues.Size() > 0)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CGenericFilter::NonFilterIndicate( long lNumEvents, 
                                           IWbemEvent** apEvents,
                                           CEventContext* pContext)
{
    HRESULT hr;

    //
    // Delivery across this filter is subject to the owner of the filter
    // being allowed to see this event, per the SD that may be attached to
    // the context.  It is also subject to the SD on the filter allowing 
    // the event provider and event owner EXECUTE access as well.
    //

    _DBG_ASSERT( lNumEvents == 1 );
    hr = AccessCheck( pContext, apEvents[0] );

    if ( FAILED(hr) )
    {
        DEBUGTRACE((LOG_ESS, "Rejecting an event targeted at filter "
                    "'%S' in '%S' for security reasons\n",
                    (LPCWSTR)(WString)GetKey(),
                    m_pNamespace->GetName()) );

        return WBEM_S_FALSE;
    }

    //
    // Decide which route to take --- can be either an aggregator, or a 
    // projector, or just forward
    //

    CEventAggregator* pAggregator = NULL;
    CEventProjectingSink* pProjector = NULL;
    {
        CInCritSec ics(&m_cs);
        
        // 
        // Look for projector first --- if there, we use it, since aggregator
        // is chained behind it.
        //

        if(m_pProjector)
        {
            pProjector = m_pProjector;
            pProjector->AddRef();
        }
        else if(m_pAggregator)
        {
            pAggregator = m_pAggregator;
            pAggregator->AddRef();
        }
    }

    //
    // Take the route identified by a non-NULL pointer
    //

    if(pProjector)
    {
        CReleaseMe rm(pProjector);
        return pProjector->Indicate( lNumEvents, apEvents, pContext );
    }
    else if(pAggregator)
    {
        CReleaseMe rm(pAggregator);
        return pAggregator->Indicate( lNumEvents, apEvents, pContext );
    }
    else
    {
        return m_ForwardingSink.Indicate( lNumEvents, apEvents, pContext );
    }
}

HRESULT CGenericFilter::CNonFilteringSink::Indicate( long lNumEvents, 
                                                     IWbemEvent** apEvents,
                                                     CEventContext* pContext )
{
    return m_pOwner->NonFilterIndicate(lNumEvents, apEvents, pContext);
}

//******************************************************************************
//
//******************************************************************************

INTERNAL CEventFilter* CEventProjectingSink::GetEventFilter() 
{
    CInCritSec ics(&m_cs);

    if(m_pOwner)
        return m_pOwner->GetEventFilter();
    else 
        return NULL;
}

HRESULT CEventProjectingSink::Initialize( _IWmiObject* pClassDef, 
                                            QL_LEVEL_1_RPN_EXPRESSION* pExp)
{
    HRESULT hres;
    int i;

    // Extract the properties selected by the user.
    // ============================================

    CWStringArray awsPropList;
    for (i = 0; i < pExp->nNumberOfProperties; i++)
    {
        CPropertyName& PropName = pExp->pRequestedPropertyNames[i];
        hres = AddProperty(pClassDef, awsPropList, PropName);
        if(FAILED(hres))
            return hres;
    }

    // Do the same for all the aggregation properties
    // ==============================================

    for (i = 0; i < pExp->nNumAggregatedProperties; i++)
    {
        CPropertyName& PropName = pExp->pAggregatedPropertyNames[i];
        hres = AddProperty(pClassDef, awsPropList, PropName);
        if(FAILED(hres))
            return hres;
    }

    return pClassDef->GetClassSubset( awsPropList.Size(),
                                      awsPropList.GetArrayPtr(),
                                      &m_pLimitedClass );
}

HRESULT CEventProjectingSink::AddProperty(  IWbemClassObject* pClassDef,
                                            CWStringArray& awsPropList,
                                            CPropertyName& PropName)
{
    LPWSTR wszPrimaryName = PropName.m_aElements[0].Element.m_wszPropertyName;

    // Check for complexity
    // ====================

    if(PropName.GetNumElements() > 1)
    {
        // Complex --- make sure the property is an object
        // ===============================================

        CIMTYPE ct;
        if(FAILED(pClassDef->Get( wszPrimaryName, 0, NULL, &ct, NULL)) ||
            ct != CIM_OBJECT)
        {
            return WBEM_E_PROPERTY_NOT_AN_OBJECT;
        }
    }

    awsPropList.Add(wszPrimaryName);
    return WBEM_S_NO_ERROR;
}

HRESULT CEventProjectingSink::Indicate( long lNumEvents, 
                                        IWbemEvent** apEvents, 
                                        CEventContext* pContext)
{
    HRESULT hres = S_OK;
    CWbemPtr<CAbstractEventSink> pSink;

    // Construct an array into which the matching events will be placed
    // ================================================================

    CTempArray<IWbemEvent*> apProjectedEvents;
    
    if(!INIT_TEMP_ARRAY(apProjectedEvents, lNumEvents))
        return WBEM_E_OUT_OF_MEMORY;
    
    {
        CInCritSec ics(&m_cs);

        if ( m_pOwner == NULL )
        {
            return WBEM_S_FALSE;
        }

        //
        // Retrieve delivery sink while locked
        //

        pSink = m_pOwner;

        for(int i = 0; i < lNumEvents; i++)
        {
            // Project this instance
            // =====================
    
            CWbemPtr<_IWmiObject> pInst;
            hres = apEvents[i]->QueryInterface( IID__IWmiObject, 
                                                (void**)&pInst );
            if ( FAILED(hres) )
            {
                break;
            }

            //
            // we cannot project the instance if it is derived from 
            // the EventDroppedEvent class.  The reason for this is because
            // we can lose class and derivation information during the 
            // projection.  This information is needed later on to determine
            // if we need to raise EventDroppedEvents ( we don't raise 
            // EventDroppedEvents for dropped EventDroppedEvents ).  The 
            // reason why we do this check on the Indicate() and not during  
            // initialization is because the class from the query could be 
            // a base class of EVENT_DROP_CLASS.
            // 

            CWbemPtr<_IWmiObject> pNewInst;

            if ( pInst->InheritsFrom( EVENT_DROP_CLASS ) != WBEM_S_NO_ERROR )
            {  
                hres = m_pLimitedClass->MakeSubsetInst( pInst, &pNewInst );
            }
            else
            {
                hres = S_FALSE;
            }
    
            if( hres != WBEM_S_NO_ERROR )
            {
                // Oh well, just send the original
                // ===============================
    
                pNewInst = pInst;
                hres = S_OK;
            }

            pNewInst->AddRef();
            apProjectedEvents[i] = pNewInst;
        }            
    }

    if ( SUCCEEDED(hres) )
    {
        // Deliver the new array either into the aggregator or the forwarder
        // =================================================================
    
        hres = pSink->Indicate(lNumEvents, apProjectedEvents, pContext);
    }
    
    // Release them
    // ============

    for(int i = 0; i < lNumEvents; i++)
        apProjectedEvents[i]->Release();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\evtools.cpp ===
//******************************************************************************
//
//  EVTOOLS.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <evtools.h>
#include <cominit.h>

//*****************************************************************************
//
//  Implementation:
//
//  This class contains a queue of event handles.  The top() one is always 
//  signalled --- it corresponds to the turn that is currently allowed to
//  execute.  Handles are added to the queue in GetInLine.  Handles are removed
//  from the queue in EndTurn, at which time the next handle in line is
//  signalled.  
//
//  m_pCurrentTurn contains the pointer to the turn that has returned from from
//  WaitForTurn, but not from EndTurn.  Note, that m_pCurrentTurn may be empty
//  even if a turn is scheduled to execute --- there is a gap between the time
//  when a turn's handle is signalled, and its WaitForTurn succeeds. 
//
//  However, it is guranteed that by the time a legitimate call to EndTurn is 
//  made, m_pCurrentTurn contains the pointer to the turn in question, at which
//  time it is reset to NULL.
//
//  An additional optimization is that if the same thread calls GetInLine
//  multiple times concurrently, we simply 
//
//*****************************************************************************

CExecLine::CExecLine() : m_pCurrentTurn(NULL), m_pLastIssuedTurn(NULL), 
                        m_dwLastIssuedTurnThreadId(0)
{
}

CExecLine::~CExecLine()
{
    // No need to do anything --- handles are closed by tokens
    // =======================================================
}

CExecLine::CTurn* CExecLine::GetInLine()
{
    CInCritSec ics(&m_cs);

    //
    // First, check if this thread was the guy who got the last turn
    // 

    if(m_pLastIssuedTurn && m_dwLastIssuedTurnThreadId == GetCurrentThreadId())
    {
        // 
        // It is us --- just reuse that turn and be done with it
        //

        m_pLastIssuedTurn->AddRef();
        return m_pLastIssuedTurn; 
    }
    
    //
    // Allocate a new turn
    // 

    CTurn* pTurn = new CTurn;
    if(pTurn == NULL)
        return NULL;

    if(!pTurn->Init())
    {
        ERRORTRACE((LOG_ESS, "Unable to initialize turn: %d\n", 
                GetLastError()));
        delete pTurn;
        return NULL;
    }

    //
    // Add its event to the queue
    // 
    
    try
    {
        m_qTurns.push_back(pTurn);
    }
    catch( CX_MemoryException )
    {
        return NULL;
    }

    //
    // Check if we are currently executing
    //

    if(m_qTurns.size() == 1)
    {
        //
        // Release first in line
        //

        if(!ReleaseFirst())
        {
            //
            // Something went horribly wrong
            // 

            ERRORTRACE((LOG_ESS, "Unable to release first turn: %d\n", 
                GetLastError()));

            m_qTurns.pop_front();
            delete pTurn;
            return NULL;
        }
    }

    //
    // Mark ourselves as the last issued turn
    //

    m_pLastIssuedTurn = pTurn;
    m_dwLastIssuedTurnThreadId = GetCurrentThreadId();
    return pTurn;
}

// assumes in m_cs and m_qTurns is not empty
BOOL CExecLine::ReleaseFirst()
{
    return SetEvent(m_qTurns.front()->GetEvent());
}


DWORD CExecLine::WaitForTurn(CTurn* pTurn, DWORD dwTimeout)
{
    // Wait for the turn event to be signaled
    // ======================================

    DWORD dwRes = WbemWaitForSingleObject(pTurn->GetEvent(), dwTimeout);

    {
        CInCritSec ics(&m_cs);

        if(dwRes == WAIT_OBJECT_0)
        {
            // Got it --- record this turn as executing
            // ========================================
            
            m_pCurrentTurn = pTurn;
        }
    }
        
    return dwRes;
}

BOOL CExecLine::EndTurn(CTurn* pTurn)
{
    CInCritSec ics(&m_cs);

    // Check that this is the running turn
    // ===================================

    if(pTurn != m_pCurrentTurn)
        return FALSE;

    m_pCurrentTurn = NULL;

    // Delete the turn object
    // ======================

    if(pTurn->Release() > 0)
    {
        //
        // This is not the last incarnation of this turn.  No further action is
        // required, as the same thread will call Wait and End again
        //

        return TRUE;
    }

    //
    // Remove the last issued turn if this is it
    //

    if(m_pLastIssuedTurn == pTurn)
    {
        m_pLastIssuedTurn = NULL;
        m_dwLastIssuedTurnThreadId = 0;
    }

    //
    // Pop its handle off the queue
    // 

    m_qTurns.pop_front();
    
    //
    // Signal the next one
    //

    if(!m_qTurns.empty())
        return ReleaseFirst();
    else
        return TRUE;
}

BOOL CExecLine::DiscardTurn(ACQUIRE CTurn* pTurn)
{
    CInCritSec ics(&m_cs);

    if(pTurn->Release() > 0)
    {
        // 
        // This is not the last incarnation of this turn. No further action is
        // required
        //

        return TRUE;
    }
    else
    {
        // if pTurn is going away, we'd better make sure that we don't try to reuse it...
        // HMH 4/12/99, RAID 48420
        if (pTurn == m_pLastIssuedTurn)
            m_pLastIssuedTurn = NULL;
    }
    

    //
    // Search for it in the queue
    // 

    BOOL bFound = FALSE;
    for(TTurnIterator it = m_qTurns.begin(); it != m_qTurns.end();)
    {
        if((*it) == pTurn)
        {
            //
            // erase it and continue
            //

            it = m_qTurns.erase(it);
            bFound = TRUE;
            break;
        }
        else
            it++;
    }

    if(!bFound)
        return FALSE;

    if(it == m_qTurns.begin() && it != m_qTurns.end())
    {
        //
        // Discarded turn was actually active --- signal the next one
        //

        ReleaseFirst();
    }

    return TRUE;
}

CExecLine::CTurn::CTurn() : m_hEvent(NULL), m_lRef(1)
{
}

BOOL CExecLine::CTurn::Init()
{
    m_dwOwningThreadId = GetCurrentThreadId();
    m_hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    return (m_hEvent != NULL);
}
    
long CExecLine::CTurn::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

long CExecLine::CTurn::Release()
{
    long l = InterlockedDecrement(&m_lRef);
    if(l == 0)
        delete this;
    return l;
}

CExecLine::CTurn::~CTurn()
{
    if(m_hEvent)
        CloseHandle(m_hEvent);
}

void* CExecLine::CTurn::operator new(size_t nSize)
{
    return CTemporaryHeap::Alloc(nSize);
}
void CExecLine::CTurn::operator delete(void* p)
{
    CTemporaryHeap::Free(p, sizeof(CExecLine::CTurn));
}




INTERNAL const SECURITY_DESCRIPTOR* GetSD( IWbemEvent* pEvent,ULONG* pcEvent )
{
    static long mstatic_lSdHandle = -1;
    HRESULT hres;

    //
    // Get the SD from the event
    //

    _IWmiObject* pEventEx = NULL;
    pEvent->QueryInterface(IID__IWmiObject, (void**)&pEventEx);
    CReleaseMe rm1(pEventEx);

    if(mstatic_lSdHandle == -1)
    {
        pEventEx->GetPropertyHandleEx(SECURITY_DESCRIPTOR_PROPNAME, 0, NULL,
                                &mstatic_lSdHandle);
    }

    const SECURITY_DESCRIPTOR* pSD = NULL;

    hres = pEventEx->GetArrayPropAddrByHandle(mstatic_lSdHandle, 0, pcEvent,
            (void**)&pSD);
    if(FAILED(hres) || pSD == NULL)
        return NULL;
    else
        return pSD;
}
    
HRESULT SetSD(IWbemEvent* pEvent, const SECURITY_DESCRIPTOR* pSD)
{
    HRESULT hres;

    VARIANT vSd;
    VariantInit(&vSd);
    CClearMe cm1(&vSd);

    long lLength = GetSecurityDescriptorLength((SECURITY_DESCRIPTOR*)pSD);

    V_VT(&vSd) = VT_ARRAY | VT_UI1;
    SAFEARRAYBOUND sab;
    sab.cElements = lLength;
    sab.lLbound = 0;
    V_ARRAY(&vSd) = SafeArrayCreate(VT_UI1, 1, &sab);
    if(V_ARRAY(&vSd) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    BYTE* abSd = NULL;
    hres = SafeArrayAccessData(V_ARRAY(&vSd), (void**)&abSd);
    if(FAILED(hres))
        return WBEM_E_OUT_OF_MEMORY;

    CUnaccessMe uam(V_ARRAY(&vSd));
    memcpy(abSd, pSD, lLength);

    // Put it into the consumer
    // ========================

    hres = pEvent->Put(SECURITY_DESCRIPTOR_PROPNAME, 0, &vSd, 0);
    return hres;
}



CTempMemoryManager CTemporaryHeap::mstatic_Manager;

/*
CTemporaryHeap::CHeapHandle CTemporaryHeap::mstatic_HeapHandle;

CTemporaryHeap::CHeapHandle::CHeapHandle()
{
    m_hHeap = HeapCreate(0, 0, 0);
}

CTemporaryHeap::CHeapHandle::~CHeapHandle()
{
    HeapDestroy(m_hHeap);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\moniprov.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __WBEM_MONITOR_PROVIDER__H_
#define __WBEM_MONITOR_PROVIDER__H_

#include "monitor.h"
#include <map>

class CMonitorProvider : 
        public CUnkBase<IWbemEventProvider, &IID_IWbemEventProvider>
{
protected:
    STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);

protected:
    CEssNamespace* m_pNamespace;
    IWbemEventSink* m_pSink;
    CCritSec m_cs;

    typedef std::map<WString, CMonitor*, WSiless> TMap;
    typedef TMap::iterator TIterator;
    TMap m_mapMonitors;

    _IWmiObject* m_pAssertClass;
    _IWmiObject* m_pRetractClass;
    _IWmiObject* m_pGoingUpClass;
    _IWmiObject* m_pGoingDownClass;
    _IWmiObject* m_pErrorClass;

    long m_lNameHandle;
    long m_lObjectHandle;
    long m_lCountHandle;
    long m_lNewHandle;

public:
    CMonitorProvider(CLifeControl* pControl = NULL);
    ~CMonitorProvider();
    HRESULT SetNamespace(CEssNamespace* pNamespace);

    HRESULT Shutdown();

    HRESULT AddMonitor(LPCWSTR wszName, LPCWSTR wszQuery, long lFlags,
                            IWbemContext* pContext);
    HRESULT RemoveMonitor(LPCWSTR wszName, IWbemContext* pContext);

    static HRESULT GetMonitorInfo(IWbemClassObject* pMonitorObj,
                                BSTR* pstrKey, BSTR* pstrQuery, long* plFlags);
protected:
    friend class CFiringMonitorCallback;

    INTERNAL IWbemEventSink* GetSink() {return m_pSink;}
    HRESULT ConstructAssert(LPCWSTR wszName, _IWmiObject* pObj, bool bEvent, 
                            DWORD dwTotalCount, _IWmiObject** ppEvent);
    HRESULT ConstructRetract(LPCWSTR wszName, _IWmiObject* pObj, bool bEvent, 
                            DWORD dwTotalCount, _IWmiObject** ppEvent);
    HRESULT ConstructGoingUp(LPCWSTR wszName, DWORD dwNumMatching, 
                            _IWmiObject** ppEvent);
    HRESULT ConstructGoingDown(LPCWSTR wszName, DWORD dwNumMatching, 
                            _IWmiObject** ppEvent);
    HRESULT ConstructError(LPCWSTR wszName, HRESULT hresError, 
                            IWbemClassObject* pErrorObj, _IWmiObject** ppEvent);

private:
    HRESULT GetInstance(_IWmiObject* pClass, LPCWSTR wszName, DWORD dwCount,
                                        _IWmiObject** ppEvent);
    HRESULT SetObject(_IWmiObject* pEvent, _IWmiObject* pObj, bool bFromEvent);
};

class CFiringMonitorCallback : public CMonitorCallback
{
protected:
    long m_lRef;
    CMonitorProvider* m_pProvider;
    WString m_wsName;
    IWbemEventSink* m_pSink;

public:
    CFiringMonitorCallback(CMonitorProvider* pProvider, LPCWSTR wszName);
    ~CFiringMonitorCallback();

    HRESULT Initialize();

    LPCWSTR GetName() {return m_wsName;}

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT Assert(_IWmiObject* pObj, LPCWSTR wszPath, bool bEvent, 
                            DWORD dwTotalCount);
    virtual HRESULT Retract(_IWmiObject* pObj, LPCWSTR wszPath, bool bEvent, 
                            DWORD dwTotalCount);
    virtual HRESULT GoingUp(DWORD dwNumMatching);
    virtual HRESULT GoingDown(DWORD dwNumMatching);
    virtual HRESULT Error(HRESULT hresError, IWbemClassObject* pErrorObj);
protected:
    bool CheckSink();
    HRESULT FireEvent(_IWmiObject* pEvent);
};


    

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\ncevents.cpp ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events within ESS.
//
#include "precomp.h"
#include "NCEvents.h"

#define NUM_NC_EVENTS       NCE_InvalidIndex
#define MAX_BUFFER_SIZE     32000
#define SEND_LATENCY        100

static HANDLE g_hConnection;
HANDLE g_hNCEvents[NUM_NC_EVENTS];

LPCWSTR szEventSetup[NUM_NC_EVENTS * 2] =
{
    L"MSFT_WmiRegisterNotificationSink",
    L"Namespace!s! QueryLanguage!s! Query!s! Sink!I64u!",

    L"MSFT_WmiCancelNotificationSink",
    L"Namespace!s! QueryLanguage!s! Query!s! Sink!I64u!",

    L"MSFT_WmiEventProviderLoaded",
    L"Namespace!s! ProviderName!s!",

    L"MSFT_WmiEventProviderUnloaded",
    L"Namespace!s! ProviderName!s!",

    L"MSFT_WmiEventProviderNewQuery",
    L"Namespace!s! ProviderName!s! QueryLanguage!s! "
        L"Query!s! QueryId!u! Result!u!",

    L"MSFT_WmiEventProviderCancelQuery",
    L"Namespace!s! ProviderName!s! QueryId!u! Result!u!",

    L"MSFT_WmiEventProviderAccessCheck",
    L"Namespace!s! ProviderName!s! QueryLanguage!s! "
        L"Query!s! Sid!c[]! Result!u!",

    L"MSFT_WmiConsumerProviderLoaded",
    L"Namespace!s! ProviderName!s! Machine!s!",

    L"MSFT_WmiConsumerProviderUnloaded",
    L"Namespace!s! ProviderName!s! Machine!s!",

    L"MSFT_WmiConsumerProviderSinkLoaded",
    L"Namespace!s! ProviderName!s! Machine!s! Consumer!s!",

    L"MSFT_WmiConsumerProviderSinkUnloaded",
    L"Namespace!s! ProviderName!s! Machine!s! Consumer!s!",

    L"MSFT_WmiThreadPoolThreadCreated",
    L"ThreadId!u!",

    L"MSFT_WmiThreadPoolThreadDeleted",
    L"ThreadId!u!",

    L"MSFT_WmiFilterActivated",
    L"Namespace!s! Name!s! QueryLanguage!s! Query!s!",

    L"MSFT_WmiFilterDeactivated",
    L"Namespace!s! Name!s! QueryLanguage!s! Query!s!",
};

#define WMI_SELF_PROV_NAME   L"WMI Self-Instrumentation Event Provider"

BOOL InitNCEvents()
{
#ifdef USE_NCEVENTS
    BOOL bRet;

    g_hConnection =
        WmiEventSourceConnect(
            L"root\\cimv2",
            WMI_SELF_PROV_NAME,
            TRUE,
            MAX_BUFFER_SIZE,
            SEND_LATENCY,
            NULL,
            NULL);

    if (g_hConnection)
    {
        for (int i = 0; i < NUM_NC_EVENTS; i++)
        {
            g_hNCEvents[i] = 
                WmiCreateObjectWithFormat(
                    g_hConnection,
                    szEventSetup[i * 2],
                    WMI_CREATEOBJ_LOCKABLE,
                    szEventSetup[i * 2 + 1]);

            if (!g_hNCEvents[i])
                break;
        }

        bRet = i == NUM_NC_EVENTS;
    }
    else
        bRet = FALSE;

    return bRet;
#else
    return TRUE;
#endif
}

void DeinitNCEvents()
{
#ifdef USE_NCEVENTS
    for (int i = 0; i < NUM_NC_EVENTS; i++)
    {
        if (g_hNCEvents[i])
            WmiDestroyObject(g_hNCEvents[i]);
    }

    if (g_hConnection)
        WmiEventSourceDisconnect(g_hConnection);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\newobj.cpp ===
//******************************************************************************
//
//  NEWOBJ.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "newobj.h"

_IWmiObject* CInstanceManager::Clone(_IWmiObject* pOld)
{
    CInCritSec ics(&m_cs);

    _IWmiObject* p = (_IWmiObject*)m_Available.Unqueue();
    if(p)
    {
        p->AddRef();
        pOld->CloneEx(0, p);
        return p;
    }
    else
    {   
        IWbemClassObject* pNew;
        HRESULT hres = pOld->Clone(&pNew);
        if(FAILED(hres))
            return NULL;
        
        _IWmiObject* pNewEx;
        pNew->QueryInterface(IID__IWmiObject, (void**)&pNewEx);
        pNew->Release();
        //pNewEx->SetDelete((void*)&CInstanceManager::Delete, this);
        return pNewEx;
    }
}

// static
void CInstanceManager::Delete(void* pArg, _IWmiObject* p)
{
    CInstanceManager* pThis = (CInstanceManager*)pArg;
    CInCritSec ics(&pThis->m_cs);

    pThis->m_Available.Enqueue(p);
}
    
void CInstanceManager::Clear()
{
    CInCritSec ics(&m_cs);
    _IWmiObject* p = NULL;
    while(p = (_IWmiObject*)m_Available.Unqueue())
    {
        p->AddRef();
        //p->SetDelete(NULL, NULL);
        p->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\moniprov.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "moniprov.h"

CMonitorProvider::CMonitorProvider(CLifeControl* pControl) : TUnkBase(pControl),
    m_pNamespace(NULL), m_pSink(NULL), m_pAssertClass(NULL), m_pRetractClass(NULL), m_pGoingUpClass(NULL), m_pGoingDownClass(NULL), m_pErrorClass( NULL )
{
}

CMonitorProvider::~CMonitorProvider()
{
    Shutdown();
    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pSink)
        m_pSink->Release();

    if( m_pAssertClass )
    {
        m_pAssertClass->Release();
    }

    if ( m_pRetractClass )
    {
        m_pRetractClass->Release();
    }

    if ( m_pGoingUpClass )
    {
        m_pGoingUpClass->Release();
    }

    if ( m_pGoingDownClass )
    {
        m_pGoingDownClass->Release();
    }

    if ( m_pErrorClass )
    {
        m_pErrorClass->Release();
    }
}

HRESULT CMonitorProvider::Shutdown()
{
    CInCritSec ics(&m_cs);

    for(TIterator it = m_mapMonitors.begin(); it != m_mapMonitors.end(); it++)
    {
        delete it->second;
    }
    m_mapMonitors.clear();
    return WBEM_S_NO_ERROR;
}

HRESULT CMonitorProvider::SetNamespace(CEssNamespace* pNamespace)
{
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
    
    //
    // Retrieve system classes from the namespace
    //

    if(FAILED(m_pNamespace->GetClass(ASSERT_EVENT_CLASS, &m_pAssertClass)))
		return WBEM_E_CRITICAL_ERROR;
    if(FAILED(m_pNamespace->GetClass(RETRACT_EVENT_CLASS, &m_pRetractClass)))
		return WBEM_E_CRITICAL_ERROR;
    if(FAILED(m_pNamespace->GetClass(GOINGUP_EVENT_CLASS, &m_pGoingUpClass)))
		return WBEM_E_CRITICAL_ERROR;
    if(FAILED(m_pNamespace->GetClass(GOINGDOWN_EVENT_CLASS, &m_pGoingDownClass)))
		return WBEM_E_CRITICAL_ERROR;
    if(FAILED(m_pNamespace->GetClass(MONITORERROR_EVENT_CLASS, &m_pErrorClass)))
		return WBEM_E_CRITICAL_ERROR;

    //
    // Retrieve handle values
    //

    m_pAssertClass->GetPropertyHandleEx(MONITORNAME_EVENT_PROPNAME,
                            0, NULL, &m_lNameHandle);
    m_pAssertClass->GetPropertyHandleEx(MONITOROBJECT_EVENT_PROPNAME,
                            0, NULL, &m_lObjectHandle);
    m_pAssertClass->GetPropertyHandleEx(MONITORCOUNT_EVENT_PROPNAME,
                            0, NULL, &m_lCountHandle);
    m_pAssertClass->GetPropertyHandleEx(MONITORNEW_EVENT_PROPNAME,
                            0, NULL, &m_lNewHandle);

	return S_OK;
}

STDMETHODIMP CMonitorProvider::ProvideEvents(IWbemObjectSink* pSink, 
                                                long lFlags)
{
    return pSink->QueryInterface(IID_IWbemEventSink, (void**)&m_pSink);
}

HRESULT CMonitorProvider::AddMonitor(LPCWSTR wszName, LPCWSTR wszQuery, 
                            long lFlags, IWbemContext* pContext)
{
    HRESULT hres;

    CMonitor* pMonitor = new CMonitor;
    if(pMonitor == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CFiringMonitorCallback* pCallback = 
        new CFiringMonitorCallback(this, wszName);
    if(pCallback == NULL || pCallback->GetName() == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pCallback->AddRef();
	CTemplateReleaseMe<CFiringMonitorCallback> rm1(pCallback);

	hres = pCallback->Initialize();
	if(FAILED(hres))
	{
		delete pMonitor;
		return hres;
	}
    
    hres = pMonitor->Construct(m_pNamespace, pCallback, wszQuery);
    if(FAILED(hres))
    {
        delete pMonitor;
        return hres;
    }

    //
    // Attempt to start the monitor. TBD: consider monitor's guard
    //

    hres = pMonitor->Start(pContext);
    if(FAILED(hres))
    {
        //
        // Could not start monitor --- depending on whether strong validation
        // is required, remove the monitor or keep it inactive
        //
        
        if(lFlags & WBEM_FLAG_STRONG_VALIDATION)
        {
            delete pMonitor;
            return hres;
        }
    }

    //
    // Add the monitor to the list, active or not
    //

    {
        CInCritSec ics(&m_cs);
        m_mapMonitors[wszName] = pMonitor;
    }

    return hres;
}

HRESULT CMonitorProvider::RemoveMonitor(LPCWSTR wszName, IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);
    
    TIterator it = m_mapMonitors.find(wszName);
    if(it == m_mapMonitors.end())
        return WBEM_S_FALSE;

    it->second->Stop(pContext);
    delete it->second;
    m_mapMonitors.erase(it);

    return WBEM_S_NO_ERROR;
}

// static
HRESULT CMonitorProvider::GetMonitorInfo(IWbemClassObject* pMonitorObj,
                                BSTR* pstrKey, BSTR* pstrQuery, long* plFlags)
{
    HRESULT hres;

    if(pstrKey)
    {
        // 
        // Extract the relpath to use as the key
        //
        
        VARIANT v;
        hres = pMonitorObj->Get(MONITOR_NAME_PROPNAME, 0, &v, NULL, NULL);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Monitor without a path? Not valid\n"));
            return hres;
        }

        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_CRITICAL_ERROR;

        *pstrKey = V_BSTR(&v);
    }

    if(pstrQuery)
    {
        //
        // Check query type
        //

        VARIANT vType;
        VariantInit(&vType);
        CClearMe cm1(&vType);

        hres = pMonitorObj->Get(MONITOR_QUERYLANG_PROPNAME, 0, &vType, NULL, 
                                    NULL);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Monitor without a query type? Not valid\n"));
            return hres;
        }

        if(V_VT(&vType) != VT_BSTR)
        {
            ERRORTRACE((LOG_ESS, "Monitor without a query type? Not valid\n"));
            return WBEM_E_INVALID_OBJECT;
        }

        if(wbem_wcsicmp(V_BSTR(&vType), L"WQL"))
        {
            ERRORTRACE((LOG_ESS, "Monitor with invalid query type %S is "
                        "rejected\n", V_BSTR(&vType)));
            return hres;
        }

        // 
        // Extract the query 
        //
        
        VARIANT v;
        hres = pMonitorObj->Get(MONITOR_QUERY_PROPNAME, 0, &v, NULL, NULL);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Monitor without a name? Not valid\n"));
            return hres;
        }

        if(V_VT(&v) != VT_BSTR)
            return hres;

        *pstrQuery = V_BSTR(&v);
    }

    if(plFlags)
    {
        // 
        // TBD: no flags for now
        //
        
        *plFlags = 0;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CMonitorProvider::ConstructAssert(LPCWSTR wszName, _IWmiObject* pObj, 
                                bool bEvent, 
                                DWORD dwTotalCount, _IWmiObject** ppEvent)
{
    HRESULT hres;
    hres = GetInstance(m_pAssertClass, wszName, dwTotalCount, ppEvent);
    if(FAILED(hres))
        return hres;
    hres = SetObject(*ppEvent, pObj, bEvent);
    if(FAILED(hres))
        (*ppEvent)->Release();
    return hres;
}
    
HRESULT CMonitorProvider::ConstructRetract(LPCWSTR wszName, _IWmiObject* pObj, bool bEvent, 
                                DWORD dwTotalCount, _IWmiObject** ppEvent)
{
    HRESULT hres;
    hres = GetInstance(m_pRetractClass, wszName, dwTotalCount, ppEvent);
    if(FAILED(hres))
        return hres;
    hres = SetObject(*ppEvent, pObj, bEvent);
    if(FAILED(hres))
        (*ppEvent)->Release();
    return hres;
}

HRESULT CMonitorProvider::ConstructGoingUp(LPCWSTR wszName, DWORD dwNumMatching, 
                                _IWmiObject** ppEvent)
{
    return GetInstance(m_pGoingUpClass, wszName, dwNumMatching, ppEvent);
}

HRESULT CMonitorProvider::ConstructGoingDown(LPCWSTR wszName, DWORD dwNumMatching, 
                                _IWmiObject** ppEvent)
{
    return GetInstance(m_pGoingDownClass, wszName, dwNumMatching, ppEvent);
}

HRESULT CMonitorProvider::ConstructError(LPCWSTR wszName, HRESULT hresError, 
                                IWbemClassObject* pErrorObj, 
                                _IWmiObject** ppEvent)
{
    return GetInstance(m_pErrorClass, wszName, 0, ppEvent);
}

HRESULT CMonitorProvider::GetInstance(_IWmiObject* pClass, LPCWSTR wszName, DWORD dwCount,
                                        _IWmiObject** ppEvent)
{
    if(pClass == NULL)
        return WBEM_E_CRITICAL_ERROR;

    HRESULT hres;
    IWbemClassObject* pEvent = NULL;
    hres = pClass->SpawnInstance(0, &pEvent);
    if(FAILED(hres))
        return hres;
    pEvent->QueryInterface(IID__IWmiObject, (void**)ppEvent);
    pEvent->Release();

    hres = (*ppEvent)->SetPropByHandle(m_lCountHandle, 0, sizeof(DWORD), 
                                        &dwCount);
    if(FAILED(hres))
    {
        (*ppEvent)->Release();
        return hres;
    }

    hres = (*ppEvent)->SetPropByHandle(m_lNameHandle, 0, 
                                        wcslen(wszName)*2+2, (LPVOID)wszName);
    if(FAILED(hres))
    {
        (*ppEvent)->Release();
        return hres;
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CMonitorProvider::SetObject(_IWmiObject* pEvent, _IWmiObject* pObj,
                                        bool bFromEvent)
{
    HRESULT hres;

    hres = pEvent->SetPropByHandle(m_lObjectHandle, 0, sizeof(_IWmiObject*), 
                                        &pObj);
    if(FAILED(hres))
        return hres;

    short bNew = (bFromEvent?-1:0);
    hres = pEvent->SetPropByHandle(m_lNewHandle, 0, sizeof(short), &bNew);
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}
    
    


CFiringMonitorCallback::CFiringMonitorCallback(CMonitorProvider* pProvider,
                                                LPCWSTR wszName)
    : m_pProvider(pProvider), m_wsName(wszName), m_pSink(NULL), m_lRef(0)
{
    if(m_pProvider)
        m_pProvider->AddRef();
}

CFiringMonitorCallback::~CFiringMonitorCallback()
{
    if(m_pProvider)
        m_pProvider->Release();
    if(m_pSink)
        m_pSink->Release();
}

ULONG STDMETHODCALLTYPE CFiringMonitorCallback::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFiringMonitorCallback::Release()
{
    long lRef = InterlockedIncrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT CFiringMonitorCallback::Initialize()
{
    //
    // Get us a restricted sink for our key.  TBD
    //

    m_pSink = m_pProvider->GetSink();
    m_pSink->AddRef();
    return S_OK;
}

bool CFiringMonitorCallback::CheckSink()
{
    return (m_pSink && (m_pSink->IsActive() == WBEM_S_NO_ERROR));
}

HRESULT CFiringMonitorCallback::FireEvent(_IWmiObject* pEvent)
{
    return m_pSink->Indicate(1, (IWbemClassObject**)&pEvent);
}

HRESULT CFiringMonitorCallback::Assert(_IWmiObject* pObj, LPCWSTR wszPath,
                        bool bEvent, DWORD dwTotalCount)
{
    if(!CheckSink())
        return WBEM_S_FALSE;

    HRESULT hres;
    _IWmiObject* pEvent = NULL;
    hres = m_pProvider->ConstructAssert(m_wsName, pObj, bEvent, dwTotalCount, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm(pEvent);
    
    return FireEvent(pEvent);
}
    
HRESULT CFiringMonitorCallback::Retract(_IWmiObject* pObj, LPCWSTR wszPath,
                            bool bEvent, DWORD dwTotalCount)
{
    if(!CheckSink())
        return WBEM_S_FALSE;

    HRESULT hres;
    _IWmiObject* pEvent = NULL;
    hres = m_pProvider->ConstructRetract(m_wsName, pObj, bEvent, dwTotalCount, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm(pEvent);
    
    return FireEvent(pEvent);
}

HRESULT CFiringMonitorCallback::GoingUp(DWORD dwNumMatching)
{
    if(!CheckSink())
        return WBEM_S_FALSE;

    HRESULT hres;
    _IWmiObject* pEvent = NULL;
    hres = m_pProvider->ConstructGoingUp(m_wsName, dwNumMatching, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm(pEvent);
    
    return FireEvent(pEvent);
}

HRESULT CFiringMonitorCallback::GoingDown(DWORD dwNumMatching)
{
    if(!CheckSink())
        return WBEM_S_FALSE;

    HRESULT hres;
    _IWmiObject* pEvent = NULL;
    hres = m_pProvider->ConstructGoingDown(m_wsName, dwNumMatching, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm(pEvent);
    
    return FireEvent(pEvent);
}

HRESULT CFiringMonitorCallback::Error(HRESULT hresError, 
                                        IWbemClassObject* pErrorObj)
{
    if(!CheckSink())
        return WBEM_S_FALSE;

    HRESULT hres;
    _IWmiObject* pEvent = NULL;
    hres = m_pProvider->ConstructError(m_wsName, hresError, pErrorObj, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm(pEvent);
    
    return FireEvent(pEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\monitor.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <ql.h>
#include <nsrep.h>
#include <monitor.h>

CMonitor::CMonitor() 
    : CGuardable(false), 
    m_CreationSink(this), m_DeletionSink(this), m_DataSink(this),
    m_ModificationInSink(this), m_ModificationOutSink(this),
    m_lRef(0), m_pNamespace(NULL), m_wszDataQuery(NULL), m_pCallback(NULL),
    m_wszCreationEvent(NULL), m_wszDeletionEvent(NULL),
    m_wszModificationInEvent(NULL), m_wszModificationOutEvent(NULL),
    m_bFirstPollDone(FALSE)
{
}

CMonitor::~CMonitor()
{
    if(m_lRef != 0)
    {
        ERRORTRACE((LOG_ESS, "Destroying monitor '%S' with non-0 ref-count: %d",
                        m_wszDataQuery, m_lRef));
    }
    if(m_pNamespace)
        m_pNamespace->Release();
    if(m_pCallback)
        m_pCallback->Release();

    delete [] m_wszDataQuery;
    delete [] m_wszCreationEvent;
    delete [] m_wszDeletionEvent;
    delete [] m_wszModificationInEvent;
    delete [] m_wszModificationOutEvent;
}

ULONG CMonitor::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CMonitor::Release()
{
    // CMonitor is not controlled by its ref-count --- it is explicitely 
    // deleted by its parent.
    return InterlockedDecrement(&m_lRef);
}


HRESULT CMonitor::Construct(CEssNamespace* pNamespace,
                        CMonitorCallback* pCallback, LPCWSTR wszQuery)
{
    HRESULT hres;

    //
    // Parse the query
    //

    CTextLexSource src(wszQuery);
    QL1_Parser parser(&src);

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    int nRes = parser.Parse(&pExp);
    if (nRes)
    {
        ERRORTRACE((LOG_ESS, "Unable to parse data monitor query '%S'\n", 
            wszQuery));
        return WBEM_E_UNPARSABLE_QUERY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExp);

    m_bWithin = !pExp->Tolerance.m_bExact;
    if(m_bWithin)
    {
        m_dwMsInterval = (DWORD)(pExp->Tolerance.m_fTolerance * 1000);
    }

    //
    // Construct the tree for the membership test
    //

    CContextMetaData Meta(new CEssMetaData(pNamespace), GetCurrentEssContext());

    hres = m_MembershipTest.CreateFromQuery(&Meta, pExp, 0, 0x7FFFFFFF);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to construct a tree from the data "
            "monitor query '%S': 0x%X\n", wszQuery, hres));
        return WBEM_E_UNPARSABLE_QUERY;
    }

    //
    // Construct event queries we could issue to implement the monitor without
    // polling
    //

    hres = ConstructWatchQueries(pExp, &m_wszCreationEvent,
                &m_wszDeletionEvent, &m_wszModificationInEvent,
                &m_wszModificationOutEvent);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to construct a watch query from "
                "'%S': 0x%x\n", wszQuery, hres));
        return hres;
    }


    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    m_pCallback = pCallback;
    if(m_pCallback)
        m_pCallback->AddRef();

    //
    // Remove the tolerance clause from the data query, in case we need to poll
    //

    m_wszDataQuery = pExp->GetText();

    return WBEM_S_NO_ERROR;
}
    
HRESULT CMonitor::ConstructWatchQueries(QL_LEVEL_1_RPN_EXPRESSION* pDataQ,
                                LPWSTR* pwszCreationEvent,
                                LPWSTR* pwszDeletionEvent,
                                LPWSTR* pwszModificationInEvent,
                                LPWSTR* pwszModificationOutEvent)
{
    //
    // BUGBUG: could do real analysis to make things faster
    //

    LPCWSTR wszTargetClassName = pDataQ->bsClassName;

    *pwszCreationEvent = NULL;
    *pwszDeletionEvent = NULL;
    *pwszModificationInEvent = NULL;
    *pwszModificationOutEvent = NULL;

    *pwszCreationEvent = new WCHAR[wcslen(wszTargetClassName) + 200];
    *pwszDeletionEvent = new WCHAR[wcslen(wszTargetClassName) + 200];
    *pwszModificationInEvent = new WCHAR[wcslen(wszTargetClassName) + 200];
    *pwszModificationOutEvent = new WCHAR[wcslen(wszTargetClassName) + 200];

    if(*pwszCreationEvent == NULL || *pwszDeletionEvent == NULL ||
        *pwszModificationInEvent == NULL || *pwszModificationOutEvent == NULL)
    {
        delete *pwszCreationEvent;
        delete *pwszDeletionEvent;
        delete *pwszModificationInEvent;
        delete *pwszModificationOutEvent;
        return WBEM_E_OUT_OF_MEMORY;
    }
        
    swprintf(*pwszCreationEvent, L"select * from __InstanceCreationEvent where "
                L"TargetInstance isa \"%s\"", wszTargetClassName);
    swprintf(*pwszDeletionEvent, L"select * from __InstanceDeletionEvent where "
                L"TargetInstance isa \"%s\"", wszTargetClassName);
    swprintf(*pwszModificationInEvent, 
                L"select * from __InstanceModificationEvent where "
                L"TargetInstance isa \"%s\"", wszTargetClassName);
    swprintf(*pwszModificationOutEvent, 
                L"select * from __InstanceModificationEvent where "
                L"TargetInstance isa \"%s\"", wszTargetClassName);

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::ActivateByGuard()
{
    return WBEM_E_CRITICAL_ERROR;
}

HRESULT CMonitor::DeactivateByGuard()
{
    return WBEM_E_CRITICAL_ERROR;
}

HRESULT CMonitor::Start(IWbemContext* pContext)
{
    HRESULT hres;

    //
    // First, we'll attempt to implement it without polling --- using events
    //

    hres = ImplementUsingEvents(pContext);
    if(FAILED(hres))
    {
        // Serious error that will prevent polling from working as well!
        return hres;
    }
    else if(hres == WBEM_S_NO_ERROR)
    {
        // Success of event implementation

        m_bUsingEvents = true;
        return hres;
    }

    // WBEM_S_FALSE means: cannot activate using events, use polling

    //
    // Whether an error or normal failure occurred, attempt to activate using
    // polling now.
    //

    hres = ImplementUsingPolling(pContext);
    m_bUsingEvents = false;
    return hres;
}

HRESULT CMonitor::Stop(IWbemContext* pContext)
{
    //
    // Stop it the way it was started
    //

    HRESULT hres;

    if(m_bUsingEvents)
        hres = StopUsingEvents(pContext);
    else
        hres = StopUsingPolling(pContext);

    //
    // Notify our clients that we are stopping
    //
    
    DWORD dwCount;
    {
        CInCritSec ics(&m_cs);
        dwCount = m_map.size();
    }

    FireStop(dwCount);

    return hres;
}

HRESULT CMonitor::ImplementUsingEvents(IWbemContext* pContext)
{
    HRESULT hres;

    // BUGBUG: propagate security context

	//
	// Remember that the data query is still outstanding and therefore
	// extra race-condition book-keeping is still necessary
	//

	m_bDataDone = false;

    //
    // Subscribe to all the event queries we have stashed.  It is assumed 
    // that the namespace is locked at this point.
    //

    hres = m_pNamespace->InternalRegisterNotificationSink(L"WQL", 
                            m_wszCreationEvent,
                            0, WMIMSG_FLAG_QOS_EXPRESS, pContext, 
                            &m_CreationSink, true, NULL );
    if(SUCCEEDED(hres))
    {
        hres = m_pNamespace->InternalRegisterNotificationSink(L"WQL", 
                            m_wszDeletionEvent,
                            0, WMIMSG_FLAG_QOS_EXPRESS, pContext, 
                            &m_DeletionSink, true, NULL );
        if(SUCCEEDED(hres))
        {
            hres = m_pNamespace->InternalRegisterNotificationSink(L"WQL", 
                                m_wszModificationInEvent,
                                0, WMIMSG_FLAG_QOS_EXPRESS, pContext, 
                                &m_ModificationInSink, true, NULL );

            if(SUCCEEDED(hres))
            {
                hres = m_pNamespace->InternalRegisterNotificationSink(L"WQL", 
                                    m_wszModificationOutEvent,
                                    0, WMIMSG_FLAG_QOS_EXPRESS, pContext, 
                                    &m_ModificationOutSink, true, NULL );
            }
        }   
    }
        
    if(FAILED(hres))
    {
        UnregisterAll();

        if(hres == WBEMESS_E_REGISTRATION_TOO_PRECISE)
        {
            //
            // There are no event providers to survice all of these requests.
            // That's OK --- it just means that we need to use polling to do
            // this monitor.
            //

            return WBEM_S_FALSE;
        }
        else
        {
            ERRORTRACE((LOG_ESS, "Monitor '%S' encountered error 0x%X trying "
                "to activate its event queries\n", m_wszDataQuery, hres));
            return WBEM_S_FALSE;
        }
    }

    //
    // Now that we are subscribed for events, issue the data query
    //

    hres = m_pNamespace->ExecQuery(m_wszDataQuery, 0, &m_DataSink);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Monitor '%S' encountered error 0x%X issuing its "
            "initializing data query\n", m_wszDataQuery, hres));
        return hres;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::StopUsingEvents(IWbemContext* pContext)
{
    return UnregisterAll();
}

HRESULT CMonitor::UnregisterAll()
{
    //
    // Cancel all queries
    //

    m_pNamespace->RemoveNotificationSink(&m_CreationSink);
    m_pNamespace->RemoveNotificationSink(&m_DeletionSink);
    m_pNamespace->RemoveNotificationSink(&m_ModificationInSink);
    m_pNamespace->RemoveNotificationSink(&m_ModificationOutSink);

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::ImplementUsingPolling(IWbemContext* pContext)
{
    HRESULT hres;

    //
    // As usual, polling is only possible if a WITHIN clause is specified
    //

    if(!m_bWithin)
        return WBEMESS_E_REGISTRATION_TOO_PRECISE;

    //
    // Basically, we will keep issuing our data query every m_dwMsInterval
    // seconds and issue events if needed.  
    //
    // Construct the timer instruction that will do that
    //

    m_pInst = new CMonitorInstruction(m_pNamespace, this);
    if(m_pInst == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    m_pInst->AddRef();
    hres = m_pInst->Initialize(L"WQL", m_wszDataQuery, m_dwMsInterval);

    if (SUCCEEDED(hres))
    {
        hres = 
            m_pNamespace->GetTimerGenerator().Set(
                m_pInst, 
                CWbemTime::GetZero());
    }

    if (FAILED(hres))
    {
        m_pInst->Release();
        return hres;
    }

    return hres;
}

HRESULT CMonitor::StopUsingPolling(IWbemContext* pContext)
{
    //
    // Cancel the timer instruction
    //

    CIdentityTest Test(m_pInst);

    ((CTimerGenerator&)m_pNamespace->GetTimerGenerator()).Remove(&Test);

    m_pInst->Release();
    m_pInst = NULL;

    return S_OK;
}

// This function is called on both creation and mod-in events.  There appear
// to be no differences between the two.
HRESULT CMonitor::ProcessPossibleAdd(_IWmiObject* pObj, bool bEvent)
{
    HRESULT hres;

    //
    // First, we need to run the object through the membership test, if it
    // came from an event --- no need to do that for a poll
    //

    if(bEvent)
    {
        CSortedArray aTrues;
        hres = m_MembershipTest.Evaluate(pObj, aTrues);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to verify set membership for incoming "
                "object in monitor '%S': 0x%X\n", m_wszDataQuery));
            return hres;
        }
    
        if(aTrues.Size() == 0)
        {
            //
            // Not in the set --- this can happen because our event 
            // registrations
            // might be a bit broader that we'd want them to be.  Later on, we 
            // might want to count these false hits and if we get too many of 
            // them, perhaps switch to polling...
            //
    
            return WBEM_S_FALSE;
        }
    }

    //
    // Get its path
    //

    VARIANT v;
    VariantInit(&v);
    hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_CRITICAL_ERROR;
    CClearMe cm(&v);

    //
    // Determine if firing is necessary
    //

    bool bFire;
    DWORD dwObjectCount;

    {
        CInCritSec ics(&m_cs);

        //
        // See if we already have it
        //
    
		TIterator it = m_map.find(V_BSTR(&v));
		if(it == m_map.end() || !it->second)
		{
			// it is either not there, or thre with FALSE as the presence 
			// indicator --- in either case, it's not thought to be in the set

			//
			// There is one test remaining --- if this is a data-add, we must 
			// make sure that we have not heard of this object before, for if
			// we have, we must ignore this info --- events always override.
			//

			if(!bEvent && 
				m_mapHeard.find(V_BSTR(&v)) != m_mapHeard.end())
			{
				bFire = false;
			}
			else
			{
				bFire = true;
				m_map[V_BSTR(&v)] = true;
				dwObjectCount = m_map.size();

				if(!m_bDataDone)
					m_mapHeard[V_BSTR(&v)] = true;
			}
		}
		else
		{
			// It's already there
			bFire = false;
		}
    }
        
    if(bFire)
        FireAssert(pObj, V_BSTR(&v), bEvent, dwObjectCount);

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::ProcessModOut(_IWmiObject* pObj, bool bEvent)
{
	HRESULT hres;

	//
	// First, we need to make sure that the object has really been modified
	// out of the set --- need to test that it's no longer in the set
	//

    CSortedArray aTrues;
    hres = m_MembershipTest.Evaluate(pObj, aTrues);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to verify set membership for outgoing "
            "object in monitor '%S': 0x%X\n", m_wszDataQuery));
        return hres;
    }

    if(aTrues.Size() != 0)
	{
		//
		// The object is still in the set --- false positive!  
		// This can happen because our event registrations
        // might be a bit broader that we'd want them to be.  Later on, we 
        // might want to count these false hits and if we get too many of them,
        // perhaps switch to polling...
        //
		//

		return WBEM_S_FALSE;
	}

	//
	// The object really has moved out of the set.  As long as it is currently
	// listed as 'in', an event should be raised
	//

	return ProcessPossibleRemove(pObj, bEvent);
}


HRESULT CMonitor::ProcessDelete(_IWmiObject* pObj, bool bEvent)
{
	HRESULT hres;

	//
	// As long as it is currently listed as 'in', an event should be raised
	//

	return ProcessPossibleRemove(pObj, bEvent);
}

HRESULT CMonitor::ProcessPossibleRemove(_IWmiObject* pObj, bool bEvent)
{
    HRESULT hres;

    //
    // Get its path
    //

    VARIANT v;
    VariantInit(&v);
    hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_CRITICAL_ERROR;
    CClearMe cm(&v);

    //
    // Determine if firing is necessary
    //

    BOOL bFire;
    DWORD dwLeft;

    {
        CInCritSec ics(&m_cs);

		// 
		// If we are not out of the data query yet, record the fact that
		// we have seen this instance, since we must ignore any data object
		// that is overriden by an event
		//

		if(!m_bDataDone)
			m_mapHeard[V_BSTR(&v)] = true;

        //
        // See if we have it
        //
    
        TIterator it = m_map.find(V_BSTR(&v));
        if(it == m_map.end())
        {
            // It's not there --- just ignore
            bFire = false;
        }
        else
        {
            //
            // There: remove and fire
            //
            
            m_map.erase(it);

            bFire = true;
            dwLeft = m_map.size();
        }
    }

    if(bFire)
        FireRetract(pObj, V_BSTR(&v), bEvent, dwLeft);
        
    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::ProcessDataDone(HRESULT hresData, IWbemClassObject* pError)
{
    DWORD dwCount;
	{
		CInCritSec ics(&m_cs);
		dwCount = m_map.size();
		m_bDataDone = true;
		m_mapHeard.clear();
	}

    if(FAILED(hresData))
    {
        //
        // Monitor data execution failed. We need to alert our clients to this
        // fact, and schedule reinitialization.
        //
        
        FireError(hresData, pError);
    
        // BUGBUG: Need to reinitialize!
    }
    else
    {
        FireReady(dwCount);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::FireAssert(_IWmiObject* pObj, LPCWSTR wszPath, bool bEvent,
                            DWORD dwTotalItems)
{
    CMonitorCallback* pCallback = GetCallback();
    CTemplateReleaseMe<CMonitorCallback> rm1(pCallback);
    if(pCallback)
        return pCallback->Assert(pObj, wszPath, bEvent, dwTotalItems);
    else
        return WBEM_S_FALSE;
}

HRESULT CMonitor::FireRetract(_IWmiObject* pObj, LPCWSTR wszPath, bool bEvent,
                            DWORD dwTotalItems)
{
    CMonitorCallback* pCallback = GetCallback();
    CTemplateReleaseMe<CMonitorCallback> rm1(pCallback);
    if(pCallback)
        return pCallback->Retract(pObj, wszPath, bEvent, dwTotalItems);
    else
        return WBEM_S_FALSE;
}
    
HRESULT CMonitor::FireReady(DWORD dwTotalItems)
{
    CMonitorCallback* pCallback = GetCallback();
    CTemplateReleaseMe<CMonitorCallback> rm1(pCallback);
    if(pCallback)
        return pCallback->GoingUp(dwTotalItems);
    else
        return WBEM_S_FALSE;
}

HRESULT CMonitor::FireStop(DWORD dwTotalItems)
{
    CMonitorCallback* pCallback = GetCallback();
    CTemplateReleaseMe<CMonitorCallback> rm1(pCallback);
    if(pCallback)
        return pCallback->GoingDown(dwTotalItems);
    else
        return WBEM_S_FALSE;
}

HRESULT CMonitor::FireError(HRESULT hresError, IWbemClassObject* pErrorObj)
{
    CMonitorCallback* pCallback = GetCallback();
    CTemplateReleaseMe<CMonitorCallback> rm1(pCallback);
    if(pCallback)
        return pCallback->Error(hresError, pErrorObj);
    else
        return WBEM_S_FALSE;
}
    
RELEASE_ME CMonitorCallback* CMonitor::GetCallback()
{
    CInCritSec ics(&m_cs);

    if(m_pCallback)
        m_pCallback->AddRef();

    return m_pCallback;
}


HRESULT CMonitor::CCreationSink::Indicate(long lNumEvents, 
                                    IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hres;

    for(long i = 0; i < lNumEvents; i++)
    {
        //
        // Extract its TargetInstance and add it
        //

        VARIANT v;
        hres = apEvents[i]->Get(L"TargetInstance", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_UNKNOWN)
        {
            ERRORTRACE((LOG_ESS, "Invalid instance creation event without "
                "TargetInstance recieved by monitor '%S'\n", 
                m_pOuter->m_wszDataQuery));
            continue;
        }
        CClearMe cm(&v);

        _IWmiObject* pObj;
        hres = V_UNKNOWN(&v)->QueryInterface(IID__IWmiObject, (void**)&pObj);
        CReleaseMe rm(pObj);
    
        hres = m_pOuter->ProcessPossibleAdd(pObj, true);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::CModificationInSink::Indicate(long lNumEvents, 
                                    IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hres;

    for(long i = 0; i < lNumEvents; i++)
    {
        //
        // Extract its TargetInstance and add it
        //

        VARIANT v;
        hres = apEvents[i]->Get(L"TargetInstance", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_UNKNOWN)
        {
            ERRORTRACE((LOG_ESS, "Invalid instance creation event without "
                "TargetInstance recieved by monitor '%S'\n", 
                m_pOuter->m_wszDataQuery));
            continue;
        }
        CClearMe cm(&v);

        _IWmiObject* pObj;
        hres = V_UNKNOWN(&v)->QueryInterface(IID__IWmiObject, (void**)&pObj);
        CReleaseMe rm(pObj);
    
        hres = m_pOuter->ProcessPossibleAdd(pObj, true);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::CDeletionSink::Indicate(long lNumEvents, 
                                    IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hres;
    for(long i = 0; i < lNumEvents; i++)
    {
        //
        // Extract its TargetInstance and remove it
        //

        VARIANT v;
        hres = apEvents[i]->Get(L"TargetInstance", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_UNKNOWN)
        {
            ERRORTRACE((LOG_ESS, "Invalid instance deletion event without "
                "TargetInstance recieved by monitor '%S'\n", 
                 m_pOuter->m_wszDataQuery));
            continue;
        }
        CClearMe cm(&v);

        _IWmiObject* pObj;
        hres = V_UNKNOWN(&v)->QueryInterface(IID__IWmiObject, (void**)&pObj);
        CReleaseMe rm(pObj);
    
        hres = m_pOuter->ProcessDelete(pObj, true);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::CModificationOutSink::Indicate(long lNumEvents, 
                                    IWbemEvent** apEvents,
                                    CEventContext* pContext)
{
    HRESULT hres;
    for(long i = 0; i < lNumEvents; i++) 
    {
        //
        // Extract its TargetInstance and remove it
        //

        VARIANT v;
        hres = apEvents[i]->Get(L"TargetInstance", 0, &v, NULL, NULL);
        if(FAILED(hres) || V_VT(&v) != VT_UNKNOWN)
        {
            ERRORTRACE((LOG_ESS, "Invalid instance deletion event without "
                "TargetInstance recieved by monitor '%S'\n", 
                 m_pOuter->m_wszDataQuery));
            continue;
        }
        CClearMe cm(&v);

        _IWmiObject* pObj;
        hres = V_UNKNOWN(&v)->QueryInterface(IID__IWmiObject, (void**)&pObj);
        CReleaseMe rm(pObj);
    
        hres = m_pOuter->ProcessModOut(pObj, true);
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CMonitor::CDataSink::Indicate(long lNumObjects, 
                                    IWbemClassObject** apObjects)
{
    HRESULT hres;

    for(long i = 0; i < lNumObjects; i++)
    {
        //
        // Just add it
        //

        _IWmiObject* pObj;
        hres = apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pObj);
        CReleaseMe rm(pObj);
    
        hres = m_pOuter->ProcessPossibleAdd(pObj, false);
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CMonitor::CDataSink::SetStatus(long lFlags, HRESULT hresResult,
                                        BSTR, IWbemClassObject* pError)
{
    if(lFlags != WBEM_STATUS_COMPLETE)
        return WBEM_S_NO_ERROR;

    m_pOuter->ProcessDataDone(hresResult, pError);
    return WBEM_S_NO_ERROR;
}
    
HRESULT CMonitor::ProcessPollObject(_IWmiObject* pObj)
{
    HRESULT hres;

    //  
    // An object came back from the query --- mark it in the table as 'present'
    //

    //
    // Get its path
    //

    VARIANT v;
    VariantInit(&v);
    hres = pObj->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_CRITICAL_ERROR;
    CClearMe cm(&v);

    LPCWSTR wszPath = V_BSTR(&v);

    //
    // Determine if firing is necessary
    //

    bool bFire;
    DWORD dwObjectCount;

    {
        CInCritSec ics(&m_cs);

        //
        // See if we already have it
        //
    
		TIterator it = m_map.find(wszPath);
		if(it == m_map.end())
		{
            // This instance was not there before --- fire an assert!

            bFire = true;
            dwObjectCount = m_map.size();
        }
		else
		{
			// It's already there
			bFire = false;
		}

        //
        // Set the presense indicator to true --- otherwise we will delete it
        // when the query is over
        //

        m_map[wszPath] = true;
    }
        
    if(bFire)
        FireAssert(pObj, wszPath, m_bFirstPollDone, dwObjectCount);

    return WBEM_S_NO_ERROR;
}

HRESULT CMonitor::ProcessPollQueryDone(HRESULT hresQuery, 
                                 IWbemClassObject* pError)
{
    //
    // The polling query has finished, so anything in the map marked with 
    // 'false' for the presence indicator has not come in this time and we must
    // fire a retract.  At the same time, we will reset all the presense 
    // indicators for the next time
    //

    CWStringArray awsRetracts;
    DWORD dwCountBefore;

    {
        CInCritSec ics(&m_cs);

        dwCountBefore = m_map.size();

        //
        // note --- for loop not incrementing iterator.  This is because 
        // sometimes we have to remove things from the map
        //

        for(TIterator it = m_map.begin(); it != m_map.end(); )
        {
            if(!it->second)
            {
                // Not there --- write down for retract

                if(awsRetracts.Add(it->first) < 0)
                    return WBEM_E_OUT_OF_MEMORY;
                
                //
                // Remove this guy from the map.  This will advance the 
                // iterator
                //

                it = m_map.erase(it);
            }
            else
            {
                // It is there --- reset the indicator
            
                it->second = true;
                it++;
            }
        }
        
    }

    //
    // Fire all the retracts we have accomulated
    //

    for(int i = 0; i < awsRetracts.Size(); i++)
    {
        FireRetract(NULL, awsRetracts[i], true, dwCountBefore - i);
    }

    //
    // Set the "done with the first query" indicator
    //
    
    m_bFirstPollDone = true;
    return S_OK;
}
        
        
    
                    

/*
    QL_LEVEL_1_RPN_EXPRESSION* pEventQ = new QL_LEVEL_1_RPN_EXPRESSION;
    
    //
    // Add all the properties that the data query was looking for, but with
    // TargetInstance
    //

    for(int i = 0; i < pDataQ->nNumberOfProperties; i++)
    {
        CPropertuName& OldName = pDataQ->pRequestedPropertyNames[i];
        CPropertyName NewName;
        NewName.AddElement(L"TargetInstance")
        for(int j = 0; j < OldName.GetNumElements(); i++)
        {
            NewName.AddElement(OldName.GetStringAt(i))
        }

        pEventQ->AddProperty(NewName);
    }

    //
    // Add "TargetInstance isa "MyClass"" there
    //

    QL_LEVEL_1_TOKEN Token;
    Token.PropertyName.AddElement(L"TargetInstance");
    Token.nTokenType = QL1_OP_EXPRESSION;
    Token.nOperator = QL1_OPERATOR_ISA;
    V_VT(&Token.vConstValue) = VT_BSTR;
    V_BSTR(&Token.vConstValue) = SysAllocString(pDataQ->bsClassName);
    Token.m_bPropComp = FALSE;
    Token.dwPropertyFunction = Token.dwConstFunction = 0;

    pEventQ->AddToken(Token);

    //
    // Convert the original query to DNF
    //

    CDNFExpression DNF;
    QL_LEVEL_1_TOKEN* aTokens = pDataQ->pArrayOfTokens;
    DNF.ConstructFromTokens(aTokens);

    //
    // Reduce it to just the part about the keys
    //
    
    CDNFExpression* pKeyDNF = NULL;
    hres = DNF.GetNecessaryProjection(&Filter, &pKeyDNF);
    if(FAILED(hres))
        return hres;

    //
    // Stick those back into the event query
    //

    if(pKeyDNF->GetNumTerms() > 0)
    {
        hres = pKeyDNF->AddToRPN(pEventQ);
        if(FAILED(hres))
            return hres;
   
        Token.nTokenType = QL1_AND;
        pEventQ->AddToken(Token);
    }
    
    //
    // At this point, our creation and deletion queries are complete.
    // But for our modification query, we need to add all the properties we 
    // are interested in with TargetInstance.X <> PreviousInstance.X
    //

    QL_LEVEL_1_RPN_EXPRESSION* pModEventQ = 
        new QL_LEVEL_1_RPN_EXPRESSION(*pEventQ);

    //
    // Add all the properties that the data query was looking for, but with
    // TargetInstance.X <> PreviousInstance.X
    //

    for(int i = 0; i < pDataQ->nNumberOfProperties; i++)
    {
        CPropertuName& OldName = pDataQ->pRequestedPropertyNames[i];
        Token.PropertyName.Empty();
        Token.PropertyName2.Empty();
        Token.PropertyName.AddElement(L"TargetInstance")
        Token.PropertyName2.AddElement(L"PreviousInstance")
        for(int j = 0; j < OldName.GetNumElements(); i++)
        {
            Token.PropertyName.AddElement(OldName.GetStringAt(i))
            Token.PropertyName2.AddElement(OldName.GetStringAt(i))
        }

        Token.m_bPropComp = TRUE;
        Token.nTokenType = QL1_OP_EXPRESSION;
        Token.nOperator = QL1_OPERATOR_NOTEQUALS;

        pModEventQ->AddToken(Token);
        
        Token.nTokenType = QL1_AND;
        pModEventQ->AddToken(Token);
    }

    //
    // Construct results
    //

    *ppCreationEventQ = new QL_LEVEL_1_RPN_EXPRESSION(*pEventQ);
    pEventQ->SetClassName(L"__InstanceCreationEvent");

    *ppDeletionEventQ = new QL_LEVEL_1_RPN_EXPRESSION(*pEventQ);
    pEventQ->SetClassName(L"__InstanceDeletionEvent");

    *pp
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\monitor.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __WMI_ESS_MONITOR__H_
#define __WMI_ESS_MONITOR__H_

#include <guard.h>
#include <map>
#include <parmdefs.h>

class CMonitorCallback
{
public:
    virtual ULONG STDMETHODCALLTYPE AddRef() = 0;
    virtual ULONG STDMETHODCALLTYPE Release() = 0;
    virtual HRESULT Assert(_IWmiObject* pObj, LPCWSTR wszPath,
                            bool bEvent, DWORD dwTotalCount) = 0;
    virtual HRESULT Retract(_IWmiObject* pObj, LPCWSTR wszPath,
                            bool bEvent, DWORD dwTotalCount) = 0;
    virtual HRESULT GoingUp(DWORD dwNumMatching) = 0;
    virtual HRESULT GoingDown(DWORD dwNumMatching) = 0;
    virtual HRESULT Error(HRESULT hresError, IWbemClassObject* pErrorObj) = 0;
};

class CMonitor : public CGuardable
{
protected:
    long m_lRef;
    CEssNamespace* m_pNamespace;
    CMonitorCallback* m_pCallback;
    LPWSTR m_wszDataQuery;
    bool m_bWithin;
    DWORD m_dwMsInterval;
    CCritSec m_cs;

    LPWSTR m_wszCreationEvent;
    LPWSTR m_wszDeletionEvent;
    LPWSTR m_wszModificationInEvent;
    LPWSTR m_wszModificationOutEvent;

    bool m_bUsingEvents;
    bool m_bRunning;
    CEvalTree m_MembershipTest;

    typedef std::map<WString, bool, WSiless> TMap;
    typedef TMap::iterator TIterator;
    typedef TMap::value_type TValue;
    TMap m_map;
    TMap m_mapHeard;
	bool m_bDataDone;
    bool m_bFirstPollDone;

    class CMonitorInstruction* m_pInst;

    class CCreationSink : public CEmbeddedEventSink<CMonitor>
    {
    public:
        CCreationSink(CMonitor* pMonitor) 
            : CEmbeddedEventSink<CMonitor>(pMonitor)
        {}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    } m_CreationSink;
    friend CCreationSink;

    class CModificationInSink : public CEmbeddedEventSink<CMonitor>
    {
    public:
        CModificationInSink(CMonitor* pMonitor) 
            : CEmbeddedEventSink<CMonitor>(pMonitor)
        {}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    } m_ModificationInSink;
    friend CModificationInSink;

    class CModificationOutSink : public CEmbeddedEventSink<CMonitor>
    {
    public:
        CModificationOutSink(CMonitor* pMonitor) 
            : CEmbeddedEventSink<CMonitor>(pMonitor)
        {}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    } m_ModificationOutSink;
    friend CModificationOutSink;

    class CDeletionSink : public CEmbeddedEventSink<CMonitor>
    {
    public:
        CDeletionSink(CMonitor* pMonitor) 
            : CEmbeddedEventSink<CMonitor>(pMonitor)
        {}
        HRESULT Indicate(long lNumEvents, IWbemEvent** apEvents, 
                            CEventContext* pContext);
    } m_DeletionSink;
    friend CDeletionSink;

    class CDataSink : public CEmbeddedObjectSink<CMonitor>
    {
    public:
        CDataSink(CMonitor* pMonitor) 
            : CEmbeddedObjectSink<CMonitor>(pMonitor)
        {}
        STDMETHOD(Indicate)(long lNumEvents, IWbemClassObject** apEvents);
        STDMETHOD(SetStatus)(long lFlags, HRESULT hresResult,
                                        BSTR, IWbemClassObject* pError);
    } m_DataSink;
    friend CDataSink;

    friend class CMonitorInstruction;
public:
    CMonitor();
    virtual ~CMonitor();
    HRESULT Shutdown();
    ULONG AddRef();
    ULONG Release();

    HRESULT Construct(CEssNamespace* pNamespace, CMonitorCallback* pCallback, 
                        LPCWSTR wszQuery);

    HRESULT Start(IWbemContext* pContext);
    HRESULT Stop(IWbemContext* pContext);

    HRESULT ActivateByGuard();
    HRESULT DeactivateByGuard();

protected:
    HRESULT ConstructWatchQueries(QL_LEVEL_1_RPN_EXPRESSION* pDataQ,
                                LPWSTR* pwszCreationEvent,
                                LPWSTR* pwszDeletionEvent,
                                LPWSTR* pwszModificationInEvent,
                                LPWSTR* pwszModificationOutEvent);
    
    RELEASE_ME CMonitorCallback* GetCallback();
    HRESULT FireError(HRESULT hresError, IWbemClassObject* pErrorObj);
    HRESULT FireStop(DWORD dwTotalItems);
    HRESULT FireReady(DWORD dwTotalItems);
    HRESULT FireRetract(_IWmiObject* pObj, LPCWSTR wszPath, bool bEvent,
                                DWORD dwTotalItems);
    HRESULT FireAssert(_IWmiObject* pObj, LPCWSTR wszPath, bool bEvent,
                                DWORD dwTotalItems);
    HRESULT ProcessDataDone(HRESULT hresData, IWbemClassObject* pError);
    HRESULT ProcessModOut(_IWmiObject* pObj, bool bEvent);
    HRESULT ProcessDelete(_IWmiObject* pObj, bool bEvent);
    HRESULT ProcessPossibleRemove(_IWmiObject* pObj, bool bEvent);
    HRESULT ProcessPossibleAdd(_IWmiObject* pObj, bool bEvent);
    HRESULT StopUsingPolling(IWbemContext* pContext);
    HRESULT ImplementUsingPolling(IWbemContext* pContext);
    HRESULT UnregisterAll();
    HRESULT StopUsingEvents(IWbemContext* pContext);
    HRESULT ImplementUsingEvents(IWbemContext* pContext);

    HRESULT ProcessPollObject(_IWmiObject* pObj);
    HRESULT ProcessPollQueryDone(HRESULT hresQuery, IWbemClassObject* pError);
};

class CMonitorInstruction : public CBasePollingInstruction
{
protected:
    CMonitor* m_pMonitor;

public:
    CMonitorInstruction(CEssNamespace* pNamespace, CMonitor* pMonitor) 
        : CBasePollingInstruction(pNamespace), m_pMonitor(pMonitor)
    {
        m_pMonitor->AddRef();
    }

    virtual ~CMonitorInstruction()
    {
        if(m_pMonitor)
            m_pMonitor->Release();
    }

    virtual HRESULT ProcessObject(_IWmiObject* pObj)
    {
        return m_pMonitor->ProcessPollObject(pObj);
    }

    virtual HRESULT ProcessQueryDone(HRESULT hresQuery, 
                                     IWbemClassObject* pError)
    {
        return m_pMonitor->ProcessPollQueryDone(hresQuery, pError);
    }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\ncevents.h ===
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
// NCEvents.h
//
// This file is the interface to using non-COM events within ESS.
//

#pragma once

#include "NCObjAPI.h"

BOOL InitNCEvents();
void DeinitNCEvents();

// Use this index with g_hNCEvents
enum NCE_INDEX
{
    MSFT_WmiRegisterNotificationSink,
    MSFT_WmiCancelNotificationSink,
    MSFT_WmiEventProviderLoaded,
    MSFT_WmiEventProviderUnloaded,
    MSFT_WmiEventProviderNewQuery,
    MSFT_WmiEventProviderCancelQuery,
    MSFT_WmiEventProviderAccessCheck,
    MSFT_WmiConsumerProviderLoaded,
    MSFT_WmiConsumerProviderUnloaded,
    MSFT_WmiConsumerProviderSinkLoaded,
    MSFT_WmiConsumerProviderSinkUnloaded,
    MSFT_WmiThreadPoolThreadCreated,
    MSFT_WmiThreadPoolThreadDeleted,
    MSFT_WmiFilterActivated,
    MSFT_WmiFilterDeactivated,
    
    NCE_InvalidIndex // This should always be the last one.
};

extern HANDLE g_hNCEvents[];

#ifdef USE_NCEVENTS
#define FIRE_NCEVENT                ::WmiSetAndCommitObject
#define IS_NCEVENT_ACTIVE(index)    ::WmiIsObjectActive(g_hNCEvents[index])
#else
#define FIRE_NCEVENT                1 ? (void)0 : ::WmiSetAndCommitObject
#define IS_NCEVENT_ACTIVE(index)    FALSE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\newobj.h ===
//******************************************************************************
//
//  NEWOBJ.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_NEW_OBJ__H_
#define __WBEM_NEW_OBJ__H_

#include <sync.h>
#include <wbemcomn.h>
#include <wbemidl.h>
#include <wbemint.h>

class CInstanceManager
{
protected:
    CCritSec m_cs;
    CFlexQueue m_Available;
public:
    ~CInstanceManager()
    {
        Clear();
    }
    void Clear();
    _IWmiObject* Clone(_IWmiObject* pOld);
    static void Delete(void* pArg, _IWmiObject* p);
};
    
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\permbind.h ===
//******************************************************************************
//
//  PERMBIND.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_PERM_BINDING__H_
#define __WMI_ESS_PERM_BINDING__H_

#include "binding.h"
#include "fastall.h"

class CPermanentBinding : public CBinding
{
protected:
    static long mstatic_lConsumerHandle;
    static long mstatic_lFilterHandle;
    static long mstatic_lSynchronicityHandle;
    static long mstatic_lQosHandle;
    static long mstatic_lSlowDownHandle;
    static long mstatic_lSecureHandle;
    static long mstatic_lSidHandle;
    static bool mstatic_bHandlesInitialized;
protected:
    static HRESULT InitializeHandles( _IWmiObject* pBindingObj);
public:
    CPermanentBinding()
    {}
    HRESULT Initialize(IWbemClassObject* pBindingObj);
    static HRESULT ComputeKeysFromObject(IWbemClassObject* pBindingObj,
                                BSTR* pstrConsumer, BSTR* pstrFilter);
    static DELETE_ME INTERNAL PSID GetSidFromObject(IWbemClassObject* pObj);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\permbind.cpp ===
//******************************************************************************
//
//  PERMBIND.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include <permbind.h>
#include <permfilt.h>

long CPermanentBinding::mstatic_lConsumerHandle = 0;
long CPermanentBinding::mstatic_lFilterHandle = 0;
long CPermanentBinding::mstatic_lQosHandle = 0;
long CPermanentBinding::mstatic_lSynchronicityHandle = 0;
long CPermanentBinding::mstatic_lSlowDownHandle = 0;
long CPermanentBinding::mstatic_lSecureHandle = 0;
long CPermanentBinding::mstatic_lSidHandle = 0;
bool CPermanentBinding::mstatic_bHandlesInitialized = false;

// static 
HRESULT CPermanentBinding::InitializeHandles( _IWmiObject* pBindingObj)
{
    if(mstatic_bHandlesInitialized)
        return S_FALSE;

    CIMTYPE ct;
    pBindingObj->GetPropertyHandle(CONSUMER_ROLE_NAME, &ct, 
                                    &mstatic_lConsumerHandle);
    pBindingObj->GetPropertyHandle(FILTER_ROLE_NAME, &ct, 
                                    &mstatic_lFilterHandle);
    pBindingObj->GetPropertyHandle(BINDING_SYNCHRONICITY_PROPNAME, &ct, 
                                    &mstatic_lSynchronicityHandle);
    pBindingObj->GetPropertyHandle(BINDING_QOS_PROPNAME, &ct, 
                                    &mstatic_lQosHandle);
    pBindingObj->GetPropertyHandle(BINDING_SECURE_PROPNAME, &ct, 
                                    &mstatic_lSecureHandle);
    pBindingObj->GetPropertyHandle(BINDING_SLOWDOWN_PROPNAME, &ct, 
                                    &mstatic_lSlowDownHandle);
    pBindingObj->GetPropertyHandleEx(OWNER_SID_PROPNAME, 0, &ct, 
                                          &mstatic_lSidHandle);

    mstatic_bHandlesInitialized = true;
    return S_OK;
}

HRESULT CPermanentBinding::Initialize( IWbemClassObject* pObj )
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pBindingObj;

    hres = pObj->QueryInterface(IID__IWmiObject, (void**)&pBindingObj );
    
    if (FAILED(hres))
        return hres;
    
    hres = InitializeHandles(pBindingObj);
    if(FAILED(hres))
        return hres;

    long lSize;

    //
    // Read the Qos property.
    //

    hres = pBindingObj->ReadPropertyValue( mstatic_lQosHandle, 
                                           sizeof(DWORD), 
                                           &lSize, 
                                           (BYTE*)&m_dwQoS );
    if(FAILED(hres))
        return hres;
    
    if ( hres != WBEM_S_NO_ERROR)
    {
        m_dwQoS = WMIMSG_FLAG_QOS_EXPRESS; // default.
    }
#ifdef __WHISTLER_UNCUT
    if ( m_dwQoS > WMIMSG_FLAG_QOS_XACT )
    {
        ERRORTRACE((LOG_ESS, "Invalid QoS of %d is used in a binding. "
                             "Setting to default.\n", m_dwQoS));

        m_dwQoS = WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( m_dwQoS == WMIMSG_FLAG_QOS_XACT )
    {
        ERRORTRACE((LOG_ESS, "XACT QoS is not a supported qos for binding. "
                             "Downgrading to Guaranteed Delivery.\n"));

        m_dwQoS = WMIMSG_FLAG_QOS_GUARANTEED;
    }
#else
    if ( m_dwQoS > WMIMSG_FLAG_QOS_EXPRESS )
    {
        ERRORTRACE((LOG_ESS, "Invalid QoS of %d is used in a binding.", m_dwQoS));
        return WBEM_E_INVALID_OBJECT;
    }
#endif
 
    //
    // Read the synchronousness property - for backwards compatibility 
    // Always overrides any Qos setting.
    // 

    VARIANT_BOOL bTemp;
    hres = pBindingObj->ReadPropertyValue(mstatic_lSynchronicityHandle, 
        sizeof(VARIANT_BOOL), &lSize, (BYTE*)&bTemp);

    if(FAILED(hres))
        return hres;
    
    if( hres == WBEM_S_NO_ERROR && bTemp == VARIANT_TRUE )
    {
        m_dwQoS = WMIMSG_FLAG_QOS_SYNCHRONOUS;
    }

    // Read security property
    // ======================

    hres = pBindingObj->ReadPropertyValue(mstatic_lSecureHandle, 
        sizeof(VARIANT_BOOL), &lSize, (BYTE*)&bTemp);

    if(FAILED(hres))
        return hres;

    if(hres != WBEM_S_NO_ERROR)
        m_bSecure = FALSE;
    else 
        m_bSecure =  (bTemp != 0);

    // Read "slow down" property
    // =========================

    hres = pBindingObj->ReadPropertyValue(mstatic_lSlowDownHandle, 
        sizeof(VARIANT_BOOL), &lSize, (BYTE*)&bTemp);

    if(FAILED(hres))
        return hres;

    if(hres != WBEM_S_NO_ERROR)
        m_bSlowDown = FALSE;
    else 
        m_bSlowDown =  (bTemp != 0);

    return WBEM_S_NO_ERROR;
}

HRESULT CPermanentBinding::ComputeKeysFromObject( IWbemClassObject* pObj,
                                                  BSTR* pstrConsumer, 
                                                  BSTR* pstrFilter )
{
    HRESULT hres;
    CWbemPtr<_IWmiObject> pBindingObj;

    hres = pObj->QueryInterface(IID__IWmiObject, (void**)&pBindingObj );
    
    if ( hres != S_OK)
    {
        return NULL;
    }
    
    InitializeHandles(pBindingObj);

    // Read filter path
    // ================

    ULONG ulFlags;
    CCompressedString* pcsFilter;

    hres = pBindingObj->GetPropAddrByHandle( mstatic_lFilterHandle,
                                             WMIOBJECT_FLAG_ENCODING_V1,
                                             &ulFlags,
                                             (void**)&pcsFilter );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    BSTR strFilterPath = pcsFilter->CreateBSTRCopy();
    if(strFilterPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strFilterPath);

    // Construct its key
    // =================

    BSTR strFilter = CPermanentFilter::ComputeKeyFromPath(strFilterPath);
    if(strFilter == NULL)
        return WBEM_E_INVALID_OBJECT_PATH;

    // Read consumer path
    // ==================

    CCompressedString* pcsConsumer;

    hres = pBindingObj->GetPropAddrByHandle( mstatic_lConsumerHandle,
                                             WMIOBJECT_FLAG_ENCODING_V1,
                                             &ulFlags,
                                             (void**)&pcsConsumer );
    if( hres != S_OK )
    {
        SysFreeString(strFilter);
        return WBEM_E_INVALID_OBJECT;
    }

    *pstrConsumer = pcsConsumer->CreateBSTRCopy();

    if(*pstrConsumer == NULL)
    {
        SysFreeString(strFilter);
        return WBEM_E_OUT_OF_MEMORY;
    }

    *pstrFilter = strFilter;

    return WBEM_S_NO_ERROR;
}

INTERNAL DELETE_ME PSID 
CPermanentBinding::GetSidFromObject(IWbemClassObject* pObj)
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pBindingObj;

    hres = pObj->QueryInterface(IID__IWmiObject, (void**)&pBindingObj );
    
    if ( hres != S_OK)
    {
        return NULL;
    }

    InitializeHandles(pBindingObj);

    PSID pAddr;
    ULONG ulNumElements;

    hres = pBindingObj->GetArrayPropAddrByHandle( mstatic_lSidHandle,
                                                  0,
                                                  &ulNumElements,
                                                  &pAddr );
    if ( hres != S_OK )
    {
        return NULL;
    }

    //
    // we copy the SID here because the SID that is returned might be 
    // unaligned.  To avoid having the caller deal with these issues, we 
    // just copy the sid into a buffer that is guaranteed to be aligned.
    //

    PBYTE pSid = new BYTE[ulNumElements];
    
    if ( pSid != NULL )
    {
        memcpy( pSid, pAddr, ulNumElements );
    }

    return pSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\nsrep.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  NSREP.H
//
//  Represents the ESS functionality for a given namespace
//
//  Classes defined:
//
//      CEssNamespace
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//  1/6/97      a-levn      Updated to initialize TSS.
//
//=============================================================================
#ifndef __NSREP_ESS__H_
#define __NSREP_ESS__H_

#include "pragmas.h"
#include "binding.h"
#include "permfilt.h"
#include "permcons.h"
#include "tempfilt.h"
#include "tempcons.h"
#include "corefind.h"
#include "consprov.h"
#include "provreg.h"
#include "wbemtss.h"
#include "poller.h"
#include "essutils.h"
#include "clscache.h"
#include "moniprov.h"
#include <map>
#include <set>

class CEss;
class CEssNamespace : public CUpdateLockable
{
protected:
    CEss* m_pEss;
    long m_lRef;

    //
    // protects level 1 members. These are members that can be used even
    // when level2 members are locked.
    //
    CCritSec m_csLevel1; 
    
    //
    // protects level 2 members. When both a level1 and level2 lock need to 
    // be aquired, the level2 lock MUST be obtained first.  This is a wbem cs
    // because we hold this lock across calls to core ( which can conceivably 
    // take longer than 2 minutes - the deadline for normal critical sections )
    //
    CWbemCriticalSection m_csLevel2;

    //
    // level 1 members 
    // 

    HANDLE m_hInitComplete;

    //
    // If events are signaled when we are in the unitialized state, then 
    // they are temporarily stored here.
    //
    CPointerArray<CEventRepresentation> m_aDeferredEvents;

    LPWSTR m_wszName;
    _IWmiProviderFactory* m_pProviderFactory;
    IWbemServices* m_pCoreSvc;
    IWbemServices* m_pFullSvc;
    IWbemInternalServices* m_pInternalCoreSvc;
    IWbemInternalServices* m_pInternalFullSvc;

    //
    // Level 2 members.
    // 

    BOOL m_bInResync;
    BOOL m_bStage1Complete;
    int m_cActive; 
    CBindingTable m_Bindings;
    CConsumerProviderCache m_ConsumerProviderCache;
    CEventProviderCache m_EventProviderCache;
    CPoller m_Poller;
    CEssClassCache m_ClassCache;
    CMonitorProvider* m_pMonitorProvider;
    CCoreEventProvider* m_pCoreEventProvider;

    CNtSid m_sidAdministrators;

    //
    // this structure maps tells us if we need to do anything for a provider
    // when a class changes.
    //
    typedef std::set<WString,WSiless,wbem_allocator<WString> > ProviderSet;
    typedef std::map<WString,ProviderSet,WSiless,wbem_allocator<ProviderSet> >
        ClassToProviderMap;
    ClassToProviderMap m_mapProviderInterestClasses;

    //
    // the state and init members are both level 1 and level2.  They can be 
    // read when the level1 lock is held.  They can only be modified when the
    // level2 and level1 locks are held.   
    //

    HRESULT m_hresInit;
    
    enum { 

        //
        // Initialization is Pending. Can service 
        // events from core in this state (though will be defferred ).
        // it is expected that Initialize() will be called
        // sometime in the near future.  We also can support limited ops 
        // while in this state.  Any operations that deal with event 
        // subsciptions or provider objects can be serviced.  Any ops that 
        // deal with event provider registrations must wait for initialization.
        //
        e_InitializePending, 

        //
        // Quiet - Initialization is not pending.  The namespace is known to
        // be empty of any ess related onjects.  Can service events in this 
        // state, but they are simply discarded.
        //
        e_Quiet, 

        //
        // We have loaded subscription objects.  All ess operations can be 
        // performed.  Events from core now can be processed.
        // 
        e_Initialized,
          
        //
        // Shutdown has been called.  All operations return error.
        //
        e_Shutdown 

    } m_eState; 

protected:
    class CConsumerClassDeletionSink : public CEmbeddedObjectSink<CEssNamespace>
    {
    public:
        CConsumerClassDeletionSink(CEssNamespace* pNamespace) :
            CEmbeddedObjectSink<CEssNamespace>(pNamespace){}

        STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects);
    } m_ClassDeletionSink;
    friend CConsumerClassDeletionSink;

protected:

    inline void LogOp( LPCWSTR wszOp, IWbemClassObject* pObj );

    HRESULT EnsureInitPending();

    HRESULT CheckMonitor(IWbemClassObject* pPrevMonitorObj,
                                IWbemClassObject* pMonitorObj);
    HRESULT CheckEventFilter(IWbemClassObject* pPrevFilterObj,
                                IWbemClassObject* pFilterObj);
    HRESULT CheckEventConsumer(IWbemClassObject* pPrevConsumerObj,
                                IWbemClassObject* pConsumerObj);
    HRESULT CheckBinding(IWbemClassObject* pPrevBindingObj,
                                IWbemClassObject* pBindingObj);
    HRESULT CheckEventProviderRegistration(IWbemClassObject* pReg);
    HRESULT CheckTimerInstruction(IWbemClassObject* pInst);
    HRESULT ActOnSystemEvent(CEventRepresentation& Event, long lFlags);
    HRESULT HandleClassChange(LPCWSTR wszClassName, IWbemClassObject* pClass);
    HRESULT HandleClassCreation(LPCWSTR wszClassName,IWbemClassObject* pClass);
    HRESULT HandleConsumerClassDeletion(LPCWSTR wszClassName);
    HRESULT PrepareForResync();
    HRESULT ReactivateAllFilters();
    HRESULT CommitResync();

    HRESULT ReloadMonitor(ADDREF IWbemClassObject* pEventMonitorObj);
    HRESULT ReloadEventFilter(ADDREF IWbemClassObject* pEventFilterObj);
    HRESULT ReloadEventConsumer(READ_ONLY IWbemClassObject* pConsumerObj,
                                    long lFlags);
    HRESULT ReloadBinding(READ_ONLY IWbemClassObject* pBindingObj);
    HRESULT ReloadTimerInstruction(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT ReloadProvider(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT ReloadEventProviderRegistration(IWbemClassObject* pInstObj);
    HRESULT ReloadConsumerProviderRegistration(IWbemClassObject* pInstObj);

    HRESULT AddMonitor(ADDREF IWbemClassObject* pEventMonitorObj);
    HRESULT AddEventFilter(ADDREF IWbemClassObject* pEventFilterObj,
                            BOOL bInRestart = FALSE);
    HRESULT AddEventConsumer(READ_ONLY IWbemClassObject* pConsumerObj,
                            long lFlags,
                            BOOL bInRestart = FALSE);
    HRESULT AddBinding(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey,
                        READ_ONLY IWbemClassObject* pBindingObj);
    HRESULT AddBinding(IWbemClassObject* pBindingObj);
    HRESULT AddTimerInstruction(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT AddProvider(READ_ONLY IWbemClassObject* pInstObj);
    HRESULT AddEventProviderRegistration(READ_ONLY IWbemClassObject* pInstObj);

    HRESULT RemoveMonitor(IWbemClassObject* pEventMonitorObj);
    HRESULT RemoveEventFilter(IWbemClassObject* pEventFilterObj);
    HRESULT RemoveEventConsumer(IWbemClassObject* pConsumerObj);
    HRESULT RemoveBinding(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey);
    HRESULT RemoveTimerInstruction(IWbemClassObject* pInstObj);
    HRESULT RemoveProvider(IWbemClassObject* pInstObj);
    HRESULT RemoveEventProviderRegistration(IWbemClassObject* pInstObj);
    HRESULT RemoveConsumerProviderRegistration(IWbemClassObject* pInstObj);

    HRESULT AssertBindings(IWbemClassObject* pEndpoint);
    HRESULT DeleteConsumerProvider(IWbemClassObject* pReg);

    HRESULT PerformSubscriptionInitialization();
    HRESULT PerformProviderInitialization();
    
    BOOL IsNeededOnStartup();
    
    HRESULT GetCurrentState(IWbemClassObject* pTemplate, 
                            IWbemClassObject** ppObj);

    HRESULT CheckSecurity(IWbemClassObject* pPrevObj,
                                            IWbemClassObject* pObj);
    HRESULT EnsureSessionSid(IWbemClassObject* pPrevObj, CNtSid& ActingSid);
    HRESULT CheckOverwriteSecurity( IWbemClassObject* pPrevObj,
                                    CNtSid& ActingSid);
    HRESULT PutSidInObject(IWbemClassObject* pObj, CNtSid& Sid);
    HRESULT IsCallerAdministrator();
    HRESULT AttemptToActivateFilter(READ_ONLY CEventFilter* pFilter);
    HRESULT GetFilterEventNamespace(CEventFilter* pFilter,
                                    RELEASE_ME CEssNamespace** ppNamespace);

    void FireNCFilterEvent(DWORD dwIndex, CEventFilter *pFilter);

    CQueueingEventSink* GetQueueingEventSink( LPCWSTR wszSinkName );

    ~CEssNamespace();
public:
    CEssNamespace(CEss* pEss);
    ULONG AddRef();
    ULONG Release();

    CEss* GetEss() { return m_pEss; }
    
    //
    // On return, namespace can be used for limited operations.  Events 
    // can be signaled ( though they may be defferred internally ) and 
    // operations dealing with subscriptions can be performed. 
    //
    HRESULT PreInitialize( LPCWSTR wszName );
        
    //
    // Performs initialization but does NOT transition state to Initialized.
    // This is done by calling MarkAsInitialized().  This allows a caller to 
    // atomically perform initalization of multiple namespaces.
    //
    HRESULT Initialize();
    
    //
    // Finishes loading event provider registrations and processes 
    // subcriptions. Transitions to FullyInitialized() state. 
    // 
    HRESULT CompleteInitialization();

    //
    // Transitions state to Initialized. 
    //
    void MarkAsInitialized( HRESULT hres );

    //
    // Transitions state to Initialize Pending if previously in the Quiet 
    // state.  Returns TRUE if transition was made.
    //
    BOOL MarkAsInitPendingIfQuiet();

    //
    // Waits for Initialization to complete. 
    // 
    HRESULT WaitForInitialization();
    
    HRESULT Park();
    HRESULT Shutdown();
    LPCWSTR GetName() {return m_wszName;}
    HRESULT GetNamespacePointer(RELEASE_ME IWbemServices** ppNamespace);
    HRESULT LoadEventProvider(LPCWSTR wszProviderName, 
                                         IWbemEventProvider** ppProv);
    HRESULT LoadConsumerProvider(LPCWSTR wszProviderName, 
                                         IUnknown** ppProv);
    HRESULT DecorateObject(IWbemClassObject* pObject);
    HRESULT ProcessEvent(CEventRepresentation& Event, long lFlags);
    HRESULT ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event );
    HRESULT SignalEvent(CEventRepresentation& Event, long lFlags);
    HRESULT ValidateSystemEvent(CEventRepresentation& Event);

    void SetActive();
    void SetInactive();
    
    HRESULT ActivateFilter(READ_ONLY CEventFilter* pFilter);
    HRESULT DeactivateFilter(READ_ONLY CEventFilter* pFilter);

    //
    // public versions of register/remove notification sink.  Do NOT use 
    // these versions if calling from within ESS.  The reason is that these 
    // versions wait for initialization and lock the namespace which might 
    // cause deadlocks if called from within ESS.  We also don't want to 
    // generate self instrumentation events for internal calls.
    //
    HRESULT RegisterNotificationSink(
                            WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, 
                            long lFlags, WMIMSG_QOS_FLAG lQosFlags, 
                            IWbemContext* pContext, 
                            IWbemObjectSink* pSink );

    HRESULT RemoveNotificationSink( IWbemObjectSink* pSink );

    HRESULT ReloadProvider( long lFlags, LPCWSTR wszProvider );
    //
    // Internal versions of register/remove notification sink.  They do
    // not lock, wait for initialization, or fire self instrumentation events.
    // If calling these methods from within ess, specify bInternal as TRUE.
    // The pOwnerSid is used when access checks for the subscription should 
    // be performed based on a particular SID.  currently this is only used 
    // for cross-namespace subscriptions.
    //
    HRESULT InternalRegisterNotificationSink(
                            WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery, 
                            long lFlags, WMIMSG_QOS_FLAG lQosFlags, 
                            IWbemContext* pContext, IWbemObjectSink* pSink,
                            bool bInternal, PSID pOwnerSid );
    HRESULT InternalRemoveNotificationSink(IWbemObjectSink* pSink);

    CWinMgmtTimerGenerator& GetTimerGenerator();
    CConsumerProviderCache& GetConsumerProviderCache() 
        {return m_ConsumerProviderCache;}

    DWORD GetProvidedEventMask(IWbemClassObject* pClass);

    HRESULT EnsureConsumerWatchInstruction();
    HRESULT InitializeTimerGenerator();
    HRESULT ScheduleDelivery(CQueueingEventSink* pDest);
    HRESULT RaiseErrorEvent(IWbemEvent* pEvent);

    void IncrementObjectCount();
    void DecrementObjectCount();
    HRESULT AddSleepCharge(DWORD dwSleep);
    HRESULT AddCache();
    HRESULT RemoveCache();
    HRESULT AddToCache(DWORD dwAdd, DWORD dwMemberTotal, 
                        DWORD* pdwSleep = NULL);
    HRESULT RemoveFromCache(DWORD dwRemove);

    HRESULT LockForUpdate();
    HRESULT UnlockForUpdate();
    bool IsShutdown() { return m_eState == e_Shutdown; }

    HRESULT GetProviderNamespacePointer(IWbemServices** ppServices);
    HRESULT GetClass( LPCWSTR wszClassName, _IWmiObject** ppClass)
        { return m_ClassCache.GetClass(wszClassName, GetCurrentEssContext(), 
                                        ppClass);}
    HRESULT GetClassFromCore(LPCWSTR wszClassName, _IWmiObject** ppClass);
    HRESULT GetInstance(LPCWSTR wszPath, _IWmiObject** ppInstance);
    HRESULT GetDbInstance(LPCWSTR wszDbKey, _IWmiObject** ppInstance);
    HRESULT CreateInstanceEnum(LPCWSTR wszClass, long lFlags, 
                                IWbemObjectSink* pSink);
    HRESULT ExecQuery(LPCWSTR wszQuery, long lFlags, IWbemObjectSink* pSink);
    
    
    CNtSid& GetAdministratorsSid() {return m_sidAdministrators;}
    HRESULT GetToken(PSID pSid, IWbemToken** ppToken);
    
       
    HRESULT RegisterFilterForAllClassChanges(CEventFilter* pFilter,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr);
    HRESULT RegisterSinkForAllClassChanges(IWbemObjectSink* pSink,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr);
    HRESULT RegisterSinkForClassChanges(IWbemObjectSink* pSink,
                                                    LPCWSTR wszClassName);
    HRESULT UnregisterFilterFromAllClassChanges(CEventFilter* pFilter);
    HRESULT UnregisterSinkFromAllClassChanges(IWbemObjectSink* pSink);
    
    HRESULT RegisterProviderForClassChanges( LPCWSTR wszClassName, 
                                             LPCWSTR wszProvName );
    
    HRESULT FirePostponedOperations();
    HRESULT ScheduleFirePostponed();
    HRESULT PostponeRelease(IUnknown* pUnk);
    
    static PSID GetSidFromObject(IWbemClassObject* pObj);

    BOOL DoesThreadOwnNamespaceLock();

    void DumpStatistics(FILE* f, long lFlags);
   
    friend class CEss;
    friend class CEssMetaData;
    friend class CFilterEnumSink;
    friend class CConsumerEnumSink;
    friend class CBindingEnumSink;
    friend class CMonitorEnumSink;
    friend class CInResync;
    friend class CAssertBindingsSink;
    friend class CFirePostponed;
};

class CInResync
{
protected:
    CEssNamespace* m_pNamespace;

public:
    CInResync(CEssNamespace* pNamespace) : m_pNamespace(pNamespace)
    {
        m_pNamespace->PrepareForResync();
    }
    ~CInResync()
    {
        m_pNamespace->ReactivateAllFilters();
        m_pNamespace->CommitResync();
    }
};

class CEssMetaData : public CMetaData
{
protected:
    CEssNamespace* m_pNamespace;

public:
    CEssMetaData(CEssNamespace* pNamespace) : m_pNamespace(pNamespace){}

    virtual HRESULT GetClass( LPCWSTR wszName, 
                              IWbemContext* pContext,
                              _IWmiObject** ppClass );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\permfilt.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  PERMFILT.CPP
//
//  This file implements the classes for standard event filters.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include <sddl.h>
#include <stdio.h>
#include "pragmas.h"
#include "permfilt.h"
#include "ess.h"
#include <genutils.h>

long CPermanentFilter::mstatic_lNameHandle = 0;
long CPermanentFilter::mstatic_lLanguageHandle = 0;
long CPermanentFilter::mstatic_lQueryHandle = 0;
long CPermanentFilter::mstatic_lEventNamespaceHandle = 0;
long CPermanentFilter::mstatic_lEventAccessHandle = 0;
long CPermanentFilter::mstatic_lGuardNamespaceHandle = 0;
long CPermanentFilter::mstatic_lGuardHandle = 0;
long CPermanentFilter::mstatic_lSidHandle = 0;
bool CPermanentFilter::mstatic_bHandlesInitialized = false;

//static 
HRESULT CPermanentFilter::InitializeHandles( _IWmiObject* pObject )
{
    if(mstatic_bHandlesInitialized)
        return S_FALSE;

    CIMTYPE ct;
    pObject->GetPropertyHandle(FILTER_KEY_PROPNAME, &ct, 
                                    &mstatic_lNameHandle);
    pObject->GetPropertyHandle(FILTER_LANGUAGE_PROPNAME, &ct, 
                                    &mstatic_lLanguageHandle);
    pObject->GetPropertyHandle(FILTER_QUERY_PROPNAME, &ct, 
                                    &mstatic_lQueryHandle);
    pObject->GetPropertyHandle(FILTER_EVENTNAMESPACE_PROPNAME, &ct, 
                                    &mstatic_lEventNamespaceHandle);
    pObject->GetPropertyHandleEx(FILTER_EVENTACCESS_PROPNAME, 0, &ct, 
                                  &mstatic_lEventAccessHandle );
    pObject->GetPropertyHandle(FILTER_GUARDNAMESPACE_PROPNAME, &ct, 
                                    &mstatic_lGuardNamespaceHandle);
    pObject->GetPropertyHandle(FILTER_GUARD_PROPNAME, &ct, 
                                    &mstatic_lGuardHandle);
    pObject->GetPropertyHandleEx(OWNER_SID_PROPNAME, 0, &ct, 
                                  &mstatic_lSidHandle);
    mstatic_bHandlesInitialized = true;
    return S_OK;
}
//******************************************************************************
//  public
//
//  See stdtrig.h for documentation
//
//******************************************************************************
CPermanentFilter::CPermanentFilter(CEssNamespace* pNamespace)     
: CGenericFilter(pNamespace), m_pEventAccessRelativeSD(NULL)
{
}

CPermanentFilter::~CPermanentFilter()
{
    if ( m_pEventAccessRelativeSD != NULL )
    {
        LocalFree( m_pEventAccessRelativeSD );
    }
}

HRESULT CPermanentFilter::Initialize( IWbemClassObject* pObj )
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pFilterObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pFilterObj );

    if ( FAILED(hres) )
    {
        return hres;
    }

    InitializeHandles( pFilterObj );

    // Check class
    // ===========

    if(pFilterObj->InheritsFrom(L"__EventFilter") != S_OK)
        return WBEM_E_INVALID_OBJECT;

    // Determine the query language
    // ============================

    ULONG ulFlags;
    CCompressedString* pcsLanguage;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lLanguageHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsLanguage );
    if( hres != S_OK || pcsLanguage == NULL)
    {
        ERRORTRACE((LOG_ESS, "Event filter with invalid query language is "
                    "rejected\n"));
        return WBEM_E_INVALID_OBJECT;
    }

    if( pcsLanguage->CompareNoCase("WQL") != 0 )
    {
        ERRORTRACE((LOG_ESS, "Event filter with invalid query language '%S' is "
                    "rejected\n", pcsLanguage->CreateWStringCopy()));
        return WBEM_E_INVALID_QUERY_TYPE;
    }

    // Get the query
    // =============

    CCompressedString* pcsQuery;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lQueryHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsQuery );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    LPWSTR wszQuery = pcsQuery->CreateWStringCopy().UnbindPtr();
    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm1(wszQuery);

    // Store it temporarily (until Park is called)
    // ===========================================

    // Figure out how much space we need
    // =================================

    int nSpace = pcsQuery->GetLength();

    // Allocate this string on the temporary heap
    // ==========================================

    m_pcsQuery = (CCompressedString*)CTemporaryHeap::Alloc(nSpace);
    if(m_pcsQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Copy the contents
    // =================

    memcpy((void*)m_pcsQuery, pcsQuery, nSpace);

    //
    // Get the event namespace
    //

    if(mstatic_lEventNamespaceHandle) // to protect against old repositories
    {
        CCompressedString* pcsEventNamespace;
        
        hres = pFilterObj->GetPropAddrByHandle( mstatic_lEventNamespaceHandle,
                                                WMIOBJECT_FLAG_ENCODING_V1,
                                                &ulFlags,
                                                (void**)&pcsEventNamespace );
        if( FAILED(hres) )
        {
            return hres;
        }
        else if ( hres == S_OK ) // o.k if event namespace is null.
        {   
            if( !(m_isEventNamespace = pcsEventNamespace))
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    CCompressedString* pcsGuard = NULL;
    if(mstatic_lGuardHandle) // to protect against old repositories
    {

        hres = pFilterObj->GetPropAddrByHandle( mstatic_lGuardHandle,
                                                WMIOBJECT_FLAG_ENCODING_V1,
                                                &ulFlags,
                                                (void**)&pcsGuard );
        if( FAILED(hres) )
            return hres;
    }

    if(pcsGuard)
    {
        CCompressedString* pcsGuardNamespace = NULL;
        if(mstatic_lGuardNamespaceHandle) // to protect against old repositories
        {
    
            hres = pFilterObj->GetPropAddrByHandle( 
                                    mstatic_lGuardNamespaceHandle,
                                    WMIOBJECT_FLAG_ENCODING_V1,
                                    &ulFlags,
                                    (void**)&pcsGuardNamespace );
            if( FAILED(hres) )
                return hres;
        }

        //
        // Check query type
        //

        VARIANT vType;
        VariantInit(&vType);
        CClearMe cm1(&vType);

        hres = pFilterObj->Get(FILTER_GUARDLANG_PROPNAME, 0, &vType, NULL, 
                                NULL);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Condition without a query type? Not valid\n"));
            return hres;
        }

        if(V_VT(&vType) != VT_BSTR)
        {
            ERRORTRACE((LOG_ESS, "Condition without a query type? Not "
                                    "valid\n"));
            return WBEM_E_INVALID_OBJECT;
        }

        if(wbem_wcsicmp(V_BSTR(&vType), L"WQL"))
        {
            ERRORTRACE((LOG_ESS, "Condition with invalid query type %S is "
                        "rejected\n", V_BSTR(&vType)));
            return hres;
        }


        if(pcsGuardNamespace)
            hres = SetGuardQuery(pcsGuard->CreateWStringCopy(), 
                                    pcsGuardNamespace->CreateWStringCopy());
        else
            hres = SetGuardQuery(pcsGuard->CreateWStringCopy(), NULL);
            
        if( FAILED(hres) )
            return hres;
    }
        
    //
    // Record the name of this filter
    //

    CCompressedString* pcsKey;
    
    hres = pFilterObj->GetPropAddrByHandle( mstatic_lNameHandle,
                                           WMIOBJECT_FLAG_ENCODING_V1,
                                           &ulFlags,
                                           (void**)&pcsKey );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    if(!(m_isKey = pcsKey))
        return WBEM_E_OUT_OF_MEMORY;

    // Get the SID
    // ===========

    PSID pSid;
    ULONG ulNumElements;
    
    hres = pFilterObj->GetArrayPropAddrByHandle( mstatic_lSidHandle,
                                                 0,
                                                 &ulNumElements,
                                                 &pSid );
    if ( hres != S_OK ) 
    {
        return WBEM_E_INVALID_OBJECT;
    }

    m_pOwnerSid = new BYTE[ulNumElements];

    if ( m_pOwnerSid == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    memcpy( m_pOwnerSid, pSid, ulNumElements );

    //
    // Get the event access SD
    //

    if( mstatic_lEventAccessHandle ) // to protect against old repositories
    {
        CCompressedString* pcsEventAccess;
        
        hres = pFilterObj->GetPropAddrByHandle( mstatic_lEventAccessHandle,
                                                WMIOBJECT_FLAG_ENCODING_V1,
                                                &ulFlags,
                                                (void**)&pcsEventAccess );
        if( FAILED(hres) )
        {
            return hres;
        }
        else if ( hres == S_OK ) // o.k if event access is null.
        {
            WString wsEventAccess;

            try
            {
                wsEventAccess = pcsEventAccess->CreateWStringCopy();
            }
            catch( CX_MemoryException )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            ULONG cEventAccessRelativeSD;

            if ( !ConvertStringSecurityDescriptorToSecurityDescriptorW(
                                   wsEventAccess, 
                                   SDDL_REVISION_1, 
                                   &m_pEventAccessRelativeSD, 
                                   &cEventAccessRelativeSD ) )
            {
                WString wsKey = m_isKey;
                try { wsKey = m_isKey; } catch( CX_MemoryException ) {}
                ERRORTRACE((LOG_ESS, "Filter '%S' contained invalid SDDL "
                            "string for event access SD.\n", wsKey )); 
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            //
            // convert the self-relative SD to an absolute SD so we can 
            // set the owner and group fields ( required by AccessCheck ) 
            //

            if ( !InitializeSecurityDescriptor( &m_EventAccessAbsoluteSD, 
                                                SECURITY_DESCRIPTOR_REVISION ))
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            PACL pAcl;            
            BOOL bAclPresent, bAclDefaulted;

            if ( !GetSecurityDescriptorDacl( m_pEventAccessRelativeSD,
                                             &bAclPresent,
                                             &pAcl,
                                             &bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
                                       
            if ( !SetSecurityDescriptorDacl( &m_EventAccessAbsoluteSD, 
                                             bAclPresent,
                                             pAcl,
                                             bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( !GetSecurityDescriptorSacl( m_pEventAccessRelativeSD,
                                             &bAclPresent,
                                             &pAcl,
                                             &bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
                                       
            if ( !SetSecurityDescriptorSacl( &m_EventAccessAbsoluteSD, 
                                             bAclPresent,
                                             pAcl,
                                             bAclDefaulted ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            //
            // always need to set the owner and group sids. We do this for 
            // two reasons (1) we want to override the user putting in anything
            // they want for these fields, and (2) we want to ensure that 
            // these fields are set because AccessCheck() requires it.
            //

            if ( !SetSecurityDescriptorOwner( &m_EventAccessAbsoluteSD,
                                              m_pOwnerSid,
                                              TRUE ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }

            if ( !SetSecurityDescriptorGroup( &m_EventAccessAbsoluteSD,
                                              m_pOwnerSid,
                                              TRUE ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
        }
    }

    // Initialize the generic filter accordingly
    // =========================================

    hres = CGenericFilter::Create(L"WQL", wszQuery);
    if(FAILED(hres))
        return hres;
    return WBEM_S_NO_ERROR;
}

const PSECURITY_DESCRIPTOR CPermanentFilter::GetEventAccessSD()
{
    if ( m_pEventAccessRelativeSD != NULL )
    {
        return &m_EventAccessAbsoluteSD;
    }
    return NULL;
}

HRESULT CPermanentFilter::GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                QL_LEVEL_1_RPN_EXPRESSION** ppExp)
{
    HRESULT hres;

    if(m_pcsQuery == NULL)
    {
        hres = RetrieveQuery(wszQuery);
    }
    else
    {
        wszQuery = m_pcsQuery->CreateWStringCopy().UnbindPtr();
        if(wszQuery == NULL)
            hres = WBEM_E_OUT_OF_MEMORY;
        else
            hres = WBEM_S_NO_ERROR;
    }

    if(FAILED(hres))
        return hres;

    if(ppExp)
    {
        // Parse it
        // ========
    
        CTextLexSource src(wszQuery);
        QL1_Parser parser(&src);
        int nRes = parser.Parse(ppExp);
        if (nRes)
        {
            ERRORTRACE((LOG_ESS, "Unable to construct event filter with "
                "unparsable "
                "query '%S'.  The filter is not active\n", wszQuery));
            return WBEM_E_UNPARSABLE_QUERY;
        }
    }

    bExact = TRUE;
    wszQueryLanguage = CloneWstr(L"WQL");

    return WBEM_S_NO_ERROR;
}

HRESULT CPermanentFilter::RetrieveQuery(DELETE_ME LPWSTR& wszQuery)
{
    HRESULT hres;

    //
    // Construct db path
    //

    BSTR strPath = SysAllocStringLen(NULL, m_isKey.GetLength() + 100);
    if(strPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strPath);

    swprintf(strPath, L"__EventFilter=\"%s\"", (LPCWSTR)(WString)m_isKey);

    //
    // Retrieve the object
    //

    _IWmiObject* pFilterObj;
    hres = m_pNamespace->GetDbInstance(strPath, &pFilterObj);
    if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

    CReleaseMe rm(pFilterObj);

    InitializeHandles(pFilterObj);

    // Extract its properties
    // ======================

    ULONG ulFlags;
    CCompressedString* pcsQuery;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lQueryHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsQuery );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    wszQuery = pcsQuery->CreateWStringCopy().UnbindPtr();

    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
    
HRESULT CPermanentFilter::GetEventNamespace(
                                        DELETE_ME LPWSTR* pwszNamespace)
{
	if(m_isEventNamespace.IsEmpty())
		*pwszNamespace = NULL;
	else
	{
		*pwszNamespace = m_isEventNamespace.CreateLPWSTRCopy();
		if(*pwszNamespace == NULL)
			return WBEM_E_OUT_OF_MEMORY;
	}
    return S_OK;
}
    
SYSFREE_ME BSTR 
CPermanentFilter::ComputeKeyFromObj( IWbemClassObject* pObj )
{
    HRESULT hres;
    
    CWbemPtr<_IWmiObject> pFilterObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pFilterObj );

    if ( FAILED(hres) )
    {
        return NULL;
    }

    InitializeHandles(pFilterObj);

    ULONG ulFlags;
    CCompressedString* pcsKey;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lNameHandle, 
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsKey );
    if( hres != S_OK )
    {
        return NULL;
    }

    return pcsKey->CreateBSTRCopy();
}

SYSFREE_ME BSTR CPermanentFilter::ComputeKeyFromPath(
                                    LPCWSTR wszPath)
{
    // Find the first quote
    // ====================

    WCHAR* pwcFirstQuote = wcschr(wszPath, L'"');
    if(pwcFirstQuote == NULL)
        return NULL;

    // Find the next quote
    // ===================

    WCHAR* pwcLastQuote = wcschr(pwcFirstQuote+1, L'"');
    if(pwcLastQuote == NULL)
        return NULL;

    return SysAllocStringLen(pwcFirstQuote+1, pwcLastQuote - pwcFirstQuote - 1);
}


HRESULT CPermanentFilter::CheckValidity( IWbemClassObject* pObj )
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pFilterObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pFilterObj );

    if ( FAILED(hres) )
    {
        return hres;
    }

    InitializeHandles(pFilterObj);

    //
    // Check class
    //

    if(pFilterObj->InheritsFrom(L"__EventFilter") != S_OK)
        return WBEM_E_INVALID_OBJECT;

    //
    // Check the query language
    //

    ULONG ulFlags;
    CCompressedString* pcsLanguage;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lLanguageHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsLanguage );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_QUERY_TYPE;
    }

    if(pcsLanguage->CompareNoCase("WQL") != 0)
        return WBEM_E_INVALID_QUERY_TYPE;

    //
    // Get the query
    //

    CCompressedString* pcsQuery;

    hres = pFilterObj->GetPropAddrByHandle( mstatic_lQueryHandle,
                                            WMIOBJECT_FLAG_ENCODING_V1,
                                            &ulFlags,
                                            (void**)&pcsQuery );
    if( hres != S_OK )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    LPWSTR wszQuery = pcsQuery->CreateWStringCopy().UnbindPtr();
    
    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    
    CVectorDeleteMe<WCHAR> vdm(wszQuery);

    //
    // Make sure it is parsable
    //
    
    CTextLexSource src(wszQuery);
    QL1_Parser parser(&src);
    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;
    int nRes = parser.Parse(&pExp);
    if (nRes)
        return WBEM_E_UNPARSABLE_QUERY;
    delete pExp;

    return WBEM_S_NO_ERROR;
}

HRESULT CPermanentFilter::ObtainToken(IWbemToken** ppToken)
{
    // 
    // Get us a token from the token cache
    //

    return m_pNamespace->GetToken(GetOwner(), ppToken);
}

void CPermanentFilter::Park()
{
    if(m_pcsQuery)
        CTemporaryHeap::Free(m_pcsQuery, m_pcsQuery->GetLength());
    m_pcsQuery = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\nsrep.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  NSREP.CPP
//
//  See nsrep.h for documentation
//
//  History:
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "esssink.h"
#include "permbind.h"
#include "aggreg.h"
#include "persistcfg.h"
#include "WinMgmtR.h"
#include <ql.h>
#include <cominit.h>
#include <genutils.h>
#include "NCEvents.h" // For the non-COM event stuff
#include <tempbind.h>
#include <wbemutil.h>

#include <tchar.h>

long g_lNumNamespaces = 0;
long g_lNumInternalTempSubscriptions = 0;
long g_lNumTempSubscriptions = 0;

#define ENSURE_INITIALIZED \
    hres = EnsureInitPending(); \
    if ( FAILED(hres) ) \
        return hres; \
    hres = WaitForInitialization(); \
    if ( FAILED(hres) ) \
        return hres; \
    CInUpdate iu(this); 

// The use of this pointer to initialize parent class is valid in this context
#pragma warning(disable : 4355) 

class CEnumSink : public CObjectSink
{
protected:
    CEssNamespace* m_pNamespace;
    HANDLE m_hEvent;
    CEssThreadObject* m_pThreadObj;

public:
    CEnumSink(CEssNamespace* pNamespace) 
        : m_pNamespace(pNamespace), 
            m_hEvent(CreateEvent(NULL, FALSE, FALSE, NULL)),
            m_pThreadObj(GetCurrentEssThreadObject())
    {}
    ~CEnumSink(){SetEvent(m_hEvent);}

    void ReleaseAndWait()
    {
        HANDLE h = m_hEvent;
        Release();
        WaitForSingleObject(h, INFINITE);
        CloseHandle(h);
    }
    virtual HRESULT Process(IWbemClassObject* pObj) = 0;
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        SetConstructedEssThreadObject(m_pThreadObj);
        for(int i = 0; i < lNumObjects; i++)
            Process(apObjects[i]);

        return S_OK;
    }
    STDMETHOD(SetStatus)(long, HRESULT, BSTR, IWbemClassObject*)
    {
        return S_OK;
    }
};
    
class CFilterEnumSink : public CEnumSink
{
public:
    CFilterEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddEventFilter(pObj, TRUE);
    }
};

class CConsumerEnumSink : public CEnumSink
{
public:
    CConsumerEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddEventConsumer(pObj, 0, TRUE);
    }
};

class CBindingEnumSink : public CEnumSink
{
public:
    CBindingEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddBinding(pObj);
    }
};

#ifdef __WHISTLER_UNCUT
class CMonitorEnumSink : public CEnumSink
{
public:
    CMonitorEnumSink(CEssNamespace* pNamespace) : CEnumSink(pNamespace){}

    virtual HRESULT Process(IWbemClassObject* pObj)
    {
        return m_pNamespace->AddMonitor(pObj);
    }
};
#endif

class CPostponedReleaseRequest : public CPostponedRequest
{
protected:
    IUnknown* m_pUnk;
public:
    CPostponedReleaseRequest(IUnknown* pToRelease) : m_pUnk(pToRelease)
    {
        try 
        {
            if(m_pUnk)
                m_pUnk->AddRef();
        }
        catch(...)
        {
        }
    }
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        try
        {
            if(m_pUnk)
                m_pUnk->Release();
        }
        catch(...)
        {
        }
        return WBEM_S_NO_ERROR;
    }
    ~CPostponedReleaseRequest()
    {
        try
        {
            if(m_pUnk)
                m_pUnk->Release();
        }
        catch(...)
        {
        }
    }
};

class CPostponedRegisterNotificationSinkRequest : public CPostponedRequest
{
protected:
   
    WString m_wsQuery;
    WString m_wsQueryLanguage;
    DWORD m_lFlags;
    DWORD m_dwQosFlags;
    CWbemPtr<IWbemObjectSink> m_pSink;
    CWbemPtr<CEssNamespace> m_pNamespace;
    CNtSid m_OwnerSid;

public:

    HRESULT SetRegistration( CEssNamespace* pNamespace,
                             LPCWSTR wszQueryLanguage,
                             LPCWSTR wszQuery,
                             long lFlags,
                             DWORD dwQosFlags,
                             IWbemObjectSink* pSink,
                             PSID pOwnerSid )
    {
        m_pSink = pSink;
        m_lFlags = lFlags;
        m_dwQosFlags = dwQosFlags;
        m_pNamespace = pNamespace;

        try 
        {
            m_wsQuery = wszQuery;
            m_wsQueryLanguage = wszQueryLanguage;
            m_OwnerSid = CNtSid(pOwnerSid);
        }
        catch( CX_MemoryException )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_NO_ERROR;
    }

    HRESULT Execute( CEssNamespace* pNamespace )
    {
        HRESULT hr;

        //
        // we must set up a new thread object and then restore the 
        // old one where we're done.  Reason for this is that we don't 
        // want our call into the other namespace to affect the postponed 
        // list of this one.
        //
        CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();
        SetCurrentEssThreadObject(NULL);

        if ( GetCurrentEssThreadObject() == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        {
            CInUpdate iu( m_pNamespace );
            hr = m_pNamespace->InternalRegisterNotificationSink( 
                                                 m_wsQueryLanguage,
                                                 m_wsQuery,
                                                 m_lFlags,
                                                 WMIMSG_QOS_FLAG(m_dwQosFlags),
                                                 NULL,
                                                 m_pSink, 
                                                 TRUE,
                                                 m_OwnerSid.GetPtr() );
        }

        if ( SUCCEEDED(hr) )
        {
            hr = m_pNamespace->FirePostponedOperations();
        }
        else
        {
            m_pNamespace->FirePostponedOperations();
        }

        delete GetCurrentEssThreadObject();
        SetConstructedEssThreadObject( pOldThreadObject );

        return hr;
    }
};

class CPostponedRemoveNotificationSinkRequest : public CPostponedRequest
{
protected:
   
    CWbemPtr<IWbemObjectSink> m_pSink;
    CWbemPtr<CEssNamespace> m_pNamespace;

public:

    CPostponedRemoveNotificationSinkRequest( CEssNamespace* pNamespace,
                                             IWbemObjectSink* pSink ) 
     : m_pSink( pSink ), m_pNamespace( pNamespace ) { }
    
    HRESULT Execute( CEssNamespace* pNamespace )
    {
        HRESULT hr;

        //
        // we must set up a new thread object and then restore the 
        // old one where we're done.  Reason for this is that we don't 
        // want our call into the other namespace to affect the postponed 
        // list of this one.
        //
        CEssThreadObject* pOldThreadObject = GetCurrentEssThreadObject();
        SetCurrentEssThreadObject(NULL);

        if ( GetCurrentEssThreadObject() == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        {
            CInUpdate iu( m_pNamespace );
            hr = m_pNamespace->InternalRemoveNotificationSink( m_pSink );
        }

        if ( SUCCEEDED(hr) )
        {
            hr = m_pNamespace->FirePostponedOperations();
        }
        else
        {
            m_pNamespace->FirePostponedOperations();
        }

        delete GetCurrentEssThreadObject();
        SetConstructedEssThreadObject( pOldThreadObject );

        return hr;
    }
};

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
CEssNamespace::CEssNamespace(CEss* pEss) : 
            m_ClassDeletionSink(this), m_bInResync(FALSE), 
            m_Bindings(this), m_hInitComplete(INVALID_HANDLE_VALUE),
            m_EventProviderCache(this), m_Poller(this), 
            m_ConsumerProviderCache(this), m_hresInit(WBEM_E_CRITICAL_ERROR),
            m_ClassCache(this), m_eState(e_Quiet),
            m_pMonitorProvider(NULL), m_pCoreEventProvider(NULL),
            m_pEss(pEss), m_wszName(NULL), m_pCoreSvc(NULL), m_pFullSvc(NULL),
            m_lRef(0), m_pInternalCoreSvc(NULL), m_pInternalFullSvc(NULL),
            m_pProviderFactory(NULL), m_bStage1Complete(FALSE)
{
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;

    g_lNumNamespaces++;

    if(AllocateAndInitializeSid( &id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pRawSid))
    {
        m_sidAdministrators = CNtSid(pRawSid);
        // We're done with this
        FreeSid( pRawSid );
    }
}

ULONG CEssNamespace::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CEssNamespace::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//
// this function is intended to be called in the same control path as
// the one which constructs the namespace object.  Any initialization that 
// cannot be defferred is done here.  
//  
HRESULT CEssNamespace::PreInitialize( LPCWSTR wszName )
{
    HRESULT hres;

    m_wszName = new WCHAR[wcslen(wszName)+1];
    
    if(m_wszName == NULL)
    {
        hres = WBEM_E_OUT_OF_MEMORY;
        return hres;
    }
    wcscpy(m_wszName, wszName);

    //
    // create the event that will be used to signal any threads waiting 
    // for initialization to finish.
    //

    m_hInitComplete = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( NULL == m_hInitComplete  )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Obtain repository only service. This is used for acessing all
    // static ess objects.
    //

    hres = m_pEss->GetNamespacePointer( m_wszName, TRUE, &m_pCoreSvc );

    if(FAILED(hres))
    {
        return WBEM_E_INVALID_NAMESPACE; // not there anymore!
    }

    hres = m_pCoreSvc->QueryInterface( IID_IWbemInternalServices,
                                       (void**)&m_pInternalCoreSvc );
    if(FAILED(hres))
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Obtain full service.  This is used accessing class objects 
    // ( which may involve accessing class providers. 
    //

    hres = m_pEss->GetNamespacePointer( m_wszName, FALSE, &m_pFullSvc );

    if(FAILED(hres))
    {
        return WBEM_E_INVALID_NAMESPACE; // not there anymore!
    }

    hres = m_pFullSvc->QueryInterface( IID_IWbemInternalServices,
                                       (void**)&m_pInternalFullSvc );
    if(FAILED(hres))
    {
        return WBEM_E_CRITICAL_ERROR;
    }
   
    //
    // Get provider factory
    //

    hres = m_pEss->GetProviderFactory( m_wszName, 
                                       m_pFullSvc, 
                                       &m_pProviderFactory);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "No provider factory in %S: 0x%X\n", 
            m_wszName, hres));
    }

    //
    // we want to ensure that core stays loaded between the PreInitialize()
    // call and the Initialize() call.  This is only ever an issue when the
    // Initialize() call is defferred.  Reason to ensure this is because we
    // must keep core loaded when we have permanent subscriptions.  If we 
    // haven't initialized yet, then we don't know if we have any.  AddRef()  
    // core here and will then decrement in Initialize() to ensure this.
    // 
    IncrementObjectCount();

    //
    // Namespace always starts out in the Quiet state.  Caller must make 
    // a MarkAsInitPendingIfQuiet() call if they are going to schedule 
    // initialization.
    //

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::EnsureInitPending()
{
    {
        CInCritSec ics(&m_csLevel1);

        if ( m_eState != e_Quiet )
        {
            return WBEM_S_FALSE;
        }
    }

    CWbemPtr<CEssNamespace> pNamespace;
    return m_pEss->GetNamespaceObject( m_wszName, TRUE, &pNamespace );
}

BOOL CEssNamespace::MarkAsInitPendingIfQuiet() 
{
    CInCritSec ics( &m_csLevel1 );

    if ( m_eState != e_Quiet )
    {
        return FALSE;
    }

    m_eState = e_InitializePending;
    
    return TRUE;
};

HRESULT CEssNamespace::Initialize()
{
    HRESULT hres;

    DEBUGTRACE((LOG_ESS,"Initializing namespace %S\n", m_wszName ));

    //
    // need to modify level2 members. Grab namespace lock.
    //

    {
        CInUpdate iu(this);

        {
            CInCritSec ics( &m_csLevel1 );

            if ( m_eState == e_Shutdown )
            {
                return WBEM_E_SHUTTING_DOWN;
            }
            
            _DBG_ASSERT( m_eState == e_InitializePending );
        }

        //
        // Load and process subscription objects 
        // 

        hres = PerformSubscriptionInitialization();

        m_bStage1Complete = TRUE;
    }

    //
    // execute postponed operations outside of namespace lock.
    // if some of them fail to execute, it doesn't mean that the namespace
    // can't be initialized.  just log the error.
    //

    HRESULT hres2 = FirePostponedOperations();

    if ( FAILED(hres2) )
    {
        ERRORTRACE((LOG_ESS,"Failed to execute postponed operations when "
                    "performing initialization in namespace %S. HR=0x%x\n", 
                    m_wszName, hres2));
    } 

    return hres;
}

HRESULT CEssNamespace::CompleteInitialization()
{
    HRESULT hres;

    DEBUGTRACE((LOG_ESS,"Completing Initialization for namespace %S\n",
                m_wszName));

    //
    // need to modify level2 members. Grab namespace lock.
    //

    {
        CInUpdate iu(this);

        {
            CInCritSec ics( &m_csLevel1 );

            if ( m_eState == e_Shutdown )
            {
                return WBEM_E_SHUTTING_DOWN;
            }

            _DBG_ASSERT( m_eState == e_InitializePending );
        }

        //
        // load and process all objects that deal with event providers.
        //

        hres = PerformProviderInitialization();
    }

    //
    // execute postponed operations outside of namespace lock.
    // if some of them fail to execute, it doesn't mean that the namespace
    // can't be initialized.  just log the error.
    //

    HRESULT hres2 = FirePostponedOperations();

    if ( FAILED(hres2) )
    {
        ERRORTRACE((LOG_ESS,"Failed to execute postponed operations when "
                    "completing initialization in namespace %S. HR=0x%x\n", 
                    m_wszName, hres2));
    } 

    return hres;
}
    
void CEssNamespace::MarkAsInitialized( HRESULT hres )
{
    //
    // we need to grab the level1 critsec here because we're going to be
    // modifying the state of the namespace and because we're going to be 
    // using the defferred events list. 
    //
    CInCritSec ics( &m_csLevel1 );

    if ( m_eState == e_Shutdown )
    {
        return;
    }

    _DBG_ASSERT( m_eState == e_InitializePending );

    //
    // transition to Initialized.
    // 
    
    if ( SUCCEEDED(hres) && m_pCoreEventProvider != NULL )
    {
        //
        // while holding level1, handle any deferred events
        // 
        
        for( int i=0; i < m_aDeferredEvents.GetSize(); i++ )
        {
            //
            // iterate through 1 by 1 because later we may propagate
            // context for each event here.
            //
            
            HRESULT hr;
            CEventContext Context;
            hr = m_pCoreEventProvider->Fire( *m_aDeferredEvents[i], &Context );
            
            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"Could not fire deferred event in "
                            "namespace '%S'. HR=0x%x\n", m_wszName, hr ));
            }

            delete m_aDeferredEvents[i];
        }

        if (  m_aDeferredEvents.GetSize() > 0 )
        {
            DEBUGTRACE((LOG_ESS,"Fired %d deferred events after init "
                        "complete in namespace '%S'.\n", 
                        m_aDeferredEvents.GetSize(),m_wszName));
        }

        m_aDeferredEvents.RemoveAll();
    }

    //
    // release the ref we were holding to keep core loaded between PreInit()
    // and now.  
    //
    DecrementObjectCount(); 

    m_eState = e_Initialized;
    m_hresInit = hres;
    
    SetEvent( m_hInitComplete );
}

HRESULT CEssNamespace::WaitForInitialization()
{       
    HRESULT hres;

    //
    // The level1 or level2 locks cannot be held when calling this function.
    // The reason for this is because we may be we waiting on the initialize 
    // event.  
    //
    
    CInCritSec ics(&m_csLevel1);

    if ( m_eState == e_Shutdown )
    {
        return WBEM_E_SHUTTING_DOWN;
    }

    if ( m_eState == e_Initialized )
    {
        return m_hresInit;
    }

    _DBG_ASSERT( m_eState == e_InitializePending );
    _DBG_ASSERT( m_hInitComplete != INVALID_HANDLE_VALUE )

    //
    // wait for initialization to complete.
    //
        
    LeaveCriticalSection( &m_csLevel1 );

    m_pEss->TriggerDeferredInitialization();

    DWORD dwRes = WaitForSingleObject( m_hInitComplete, 20*60*1000 );
    
    EnterCriticalSection( &m_csLevel1 );
    
    if ( dwRes != WAIT_OBJECT_0 )
    {
        return WBEM_E_CRITICAL_ERROR;
    }           

    return m_hresInit;
}

BOOL CEssNamespace::DoesThreadOwnNamespaceLock()
{
    return m_csLevel2.GetLockCount() != -1 &&
           m_csLevel2.GetOwningThreadId() == GetCurrentThreadId();
}

void CEssNamespace::LogOp( LPCWSTR wszOp, IWbemClassObject* pObj )
{
    if ( LoggingLevelEnabled(2) )
    {
        _DBG_ASSERT(pObj!=NULL);
        BSTR bstrText;
        if ( SUCCEEDED(pObj->GetObjectText( 0, &bstrText )) )
        {
            DEBUGTRACE((LOG_ESS,"%S in namespace %S. Object is %S\n",
                        wszOp, m_wszName, bstrText ));
            SysFreeString( bstrText );
        }
    }
}

CQueueingEventSink* CEssNamespace::GetQueueingEventSink( LPCWSTR wszSinkName )
{
    HRESULT hr;

    //
    // TODO: For now there is a 1 to 1 mapping between a sink and a consumer.
    // ( consumer inherits from queueing sink ).  This will not always be 
    // the case.  Here, the sink name is really the standard path to the cons.
    //

    CEventConsumer* pCons;

    hr = m_Bindings.FindEventConsumer( wszSinkName, &pCons );

    if ( FAILED(hr) )
    {
        return NULL;
    }

    return pCons;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
BOOL CEssNamespace::IsNeededOnStartup()
{
    return m_Bindings.DoesHavePermanentConsumers();
}

void CEssNamespace::SetActive()
{
    //
    // Inform ESS of our newely active status so that it can make sure 
    // we are reloaded the next time around
    //
    m_pEss->SetNamespaceActive(m_wszName);
}

void CEssNamespace::SetInactive()
{
    //
    // Inform ESS of our newely inactive status so that it does not have to
    // reload us the next time around
    //
    m_pEss->SetNamespaceInactive(m_wszName);
}

//
// This is a quick and dirty shutdown of the namespace that is used when the 
// process is shutting down.  
// 
HRESULT CEssNamespace::Park()
{
//    bool bSkipClean = true;
//
//    DWORD dwVal = 0;
//    Registry r(WBEM_REG_WINMGMT);
//    
//    if ( r.GetDWORDStr( _TEXT("Force Clean Shutdown"), &dwVal ) 
//           == Registry::no_error)
//    {
//        bSkipClean = false;
//    }
//
//    m_Bindings.Clear( bSkipClean );

    m_Bindings.Clear( false );

    FirePostponedOperations();

    return S_OK;
}
   
//
// This is the slow and clean shutdown that is used when the namespace is 
// purged.
//
HRESULT CEssNamespace::Shutdown()
{
    {
        //
        // we want to wait until all update operations have completed, then
        // we'll mark the namespace as shutdown.
        // 
        CInUpdate iu(this);

        //
        // we will also be modifying the level1 members too so need level1
        // lock.
        // 
        CInCritSec ics(&m_csLevel1);
        
        m_eState = e_Shutdown;
    }

    //
    // at this point all new calls into the namespace will be rejected.
    // 
    
    //
    // wake up any threads waiting for Initialization.
    //

    SetEvent( m_hInitComplete );

    InternalRemoveNotificationSink(&m_ClassDeletionSink);
        
    m_EventProviderCache.Shutdown();
    m_Bindings.Clear( false );
    m_Poller.Clear();
    m_ConsumerProviderCache.Clear();

    FirePostponedOperations();

    return WBEM_S_NO_ERROR;
}

CEssNamespace::~CEssNamespace()
{

//
//    Do not call shutdown here.  Shutdown() is an operation that incurrs 
//    postponed operations and triggering them to fire here is not usually
//    expected by the caller.  If the caller wants to call shutdown on their
//    own then they are welcome to do so.    
//
    g_lNumNamespaces--;

    delete [] m_wszName;

    if(m_pCoreSvc)
        m_pCoreSvc->Release();

    if(m_pFullSvc)
        m_pFullSvc->Release();

    if(m_pInternalCoreSvc)
        m_pInternalCoreSvc->Release();

    if(m_pInternalFullSvc)
        m_pInternalFullSvc->Release();

    if(m_pProviderFactory)
        m_pProviderFactory->Release();

    if(m_pCoreEventProvider)
        m_pCoreEventProvider->Release();
    
    if(m_pMonitorProvider)
        m_pMonitorProvider->Release();

    if ( m_hInitComplete != INVALID_HANDLE_VALUE )
        CloseHandle( m_hInitComplete );

    for( int i=0; i < m_aDeferredEvents.GetSize(); i++ )
        delete m_aDeferredEvents[i];
}

HRESULT CEssNamespace::GetNamespacePointer(
                                RELEASE_ME IWbemServices** ppNamespace)
{
    //
    // This function returns the full svc pointer for use outside this class.
    // We want to ensure that we don't use the full service ptr until we've 
    // completed stage 1 initialization.  Reason is that we don't want to 
    // load class providers until the second stage of initialization.
    //

    _DBG_ASSERT( m_bStage1Complete );

    if(m_pFullSvc == NULL)
        return WBEM_E_CRITICAL_ERROR;

    *ppNamespace = m_pFullSvc;
    (*ppNamespace)->AddRef();

    return S_OK;
}

HRESULT CEssNamespace::ActOnSystemEvent(CEventRepresentation& Event, 
                                        long lFlags)
{
    HRESULT hres;

// This macro will execute its parameter if updates are allowed at this time on
// this thread, and schedule it otherwise (in the case of an event provider 
// calling back
#define PERFORM_IF_ALLOWED(OP) OP
        
    // Check the type
    // ==============

    if(Event.IsInstanceEvent())
    {
        // Instance creation, deletion or modification event. Check class
        // ==============================================================

        if(!wbem_wcsicmp(CLASS_OF(Event), EVENT_FILTER_CLASS))
        {
            return PERFORM_IF_ALLOWED(ReloadEventFilter(OBJECT_OF(Event)));
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), BINDING_CLASS))
        {
            return PERFORM_IF_ALLOWED(ReloadBinding(OBJECT_OF(Event)));
        }
#ifdef __WHISTLER_UNCUT
        else if(!wbem_wcsicmp(CLASS_OF(Event), MONITOR_CLASS))
        {
            return PERFORM_IF_ALLOWED(ReloadMonitor(OBJECT_OF(Event)));
        }
#endif
        else if(!wbem_wcsicmp(CLASS_OF(Event), 
                              EVENT_PROVIDER_REGISTRATION_CLASS))
        {
            return PERFORM_IF_ALLOWED(
                        ReloadEventProviderRegistration(OBJECT_OF(Event)));
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), 
                              CONSUMER_PROVIDER_REGISTRATION_CLASS))
        {
            return PERFORM_IF_ALLOWED(
                        ReloadConsumerProviderRegistration(OBJECT_OF(Event)));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(PROVIDER_CLASS) == S_OK)
        {
            return PERFORM_IF_ALLOWED(ReloadProvider(OBJECT_OF(Event)));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(CONSUMER_CLASS) == S_OK)
        {
            return PERFORM_IF_ALLOWED(ReloadEventConsumer(OBJECT_OF(Event), 
                                                            lFlags));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(TIMER_BASE_CLASS) == S_OK)
        {
           return PERFORM_IF_ALLOWED(ReloadTimerInstruction(OBJECT_OF(Event)));
        }
        else
        {
            return WBEM_S_FALSE;
        }
    }
    else if(Event.type == e_EventTypeClassDeletion)
    {
        //
        // For now --- only for deletions.  Force-mode modifications are not
        // properly handled at the moment.
        //

        return PERFORM_IF_ALLOWED(
                    HandleClassChange(CLASS_OF(Event), OBJECT_OF(Event)));
    }
    else if(Event.type == e_EventTypeClassCreation)
    {
        return PERFORM_IF_ALLOWED(
                    HandleClassCreation(CLASS_OF(Event), OBJECT_OF(Event)));
    }
    else if(Event.type == e_EventTypeNamespaceDeletion)
    {
        // Construct full namespace name (ours + child)
        // ============================================

        LPWSTR wszFullName = new WCHAR[
            wcslen(m_wszName) + wcslen(Event.wsz2) + 2];

        if(wszFullName == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CVectorDeleteMe<WCHAR> vdm( wszFullName );
            
        swprintf(wszFullName, L"%s\\%s", m_wszName, Event.wsz2);

        // Get the main object to purge that namespace
        // ===========================================

        return m_pEss->PurgeNamespace(wszFullName);
    }
    else
    {
        // Not of interest
        // ===============

        return WBEM_S_FALSE;
    }
}

HRESULT CEssNamespace::ValidateSystemEvent(CEventRepresentation& Event)
{
    HRESULT hr;

    // Check the type
    // ==============

    if(Event.IsInstanceEvent())
    {
        IWbemClassObject* pPrevObj = NULL;
        IWbemClassObject* pObj = NULL;
        if(Event.type == e_EventTypeInstanceCreation)
            pObj = OBJECT_OF(Event);
        else if(Event.type == e_EventTypeInstanceDeletion)
            pPrevObj = OBJECT_OF(Event);
        else if(Event.type == e_EventTypeInstanceModification)
        {
            pObj = OBJECT_OF(Event);
            pPrevObj = OTHER_OBJECT_OF(Event);
        }

        // Instance creation, deletion or modification event. Check class
        // ==============================================================

        if(!wbem_wcsicmp(CLASS_OF(Event), EVENT_FILTER_CLASS))
        {
            hr = CheckEventFilter(pPrevObj, pObj);
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), BINDING_CLASS))
        {
            hr = CheckBinding(pPrevObj, pObj);
        }
        else if(!wbem_wcsicmp(CLASS_OF(Event), 
                                             EVENT_PROVIDER_REGISTRATION_CLASS))
        {
            hr = CheckEventProviderRegistration(OBJECT_OF(Event));
        }
        else if(OBJECT_OF(Event)->InheritsFrom(CONSUMER_CLASS) == S_OK)
        {
            hr = CheckEventConsumer(pPrevObj, pObj);
        }
        else if(OBJECT_OF(Event)->InheritsFrom(TIMER_BASE_CLASS) == S_OK)
        {
            hr = CheckTimerInstruction(pObj);
        }
        else
        {
            hr = WBEM_S_FALSE;
        }

        //
        // even some of the validation routines use postponed operations.
        //
        FirePostponedOperations();
    }
    else
    {
        // Not of interest
        // ===============

        hr = WBEM_S_FALSE;
    }

    return hr;
}

HRESULT CEssNamespace::CheckEventConsumer(IWbemClassObject* pPrevConsumerObj,
                                            IWbemClassObject* pConsumerObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    hres = CheckSecurity(pPrevConsumerObj, pConsumerObj);
    return hres;
}

PSID CEssNamespace::GetSidFromObject(IWbemClassObject* pObj)
{
    HRESULT hres;

    VARIANT vSid;
    VariantInit(&vSid);
    CClearMe cm1(&vSid);

    hres = pObj->Get(OWNER_SID_PROPNAME, 0, &vSid, NULL, NULL);
    if(FAILED(hres) || V_VT(&vSid) != (VT_UI1 | VT_ARRAY))
    {
        return NULL;
    }

    // Construct an actual PSID from the SAFEARRAY
    // ===========================================

    PSID pOriginal = NULL;

    hres = SafeArrayAccessData(V_ARRAY(&vSid), (void**)&pOriginal);
    if(FAILED(hres))
    {
        return NULL;
    }

    CUnaccessMe uam(V_ARRAY(&vSid));

    long cOriginal;
    if ( FAILED(SafeArrayGetUBound( V_ARRAY(&vSid), 1, &cOriginal ) ))
    {
        return NULL;
    }

    cOriginal++; // SafeArrayGetUBound() is -1 based

    //
    // validate SID.
    // 

    DWORD dwSidLength = GetLengthSid(pOriginal);

    if ( dwSidLength > cOriginal || !IsValidSid(pOriginal) )
    {
        return NULL;
    }

    // Make a copy and return it
    // =========================

    PSID pCopy = (PSID)new BYTE[dwSidLength];
    if(pCopy == NULL)
        return NULL;

    if(!CopySid(dwSidLength, pCopy, pOriginal))
    {
        delete [] (BYTE*)pCopy;
        return NULL;
    }

    return pCopy;
}

    
    


HRESULT CEssNamespace::CheckSecurity(IWbemClassObject* pPrevObj,
                                        IWbemClassObject* pObj)
{
    HRESULT hres;

    if(!IsNT())
        return WBEM_S_NO_ERROR;

    // Retrieve the SID of the calling user
    // ====================================

    hres = WbemCoImpersonateClient();
    if(FAILED(hres))
        return hres;

    CNtSid Sid;
    hres = CDerivedObjectSecurity::RetrieveSidFromCall(&Sid);
    WbemCoRevertToSelf();
    if(FAILED(hres))
        return hres;

    // If modifying an existing object, check override security
    // ========================================================

    if(pPrevObj)
    {
        hres = CheckOverwriteSecurity(pPrevObj, Sid);
        if(FAILED(hres))
            return hres;
    }

    // If creating a new version of an object, ensure Sid correctness
    // ==============================================================

    if(pObj)
    {
        hres = EnsureSessionSid(pObj, Sid);
        if(FAILED(hres))
            return hres;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::EnsureSessionSid(IWbemClassObject* pObj, CNtSid& Sid)
{
    HRESULT hres;

    //
    // Check for the special case of administrators --- they can use the
    // Administrators SID instead of their own for off-line operations.
    //

    hres = IsCallerAdministrator();
    if(FAILED(hres) && hres != WBEM_E_ACCESS_DENIED)
        return hres;

    if(SUCCEEDED(hres))
    {
        //
        // This is an admin --- check if there is a SID in the object already
        //

        PSID pOldSid = GetSidFromObject(pObj);
        if(pOldSid == NULL)
        {
            //
            // No SID --- just put an owner SID in there
            //

            return PutSidInObject(pObj, Sid);
        }
        else
        {
            CVectorDeleteMe<BYTE> vdm((BYTE*)pOldSid);

            //
            // There is a SID there already --- the only allowed ones are the
            // user himself or the Administrators.  Make sure it is one of those
            //

            if(!EqualSid(pOldSid, Sid.GetPtr()) &&
                !EqualSid(pOldSid, GetAdministratorsSid().GetPtr()))
            {
                //
                // Invalid SID found --- replace with the owner SID
                //

                return PutSidInObject(pObj, Sid);
            }

            //
            // Valid SID found --- leave it there
            //

            return WBEM_S_NO_ERROR;
        }
    }

    //
    // User not an administrator --- just stick his SID into the object
    //

    return PutSidInObject(pObj, Sid);
}
            
HRESULT CEssNamespace::PutSidInObject(IWbemClassObject* pObj, CNtSid& Sid)
{
    HRESULT hres;

    //
    // Clear it first
    //

    VARIANT vSid;
    VariantInit(&vSid);
    V_VT(&vSid) = VT_NULL;
    CClearMe cm1(&vSid);

    hres = pObj->Put(OWNER_SID_PROPNAME, 0, &vSid, 0);
    if(FAILED(hres))
        return hres;

    //
    // Construct a safearray for it
    //

    V_VT(&vSid) = VT_ARRAY | VT_UI1;
    SAFEARRAYBOUND sab;
    sab.cElements = Sid.GetSize();
    sab.lLbound = 0;
    V_ARRAY(&vSid) = SafeArrayCreate(VT_UI1, 1, &sab);
    if(V_ARRAY(&vSid) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Copy the SID in there
    // =====================

    BYTE* abSid = NULL;
    hres = SafeArrayAccessData(V_ARRAY(&vSid), (void**)&abSid);
    if(FAILED(hres))
        return WBEM_E_OUT_OF_MEMORY;
    CUnaccessMe uam(V_ARRAY(&vSid));
    if(!CopySid(Sid.GetSize(), (PSID)abSid, Sid.GetPtr()))
        return WBEM_E_OUT_OF_MEMORY;

    // Put it into the consumer
    // ========================

    hres = pObj->Put(OWNER_SID_PROPNAME, 0, &vSid, 0);
    return hres;
}

HRESULT CEssNamespace::CheckOverwriteSecurity(IWbemClassObject* pPrevObj,
                                                CNtSid& ActingSid)
{
    HRESULT hres;

    if(!IsNT())
        return WBEM_S_NO_ERROR;

    // Retrieve owner SID from the old object
    // ======================================

    PSID pOwnerSid = GetSidFromObject(pPrevObj);
    if(pOwnerSid == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CVectorDeleteMe<BYTE> vdm((BYTE*)pOwnerSid);

    // Compare the owner sid with the acting SID.  If same, allow access
    // =================================================================

    if(EqualSid(pOwnerSid, ActingSid.GetPtr()))
        return WBEM_S_NO_ERROR;

    // Not the same --- still hope that the acting SID is an Admin
    // ===========================================================

    hres = IsCallerAdministrator();
    if(FAILED(hres))
        return hres;

    //
    // OK --- an admin can overwrite
    //

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::IsCallerAdministrator()
{
    HRESULT hres;

    hres = WbemCoImpersonateClient();
    if(FAILED(hres))
        return hres;

    HANDLE hToken;
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken))
        return WBEM_E_FAILED;
    CCloseMe ccm(hToken);
    
    if(CNtSecurity::IsUserInGroup(hToken, GetAdministratorsSid()))
        return WBEM_S_NO_ERROR;

    return WBEM_E_ACCESS_DENIED;
}

HRESULT CEssNamespace::CheckEventFilter(IWbemClassObject* pOldFilterObj,
                                        IWbemClassObject* pFilterObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    // Check security
    // ==============

    hres = CheckSecurity(pOldFilterObj, pFilterObj);
    if(FAILED(hres))
        return hres;

    // Check everything else
    // =====================

    return CPermanentFilter::CheckValidity(pFilterObj);
}

HRESULT CEssNamespace::ReloadEventFilter(IWbemClassObject* pFilterObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadEventFilter", pFilterObjTemplate );  

    ENSURE_INITIALIZED

    // Start by deleting this event filter from our records, if there
    // ==============================================================

    hres = RemoveEventFilter(pFilterObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this filter in the database
    // ==========================================================

    IWbemClassObject* pFilterObj = NULL;
    hres = GetCurrentState(pFilterObjTemplate, &pFilterObj);
    if(FAILED(hres))
        return hres;

    if(pFilterObj == NULL)
    {
        // The filter has been deleted --- no further action is needed
        // ===========================================================

        return S_OK;
    }

    CReleaseMe rm1(pFilterObj);

    // Now create it if necessary
    // ==========================

    hres = AddEventFilter(pFilterObj);
    if(FAILED(hres))
        return hres;

    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked and the filter deleted from the records,
//  AddEventFilter updates the records to the state of this filter in the
//  database.
// 
//******************************************************************************
HRESULT CEssNamespace::AddEventFilter(IWbemClassObject* pFilterObj,
                                        BOOL bInRestart)
{
    HRESULT hres;

    // Construct the new filter
    // ========================

    CPermanentFilter* pFilter = new CPermanentFilter(this);
    if(pFilter == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pFilter->AddRef();
    CReleaseMe rm2(pFilter);

    // Initialize it
    // =============

    hres = pFilter->Initialize(pFilterObj);
    if(FAILED(hres))
        return hres;

    // Add it to the table
    // ===================

    hres = m_Bindings.AddEventFilter(pFilter);
    if(FAILED(hres))
        return hres;

    if(!bInRestart)
    {
        // Process all the bindings that this filter might have
        // ====================================================
    
        hres = AssertBindings(pFilterObj);
        if(FAILED(hres))
            return hres;
    }

    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked, RemoveEventFilter updates the records 
//  to remove all mention of this filter. Note: this is *not* the function to be
//  called in response to the database instance-deletion event, as the filter 
//  could have been recreated in the interim.
// 
//******************************************************************************
HRESULT CEssNamespace::RemoveEventFilter(IWbemClassObject* pFilterObj)
{
    HRESULT hres;

    // Calculate the key for this filter
    // =================================

    BSTR strKey = CPermanentFilter::ComputeKeyFromObj(pFilterObj);
    if(strKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strKey);

    // Remove it from the table, thus deactivating it
    // ==============================================

    hres = m_Bindings.RemoveEventFilter(strKey);
    if(hres == WBEM_E_NOT_FOUND)
        return S_FALSE;
    return hres;
}

//*****************************************************************************
//
//  Called in response to an instance operation event related to an event 
//  consumer object.
//
//*****************************************************************************
HRESULT CEssNamespace::ReloadEventConsumer(
                        IWbemClassObject* pConsumerObjTemplate,
                        long lFlags)
{
    HRESULT hres;

    LogOp( L"ReloadConsumer", pConsumerObjTemplate );  

    ENSURE_INITIALIZED

    // Start by deleting this event consumer from our records, if there
    // ================================================================

    hres = RemoveEventConsumer(pConsumerObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this Consumer in the database
    // ============================================================

    IWbemClassObject* pConsumerObj = NULL;
    hres = GetCurrentState(pConsumerObjTemplate, &pConsumerObj);
    if(FAILED(hres))
        return hres;

    if(pConsumerObj == NULL)
    {
        // The Consumer has been deleted --- no further action is needed
        // =============================================================

        return S_OK;
    }

    CReleaseMe rm1(pConsumerObj);

    // Now create it if necessary
    // ==========================

    hres = AddEventConsumer(pConsumerObjTemplate, lFlags, FALSE);
    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked and the consumer deleted from the records
//  AddEventConsumer updates the records to the state of this consumer in the
//  database.
// 
//******************************************************************************
HRESULT CEssNamespace::AddEventConsumer(IWbemClassObject* pConsumerObj,
                                        long lFlags,
                                        BOOL bInRestart)
{
    HRESULT hres;

    // Construct the new Consumer
    // ==========================

    CPermanentConsumer* pConsumer = new CPermanentConsumer(this);
    if(pConsumer == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pConsumer->AddRef();
    CReleaseMe rm2(pConsumer);

    // Initialize it
    // =============

    hres = pConsumer->Initialize(pConsumerObj);
    if(FAILED(hres))
        return hres;

    //
    // Validate if required
    //

    if(lFlags & WBEM_FLAG_STRONG_VALIDATION)
    {
        hres = pConsumer->Validate(pConsumerObj);
        if(FAILED(hres))
        {
            return hres;
        }
    }
        

    // Add it to the table
    // ===================

    hres = m_Bindings.AddEventConsumer(pConsumer);
    if(FAILED(hres))
        return hres;

    if(!bInRestart)
    {
        // Process all the bindings that this consumer might have
        // ======================================================
    
        hres = AssertBindings(pConsumerObj);
        if(FAILED(hres))
            return hres;
    }

    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked, RemoveEventConsumer updates the records 
//  to remove all mention of this consumer. 
// 
//******************************************************************************
HRESULT CEssNamespace::RemoveEventConsumer(IWbemClassObject* pConsumerObj)
{
    HRESULT hres;

    // Calculate the key for this filter
    // =================================

    BSTR strKey = CPermanentConsumer::ComputeKeyFromObj(this, pConsumerObj);
    if(strKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strKey);

    // Remove it from the table
    // ========================

    hres = m_Bindings.RemoveEventConsumer(strKey);
    if(hres == WBEM_E_NOT_FOUND)
        return S_FALSE;
    return hres;
}

HRESULT CEssNamespace::CheckBinding(IWbemClassObject* pPrevBindingObj, 
                                    IWbemClassObject* pBindingObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    //
    // Check security
    //

    hres = CheckSecurity(pPrevBindingObj, pBindingObj);
    if(FAILED(hres))
        return hres;

    //
    // Construct a fake binding to test correctness
    //

    CPermanentBinding* pBinding = new CPermanentBinding;
    if(pBinding == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pBinding->AddRef();
    CTemplateReleaseMe<CPermanentBinding> trm(pBinding);

    hres = pBinding->Initialize(pBindingObj);
    if(FAILED(hres))
        return hres;

    return S_OK;
}
    
//******************************************************************************
//
//  Called in response to an instance operation event related to a binding
//  instance.
//
//******************************************************************************

HRESULT CEssNamespace::ReloadBinding(IWbemClassObject* pBindingObjTemplate)
{
    HRESULT hres;
    
    LogOp( L"ReloadBinding", pBindingObjTemplate );  

    ENSURE_INITIALIZED

    // Retrieve consumer and provider keys from the binding
    // ====================================================

    BSTR strPrelimConsumerKey = NULL;
    BSTR strFilterKey = NULL;
    hres = CPermanentBinding::ComputeKeysFromObject(pBindingObjTemplate, 
                &strPrelimConsumerKey, &strFilterKey);
    if(FAILED(hres))
        return hres;

    CSysFreeMe sfm1(strPrelimConsumerKey);
    CSysFreeMe sfm2(strFilterKey);

    // Get real paths from these possibly abbreviated ones
    // ===================================================

    BSTR strConsumerKey = NULL;

    hres = m_pInternalCoreSvc->GetNormalizedPath( strPrelimConsumerKey, 
                                                  &strConsumerKey);
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm3(strConsumerKey);
    
    // Start by deleting this binding from our records, if there
    // =========================================================

    hres = RemoveBinding(strFilterKey, strConsumerKey);
    if(FAILED(hres) && hres != WBEM_E_NOT_FOUND)
        return hres;

    // Determine the current state of this binding in the database
    // ============================================================

    IWbemClassObject* pBindingObj = NULL;
    hres = GetCurrentState(pBindingObjTemplate, &pBindingObj);
    if(FAILED(hres))
        return hres;

    if(pBindingObj == NULL)
    {
        // The Binding has been deleted --- no further action is needed
        // =============================================================

        return S_OK;
    }

    CReleaseMe rm1(pBindingObj);

    // Now create it if necessary
    // ==========================

    hres = AddBinding(strFilterKey, strConsumerKey, pBindingObjTemplate);
    return hres;
}

HRESULT CEssNamespace::AddBinding(IWbemClassObject* pBindingObj)
{
    HRESULT hres;

    // Retrieve consumer and provider keys from the binding
    // ====================================================

    BSTR strPrelimConsumerKey = NULL;
    BSTR strFilterKey = NULL;
    hres = CPermanentBinding::ComputeKeysFromObject(pBindingObj, 
                &strPrelimConsumerKey, &strFilterKey);
    if(FAILED(hres))
        return hres;

    CSysFreeMe sfm1(strPrelimConsumerKey);
    CSysFreeMe sfm2(strFilterKey);

    // Get real paths from these possibly abbreviated ones
    // ===================================================

    BSTR strConsumerKey = NULL;

    hres = m_pInternalCoreSvc->GetNormalizedPath( strPrelimConsumerKey, 
                                                  &strConsumerKey );
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm3(strConsumerKey);

    return AddBinding(strFilterKey, strConsumerKey, pBindingObj);
}


HRESULT CEssNamespace::AddBinding(LPCWSTR wszFilterKey, LPCWSTR wszConsumerKey,
                                    IWbemClassObject* pBindingObj)
{
    HRESULT hres;

    // Create a new binding
    // ====================

    CPermanentBinding* pBinding = new CPermanentBinding;
    if(pBinding == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pBinding->AddRef();
    CReleaseMe rm1(pBinding);

    // Initialize it with the information we have
    // ==========================================

    hres = pBinding->Initialize(pBindingObj);
    if(FAILED(hres))
        return hres;

    // Extract its creator's SID
    // ========================

    PSID pSid = CPermanentBinding::GetSidFromObject(pBindingObj);
    
    if ( pSid == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = m_Bindings.Bind( wszFilterKey, wszConsumerKey, pBinding, pSid );
    
    delete [] pSid;

    return hres;
}

HRESULT CEssNamespace::RemoveBinding(LPCWSTR wszFilterKey, 
                                        LPCWSTR wszConsumerKey)
{
    HRESULT hres;
    hres = m_Bindings.Unbind(wszFilterKey, wszConsumerKey);
    if(hres == WBEM_E_NOT_FOUND)
        return S_FALSE;
    return hres;
}


    
//******************************************************************************
//
//  Reads all the bindings referencing a given objects from the database and
//  asserts them.
//
//******************************************************************************
class CAssertBindingsSink : public CObjectSink
{
protected:
    CEssNamespace* m_pNamespace;
public:
    CAssertBindingsSink(CEssNamespace* pNamespace) : m_pNamespace(pNamespace)
    {
        AddRef();
    }
    STDMETHOD(Indicate)(long lNumObjects, IWbemClassObject** apObjects)
    {
        for(long i = 0; i < lNumObjects; i++)
        {
            m_pNamespace->AddBinding(apObjects[i]);
        }
        return S_OK;
    }
};


HRESULT CEssNamespace::AssertBindings(IWbemClassObject* pEndpoint)
{
    // Get the relative path of the endpoint
    // =====================================

    VARIANT vRelPath;
    VariantInit(&vRelPath);
    CClearMe cm1(&vRelPath);
    HRESULT hres = pEndpoint->Get(L"__RELPATH", 0, &vRelPath, NULL, NULL);
    if(FAILED(hres)) 
        return hres;
    if(V_VT(&vRelPath) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    BSTR strRelPath = V_BSTR(&vRelPath);

    // Issue the query
    // ===============

    BSTR strQuery = SysAllocStringLen(NULL, 200 + wcslen(strRelPath));
    if(strQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strQuery);

    swprintf(strQuery, L"references of {%s} where "
                L"ResultClass = __FilterToConsumerBinding", strRelPath);

    CAssertBindingsSink Sink(this);
    hres = ExecQuery(strQuery, 0, &Sink);
    return hres;
}

HRESULT CEssNamespace::ReloadTimerInstruction(
                                    IWbemClassObject* pInstObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadTimerInstruction", pInstObjTemplate );  

    ENSURE_INITIALIZED

    hres = RemoveTimerInstruction(pInstObjTemplate);
    if(FAILED(hres))
        return hres;
    
    // Get the current version from the namespace
    // ==========================================

    IWbemClassObject* pInstObj = NULL;
    hres = GetCurrentState(pInstObjTemplate, &pInstObj);
    if(FAILED(hres))
        return hres;

    if(pInstObj == NULL)
    {
        // The instruction has been deleted --- no further action is needed
        // ================================================================

        return S_OK;
    }

    CReleaseMe rm1(pInstObj);

    // Add it to the generator
    // =======================

    hres = AddTimerInstruction(pInstObj);
    if(FAILED(hres))
        return hres;

    return hres;
}

HRESULT CEssNamespace::AddTimerInstruction(IWbemClassObject* pInstObj)
{
    return m_pEss->GetTimerGenerator().
        LoadTimerEventObject(m_wszName, pInstObj);
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEssNamespace::RemoveTimerInstruction(IWbemClassObject* pOldObject)
{
    HRESULT hres;

    VARIANT vID;
    VariantInit(&vID);
    hres = pOldObject->Get(TIMER_ID_PROPNAME, 0, &vID, NULL, NULL);
    if(FAILED(hres)) return hres;

    m_pEss->GetTimerGenerator().Remove(m_wszName, V_BSTR(&vID));
    VariantClear(&vID);
    return S_OK;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
#ifdef __WHISTLER_UNCUT
HRESULT CEssNamespace::CheckMonitor(IWbemClassObject* pOldMonitorObj,
                                        IWbemClassObject* pMonitorObj)
{
    HRESULT hres;

    ENSURE_INITIALIZED

    // Check security
    // ==============

    hres = CheckSecurity(pOldMonitorObj, pMonitorObj);
    if(FAILED(hres))
        return hres;

    // BUGBUG: any other checks?
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::ReloadMonitor(IWbemClassObject* pMonitorObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadMonitor", pMonitorObjTemplate );  

    ENSURE_INITIALIZED

    //
    // Start by deleting this monitor from our records, if there
    //

    hres = RemoveMonitor(pMonitorObjTemplate);
    if(FAILED(hres))
        return hres;

    //
    // Determine the current state of this monitor in the database
    //

    IWbemClassObject* pMonitorObj = NULL;
    hres = GetCurrentState(pMonitorObjTemplate, &pMonitorObj);
    if(FAILED(hres))
        return hres;

    if(pMonitorObj == NULL)
    {
        //
        // The monitor has been deleted --- no further action is needed
        //

        return S_OK;
    }

    CReleaseMe rm1(pMonitorObj);

    // Now create it if necessary
    // ==========================

    hres = AddMonitor(pMonitorObj);
    if(FAILED(hres))
        return hres;

    return hres;
}

//******************************************************************************
//
// 
//******************************************************************************
    
HRESULT CEssNamespace::AddMonitor(IWbemClassObject* pMonitorObj)
{
    HRESULT hres;

    if(m_pMonitorProvider == NULL)
        return WBEM_E_UNEXPECTED;

    //
    // Get the information from the monitor object
    //

    BSTR strKey, strQuery;
    long lFlags;
    hres = CMonitorProvider::GetMonitorInfo(pMonitorObj, &strKey,
                                            &strQuery, &lFlags);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "A monitor was could not be cracked "
                "in namespace '%S' as invalid: 0x%X\n", GetName(), hres));
        return hres;
    }
    
    CSysFreeMe sfm1(strKey);
    CSysFreeMe sfm2(strQuery);
                                
    //
    // Attempt to add the monitor to the monitor provider
    //

    hres = m_pMonitorProvider->AddMonitor(strKey, strQuery,
                                          lFlags, GetCurrentEssContext());
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Monitor '%S' at '%S' was rejected in "
                    "namespace '%S' with error code 0x%X\n", 
                    strQuery, strKey, GetName()));
        return hres;
    }
    
    return hres;
}

//******************************************************************************
//
//  Starting with the namespace locked, RemoveMonitor updates the records 
//  to remove all mention of this monitor. Note: this is *not* the function to 
//  be
//  called in response to the database instance-deletion event, as the monitor 
//  could have been recreated in the interim.
// 
//******************************************************************************
HRESULT CEssNamespace::RemoveMonitor(IWbemClassObject* pMonitorObj)
{
    HRESULT hres;

    if(m_pMonitorProvider == NULL)
    return WBEM_E_UNEXPECTED;

    //
    // Calculate the key form this monitor
    //

    BSTR strKey;
    hres = CMonitorProvider::GetMonitorInfo(pMonitorObj, &strKey,
                                            NULL, NULL);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "A monitor was could not be cracked "
                    "in namespace '%S' as invalid: 0x%X\n", GetName(), hres));
        return hres;
    }
    
    CSysFreeMe sfm1(strKey);

    //
    // Remove it from the provider
    // 

    hres = m_pMonitorProvider->RemoveMonitor(strKey, GetCurrentEssContext());
    if(hres == WBEM_E_NOT_FOUND)
    return S_FALSE;
    return hres;
}
#endif

HRESULT CEssNamespace::SignalEvent( READ_ONLY CEventRepresentation& Event,
                                   long lFlags )
{
    HRESULT hres;
    
    //
    // we cannot hold any turns in an exec line or hold the namespace lock
    // when calling this function.  This is because this function will 
    // aquire the proxy lock.  
    // 
    CPostponedList* pList;
    
    _DBG_ASSERT( !DoesThreadOwnNamespaceLock() );
    _DBG_ASSERT( !(pList=GetCurrentPostponedList()) || 
                 !pList->IsHoldingTurns() );

    // BUGBUG: need to propagate security context to this function ?

    CWbemPtr<CCoreEventProvider> pCoreEventProvider; 

    {
        //
        // we need to figure out if we need to deffer the event or signal it.
        // we deffer events when we are in the init pending or init state.
        // 

        CInCritSec ics( &m_csLevel1 );

        if ( m_eState == e_Initialized )
        {
            pCoreEventProvider = m_pCoreEventProvider;
        }
        else if ( m_eState == e_InitializePending )
        {
            //
            // Copy and add to defferred list. 
            // 
            
            CEventRepresentation* pEvRep = Event.MakePermanentCopy();
            
            if ( pEvRep == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            
            if ( m_aDeferredEvents.Add( pEvRep ) < 0 )
            {
                delete pEvRep;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    if ( pCoreEventProvider != NULL )
    {
        CEventContext Context;
        hres = pCoreEventProvider->Fire( Event, &Context );
        
        if(FAILED(hres))
        {
            return hres;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See ess.h for documentation
//
//******************************************************************************
HRESULT CEssNamespace::ProcessEvent(READ_ONLY CEventRepresentation& Event,
                                    long lFlags)
{
    // Ignore internal operations
    // ==========================

    if(Event.wsz2 != NULL && 
       (!wbem_wcsicmp(Event.wsz2, L"__TimerNextFiring") ||
        !wbem_wcsicmp(Event.wsz2, L"__ListOfEventActiveNamespaces")))
    {
        return WBEM_S_NO_ERROR;
    }

    HRESULT hres, hresReturn = WBEM_S_NO_ERROR;

    // Analyze it for system changes
    // =============================

    hres = ActOnSystemEvent(Event, lFlags);
    
    if(FAILED(hres))
    {
        //
        // Check if this operation needs to be failed if invalid
        //

        if( lFlags & WBEM_FLAG_STRONG_VALIDATION )
        {
            hresReturn = hres;
        }
        else
        {
            ERRORTRACE((LOG_ESS, "Event subsystem was unable to perform the "
                        "necessary operations to accomodate a change to the system "
                        "state.\nThe state of the database may not reflect the state "
                        "of the event subsystem (%X)\n", hres));
        }
    }

    // Fire postponed operations
    // =========================

    hres = FirePostponedOperations();

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS,"Event subsystem was unable to perform the (post) "
                    "necessary operations to accomodate a change to the system state.\n"
                    "The state of the database may not reflect the state of the event "
                    "subsystem (%X)\n", hres));
    }

    // Deliver it to consumers
    // =======================

    hres = SignalEvent( Event, lFlags );

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Event subsystem was unable to deliver a "
                    "repository intrinsic event to some consumers (%X)\n", hres));
    }

    return hresReturn;
}


HRESULT CEssNamespace::ProcessQueryObjectSinkEvent( READ_ONLY CEventRepresentation& Event )
{
    HRESULT hres = S_FALSE;

    CRefedPointerArray< CEventFilter > apEventFilters;
    
    if ( m_Bindings.GetEventFilters( apEventFilters ) )
    {
        if ( apEventFilters.GetSize( ) > 0 )
        {
            //
            // Convert to real event
            // 

            IWbemClassObject* pEvent;

            HRESULT hr = Event.MakeWbemObject( this, &pEvent );

            if( FAILED( hr ) )
            {
                return hr;
            }

            CReleaseMe rm1( pEvent );

            //
            // Fire all matching filters
            //

            for( int i = 0; i < apEventFilters.GetSize( ); ++i )
            {
                CEventContext Context;

                CEventFilter* pEventFilter = apEventFilters[i];
                hr = pEventFilter->Indicate( 1, &pEvent, &Context );

                if ( FAILED( hr ) )
                {
                    return hr;
                }

                //
                // Return S_FALSE if all of the Indicates returns S_FALSE
                //

                if ( S_FALSE != hr )
                {
                    hres = S_OK;
                }
            }
        }
    }
    else
    {
        return E_FAIL;
    }

    return hres;
}



HRESULT CEssNamespace::RegisterNotificationSink( WBEM_CWSTR wszQueryLanguage, 
                                                 WBEM_CWSTR wszQuery, 
                                                 long lFlags, 
                                                 WMIMSG_QOS_FLAG lQosFlags, 
                                                 IWbemContext* pContext, 
                                                 IWbemObjectSink* pSink )
{
    HRESULT hres;

    //
    // Report the MSFT_WmiRegisterNotificationSink event.
    //
    FIRE_NCEVENT( g_hNCEvents[MSFT_WmiRegisterNotificationSink], 
                  WMI_SENDCOMMIT_SET_NOT_REQUIRED,
                 
                  // Data follows...
                  (LPCWSTR) m_wszName,
                  wszQueryLanguage,
                  wszQuery,
                  (DWORD64) pSink);

    DEBUGTRACE((LOG_ESS,"Registering notification sink with query %S in "
                "namespace %S.\n", wszQuery, m_wszName ));

    {
            
        ENSURE_INITIALIZED

        hres = InternalRegisterNotificationSink( wszQueryLanguage, 
                                                 wszQuery,
                                                 lFlags, 
                                                 lQosFlags,
                                                 pContext, 
                                                 pSink,
                                                 FALSE,
                                                 NULL );
    }

    if(FAILED(hres))
    {
        // Clean up and return
        FirePostponedOperations();
        return hres;
    }

    // Filter and consumer are in place --- fire external operations
    // =============================================================

    hres = FirePostponedOperations();

    if(FAILED(hres))
    {
        {
            CInUpdate iu(this);

            InternalRemoveNotificationSink( pSink );     
        }

        //
        // need to make sure that we fire postponed here too. Remember that 
        // we cannot hold the namespace lock when firing postponed ops.
        //

        FirePostponedOperations();
    }
    else
    {
        InterlockedIncrement(&g_lNumTempSubscriptions);
    }
    
    return hres;
}

HRESULT CEssNamespace::InternalRegisterNotificationSink(
                                                 WBEM_CWSTR wszQueryLanguage, 
                                                 WBEM_CWSTR wszQuery, 
                                                 long lFlags, 
                                                 WMIMSG_QOS_FLAG lQosFlags,
                                                 IWbemContext* pContext, 
                                                 IWbemObjectSink* pSink,
                                                 bool bInternal,
                                                 PSID pOwnerSid )
{
    HRESULT hres;

    if(wbem_wcsicmp(wszQueryLanguage, L"WQL"))
        return WBEM_E_INVALID_QUERY_TYPE;

    LPWSTR wszConsumerKey = NULL;
    CVectorDeleteMe<WCHAR> vdm2(&wszConsumerKey);
    wszConsumerKey = CTempConsumer::ComputeKeyFromSink(pSink);
    if ( NULL == wszConsumerKey )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    bool bInterNamespace = pOwnerSid != NULL;

#ifdef __WHISTLER_UNCUT
    //
    // Check if this is a monitoring request
    //

    if(lFlags & WBEM_FLAG_MONITOR)
    {
        if(m_pMonitorProvider == NULL)
            return WBEM_E_NOT_SUPPORTED;

        //
        // Issue a subscription for anything eminating from the monitor we are
        // about to create.  We are going to use the consumer key as the key
        // for the monitor --- this means that ONE CANNOT issue more than one
        // monitor against the same sink!
        //

        WCHAR* wszNewQuery = new WCHAR[wcslen(wszConsumerKey) + 200];

        if ( wszNewQuery == NULL )
        {
            return WBEM_E_OUT_MEMORY;
        }

        CVectorDeleteMe<WCHAR> vdm1(wszNewQuery);
        swprintf(wszNewQuery, L"select * from "MONITOR_BASE_EVENT_CLASS 
                 L" where "MONITORNAME_EVENT_PROPNAME L" = \"%s\"", 
                 wszConsumerKey);
        hres = InternalRegisterNotificationSink(L"WQL", wszNewQuery, 
                                                lFlags & ~WBEM_FLAG_MONITOR, lQosFlags, pContext, pSink, NULL);
        if(FAILED(hres))
            return hres;

        // 
        // Construct the new monitor
        //

        hres = m_pMonitorProvider->AddMonitor(wszConsumerKey, wszQuery, 
                                              lFlags, pContext);
        if(FAILED(hres))
            return hres;

        return WBEM_S_NO_ERROR;
    }

    //
    // Normal subscription
    //
#endif

    LPWSTR wszFilterKey = NULL;
    CVectorDeleteMe<WCHAR> vdm1(&wszFilterKey);

    {    
        // Create a new temporary filter and add it to the binding table
        // =============================================================

        CTempFilter* pFilter = new CTempFilter(this);
        if(pFilter == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        hres = pFilter->Initialize( wszQueryLanguage, 
                                    wszQuery, 
                                    lFlags, 
                                    pOwnerSid,
                                    bInternal,
                                    pContext,
                                    pSink );
        if(FAILED(hres))
        {
            delete pFilter;
            return hres;
        }
        
        hres = m_Bindings.AddEventFilter(pFilter);
        if(FAILED(hres))
        {
            delete pFilter;
            return hres;
        }
        
        wszFilterKey = pFilter->GetKey().CreateLPWSTRCopy();
        if(wszFilterKey == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        // Check if this sink has already been used by looking for it in the
        // binding table
        // =================================================================

        CTempConsumer* pConsumer = NULL;
        if(FAILED(m_Bindings.FindEventConsumer(wszConsumerKey, NULL)))
        {
            // Create a new temporary consumer and add it to the table
            // =======================================================

            pConsumer = _new CTempConsumer(this);
            if(pConsumer == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            hres = pConsumer->Initialize( bInterNamespace, pSink);
            if(FAILED(hres))
                return hres;

            hres = m_Bindings.AddEventConsumer(pConsumer);
            if(FAILED(hres))
            {
                // Undo filter creation
                // ====================

                m_Bindings.RemoveEventFilter(wszFilterKey);
                return hres;
            }
        }
        
        // Bind them together
        // ==================

        CBinding* pBinding = new CTempBinding( lFlags, 
                                               lQosFlags,
                                               bInterNamespace );
        if(pBinding == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pBinding->AddRef();
        CReleaseMe rm1(pBinding);

        // 
        // SPAGETTI WARNING: From this point on, we must flush the postponed
        // operation cache, or we may leak memory.  But not before all the 
        // CReleaseMe calls have fired.
        //

        hres = m_Bindings.Bind(wszFilterKey, wszConsumerKey, pBinding, NULL);
        
        // Check that the filter is active --- otherwise activatioin must have
        // failed.
        // ===================================================================
        if(SUCCEEDED(hres) && !pFilter->IsActive())
            hres = pFilter->GetFilterError();

        if(FAILED(hres))
        {
            //
            // The core will deliver the SetStatus call to the consumer based
            // on the return code from the ESS.  Since we are failing, we should
            // not call SetStatus ourselves.
            //

            if(pConsumer)
            pConsumer->Shutdown(true); // quiet

            m_Bindings.RemoveEventFilter(wszFilterKey);
            m_Bindings.RemoveEventConsumer(wszConsumerKey);
        }
        else
        {
            InterlockedIncrement(&g_lNumInternalTempSubscriptions);    
        }
    }

    return hres;
}

HRESULT CEssNamespace::RemoveNotificationSink( IWbemObjectSink* pSink )
{
    // Fire a MSFT_WmiCancelNotificationSink if necessary.
    if (IS_NCEVENT_ACTIVE(MSFT_WmiCancelNotificationSink))
    {
        LPWSTR wszConsumerKey = CTempConsumer::ComputeKeyFromSink(pSink);
        
        if (wszConsumerKey != NULL)
        {
            CVectorDeleteMe<WCHAR> vdm0(wszConsumerKey);
            CInUpdate iu(this);

            // Find the consumer in question
            CEventConsumer *pConsumer = NULL;

            if (SUCCEEDED(m_Bindings.FindEventConsumer(wszConsumerKey, &pConsumer)))
            {
                CRefedPointerSmallArray<CEventFilter> 
                apFilters;
                CReleaseMe rm1(pConsumer);

                // Make addrefed copies of all its associated filters
                if (SUCCEEDED(pConsumer->GetAssociatedFilters(apFilters))
                    && apFilters.GetSize())
                {
                    int    nFilters = apFilters.GetSize();
                    LPWSTR wszQuery = NULL,
                    wszQueryLanguage = NULL;
                    BOOL   bExact;

                    apFilters[0]->
                    GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, NULL);

                    CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
                    CVectorDeleteMe<WCHAR> vdm2(wszQuery);

                    //
                    // Report the MSFT_WmiRegisterNotificationSink event.
                    //
                    FIRE_NCEVENT(
                                 g_hNCEvents[MSFT_WmiCancelNotificationSink], 
                                 WMI_SENDCOMMIT_SET_NOT_REQUIRED,

                                 // Data follows...
                                 (LPCWSTR) m_wszName,
                                 wszQueryLanguage,
                                 wszQuery,
                                 (DWORD64) pSink);
                }
            }
        }
    }

    HRESULT hres;

    {
        CInUpdate iu( this );

        hres = InternalRemoveNotificationSink( pSink );
    }

    FirePostponedOperations();

    if ( SUCCEEDED(hres) )
    {
        InterlockedDecrement( &g_lNumTempSubscriptions );
    }

    return hres;
}

HRESULT CEssNamespace::InternalRemoveNotificationSink(IWbemObjectSink* pSink)
{
    HRESULT hres;
    
    LPWSTR wszKey = CTempConsumer::ComputeKeyFromSink(pSink);
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm1(wszKey);

#ifdef __WHISTLER_UNCUT
    //
    // Remove any monitors that may be associated with it
    //

    if(m_pMonitorProvider)
        m_pMonitorProvider->RemoveMonitor(wszKey, GetCurrentEssContext());
#endif

    // Find the consumer container
    // ===========================

    hres = m_Bindings.RemoveConsumerWithFilters(wszKey);
    if(FAILED(hres))
        return hres;
    else
        InterlockedDecrement( &g_lNumInternalTempSubscriptions );
    
    return hres;
}


void CEssNamespace::FireNCFilterEvent(DWORD dwIndex, CEventFilter *pFilter)
{
    if (IS_NCEVENT_ACTIVE(dwIndex))
    {
        LPWSTR        wszQuery = NULL;
        LPWSTR        wszQueryLanguage = NULL;
        BOOL          bExact;
        CWbemPtr<CEssNamespace> pNamespace;
        
        GetFilterEventNamespace(pFilter, &pNamespace);

        // I'll assume we should use the current namespace if it's null.
        if (!pNamespace)
            pNamespace = this;

        pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, NULL);

        CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
        CVectorDeleteMe<WCHAR> vdm2(wszQuery);

        //
        // Report the event.
        //
        FIRE_NCEVENT(
                     g_hNCEvents[dwIndex], 
                     WMI_SENDCOMMIT_SET_NOT_REQUIRED,

                     // Data follows...
                     pNamespace ? (LPCWSTR) pNamespace->GetName() : NULL,
                     (LPCWSTR) (WString) pFilter->GetKey(),
                     wszQueryLanguage,
                     wszQuery);
    }
}

//*****************************************************************************
//
//  Called by the filter when it notices that it has consumers. The filter is
//  guaranteed to be either valid or temporarily invalid and not active. It is
//  guaranteed that no more than 1 activation/deactivation can occur on the 
//  same filter at the same time.
//
//*****************************************************************************
HRESULT CEssNamespace::ActivateFilter(READ_ONLY CEventFilter* pFilter)
{
    HRESULT hres, hresAttempt;

    hresAttempt = AttemptToActivateFilter(pFilter);

    if(FAILED(hresAttempt))
    {
        pFilter->MarkAsTemporarilyInvalid(hresAttempt);

        // 
        // We need to log an event about our inability to activate the filter
        // unless we shall report this failure to the caller.  We can only
        // report this to the caller if the filter is being created (not 
        // reactivated), and the caller is not using a force-mode
        //

        if(pFilter->DoesAllowInvalid() || pFilter->HasBeenValid())
        {
            LPWSTR wszQuery = NULL;
            LPWSTR wszQueryLanguage = NULL;
            BOOL bExact;
            
            hres = pFilter->GetCoveringQuery( wszQueryLanguage, 
                                              wszQuery, 
                                              bExact,
                                              NULL);
            if(FAILED(hres))
                return hres;
            
            CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
            CVectorDeleteMe<WCHAR> vdm2(wszQuery);

            //
            // Don't change this one: could be Nova customer dependencies
            //

            m_pEss->GetEventLog().Report( EVENTLOG_ERROR_TYPE, 
                                          WBEM_MC_CANNOT_ACTIVATE_FILTER,
                                          m_wszName, 
                                          wszQuery, 
                                          (CHex)hresAttempt );

            ERRORTRACE((LOG_ESS, "Could not activate filter %S in namespace "
                        "%S. HR=0x%x\n", wszQuery, m_wszName, hresAttempt ));
        }
    }
    else
    {
        //
        // Report the MSFT_WmiFilterActivated event.
        //
        FireNCFilterEvent(MSFT_WmiFilterActivated, pFilter);

        pFilter->MarkAsValid();
    }

    return hresAttempt;
}


//******************************************************************************
//
//  Worker for ActivateFilter --- does all the work but does not mark the filter
//  status
//
//******************************************************************************
HRESULT CEssNamespace::AttemptToActivateFilter(READ_ONLY CEventFilter* pFilter)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //
    // Get the query information from the filter
    // 

    LPWSTR wszQueryLanguage = NULL;
    LPWSTR wszQuery = NULL;
    BOOL bExact;

    QL_LEVEL_1_RPN_EXPRESSION* pExp = NULL;

    hres = pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery, bExact, &pExp);
    if(FAILED(hres))
    {
        WMIESS_REPORT((WMIESS_CANNOT_GET_FILTER_QUERY, m_wszName, pFilter));
        return hres;
    }

    CVectorDeleteMe<WCHAR> vdm1(wszQueryLanguage);
    CVectorDeleteMe<WCHAR> vdm2(wszQuery);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm1(pExp);

    if(!bExact)
    {
        //
        // We don't support inexact filter, nor do we have any now
        //
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // Check if the events are supposed to come from this namespace or some
    // other one.  Cross-namespace filters are all we are interested in the
    // initialize phase, since we're going to reprocess normal filters
    // after loading provider registrations ( In CompleteInitialization() )
    //

    CEssNamespace* pOtherNamespace = NULL;
    hres = GetFilterEventNamespace(pFilter, &pOtherNamespace);
    if(FAILED(hres))
        return hres;

    if( pOtherNamespace )
    {
        CTemplateReleaseMe<CEssNamespace> rm0(pOtherNamespace);

        if ( m_bInResync )
        {
            //
            // we don't need to do anything in the other namespace during 
            // resync of this one, so no work to do here.  Actually, since 
            // resync doesn't do a deactivate, the registration is still there
            // so be careful of double registration if removing this check.
            //

            return WBEM_S_FALSE;
        }

        DEBUGTRACE((LOG_ESS,"Activating cross-namespace filter %p with query "
                        "%S in namespace %S from namespace %S.\n", pFilter, 
                        wszQuery, pOtherNamespace->GetName(), m_wszName ));

        //
        // Register this notification sink with the other namespace, as 
        // if it were a temporary consumer.  Make the registration 
        // synchronous, as whatever asynchronicity we need will be 
        // provided by the ultimate consumer handling. This needs to be a 
        // postponed operation though, else we could have a deadlock 
        // scenario if at the same time cross namespace subscriptions 
        // were registered in both namespaces.
        //
        
        //
        // BUGBUG: security propagation
        //
        
        CPostponedRegisterNotificationSinkRequest* pReq;

        pReq = new CPostponedRegisterNotificationSinkRequest;

        if ( pReq == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        hres = pReq->SetRegistration( pOtherNamespace,
                                      wszQueryLanguage,
                                      wszQuery, 
                                      pFilter->GetForceFlags(), 
                                      WMIMSG_FLAG_QOS_SYNCHRONOUS,
                                      pFilter->GetNonFilteringSink(),
                                      pFilter->GetOwner() );
        
        if(FAILED(hres))
        {
            return hres;
        }

        CPostponedList* pList = GetCurrentPostponedList();

        _DBG_ASSERT( pList != NULL );

        hres = pList->AddRequest( this, pReq );

        if ( FAILED(hres) )
        {
            return hres;
        }

        return WBEM_S_NO_ERROR;
    }
    else if ( m_eState == e_Initialized || m_bInResync )
    {
        //
        // Filter is being activated in this namespace.  We must avoid 
        // processing filters before we're fully initialized.  This can 
        // happen when one namespace is initializing its cross namespace 
        // subscription to one that is still initializing. We do not process
        // filters before we're initialized because (1) we are not allowed to 
        // access class providers during stage1 init and (2) we're going to 
        // resync everything anyways during stage2 init.  
        //

        DEBUGTRACE((LOG_ESS,"Activating filter %p with query %S "
                    "in namespace %S.\n", pFilter, wszQuery, m_wszName ));

        // Retrieve its non-filtering sink
        // ===============================

        CAbstractEventSink* pNonFilter = pFilter->GetNonFilteringSink();
        if(pNonFilter == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        //
        // Register for class modification events of relevance for this filter
        //

        hres = RegisterFilterForAllClassChanges(pFilter, pExp);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,"Unable to register for class changes related "
                "to filter %S in namespace %S: 0x%x\n", wszQuery, GetName(), 
                hres));
            return hres;
        }

        //
        // Prepare filter for action
        //

        hres = pFilter->GetReady(wszQuery, pExp);
        
        if( SUCCEEDED(hres) )
        { 
            //
            // Register it in the core tables
            //

            hres = m_EventProviderCache.LoadProvidersForQuery(wszQuery, 
                                            pExp, pNonFilter);
            if(SUCCEEDED(hres))
            {
                hres = m_Poller.ActivateFilter(pFilter, wszQuery, pExp);
                if(FAILED(hres))
                {
                    // Need to deactivate providers
                    // ============================

                    m_EventProviderCache.ReleaseProvidersForQuery(
                                                            pNonFilter);
                }
            }
        }    
    }

    if(FAILED(hres))
    {
        //
        // Keep this filter registered for its class change events, as one of 
        // them could make it valid!
        //
    }

    return hres;
}

//*****************************************************************************
//
//  Retrieves the namespace pointer for the event namespace for this filter.
//  If current, returns NULL.  
//
//*****************************************************************************

HRESULT CEssNamespace::GetFilterEventNamespace(CEventFilter* pFilter,
                                         RELEASE_ME CEssNamespace** ppNamespace)
{
    HRESULT hres;

    *ppNamespace = NULL;

    LPWSTR wszNamespace = NULL;
    hres = pFilter->GetEventNamespace(&wszNamespace);
    if(FAILED(hres))
    {
        WMIESS_REPORT((WMIESS_INVALID_FILTER_NAMESPACE, m_wszName, pFilter, 
                        wszNamespace));
        return hres;
    }
    CVectorDeleteMe<WCHAR> vdm0(wszNamespace);

    if(wszNamespace && wbem_wcsicmp(wszNamespace, m_wszName))
    {
        //
        // Different namespace: Find it in the list. 
        //

        hres = m_pEss->GetNamespaceObject( wszNamespace, TRUE, ppNamespace );

        if(FAILED(hres))
        {
            WMIESS_REPORT((WMIESS_CANNOT_OPEN_FILTER_NAMESPACE, m_wszName, 
                            pFilter, wszNamespace));
            return hres;
        }

        //
        // Check if we got back our current namespace --- could happen if the
        // spelling is different, etc
        //

        if(*ppNamespace == this)
        {
            (*ppNamespace)->Release();
            *ppNamespace = NULL;
        }

        return S_OK;
    }
    else
    {
        // Same namespace
        *ppNamespace = NULL;
        return S_OK; 
    }
}

HRESULT CEssNamespace::RegisterFilterForAllClassChanges(CEventFilter* pFilter,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    HRESULT hres;
    
    //
    // Do nothing for class operation filters.  They simply serve as their own
    // "class change" filters
    //
    
    if(!wbem_wcsicmp(pExpr->bsClassName, L"__ClassOperationEvent") ||
        !wbem_wcsicmp(pExpr->bsClassName, L"__ClassCreationEvent") ||
        !wbem_wcsicmp(pExpr->bsClassName, L"__ClassDeletionEvent") ||
        !wbem_wcsicmp(pExpr->bsClassName, L"__ClassModificationEvent"))
    {
        pFilter->MarkReconstructOnHit();
        return WBEM_S_NO_ERROR;
    }

    //
    // get the sink for class change notifications.
    // 

    IWbemObjectSink* pClassChangeSink = pFilter->GetClassChangeSink(); // NOREF
    _DBG_ASSERT( pClassChangeSink != NULL );

    //
    // since the class change sink will be modifying internal namespace 
    // structures, we must wrap with an internal operations sink.  This is so
    // the thread that performs the indicate will be guaranteed to have a 
    // valid thread object associated with it.
    // 

    CWbemPtr<CEssInternalOperationSink> pInternalOpSink;
    pInternalOpSink = new CEssInternalOperationSink( pClassChangeSink );

    if ( pInternalOpSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // store the new sink with the filter because we need it later to unreg
    // 

    CWbemPtr<IWbemObjectSink> pOldInternalOpSink;
    hres = pFilter->SetActualClassChangeSink( pInternalOpSink, 
                                              &pOldInternalOpSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    _DBG_ASSERT( pOldInternalOpSink == NULL );

    return RegisterSinkForAllClassChanges( pInternalOpSink, pExpr );
}

HRESULT CEssNamespace::RegisterSinkForAllClassChanges(IWbemObjectSink* pSink,
                            QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    HRESULT hres;

    //
    // First of all, the class we are looking for is of interest
    //

    hres = RegisterSinkForClassChanges(pSink, pExpr->bsClassName);
    if(FAILED(hres))
        return hres;

    //
    // Now, iterate over all the tokens looking for ISAs.  We need those classes
    // too.
    //

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN* pToken = pExpr->pArrayOfTokens + i;

        if(pToken->nTokenType == QL1_OP_EXPRESSION && 
            (pToken->nOperator == QL1_OPERATOR_ISA ||
             pToken->nOperator == QL1_OPERATOR_ISNOTA) &&
            V_VT(&pToken->vConstValue) == VT_BSTR)
        {
            hres = RegisterSinkForClassChanges(pSink, 
                                                  V_BSTR(&pToken->vConstValue));
            if(FAILED(hres))
            {
                UnregisterSinkFromAllClassChanges(pSink);
                return hres;
            }
        }
    }

	// Somehow need to keep this filter subscribed to various events until all
	// the classes show up

    return WBEM_S_NO_ERROR;
}
    
HRESULT CEssNamespace::RegisterSinkForClassChanges(IWbemObjectSink* pSink,
                                                    LPCWSTR wszClassName)
{
    //
    // Do not register for changes to system classes --- they do not change!
    //

    if(wszClassName[0] == L'_')
    {
        return WBEM_S_NO_ERROR;
    }

    //
    // Just issue the appropriate query against the namespace.  The filter
    // will know what to do when called
    //

    LPWSTR wszQuery = new WCHAR[wcslen(wszClassName) + 100];

    if ( wszQuery == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    swprintf(wszQuery, L"select * from __ClassOperationEvent where "
                L"TargetClass isa \"%s\"", wszClassName);
    CVectorDeleteMe<WCHAR> vdm( wszQuery );

    return InternalRegisterNotificationSink(L"WQL", 
            wszQuery, 0, WMIMSG_FLAG_QOS_SYNCHRONOUS, 
            GetCurrentEssContext(), pSink, true, NULL );
}

HRESULT CEssNamespace::RegisterProviderForClassChanges( LPCWSTR wszClassName,
                                                        LPCWSTR wszProvName )
{
    try
    {
        CInCritSec ics(&m_csLevel1);
        m_mapProviderInterestClasses[wszClassName].insert( wszProvName );
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}
                
    
HRESULT CEssNamespace::UnregisterFilterFromAllClassChanges(
                            CEventFilter* pFilter)
{
    HRESULT hres;

    //
    // unbind the filter from the actual class change sink and use it to unreg
    //

    CWbemPtr<IWbemObjectSink> pActualClassChangeSink;

    hres = pFilter->SetActualClassChangeSink( NULL, &pActualClassChangeSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    if ( pActualClassChangeSink != NULL )
    {
        hres = UnregisterSinkFromAllClassChanges( pActualClassChangeSink );
    }

    return hres;
}

HRESULT CEssNamespace::UnregisterSinkFromAllClassChanges(
                            IWbemObjectSink* pSink)
{
    return InternalRemoveNotificationSink(pSink);
}
    

HRESULT CEssNamespace::DeactivateFilter( READ_ONLY CEventFilter* pFilter )
{
    HRESULT hres;

    DEBUGTRACE((LOG_ESS,"Deactivating filter %p\n", pFilter ));

    HRESULT hresGlobal = WBEM_S_NO_ERROR;

    //
    // Check if the events are supposed to come from this namespace or some
    // other one.
    //

    CEssNamespace* pOtherNamespace = NULL;
    hres = GetFilterEventNamespace(pFilter, &pOtherNamespace);
    if(FAILED(hres))
        return hres;

    if( pOtherNamespace )
    {
        CTemplateReleaseMe<CEssNamespace> rm0(pOtherNamespace);

        //
        // Unregister this notification sink with the other namespace, 
        // as if it were a temporary consumer.  This needs to be a 
        // postponed operation though, else we could have a deadlock 
        // scenario if at the same time cross namespace subscriptions 
        // were registered in both namespaces.
        //
        
        CPostponedRemoveNotificationSinkRequest* pReq;

        pReq = new CPostponedRemoveNotificationSinkRequest(
                                              pOtherNamespace, 
                                              pFilter->GetNonFilteringSink() );

        if ( pReq == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        CPostponedList* pList = GetCurrentPostponedList();
        
        _DBG_ASSERT( pList != NULL );
        
        hres = pList->AddRequest( this, pReq );
        
        if ( FAILED(hres) )
        {
            delete pReq;
            return hres;
        }
            
        return WBEM_S_NO_ERROR;
    }
    else
    {
        //
        // Current namespace --- unregister for real
        //

        // Retrieve its non-filtering sink
        // ===============================
    
        CAbstractEventSink* pNonFilter = pFilter->GetNonFilteringSink();
        if(pNonFilter == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        //
        // Report the MSFT_WmiFilterDeactivated event.
        //
        FireNCFilterEvent(MSFT_WmiFilterDeactivated, pFilter);

        //
        // Unregister it from class change notifications
        //

        hres = UnregisterFilterFromAllClassChanges(pFilter);
        if(FAILED(hres))
            hresGlobal = hres;
        
        // Deactivate in providers, poller, and static search
        // ==================================================
    
        hres = m_EventProviderCache.ReleaseProvidersForQuery(pNonFilter);
        if(FAILED(hres))
            hresGlobal = hres;
    
        hres = m_Poller.DeactivateFilter(pFilter);
        if(FAILED(hres))
            hresGlobal = hres;
    
        pFilter->SetInactive();
            
        return hres;
    }
}

HRESULT CEssNamespace::HandleClassCreation( LPCWSTR wszClassName, 
                                            IWbemClassObject* pClass)
{
    // 
    // Check if this is a class that a provider is waiting for.
    //
    
    ProviderSet setProviders;

    {
        CInCritSec ics( &m_csLevel1 );

        ClassToProviderMap::iterator it;
        it = m_mapProviderInterestClasses.find( wszClassName );

        if ( it != m_mapProviderInterestClasses.end() )
        {
            //
            // copy the interested provider list.
            //
            setProviders = it->second;
            
            //
            // remove the entry from the map.
            //
            m_mapProviderInterestClasses.erase( it );
        }
    }

    if ( setProviders.size() > 0 )
    {
        //
        // reload interested providers.
        //

        DEBUGTRACE((LOG_ESS,"Reloading some providers in namespace %S due to "
                    "creation of %S class\n", m_wszName, wszClassName ));

        ProviderSet::iterator itProv;

        for( itProv=setProviders.begin(); itProv!=setProviders.end(); itProv++)
        {
            ReloadProvider( 0, *itProv );
        }
    }

    return S_OK;
}


//*****************************************************************************
//
// Updates internal structures to reflect a change to this class.  Assumes that
// the namespace is already locked.
// Very few errors are reported from this function, since class changes cannot
// be vetoed.
// 
//*****************************************************************************
HRESULT CEssNamespace::HandleClassChange(LPCWSTR wszClassName, 
                                         IWbemClassObject* pClass)
{
    // Check if the class in question is an event consumer class
    // =========================================================
    
    if(pClass->InheritsFrom(CONSUMER_CLASS) == S_OK)
    {
        CInUpdate iu(this);
        
        HandleConsumerClassDeletion(wszClassName);
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::HandleConsumerClassDeletion(LPCWSTR wszClassName)
{
    // There are two varieties: non-singleton and singleton
    // ====================================================

    LPWSTR wszPrefix = new WCHAR[wcslen(wszClassName) + 2];
    if(wszPrefix == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm( wszPrefix );

    swprintf(wszPrefix, L"%s.", wszClassName);
    m_Bindings.RemoveConsumersStartingWith(wszPrefix);

    swprintf(wszPrefix, L"%s=", wszClassName);
    m_Bindings.RemoveConsumersStartingWith(wszPrefix);

    return WBEM_S_NO_ERROR;
}
    
HRESULT CEssNamespace::ReloadProvider( long lFlags, LPCWSTR wszProvider )
{
    HRESULT hres;

    WString wsRelpath;

    //
    // we only have to do this for event providers.  Check to see if 
    // we know about this try to see if we even have any event providers to reload ...
    // 

    try 
    {
        wsRelpath = L"__Win32Provider.Name='"; 
        wsRelpath += wszProvider;
        wsRelpath += L"'";
    }
    catch( CX_MemoryException )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemPtr<_IWmiObject> pObj;
    hres = GetInstance( wsRelpath, &pObj );

    if ( SUCCEEDED(hres) )
    {
        {
            ENSURE_INITIALIZED
            CInResync ir(this);
            //
            // note : in case of reloading event provider due to notification
            // from provss, we only need to handle event providers since 
            // consumer providers already have a reloading mechanism.
            //
            m_EventProviderCache.RemoveProvider(pObj);
            hres = AddProvider( pObj );
        }

        if ( SUCCEEDED(hres) )
        {
            hres = FirePostponedOperations();
        }
        else
        {
            FirePostponedOperations();
        }
    }

    return hres;
}

HRESULT CEssNamespace::ReloadProvider(IWbemClassObject* pProvObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadProvider", pProvObjTemplate );  

    ENSURE_INITIALIZED

    CInResync ir(this);

    // Start by deleting this provider from our records, if there
    // ==========================================================

    hres = RemoveProvider(pProvObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this provider in the database
    // ============================================================

    IWbemClassObject* pProvObj = NULL;
    hres = GetCurrentState(pProvObjTemplate, &pProvObj);
    if(FAILED(hres))
        return hres;

    if(pProvObj == NULL)
    {
        // The provider has been deleted --- no further action is needed
        // =============================================================

        return S_OK;
    }

    CReleaseMe rm1(pProvObj);

    // Now create it if necessary
    // ==========================

    hres = AddProvider(pProvObj);
    if(FAILED(hres))
        return hres;

    return hres;
}
    
HRESULT CEssNamespace::ReloadEventProviderRegistration(
                            IWbemClassObject* pProvRegObjTemplate)
{
    HRESULT hres;

    LogOp( L"ReloadEventProviderRegistration", pProvRegObjTemplate );  

    ENSURE_INITIALIZED

    CInResync ir(this);

    // Start by deleting this provider from our records, if there
    // ==========================================================

    hres = RemoveEventProviderRegistration(pProvRegObjTemplate);
    if(FAILED(hres))
        return hres;

    // Determine the current state of this registration in the database
    // ================================================================

    IWbemClassObject* pProvRegObj = NULL;
    hres = GetCurrentState(pProvRegObjTemplate, &pProvRegObj);
    if(FAILED(hres))
        return hres;

    if(pProvRegObj == NULL)
    {
        // The registration has been deleted --- no further action is needed
        // =================================================================

        return S_OK;
    }

    CReleaseMe rm1(pProvRegObj);

    // Now create it if necessary
    // ==========================

    hres = AddEventProviderRegistration(pProvRegObj);
    if(FAILED(hres))
        return hres;

    return hres;
}
    
HRESULT CEssNamespace::ReloadConsumerProviderRegistration(
                            IWbemClassObject* pProvRegObjTemplate)
{
    CInUpdate iu(this);

    // Reset consumer provider info in all the consumers using this consumer
    // provider.  That's all we need to do --- they will simply pick up the new
    // data on next delivery.  We don't even need to get the current version,
    // since all we need is the key
    // ========================================================================

    return RemoveConsumerProviderRegistration(pProvRegObjTemplate);
}


//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Adds this provider to the records.  Expects ReactivateAllFilters and 
//  CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::AddProvider(READ_ONLY IWbemClassObject* pProv)
{
    HRESULT hres;

    hres = m_EventProviderCache.AddProvider(pProv);
    return hres;
}

HRESULT CEssNamespace::CheckEventProviderRegistration(IWbemClassObject* pReg)
{
    HRESULT hres;
    ENSURE_INITIALIZED
    hres = m_EventProviderCache.CheckProviderRegistration(pReg);
    return hres;
}

HRESULT CEssNamespace::CheckTimerInstruction(IWbemClassObject* pInst)
{
    HRESULT hres;
    ENSURE_INITIALIZED
    hres = GetTimerGenerator().CheckTimerInstruction(pInst);
    return hres;
}

//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Adds this event provider registration to the records.  Expects 
//  ReactivateAllFilters and CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::AddEventProviderRegistration(
                                    IWbemClassObject* pReg)
{
    HRESULT hres;

    hres = m_EventProviderCache.AddProviderRegistration(pReg);
    return hres;
}

//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Removes this provider from the records.  Expects ReactivateAllFilters and 
//  CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::RemoveProvider(READ_ONLY IWbemClassObject* pProv)
{
    HRESULT hres;

    // Handle event consumer providers
    // ===============================

    IWbemClassObject* pConsProvReg;
    hres = m_ConsumerProviderCache.
                GetConsumerProviderRegFromProviderReg(pProv, &pConsProvReg);
    if(SUCCEEDED(hres))
    {
        RemoveConsumerProviderRegistration(pConsProvReg);
        pConsProvReg->Release();
    }

    // Handle event providers
    // ======================

    hres = m_EventProviderCache.RemoveProvider(pProv);
    return hres;
}

//*****************************************************************************
//
//  Assumes that the namespace is locked and PrepareForResync has been called
//  Adds this event provider registration to the records.  Expects 
//  ReactivateAllFilters and CommitResync to be called later
//
//*****************************************************************************
HRESULT CEssNamespace::RemoveEventProviderRegistration(
                                    READ_ONLY IWbemClassObject* pReg)
{
    HRESULT hres;

    hres = m_EventProviderCache.RemoveProviderRegistration(pReg);
    return hres;
}

DWORD CEssNamespace::GetProvidedEventMask(IWbemClassObject* pClass)
{
    return m_EventProviderCache.GetProvidedEventMask(pClass);
}


//*****************************************************************************
//
//  This function is called before a major update to the records. Without any 
//  calls to external components, it "deactivates" all the filters, in a sense 
//  that when all of them are "reactivated", the system will arrive in a 
//  consistent state (usage counts, etc).  CommitResync will then perform any
//  necessary activations/deactivations based on the new state
//
//*****************************************************************************

HRESULT CEssNamespace::PrepareForResync()
{
    m_bInResync = TRUE;

    // Ask the poller to "virtually" stop all polling instructions, without
    // actually stopping them physically
    // ====================================================================

    m_Poller.VirtuallyStopPolling();

    // Ask provider cache to "virtually" release all its providers, without
    // actually releasing them physically
    // ====================================================================

    m_EventProviderCache.VirtuallyReleaseProviders();

    // Ask core search to mark all filters so that it would know which ones are
    // gone after the resync
    // ========================================================================

    DEBUGTRACE((LOG_ESS,"Prepared resync in namespace %S\n", m_wszName ));

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::ReactivateAllFilters()
{
    DEBUGTRACE((LOG_ESS,"Reactivating all filters in namespace %S\n",
                 m_wszName ));
    return m_Bindings.ReactivateAllFilters();
}

HRESULT CEssNamespace::CommitResync()
{
    m_bInResync = FALSE;

    // Tell provider cache to perform all the loadings and unloadings it 
    // needs to perform based on the new data
    // =================================================================

    m_EventProviderCache.CommitProviderUsage();

    // Tell the poller to cancel unnecessary instructions
    // ==================================================

    m_Poller.CancelUnnecessaryPolling();

    DEBUGTRACE((LOG_ESS,"Committed resync in namespace %S\n", m_wszName ));

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::RemoveConsumerProviderRegistration(
                            IWbemClassObject* pReg)
{
    // Get the name of the consumer provider being deleteed
    // ====================================================

    BSTR strProvRef = CConsumerProviderCache::GetProviderRefFromRecord(pReg);
    if(strProvRef == NULL)
    {
        ERRORTRACE((LOG_ESS, "Invalid consumer provider record is being deleted"
                                "\n"));
        return WBEM_S_FALSE;
    }
    CSysFreeMe sfm1(strProvRef);

    // Reset it in all the consumers
    // =============================

    m_Bindings.ResetProviderRecords(strProvRef);

    // Remove it from the cache
    // ========================

    m_ConsumerProviderCache.RemoveConsumerProvider(strProvRef);

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::ScheduleDelivery(CQueueingEventSink* pDest)
{
    return m_pEss->EnqueueDeliver(pDest);
}

HRESULT CEssNamespace::DecorateObject(IWbemClassObject* pObj)
{
    return m_pEss->DecorateObject(pObj, m_wszName);
}

HRESULT CEssNamespace::EnsureConsumerWatchInstruction()
{
    return m_Bindings.EnsureConsumerWatchInstruction();
}

HRESULT CEssNamespace::AddSleepCharge(DWORD dwSleep)
{
    return m_pEss->AddSleepCharge(dwSleep);
}

HRESULT CEssNamespace::AddCache()
{
    return m_pEss->AddCache();
}

HRESULT CEssNamespace::RemoveCache()
{
    return m_pEss->RemoveCache();
}

HRESULT CEssNamespace::AddToCache(DWORD dwAdd, DWORD dwMemberTotal, 
                                    DWORD* pdwSleep)
{
    return m_pEss->AddToCache(dwAdd, dwMemberTotal, pdwSleep);
}

HRESULT CEssNamespace::RemoveFromCache(DWORD dwRemove)
{
    return m_pEss->RemoveFromCache(dwRemove);
}

HRESULT CEssNamespace::PerformSubscriptionInitialization()
{
    HRESULT hres;
    DWORD dwRead;

    //
    // must use repository only svc ptr here, else we can deadlock when 
    // class providers try to call back in. 
    // 

#ifdef __WHISTLER_UNCUT
    // Enumerator all EventMonitors
    // ============================

    CMonitorEnumSink* pMonitorSink = new CMonitorEnumSink(this);

    if ( NULL == pMonitorSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pMonitorSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum(MONITOR_CLASS, 0,
                         pMonitorSink);
    pMonitorSink->ReleaseAndWait();
#endif

    // Enumerator all EventFilters
    // ===========================

    CFilterEnumSink* pFilterSink = new CFilterEnumSink(this);

    if ( NULL == pFilterSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pFilterSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum( EVENT_FILTER_CLASS, 0,
                                                    pFilterSink);
    pFilterSink->ReleaseAndWait();

    // Enumerator all consumers
    // ========================

    CConsumerEnumSink* pConsumerSink = new CConsumerEnumSink(this);

    if ( NULL == pConsumerSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pConsumerSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum( CONSUMER_CLASS, 0,
                                                    pConsumerSink);
    pConsumerSink->ReleaseAndWait();

    // Enumerator all bindings
    // =======================

    CBindingEnumSink* pBindingSink = new CBindingEnumSink(this);

    if ( NULL == pBindingSink )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pBindingSink->AddRef();
    
    m_pInternalCoreSvc->InternalCreateInstanceEnum( BINDING_CLASS, 0,
                                                    pBindingSink);
    pBindingSink->ReleaseAndWait();

    return WBEM_S_NO_ERROR;
}


HRESULT CEssNamespace::PerformProviderInitialization()
{
    HRESULT hres;
    DWORD dwRead;

    //
    // make sure that we resync all subscriptions after we've processed 
    // provider objs
    // 

    CInResync ir( this );

    //
    // Enumerate all the providers
    // 

    IEnumWbemClassObject* penumProvs;

    hres = m_pCoreSvc->CreateInstanceEnum( PROVIDER_CLASS, 
                                           WBEM_FLAG_DEEP, 
                                           GetCurrentEssContext(), 
                                           &penumProvs );
   
    if ( SUCCEEDED(hres) )
    {
        CReleaseMe rm1(penumProvs);
    
        // Add them all to ESS
        // ===================
    
        IWbemClassObject* pProvObj;
        while((hres=penumProvs->Next(INFINITE, 1, &pProvObj, &dwRead)) == S_OK)
        {
            hres = AddProvider(pProvObj);
            pProvObj->Release();

            if(FAILED(hres))
            {
                // Already logged.
            }
        }
    }

    if ( FAILED(hres) )
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred enumerating event providers "
            "in namespace %S. Some event providers may not be active\n", hres,
            m_wszName));
    }

    //
    // Enumerate all the provider registrations
    // 

    IEnumWbemClassObject* penumRegs;
    hres = m_pCoreSvc->CreateInstanceEnum( EVENT_PROVIDER_REGISTRATION_CLASS, 
                                           WBEM_FLAG_DEEP, 
                                           GetCurrentEssContext(), 
                                           &penumRegs);
    if ( SUCCEEDED(hres) )
    {
        CReleaseMe rm2(penumRegs);
    
        // Add them all to ESS
        // ===================
    
        IWbemClassObject* pRegObj;
        while((hres = penumRegs->Next(INFINITE, 1, &pRegObj, &dwRead)) == S_OK)
        {
            hres = AddEventProviderRegistration(pRegObj);
            pRegObj->Release();
            if(FAILED(hres))
            {
                // Already logged
            }
        }
    }

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred enumerating event providers "
            "registrations in namespace %S. "
            "Some event providers may not be active\n", hres, m_wszName));
    }

    //
    // Create and initialize the core provider. 
    //
    
    CWbemPtr<CCoreEventProvider> pCoreEventProvider = new CCoreEventProvider;
    
    if ( pCoreEventProvider != NULL )
    {
        hres = pCoreEventProvider->SetNamespace(this);

        if ( SUCCEEDED(hres) )
        {
            LPCWSTR awszQuery[5] = 
            {
                L"select * from __InstanceOperationEvent",
                L"select * from __ClassOperationEvent",
                L"select * from __NamespaceOperationEvent",
                L"select * from __SystemEvent",
                L"select * from __TimerEvent"
            };

            hres = m_EventProviderCache.AddSystemProvider(pCoreEventProvider,
                                                          L"$Core", 
                                                          5, 
                                                          awszQuery );
        }
    }
    else
    {
        hres = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED(hres) )
    {
        pCoreEventProvider->AddRef();
        m_pCoreEventProvider = pCoreEventProvider;
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Core event provider cannot initialize due "
                    "to critical errors. HR=0x%x\n", hres));
    }

#ifdef __WHISTLER_UNCUT

    //
    // Create and initialize the monitor provider. 
    //
    
    CWbemPtr<CMonitorProvider> pMonitorProvider = new CMonitorProvider;
    
    if ( pMonitorProvider != NULL )
    {
        hres = pMonitorProvider->SetNamespace(this);

        if ( SUCCEEDED(hres) )
        {
            LPCWSTR wszQuery = L"select * from "MONITOR_BASE_EVENT_CLASS;
            hres = m_EventProviderCache.AddSystemProvider( pMonitorProvider, 
                                                           L"__Monitor", 
                                                           1, 
                                                           &wszQuery );
        }
    }
    else
    {
        hres = WBEM_E_OUT_OF_MEMORY;
    }

    if ( SUCCEEDED(hres) )
    {
        pMonitorProvider->AddRef();
        m_pMonitorProvider = pMonitorProvider;
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Monitor event provider cannot initialize due "
                    "to critical errors. HR=0x%x\n", hres));
    }
#endif

    // Initialize timer generator
    // ==========================

    hres = InitializeTimerGenerator();

    if(FAILED(hres)) 
    {
        ERRORTRACE((LOG_ESS, "Error 0x%X occurred initializing the timer "
            "in namespace %S. Some timer instructions may not be active\n", 
            hres, m_wszName));
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::InitializeTimerGenerator()
{
    return m_pEss->InitializeTimerGenerator( m_wszName, m_pCoreSvc );
}

HRESULT CEssNamespace::FirePostponedOperations()
{
    HRESULT hr, hrReturn = WBEM_S_NO_ERROR;

    //
    // Update lock cannot be held when calling this function and there 
    // are operations to execute.
    //

    _DBG_ASSERT( !DoesThreadOwnNamespaceLock() );

    //
    // execute both primary and event postponed ops until empty.
    //

    CPostponedList* pList = GetCurrentPostponedList();
    CPostponedList* pEventList = GetCurrentPostponedEventList();

    do
    {    
        //
        // execute the primary postponed ops.
        // 

        if( pList != NULL )
        {
            hr = pList->Execute(this, CPostponedList::e_ReturnOneError);
        
            if ( SUCCEEDED(hrReturn) )
            {
                hrReturn = hr;
            }
        }

        //
        // now execute postponed events 
        //
        
        if ( pEventList != NULL )
        {
            hr = pEventList->Execute(this, CPostponedList::e_ReturnOneError);

            if ( SUCCEEDED(hrReturn) )
            {
                hrReturn = hr;
            }
        }
    }
    while( pList != NULL && !pList->IsEmpty() );

    return hrReturn;
}

HRESULT CEssNamespace::PostponeRelease(IUnknown* pUnk)
{
    CPostponedList* pList = GetCurrentPostponedList();
    if(pList == NULL)
    {
        //
        // Just execute it
        //

        pUnk->Release();
        return WBEM_S_NO_ERROR;
    }
    CPostponedReleaseRequest* pReq = new CPostponedReleaseRequest(pUnk);
    if(pReq == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // this is a namespace agnostic postponed request, so specify null.
    // 
    return pList->AddRequest( NULL, pReq );
}

HRESULT CEssNamespace::GetProviderNamespacePointer(IWbemServices** ppServices)
{
    IWbemServices* pServices = NULL;
    HRESULT hres = m_pEss->GetNamespacePointer(m_wszName, FALSE, &pServices);
    if(FAILED(hres))
        return hres;

    IWbemUnloadingControl* pControl = NULL;
    pServices->QueryInterface(IID_IWbemUnloadingControl, 
                                    (void**)&pControl);
    if(pControl)
    {
        pControl->SetMustPreventUnloading(true);
        pControl->Release();
    }

    *ppServices = pServices;
    return WBEM_S_NO_ERROR;
}

void CEssNamespace::IncrementObjectCount()
{
    m_pEss->IncrementObjectCount();
}
void CEssNamespace::DecrementObjectCount()
{
    m_pEss->DecrementObjectCount();
}

HRESULT CEssNamespace::LockForUpdate()
{
    m_csLevel2.Enter();
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::UnlockForUpdate()
{
    m_ClassCache.Clear();
    m_csLevel2.Leave();
    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::GetCurrentState( IWbemClassObject* pTemplate, 
                                        IWbemClassObject** ppObj)
{
    HRESULT hres;
    *ppObj = NULL;

    // Retrieve the path
    // =================

    VARIANT vPath;
    hres = pTemplate->Get(L"__RELPATH", 0, &vPath, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&vPath);
    if(V_VT(&vPath) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    // Get it from the namespace
    // =========================

    _IWmiObject* pObj;
    hres = GetInstance( V_BSTR(&vPath), &pObj );

    if( hres == WBEM_E_NOT_FOUND )
        return WBEM_S_FALSE;

    *ppObj = pObj;
    return hres;
}

CWinMgmtTimerGenerator& CEssNamespace::GetTimerGenerator()
{
    return m_pEss->GetTimerGenerator();
}
    
HRESULT CEssNamespace::RaiseErrorEvent(IWbemEvent* pEvent)
{
    CEventRepresentation Event;
    Event.type = e_EventTypeSystem;
    Event.nObjects = 1;
    Event.apObjects = &pEvent;

    HRESULT hres;
    
    hres = SignalEvent( Event, 0 );
        
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Event subsystem was unable to deliver an "
                    "error event to some consumers (%X)\n", hres));
    }

    return S_OK;
}

HRESULT CEssNamespace::GetClassFromCore( LPCWSTR wszClassName, 
                                         _IWmiObject** ppClass )
{
    HRESULT hres;
    CWbemPtr<IWbemClassObject> pClass;
    *ppClass = NULL;

    //
    // want to ensure that we don't use the full service ptr until we've 
    // completed stage 1 initialization.  Reason is that we don't want to 
    // load class providers until the second stage of initialization.
    //
    _DBG_ASSERT( m_bStage1Complete );

    //
    // must use full service because will need to support dynamic classes.
    // 

    hres = m_pInternalFullSvc->InternalGetClass( wszClassName, &pClass );

    if ( FAILED(hres) )
    {
        return hres;
    }

    return pClass->QueryInterface( IID__IWmiObject, (void**)ppClass );
}
    
HRESULT CEssNamespace::GetInstance( LPCWSTR wszPath, 
                                    _IWmiObject** ppInstance )
{
    HRESULT hres;
    CWbemPtr<IWbemClassObject> pInstance;
    *ppInstance = NULL;

    hres = m_pInternalCoreSvc->InternalGetInstance( wszPath, &pInstance );

    if ( FAILED(hres) )
    {
        return hres;
    }

    return pInstance->QueryInterface( IID__IWmiObject, (void**)ppInstance );
}

HRESULT CEssNamespace::GetDbInstance( LPCWSTR wszDbKey, 
                                      _IWmiObject** ppInstance)
{
    HRESULT hres;
    CWbemPtr<IWbemClassObject> pInstance;
    *ppInstance = NULL;

    hres = m_pInternalCoreSvc->GetDbInstance( wszDbKey, &pInstance );

    if ( FAILED(hres) )
    {
        return hres;
    }

    return pInstance->QueryInterface( IID__IWmiObject, (void**)ppInstance );
}

HRESULT CEssNamespace::CreateInstanceEnum(LPCWSTR wszClass, long lFlags, 
                            IWbemObjectSink* pSink)
{
    return m_pInternalCoreSvc->InternalCreateInstanceEnum(wszClass, lFlags, pSink);
}

HRESULT CEssNamespace::ExecQuery(LPCWSTR wszQuery, long lFlags, 
                                        IWbemObjectSink* pSink)
{
    return m_pInternalCoreSvc->InternalExecQuery(L"WQL", wszQuery, lFlags, pSink);
}

HRESULT CEssNamespace::GetToken(PSID pSid, IWbemToken** ppToken)
{
    return m_pEss->GetToken(pSid, ppToken);
}
    

void CEssNamespace::DumpStatistics(FILE* f, long lFlags)
{
    CInUpdate iu(this);

    fprintf(f, "------- Namespace '%S' ----------\n", m_wszName);

    m_Bindings.DumpStatistics(f, lFlags);
    m_ConsumerProviderCache.DumpStatistics(f, lFlags);
    m_EventProviderCache.DumpStatistics(f, lFlags);
    m_Poller.DumpStatistics(f, lFlags);
}


HRESULT CEssMetaData::GetClass( LPCWSTR wszName, IWbemContext* pContext,
                                _IWmiObject** ppClass)
{
    return m_pNamespace->m_ClassCache.GetClass(wszName, pContext, ppClass);
}

STDMETHODIMP CEssNamespace::CConsumerClassDeletionSink::Indicate(
                                    long lNumObjects, 
                                    IWbemClassObject** apObjects)
{
    HRESULT hres;

    for(long i = 0; i < lNumObjects; i++)
    {
        _IWmiObject* pEvent = NULL;
        apObjects[i]->QueryInterface(IID__IWmiObject, (void**)&pEvent);
        CReleaseMe rm1(pEvent);

        //
        // Get the class name of the class being deleted
        //

        VARIANT vObj;
        hres = pEvent->Get(L"TargetClass", 0, &vObj, NULL, NULL);
        if(SUCCEEDED(hres))
        {
            CClearMe cm1(&vObj);
            IWbemClassObject* pClass;
            V_UNKNOWN(&vObj)->QueryInterface(IID_IWbemClassObject, 
                                                (void**)&pClass);
            CReleaseMe rm2(pClass);

            VARIANT vClass;
            hres = pClass->Get(L"__CLASS", 0, &vClass, NULL, NULL);
            if(SUCCEEDED(hres))
            {
                CClearMe cm(&vClass);
                m_pOuter->HandleConsumerClassDeletion(V_BSTR(&vClass));
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEssNamespace::LoadEventProvider(LPCWSTR wszProviderName, 
                                         IWbemEventProvider** ppProv)
{
    HRESULT hres;
    *ppProv = NULL;
    
    //
    // Get provider pointer from the provider subsystem
    //

    if(m_pProviderFactory == NULL)
        return WBEM_E_CRITICAL_ERROR;

	WmiInternalContext t_InternalContext ;
	ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

    hres = m_pProviderFactory->GetProvider(

	t_InternalContext ,
        0,                  // lFlags
        GetCurrentEssContext(),
        0,
        NULL,
        NULL,
        0,   
        wszProviderName,
        IID_IWbemEventProvider,
        (LPVOID *) ppProv
        );

    return hres;
}

HRESULT CEssNamespace::LoadConsumerProvider(LPCWSTR wszProviderName, 
                                         IUnknown** ppProv)
{
    HRESULT hres;
    *ppProv = NULL;
    
    //
    // Get provider pointer from the provider subsystem
    //

    if(m_pProviderFactory == NULL)
        return WBEM_E_CRITICAL_ERROR;

	WmiInternalContext t_InternalContext ;
	ZeroMemory ( & t_InternalContext , sizeof ( t_InternalContext ) ) ;

    hres = m_pProviderFactory->GetProvider(
	
	t_InternalContext ,
        0,                  // lFlags
        GetCurrentEssContext(),
        0,
        NULL,
        NULL,
        0,   
        wszProviderName,
        IID_IUnknown,
        (LPVOID *) ppProv
        );

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\permcons.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  STDCONS.H
//
//  This file defines the class for permanent event consumer.
//
//  Classes defined:
//
//      CPermanentConsumer
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================

#ifndef __PERM_EVENT_CONSUMER__H_
#define __PERM_EVENT_CONSUMER__H_

#include "binding.h"
#include "consprov.h"
#include "fastall.h"

class CPermanentConsumer : public CEventConsumer
{
protected:
    IWbemUnboundObjectSink* m_pCachedSink;
    DWORD m_dwLastDelivery;
    IWbemClassObject* m_pLogicalConsumer;
    
    static long mstatic_lMaxQueueSizeHandle;
    static long mstatic_lSidHandle;
    static bool mstatic_bHandlesInitialized;
    static HRESULT InitializeHandles( _IWmiObject* pObject);
protected:
    HRESULT RetrieveProviderRecord(
                        RELEASE_ME CConsumerProviderRecord** ppRecord,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer = NULL);
    HRESULT RetrieveSink(RELEASE_ME IWbemUnboundObjectSink** ppSink,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer);
    HRESULT ObtainSink(RELEASE_ME IWbemUnboundObjectSink** ppSink,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer);
    HRESULT ClearCache();
    HRESULT Indicate(IWbemUnboundObjectSink* pSink,
                                    IWbemClassObject* pLogicalConsumer, 
                                    long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure);

    HRESULT ConstructErrorEvent(LPCWSTR wszEventClass,
                                IWbemEvent* pEvent, IWbemEvent** ppErrorEvent);
    HRESULT ReportConsumerFailure(IWbemEvent* pEvent, HRESULT hresError,
                                    _IWmiObject* pErrorObj);
    HRESULT ReportQosFailure(IWbemEvent* pEvent, HRESULT hresError);
    HRESULT ReportConsumerFailure(long lNumEvents,
                                IWbemEvent** apEvents,  HRESULT hresError);

    HRESULT Redeliver(long lNumEvents, IWbemEvent** apEvents, BOOL bSecure);

    void FireSinkUnloadedEvent();

public:
    CPermanentConsumer(CEssNamespace* pNamespace);
    HRESULT Initialize(READ_ONLY IWbemClassObject* pActualConsumer);
    virtual ~CPermanentConsumer();

    BOOL UnloadIfUnusedFor(CWbemInterval Interval);
    BOOL IsFullyUnloaded();
    BOOL IsPermanent() const {return TRUE;}
    HRESULT ResetProviderRecord(LPCWSTR wszProvider);
    static SYSFREE_ME BSTR ComputeKeyFromObj(CEssNamespace* pNamespace,
                                             IWbemClassObject* pConsumerObj);

    virtual HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure, CEventContext* pContext);
    HRESULT ReportQueueOverflow(IWbemEvent* pEvent, DWORD dwQueueSize);
    HRESULT Validate(IWbemClassObject* pLogicalConsumer);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\permcons.cpp ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  STDCONS.CPP
//
//  This file implements the class for standard event consumer.
//
//  History:
//
//  11/27/96    a-levn      Compiles.
//
//=============================================================================
#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include "permcons.h"
#include "ess.h"
#include <wbemidl.h>
#include "wbemutil.h"
#include <cominit.h>
#include <genutils.h>
#include "NCEvents.h"


#define HRESULT_ERROR_MASK (0x0000FFFF)
#define HRESULT_ERROR_FUNC(X) (X&HRESULT_ERROR_MASK)
#define HRESULT_ERROR_SERVER_UNAVAILABLE	1722L
#define HRESULT_ERROR_CALL_FAILED_DNE		1727L

long CPermanentConsumer::mstatic_lMaxQueueSizeHandle = 0;
long CPermanentConsumer::mstatic_lSidHandle = 0;
bool CPermanentConsumer::mstatic_bHandlesInitialized = false;

// static 
HRESULT CPermanentConsumer::InitializeHandles( _IWmiObject* pObject)
{
    if(mstatic_bHandlesInitialized)
        return S_FALSE;

    CIMTYPE ct;
    pObject->GetPropertyHandle(CONSUMER_MAXQUEUESIZE_PROPNAME, &ct, 
                                    &mstatic_lMaxQueueSizeHandle);
    pObject->GetPropertyHandleEx(OWNER_SID_PROPNAME, 0, &ct, 
                                    &mstatic_lSidHandle);

    mstatic_bHandlesInitialized = true;
    return S_OK;
}

//******************************************************************************
//  public
//
//  See stdcons.h for documentation
//
//******************************************************************************
CPermanentConsumer::CPermanentConsumer(CEssNamespace* pNamespace)
 : CEventConsumer(pNamespace), m_pCachedSink(NULL), m_pLogicalConsumer(NULL),
        m_dwLastDelivery(GetTickCount())
{
    pNamespace->IncrementObjectCount();
}

HRESULT CPermanentConsumer::Initialize(IWbemClassObject* pObj)
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pActualConsumer;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pActualConsumer );

    if ( FAILED(hres) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    InitializeHandles(pActualConsumer);

    // Get the "database key" --- unique identifier
    // ============================================

    BSTR strStandardPath;
    hres = pActualConsumer->GetNormalizedPath( 0, &strStandardPath );
    if(FAILED(hres))
        return hres;

    CSysFreeMe sfm1(strStandardPath);
    if(!(m_isKey = strStandardPath))
        return WBEM_E_OUT_OF_MEMORY;

    //
    // set the queueing sink name to the consumer name.  
    // TODO : this is temporary and will go away when the consumer no longer
    // inherits from queueing sink.
    //

    hres = SetName( strStandardPath );

    if ( FAILED(hres) )
    {
        return hres;
    }

    // Get the maximum queue size, if specified
    // ========================================

    DWORD dwMaxQueueSize;
    hres = pActualConsumer->ReadDWORD(mstatic_lMaxQueueSizeHandle, 
                                        &dwMaxQueueSize);
    if(hres == S_OK)
        SetMaxQueueSize(dwMaxQueueSize);

    // Get the SID
    // ===========

    if(IsNT())
    {
        PSID pSid;
        ULONG ulNumElements;

        hres = pActualConsumer->GetArrayPropAddrByHandle( mstatic_lSidHandle,
                                                          0,
                                                          &ulNumElements,
                                                          &pSid );
        if ( hres != S_OK )
        {
            return WBEM_E_INVALID_OBJECT;
        }
        
        m_pOwnerSid = new BYTE[ulNumElements];

        if ( m_pOwnerSid == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy( m_pOwnerSid, pSid, ulNumElements );
    }

    return WBEM_S_NO_ERROR;
}

//******************************************************************************
//  public
//
//  See stdcons.h for documentation
//
//******************************************************************************
CPermanentConsumer::~CPermanentConsumer()
{
    if(m_pCachedSink) 
    {
        FireSinkUnloadedEvent();

        m_pCachedSink->Release();
    }

    if(m_pNamespace)
        m_pNamespace->DecrementObjectCount();
    if(m_pLogicalConsumer)
        m_pLogicalConsumer->Release();
}

HRESULT CPermanentConsumer::RetrieveProviderRecord(
                        RELEASE_ME CConsumerProviderRecord** ppRecord,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer)
{
    HRESULT hres;

    // Retrieve our logical consumer instance
    // ======================================

    _IWmiObject* pLogicalConsumer = NULL;
    WString wsKey = m_isKey;
    hres = m_pNamespace->GetDbInstance((LPCWSTR)wsKey, &pLogicalConsumer);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pLogicalConsumer);

    *ppRecord = m_pNamespace->GetConsumerProviderCache().GetRecord(
                    pLogicalConsumer);
    if(*ppRecord == NULL)
    {
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }
    else
    {
        if(pLogicalConsumer && ppLogicalConsumer)
        {
            *ppLogicalConsumer = pLogicalConsumer;
            (*ppLogicalConsumer)->AddRef();
        }
    }

    return WBEM_S_NO_ERROR;
}
        
//******************************************************************************
//
//  RetrieveConsumer
//
//  Have consumer provider produce a sink for this logical consumer
//
//******************************************************************************
HRESULT CPermanentConsumer::RetrieveSink(
                        RELEASE_ME IWbemUnboundObjectSink** ppSink, 
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer)
{
    // Check if one is cached
    // ======================

    {
        CInCritSec ics(&m_cs);
        if(m_pCachedSink)
        {
            *ppSink = m_pCachedSink;
            (*ppSink)->AddRef();
            *ppLogicalConsumer = m_pLogicalConsumer;
            if(*ppLogicalConsumer)
                (*ppLogicalConsumer)->AddRef();
            return WBEM_S_NO_ERROR;
        }
    }

    // Not cached. Retrieve one
    // ========================

    HRESULT hres = ObtainSink(ppSink, ppLogicalConsumer);
    if(FAILED(hres))
        return hres;

    m_pNamespace->EnsureConsumerWatchInstruction();

    // Cache it, if needed
    // ===================

    {
        CInCritSec ics(&m_cs);

        if(m_pCachedSink)
        {
            if(m_pCachedSink != (*ppSink))
            {
                // Drop ours, and use the one that's there
                // =======================================
    
                (*ppSink)->Release();
                *ppSink = m_pCachedSink;
                (*ppSink)->AddRef();
            }
        
            if(m_pLogicalConsumer != *ppLogicalConsumer)
            {
                if(*ppLogicalConsumer)
                    (*ppLogicalConsumer)->Release();
                *ppLogicalConsumer = m_pLogicalConsumer;
                if(*ppLogicalConsumer)
                    (*ppLogicalConsumer)->AddRef();
            }
                
            return WBEM_S_NO_ERROR;
        }
        else
        {
            // Cache it
            // ========

            m_pCachedSink = *ppSink;
            m_pCachedSink->AddRef();

            m_pLogicalConsumer = *ppLogicalConsumer;
            if(m_pLogicalConsumer)
                m_pLogicalConsumer->AddRef();
        }
    }
    
    return WBEM_S_NO_ERROR;
}
        
HRESULT CPermanentConsumer::ObtainSink(
                        RELEASE_ME IWbemUnboundObjectSink** ppSink,
                        RELEASE_ME IWbemClassObject** ppLogicalConsumer)
{
    *ppSink = NULL;

    CConsumerProviderRecord* pRecord = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;

    HRESULT hres = RetrieveProviderRecord(&pRecord, &pLogicalConsumer);
    if(FAILED(hres))
        return hres;

    CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);
    CReleaseMe rm2(pLogicalConsumer);

    // Check for global sink shortcut
    // ==============================

    hres = pRecord->GetGlobalObjectSink(ppSink, pLogicalConsumer);
    if(FAILED(hres)) return hres;


    if(*ppSink != NULL)
    {
        // That's it --- this consumer provider provides itself!
        // =====================================================

        *ppLogicalConsumer = pLogicalConsumer;
        if(pLogicalConsumer)
            pLogicalConsumer->AddRef();
        return S_OK;
    }

    hres = pRecord->FindConsumer(pLogicalConsumer, ppSink);
    if(FAILED(hres)) 
    {
        ERRORTRACE((LOG_ESS, "Event consumer provider is unable to instantiate "
            "event consumer %S: error code 0x%X\n", 
                (LPCWSTR)(WString)m_isKey, hres));
        return hres;
    }
    else
    {
        if(hres == WBEM_S_FALSE)
        {
            // Consumer provider says: don't need logical consumer!
            // ====================================================

            *ppLogicalConsumer = NULL;
        }
        else
        {
            *ppLogicalConsumer = pLogicalConsumer;
            (*ppLogicalConsumer)->AddRef();
        }
    }
    return hres;
}

//******************************************************************************
//  
//  ClearCache
//
//  Releases cached event consumer pointers.
//
//******************************************************************************
HRESULT CPermanentConsumer::ClearCache()
{
    //
    // First, clear consumer provider record
    //

    CConsumerProviderRecord* pRecord = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;
    HRESULT hres = RetrieveProviderRecord(&pRecord, &pLogicalConsumer);
    if(SUCCEEDED(hres))
    {
        pLogicalConsumer->Release();
        pRecord->Invalidate();
        pRecord->Release();
    }
        
    // 
    // Need to PostponeRelease outside of the critical section, since
    // it will not actually postpone if done on a delivery thread
    //

    IWbemUnboundObjectSink* pSink = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pCachedSink)
        {
            FireSinkUnloadedEvent();

            pSink = m_pCachedSink;
            m_pCachedSink = NULL;
        }

        if(m_pLogicalConsumer)
        {
            m_pLogicalConsumer->Release();
            m_pLogicalConsumer = NULL;
        }
    }

    _DBG_ASSERT( m_pNamespace != NULL );

    if(pSink)
        m_pNamespace->PostponeRelease(pSink);

    return S_OK;
}

HRESULT CPermanentConsumer::Indicate(IWbemUnboundObjectSink* pSink,
                                    IWbemClassObject* pLogicalConsumer, 
                                    long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure)
{
    HRESULT hres;

    try
    {
        hres = pSink->IndicateToConsumer(pLogicalConsumer, lNumEvents, 
                                            apEvents);
    }
    catch(...)
    {
        ERRORTRACE((LOG_ESS, "Event consumer threw an exception!\n"));
        hres = WBEM_E_PROVIDER_FAILURE;
    }
   
    return hres;
}
    

    
//******************************************************************************
//  public
//
//  See stdcons.h for documentation
//
//******************************************************************************
HRESULT CPermanentConsumer::ActuallyDeliver(long lNumEvents, 
                                IWbemEvent** apEvents, BOOL bSecure, 
                                CEventContext* pContext)
{
    HRESULT hres;

    // Mark "last-delivery" time
    // =========================

    m_dwLastDelivery = GetTickCount();

    // Retrieve the sink to deliver the event into
    // ===========================================

    IWbemUnboundObjectSink* pSink = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;
    hres = RetrieveSink(&pSink, &pLogicalConsumer);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed the first attempt to retrieve the sink to "
            "deliver an event to event consumer %S with error code %X.\n"
            "WMI will reload and retry.\n", 
                (LPCWSTR)(WString)m_isKey, hres));

        return Redeliver(lNumEvents, apEvents, bSecure);
    }

    CReleaseMe rm1(pSink);
    CReleaseMe rm2(pLogicalConsumer);

    // Try to deliver (m_pLogicalConsumer is immutable, so no cs is needed)
    // ====================================================================

    hres = Indicate(pSink, pLogicalConsumer, lNumEvents, apEvents, bSecure);
    if(FAILED(hres))
    {
        // decide whether it's an RPC error code
		DWORD shiftedRPCFacCode = FACILITY_RPC << 16;

		if ( ( ( hres & 0x7FF0000 ) == shiftedRPCFacCode ) || 
             ( HRESULT_ERROR_FUNC(hres) == HRESULT_ERROR_SERVER_UNAVAILABLE ) || 
             ( HRESULT_ERROR_FUNC(hres) == HRESULT_ERROR_CALL_FAILED_DNE ) || 
             ( hres == RPC_E_DISCONNECTED ) )
		{			
			ERRORTRACE((LOG_ESS, "Failed the first attempt to deliver an event to "
				"event consumer %S with error code 0x%X.\n"
				"WMI will reload and retry.\n", 
					(LPCWSTR)(WString)m_isKey, hres));

			return Redeliver(lNumEvents, apEvents, bSecure);
		}
		else
		{
            ReportConsumerFailure(lNumEvents, apEvents, hres);

            ERRORTRACE((LOG_ESS, "Failed to deliver an event to "
				"event consumer %S with error code 0x%X. Dropping event.\n",
				(LPCWSTR)(WString)m_isKey, hres));

			return hres;
		}
    }
    return hres;
}

HRESULT CPermanentConsumer::Redeliver(long lNumEvents, 
                                IWbemEvent** apEvents, BOOL bSecure)
{
    HRESULT hres;

    // Clear everything
    // ================

    ClearCache();

    // Re-retrieve the sink
    // ====================

    IWbemUnboundObjectSink* pSink = NULL;
    IWbemClassObject* pLogicalConsumer = NULL;

    hres = RetrieveSink(&pSink, &pLogicalConsumer);
    if(SUCCEEDED(hres))
    {
        CReleaseMe rm1(pSink);
        CReleaseMe rm2(pLogicalConsumer);
    
        // Re-deliver
        // ==========
    
        hres = Indicate(pSink, pLogicalConsumer, lNumEvents, apEvents, bSecure);
    }

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, 
            "Failed the second attempt to deliver an event to "
            "event consumer %S with error code %X.\n"
            "This event is dropped for this consumer.\n", 
            (LPCWSTR)(WString)m_isKey, hres));

        ReportConsumerFailure(lNumEvents, apEvents, hres);
    }

    return hres;
}

BOOL CPermanentConsumer::IsFullyUnloaded()
{
    return (m_pCachedSink == NULL);
}

HRESULT CPermanentConsumer::Validate(IWbemClassObject* pLogicalConsumer)
{
    HRESULT hres;

    //
    // Retrieve our consumer provider record
    //

    CConsumerProviderRecord* pRecord = NULL;
    hres = RetrieveProviderRecord(&pRecord);
    if(FAILED(hres))
        return hres;

    CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);
    
    //  
    // Get it to validate our logical consumer
    //

    hres = pRecord->ValidateConsumer(pLogicalConsumer);
    return hres;
}

    
    

BOOL CPermanentConsumer::UnloadIfUnusedFor(CWbemInterval Interval)
{
    CInCritSec ics(&m_cs);

    if(m_pCachedSink && 
        GetTickCount() - m_dwLastDelivery > Interval.GetMilliseconds())
    {
        FireSinkUnloadedEvent();

        _DBG_ASSERT( m_pNamespace != NULL );
        m_pNamespace->PostponeRelease(m_pCachedSink);
        m_pCachedSink = NULL;
        
        if(m_pLogicalConsumer)
            m_pLogicalConsumer->Release();
        m_pLogicalConsumer = NULL;

        DEBUGTRACE((LOG_ESS, "Unloading event consumer sink %S\n", 
                   (LPCWSTR)(WString)m_isKey));
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

HRESULT CPermanentConsumer::ResetProviderRecord(LPCWSTR wszProviderRef)
{
    HRESULT hres;

    // Check if anything is even cached
    // ================================

    {
        CInCritSec ics(&m_cs);
        if(m_pCachedSink == NULL)
            return WBEM_S_FALSE;
    }

    // Locate our consumer provider record
    // ===================================

    CConsumerProviderRecord* pRecord = NULL;
    hres = RetrieveProviderRecord(&pRecord);
    if(FAILED(hres))
        return hres;
    CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);

    if(!_wcsicmp(pRecord->GetProviderRef(), wszProviderRef))
    {
        ClearCache();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_S_FALSE;
    }
}

SYSFREE_ME BSTR CPermanentConsumer::ComputeKeyFromObj(
                                        CEssNamespace* pNamespace,
                                        IWbemClassObject* pObj)
{
    HRESULT hres;

    CWbemPtr<_IWmiObject> pConsumerObj;

    hres = pObj->QueryInterface( IID__IWmiObject, (void**)&pConsumerObj );

    if ( FAILED(hres) )
    {
        return NULL;
    }

    BSTR strStandardPath = NULL;

    hres = pConsumerObj->GetNormalizedPath( 0, &strStandardPath );
    if(FAILED(hres))
        return NULL;

    return strStandardPath;
}

HRESULT CPermanentConsumer::ReportQueueOverflow(IWbemEvent* pEvent, 
                                                    DWORD dwQueueSize)
{
    HRESULT hres;

    if(CEventConsumer::ReportEventDrop(pEvent) != S_OK)
        return S_FALSE;

    // Construct event instance
    // ========================

    IWbemEvent* pErrorEvent = NULL;
    hres = ConstructErrorEvent(QUEUE_OVERFLOW_CLASS, pEvent, &pErrorEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pErrorEvent);

    // Fill in the queue size
    // ======================

    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = dwQueueSize;

    hres = pErrorEvent->Put(QUEUE_OVERFLOW_SIZE_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    // Raise it
    // ========

    hres = m_pNamespace->RaiseErrorEvent(pErrorEvent);
    return hres;
}

HRESULT CPermanentConsumer::ReportConsumerFailure(long lNumEvents,
                                IWbemEvent** apEvents,  HRESULT hresError)
{
    HRESULT hres;

    //
    // Compute the error object to use
    //

    _IWmiObject* pErrorObj = NULL;

    //
    // Get it from the thread
    //

    IErrorInfo* pErrorInfo = NULL;
    hres = GetErrorInfo(0, &pErrorInfo);
    if(hres != S_OK)
    {
        pErrorInfo = NULL;
    }
    else
    {
        hres = pErrorInfo->QueryInterface(IID__IWmiObject, (void**)&pErrorObj);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Non-WMI error object found returned by event "
                "consumer.  Error object ignored\n"));
            pErrorObj = NULL;
        }
    }

    CReleaseMe rm1(pErrorObj);

    for(long l = 0; l < lNumEvents; l++)
    {
        ReportConsumerFailure(apEvents[l], hresError, pErrorObj);
    }

    return S_OK;
}

HRESULT CPermanentConsumer::ReportConsumerFailure(IWbemEvent* pEvent, 
                                                    HRESULT hresError,
                                                    _IWmiObject* pErrorObj)
{
    HRESULT hres;

    if(CEventConsumer::ReportEventDrop(pEvent) != S_OK)
        return S_FALSE;

    //
    // Construct event instance
    //

    IWbemEvent* pErrorEvent = NULL;
    hres = ConstructErrorEvent(CONSUMER_FAILURE_CLASS, pEvent, &pErrorEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pErrorEvent);

    //
    // Fill in the error code
    //

    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = hresError;

    hres = pErrorEvent->Put(CONSUMER_FAILURE_ERROR_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    if(pErrorObj)
    {
        //
        // Fill in the error object
        //
    
        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = pErrorObj;
    
        hres = pErrorEvent->Put(CONSUMER_FAILURE_ERROROBJ_PROPNAME, 0, &v, 0);
        if(FAILED(hres))
        {
            //
            // That's OK, sometimes error objects are not supported
            //
        }
    }

    // Raise it
    // ========

    hres = m_pNamespace->RaiseErrorEvent(pErrorEvent);
    return hres;
}

HRESULT CPermanentConsumer::ReportQosFailure( IWbemEvent* pEvent, 
                                              HRESULT hresError )
{
    HRESULT hres;

    if(CEventConsumer::ReportEventDrop(pEvent) != S_OK)
        return S_FALSE;

    // Construct event instance
    // ========================

    IWbemEvent* pErrorEvent = NULL;
    hres = ConstructErrorEvent(QOS_FAILURE_CLASS, pEvent, &pErrorEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pErrorEvent);

    // Fill in the error code
    // ======================

    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = hresError;

    hres = pErrorEvent->Put(QOS_FAILURE_ERROR_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    // Raise it
    // ========

    hres = m_pNamespace->RaiseErrorEvent(pErrorEvent);
    return hres;
}
    

HRESULT CPermanentConsumer::ConstructErrorEvent(LPCWSTR wszEventClass,
                                IWbemEvent* pEvent, IWbemEvent** ppErrorEvent)
{
    HRESULT hres;

    _IWmiObject* pClass = NULL;
    hres = m_pNamespace->GetClass(wszEventClass, &pClass);
    if(FAILED(hres)) 
        return hres;
    CReleaseMe rm2(pClass);

    IWbemClassObject* pErrorEvent = NULL;
    hres = pClass->SpawnInstance(0, &pErrorEvent);
    if(FAILED(hres)) 
        return hres;
    CReleaseMe rm3(pErrorEvent);

    VARIANT v;
    VariantInit(&v);
    
    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = pEvent;

    hres = pErrorEvent->Put(EVENT_DROP_EVENT_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString((WString)m_isKey);

    hres = pErrorEvent->Put(EVENT_DROP_CONSUMER_PROPNAME, 0, &v, 0);
    VariantClear(&v);
    if(FAILED(hres))
        return hres;
    
    *ppErrorEvent = pErrorEvent;
    pErrorEvent->AddRef();
    return S_OK;
}

void CPermanentConsumer::FireSinkUnloadedEvent()
{
    CConsumerProviderRecord *pRecord = NULL;
    IWbemClassObject        *pLogicalConsumer = NULL;

    if (SUCCEEDED(RetrieveProviderRecord(&pRecord, &pLogicalConsumer)))
    {
        CTemplateReleaseMe<CConsumerProviderRecord> rm1(pRecord);
        CReleaseMe rm2(pLogicalConsumer);
        
        //
        // Report the MSFT_WmiConsumerProviderSinkUnloaded event.
        //
        pRecord->FireNCSinkEvent(
            MSFT_WmiConsumerProviderSinkUnloaded,
            pLogicalConsumer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\poller.h ===
//******************************************************************************
//
//  POLLER.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_POLLER__H_
#define __WBEM_POLLER__H_

#include <tss.h>
#include <wbemcomn.h>
#include <map>
#include <analyser.h>
#include <evsink.h>

#pragma warning(disable: 4786)
class CEssNamespace;

class CBasePollingInstruction : public CTimerInstruction
{
public:
    void AddRef();
    void Release();
    int GetInstructionType() {return INSTTYPE_INTERNAL;}

    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const;
    virtual CWbemTime GetFirstFiringTime() const;
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);

    bool DeleteTimer();

public:
    CBasePollingInstruction(CEssNamespace* pNamespace);
    virtual ~CBasePollingInstruction();

    HRESULT Initialize(LPCWSTR wszLanguage, 
                        LPCWSTR wszQuery, DWORD dwMsInterval,
                        bool bAffectsQuota = false);

    void Cancel();

protected:
    long m_lRef;

    CEssNamespace* m_pNamespace;
    BSTR m_strLanguage;
    BSTR m_strQuery;
    CWbemInterval m_Interval;
    IServerSecurity* m_pSecurity;
    bool m_bUsedQuota;
    bool m_bCancelled;
    HANDLE m_hTimer;
    CCritSec m_cs;
    
protected:
    HRESULT ExecQuery();

    virtual HRESULT ProcessObject(_IWmiObject* pObj) = 0;
    virtual HRESULT ProcessQueryDone(HRESULT hresQuery, 
                                     IWbemClassObject* pError) = 0;
    virtual BOOL CompareTo(CBasePollingInstruction* pOther);
    static void staticTimerCallback(void* pParam, BOOLEAN);
    void Destroy();
};

class CPollingInstruction : public CBasePollingInstruction
{
public:
    CPollingInstruction(CEssNamespace* pNamespace);
    ~CPollingInstruction();

    HRESULT Initialize(LPCWSTR wszLanguage, 
                        LPCWSTR wszQuery, DWORD dwMsInterval, 
                        DWORD dwEventMask, 
                        CEventFilter* pDest);
    HRESULT FirstExecute();

protected:
    DWORD m_dwEventMask;
    CEventFilter* m_pDest;
    bool m_bOnRestart;
    void* m_pUser;
    

    struct CCachedObject
    {
        BSTR m_strPath;
        _IWmiObject* m_pObject;
    
        CCachedObject(_IWmiObject* pObject);
        ~CCachedObject();
        BOOL IsValid(){    return (NULL != m_strPath); };
        static int __cdecl compare(const void* pelem1, const void* pelem2);
    };

    typedef CUniquePointerArray<CCachedObject> CCachedArray;
    CCachedArray* m_papPrevObjects;
    CCachedArray* m_papCurrentObjects;

    friend class CPoller;
protected:
    HRESULT RaiseCreationEvent(CCachedObject* pNewObj);
    HRESULT RaiseDeletionEvent(CCachedObject* pOldObj);
    HRESULT RaiseModificationEvent(CCachedObject* pNewObj, 
                                   CCachedObject* pOldObj = NULL);
    static SYSFREE_ME BSTR GetObjectClass(CCachedObject* pObj);

    HRESULT ProcessObject(_IWmiObject* pObj);
    HRESULT ProcessQueryDone(HRESULT hresQuery, 
                                     IWbemClassObject* pError);
    HRESULT SubtractMemory(CCachedArray* pArray);
    HRESULT ResetPrevious();
    DWORD ComputeObjectMemory(_IWmiObject* pObj);
};

class CEventFilterContainer;

class CPoller
{
public:
    CPoller(CEssNamespace* pEssNamespace);
    ~CPoller();
    void Clear();

    HRESULT ActivateFilter(CEventFilter* pDest, 
                LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp);
    HRESULT DeactivateFilter(CEventFilter* pDest);
    HRESULT VirtuallyStopPolling();
    HRESULT CancelUnnecessaryPolling();

    void DumpStatistics(FILE* f, long lFlags);

protected:
    CEssNamespace* m_pNamespace;
    CQueryAnalyser m_Analyser;
    BOOL m_bInResync;
    CCritSec m_cs;
    
    struct FilterInfo
    {
        BOOL m_bActive;
        DWORD_PTR m_dwFilterId;
    };

    typedef std::map<CPollingInstruction*, FilterInfo, std::less<CPollingInstruction*>, 
                     wbem_allocator<FilterInfo> > CInstructionMap;
    CInstructionMap m_mapInstructions;

    friend class CKeyTest;
    class CKeyTest : public CInstructionTest
    {
        DWORD_PTR m_dwKey;
        CInstructionMap& m_mapInstructions;
    public:
        CKeyTest(DWORD_PTR dwKey, CInstructionMap& mapInstructions) 
            : m_dwKey(dwKey), m_mapInstructions(mapInstructions)
        {}
    
        BOOL operator()(CTimerInstruction* pToTest) 
        {
            CInstructionMap::iterator it = 
                m_mapInstructions.find((CPollingInstruction*)pToTest);
            if(it == m_mapInstructions.end())
                return FALSE;            
            if ( !it->second.m_bActive && m_dwKey == 0xFFFFFFFF )
                return TRUE;
            return (it->second.m_dwFilterId == m_dwKey);
        }
    };
protected:
    HRESULT AddInstruction(DWORD_PTR dwKey, CPollingInstruction* pInst);

    HRESULT ListNonProvidedClasses(IN CClassInformation* pInfo,
                                   IN DWORD dwDesiredMask,
                                   OUT CClassInfoArray& aNonProvided);
    BOOL IsClassDynamic(IWbemClassObject* pClass);
    BOOL AddDynamicClass(IWbemClassObject* pClass, DWORD dwDesiredMask, 
                              OUT CClassInfoArray& aNonProvided);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\permfilt.h ===
//=============================================================================
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  STDTRIG.H
//
//  This files defines the classes for event filters corresponding to standard
//  event filters the users will create
//
//  Classes defined:
//
//      CBuiltinEventFilter         Base class for standard filters
//
//  History:
//
//  11/27/96    a-levn      Compiles
//
//=============================================================================

#ifndef __BUILTIN_FILTER__H_
#define __BUILTIN_FILTER__H_

#include "eventrep.h"
#include "binding.h"
#include "aggreg.h"
#include "filter.h"

class CEssNamespace;
class CPermanentFilter : public CGenericFilter
{
protected:
    CCompressedString* m_pcsQuery;
    CInternalString m_isEventNamespace;

    PSECURITY_DESCRIPTOR m_pEventAccessRelativeSD;
    SECURITY_DESCRIPTOR m_EventAccessAbsoluteSD;

    static long mstatic_lNameHandle;
    static long mstatic_lLanguageHandle;
    static long mstatic_lQueryHandle;
    static long mstatic_lEventNamespaceHandle;
    static long mstatic_lEventAccessHandle;
    static long mstatic_lSidHandle;
    static bool mstatic_bHandlesInitialized;
    static long mstatic_lGuardNamespaceHandle;
    static long mstatic_lGuardHandle;

    static HRESULT InitializeHandles(_IWmiObject* pObject);
protected:
    static SYSFREE_ME BSTR GetBSTR(READ_ONLY IWbemClassObject* pObject, 
        READ_ONLY LPWSTR wszName);
    HRESULT RetrieveQuery(DELETE_ME LPWSTR& wszQuery);

public:
    CPermanentFilter(CEssNamespace* pNamespace);
    HRESULT Initialize(IWbemClassObject* pFilterObj);

    virtual ~CPermanentFilter();

    BOOL IsPermanent() {return TRUE;}
    virtual HRESULT SetThreadSecurity() {return S_OK;}
    HRESULT ObtainToken(IWbemToken** ppToken);

    virtual const PSECURITY_DESCRIPTOR GetEventAccessSD();

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp);
    virtual DWORD GetForceFlags() {return 0;}
    virtual HRESULT GetEventNamespace(DELETE_ME LPWSTR* pwszNamespace);
    static SYSFREE_ME BSTR ComputeKeyFromObj(IWbemClassObject* pFilterObj);
    static SYSFREE_ME BSTR ComputeKeyFromPath(LPCWSTR wszPath);
    static HRESULT CheckValidity( IWbemClassObject* pFilterObj);

    void Park();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\postpone.cpp ===
//******************************************************************************
//
//  POSTPONE.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <ess.h>
#include <postpone.h>

HRESULT CPostponedList::AddRequest( CEssNamespace* pNamespace,
                                    ACQUIRE CPostponedRequest* pReq )
{
    if ( pReq->DoesHoldTurn() )
    {
        m_cTurnsHeld++;
    }

    pReq->SetNamespace( pNamespace );

    if(!m_qpRequests.Enqueue(pReq))
        return WBEM_E_OUT_OF_MEMORY;
    else
        return WBEM_S_NO_ERROR;
}

HRESULT CPostponedList::Execute(CEssNamespace* pNamespace, 
                                EPostponedExecuteFlags eFlags,
                                DELETE_ME CPostponedRequest** ppFailed)
{
    if(ppFailed)
        *ppFailed = NULL;

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    while(m_qpRequests.GetQueueSize())
    {
        // Retrieve and remove the next request
        // ====================================

        CPostponedRequest* pReq = m_qpRequests.Dequeue();

        if ( pReq->DoesHoldTurn() )
        {
            _DBG_ASSERT( m_cTurnsHeld > 0 );
            m_cTurnsHeld--;
        }

        //
        // see if the namespace that postponed the request is different 
        // from the one executing it.  If it is, this is very bad. This
        // can happen in (faulty) cross namespace logic when one namespace is
        // executing an operation in the other,  normally while holding 
        // its own ns lock, and then the other fires the postponed 
        // operations for itself and the original namespace which surely 
        // was not intended.  Some requests aren't namespace specific, so
        // it we don't do the check for these.
        //
        _DBG_ASSERT( pReq->GetNamespace() == NULL || 
                     pReq->GetNamespace() == pNamespace );

        // Execute it
        // ==========

        HRESULT hres = pReq->Execute(pNamespace);
        if(FAILED(hres))
        {
            if(eFlags == e_StopOnFailure)
            {
                // Return the request and the error
                // ================================

                if(ppFailed)
                    *ppFailed = pReq;
                else
                    delete pReq;
                return hres;
            }
            else
            {
                // Record the request and the error
                // ================================

                if(ppFailed)
                {
                    delete *ppFailed;
                    *ppFailed = pReq;
                }
                else
                    delete pReq;

                if(SUCCEEDED(hresGlobal))
                    hresGlobal = hres;
            }
        }
        else
        {
            delete pReq;
        }
    }

    return hresGlobal;
}

HRESULT CPostponedList::Clear()
{
    m_qpRequests.Clear();
    m_cTurnsHeld = 0;
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\poller.cpp ===
//******************************************************************************
//
//  POLLER.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include <cominit.h>
#include <callsec.h>
#include "Quota.h"

long g_lNumPollingCachedObjects = 0;
long g_lNumPollingInstructions = 0;

// {2ECF39D0-2B26-11d2-AEC8-00C04FB68820}
const GUID IID_IWbemCallSecurity = {
0x2ecf39d0, 0x2b26, 0x11d2, {0xae, 0xc8, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20}};

void CBasePollingInstruction::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CBasePollingInstruction::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0) 
    {
        if(DeleteTimer())
        {
            delete this;
        }
        else
        {
            //
            // Deep trouble --- cannot delete timer, so it will execute again.
            // This means I must leak this instruction (to prevent a crash)
            //
        }
    }
}

CBasePollingInstruction::CBasePollingInstruction(CEssNamespace* pNamespace)
    : m_pNamespace(pNamespace), m_strLanguage(NULL), m_strQuery(NULL),
        m_pSecurity(NULL), m_lRef(0), m_bUsedQuota(false),
        m_bCancelled(false), m_hTimer(NULL)
{
    pNamespace->AddRef();
}

CBasePollingInstruction::~CBasePollingInstruction()
{
    Destroy();
}

void CBasePollingInstruction::Destroy()
{
    //
    // The timer is guaranteed to have been deleted by the Release
    //

    _DBG_ASSERT(m_hTimer == NULL);

    if(m_pNamespace)
        m_pNamespace->Release();

    SysFreeString(m_strLanguage);
    SysFreeString(m_strQuery);

    if (m_bUsedQuota)
    {
        if (m_pSecurity)
            m_pSecurity->ImpersonateClient();

        g_quotas.DecrementQuotaIndex(
            ESSQ_POLLING_INSTRUCTIONS,
            NULL,
            1);

        if (m_pSecurity)
            m_pSecurity->RevertToSelf();
    }

    if(m_pSecurity)
        m_pSecurity->Release();
}

bool CBasePollingInstruction::DeleteTimer()
{
    HANDLE hTimer = NULL;

    {
        CInCritSec ics(&m_cs);
        
        hTimer = m_hTimer;
        m_bCancelled = true;
    }

    if(hTimer)
    {
        if(!DeleteTimerQueueTimer(NULL, hTimer, INVALID_HANDLE_VALUE))
        {
            return false;
        }
        m_hTimer = NULL; // no need for cs --- it's cancelled!
    }

    return true;
}

CWbemTime CBasePollingInstruction::GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const
{
    *plFiringCount = 1;

    CWbemTime Next = LastFiringTime + m_Interval;
    if(Next < CWbemTime::GetCurrentTime())
    {
        // We missed a poll. No problem --- reschedule for later
        // =====================================================

        return CWbemTime::GetCurrentTime() + m_Interval;
    }
    else
    {
        return Next;
    }
}

CWbemTime CBasePollingInstruction::GetFirstFiringTime() const
{
    // The first time is a random function of the interval
    // ===================================================

    double dblFrac = (double)rand() / RAND_MAX;
    return CWbemTime::GetCurrentTime() + m_Interval * dblFrac;
}

HRESULT CBasePollingInstruction::Initialize(LPCWSTR wszLanguage, 
                                        LPCWSTR wszQuery, DWORD dwMsInterval,
                                        bool bAffectsQuota)
{
    m_strLanguage = SysAllocString(wszLanguage);
    m_strQuery = SysAllocString(wszQuery);
    if(m_strLanguage == NULL || m_strQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_Interval.SetMilliseconds(dwMsInterval);
    
    //
    // Retrieve the current security object.  Even though it is ours, we cannot
    // keep it, since it is shared by other threads
    //
    
    HRESULT hres = WBEM_S_NO_ERROR;

    m_pSecurity = CWbemCallSecurity::MakeInternalCopyOfThread();

    if (bAffectsQuota)
    {
        if ( m_pSecurity )
        {
            hres = m_pSecurity->ImpersonateClient();


            if ( FAILED(hres) )
            {
                ERRORTRACE((LOG_ESS, "Polling instruction for query %S failed "
                            "to impersonate client during initialization.\n",
                             wszQuery ));
                return hres;
            }
        }

        hres = 
            g_quotas.IncrementQuotaIndex(
                ESSQ_POLLING_INSTRUCTIONS,
                NULL,
                1);

        if (m_pSecurity)
            m_pSecurity->RevertToSelf();

        if (SUCCEEDED(hres))
            m_bUsedQuota = true;
    }

    return hres;
}

void CBasePollingInstruction::staticTimerCallback(void* pParam, BOOLEAN)
{
    CBasePollingInstruction* pInst = (CBasePollingInstruction*)pParam;

    try
    {
        pInst->ExecQuery();
    }
    catch( CX_MemoryException )
    {
    }

    // 
    // Reschedule the timer, if needed
    //

    {
        CInCritSec ics(&pInst->m_cs);

        //
        // First, check if the instruction has been cancelled
        //

        if(pInst->m_bCancelled)
            return;

        //
        // Delete ourselves
        //

        _DBG_ASSERT(pInst->m_hTimer != NULL);

        DeleteTimerQueueTimer(NULL, pInst->m_hTimer, NULL);

        CreateTimerQueueTimer(&pInst->m_hTimer, NULL, 
                                (WAITORTIMERCALLBACK)&staticTimerCallback, 
                                pParam,
                                pInst->m_Interval.GetMilliseconds(),
                                0, 
                                WT_EXECUTELONGFUNCTION);
    }
}
    
HRESULT CBasePollingInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    return ExecQuery();
}

void CBasePollingInstruction::Cancel()
{
    m_bCancelled = true;
}

HRESULT CBasePollingInstruction::ExecQuery()
{
    HRESULT hres;

    // Impersonate
    // ===========

    if(m_pSecurity)
    {
        hres = m_pSecurity->ImpersonateClient();
        if(FAILED(hres) && (hres != E_NOTIMPL))
        {
            ERRORTRACE((LOG_ESS, "Impersonation failed with error code %X for "
                "polling query %S.  Will retry at next polling interval\n",
                hres, m_strQuery));
            return hres;
        }
    }

    // Execute the query synchrnously (TBD: async would be better)
    // ==============================

    IWbemServices* pServices = NULL;
    hres = m_pNamespace->GetNamespacePointer(&pServices);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pServices);
    
    DEBUGTRACE((LOG_ESS, "Executing polling query '%S' in namespace '%S'\n",
                m_strQuery, m_pNamespace->GetName()));

    IEnumWbemClassObject* pEnum;
    hres = pServices->ExecQuery(m_strLanguage, m_strQuery, 
                        WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY |
                        WBEM_FLAG_KEEP_SHAPE, 
                                            GetCurrentEssContext(), &pEnum);
    if(m_pSecurity)
        m_pSecurity->RevertToSelf();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Polling query %S failed with error code %X.  "
            "Will retry at next polling interval\n", m_strQuery, hres));
        return hres;
    }
    CReleaseMe rm2(pEnum);

    // Get the results into an array
    // =============================

    IWbemClassObject* aBuffer[100];
    DWORD dwNumRet;
    while(1)
    {
        hres = pEnum->Next(1000, 100, aBuffer, &dwNumRet);
        if(FAILED(hres))
            break;

        bool bDone = false;
        if(hres == WBEM_S_FALSE)
            bDone = true;

        //
        // Check if this query has been cancelled
        //

        if(m_bCancelled)
        {
            DEBUGTRACE((LOG_ESS, "Aborting polling query '%S' because its "
                "subscription is cancelled\n", m_strQuery));
            return WBEM_E_CALL_CANCELLED;
        }

        for(DWORD dw = 0; dw < dwNumRet; dw++)
        {
            _IWmiObject* pObj = NULL;
            aBuffer[dw]->QueryInterface(IID__IWmiObject, (void**)&pObj);
            CReleaseMe rm(pObj);

            hres = ProcessObject(pObj);
            
            if(FAILED(hres))
                break;
        }

        for( dw=0; dw < dwNumRet; dw++ )
        {
            aBuffer[dw]->Release();
        }

        if(dw < dwNumRet || FAILED(hres))
            break;

        if(bDone)
            break;
    }

    ProcessQueryDone(hres, NULL);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Polling query '%S' failed with error code 0x%X.  "
            "Will retry at next polling interval\n", m_strQuery, hres));
        return hres;
    }
    else
    {
        DEBUGTRACE((LOG_ESS, "Polling query '%S' done\n", m_strQuery));
    }

    return WBEM_S_NO_ERROR;
}
    
BOOL CBasePollingInstruction::CompareTo(CBasePollingInstruction* pOther)
{
    if(wcscmp(pOther->m_strLanguage, m_strLanguage)) return FALSE;
    if(wcscmp(pOther->m_strQuery, m_strQuery)) return FALSE;
    if(pOther->m_Interval.GetMilliseconds() != m_Interval.GetMilliseconds())
        return FALSE;

    return TRUE;
}

//***************************************************************************
//***************************************************************************
//***************************************************************************

CPollingInstruction::CCachedObject::CCachedObject(_IWmiObject* pObject)
    : m_pObject(pObject), m_strPath(NULL)
{
    g_lNumPollingCachedObjects++;
    
    // Extract the path
    // ================

    VARIANT v;
    VariantInit(&v);
    if (SUCCEEDED(pObject->Get(L"__RELPATH", 0, &v, NULL, NULL)))
        m_strPath = V_BSTR(&v);
    // Variant intentionally not cleared
    pObject->AddRef();
}

CPollingInstruction::CCachedObject::~CCachedObject()
{
    g_lNumPollingCachedObjects--;

    if(m_pObject)
        m_pObject->Release();
    SysFreeString(m_strPath);
}

int __cdecl CPollingInstruction::CCachedObject::compare(const void* pelem1, 
                                                        const void* pelem2)
{
    CCachedObject* p1 = *(CCachedObject**)pelem1;
    CCachedObject* p2 = *(CCachedObject**)pelem2;

    return wbem_wcsicmp(p1->m_strPath, p2->m_strPath);
}

CPollingInstruction::CPollingInstruction(CEssNamespace* pNamespace)
: CBasePollingInstruction(pNamespace), m_papCurrentObjects(NULL),
  m_dwEventMask(0), m_pDest(NULL),  m_papPrevObjects(NULL), m_pUser(NULL)
{
    g_lNumPollingInstructions++;
}

CPollingInstruction::~CPollingInstruction()
{
    g_lNumPollingInstructions--;

    SubtractMemory(m_papCurrentObjects);
    delete m_papCurrentObjects;

    ResetPrevious();

    if(m_pDest)
        m_pDest->Release();

    if(m_pUser)
        g_quotas.FreeUser(m_pUser);
}

// This class represents a postponed request to execute a query
class CPostponedQuery : public CPostponedRequest
{
protected:
    CPollingInstruction* m_pInst;

public:
    CPostponedQuery(CPollingInstruction* pInst) : m_pInst(pInst)
    {
        m_pInst->AddRef();
    }
    ~CPostponedQuery()
    {
        m_pInst->Release();
    }
    
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        return m_pInst->FirstExecute();
    }
};

HRESULT CPollingInstruction::FirstExecute()
{
    //
    // Check if our filter has any hope
    //

    if(FAILED(m_pDest->GetPollingError()))
    {
        DEBUGTRACE((LOG_ESS, "Polling query '%S' will not be attempted as \n"
            "another polling query related to the same subscription has failed "
            "to start with error code 0x%X, deactivating subscription\n", 
            m_strQuery, m_pDest->GetPollingError()));
        return m_pDest->GetPollingError();
    }

    if(m_bCancelled)
    {
        DEBUGTRACE((LOG_ESS, "Aborting polling query '%S' because its "
            "subscription is cancelled\n", m_strQuery));
        return WBEM_E_CALL_CANCELLED;
    }

    // note that if this function fails, then it will be destroyed when 
    // the postponed query releases it reference.  If this function succeedes
    // then tss will hold onto a reference and keep it alive.
    //

    m_papCurrentObjects = _new CCachedArray;
    
    if( m_papCurrentObjects == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hres = ExecQuery();

    if ( FAILED(hres) )
    {
        ERRORTRACE((LOG_ESS, "Polling query '%S' failed on the first try with "
            "error code 0x%X.\nDeactivating subscription\n", m_strQuery, hres));
        m_pDest->SetPollingError(hres);
        return hres;
    }

    //
    // add this instruction to the scheduler
    //
   
    if(!CreateTimerQueueTimer(&m_hTimer, NULL, 
                                (WAITORTIMERCALLBACK)&staticTimerCallback, 
                                (void*)(CBasePollingInstruction*)this,
                                m_Interval.GetMilliseconds(), 
                                0, 
                                WT_EXECUTELONGFUNCTION))
    {
        long lRes = GetLastError();
        ERRORTRACE((LOG_ESS, "ESS is unable to schedule a timer instruction "
            "with the system (error code %d).  This operation will be "
            "aborted.\n", lRes));
    
        return WBEM_E_FAILED;
    }
        
    return WBEM_S_NO_ERROR;
}

HRESULT CPollingInstruction::Initialize(LPCWSTR wszLanguage, LPCWSTR wszQuery, 
                        DWORD dwMsInterval, DWORD dwEventMask, 
                        CEventFilter* pDest)
{
    HRESULT hres;

    hres = CBasePollingInstruction::Initialize(wszLanguage, wszQuery, 
                                                dwMsInterval);
    if(FAILED(hres))
        return hres;

    m_dwEventMask = dwEventMask;

    m_pDest = pDest;
    pDest->AddRef();

    hres = g_quotas.FindUser(pDest, &m_pUser);
    if(FAILED(hres))
        return hres;
    
    return WBEM_S_NO_ERROR;
}

HRESULT CPollingInstruction::ProcessObject(_IWmiObject* pObj)
{
    HRESULT hres;

    //
    // Make sure that the current object list exists
    //

    if(m_papCurrentObjects == NULL)
    {
        m_papCurrentObjects = new CCachedArray;
        if(m_papCurrentObjects == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Check if this query has been cancelled
    //

    if(m_bCancelled)
    {
        DEBUGTRACE((LOG_ESS, "Aborting polling query '%S' because its "
            "subscription is cancelled\n", m_strQuery));
        return WBEM_E_CALL_CANCELLED;
    }

    //
    // Check quotas
    //

    DWORD dwSize = ComputeObjectMemory(pObj);

    hres = g_quotas.IncrementQuotaIndexByUser(ESSQ_POLLING_MEMORY,
                            m_pUser, dwSize);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Aborting polling query '%S' because the quota "
            "for memory used by polling is exceeded\n", m_strQuery));
        return hres;
    }

    //
    // Add the object to the current list
    //

    CCachedObject* pRecord = _new CCachedObject(pObj);
    if(pRecord == NULL || !pRecord->IsValid())
    {
        delete pRecord;
        return WBEM_E_OUT_OF_MEMORY;
    }


    if(m_papCurrentObjects->Add(pRecord) < 0)
    {
        delete pRecord;
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    return WBEM_S_NO_ERROR;
}

DWORD CPollingInstruction::ComputeObjectMemory(_IWmiObject* pObj)
{
    DWORD dwSize = 0;
    HRESULT hres = pObj->GetObjectMemory( NULL, 0, &dwSize );
    
    if (FAILED(hres) && hres != WBEM_E_BUFFER_TOO_SMALL )
    {
        return hres;
    }
    
    return dwSize;
}

HRESULT CPollingInstruction::ProcessQueryDone( HRESULT hresQuery, 
                                               IWbemClassObject* pErrorObj)
{
    HRESULT hres;

    if(FAILED(hresQuery))
    {
        //
        // If the query failed, retain the previous poll 
        // result --- that's the best we can do
        //

        SubtractMemory(m_papCurrentObjects);
        delete m_papCurrentObjects;
        m_papCurrentObjects = NULL;

        //
        // Report subscription error
        //

        return WBEM_S_FALSE;
    }
    else if ( m_papCurrentObjects == NULL )
    {
        //
        // Query came back empty --- emulate by creating an empty 
        // m_papCurrentObjects
        //

        m_papCurrentObjects = new CCachedArray;
        if(m_papCurrentObjects == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
                
    //
    // Sort the objects by path
    // 

    qsort((void*)m_papCurrentObjects->GetArrayPtr(), 
          m_papCurrentObjects->GetSize(), 
          sizeof(CCachedObject*), CCachedObject::compare);

    //
    // At this point, m_papCurrentObjects contains the sorted results of the
    // current query. If this is not the first time, m_papPrevObjects 
    // contains the previous result.  If first time, then all done for now.
    //

    if( m_papPrevObjects == NULL )
    {
        m_papPrevObjects = m_papCurrentObjects;
        m_papCurrentObjects = NULL;
        return WBEM_S_NO_ERROR;
    }

    //
    // Now is the time to compare
    //

    long lOldIndex = 0, lNewIndex = 0;

    while(lNewIndex < m_papCurrentObjects->GetSize() && 
          lOldIndex < m_papPrevObjects->GetSize())
    {
        int nCompare = wbem_wcsicmp(
                              m_papCurrentObjects->GetAt(lNewIndex)->m_strPath,
                              m_papPrevObjects->GetAt(lOldIndex)->m_strPath);
        if(nCompare < 0)
        {
            // The _new object is not in the old array --- object created
            // =========================================================

            if(m_dwEventMask & (1 << e_EventTypeInstanceCreation))
            {
                RaiseCreationEvent(m_papCurrentObjects->GetAt(lNewIndex));
            }
            lNewIndex++;
        }
        else if(nCompare > 0)
        {
            // The old object is not in the _new array --- object deleted
            // =========================================================
                
            if(m_dwEventMask & (1 << e_EventTypeInstanceDeletion))
            {
                RaiseDeletionEvent(m_papPrevObjects->GetAt(lOldIndex));
            }
            lOldIndex++;
        }
        else
        {
            if(m_dwEventMask & (1 << e_EventTypeInstanceModification))
            {
                // Compare the objects themselves
                // ==============================

                hres = m_papCurrentObjects->GetAt(lNewIndex)->m_pObject->
                    CompareTo(
                        WBEM_FLAG_IGNORE_CLASS | WBEM_FLAG_IGNORE_OBJECT_SOURCE,
                        m_papPrevObjects->GetAt(lOldIndex)->m_pObject);
                if(hres != S_OK)
                {
                    // The objects are not the same --- object changed
                    // ===============================================
        
                    RaiseModificationEvent(
                        m_papCurrentObjects->GetAt(lNewIndex),
                        m_papPrevObjects->GetAt(lOldIndex));
                }
            }
            lOldIndex++; lNewIndex++;
        }
    }
    
    if(m_dwEventMask & (1 << e_EventTypeInstanceDeletion))
    {
        while(lOldIndex < m_papPrevObjects->GetSize())
        {
            RaiseDeletionEvent(m_papPrevObjects->GetAt(lOldIndex));
            lOldIndex++;
        }
    }

    if(m_dwEventMask & (1 << e_EventTypeInstanceCreation))
    {
        while(lNewIndex < m_papCurrentObjects->GetSize())
        {
            RaiseCreationEvent(m_papCurrentObjects->GetAt(lNewIndex));
            lNewIndex++;
        }
    }

    // Replace the cached array with the new one
    // =========================================

    ResetPrevious();

    m_papPrevObjects = m_papCurrentObjects;
    m_papCurrentObjects = NULL;

    return S_OK;
}
    
HRESULT CPollingInstruction::RaiseCreationEvent(CCachedObject* pNewObj)
{
    IWbemClassObject* _pObj = pNewObj->m_pObject;

    CEventRepresentation Event;
    Event.type = e_EventTypeInstanceCreation;
    Event.wsz1 = (LPWSTR)m_pNamespace->GetName();
    Event.wsz2 = GetObjectClass(pNewObj);
    Event.wsz3 = NULL;
    Event.nObjects = 1;
    Event.apObjects = &_pObj;
    
    IWbemEvent* pEventObj;
    if(FAILED(Event.MakeWbemObject(m_pNamespace, &pEventObj)))
        return WBEM_E_OUT_OF_MEMORY;

    // BUGBUG: context
    HRESULT hres = m_pDest->Indicate(1, &pEventObj, NULL);
    pEventObj->Release();
    SysFreeString(Event.wsz2);
    return hres;
}

HRESULT CPollingInstruction::RaiseDeletionEvent(CCachedObject* pOldObj)
{
    IWbemClassObject* _pObj = pOldObj->m_pObject;

    CEventRepresentation Event;
    Event.type = e_EventTypeInstanceDeletion;
    Event.wsz1 = (LPWSTR)m_pNamespace->GetName();
    Event.wsz2 = GetObjectClass(pOldObj);
    Event.wsz3 = NULL;
    Event.nObjects = 1;
    Event.apObjects = &_pObj;

    IWbemEvent* pEventObj;
    if(FAILED(Event.MakeWbemObject(m_pNamespace, &pEventObj)))
        return WBEM_E_OUT_OF_MEMORY;

    // BUGBUG: context
    HRESULT hres = m_pDest->Indicate(1, &pEventObj, NULL);
    pEventObj->Release();
    SysFreeString(Event.wsz2);
    return hres;
}
    
HRESULT CPollingInstruction::RaiseModificationEvent(CCachedObject* pNewObj,
                                                    CCachedObject* pOldObj)
{
    IWbemClassObject* apObjects[2];

    CEventRepresentation Event;
    Event.type = e_EventTypeInstanceModification;
    Event.wsz1 = (LPWSTR)m_pNamespace->GetName();
    Event.wsz2 = GetObjectClass(pNewObj);
    Event.wsz3 = NULL;
    Event.nObjects = 2;
    Event.apObjects = (IWbemClassObject**)apObjects;
    Event.apObjects[0] = pNewObj->m_pObject;
    Event.apObjects[1] = (pOldObj?pOldObj->m_pObject:NULL);

    IWbemEvent* pEventObj;
    if(FAILED(Event.MakeWbemObject(m_pNamespace, &pEventObj)))
        return WBEM_E_OUT_OF_MEMORY;

    // BUGBUG: context
    HRESULT hres = m_pDest->Indicate(1, &pEventObj, NULL);
    pEventObj->Release();
    SysFreeString(Event.wsz2);
    return hres;
}

HRESULT CPollingInstruction::ResetPrevious()
{
    HRESULT hres;

    SubtractMemory(m_papPrevObjects);

    delete m_papPrevObjects;
    m_papPrevObjects = NULL;
    
    return S_OK;
}

HRESULT CPollingInstruction::SubtractMemory(CCachedArray* pArray)
{
    HRESULT hres;

    if(pArray == NULL)
        return S_FALSE;

    for(int i = 0; i < pArray->GetSize(); i++)
    {
        _IWmiObject* pObj = pArray->GetAt(i)->m_pObject;

        DWORD dwSize = ComputeObjectMemory(pObj);
        hres = g_quotas.DecrementQuotaIndexByUser(ESSQ_POLLING_MEMORY,
                                m_pUser, dwSize);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}


SYSFREE_ME BSTR CPollingInstruction::GetObjectClass(CCachedObject* pObj)
{
    VARIANT v;
    VariantInit(&v);
    if ( FAILED( pObj->m_pObject->Get(L"__CLASS", 0, &v, NULL, NULL) ) )
    {
        return NULL;
    }
    return V_BSTR(&v);
}

//*****************************************************************************
//*****************************************************************************
//
//                      P o l l e r
//
//*****************************************************************************
//*****************************************************************************

CPoller::CPoller(CEssNamespace* pNamespace)         
    : m_pNamespace(pNamespace), m_bInResync(FALSE)
{
}

CPoller::~CPoller()
{
}

void CPoller::Clear()
{
    CInstructionMap::iterator it = m_mapInstructions.begin(); 
    while(it != m_mapInstructions.end())
    {
        // Release the refcount this holds on the instructioin
        // ===================================================

        it->first->Cancel();
        it->first->DeleteTimer();
        it->first->Release();
        it = m_mapInstructions.erase(it);
    }
}
    
HRESULT CPoller::ActivateFilter(CEventFilter* pDest, 
                LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExpr)
{
    // Check what kind of events it is looking for
    // ===========================================

    DWORD dwEventMask = CEventRepresentation::GetTypeMaskFromName(
                            pExpr->bsClassName);

    if((dwEventMask & 
        ((1 << e_EventTypeInstanceCreation) | 
         (1 << e_EventTypeInstanceDeletion) |
         (1 << e_EventTypeInstanceModification)
        )
       ) == 0
      )
    {
        // This registration does not involve instance-related events and
        // therefore there is no polling involved
        // ==============================================================
        
        return WBEM_S_FALSE;
    }

    // The query is looking for instance-change events. See what classes 
    // of objects it is interested in.
    // =================================================================

    CClassInfoArray* paInfos;
    HRESULT hres = m_Analyser.GetPossibleInstanceClasses(pExpr, paInfos);
    if(FAILED(hres)) return hres;
    CDeleteMe<CClassInfoArray> dm2(paInfos);

    if(!paInfos->IsLimited())
    {
        // Analyser could not find any limits on the possible classes.
        // Rephrase that as all children of ""
        // ===========================================================

        CClassInformation* pNewInfo = _new CClassInformation;
        if(pNewInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pNewInfo->m_wszClassName = NULL;
        pNewInfo->m_bIncludeChildren = TRUE;
        paInfos->AddClass(pNewInfo);

        paInfos->SetLimited(TRUE);
    }


    // See if it is looking for any dynamic classes.
    // =============================================
    for(int i = 0; i < paInfos->GetNumClasses(); i++)
    {
        CClassInfoArray aNonProvided;
        hres = ListNonProvidedClasses(
                            paInfos->GetClass(i), dwEventMask, aNonProvided);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,"Failed searching for classes to poll.\n"
                "Class name: %S, Error code: %X\n\n", 
                paInfos->GetClass(i)->m_wszClassName, hres));
            
            return hres;
        }


        // Increment our quotas if necessary.
        DWORD nClasses = aNonProvided.GetNumClasses();

        if (nClasses)
        {
            if (FAILED(hres = g_quotas.IncrementQuotaIndex(
                                   ESSQ_POLLING_INSTRUCTIONS, pDest, nClasses)))
            {
                return hres;
            }
        }


        // Institute polling for each class
        // ================================
        for(int j = 0; j < nClasses; j++)
        {
            // We have an instance-change event registration where dynamic 
            // instances are involved. Check if tolerance is specified
            // ===========================================================
    
            if(pExpr->Tolerance.m_bExact || 
                pExpr->Tolerance.m_fTolerance == 0)
            {
                return WBEMESS_E_REGISTRATION_TOO_PRECISE;
            }
        
            // Tolerance is there. Get the right query for this class
            // ======================================================

            LPWSTR wszThisQuery = NULL;
            hres = m_Analyser.GetLimitingQueryForInstanceClass(
                        pExpr, *aNonProvided.GetClass(j), wszThisQuery);
            CVectorDeleteMe<WCHAR> vdm1(wszThisQuery);

            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS,"ERROR: Limiting query extraction failed.\n"
                    "Original query: %S\nClass: %S\nError code: %X\n",
                    wszQuery, aNonProvided.GetClass(j)->m_wszClassName, hres));
                return hres;
            }

            DEBUGTRACE((LOG_ESS,"Instituting polling query %S to satisfy event"
                       " query %S\n", wszThisQuery, wszQuery));
    
            DWORD dwMs = pExpr->Tolerance.m_fTolerance * 1000;

            CWbemPtr<CPollingInstruction> pInst;
            pInst = _new CPollingInstruction(m_pNamespace);

            if(pInst == NULL)
                return WBEM_E_OUT_OF_MEMORY;
    
            hres = pInst->Initialize( L"WQL", 
                                      wszThisQuery, 
                                      dwMs, 
                                      aNonProvided.GetClass(j)->m_dwEventMask,
                                      pDest);
            if ( SUCCEEDED(hres) )
            {
                hres = AddInstruction( (DWORD_PTR)pDest, pInst );
            }

            if ( FAILED(hres) )
            {
                ERRORTRACE((LOG_ESS,
                    "ERROR: Polling instruction initialization failed\n"
                    "Query: %S\nError code: %X\n\n", wszThisQuery, hres));
                return hres;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CPoller::AddInstruction( DWORD_PTR dwKey, CPollingInstruction* pInst )
{
    HRESULT hr;
    CInCritSec ics(&m_cs);

    if( m_bInResync )
    {
        // Search for the instruction in the map
        // =====================================

        CInstructionMap::iterator it;
        for( it=m_mapInstructions.begin(); it != m_mapInstructions.end(); it++)
        {
            //
            // if the filter key is the same and the instructions have the 
            // same queries, then there is a match.  It is not enough to 
            // do just the filter key, since there can be multiple instructions
            // per filter, and it is not enough to do just the instruction 
            // comparison since multiple filters can have the same polling 
            // instruction queries.  Since there can never be multiple 
            // instructions with the same query for the same filter, 
            // comparing both works.
            //
            if( it->second.m_dwFilterId == dwKey && 
                it->first->CompareTo( pInst ) )
            {
                //
                // Found it, set to active but DO NOT add to the generator.
                // it is already there
                // 
                it->second.m_bActive = TRUE;
                return WBEM_S_FALSE;
            }
        }
    }
    
    //
    // add to the instruction to the map.
    //

    FilterInfo Info;
    Info.m_dwFilterId = dwKey;
    Info.m_bActive = TRUE;
    
    try
    {
        m_mapInstructions[pInst] = Info;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pInst->AddRef();  

    //
    // Postpone the first execution of the query.  
    // 1. Execution may not be done here, because the namespace is 
    //    locked
    // 2. Execution may not be done asynchronously, because we
    //    must get a baseline reading before returning to the 
    //    client.
    //
    
    CPostponedList* pList = GetCurrentPostponedList();
    _DBG_ASSERT( pList != NULL );

    CPostponedQuery* pReq = new CPostponedQuery( pInst );
        
    if ( pList != NULL )
    {
        hr = pList->AddRequest( m_pNamespace, pReq );

        if ( FAILED(hr) )
        {
            delete pReq;
        }
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    if ( FAILED(hr) )
    {
        pInst->Release();
        m_mapInstructions.erase( pInst );
    }

    return hr;
}
    
HRESULT CPoller::DeactivateFilter(CEventFilter* pDest)
{
    CInCritSec ics(&m_cs);

    DWORD_PTR dwKey = (DWORD_PTR)pDest;

    // Remove it from the map
    // ======================

    CInstructionMap::iterator it = m_mapInstructions.begin(); 
    DWORD nItems = 0;

    while(it != m_mapInstructions.end())
    {
        if(it->second.m_dwFilterId == dwKey)
        {
            CBasePollingInstruction* pInst = it->first;
    
            //
            // First, cancel the instruction so that if it is executing, it will
            // abort at the earliest convenience
            //

            pInst->Cancel();

            //
            // Then, deactivate the timer.  This will block until the
            // instruction has finished executing, if it is currently doing so
            //

            pInst->DeleteTimer();

            //
            // Now we are safe --- release the instruction. 
            //

            it = m_mapInstructions.erase(it);
            pInst->Release();

            nItems++;
        }
        else it++;
    }

    // Release our quotas if needed.
    if (nItems)
        g_quotas.DecrementQuotaIndex(ESSQ_POLLING_INSTRUCTIONS, pDest, nItems);

    return WBEM_S_NO_ERROR;
}

HRESULT CPoller::ListNonProvidedClasses(IN CClassInformation* pInfo,
                                        IN DWORD dwDesiredMask,
                                        OUT CClassInfoArray& aNonProvided)
{
    HRESULT hres;
    aNonProvided.Clear();

    // Get the class itself
    // ====================

    IWbemServices* pNamespace;
    hres = m_pNamespace->GetNamespacePointer(&pNamespace);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm0(pNamespace);

    IWbemClassObject* pClass = NULL;
    hres = pNamespace->GetObject(pInfo->m_wszClassName, 0, 
                        GetCurrentEssContext(), &pClass, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pClass);

    if(IsClassDynamic(pClass))
    {
        AddDynamicClass(pClass, dwDesiredMask, aNonProvided);
        return WBEM_S_NO_ERROR;
    }

    // Enumerate all its descendants
    // =============================

    IEnumWbemClassObject* pEnum;
    hres = pNamespace->CreateClassEnum(pInfo->m_wszClassName, 
            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY |
                ((pInfo->m_bIncludeChildren)?WBEM_FLAG_DEEP:WBEM_FLAG_SHALLOW),
                                        GetCurrentEssContext(), &pEnum);
    if(FAILED(hres)) return hres;
    CReleaseMe rm3(pEnum);

    IWbemClassObject* pChild = NULL;
    DWORD dwNumRet;
    while(SUCCEEDED(pEnum->Next(INFINITE, 1, &pChild, &dwNumRet)) && dwNumRet > 0)
    {
        // Check if this one is dynamic
        // ============================

        if(IsClassDynamic(pChild))
        {
            AddDynamicClass(pChild, dwDesiredMask, aNonProvided);
        }

        pChild->Release();
        pChild = NULL;
    }
    
    return WBEM_S_NO_ERROR;
}

BOOL CPoller::AddDynamicClass(IWbemClassObject* pClass, DWORD dwDesiredMask, 
                              OUT CClassInfoArray& aNonProvided)
{
    // Check to see if all desired events are provided
    // ===============================================

    DWORD dwProvidedMask = m_pNamespace->GetProvidedEventMask(pClass);
    DWORD dwRemainingMask = ((~dwProvidedMask) & dwDesiredMask);
    if(dwRemainingMask)
    {
        // Add it to the array of classes to poll
        // ======================================

        CClassInformation* pNewInfo = _new CClassInformation;
        if(pNewInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        VARIANT v;
        VariantInit(&v);
        pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        pNewInfo->m_wszClassName = CloneWstr(V_BSTR(&v));
        if(pNewInfo->m_wszClassName == NULL)
        {
            delete pNewInfo;
            return WBEM_E_OUT_OF_MEMORY;
        }
    
        VariantClear(&v);

        pNewInfo->m_bIncludeChildren = FALSE;            
        pNewInfo->m_dwEventMask = dwRemainingMask;
        pNewInfo->m_pClass = pClass;
        pClass->AddRef();
    
        if(!aNonProvided.AddClass(pNewInfo))
        {
            delete pNewInfo;
            return WBEM_E_OUT_OF_MEMORY;
        }
        return TRUE;
    }

    return FALSE;
}
            
BOOL CPoller::IsClassDynamic(IWbemClassObject* pClass)
{
    HRESULT hres;
    IWbemQualifierSet* pSet;
    hres = pClass->GetQualifierSet(&pSet);
    if(FAILED(hres))
        return TRUE;

    VARIANT v;
    VariantInit(&v);
    hres = pSet->Get(L"dynamic", 0, &v, NULL);
    pSet->Release();

    if(FAILED(hres)) return FALSE;
    
    BOOL bRes = V_BOOL(&v);
    VariantClear(&v);
    return bRes;
}

HRESULT CPoller::VirtuallyStopPolling()
{
    CInCritSec ics(&m_cs);

    // Mark all polling instructions in the map with the key of 0xFFFFFFFF
    // This will not stop them from working, but will separate them from the
    // new ones.
    // =====================================================================

    for(CInstructionMap::iterator it = m_mapInstructions.begin(); 
            it != m_mapInstructions.end(); it++)
    {
        it->second.m_bActive = FALSE;
    }

    m_bInResync = TRUE;

    return WBEM_S_NO_ERROR;

}

HRESULT CPoller::CancelUnnecessaryPolling()
{
    CInCritSec ics(&m_cs);

    // Remove it from the map
    // ======================

    CInstructionMap::iterator it = m_mapInstructions.begin(); 
    while(it != m_mapInstructions.end())
    {
        if( !it->second.m_bActive )
        {
            CBasePollingInstruction* pInst = it->first;

            //
            // First, cancel the instruction so that if it is executing, it will
            // abort at the earliest convenience
            //

            pInst->Cancel();

            //
            // Then, deactivate the timer.  This will block until the
            // instruction has finished executing, if it is currently doing so
            //

            pInst->DeleteTimer();

            //
            // Now we are safe --- release the instruction. 
            //

            it = m_mapInstructions.erase(it);
            pInst->Release();
        }
        else it++;
    }

    m_bInResync = FALSE;
    return WBEM_S_NO_ERROR;
}

void CPoller::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d polling instructions\n", m_mapInstructions.size());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\precomp.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#pragma warning (disable : 4786)

#define COREPROX_POLARITY __declspec( dllimport )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\pragmas.h ===
//******************************************************************************
//
//  PRAGMAS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#pragma warning(disable:4355)
#pragma warning(disable:4786)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\postpone.h ===
//******************************************************************************
//
//  POSTPONE.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_ESS_POSTPONE__H_
#define __WBEM_ESS_POSTPONE__H_

#include <arrtempl.h>
#include <wbemcomn.h>

class CEssNamespace;
class CPostponedRequest
{
    CEssNamespace* m_pNamespace; // stored for an assertion at execute()
public:
    CPostponedRequest() : m_pNamespace(NULL) {}
    virtual ~CPostponedRequest(){}

    void SetNamespace( CEssNamespace* pNamespace ) { m_pNamespace=pNamespace; }
    CEssNamespace* GetNamespace() { return m_pNamespace; }

    virtual HRESULT Execute(CEssNamespace* pNamespace) = 0;
    
    //
    // if a postponed request holds a CExecLine::Turn, then override this 
    // method to return TRUE.  ( used for debugging purposes - we want to know
    // if a postponed list is holding any turns )
    //
    virtual BOOL DoesHoldTurn() { return FALSE; }
};

class CPostponedList
{
protected:
    ULONG m_cTurnsHeld;
    CUniquePointerQueue<CPostponedRequest> m_qpRequests;

public:
    typedef enum
    {
        e_StopOnFailure, e_ReturnOneError
    } EPostponedExecuteFlags;

    CPostponedList() : m_qpRequests(0), m_cTurnsHeld(0) {}
    virtual ~CPostponedList(){}

    BOOL IsEmpty() { return m_qpRequests.GetQueueSize() == 0; }
    BOOL IsHoldingTurns() { return m_cTurnsHeld > 0; }

    HRESULT AddRequest( CEssNamespace* pNamespace, 
                        ACQUIRE CPostponedRequest* pReq );

    HRESULT Execute( CEssNamespace* pNamespace, 
                     EPostponedExecuteFlags eFlags,
                     DELETE_ME CPostponedRequest** ppFailed = NULL);
    HRESULT Clear();
};
        
       
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\provreg.cpp ===
//******************************************************************************
//
//  PROVREG.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <parmdefs.h>
#include <ql.h>
#include "ess.h"
#include <wbemutil.h>
#include <cominit.h>
#include <objpath.h>
#include <provinit.h>
#include <winmgmtr.h>
#include <newobj.h>
#include <comutl.h>
#include "NCEvents.h"

_IWmiObject* g_pCopy;

#define WBEM_MAX_FILTER_ID 0x80000000

inline BOOL IsRpcError( HRESULT hr ) 
{
    //
    // we'll consider any error but a wbem error to be an rpc error.
    //

    return HRESULT_FACILITY(hr) != FACILITY_ITF;
} 

CWbemInterval CEventProviderWatchInstruction::mstatic_Interval;

CEventProviderWatchInstruction::CEventProviderWatchInstruction(
                                                    CEventProviderCache* pCache)
        : CBasicUnloadInstruction(mstatic_Interval), m_pCache(pCache)
{
}

void CEventProviderWatchInstruction::staticInitialize(IWbemServices* pRoot)
{
    mstatic_Interval = CBasicUnloadInstruction::staticRead(pRoot, GetCurrentEssContext(), 
                                            L"__EventProviderCacheControl=@");
}

HRESULT CEventProviderWatchInstruction::Fire(long, CWbemTime)
{
    CInCritSec ics(&m_cs);

    if(!m_bTerminate)
    {
        SetCurrentEssThreadObject(NULL);
        
        if ( GetCurrentEssThreadObject() != NULL )
        {
            m_pCache->UnloadUnusedProviders(m_Interval);
            delete GetCurrentEssThreadObject();
            ClearCurrentEssThreadObject();
        }
    }

    return WBEM_S_FALSE;
}

//******************************************************************************
//******************************************************************************
//
//          PROVIDER SINK (SERVER)
//
//******************************************************************************
//******************************************************************************

CProviderSinkServer::CEventDestination::CEventDestination(
                                    WBEM_REMOTE_TARGET_ID_TYPE id,
                                    CAbstractEventSink* pSink)
    : m_id(id), m_pSink(pSink)
{
    if(m_pSink)
        m_pSink->AddRef();
}

CProviderSinkServer::CEventDestination::CEventDestination(
                                    const CEventDestination& Other)
    : m_id(Other.m_id), m_pSink(Other.m_pSink)
{
    if(m_pSink)
        m_pSink->AddRef();
}

CProviderSinkServer::CEventDestination::~CEventDestination()
{
    if(m_pSink)
        m_pSink->Release();
}

        
CProviderSinkServer::CProviderSinkServer()
: m_lRef(0), m_pNamespace(NULL), m_pMetaData(NULL), m_Stub(this),  m_idNext(0),
  m_pPseudoProxy(NULL), m_pPseudoSink(NULL), m_pReqSink(NULL), m_lLocks(0)
{
}

HRESULT CProviderSinkServer::Initialize( CEssNamespace* pNamespace,
                                    IWbemEventProviderRequirements* pReqSink )
{
    HRESULT hres;

    //
    // This sink owns us, so we intentionally do not AddRef it
    //

    m_pReqSink = pReqSink;

    m_pMetaData = new CEssMetaData(pNamespace);
    if(m_pMetaData == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    m_pMetaData->AddRef();

    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    //
    // create the pseudo proxy and sink.
    // 

    hres = WbemCoCreateInstance( CLSID_WbemFilterProxy, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER,
                                 IID_IWbemLocalFilterProxy, 
                                 (void**)&m_pPseudoProxy );
    if( FAILED(hres) )
    {
        return hres;
    }
            
    hres = m_pPseudoProxy->SetStub( &m_Stub );
            
    if(FAILED(hres))
    {
        return hres;
    }
    
    return m_pPseudoProxy->GetMainSink(&m_pPseudoSink);
}

HRESULT CProviderSinkServer::GetMainProxy(IWbemEventSink** ppSink)
{
    _DBG_ASSERT( m_pPseudoSink != NULL );
    m_pPseudoSink->AddRef();
    *ppSink = m_pPseudoSink;
    return WBEM_S_NO_ERROR;
}

CProviderSinkServer::~CProviderSinkServer()
{
    if(m_pPseudoProxy)
        m_pPseudoProxy->Release();
    if(m_pPseudoSink)
        m_pPseudoSink->Release();
    if(m_pMetaData)
        m_pMetaData->Release();
    if(m_pNamespace)
        m_pNamespace->Release();
}

ULONG STDMETHODCALLTYPE CProviderSinkServer::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CProviderSinkServer::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) 
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::QueryInterface(REFIID riid, 
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IMarshal)
        *ppv = (IMarshal*)this;
    else 
        return E_NOINTERFACE;
    
    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::DeliverEvent(
                        DWORD dwNumEvents,
                        IWbemClassObject** apEvents, 
                        WBEM_REM_TARGETS* aTargets,
                        CEventContext* pContext)
{
    if(aTargets == NULL || aTargets->m_aTargets == NULL || apEvents == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL parameter received from a "
                    "filter proxy for an event provider. Either an internal "
                    "error has occurred, or a DENIAL OF SERVICE ATTACK has "
                    "been thwarted\n"));

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // ensure that there is no ess thread object associated with this thread.
    // to avoid making the design more complicated we are not going to support
    // postpone operations being used on event signaling threads.  If we did
    // we have to start creating thread objects and firing postponed ops on
    // every event signaling - it would be rather messy and inefficient to 
    // say the least. 
    //

    CEssThreadObject* pThreadObj = GetCurrentEssThreadObject();

    if ( pThreadObj != NULL )
    {
        ClearCurrentEssThreadObject();
    }

    for(DWORD i = 0; i < dwNumEvents; i++)
    {
        DeliverOneEvent(apEvents[i], aTargets + i, pContext);
    }

    if ( pThreadObj != NULL )
    {
        SetConstructedEssThreadObject( pThreadObj );
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CProviderSinkServer::DeliverOneEvent( IWbemClassObject* pEvent,
                                              WBEM_REM_TARGETS* pTargets,
                                              CEventContext* pContext )
{
    HRESULT hres;

    _DBG_ASSERT( pContext != NULL );

    if(pEvent == NULL)
    {
        ERRORTRACE((LOG_ESS, "NULL parameter received from a "
                    "filter proxy for an event provider. Either an internal "
                    "error has occurred, or a DENIAL OF SERVICE ATTACK has "
                    "been thwarted\n"));

        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // allocate the context to be used if we need to switch to a per event 
    // context ( e.g. when the event has a SD ).  
    // 
    CEventContext PerEventContext;
    
    //
    // take care of the event SD here.  If there is an SD associated with the 
    // context, then we always use that one.  If not, then we take the one 
    // associated with the event.  In the latter case, it is important to 
    // pull the SD out here because sometimes we perform the access check 
    // after the SD has been projected out from the event ( this happens in 
    // cross-namespace subscriptions.
    //

    if ( pContext->GetSD() == NULL )
    {
        ULONG cEventSD;
        PBYTE pEventSD = (PBYTE)GetSD( pEvent, &cEventSD );

        if ( pEventSD != NULL )
        {
            //
            // must use a different context for the event, 
            // since it has its own SD
            //
            pContext = &PerEventContext;

            //
            // we must copy the SD here because it is not guaranteed to be 
            // aligned properly since it is a ptr to the direct event object 
            // data.  The bytes MUST NOT be treated as an SD until it has 
            // been copied. 
            // 

            if ( !pContext->SetSD( cEventSD, pEventSD, TRUE ) )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            
            if ( !IsValidSecurityDescriptor( 
                              (PSECURITY_DESCRIPTOR)pContext->GetSD() ) )
            {
                return WBEM_E_INVALID_OBJECT;
            }
        }
    }
    else
    {
        if ( !IsValidSecurityDescriptor( 
                              (PSECURITY_DESCRIPTOR)pContext->GetSD() ) )
        {
            return WBEM_E_INVALID_PARAMETER;
        }
    }

    //
    // clone the event
    // 

    IWbemEvent* pClone = NULL;

/*
    _IWmiObject* pEventEx;
    pEvent->QueryInterface(IID__IWmiObject, (void**)&pEventEx);
    pClone = m_InstanceManager.Clone(pEventEx);
    pEventEx->Release();

    if(pClone == NULL)
        return WBEM_E_OUT_OF_MEMORY;
*/
        
    hres = pEvent->Clone(&pClone);
    if(FAILED(hres))
        return hres;

/*
    pClone = pEvent;
    pClone->AddRef();
*/

    CReleaseMe rm1(pClone);

    if(pTargets->m_lNumTargets > 1)
        return MultiTargetDeliver(pClone, pTargets, pContext);

    // Single target
    // =============

    // Check validity
    // ==============

    long lDestId = pTargets->m_aTargets[0];
    CAbstractEventSink* pDest = NULL;

    {
        CInCritSec ics(&m_cs);
        
        hres = FindDestinations(1, pTargets->m_aTargets, &pDest);
        if(FAILED(hres))
            return hres;

        if(!pDest)
            // No longer there --- that's OK
            return WBEM_S_FALSE;
    }

    hres = pDest->Indicate(1, &pClone, pContext);
    pDest->Release();

    return hres;
}


HRESULT CProviderSinkServer::MultiTargetDeliver(IWbemEvent* pEvent, 
                                    WBEM_REM_TARGETS* pTargets,
                                    CEventContext* pContext)
{
    HRESULT hres;

    // Convert the target IDs to the actual targets
    // ============================================

    CTempArray<CAbstractEventSink*> apSinks;
    if(!INIT_TEMP_ARRAY(apSinks, pTargets->m_lNumTargets))
        return WBEM_E_OUT_OF_MEMORY;

    {
        CInCritSec ics(&m_cs);
        
        hres = FindDestinations(pTargets->m_lNumTargets, pTargets->m_aTargets,
                                (CAbstractEventSink**)apSinks);
        if(FAILED(hres))
            return hres;
    }

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    for(int i = 0; i < pTargets->m_lNumTargets; i++)
    {
        if(apSinks[i])
        {
            hres = apSinks[i]->Indicate(1, &pEvent, pContext);
            if(FAILED(hres))
                hresGlobal = hres;
            apSinks[i]->Release();
        }
    }

    // DEBUGTRACE((LOG_ESS, "Done delivering\n"));
    return hresGlobal;
}
        
// assumes: locked
HRESULT CProviderSinkServer::FindDestinations(long lNum, 
                                IN WBEM_REMOTE_TARGET_ID_TYPE* aidTargets,
                                RELEASE_ME CAbstractEventSink** apSinks)
{
    //
    // Do a binary search for each one.  The range will be getting progressively
    // smaller with each element we find
    //

    long lLastFoundIndex = -1;

    for(long i = 0; i < lNum; i++)
    {
        long lMinIndex = lLastFoundIndex+1;
        long lMaxIndex = m_apDestinations.GetSize() - 1;
        long lFound = -1;
        WBEM_REMOTE_TARGET_ID_TYPE idCurrent = aidTargets[i];
    
        //
        // Search the remaining portion of the array
        //

        while(lMinIndex <= lMaxIndex)
        {
            long lMidIndex = (lMinIndex + lMaxIndex) / 2;

            WBEM_REMOTE_TARGET_ID_TYPE idMid = m_apDestinations[lMidIndex]->m_id;
            if(idMid == idCurrent)
            {
                lFound = lMidIndex;
                break;
            }
            else if(idCurrent < idMid)
            {
                lMaxIndex = lMidIndex - 1;
            }
            else
            {
                lMinIndex = lMidIndex + 1;
            }
        }

        if(lFound < 0)
        {
            //
            // Invalid target ID -- OK, so NULL target then
            //

            apSinks[i] = NULL;
        }
        else
        {
            apSinks[i] = m_apDestinations[lFound]->m_pSink;
            (apSinks[i])->AddRef();

            //
            // The rest of the IDs can only be found to the right of this one
            // because the targets are sorted
            //

            lLastFoundIndex = lFound;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::DeliverStatus(long lFlags, 
                        HRESULT hresStatus,
                        LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                        WBEM_REM_TARGETS* pTargets,
                        CEventContext* pContext)
{
    return WBEM_E_UNEXPECTED;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::DeliverProviderRequest(
                        long lFlags)
{
    if(m_pReqSink)
        return m_pReqSink->DeliverProviderRequest(lFlags);
    else
        return WBEM_E_UNEXPECTED;
}


// assumes: locked
HRESULT CProviderSinkServer::GetDestinations(
                        CUniquePointerArray<CEventDestination>& apDestinations)
{
    for(int i = 0; i < m_apDestinations.GetSize(); i++)
    {
        CEventDestination* pNew = new CEventDestination(*m_apDestinations[i]);
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(apDestinations.Add(pNew) < 0)
        {
            delete pNew;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
            
    return WBEM_S_NO_ERROR;
}
    
// assumes in m_cs;
HRESULT CProviderSinkServer::AddDestination(CAbstractEventSink* pDest,
                                WBEM_REMOTE_TARGET_ID_TYPE* pID)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //
    // Allocate a new destination ID
    //

    WBEM_REMOTE_TARGET_ID_TYPE idNew = m_idNext++;
    if(m_idNext > WBEM_MAX_FILTER_ID / 2)
    {
        // 
        // 32-bit integer roll-over! This provider has processed over 
        // 4000000000 filter creations!  Canfetti is falling from the ceiling
        //

        DEBUGTRACE((LOG_ESS, "Filter ID rollover!!!\n"));

        // BUGBUG: Postpone a call to reactivate all filters!
    }

    //
    // Add a new destination entry
    //

    CEventDestination* pDestRecord = new CEventDestination(idNew, pDest);
    if(pDestRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_apDestinations.Add(pDestRecord);
            
    // Record the ID in the TARGETS
    // ============================

    *pID = idNew;
    return hres;
}

HRESULT CProviderSinkServer::AddFilter(LPCWSTR wszQuery, 
                    QL_LEVEL_1_RPN_EXPRESSION* pExp,
                    CAbstractEventSink* pDest, 
                    WBEM_REMOTE_TARGET_ID_TYPE* pidRequest)
{
    HRESULT hres;
    WBEM_REMOTE_TARGET_ID_TYPE idDest;

    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);

        // Copy proxies
        // ============

        if(!GetProxies(apProxies))
            return WBEM_E_OUT_OF_MEMORY;

        // Add to the list of destinations registered with the provider and
        // construct the target identification for the proxies
        // ================================================================

        hres = AddDestination(pDest, &idDest);
        if(FAILED(hres))
            return hres;
    }
    
    if(pidRequest)
        *pidRequest = idDest;

    // Go through all the proxies and schedule calls
    // =============================================

    HRESULT hresReal = WBEM_S_NO_ERROR;
    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        IWbemLocalFilterProxy *pLocalProxy = NULL;

        // See if the proxy will allow us to call LocalAddFilter (in which case
        // it's the pseudo proxy).
        if (SUCCEEDED(apProxies[i]->QueryInterface(
			IID_IWbemLocalFilterProxy, (LPVOID*) &pLocalProxy)))
        {
            CReleaseMe rm1(pLocalProxy);

            hres = pLocalProxy->LocalAddFilter( GetCurrentEssContext(), 
                                                wszQuery, 
                                                pExp, 
                                                idDest );

            hresReal = hres; // other errors do not matter
        }
        else
        {
            hres = apProxies[i]->AddFilter( GetCurrentEssContext(), 
                                            wszQuery,
                                            idDest );
        }

        if( FAILED(hres) )
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }

            ERRORTRACE((LOG_ESS, "Unable to add query %S to a remote provider "
                        "proxy. Error code: %X\n", wszQuery, hres));
        }
    }
            
    return hresReal;
}

HRESULT CProviderSinkServer::RemoveFilter(CAbstractEventSink* pDest,
                                    WBEM_REMOTE_TARGET_ID_TYPE* pidRequest)
{
    HRESULT hres;

    // Find and invalidate the filter in the list of destinations
    // ==========================================================

    CEventDestination* pToRemove = NULL;
    CRefedPointerArray<IWbemFilterProxy> apProxies;

    {
        CInCritSec ics(&m_cs);
    
        // Copy the proxies
        // ================

        if(!GetProxies(apProxies))
            return WBEM_E_OUT_OF_MEMORY;

        // Search for it in the array of destinations
        // ==========================================

        for(int i = 0; i < m_apDestinations.GetSize(); i++)
        {
            if(m_apDestinations[i]->m_pSink == pDest)
            {
                m_apDestinations.RemoveAt(i, &pToRemove);
                break;
            }
        }

        if(pToRemove == NULL)
            return WBEM_E_NOT_FOUND;
    }

    if(pidRequest)
        *pidRequest = pToRemove->m_id;

    // The filter is invalidated, but not removed. We are outside of the CS, so
    // events can be delivered (but no other changes can occur)
    // =========================================================================
    
    // Instruct all proxies to (later) remove this filter from consideration
    // =====================================================================

    for(int i = 0; i < apProxies.GetSize(); i++) 
    {
        hres = apProxies[i]->RemoveFilter(GetCurrentEssContext(), 
                                            pToRemove->m_id);
        if(FAILED(hres))
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }

            ERRORTRACE((LOG_ESS, "Unable to remove filter %I64d from an event "
                "provider proxy: 0x%X\n", pToRemove->m_id, hres));
        }
    }

    //
    // Delete the destination in question
    // 

    delete pToRemove;

    return WBEM_S_NO_ERROR;
}

// assumes all proxies are locked
void CProviderSinkServer::RemoveAllFilters()
{
    CRefedPointerArray<IWbemFilterProxy> apProxies;

    {
        CInCritSec ics(&m_cs);
    
        // Copy the proxies
        // ================

        if(!GetProxies(apProxies))
            return;

        //
        // Clear out both the list of destinations 
        //

        m_apDestinations.RemoveAll();
    }

    //
    // Remove all filters from all proxies
    //

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        HRESULT hres = 
            apProxies[i]->RemoveAllFilters(GetCurrentEssContext());
    
        if(FAILED(hres))
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }

            ERRORTRACE((LOG_ESS, "Unable to remove all queries from a "
                        "remote provider proxy. Error code: %X\n", hres));
        }
    }

}

//
// Only allow utilization of the guarantee if the proxy's definition
// matches the provider's definition.  In other words, only when
// the provider's registration has been successfully processed,
// and the proxies are set up to reflect it, should utilization of
// the guarantee be allowed.  The reason for this is that an incomplete
// source definition can cause bad things to happen when events are
// evaluated using a filter that was optimized for that definition.
//
HRESULT CProviderSinkServer::AllowUtilizeGuarantee()
{
    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);

        if ( !GetProxies( apProxies ) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        HRESULT hr = apProxies[i]->AllowUtilizeGuarantee();

        if ( FAILED(hr) && IsRpcError(hr) )
        {
            UnregisterProxy( apProxies[i] );
        }   
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CProviderSinkServer::AddDefinitionQuery(LPCWSTR wszQuery)
{
    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        
        GetProxies(apProxies);
        
        if ( m_awsDefinitionQueries.Add(wszQuery) < 0 ) 
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    //
    // we always try to add the definition to all proxies, but if there's an
    // error ( other than RPC ) we return it to the caller.
    //

    HRESULT hresReturn = WBEM_S_NO_ERROR;

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        HRESULT hres = apProxies[i]->AddDefinitionQuery(
                                            GetCurrentEssContext(), wszQuery);
        if( FAILED(hres) )
        {
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }
            else
            {
                hresReturn = hres;
            } 

            ERRORTRACE((LOG_ESS, "Unable to add definition query %S to a "
                        "provider proxy. Error code: %X\n", wszQuery, hres));
        }
    }

    return hresReturn;
}

// assumes: all proxies are locked
void CProviderSinkServer::RemoveAllDefinitionQueries()
{
    CInCritSec ics(&m_cs);

    m_awsDefinitionQueries.Empty();

    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres = m_apProxies[i]->RemoveAllDefinitionQueries(
                                        GetCurrentEssContext());
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove all definition queries from"
                                 " a provider proxy. Error code: %X\n", hres));
        }
    }
}

void CProviderSinkServer::Clear()
{
    // Provider is being removed.  First, we disconnect all proxies, ensuring
    // that no more events are delivered
    // ======================================================================

    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        GetProxies(apProxies);
        m_apProxies.RemoveAll();
        m_awsDefinitionQueries.Empty();
    }

    //
    // since we are going to disconnect the proxy it is illegal to own the
    // namespace lock.  Reason is that disconnecting takes ownership of the
    // proxy lock. 
    //
    _DBG_ASSERT( !m_pNamespace->DoesThreadOwnNamespaceLock() );

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        apProxies[i]->Disconnect();
    }

    // Now we clean up
    // ===============

    RemoveAllFilters();
    RemoveAllDefinitionQueries();

    m_pReqSink = NULL;

    CWbemPtr<IUnknown> pStubUnk;

    HRESULT hr = m_Stub.QueryInterface( IID_IUnknown, (void**)&pStubUnk );

    _DBG_ASSERT( SUCCEEDED(hr) );

    hr = CoDisconnectObject( pStubUnk, 0 );

    if ( FAILED( hr ) )
    {
        ERRORTRACE((LOG_ESS,"Failed Disconnecting Stub.\n"));
    }
}

HRESULT CProviderSinkServer::Lock()
{
    //
    // it is illegal to lock proxies while holding the namespace lock.
    //
    _DBG_ASSERT( !m_pNamespace->DoesThreadOwnNamespaceLock() );

    // DEBUGTRACE((LOG_ESS, "Server %p locking all proxies\n", this));

    // First we lock all the proxies.  In the interim, events are still
    // delivered.  Once done, events are blocked in proxies
    // ================================================================

    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        //
        // First, check if we are already locked.  If so, no need to bother
        // the proxies. Not only that, but since proxies are out-of-proc, we 
        // would be re-locking them on a different thread, causing a deadlock.
        //
        if(m_lLocks++ > 0)
            return WBEM_S_NO_ERROR;

        GetProxies(apProxies);
    }

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        // DEBUGTRACE((LOG_ESS, "Server %p locking proxy %p\n", this,
        //             apProxies[i]));

        HRESULT hres = apProxies[i]->Lock();

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to lock a remote provider proxy. "
                                 "Error code: %X\n", hres));            
            //
            // if we couldn't lock it because of an RPC Error, simply 
            // unregister, else we have big problems and should unlock all 
            // the proxies and return the error.
            // 

            if ( IsRpcError( hres ) ) 
            {
                UnregisterProxy( apProxies[i] );
            }
            else
            {
                for(int j = 0; j < i; j++)
                    apProxies[j]->Unlock();
                return hres;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

BOOL CProviderSinkServer::GetProxies(
                            CRefedPointerArray<IWbemFilterProxy>& apProxies)
{
    CInCritSec ics(&m_cs);

    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        if(apProxies.Add(m_apProxies[i]) < 0)
            return FALSE;
    }

    return TRUE; 
}
    

void CProviderSinkServer::Unlock()
{
    // DEBUGTRACE((LOG_ESS, "Server %p unlocking all proxies\n", this));
    CRefedPointerArray<IWbemFilterProxy> apProxies;
    {
        CInCritSec ics(&m_cs);
        //
        // First, check if this is the last unlock.  If not, we didn't forward
        // this lock, so we shouldn't forward this unlock either
        //
        if(--m_lLocks != 0)
            return;

        GetProxies(apProxies);
    }

    for(int i = 0; i < apProxies.GetSize(); i++)
    {
        // DEBUGTRACE((LOG_ESS, "Server %p unlocking proxy %p\n", this,
        //             apProxies[i]));
        HRESULT hres = apProxies[i]->Unlock();
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to unlock a remote provider proxy. "
                        "Error code: %X\n", hres));
            
            if ( IsRpcError(hres) )
            {
                UnregisterProxy( apProxies[i] );
            }
        }
    }
}

    
HRESULT STDMETHODCALLTYPE CProviderSinkServer::RegisterProxy(
                                                    IWbemFilterProxy* pProxy)
{
    // Initialize it with ourselves
    // ============================

    HRESULT hres = pProxy->Initialize(m_pMetaData, &m_Stub);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to initialize remote proxy: %X\n", hres));
        return hres;
    }

    {
        CInCritSec ics(&m_cs);

        // At this point, it is locked
        // ===========================

        if(m_apProxies.Add(pProxy) < 0)
            return WBEM_E_OUT_OF_MEMORY;

        //
        // Add all the definition queries to this proxy
        //

        int i;
        BOOL bUtilizeGuarantee = TRUE;
        
        for(i = 0; i < m_awsDefinitionQueries.Size(); i++)
        {
            hres = pProxy->AddDefinitionQuery( GetCurrentEssContext(), 
                                               m_awsDefinitionQueries[i]);

            if(FAILED(hres))
            {
                //
                // TODO : We need to mark the provider as inactive.
                // 

                ERRORTRACE((LOG_ESS, "Unable to add definition query '%S' to "
                    "provider sink: 0x%X.\n", 
                    m_awsDefinitionQueries[i], hres));
                
                bUtilizeGuarantee = FALSE;
            }
        }

        if ( bUtilizeGuarantee )
        {
            pProxy->AllowUtilizeGuarantee();
        }
        
        //
        // Add all the filters to this proxy
        //

        for(i = 0; i < m_apDestinations.GetSize(); i++)
        {
            // Retrieve the filter from the event sink
            // =======================================

            CEventDestination* pDest = m_apDestinations[i];
    
            CEventFilter* pFilter = pDest->m_pSink->GetEventFilter();
            if(pFilter == NULL)
            {
                ERRORTRACE((LOG_ESS, "Internal error: non-filter sink in "
                    "proxy\n"));
                continue;
            }

            LPWSTR wszQuery;
            LPWSTR wszQueryLanguage;
            BOOL bExact;
            if(SUCCEEDED(pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery,
                                           bExact, NULL)) && bExact)
            {
                // Add this filter to this proxy
                // =============================

                hres = pProxy->AddFilter(GetCurrentEssContext(), wszQuery, 
                                            pDest->m_id);

                if(FAILED(hres))
                {
                    ERRORTRACE((LOG_ESS, "Unable to add query %S to a remote "
                           "provider proxy. Error code: %X\n", wszQuery, hres));
                }

                delete [] wszQuery;
                delete [] wszQueryLanguage;
            }
        }

        //
        // Only unlock the remote proxy if we ourselves are not currently
        // locked.  If we are, the proxy will get unlocked with all the others
        // since it is now added to m_apProxies.
        //

        if(m_lLocks == 0)
            pProxy->Unlock();
    }
            
    return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CProviderSinkServer::UnregisterProxy(
                                                    IWbemFilterProxy* pProxy)
{
    CInCritSec ics(&m_cs);

    // Look for it
    // ===========

    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        if(m_apProxies[i] == pProxy)
        {
            // It is safe to release it, since the caller has a ref-count
            // ==========================================================
            m_apProxies.RemoveAt(i);
            return WBEM_S_NO_ERROR;
        }
    }

    return WBEM_S_FALSE;
}





ULONG STDMETHODCALLTYPE CFilterStub::AddRef()
{
    return m_pSink->AddRef();
}

ULONG STDMETHODCALLTYPE CFilterStub::Release()
{
    return m_pSink->Release();
}

HRESULT STDMETHODCALLTYPE CFilterStub::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemFilterStub)
    {
        *ppv = (IWbemFilterStub*)this;
    }
    else if(riid == IID_IWbemMultiTarget)
    {
        *ppv = (IWbemMultiTarget*)this;
    }
    else if ( riid == IID_IWbemFetchSmartMultiTarget )
    {
        *ppv = (IWbemFetchSmartMultiTarget*)this;
    }
    else if ( riid == IID_IWbemSmartMultiTarget )
    {
        *ppv = (IWbemSmartMultiTarget*)this;
    }
    else if( riid == IID_IWbemEventProviderRequirements)
    {
        *ppv = (IWbemEventProviderRequirements*)this;
    }
    else return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFilterStub::RegisterProxy(IWbemFilterProxy* pProxy)
{
    return m_pSink->RegisterProxy(pProxy);
}

HRESULT STDMETHODCALLTYPE CFilterStub::UnregisterProxy(IWbemFilterProxy* pProxy)
{
    return m_pSink->UnregisterProxy(pProxy);
}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverEvent(DWORD dwNumEvents,
                    IWbemClassObject** apEvents, 
                    WBEM_REM_TARGETS* aTargets,
                    long lSDLength, BYTE* pSD)
{
    CEventContext Context;
    Context.SetSD( lSDLength, pSD, FALSE );
    return m_pSink->DeliverEvent( dwNumEvents, apEvents, aTargets, &Context );
}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverStatus(long lFlags, 
                    HRESULT hresStatus,
                    LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                    WBEM_REM_TARGETS* pTargets,
                    long lSDLength, BYTE* pSD)
{
    CEventContext Context;
    Context.SetSD( lSDLength, pSD, FALSE );
    return m_pSink->DeliverStatus(lFlags, hresStatus, wszStatus, pErrorObj,
                                    pTargets, &Context);
}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverProviderRequest(long lFlags)
{
    return m_pSink->DeliverProviderRequest(lFlags);
}

HRESULT STDMETHODCALLTYPE  CFilterStub::GetSmartMultiTarget( IWbemSmartMultiTarget** ppSmartMultiTarget )
{
    return QueryInterface( IID_IWbemSmartMultiTarget, (void**) ppSmartMultiTarget );

}

HRESULT STDMETHODCALLTYPE CFilterStub::DeliverEvent(ULONG dwNumEvents,
                    ULONG dwBuffSize, 
                    BYTE* pBuffer,
                    WBEM_REM_TARGETS* pTargets, 
                    long lSDLength, BYTE* pSD)
{

    // Unwind the buffer into an object.  Note that because m_ClassCache is
    // STL based, it is intrinsically thread-safe.  Also, calling proxies are
    // serialized, so we shouldn't have any thread-safety problems here.

    CWbemMtgtDeliverEventPacket packet( (LPBYTE) pBuffer, dwBuffSize );
    long lObjectCount; 
    IWbemClassObject ** pObjArray;
    HRESULT hr = packet.UnmarshalPacket( lObjectCount, pObjArray, m_ClassCache );

    if ( SUCCEEDED( hr ) )
    {
        // Number must be dwNumEvents

        if(lObjectCount == dwNumEvents)
        {
            // Now call the standard deliver event function and hand it the
            // object

            hr = DeliverEvent(dwNumEvents, pObjArray, pTargets, lSDLength, pSD);
        }
        else
        {
            hr = WBEM_E_UNEXPECTED;
        }

        // Release the objects in the array and clean up pObjArray

        for ( int lCtr = 0; lCtr < lObjectCount; lCtr++ )
        {
            pObjArray[lCtr]->Release();
        }

        delete [] pObjArray;

    }   // IF UnmarshalPacket

    return hr;
}
        

void CProviderSinkServer::GetStatistics(long* plProxies, long* plDestinations,
                    long* plFilters, long* plTargetLists, long* plTargets,
                    long* plPostponed)
{
    *plProxies = m_apProxies.GetSize();
    *plDestinations = m_apDestinations.GetSize();

/* BUGBUG: do properly for all sinks
    ((CFilterProxy*)m_pSink)->GetStatistics(plFilters, plTargetLists, 
                                plTargets, plPostponed);
*/
}

//******************************************************************************
//******************************************************************************
//
//          CRECORD :: CQUERY RECORD
//
//******************************************************************************
//******************************************************************************
CEventProviderCache::CRecord::CQueryRecord::CQueryRecord()
    : m_strQuery(NULL), m_pEventClass(NULL), 
        m_dwEventMask(0), m_paInstanceClasses(NULL), m_pExpr(NULL)
{
}

HRESULT CEventProviderCache::CRecord::CQueryRecord::EnsureClasses( 
                                                    CEssNamespace* pNamespace )
{
    HRESULT hres = WBEM_S_NO_ERROR;

    _IWmiObject* pClass;

    if ( m_pEventClass == NULL )
    {
        if ( SUCCEEDED( pNamespace->GetClass( m_pExpr->bsClassName, 
                                                &pClass ) ) )
        {
            m_pEventClass = pClass;
        }
        else
        {
            hres = WBEM_S_FALSE;
        }
    }

    if ( m_paInstanceClasses != NULL )
    {
        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);

            if ( pInfo->m_pClass == NULL )
            {
                if ( SUCCEEDED( pNamespace->GetClass( pInfo->m_wszClassName, 
                                                      &pClass) ) )
                {
                    pInfo->m_pClass = pClass;
                }
                else
                {
                    hres = WBEM_S_FALSE;
                }
            }
        }
    }
    else
    {
        hres = WBEM_S_FALSE;
    }
        
    return hres;
}

void CEventProviderCache::CRecord::CQueryRecord::ReleaseClasses()
{
    if ( m_pEventClass != NULL )
    {
        m_pEventClass->Release();
        m_pEventClass = NULL;
    }

    if ( m_paInstanceClasses != NULL )
    {
        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);

            if ( pInfo->m_pClass != NULL )
            {
                pInfo->m_pClass->Release();
                pInfo->m_pClass = NULL;
            }
        }
    }
}

HRESULT CEventProviderCache::CRecord::CQueryRecord::Initialize(
                                                LPCWSTR wszQuery,
                                                LPCWSTR wszProvName,
                                                CEssNamespace* pNamespace,
                                                bool bSystem)
{
    HRESULT hres;

    m_strQuery = SysAllocString(wszQuery);
    if(m_strQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    // Parse the query
    // ===============

    CTextLexSource Source((LPWSTR)wszQuery);
    QL1_Parser Parser(&Source);
    if(Parser.Parse(&m_pExpr) != QL1_Parser::SUCCESS)
    {
        ERRORTRACE((LOG_ESS,
            "Invalid query in provider registration: %S\n", wszQuery));

        CEventLog Log; Log.Open();
        Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_INVALID_EVENT_PROVIDER_QUERY,
                                wszQuery);
        return WBEM_E_UNPARSABLE_QUERY;
    }

    if(!bSystem)
    {
        if(!wbem_wcsicmp(m_pExpr->bsClassName, L"__Event") ||
           !wbem_wcsicmp(m_pExpr->bsClassName, L"__ExtrinsicEvent"))
        {
            ERRORTRACE((LOG_ESS,
                "Provider claims to provide all events with "
                "query:  %S\n"
                "We don't believe it, so we ignore the registration\n\n",
                wszQuery));
    
            CEventLog Log; Log.Open();
            Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_TOO_BROAD,
                                wszQuery);
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }
    }

    // Determine its event mask
    // ========================

    m_dwEventMask = CEventRepresentation::GetTypeMaskFromName(
                                m_pExpr->bsClassName);

    // Check if the mask mentions any pollable events
    // ==============================================

    if(m_dwEventMask & INTRINSIC_EVENTS_MASK)
    {
        // Yes. Get instance classes for which it providers these events
        // =============================================================

        hres = CQueryAnalyser::GetDefiniteInstanceClasses(m_pExpr, 
                                            m_paInstanceClasses);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,
                "Unable to determine instance classes for which events"
                    "are provided by this query: %S\n", wszQuery));

            CEventLog Log; Log.Open();
            Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_INVALID_EVENT_PROVIDER_INTRINSIC_QUERY,
                                wszQuery);
            return WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY;
        }

        if(!bSystem && !m_paInstanceClasses->IsLimited())
        {
            ERRORTRACE((LOG_ESS,
                "Provider claims to provide all intrinsic events with "
                "query:  %S\n"
                "We don't believe it, so we ignore the registration\n\n",
                wszQuery));

            CEventLog Log; Log.Open();
            Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_TOO_BROAD,
                                wszQuery);
            return WBEMESS_E_REGISTRATION_TOO_BROAD;
        }

        // Get the actual classes from the namespace
        // =========================================

        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);
            _IWmiObject* pClass = NULL;
            hres = pNamespace->GetClass(pInfo->m_wszClassName, &pClass);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS,
                    "Could not get class %S for which provider claims"
                    " to provider events. Error code: %X\n", 
                    pInfo->m_wszClassName, hres));

                CEventLog Log; Log.Open();
                Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_NOT_FOUND,
                                wszQuery, pInfo->m_wszClassName);

                //
                // Before continuing, we register for class creation event on 
                // this class.  This way, when it is finally created, we will 
                // reactivate stuff and bring the system back on track
                //
        
                hres = pNamespace->RegisterProviderForClassChanges( 
                                                        pInfo->m_wszClassName,
                                                        wszProvName );

                // ignore error code --- what can we do?
                return WBEM_S_FALSE;
            }
            
            //
            // don't store, we'll retrieve it later as necessary.  This 
            // will require that the user call EnsureClasses() before calling
            // any function that needs those classes.
            //

            pClass->Release();
        }
    }
            
    // Get the event class
    // ===================

    _IWmiObject* pClass = NULL;
    hres = pNamespace->GetClass(m_pExpr->bsClassName, &pClass);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS,
            "Invalid event class %S in provider registration \n"
                    "Query was: %S\n\n", m_pExpr->bsClassName, wszQuery));

        CEventLog Log; Log.Open();
        Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_NOT_FOUND,
                                wszQuery, m_pExpr->bsClassName);

        //
        // Before continuing, we register for class creation event on this
        // class.  This way, when it is finally created, we will reactivate
        // stuff and bring the system back on track
        //

        hres = pNamespace->RegisterProviderForClassChanges(
                                                        m_pExpr->bsClassName,
                                                        wszProvName );
        // ignore error code --- what can we do?

        return WBEM_S_FALSE;
    }

    //
    // don't store, we'll retrieve it later as necessary.  This 
    // will require that the user call EnsureClasses() before calling
    // any function that needs those classes.
    //
    
    CReleaseMe rmpClass( pClass );

    if( pClass->InheritsFrom(L"__Event") != S_OK)
    {
        ERRORTRACE((LOG_ESS,
            "Invalid event class %S in provider registration \n"
                    "Query was: %S\n\n", m_pExpr->bsClassName, wszQuery));

        CEventLog Log; Log.Open();
        Log.Report(EVENTLOG_ERROR_TYPE, 
                                WBEM_MC_EVENT_PROVIDER_QUERY_NOT_EVENT,
                                wszQuery, m_pExpr->bsClassName);
        return WBEM_S_FALSE;
    }

    return WBEM_S_NO_ERROR;
}
    
CEventProviderCache::CRecord::CQueryRecord::~CQueryRecord()
{
    SysFreeString(m_strQuery);
    if(m_pEventClass)
        m_pEventClass->Release();
    delete m_paInstanceClasses;
    delete m_pExpr;
}

HRESULT CEventProviderCache::CRecord::CQueryRecord::Update(LPCWSTR wszClassName,
                            IWbemClassObject* pClass)
{
    HRESULT hres = WBEM_S_FALSE;

    // Check the event class
    // =====================

    if(!wbem_wcsicmp(wszClassName, m_pExpr->bsClassName))
    {
        if(pClass == NULL)
        {
            // This query record is hereby invalid
            // ===================================

            ERRORTRACE((LOG_ESS, 
                "Event provider query, %S, is invalidated by class "
                "deletion of %S\n", m_strQuery, m_pExpr->bsClassName));

            if(m_pEventClass)
                m_pEventClass->Release();
            m_pEventClass = NULL;
            delete m_paInstanceClasses;
            m_paInstanceClasses = NULL;
        }
        else
        {
            // Change the class definition
            // ===========================

            if(m_pEventClass)
            {
                m_pEventClass->Release();
                pClass->Clone(&m_pEventClass);
            }
        }

        hres = WBEM_S_NO_ERROR;
    }
            
    if(m_paInstanceClasses)
    {
        // Check the instance classes
        // ==========================

        for(int i = 0; i < m_paInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_paInstanceClasses->GetClass(i);
            
            if(!wbem_wcsicmp(wszClassName, pInfo->m_wszClassName))
            {
                if(pClass)
                {
                    // This class is no longer there
                    // =============================
        
                    ERRORTRACE((LOG_ESS,
                        "Class %S for which provider claims to provide"
                        " events is deleted", pInfo->m_wszClassName));

                    m_paInstanceClasses->RemoveClass(i);
                    i--;
                }
                else
                {
                    // Change the class definition
                    // ===========================
        
                    if(pInfo->m_pClass)
                    {
                        pInfo->m_pClass->Release();
                        pClass->Clone(&pInfo->m_pClass);
                    }
                }
                hres = WBEM_S_NO_ERROR;
            }
        }
    }

    return hres;
}
    
HRESULT CEventProviderCache::CRecord::CQueryRecord::DoesIntersectWithQuery(
                        IN CRequest& Request, CEssNamespace* pNamespace)
{
    HRESULT hres;

    if(m_pEventClass == NULL)
    {
        // Inactive record
        
        return WBEM_S_FALSE;
    }

    // Check that the classes are related --- one is derived from another
    // ==================================================================

    if(m_pEventClass->InheritsFrom(Request.GetQueryExpr()->bsClassName) 
                                != WBEM_S_NO_ERROR && 
       Request.GetEventClass(pNamespace)->InheritsFrom(m_pExpr->bsClassName)
                                != WBEM_S_NO_ERROR
      )
    {
        // Not the right class.
        // ====================

        return WBEM_S_FALSE;
    }

    // For extrinsic providers, this is good enough. But for 
    // intrinsic providers, we need to check if the requested
    // instance classes intersect with the provided ones
    // ======================================================

    if(Request.GetEventMask() & INSTANCE_EVENTS_MASK)
    {
        INTERNAL CClassInfoArray* pClasses = NULL;
        hres = Request.GetInstanceClasses(pNamespace, &pClasses);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,
                "Failed to determine instance classes required by query '%S':"
                "0x%X\n", Request.GetQuery(), hres));
            
            return hres;
        }

        if(!CQueryAnalyser::CompareRequestedToProvided(
                                      *pClasses, 
                                      *m_paInstanceClasses))
        {
            // This intrinsic provider does not need activation
            // ================================================

            return WBEM_S_FALSE;
        }
    }

    // All test have been passed
    // =========================

    return WBEM_S_NO_ERROR;
}

DWORD CEventProviderCache::CRecord::CQueryRecord::GetProvidedEventMask(
                                                   IWbemClassObject* pClass,
                                                   BSTR strClassName)
{
    if(m_pEventClass == NULL || m_paInstanceClasses == NULL)
    {
        // Not active as an intrinsic provider record
        // ==========================================

        return 0;
    }

    // Check that we supply intrinsic events
    // =====================================

    if((m_dwEventMask & INSTANCE_EVENTS_MASK) == 0)
        return 0;

    // Go through all the instance classes for which it provides events
    // ================================================================

    for(int k = 0; k < m_paInstanceClasses->GetNumClasses(); k++)
    {
        CClassInformation* pInfo = m_paInstanceClasses->GetClass(k);
        if(pInfo->m_pClass == NULL)
        {
            // Non-existent class
            // ==================

            return 0;
        }

        //
        // If desired class is derived from the provided class, then we are 
        // covered.  If it is the other way around, we are not
        //

        if(pClass->InheritsFrom(pInfo->m_wszClassName) == S_OK)
            return m_dwEventMask;
  }

    return 0;
}
    
//******************************************************************************
//******************************************************************************
//
//                                  CRECORD
//
//******************************************************************************
//******************************************************************************

CEventProviderCache::CRecord::CRecord()
    : m_strName(NULL), m_lRef(0), m_bStarted(false), m_lPermUsageCount(0),
       m_bProviderSet(FALSE), m_lUsageCount(0), m_pProvider(NULL),
       m_pQuerySink(NULL), m_pMainSink(NULL), m_pSecurity(NULL),
       m_LastUse(CWbemTime::GetCurrentTime()), m_bRecorded(FALSE),
       m_bNeedsResync(TRUE), m_strNamespace(NULL)
{
}

HRESULT CEventProviderCache::CRecord::Initialize( LPCWSTR wszName,
                                                  CEssNamespace* pNamespace )
                  
{
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();

    m_pMainSink = new CProviderSinkServer();
    if(m_pMainSink == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    m_pMainSink->AddRef();

    m_strNamespace = SysAllocString(pNamespace->GetName());
    if(m_strNamespace == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    if ( wszName != NULL )
    {
        m_strName = SysAllocString(wszName);
        if(m_strName == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    return m_pMainSink->Initialize(pNamespace, this);
}

CEventProviderCache::CRecord::~CRecord()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    if( m_pMainSink )
    {
        //
        // shutdown and release the sink server.  We must postpone the 
        // shutdown though because it will release any outstanding 
        // proxies which cannot be done while holding the namespace lock.
        //
        
        CPostponedList* pList = GetCurrentPostponedList();

        _DBG_ASSERT( pList != NULL );

        CPostponedSinkServerShutdown* pReq;

        pReq = new CPostponedSinkServerShutdown( m_pMainSink );

        if ( pReq != NULL )
        {
            if ( FAILED(pList->AddRequest( m_pNamespace, pReq ) ) )
            {
                delete pReq;
            }
        }

        m_pMainSink->Release();
    }

    UnloadProvider();

    SysFreeString(m_strNamespace);
    SysFreeString(m_strName);
}

ULONG CEventProviderCache::CRecord::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG CEventProviderCache::CRecord::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

BOOL CEventProviderCache::CRecord::IsEmpty() 
{
    return ( !m_bProviderSet && m_apQueries.GetSize() == 0);
}

HRESULT CEventProviderCache::CRecord::SetProvider(IWbemClassObject* pWin32Prov)
{
    HRESULT hres;

    // Clean out the old data
    // ======================
    
    m_bProviderSet = FALSE;

    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);

    // Verity object validity
    // ======================

    if(pWin32Prov->InheritsFrom(WIN32_PROVIDER_CLASS) != WBEM_S_NO_ERROR)
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;

    // removed doublecheck -  a decoupled provider does not have a clsid
	// if(FAILED(pWin32Prov->Get(PROVIDER_CLSID_PROPNAME, 0, &v, NULL, NULL)) ||
    //        V_VT(&v) != VT_BSTR)
    //    return WBEM_E_INVALID_PROVIDER_REGISTRATION;

    if(m_pProvider)
    {
        UnloadProvider();
    }

    // Store object for later use
    // ==========================

    m_bProviderSet = TRUE;

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::ResetProvider()
{
    if(m_bProviderSet)
    {
        m_bProviderSet = FALSE;
        return WBEM_S_NO_ERROR;
    }
    else
    {
        return WBEM_S_FALSE;
    }
}

HRESULT CEventProviderCache::CRecord::GetProviderInfo(
                                       IWbemClassObject* pRegistration, 
                                       BSTR& strName)
{
    VARIANT v;
    VariantInit(&v);
    strName = NULL;

    if(FAILED(pRegistration->Get(PROVIDER_NAME_PROPNAME, 0, &v, NULL, NULL)) ||
            V_VT(&v) != VT_BSTR)
    {
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    strName = V_BSTR(&v);
    // VARIANT intentionally not cleared
    return WBEM_S_NO_ERROR;
}
    
HRESULT CEventProviderCache::CRecord::GetRegistrationInfo(
                                       IWbemClassObject* pRegistration, 
                                       BSTR& strName)
{
    VARIANT v;
    VariantInit(&v);
    CClearMe cm1(&v);
    strName = NULL;

    if(FAILED(pRegistration->Get(EVPROVREG_PROVIDER_REF_PROPNAME, 0, &v, 
            NULL, NULL)) || V_VT(&v) != VT_BSTR)
    {
        ERRORTRACE((LOG_ESS, "NULL provider reference in event provider "
            "registration! Registration is invalid\n"));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    // Parse the path
    // ==============

    CObjectPathParser Parser;
    ParsedObjectPath* pPath;
    int nRes = Parser.Parse(V_BSTR(&v), &pPath);
    if(nRes != CObjectPathParser::NoError)
    {
        ERRORTRACE((LOG_ESS, "Unparsable provider reference in event provider "
            "registration: %S. Registration is invalid\n", V_BSTR(&v)));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    //
    // It would be good to check that the class specified here is valid, but
    // we cannot just compare the name since this may be a derived class of
    // __Win32Provider.  And getting the class definition and comparing would
    // be too expensive, so we'll just trust the provider here
    //
    //
    // if(_wcsicmp(pPath->m_pClass, WIN32_PROVIDER_CLASS))
    // {
    //     Parser.Free(pPath);
    //     return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    // }

    if(pPath->m_dwNumKeys != 1)
    {
        Parser.Free(pPath);
        ERRORTRACE((LOG_ESS, "Wrong number of keys in provider reference in "
            "event provider registration: %S. Registration is invalid\n", 
            V_BSTR(&v)));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    if(V_VT(&pPath->m_paKeys[0]->m_vValue) != VT_BSTR)
    {
        Parser.Free(pPath);
        ERRORTRACE((LOG_ESS, "Wrong key type in provider reference in event "
            "provider registration: %S. Registration is invalid\n", 
            V_BSTR(&v)));
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }

    strName = SysAllocString(V_BSTR(&pPath->m_paKeys[0]->m_vValue));
    Parser.Free(pPath);

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::SetQueries(CEssNamespace* pNamespace, 
                                                IWbemClassObject* pRegistration)
{
    HRESULT hres;
        
    // Get the list of class names
    // ===========================

    VARIANT v;
    VariantInit(&v);

    if(FAILED(pRegistration->Get(EVPROVREG_QUERY_LIST_PROPNAME, 0, &v, 
        NULL, NULL)) || V_VT(&v) != (VT_BSTR | VT_ARRAY))
    {
        ResetQueries();
        return WBEM_E_INVALID_PROVIDER_REGISTRATION;
    }
    CClearMe cm(&v);

    SAFEARRAY* psa = V_ARRAY(&v);
    long lLBound, lUBound;
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    long lElements = lUBound - lLBound + 1;

    BSTR* astrQueries;
    SafeArrayAccessData(psa, (void**)&astrQueries);
    CUnaccessMe um(psa);
    
    return SetQueries(pNamespace, lElements, (LPCWSTR*)astrQueries);
}

HRESULT CEventProviderCache::CRecord::SetQueries(CEssNamespace* pNamespace, 
                                                 long lNumQueries,
                                                 LPCWSTR* awszQueries)
{
    HRESULT hres;

    ResetQueries();

    // Create a record for each query
    // ==============================

    BOOL bUtilizeGuarantee = TRUE;

    for(long lQueryIndex = 0; lQueryIndex < lNumQueries; lQueryIndex++)
    {
        hres = AddDefinitionQuery(pNamespace, awszQueries[lQueryIndex]);

        if ( FAILED(hres) )
        {
            bUtilizeGuarantee = FALSE;
        }
        
        if( hres == WBEM_E_OUT_OF_MEMORY )
        {
            return hres;
        }
    }

    if ( bUtilizeGuarantee )
    {
        m_pMainSink->AllowUtilizeGuarantee();
    }

    return WBEM_S_NO_ERROR;
}


// assumes: CProviderSinkServer locked!
HRESULT CEventProviderCache::CRecord::AddDefinitionQuery(
                                                CEssNamespace* pNamespace, 
                                                LPCWSTR wszQuery)
{
    HRESULT hres;

    CQueryRecord* pNewQueryRecord = new CQueryRecord;
    if(pNewQueryRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = pNewQueryRecord->Initialize( wszQuery, m_strName, pNamespace, IsSystem());
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS,
            "Skipping provider %S invalid registration query %S\n",
            m_strName, wszQuery));
    }
    else
    {
        hres = m_pMainSink->AddDefinitionQuery(wszQuery);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, 
                "Skipping provider %S registration query %S\n"
               "   failed to merge: %X\n", 
                    m_strName, wszQuery, hres));
        }
        if(m_apQueries.Add(pNewQueryRecord) < 0)
        {
            delete pNewQueryRecord;
            hres = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hres;
}

HRESULT CEventProviderCache::CRecord::ResetQueries()
{
    m_apQueries.RemoveAll();
    m_pMainSink->RemoveAllDefinitionQueries();
    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::PostponeNewQuery(CExecLine::CTurn* pTurn,
        DWORD dwId, LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
        CAbstractEventSink* pDest)
{
    CPostponedList* pList = GetCurrentPostponedList();
    //
    // if null, then no thread object associated with thread.  caller may
    // need to use an CEssInternalOperationSink.
    // 
    _DBG_ASSERT( pList != NULL );

    CPostponedNewQuery* pReq = new CPostponedNewQuery(this, dwId, 
                        wszQueryLanguage, wszQuery, pTurn, pDest);
    if(pReq == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    HRESULT hr = pList->AddRequest( m_pNamespace, pReq);

    if ( FAILED(hr) )
    {
        delete pReq;
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::PostponeCancelQuery(
                                        CExecLine::CTurn* pTurn, DWORD dwId)
{
    CPostponedList* pList = GetCurrentPostponedList();
    //
    // if null, then no thread object associated with thread.  caller may
    // need to use an CEssInternalOperationSink.
    // 
    _DBG_ASSERT( pList != NULL );
    
    CPostponedCancelQuery* pReq = new CPostponedCancelQuery(this, pTurn, dwId);
    
    if( pReq == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = pList->AddRequest( m_pNamespace, pReq );

    if ( FAILED(hr) )
    {
        delete pReq;
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

// assumes: no locks are held
HRESULT CEventProviderCache::CRecord::Exec_LoadProvider(
                                            CEssNamespace* pNamespace)
{
    HRESULT hres;

    // Having locked the namespace, retrieve the necessary parameters
    // ==============================================================

    CLSID clsid;

    IWbemObjectSink* pEventSink = NULL;
    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        // Check if it is already loaded
        // =============================

        if(m_pProvider)
            return WBEM_S_FALSE;
    } 

    IWbemEventProvider* pProvider = NULL;
    hres = m_pNamespace->LoadEventProvider(m_strName, &pProvider);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to load event provider '%S' in namespace "
                    "'%S': 0x%X\n", m_strName, m_pNamespace->GetName(), hres));
        return hres;
    }
    CReleaseMe rm1(pProvider);

/* TAKEN CARE OF BY THE PROVSS
    //
    // In case this is a "framework" provider, inform it of its registration
    //

    IWbemProviderIdentity* pIdent = NULL;
    hres = pProvider->QueryInterface(IID_IWbemProviderIdentity, 
                                            (void**)&pIdent);
    if(SUCCEEDED(hres))
    {
        CReleaseMe rm(pIdent);
        hres = pIdent->SetRegistrationObject(0, m_pWin32Prov);

		if(hres == WBEM_E_PROVIDER_NOT_CAPABLE)
			hres = WBEM_S_SUBJECT_TO_SDS;

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Event provider %S failed to accept its "
                "registration object with error code 0x%X\n", m_strName, hres));
            return hres;
        }
    }
*/

    //
    // Deposit this and other provider pointers into the record
    //

    hres = SetProviderPointer(pNamespace, pProvider);
    if(FAILED(hres))
        return hres;

    //
    // Report the MSFT_WmiEventProviderLoaded event.
    //

    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiEventProviderLoaded], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        pNamespace->GetName(),
        m_strName);

    //
    // Postpone start until all activations are done
    //

    CPostponedList* pList = GetCurrentPostponedList();
    //
    // if null, then no thread object associated with thread.  caller may
    // need to use an CEssInternalOperationSink.
    // 
    _DBG_ASSERT( pList != NULL );
    
    CPostponedProvideEvents* pReq = new CPostponedProvideEvents(this);
    
    if(pReq == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hres = pList->AddRequest( m_pNamespace, pReq);

    if ( FAILED(hres) )
    {
        delete pReq;
    }
    
    return hres;
}

HRESULT CEventProviderCache::CRecord::SetProviderPointer(
                                                CEssNamespace* pNamespace,
                                                IWbemEventProvider* pProvider)
{
    HRESULT hres;

    //
    // Check the "smart provider" interface
    //

    IWbemEventProviderQuerySink* pQuerySink = NULL;
    hres = pProvider->QueryInterface(IID_IWbemEventProviderQuerySink,
                            (void**)&pQuerySink);
    CReleaseMe rm4(pQuerySink);

    //
    // Check the security interface
    //

    IWbemEventProviderSecurity* pSecurity = NULL;
    hres = pProvider->QueryInterface(IID_IWbemEventProviderSecurity,
                            (void**)&pSecurity);
    CReleaseMe rm5(pSecurity);

    // Having locked the namespace, deposit the pointers into the record
    // =================================================================

    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        m_pProvider = pProvider;
        pProvider->AddRef();
        m_pQuerySink = pQuerySink;
        if(pQuerySink)
            pQuerySink->AddRef();

        m_pSecurity = pSecurity;
        if(pSecurity)
            pSecurity->AddRef();
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CEventProviderCache::CRecord::Exec_StartProvider(
                                            CEssNamespace* pNamespace)
{
    IWbemEventProvider* pProvider = NULL;
    IWbemEventSink* pEventSink = NULL;
    HRESULT hres;

    {
        CInUpdate iu(pNamespace);

        if(m_bStarted)
            return WBEM_S_NO_ERROR;

        m_bStarted = true;

        pProvider = m_pProvider;
        if(pProvider)
            pProvider->AddRef();

        // Retrieve the sink to give to the provider
        // =========================================

        hres = m_pMainSink->GetMainProxy(&pEventSink);
        if(FAILED(hres))
            return hres;
    }

    CReleaseMe rm1(pProvider);
    CReleaseMe rm2(pEventSink);

    if(pProvider)
    {
        hres = pProvider->ProvideEvents(pEventSink, 0);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS,
                "Could not start provider %S. Error: %X\n", m_strName, hres));
            return WBEM_E_PROVIDER_FAILURE;
        }
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::AddActiveProviderEntryToRegistry()
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace, hkeyProvider;

    DEBUGTRACE((LOG_ESS,"Adding provider %S from namespace %S to "
                " registry as active provider\n", m_strName, m_strNamespace));

    //
    // open ess key.  It is expected that this key is already created. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );

    if ( lRes == ERROR_SUCCESS )
    {
        //
        // open namespace key. It is expected that this key is already created.
        //

        lRes = RegOpenKeyExW( hkeyEss,
                              m_strNamespace,
                              0, 
                              KEY_ALL_ACCESS,
                              &hkeyNamespace );

        if ( lRes == ERROR_SUCCESS )
        {
            //
            // create the provider sub key.
            //

            lRes = RegCreateKeyExW( hkeyNamespace,
                                    m_strName,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hkeyProvider,
                                    NULL );

            if ( lRes == ERROR_SUCCESS )
            {
                RegCloseKey( hkeyProvider );
            }
            
            RegCloseKey( hkeyNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    return HRESULT_FROM_WIN32( lRes );
}

HRESULT CEventProviderCache::CRecord::RemoveActiveProviderEntryFromRegistry()
{
    LONG lRes;
    HKEY hkeyEss, hkeyNamespace;

    DEBUGTRACE((LOG_ESS,"Removing provider %S from namespace %S from "
                " registry as active provider\n", m_strName, m_strNamespace));

    //
    // open ess key. 
    // 

    lRes = RegOpenKeyExW( HKEY_LOCAL_MACHINE, 
                          WBEM_REG_ESS,
                          0,
                          KEY_ALL_ACCESS,
                          &hkeyEss );

    if ( lRes == ERROR_SUCCESS )
    {
        //
        // open namespace key. It is expected that this key is already created.
        //

        lRes = RegOpenKeyExW( hkeyEss,
                              m_strNamespace,
                              0, 
                              KEY_ALL_ACCESS,
                              &hkeyNamespace );

        if ( lRes == ERROR_SUCCESS )
        {
            //
            // delete the provider sub key.
            //
            
            lRes = RegDeleteKeyW( hkeyNamespace, m_strName );

            RegCloseKey( hkeyNamespace );
        }

        RegCloseKey( hkeyEss );
    }

    return HRESULT_FROM_WIN32( lRes );
}
                           
void CEventProviderCache::CRecord::UnloadProvider()
{
    HRESULT hr;

    DEBUGTRACE((LOG_ESS,"Unloading Provider %S in namespace %S\n",
                m_strName, m_strNamespace ));

    //
    // make sure the provider is removed from the provider cache.  This is 
    // so if we load the provider again in the near future, we don't call 
    // ProvideEvents() on it twice. 
    // 

    if ( m_pProvider != NULL )
    {
        CWbemPtr<_IWmiProviderCache> pProvCache;

        hr = m_pProvider->QueryInterface( IID__IWmiProviderCache, 
                                          (void**)&pProvCache );

        if ( SUCCEEDED(hr) )
        {
            hr = pProvCache->Expel( 0, GetCurrentEssContext() );

            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"Could not expel provider %S from "
                            "provider cache in namespace %S. HR=0x%x\n",
                            m_strName,m_strNamespace,hr));
            }
        }

        m_pNamespace->PostponeRelease(m_pProvider);
        m_pProvider = NULL;
    }

    if(m_pQuerySink)
        m_pNamespace->PostponeRelease(m_pQuerySink);
    m_pQuerySink = NULL;

    if(m_pSecurity)
        m_pNamespace->PostponeRelease(m_pSecurity);
    m_pSecurity = NULL;
    m_bStarted = false;

    //
    // Report the MSFT_WmiEventProviderUnloaded event.
    //
    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiEventProviderUnloaded], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        m_strNamespace,
        m_strName);
}

HRESULT CEventProviderCache::CRecord::Exec_NewQuery(CEssNamespace* pNamespace,
            CExecLine::CTurn* pTurn,
            DWORD dwID, LPCWSTR wszLanguage, LPCWSTR wszQuery,
            CAbstractEventSink* pDest)
{
    HRESULT hres;

    // Wait for our turn to make changes
    // =================================

    CExecLine::CInTurn it(&m_Line, pTurn);
    
    hres = ActualExecNewQuery(pNamespace, dwID, wszLanguage, wszQuery, pDest);
    if(FAILED(hres))
    {
        //
        // Check:  it could be provider needs to be restarted
        //
    
        if(HRESULT_FACILITY(hres) != FACILITY_ITF)
        {
            ERRORTRACE((LOG_ESS, "Non-WMI error code recieved from provider "
                "%S: 0x%x.  WMI will attempt to re-activate\n", m_strName,
                hres));

            {
                CInUpdate iu( pNamespace );        
                UnloadProvider();
            }
            
            hres = ActualExecNewQuery(pNamespace, dwID, wszLanguage, wszQuery,
                                        pDest);
        }
    }

    if(FAILED(hres))
    {
        // Filter activation failed:  deactivate
        // =====================================

        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        pNamespace->DeactivateFilter(pDest->GetEventFilter());
    }

    return hres;
}

HRESULT CEventProviderCache::CRecord::ActualExecNewQuery(
            CEssNamespace* pNamespace,
            DWORD dwID, LPCWSTR wszLanguage, LPCWSTR wszQuery,
            CAbstractEventSink* pDest)
{
    HRESULT hres;

    // Ensure provider is loaded
    // =========================

    hres = Exec_LoadProvider(pNamespace);
    if(FAILED(hres))
        return hres;

    // With namespace locked, check if the provider is loaded
    // ======================================================

    IWbemEventProviderQuerySink* pSink = NULL;
    IWbemEventProviderSecurity* pSecurity = NULL;
    PSID pCopySid = NULL;
    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        if(m_pQuerySink != NULL)
        {
            pSink = m_pQuerySink;
            pSink->AddRef();
        }
        if(m_pSecurity != NULL)
        {
            pSecurity = m_pSecurity;
            pSecurity->AddRef();

            // Make a copy of the filter's owner SID
            // =====================================

            PSID pActualSid = pDest->GetEventFilter()->GetOwner();
            if(pActualSid != NULL)
            {
                pCopySid = new BYTE[GetLengthSid(pActualSid)];
                if(pCopySid == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
    
                if(!CopySid(GetLengthSid(pActualSid), pCopySid, pActualSid))
                {
                    delete [] pCopySid;
                    return WBEM_E_OUT_OF_MEMORY;
                }
            }
        }
    }

    CReleaseMe rm1(pSink);
    CReleaseMe rm2(pSecurity);
    CVectorDeleteMe<BYTE> vdm((BYTE*)pCopySid);
    
    //
    // Check security, if possible.  If provider does not support the interface,
    // interpret as "check SDs", as this may be a new-model-only provider
    //

    hres = WBEM_S_SUBJECT_TO_SDS;
    if(pSecurity)
    {
        DWORD dwSidLen = pCopySid ? GetLengthSid(pCopySid) : 0;

        // Check security based on the SID or thread
        // =========================================

        if ( dwSidLen == 0 )
        {
            //
            // Check security based on the thread.  First save the current
            // call context, then switch it back after we're done.
            //
            
            IUnknown *pOldCtx, *pTmpCtx;
            CoSwitchCallContext( NULL, &pOldCtx );
            
            pDest->GetEventFilter()->SetThreadSecurity();
            
            hres = pSecurity->AccessCheck( wszLanguage, 
                                           wszQuery, 
                                           0, 
                                           NULL );
            
            CoSwitchCallContext( pOldCtx, &pTmpCtx ); 
        }
        else
        {
            hres = pSecurity->AccessCheck( wszLanguage, 
                                           wszQuery, 
                                           dwSidLen, 
                                           (BYTE*)pCopySid);
        }

        //
        // Report the MSFT_WmiEventProviderAccessCheck event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiEventProviderAccessCheck], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_strNamespace,
            m_strName,
            wszLanguage,
            wszQuery,
            pCopySid, dwSidLen,
            hres);
    }
    
	if(hres == WBEM_E_PROVIDER_NOT_CAPABLE)
		hres = WBEM_S_NO_ERROR;

    if(SUCCEEDED(hres))
    {
        // Security check has been passed: decrement remaining count
        // =========================================================

        pDest->GetEventFilter()->DecrementRemainingSecurityChecks(hres);
    }
    else
    {
        ERRORTRACE((LOG_ESS, "Event provider refused consumer registration "
            "query %S for security reasons: 0x%X\n", wszQuery, hres));
    }

    // Call "NewQuery" if required
    // ===========================

    if(SUCCEEDED(hres) && pSink)
    {
        hres = pSink->NewQuery(dwID, (LPWSTR)wszLanguage, (LPWSTR)wszQuery);
		if(hres == WBEM_E_PROVIDER_NOT_CAPABLE)
			hres = WBEM_S_NO_ERROR;
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Event provider refused consumer registration "
                "query %S: error code 0x%X\n", wszQuery, hres));
        }

        //
        // Report the MSFT_WmiEventProviderNewQuery event.
        //
        FIRE_NCEVENT(
            g_hNCEvents[MSFT_WmiEventProviderNewQuery], 
            WMI_SENDCOMMIT_SET_NOT_REQUIRED,

            // Data follows...
            m_strNamespace,
            m_strName,
            wszLanguage,
            wszQuery,
            dwID,
            hres);
    }

    return hres;
}

HRESULT CEventProviderCache::CRecord::Exec_CancelQuery(
                            CEssNamespace* pNamespace, CExecLine::CTurn* pTurn,
                            DWORD dwId)
{
    CExecLine::CInTurn it(&m_Line, pTurn);

    // With namespace locked, check if the provider is loaded
    // ======================================================

    IWbemEventProviderQuerySink* pSink = NULL;
    {
        CInUpdate iu(pNamespace);

        if(pNamespace->IsShutdown())
            return WBEM_E_INVALID_NAMESPACE;

        if(m_pQuerySink == NULL)
            return WBEM_S_FALSE;

        pSink = m_pQuerySink;
        pSink->AddRef();
    }

    CReleaseMe rm1(pSink);
    
    // Make the call
    // =============
    HRESULT hr;

    hr = pSink->CancelQuery(dwId);

    //
    // Report the MSFT_WmiEventProviderCancelQuery event.
    //
    FIRE_NCEVENT(
        g_hNCEvents[MSFT_WmiEventProviderCancelQuery], 
        WMI_SENDCOMMIT_SET_NOT_REQUIRED,

        // Data follows...
        m_strNamespace,
        m_strName,
        dwId,
        hr);

    return hr;
}

HRESULT CEventProviderCache::CRecord::DeliverProviderRequest(
                        long lFlags)
{
    HRESULT hres;

    //
    // The only requirement we support is WBEM_REQUIREMENT_RECHECK_SUBSCRIPTIONS
    //

    if(lFlags != WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS)
        return WBEM_E_INVALID_PARAMETER;

    //
    // With this object locked, retrieve all the filters for this provider. 
    // Get provider pointers, as well
    //

    CProviderSinkServer::TDestinationArray apDestinations;
    IWbemEventProviderQuerySink* pSink = NULL;
    IWbemEventProviderSecurity* pSecurity = NULL;

    {
        CInUpdate iu(m_pMainSink->GetNamespace());

        hres = m_pMainSink->GetDestinations(apDestinations);
        if(FAILED(hres))
            return hres;

        if(m_pQuerySink != NULL)
        {
            pSink = m_pQuerySink;
            pSink->AddRef();
        }

        if(m_pSecurity != NULL)
        {
            pSecurity = m_pSecurity;
            pSecurity->AddRef();
        }
    }

    CReleaseMe rm1(pSink);
    CReleaseMe rm2(pSecurity);

    // 
    // Iterate over them all, rechecking each with the provider
    //

    for(int i = 0; i < apDestinations.GetSize(); i++)
    {
        CProviderSinkServer::CEventDestination* pEventDest = apDestinations[i];
        CAbstractEventSink* pDest = pEventDest->m_pSink;

        // 
        // Retrieve the event filter associated with this sink
        //

        CEventFilter* pFilter = pDest->GetEventFilter();
        if(pFilter == NULL)
        {
            ERRORTRACE((LOG_ESS, "Internal error: non-filter sink in proxy\n"));
            continue;
        }

        //
        // Retrieve the query from this filter.
        //

        LPWSTR wszQuery;
        LPWSTR wszQueryLanguage;
        BOOL bExact;
        hres = pFilter->GetCoveringQuery(wszQueryLanguage, wszQuery,
                                       bExact, NULL);
        if(FAILED(hres) || !bExact)
            continue;
        
        CVectorDeleteMe<WCHAR> vdm1(wszQuery);
        CVectorDeleteMe<WCHAR> vdm2(wszQueryLanguage);

        //
        // Check security first
        //

        if(pSecurity)
        {
            PSID pSid = pFilter->GetOwner();
            if(pSid)
            {
                // Check security based on SID
                hres = pSecurity->AccessCheck(wszQueryLanguage, wszQuery, 
                                            GetLengthSid(pSid), 
                                            (BYTE*)pSid);
            }
            else
            {
                //
                // Check security based on the thread.  First save the current
                // call context, then switch it back after we're done.
                //

                IUnknown *pOldCtx, *pTmpCtx;
                CoSwitchCallContext( NULL, &pOldCtx );

                pFilter->SetThreadSecurity();

                hres = pSecurity->AccessCheck( wszQueryLanguage, 
                                               wszQuery, 
                                               0, 
                                               NULL );

                CoSwitchCallContext( pOldCtx, &pTmpCtx ); 
            }
            if(FAILED(hres))
            {
                //
                // Increment remaining security checks, thus disabling filter
                //

                ERRORTRACE((LOG_ESS, "Disabling filter %S as provider denies "
                    " access for this user: 0x%X\n", wszQuery, hres));
                
                pFilter->IncrementRemainingSecurityChecks();
            }
        }

        if(SUCCEEDED(hres) && pSink)
        {
            //
            // Check everything else --- do a NewQuery
            //

            hres = pSink->NewQuery(pEventDest->m_id, (LPWSTR)wszQueryLanguage, 
                        (LPWSTR)wszQuery);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS, "Disabling filter %S as provider refuses "
                    "registration: error code 0x%X\n", wszQuery, hres));
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

CExecLine::CTurn* CEventProviderCache::CRecord::GetInLine()
{
    return m_Line.GetInLine();
}
void CEventProviderCache::CRecord::DiscardTurn(CExecLine::CTurn* pTurn)
{
    m_Line.DiscardTurn(pTurn);
}

HRESULT CEventProviderCache::CRecord::Activate(CEssNamespace* pNamespace, 
                                                CRequest* pRequest,
                                        WBEM_REMOTE_TARGET_ID_TYPE idRequest)
{
    CExecLine::CTurn* pTurn = GetInLine();
    if(pTurn == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_lUsageCount++;
    m_LastUse = CWbemTime::GetCurrentTime();

    if ( pRequest->GetDest()->GetEventFilter()->IsPermanent() )
    {
        m_lPermUsageCount++;
        CheckPermanentUsage();
    }

    // Notify him of the new query, if required
    // ========================================

    HRESULT hr;

    hr = PostponeNewQuery( pTurn, 
                           idRequest, 
                           L"WQL", 
                           pRequest->GetQuery(), 
                           pRequest->GetDest() );
    if ( FAILED(hr) )
    {
        DiscardTurn( pTurn );
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::CRecord::Deactivate( CAbstractEventSink* pDest,
                                        WBEM_REMOTE_TARGET_ID_TYPE idRequest )
{
    if( !m_bProviderSet )
    {
        // Provider is not registered.
        // ===========================

        return WBEM_S_FALSE;
    }

    // Notify him of the cancellation, if required
    // ===========================================

    CExecLine::CTurn* pTurn = GetInLine();

    if(pTurn == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hr = PostponeCancelQuery(pTurn, idRequest);

    if ( FAILED(hr) )
    {
        DiscardTurn( pTurn );
        return hr;
    }

    m_lUsageCount--;
    m_LastUse = CWbemTime::GetCurrentTime();
    
    if ( pDest->GetEventFilter()->IsPermanent() )
    {
        //
        // TODO: Out usage counts can easily get out of wack because of 
        // mismatched Activate/Deactivates in the presence of failures.
        // _DBG_ASSERT( m_lPermUsageCount > 0 );
        //
        m_lPermUsageCount--;
        CheckPermanentUsage();
    }
        
    return WBEM_S_NO_ERROR;
}
    
HRESULT CEventProviderCache::CRecord::DeactivateFilter(
                                        CAbstractEventSink* pDest)
{
    HRESULT hres;

    // Try to remove it from our stub
    // ==============================

    WBEM_REMOTE_TARGET_ID_TYPE idRequest;
    hres = m_pMainSink->RemoveFilter(pDest, &idRequest);

    if(hres == WBEM_E_NOT_FOUND) // not there --- no problem
        return WBEM_S_FALSE;
    else if(FAILED(hres))
        return hres;

    hres = Deactivate( pDest, idRequest);

    return hres;
}



HRESULT CEventProviderCache::CRecord::ActivateIfNeeded(CRequest& Request, 
                                        IN CEssNamespace* pNamespace)
{
    HRESULT hres;

    // Go through all the classes supplied by the provider and see if ours
    // is an ancestor of any of them.
    // ===================================================================

    for(int j = 0; j < m_apQueries.GetSize(); j++)
    {
        CQueryRecord* pQueryRecord = m_apQueries[j];

        _DBG_ASSERT( pQueryRecord != NULL );
        pQueryRecord->EnsureClasses( pNamespace );

        hres = pQueryRecord->DoesIntersectWithQuery(Request, pNamespace);
        
        pQueryRecord->ReleaseClasses();

        if(FAILED(hres))
        {
            // Something is wrong with the query itself --- no point in 
            // continuing to other registrations
            // ========================================================

            return hres;
        }
        else if(hres == WBEM_S_NO_ERROR)
        {
            DEBUGTRACE((LOG_ESS,"Activating filter '%S' with provider %S\n",
                        Request.GetQuery(), m_strName ));

            // First, increment the number of remaining security checks on this
            // filter, since, even though we are adding it to the proxy, we do 
            // not want events reaching it until the provider said OK
            // ================================================================

            Request.GetDest()->GetEventFilter()->
                                    IncrementRemainingSecurityChecks();

            // Add this filter to the proxies
            // ==============================
    
            WBEM_REMOTE_TARGET_ID_TYPE idRequest;
            hres = m_pMainSink->AddFilter(Request.GetQuery(), 
                                            Request.GetQueryExpr(),
                                            Request.GetDest(),
                                            &idRequest);
            if(FAILED(hres)) return hres;

            // Schedule activation of this record, which will involve loading
            // and notifying the provider. Also at that time, filter's security
            // check count will be reduced and events can start flowing
            // ================================================================

            hres = Activate(pNamespace, &Request, idRequest);

            if(hres != WBEM_S_NO_ERROR) // S_FALSE means no provider
            {
                m_pMainSink->RemoveFilter(Request.GetDest());
                return hres;
            }

            // No point in continuing --- the provider has been activated
            // ==========================================================
    
            break;
        }
    }

    return WBEM_S_NO_ERROR;
}



HRESULT CEventProviderCache::CRecord::CancelAllQueries()
{
    HRESULT hres;

    //
    // With this object locked, retrieve all the filters for this provider. 
    // Get provider pointers, as well
    //

    CProviderSinkServer::TDestinationArray apDestinations;
    IWbemEventProviderQuerySink* pSink = NULL;

    {
        CInUpdate iu(m_pMainSink->GetNamespace());

        if(m_pQuerySink == NULL)
        {
            //
            // Nothing to cancel!
            //

            return WBEM_S_FALSE;
        }

        hres = m_pMainSink->GetDestinations(apDestinations);
        if(FAILED(hres))
            return hres;

        pSink = m_pQuerySink;
        pSink->AddRef();
    }

    CReleaseMe rm1(pSink);

    // 
    // Iterate over them all, rechecking each with the provider
    //

    for(int i = 0; i < apDestinations.GetSize(); i++)
    {
        CProviderSinkServer::CEventDestination* pEventDest = apDestinations[i];

        //
        // Notify the provider of the cancellation
        //

        CExecLine::CTurn* pTurn = GetInLine();
        
        if( pTurn == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hres = PostponeCancelQuery(pTurn, pEventDest->m_id);
        
        if( FAILED(hres) )
        {
            DiscardTurn( pTurn );
            return hres;
        }
    }

    return S_OK;
}

//
// takes care of storing permanently the 'permanent' usage state of a provider 
//  
void CEventProviderCache::CRecord::CheckPermanentUsage()
{
    HRESULT hr;

    if ( IsSystem() )
    {
        return;
    }

    if ( m_lPermUsageCount == 0 && m_bRecorded )
    {
        hr = RemoveActiveProviderEntryFromRegistry();

        //
        // no matter what the outcome, make sure to set recorded to false.
        // 

        m_bRecorded = FALSE;

        //
        // since a namespace is deactivated before the filters are deactivated,
        // ( because filter deactivation is postponed ), it is possible that 
        // the namespace key will be deleted by the time we get here. 
        // this happens when we're deactivating the last permanent consumer
        // in the namespace.
        //

        if ( FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
        {
            ERRORTRACE((LOG_ESS,"Error removing active provider entry "
                        "from registry in namespace %S. HR=0x%x\n",
                        m_pNamespace->GetName(), hr ));
        }
    }
    else if ( m_lPermUsageCount > 0 && !m_bRecorded )
    {
        hr = AddActiveProviderEntryToRegistry();

        if ( SUCCEEDED(hr) )
        {
            m_bRecorded = TRUE;
        }
        else
        {
            ERRORTRACE((LOG_ESS,"Error adding active provider entry "
                        "to registry in namespace %S. HR=0x%x\n",
                        m_pNamespace->GetName(), hr ));
        }
    }
}

void CEventProviderCache::CRecord::ResetUsage()
{
    DEBUGTRACE((LOG_ESS,"Resetting provider '%S' in namespace '%S' to prepare "
                "for resync.\n", m_strName, m_strNamespace ));
    //
    // set a flag so that when all filters are reactivated we know to 
    // process them for this record.  
    //
    m_bNeedsResync = TRUE;

    CancelAllQueries();
    m_lUsageCount = 0;

    //
    // when the changes to the event provider cache is committed, we will 
    // enumerate all records and remove ones having a perm usage count still 0
    // from the registry. 
    // 
    m_lPermUsageCount = 0;

    m_pMainSink->RemoveAllFilters();
}

bool CEventProviderCache::CRecord::DeactivateIfNotUsed()
{
    if(m_lUsageCount == 0 && m_pProvider)
    {
        // Stop the provider
        // =================

        UnloadProvider();
        DEBUGTRACE((LOG_ESS, "Unloading event provider %S\n", m_strName));

        return true;
    }
    else
        return false;
}

bool CEventProviderCache::CRecord::IsUnloadable()
{
    return (IsActive() && GetUsageCount() == 0);
}

DWORD CEventProviderCache::CRecord::GetProvidedEventMask(
                                            IWbemClassObject* pClass,
                                            BSTR strClassName)
{
    DWORD dwEventMask = 0;

    // Go through all its registered queries
    // =====================================

    for(int j = 0; j < m_apQueries.GetSize(); j++)
    {
        CRecord::CQueryRecord* pQueryRecord = m_apQueries.GetAt(j);

        _DBG_ASSERT( pQueryRecord != NULL );
        pQueryRecord->EnsureClasses( m_pNamespace );

        dwEventMask |= pQueryRecord->GetProvidedEventMask(pClass, strClassName);

        pQueryRecord->ReleaseClasses();
    }

    return dwEventMask;
}


bool CEventProviderCache::CSystemRecord::DeactivateIfNotUsed()
{
    //
    // System providers cannot be deactivated
    //

    return false;
}
    
bool CEventProviderCache::CSystemRecord::IsUnloadable()
{
    //
    // System providers cannot be deactivated
    //

    return false;
}
    
/*
HRESULT CEventProviderCache::CSystemRecord::PostponeNewQuery(
                                 CExecLine::CTurn* pTurn, DWORD dwId, 
                                 LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                                 CAbstractEventSink* pDest)
{
    //
    // System providers do not need calls to them postponed!
    //

    return Exec_NewQuery(m_pNamespace, pTurn, dwId, wszQueryLanguage, wszQuery,
                            pDest);
}

    
HRESULT CEventProviderCache::CSystemRecord::PostponeCancelQuery(
                                CExecLine::CTurn* pTurn, DWORD dwId)
{
    //
    // System providers do not need calls to them postponed!
    //

    return Exec_CancelQuery(m_pNamespace, pTurn, dwId);
}
*/

//******************************************************************************
//******************************************************************************
//
//                            REQUEST
//
//******************************************************************************
//******************************************************************************

CEventProviderCache::CRequest::CRequest(IN CAbstractEventSink* pDest, 
        LPWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp)
    : m_pDest(pDest), 
        m_wszQuery(wszQuery), m_pExpr(pExp), 
        m_dwEventMask(0), m_papInstanceClasses(NULL), m_pEventClass(NULL)
{
}

CEventProviderCache::CRequest::~CRequest()
{
    // Do not delete namespace, language, and query, and QL -- they were STOREd
    // ========================================================================

    if(m_papInstanceClasses)
        delete m_papInstanceClasses;
    if(m_pEventClass)
        m_pEventClass->Release();
}

INTERNAL QL_LEVEL_1_RPN_EXPRESSION* CEventProviderCache::CRequest::
GetQueryExpr()
{
    return m_pExpr;
}

DWORD CEventProviderCache::CRequest::GetEventMask()
{
    if(m_dwEventMask == 0)
    {
        QL_LEVEL_1_RPN_EXPRESSION* pExpr = GetQueryExpr();
        if(pExpr == NULL)
            return 0;
        m_dwEventMask = 
            CEventRepresentation::GetTypeMaskFromName(pExpr->bsClassName);
    }

    return m_dwEventMask;
}
    
HRESULT CEventProviderCache::CRequest::GetInstanceClasses(
                                        CEssNamespace* pNamespace,
                                        INTERNAL CClassInfoArray** ppClasses)
{
    *ppClasses = NULL;
    if(!m_papInstanceClasses)
    {
        QL_LEVEL_1_RPN_EXPRESSION* pExpr = GetQueryExpr();
        if(pExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        HRESULT hres = CQueryAnalyser::GetPossibleInstanceClasses(
                        pExpr, m_papInstanceClasses);
        if(FAILED(hres))
        {
            return hres;
        }

        if(m_papInstanceClasses == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        // Get the actual classes from the namespace
        // =========================================

        for(int i = 0; i < m_papInstanceClasses->GetNumClasses(); i++)
        {
            CClassInformation* pInfo = m_papInstanceClasses->GetClass(i);
            _IWmiObject* pClass = NULL;

            hres = pNamespace->GetClass(pInfo->m_wszClassName, &pClass);
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS,
                    "Could not get class %S for which intrinsic events"
                    " are requested. Error code: %X\n", 
                    pInfo->m_wszClassName, hres));

                delete m_papInstanceClasses;
                m_papInstanceClasses = NULL;

                if(hres == WBEM_E_NOT_FOUND)
                    hres = WBEM_E_INVALID_CLASS;

                return hres;
            }

            pInfo->m_pClass = pClass;
        }

    }
    *ppClasses = m_papInstanceClasses;
    return WBEM_S_NO_ERROR;
}

INTERNAL IWbemClassObject* CEventProviderCache::CRequest::GetEventClass(
                                        CEssNamespace* pNamespace)
{
    HRESULT hres;
    if(m_pEventClass == NULL)
    {
        QL_LEVEL_1_RPN_EXPRESSION* pExpr = GetQueryExpr();
        if(pExpr == NULL)
            return NULL;

        _IWmiObject* pClass = NULL;
        hres = pNamespace->GetClass(pExpr->bsClassName, &pClass);
        if(FAILED(hres))
        {
            return NULL;
        }
        m_pEventClass = pClass;
    }

    return m_pEventClass;
}

HRESULT CEventProviderCache::CRequest::CheckValidity(CEssNamespace* pNamespace)
{
    if(GetQueryExpr() == NULL)
        return WBEM_E_INVALID_QUERY;

    if(GetEventClass(pNamespace) == NULL)
        return WBEM_E_INVALID_CLASS;

    return WBEM_S_NO_ERROR;
}
//******************************************************************************
//******************************************************************************
//
//                            PROVIDER CACHE
//
//******************************************************************************
//******************************************************************************


CEventProviderCache::CEventProviderCache(CEssNamespace* pNamespace) 
    : m_pNamespace(pNamespace), m_pInstruction(NULL), m_bInResync(FALSE)
{
}

CEventProviderCache::~CEventProviderCache()
{
    Shutdown();
}

// assumes: in m_cs
long CEventProviderCache::FindRecord(LPCWSTR wszName)
{
    for(long l = 0; l < m_aRecords.GetSize(); l++)
    {
        if(!_wcsicmp(wszName, m_aRecords[l]->m_strName))
        {
            return l;
        }
    }

    return -1;
}

HRESULT CEventProviderCache::AddProvider(IWbemClassObject* pWin32Prov)
{
    HRESULT hres;
    CInCritSec ics(&m_cs);

    if(m_pNamespace == NULL)
        return WBEM_E_INVALID_NAMESPACE;

    // Determine provider's name
    // =========================

    BSTR strName;
    hres = CRecord::GetProviderInfo(pWin32Prov, strName);
    if(FAILED(hres))
        return hres;
    CSysFreeMe sfm1(strName);

    // Check if it exists
    // ==================

    long lIndex = FindRecord(strName);
    if(lIndex != -1)
    {
        // Already there
        // =============

        hres = m_aRecords[lIndex]->SetProvider(pWin32Prov);
        if(FAILED(hres))
            return hres;

        return WBEM_S_FALSE;
    }

    // Create a new provider record
    // ============================

    CRecord* pNewRecord = _new CRecord;
    if(pNewRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewRecord->AddRef();
    CTemplateReleaseMe<CRecord> rm1(pNewRecord);
        
    hres = pNewRecord->Initialize( strName, m_pNamespace );
    if(FAILED(hres)) 
        return hres;

    hres = pNewRecord->SetProvider(pWin32Prov);
    if(FAILED(hres)) 
        return hres;

    // Store it
    // ========

    if(m_aRecords.Add(pNewRecord) < 0)
    {
        delete pNewRecord;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::AddSystemProvider(IWbemEventProvider* pProvider,
											    LPCWSTR wszName,
                                                long lNumQueries,
                                                LPCWSTR* awszQueries)
{
    CInCritSec ics(&m_cs);
    HRESULT hres;

    //
    // First of all, construct a system provider record and add it
    //

    CSystemRecord* pNewRecord = new CSystemRecord;
    if(pNewRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    pNewRecord->AddRef();
    CTemplateReleaseMe<CSystemRecord> rm1(pNewRecord);
        
    hres = pNewRecord->Initialize( wszName, m_pNamespace);
    if(FAILED(hres)) 
        return hres;

    //
    // Now, add all the queries in
    //

    hres = pNewRecord->SetQueries(m_pNamespace, lNumQueries, awszQueries);
    if(FAILED(hres)) 
        return hres;

    //
    // Populate it with the provider pointer
    //

    hres = pNewRecord->SetProviderPointer(m_pNamespace, pProvider);
    if(FAILED(hres)) 
        return hres;

    //
    // Launch it
    //

    hres = pNewRecord->Exec_StartProvider(m_pNamespace);
    if(FAILED(hres)) 
        return hres;
    
    m_aRecords.Add(pNewRecord);

    return WBEM_S_NO_ERROR;
}
    
    
HRESULT CEventProviderCache::RemoveProvider(IWbemClassObject* pWin32Prov)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    // Determine provider's name
    // =========================

    BSTR strName;
    hres = CRecord::GetProviderInfo(pWin32Prov, strName);
    if(FAILED(hres))
        return hres;

    // Find this record
    // ================

    long lIndex = FindRecord(strName);
    SysFreeString(strName);
    if(lIndex == -1)
    {
        return WBEM_S_FALSE;
    }
    else
    {
        m_aRecords[lIndex]->ResetUsage();
        m_aRecords[lIndex]->ResetProvider();

        if(m_aRecords[lIndex]->IsEmpty())
        {
            m_aRecords.RemoveAt(lIndex);
        }

        return WBEM_S_NO_ERROR;
    }
}

HRESULT CEventProviderCache::CheckProviderRegistration(
                                IWbemClassObject* pRegistration)
{
    CInCritSec ics(&m_cs);
    
    if(m_pNamespace == NULL)
        return WBEM_E_INVALID_NAMESPACE;

    HRESULT hres;

    // Create a new provider record
    // ============================

    CRecord* pRecord = new CRecord;
    if(pRecord == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<CRecord> dm1(pRecord);
    
    hres = pRecord->Initialize( NULL, m_pNamespace );
    if(FAILED(hres))
        return hres;

    // Set the queries into it
    // =======================

    hres = pRecord->SetQueries(m_pNamespace, pRegistration);
    return hres;
}

HRESULT CEventProviderCache::AddProviderRegistration(
                                IWbemClassObject* pRegistration)
{
    HRESULT hres;
    BSTR strName;

    if( m_pNamespace == NULL )
    {
        return WBEM_E_INVALID_NAMESPACE;
    }

    hres = CRecord::GetRegistrationInfo( pRegistration, strName );
    
    if( FAILED(hres) ) 
    {
        return hres;
    }

    CSysFreeMe sfm( strName );

    CInCritSec ics(&m_cs);

    long lIndex = FindRecord( strName );
    
    if(lIndex == -1)
    {
        CRecord* pRecord = new CRecord;
        
        if(pRecord == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        
        hres = pRecord->Initialize( strName, m_pNamespace );

        if(FAILED(hres))
        {
            delete pRecord;
            return hres;
        }

        hres = pRecord->SetQueries(m_pNamespace, pRegistration);

        if ( FAILED(hres) )
        {
            delete pRecord;
            return hres;
        }

        lIndex = m_aRecords.Add(pRecord);

        if(lIndex == -1)
        {
            delete pRecord;
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        hres = m_aRecords[lIndex]->SetQueries(m_pNamespace, pRegistration);
    }
        
    return hres;
}

HRESULT CEventProviderCache::RemoveProviderRegistration(
                                    IWbemClassObject* pRegistration)
{
    HRESULT hres;
    BSTR strName;

    hres = CRecord::GetRegistrationInfo( pRegistration, strName );
    
    if( FAILED(hres) ) 
    {
        return hres;
    }

    CSysFreeMe sfm( strName );

    CInCritSec ics(&m_cs);

    long lIndex = FindRecord( strName );
   
    if(lIndex == -1)
       return WBEM_S_FALSE;

    // Set registration info
    // =====================

    m_aRecords[lIndex]->ResetUsage();
    m_aRecords[lIndex]->ResetQueries();

    if(m_aRecords[lIndex]->IsEmpty())
    {
        m_aRecords.RemoveAt(lIndex);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::ReleaseProvidersForQuery(CAbstractEventSink* pDest)
{
    CInCritSec ics(&m_cs);
    HRESULT hres;

    // Search all the providers
    // ========================

    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];
        hres = pRecord->DeactivateFilter(pDest);

        // If failures occur, they are logged. Continue.
    }

    // Make sure unload instruction is running
    // =======================================

    EnsureUnloadInstruction();

    return  WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::LoadProvidersForQuery(LPWSTR wszQuery,
        QL_LEVEL_1_RPN_EXPRESSION* pExp, CAbstractEventSink* pDest)
{
    CInCritSec ics(&m_cs);

    if(m_pNamespace == NULL)
        return WBEM_E_INVALID_NAMESPACE;

    HRESULT hres;

    // DEBUGTRACE((LOG_ESS, "Activating providers for %S (%p)\n", 
    //             wszQuery, pDest));

    // Create a request record
    // =======================

    CRequest Request(pDest, wszQuery, pExp);

    // Check query validity
    // ====================

    hres = Request.CheckValidity(m_pNamespace);
    if(FAILED(hres))
        return hres;

    // Search all the providers
    // ========================

    HRESULT hresGlobal = WBEM_S_NO_ERROR;
    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];

        if ( !m_bInResync || pRecord->NeedsResync() )
        {
            HRESULT hr = pRecord->ActivateIfNeeded(Request, m_pNamespace);
            if(FAILED(hr))
               hresGlobal = hr;
        }
    }

    return hresGlobal;
}

void CEventProviderCache::EnsureUnloadInstruction()
{
    if(m_pInstruction == NULL && m_pNamespace != NULL)
    {
        m_pInstruction = new CEventProviderWatchInstruction(this);
        if(m_pInstruction != NULL)
        {
            m_pInstruction->AddRef();
            m_pNamespace->GetTimerGenerator().Set(m_pInstruction);
        }
    }
}

DWORD CEventProviderCache::GetProvidedEventMask(IWbemClassObject* pClass)
{
    HRESULT hres;
    CInCritSec ics(&m_cs);

    VARIANT v;
    VariantInit(&v);
    hres = pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    CClearMe cm1(&v);


    DWORD dwProvidedMask = 0;

    // Search all the providers
    // ========================

    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];
        dwProvidedMask |= pRecord->GetProvidedEventMask(pClass, V_BSTR(&v));
    }
    return dwProvidedMask;
}
    
HRESULT CEventProviderCache::VirtuallyReleaseProviders()
{
    //
    // just need to record the fact that we are in resync.  This allows us to
    // handle reactivation of filters differently than when not in resync.  
    // For example, during resync we only process reactivations for provider 
    // records that had changed causing the resync in the first place.
    //

    CInCritSec ics(&m_cs);
    m_bInResync = TRUE;

    return WBEM_S_NO_ERROR;
}
    
HRESULT CEventProviderCache::CommitProviderUsage()
{
    CInCritSec ics(&m_cs);

    // Called after VirtuallyReleaseProviders and re-activating all filters
    // to actually deactivate all the providers whose usage count went to 0.
    // =====================================================================

    //
    // need to process all records and ensure that any having a perm usage 
    // count of 0 be removed from the registry.  Also make sure that we 
    // reset each records resync flag.
    // 
    for( int i=0; i < m_aRecords.GetSize(); i++ )
    {
        m_aRecords[i]->ResetNeedsResync();
        m_aRecords[i]->CheckPermanentUsage();
    }

    // At this point, there is nothing to be done.  When unload instruction 
    // executes, providers that are no longer needed will be unloaded. All we
    // need to do is allow the unload instruction to proceed.
    // ======================================================================

    m_bInResync = FALSE;
    EnsureUnloadInstruction();

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::UnloadUnusedProviders(CWbemInterval Interval)
{
    //
    // Extract the namespace pointer while locked to examine it for 
    // shutdownness
    //

    CEssNamespace* pNamespace = NULL;
    {
        CInCritSec ics(&m_cs);
        pNamespace = m_pNamespace;
        pNamespace->AddRef();
    }

    CTemplateReleaseMe<CEssNamespace> rm1(pNamespace);

    {
        CInUpdate iu(pNamespace);
        
        if(pNamespace->IsShutdown())
            return WBEM_S_FALSE;
        
        if(m_bInResync)
        {
            // Usage counters are not up-to-date --- wait for the next time
            // ============================================================
            
            return WBEM_S_FALSE;
        }
        
        BOOL bDeactivated = FALSE;
        BOOL bActiveLeft = FALSE;
        for(int i = 0; i < m_aRecords.GetSize(); i++)
        {
            CRecord* pRecord = m_aRecords[i];
            if(pRecord->IsActive() && 
               CWbemTime::GetCurrentTime() - pRecord->m_LastUse > Interval)
            {
                if(pRecord->DeactivateIfNotUsed())
                    bDeactivated = TRUE;
            }
            
            //
            // Check if we need to come back for this one
            //

            if(pRecord->IsUnloadable())
                bActiveLeft = TRUE;
        }
        
        if(bDeactivated)
            pNamespace->GetTimerGenerator().ScheduleFreeUnusedLibraries();
        
        if(!bActiveLeft && m_pInstruction)
        {
            m_pInstruction->Terminate();
            m_pInstruction->Release();
            m_pInstruction = NULL;
        }
    }

    pNamespace->FirePostponedOperations();

    return WBEM_S_NO_ERROR;
}

HRESULT CEventProviderCache::Shutdown()
{
    CInCritSec ics(&m_cs);

    if(m_pInstruction)
    {
        m_pInstruction->Terminate();
        m_pInstruction->Release();
        m_pInstruction = NULL;
    }
    m_aRecords.RemoveAll();

    m_pNamespace = NULL;
    return WBEM_S_NO_ERROR;
}

void CEventProviderCache::DumpStatistics(FILE* f, long lFlags)
{
    CInCritSec ics(&m_cs);

    long lLoaded = 0;
    long lQueries = 0;
    long lProxies = 0;
    long lFilters = 0;
    long lDestinations = 0;
    long lTargetLists = 0;
    long lTargets = 0;
    long lPostponed = 0;
    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CRecord* pRecord = m_aRecords[i];
        if(pRecord->m_pProvider)
            lLoaded++;
        
        lQueries += pRecord->m_apQueries.GetSize();

        long lThisProxies = 0;
        long lThisFilters = 0;
        long lThisTargetLists = 0;
        long lThisTargets = 0;
        long lThisPostponed = 0;
        long lThisDestinations = 0;
        pRecord->m_pMainSink->GetStatistics(&lThisProxies, &lThisDestinations,
                                &lThisFilters, &lThisTargetLists, 
                                &lThisTargets, &lThisPostponed);

        lProxies += lThisProxies;
        lDestinations += lThisDestinations;
        lFilters += lThisFilters;
        lTargetLists += lThisTargetLists;
        lTargets += lThisTargets;
        lPostponed += lThisPostponed;
    }

    fprintf(f, "%d provider records, %d definition queries, %d proxies\n"
        "%d destinations, %d proxy filters, %d proxy target lists\n"
        "%d proxy targets, %d postponed in proxies\n", 
        m_aRecords.GetSize(), lQueries, lProxies, lDestinations, lFilters, 
        lTargetLists, lTargets, lPostponed);
}

CPostponedNewQuery::CPostponedNewQuery(CEventProviderCache::CRecord* pRecord, 
                    DWORD dwId, LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                    CExecLine::CTurn* pTurn, CAbstractEventSink* pDest)
    : m_pRecord(pRecord), m_dwId(dwId), m_pTurn(pTurn), m_pcsQuery(NULL),
        m_pDest(pDest)
{
    m_pRecord->AddRef();
    m_pDest->AddRef();

    // Figure out how much space we need
    // =================================

    int nSpace = CCompressedString::ComputeNecessarySpace(wszQuery);

    // Allocate this string on the temporary heap
    // ==========================================

    m_pcsQuery = (CCompressedString*)CTemporaryHeap::Alloc(nSpace);
    if(m_pcsQuery == NULL)
        return;

    m_pcsQuery->SetFromUnicode(wszQuery);
}

CPostponedNewQuery::~CPostponedNewQuery()
{
    if(m_pTurn)
        m_pRecord->DiscardTurn(m_pTurn);
    if(m_pcsQuery)
        CTemporaryHeap::Free(m_pcsQuery, m_pcsQuery->GetLength());
    if(m_pDest)
        m_pDest->Release();

    m_pRecord->Release();
}
HRESULT CPostponedNewQuery::Execute(CEssNamespace* pNamespace)
{
    if(m_pcsQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    HRESULT hres = m_pRecord->Exec_NewQuery(pNamespace, m_pTurn, m_dwId, 
                                    L"WQL", m_pcsQuery->CreateWStringCopy(),
                                    m_pDest);
    m_pTurn = NULL;
    return hres;
}

void* CPostponedNewQuery::operator new(size_t nSize)
{
    return CTemporaryHeap::Alloc(nSize);
}
void CPostponedNewQuery::operator delete(void* p)
{
    CTemporaryHeap::Free(p, sizeof(CPostponedNewQuery));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tempbind.cpp ===
//******************************************************************************
//
//  TEMPBIND.CPP
//
//  Copyright (C) 2000 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include <tempbind.h>

CTempBinding::CTempBinding( long lFlags, 
                            WMIMSG_QOS_FLAG lQosFlags,
                            bool bSecure )
{
    m_dwQoS = lQosFlags;
    m_bSecure = bSecure;
    m_bSlowDown = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\provreg.h ===
//******************************************************************************
//
//  PROVREG.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __EVENTPROV_REG__H_
#define __EVENTPROV_REG__H_

#include <time.h>
#include <wbemidl.h>
#include <arrtempl.h>
#include <analyser.h>
#include <evaltree.h>
#include <sync.h>
#include <filtprox.h>
#include <unload.h>
#include <postpone.h>
#include <mtgtpckt.h>
#include <newobj.h>

class CEventProviderCache;
class CEventProviderWatchInstruction : public CBasicUnloadInstruction
{
protected:
    CEventProviderCache* m_pCache;
    static CWbemInterval mstatic_Interval;

public:
    CEventProviderWatchInstruction(CEventProviderCache* pCache);
    static void staticInitialize(IWbemServices* pRoot);
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
};

class CProviderSinkServer;
class CFilterStub : public IWbemFilterStub, public IWbemMultiTarget,
                public IWbemFetchSmartMultiTarget, public IWbemSmartMultiTarget,
                public IWbemEventProviderRequirements
{
protected:
    CProviderSinkServer* m_pSink;
    CWbemClassCache m_ClassCache;

public:
    CFilterStub(CProviderSinkServer* pSink) : m_pSink(pSink){}

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT STDMETHODCALLTYPE RegisterProxy(IWbemFilterProxy* pProxy);
    HRESULT STDMETHODCALLTYPE UnregisterProxy(IWbemFilterProxy* pProxy);

    HRESULT STDMETHODCALLTYPE DeliverEvent(DWORD dwNumEvents, 
                        IWbemClassObject** apEvents, 
                        WBEM_REM_TARGETS* aTargets,
                        long lSDLength, BYTE* pSD);
    HRESULT STDMETHODCALLTYPE DeliverStatus(long lFlags, HRESULT hresStatus,
                        LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                        WBEM_REM_TARGETS* aTargets,
                        long lSDLength, BYTE* pSD);

	HRESULT STDMETHODCALLTYPE GetSmartMultiTarget(
		IWbemSmartMultiTarget** ppSmartMultiTarget );

	HRESULT STDMETHODCALLTYPE DeliverEvent(DWORD dwNumEvents, DWORD dwBuffSize,
						BYTE* pBuffer,
                        WBEM_REM_TARGETS* aTargets,
                        long lSDLength, BYTE* pSD);

    HRESULT STDMETHODCALLTYPE DeliverProviderRequest(long lFlags);

};

class CEssMetaData;
class CProviderSinkServer : public IUnknown
{
public:
    struct CEventDestination
    {
        WBEM_REMOTE_TARGET_ID_TYPE m_id;
        CAbstractEventSink* m_pSink;

        CEventDestination(WBEM_REMOTE_TARGET_ID_TYPE Id, 
                            CAbstractEventSink* pSink);
        CEventDestination(const CEventDestination& Other);
        ~CEventDestination();
    };
    
    typedef CUniquePointerArray<CEventDestination> TDestinationArray;
protected:
    long m_lRef;

    CRefedPointerArray<IWbemFilterProxy> m_apProxies;
    TDestinationArray m_apDestinations;
    TDestinationArray m_apPreviousDestinations;
    WBEM_REMOTE_TARGET_ID_TYPE m_idNext;

    CWStringArray m_awsDefinitionQueries;

    IWbemLocalFilterProxy* m_pPseudoProxy;
    IWbemEventSink* m_pPseudoSink;

    CEssMetaData* m_pMetaData;
    CEssNamespace* m_pNamespace;
    IWbemEventProviderRequirements* m_pReqSink;

    CCritSec m_cs;
    long m_lLocks;

protected:
    CFilterStub m_Stub;
    CInstanceManager m_InstanceManager;

public:
    CProviderSinkServer();
    HRESULT Initialize(CEssNamespace* pNamespace, 
                        IWbemEventProviderRequirements* pReqSink);
    ~CProviderSinkServer();

    void Clear();
    HRESULT GetMainProxy(IWbemEventSink** ppSink);

    void GetStatistics(long* plProxies, long* plDestinations,
                    long* plFilters, long* plTargetLists, long* plTargets,
                    long* plPostponed);
    HRESULT GetDestinations(
                        TDestinationArray& apDestinations);
    INTERNAL CEssNamespace* GetNamespace() {return m_pNamespace;}

protected:
    HRESULT AddDestination(CAbstractEventSink* pDest, 
                        WBEM_REMOTE_TARGET_ID_TYPE* pID);
    BOOL GetProxies(CRefedPointerArray<IWbemFilterProxy>& apProxies);
   
    HRESULT FindDestinations(long lNum, 
                                IN WBEM_REMOTE_TARGET_ID_TYPE* aidTargets,
                                RELEASE_ME CAbstractEventSink** apSinks);

public:
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    HRESULT AddFilter(LPCWSTR wszQuery, QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        CAbstractEventSink* pDest, 
                        WBEM_REMOTE_TARGET_ID_TYPE* pidRequest = NULL);
    HRESULT RemoveFilter(CAbstractEventSink* pDest,
                        WBEM_REMOTE_TARGET_ID_TYPE* pidRequest = NULL);
    void RemoveAllFilters();
    HRESULT AddDefinitionQuery(LPCWSTR wszQuery);
    HRESULT AllowUtilizeGuarantee();
    void RemoveAllDefinitionQueries();

    HRESULT Lock();
    void Unlock();

public: // IWbemMultiTarget (forwarded)

    HRESULT STDMETHODCALLTYPE DeliverEvent(DWORD dwNumEvents, 
                        IWbemClassObject** apEvents, 
                        WBEM_REM_TARGETS* aTargets,
                        CEventContext* pContext);
    HRESULT DeliverOneEvent(IWbemClassObject* pEvent,
                                        WBEM_REM_TARGETS* pTargets,
                        CEventContext* pContext);

    HRESULT STDMETHODCALLTYPE DeliverStatus(long lFlags, HRESULT hresStatus,
                        LPCWSTR wszStatus, IWbemClassObject* pErrorObj,
                        WBEM_REM_TARGETS* aTargets,
                        CEventContext* pContext);
    HRESULT MultiTargetDeliver(IWbemEvent* pEvent, WBEM_REM_TARGETS* pTargets,
                        CEventContext* pContext);

public: // IWbemFilterStub (forwarded)

    HRESULT STDMETHODCALLTYPE RegisterProxy(IWbemFilterProxy* pProxy);
    HRESULT STDMETHODCALLTYPE UnregisterProxy(IWbemFilterProxy* pProxy);

public: // IWbemEventProviderRequirements (forwarded)

    HRESULT STDMETHODCALLTYPE DeliverProviderRequest(long lFlags);

};

class CEventProviderCache
{
    class CRequest
    {
    private:
        CAbstractEventSink* m_pDest;
        LPWSTR m_wszQuery;
        QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
        IWbemClassObject* m_pEventClass;
        DWORD m_dwEventMask;
        CClassInfoArray* m_papInstanceClasses;

    public:
        CRequest(IN CAbstractEventSink* pDest, LPWSTR wszQuery,
                    QL_LEVEL_1_RPN_EXPRESSION* pExp);
        ~CRequest();

        INTERNAL LPWSTR GetQuery() {return m_wszQuery;}
        INTERNAL CAbstractEventSink* GetDest() {return m_pDest;}

        INTERNAL QL_LEVEL_1_RPN_EXPRESSION* GetQueryExpr();
        DWORD GetEventMask();
        HRESULT GetInstanceClasses(CEssNamespace* pNamespace,
                                        INTERNAL CClassInfoArray** ppClasses);
        INTERNAL IWbemClassObject* GetEventClass(CEssNamespace* pNamespace);

        HRESULT CheckValidity(CEssNamespace* pNamespace);
    };


    class CRecord : IWbemEventProviderRequirements
    {
        class CQueryRecord
        {
            BSTR m_strQuery;
            IWbemClassObject* m_pEventClass;
            DWORD m_dwEventMask;
            CClassInfoArray* m_paInstanceClasses;
            QL_LEVEL_1_RPN_EXPRESSION* m_pExpr;
        
        public:
            CQueryRecord();
            HRESULT Initialize( COPY LPCWSTR wszQuery, 
                                LPCWSTR wszProvName,
                                CEssNamespace* pNamespace,
                                bool bSystem);
            ~CQueryRecord();
    
            HRESULT Update(LPCWSTR wszClassName, IWbemClassObject* pClass);
            HRESULT DoesIntersectWithQuery(CRequest& Request,
                                            CEssNamespace* pNamespace);
            DWORD GetProvidedEventMask(IWbemClassObject* pClass,
                                        BSTR strClassName);
            LPCWSTR GetQuery() {return m_strQuery;}

            HRESULT EnsureClasses( CEssNamespace* pNamespace );
            void ReleaseClasses();
        };

        friend class CEventProviderCache;
    public:
        long m_lRef;
        BSTR m_strNamespace;
        BSTR m_strName;
        BOOL m_bProviderSet;
        CUniquePointerArray<CQueryRecord> m_apQueries;
        long m_lUsageCount;
        long m_lPermUsageCount;
        BOOL m_bRecorded;
        BOOL m_bNeedsResync;
        CWbemTime m_LastUse;
        IWbemEventProvider* m_pProvider;
        IWbemEventProviderQuerySink* m_pQuerySink;
        IWbemEventProviderSecurity* m_pSecurity;
        CExecLine m_Line;
        bool m_bStarted;
        CEssNamespace* m_pNamespace;

        CProviderSinkServer* m_pMainSink;
    public:
        CRecord();
        HRESULT Initialize( LPCWSTR wszName, CEssNamespace* pNamespace );
        
        HRESULT SetProvider(IWbemClassObject* pWin32Prov);
        HRESULT SetProviderPointer(CEssNamespace* pNamespace, 
                                    IWbemEventProvider* pProvider);
        HRESULT ResetProvider();
        HRESULT SetQueries(CEssNamespace* pNamespace, 
                           IWbemClassObject* pRegistration);
        HRESULT SetQueries(CEssNamespace* pNamespace, long lNumQueries,
                                                 LPCWSTR* awszQueries);
        HRESULT ResetQueries();
        HRESULT Load(CEssNamespace* pNamespace);
        HRESULT DeactivateFilter(CAbstractEventSink* pDest);
        HRESULT CancelAllQueries();
        HRESULT STDMETHODCALLTYPE DeliverProviderRequest(long lFlags);

        static HRESULT GetProviderInfo(IWbemClassObject* pWin32Prov, 
                                       BSTR& strName);
        static HRESULT GetRegistrationInfo(IWbemClassObject* pRegistration, 
                                       BSTR& strName);
        HRESULT ActivateIfNeeded(IN CRequest& Request,
                    IN CEssNamespace* pNamespace);

        BOOL NeedsResync() { return m_bNeedsResync; }
        void ResetNeedsResync() { m_bNeedsResync = FALSE; }

        BOOL IsEmpty();  
        void ResetUsage();
        void CheckPermanentUsage();
        virtual bool DeactivateIfNotUsed();
        virtual bool IsUnloadable();
        HRESULT Update(LPCWSTR wszClassName, IWbemClassObject* pClass);
        DWORD GetProvidedEventMask(IWbemClassObject* pClass, BSTR strClassName);
        
        INTERNAL CProviderSinkServer* GetMainSink() {return m_pMainSink;}

        void Lock() {m_pMainSink->Lock();}
        void Unlock() {m_pMainSink->Unlock();}
        BOOL IsActive() {return (m_pProvider != NULL);}
        long GetUsageCount() {return m_lUsageCount;}

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHOD(QueryInterface)(REFIID riid, void** ppv) {return E_FAIL;}

        ~CRecord();
    protected:

        HRESULT Activate(CEssNamespace* pNamespace, CRequest* pRequest,
                                WBEM_REMOTE_TARGET_ID_TYPE idRequest);
        HRESULT Deactivate( CAbstractEventSink* pDest,
                            WBEM_REMOTE_TARGET_ID_TYPE idRequest);

        HRESULT AddActiveProviderEntryToRegistry();
        HRESULT RemoveActiveProviderEntryFromRegistry();

        HRESULT AddDefinitionQuery(CEssNamespace* pNamespace, LPCWSTR wszQuery);
        HRESULT Exec_LoadProvider(CEssNamespace* pNamespace);
        HRESULT Exec_StartProvider(CEssNamespace* pNamespace);
        HRESULT Exec_NewQuery(CEssNamespace* pNamespace, 
                    CExecLine::CTurn* pTurn, DWORD dwID, 
                    LPCWSTR wszLanguage, LPCWSTR wszQuery,
                    CAbstractEventSink* pDest);
        HRESULT ActualExecNewQuery(CEssNamespace* pNamespace, 
                    DWORD dwID, LPCWSTR wszLanguage, LPCWSTR wszQuery,
                    CAbstractEventSink* pDest);
        HRESULT Exec_CancelQuery(CEssNamespace* pNamespace, 
                    CExecLine::CTurn* pTurn, DWORD dwId);
        CExecLine::CTurn* GetInLine();
        void DiscardTurn(CExecLine::CTurn* pTurn);

        virtual HRESULT PostponeNewQuery(CExecLine::CTurn* pTurn, DWORD dwId, 
                                 LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                                 CAbstractEventSink* pDest);
        virtual HRESULT PostponeCancelQuery(CExecLine::CTurn* pTurn, 
                                 DWORD dwId);
        void UnloadProvider();

        virtual bool IsSystem() {return false;}

        friend class CPostponedNewQuery;
        friend class CPostponedCancelQuery;
        friend class CPostponedProvideEvents;

    protected:
    };

    class CSystemRecord : public CRecord
    {
    public:
        virtual bool DeactivateIfNotUsed();
        virtual bool IsUnloadable();
/*        HRESULT PostponeNewQuery(CExecLine::CTurn* pTurn, DWORD dwId, 
                                 LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                                 CAbstractEventSink* pDest);
        HRESULT PostponeCancelQuery(CExecLine::CTurn* pTurn, DWORD dwId); */
        virtual bool IsSystem() {return true;}
    };
        

    friend class CPostponedNewQuery;
    friend class CPostponedCancelQuery;
    friend class CEventProviderWatchInstruction;
    friend class CPostponedProvideEvents;

    CCritSec m_cs;
    CRefedPointerArray<CRecord> m_aRecords;
    CEssNamespace* m_pNamespace;
    CEventProviderWatchInstruction* m_pInstruction;
    BOOL m_bInResync;

protected:
    long FindRecord(LPCWSTR wszName);

public:
    CEventProviderCache(CEssNamespace* pNamespace);
    ~CEventProviderCache();
    HRESULT Shutdown();

    HRESULT AddProvider(IWbemClassObject* pWin32Prov);
    HRESULT AddSystemProvider(IWbemEventProvider* pProvider, LPCWSTR wszName,
                              long lNumQueries, LPCWSTR* awszQueries);
    HRESULT RemoveProvider(IWbemClassObject* pWin32Prov);
    HRESULT CheckProviderRegistration(IWbemClassObject* pRegistration);
    HRESULT AddProviderRegistration(IWbemClassObject* pRegistration);
    HRESULT RemoveProviderRegistration(IWbemClassObject* pRegistration);

    HRESULT LoadProvidersForQuery(LPWSTR wszQuery,
                                    QL_LEVEL_1_RPN_EXPRESSION* pExp, 
                                    CAbstractEventSink* pDest);

    HRESULT ReleaseProvidersForQuery(CAbstractEventSink* pDest);

    DWORD GetProvidedEventMask(IWbemClassObject* pClass);
    HRESULT VirtuallyReleaseProviders();
    HRESULT CommitProviderUsage();
    HRESULT UnloadUnusedProviders(CWbemInterval Interval);
    void EnsureUnloadInstruction();

    void DumpStatistics(FILE* f, long lFlags);
};

class CPostponedNewQuery : public CPostponedRequest
{
protected:
    CEventProviderCache::CRecord* m_pRecord;
    DWORD m_dwId;
    CCompressedString* m_pcsQuery;
    CExecLine::CTurn* m_pTurn;
    CAbstractEventSink* m_pDest;

public:
    CPostponedNewQuery(CEventProviderCache::CRecord* pRecord, DWORD dwId,
                        LPCWSTR wszQueryLanguage, LPCWSTR wszQuery,
                        CExecLine::CTurn* pTurn, CAbstractEventSink* pDest);
    ~CPostponedNewQuery();
    HRESULT Execute(CEssNamespace* pNamespace);
    BOOL DoesHoldTurn() { return TRUE; }

    void* operator new(size_t nSize);
    void operator delete(void* p);
};

class CPostponedCancelQuery : public CPostponedRequest
{
protected:
    DWORD m_dwId;
    CEventProviderCache::CRecord* m_pRecord;
    CExecLine::CTurn* m_pTurn;

public:
    CPostponedCancelQuery(CEventProviderCache::CRecord* pRecord, 
                            CExecLine::CTurn* pTurn, DWORD dwId)
        : m_pRecord(pRecord), m_dwId(dwId), m_pTurn(pTurn)
    {
        m_pRecord->AddRef();
    }
    ~CPostponedCancelQuery()
    {
        if(m_pTurn)
            m_pRecord->DiscardTurn(m_pTurn);
        m_pRecord->Release();
    }
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        HRESULT hres = m_pRecord->Exec_CancelQuery(pNamespace, m_pTurn, m_dwId);
        m_pTurn = NULL;
        return hres;
    }
    BOOL DoesHoldTurn() { return TRUE; }
};

class CPostponedProvideEvents : public CPostponedRequest
{
protected:
    DWORD m_dwId;
    CEventProviderCache::CRecord* m_pRecord;
    CExecLine::CTurn* m_pTurn;

public:
    CPostponedProvideEvents(CEventProviderCache::CRecord* pRecord)
        : m_pRecord(pRecord)
    {
        m_pRecord->AddRef();
    }
    ~CPostponedProvideEvents()
    {
        m_pRecord->Release();
    }
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        HRESULT hres = m_pRecord->Exec_StartProvider(pNamespace);
        return hres;
    }
    BOOL DoesHoldTurn() { return TRUE; }
};

class CPostponedSinkServerShutdown : public CPostponedRequest
{
protected:
    
    CWbemPtr<CProviderSinkServer> m_pSinkServer;
    
public:

    CPostponedSinkServerShutdown( CProviderSinkServer* pSinkServer ) 
    : m_pSinkServer( pSinkServer ) { }

    HRESULT Execute( CEssNamespace* pNamespace )
    {
        m_pSinkServer->Clear();
        return WBEM_S_NO_ERROR;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tempbind.h ===
//******************************************************************************
//
//  TEMPBIND.H
//
//  Copyright (C) 2000 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TEMP_BINDING__H_
#define __WMI_ESS_TEMP_BINDING__H_

#include "binding.h"
#include "fastall.h"

class CTempBinding : public CBinding
{
public:
    CTempBinding( long lFlags, WMIMSG_QOS_FLAG lQosFlags, bool bSecure );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\qsink.cpp ===
//******************************************************************************
//
//  QSINK.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <genutils.h>
#include <cominit.h>
#include "ess.h"
#include "evsink.h"
#include "delivrec.h"
   
/*****************************************************************************
  CQueueingEventSink
******************************************************************************/

class CSpinLock
{
protected:
    long m_lCount;
public:
    CSpinLock() : m_lCount(-1){}
    ~CSpinLock(){}

    void Enter();
    void Leave();
};

class CInSpinLock
{
protected:
    CSpinLock* m_p;
public:
    CInSpinLock(CSpinLock* p) : m_p(p) {m_p->Enter();}
    ~CInSpinLock() {m_p->Leave();}
};


void CSpinLock::Leave()
{
    InterlockedDecrement(&m_lCount);
}

#define IN_SPIN_LOCK CInCritSec

#define MAX_EVENT_DELIVERY_SIZE 10000000
#define SLOWDOWN_DROP_LIMIT 1000
#define DELIVER_SPIN_COUNT 1000

CQueueingEventSink::CQueueingEventSink(CEssNamespace* pNamespace) 
: m_pNamespace(pNamespace), m_bDelivering(FALSE), m_dwTotalSize(0),
  m_dwMaxSize(0xFFFFFFFF), m_wszName(NULL), m_bRecovering(FALSE), 
  m_hRecoveryComplete(NULL), m_hrRecovery(S_OK)
{
    m_pNamespace->AddRef();
    m_pNamespace->AddCache();
}

CQueueingEventSink::~CQueueingEventSink() 
{
    if ( m_hRecoveryComplete != NULL )
    {
        CloseHandle( m_hRecoveryComplete );
    }
    delete m_wszName;
    m_pNamespace->RemoveCache();
    m_pNamespace->Release();
}

HRESULT CQueueingEventSink::SetName( LPCWSTR wszName )
{
    if ( m_wszName != NULL )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    m_wszName = new WCHAR[wcslen(wszName)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy( m_wszName, wszName );

    return WBEM_S_NO_ERROR;
}
   

STDMETHODIMP CQueueingEventSink::SecureIndicate( long lNumEvents, 
                                                 IWbemEvent** apEvents,
                                                 BOOL bMaintainSecurity,
                                                 BOOL bSlowDown,
                                                 DWORD dwQoS,
                                                 CEventContext* pContext)
{
    // BUGBUG: context. levn: no security implications at this level --- we
    // are past the filter

    HRESULT hres;
    DWORD dwSleep = 0;

    // If security needs to be maintained, record the calling security 
    // context
    // ===============================================================

    IWbemCallSecurity* pSecurity = NULL;

    if(bMaintainSecurity && IsNT())
    {
        pSecurity = CWbemCallSecurity::CreateInst();
        if (pSecurity == 0)
            return WBEM_E_OUT_OF_MEMORY;
        
        hres = pSecurity->CloneThreadContext(FALSE);
        if(FAILED(hres))
        {
            pSecurity->Release();
            return hres;
        }
    }

    CReleaseMe rmpSecurity( pSecurity );

    HRESULT hr;

    BOOL bSchedule = FALSE;

    for(int i = 0; i < lNumEvents; i++)
    {
        CWbemPtr<CDeliveryRecord> pRecord;
        
        //
        // TODO: Fix this so that we put multiple events in the record. 
        // 

        hr = GetDeliveryRecord( 1, 
                                &apEvents[i], 
                                dwQoS, 
                                pContext, 
                                pSecurity, 
                                &pRecord );

        if ( FAILED(hr) )
        {
            ERRORTRACE((LOG_ESS, "Couldn't create delivery record for %S "
                                 " sink. HR = 0x%x\n", m_wszName, hr ));
            ReportQosFailure( apEvents[i], hr );
            continue;
        }

        DWORD dwThisSleep;
        BOOL bFirst;
        
        if( !AddRecord( pRecord, bSlowDown, &dwThisSleep, &bFirst) )
        {
            //
            // make sure that we give the record a chance to perform any post 
            // deliver actions before getting rid of it.
            //
            pRecord->PostDeliverAction( NULL, S_OK );

            return WBEM_E_OUT_OF_MEMORY;
        }

        dwSleep += dwThisSleep;
        if(bFirst)
        bSchedule = TRUE;
    }

    if(bSchedule)
    {
        // DeliverAll();
        // TRACE((LOG_ESS, "Scheduling delivery!!\n"));
        hres = m_pNamespace->ScheduleDelivery(this);
    }
    else
    {
        // TRACE((LOG_ESS, "NOT Scheduling delivery!!\n"));
        hres = WBEM_S_FALSE;
    }

    if(dwSleep && bSlowDown)
    m_pNamespace->AddSleepCharge(dwSleep);

    return  hres;
}

BOOL CQueueingEventSink::AddRecord( CDeliveryRecord* pRecord, 
                                    BOOL bSlowDown,
                                    DWORD* pdwSleep, 
                                    BOOL* pbFirst )
{
    // Inform the system of the additional space in the queue
    // ======================================================

    DWORD dwRecordSize = pRecord->GetTotalBytes();

    pRecord->AddToCache( m_pNamespace, m_dwTotalSize, pdwSleep );

    BOOL bDrop = FALSE;

    // Check if the sleep is such as to cause us to drop the event
    // ===========================================================

    if(!bSlowDown && *pdwSleep > SLOWDOWN_DROP_LIMIT)
    {
        bDrop = TRUE;
    }
    else
    {
        // Check if our queue size is so large as to cause us to drop
        // ==============================================================

        if(m_dwTotalSize + dwRecordSize > m_dwMaxSize)
        bDrop = TRUE;
    }

    if( bDrop )
    {
        //
        // Report that we're dropping the events.  Call for each event.
        // 

        IWbemClassObject** apEvents = pRecord->GetEvents();

        for( ULONG i=0; i < pRecord->GetNumEvents(); i++ )
        {
            ReportQueueOverflow( apEvents[i], m_dwTotalSize + dwRecordSize );
        }

        *pdwSleep = 0;
        *pbFirst = FALSE;
    }
    else
    {
        IN_SPIN_LOCK isl(&m_sl);

        *pbFirst = (m_qpEvents.GetQueueSize() == 0) && !m_bDelivering;
        m_dwTotalSize += dwRecordSize;
        
        if(!m_qpEvents.Enqueue(pRecord))
        {
            *pdwSleep = 0;
            return FALSE;
        }
        pRecord->AddRef();
    }

    return TRUE;
}

HRESULT CQueueingEventSink::DeliverAll()
{
    HRESULT hr = WBEM_S_NO_ERROR;
    BOOL    bSomeLeft = TRUE;

    while( bSomeLeft )
    {
        try
        {
            {
                IN_SPIN_LOCK ics(&m_sl);
                m_bDelivering = TRUE;
            }

            hr = DeliverSome( );
        }
        catch( CX_MemoryException )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
        catch ( ... )
        {
            hr = WBEM_E_FAILED;
        }

        {
            IN_SPIN_LOCK ics(&m_sl);
            m_bDelivering = FALSE;

            if ( SUCCEEDED( hr ) )
            {
                bSomeLeft = (m_qpEvents.GetQueueSize() != 0);
            }
            else
            {
                m_qpEvents.Clear();
                bSomeLeft = FALSE;
            }
        }
    }

    return hr;
}

void CQueueingEventSink::ClearAll()
{
    IN_SPIN_LOCK isl(&m_sl);
    m_qpEvents.Clear();
}

#pragma optimize("", off)
void CQueueingEventSink::WaitABit()
{
    SwitchToThread();
/*
    int nCount = 0;
    while(m_qpEvents.GetQueueSize() == 0 && nCount++ < DELIVER_SPIN_COUNT);
*/
}
#pragma optimize("", on)


HRESULT CQueueingEventSink::DeliverSome( )
{
    // Retrieve records until maximum size is reached and while the same
    // security context is used for all
    // ==================================================================

    CTempArray<CDeliveryRecord*> apRecords;

    m_sl.Enter(); // CANNOT USE SCOPE BECAUSE CTempArray uses _alloca
    DWORD dwMaxRecords = m_qpEvents.GetQueueSize();
    m_sl.Leave();

    if(!INIT_TEMP_ARRAY(apRecords, dwMaxRecords))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CDeliveryRecord* pEventRec;
    DWORD dwDeliverySize = 0;
    DWORD dwTotalEvents = 0; 
    int cRecords = 0;
    LUID luidBatch;
    IWbemCallSecurity* pBatchSecurity = NULL;

    m_sl.Enter();

    while( dwDeliverySize < GetMaxDeliverySize() && 
           cRecords < dwMaxRecords &&
           (pEventRec = m_qpEvents.Dequeue()) != NULL ) 
    {
        // Compare it to the last context
        // ==============================

        m_sl.Leave();
        if( dwDeliverySize > 0 )
        {
            if(!DoesRecordFitBatch(pEventRec, pBatchSecurity, luidBatch))
            {
                // Put it back and that's it for the batch
                // =======================================

                IN_SPIN_LOCK ics(&m_sl);
                m_qpEvents.Requeue(pEventRec);

                break;
            }
        }
        else
        {
            // First --- record luid
            // =====================

            pBatchSecurity = pEventRec->GetCallSecurity();

            if( pBatchSecurity )
            {
                pBatchSecurity->AddRef();
                pBatchSecurity->GetAuthenticationId( luidBatch );
            }
        }

        apRecords[cRecords++] = pEventRec;
        dwTotalEvents += pEventRec->GetNumEvents();
        
        // Matched batch parameters --- add it to the batch
        // ================================================

        DWORD dwRecordSize = pEventRec->GetTotalBytes();

        m_dwTotalSize -= dwRecordSize;
        dwDeliverySize += dwRecordSize;

        //
        // Remove this size from the total of events held
        //

        m_sl.Enter();
    }

    m_sl.Leave();

    //
    // we've now got one or more delivery records to handle. 
    //

    //
    // we now need to initialize the event array that we're going to indicate
    // to the client.
    //

    CTempArray<IWbemClassObject*> apEvents;

    if( !INIT_TEMP_ARRAY( apEvents, dwTotalEvents ))
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // go through the delivery records and add their events to the 
    // events to deliver.  Also perform any PreDeliverAction on the   
    // record.
    //

    CWbemPtr<ITransaction> pTxn;
    HRESULT hr;
    int cEvents = 0;
    int i;

    for(i=0; i < cRecords; i++ )
    {
        //if ( apRecords[i]->RequiresTransaction() && pTxn == NULL )
        //{
            // TODO : XACT - aquire txn from DTC.
        //}

        hr = apRecords[i]->PreDeliverAction( pTxn );

        if ( FAILED(hr) )
        {
            // 
            // TODO : handle error reporting here.
            // 
            continue;
        }

        IWbemEvent** apRecordEvents = apRecords[i]->GetEvents();
        DWORD cRecordEvents = apRecords[i]->GetNumEvents();

        for( DWORD j=0; j < cRecordEvents; j++ )
        {
            apEvents[cEvents++] = apRecordEvents[j];
        }
    }
    
    // Actually Deliver
    // =======

    HRESULT hres = WBEM_S_NO_ERROR;

    if( dwDeliverySize > 0 )
    {
        //
        // Error returns are already logged in ActuallyDeliver
        // we do not need to return return value of DeliverEvents 
        //
        hres = DeliverEvents( pBatchSecurity, cEvents, apEvents );
    }

    //
    // call postdeliveryaction on all the records.  Then clean them up.
    // 

    for(i=0; i < cRecords; i++ )
    {
        apRecords[i]->PostDeliverAction( pTxn, hres );
        apRecords[i]->Release();
    }

    // Release all of the events.
    // ================

    if( pBatchSecurity )
    {
        pBatchSecurity->Release();
    }

    // Check if we need to continue
    // ============================

    WaitABit();

    return WBEM_S_NO_ERROR;
}

HRESULT CQueueingEventSink::DeliverEvents(IWbemCallSecurity* pBatchSecurity, 
                                          long lNumEvents, IWbemEvent** apEvents)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    IUnknown* pOldSec = NULL;
    if(pBatchSecurity)
    {
        hres = WbemCoSwitchCallContext(pBatchSecurity, &pOldSec);
        if(FAILED(hres))
        {
            // Unable to set security --- cannot deliver
            // =========================================
        }
    }

    if(SUCCEEDED(hres))
    {
        // BUGBUG: propagate context.  levn: no security implications at this
        // point --- we are past the filter
        hres = ActuallyDeliver(lNumEvents, apEvents, (pBatchSecurity != NULL), 
                               NULL);
    }

    if(pBatchSecurity)
    {
        IUnknown* pTemp;
        WbemCoSwitchCallContext(pOldSec, &pTemp);
    }

    return hres;
}

BOOL CQueueingEventSink::DoesRecordFitBatch( CDeliveryRecord* pEventRec, 
                                             IWbemCallSecurity* pBatchSecurity,
                                             LUID luidBatch )
{
    IWbemCallSecurity* pEventSec = pEventRec->GetCallSecurity();

    if( pEventSec != NULL || pBatchSecurity != NULL )
    {
        if( pEventSec == NULL || pBatchSecurity == NULL )
        {
            // Definite mistatch --- one NULL, one not
            // =======================================

            return FALSE;
        }
        else
        {
            LUID luidThis;
            pEventSec->GetAuthenticationId(luidThis);

            if( luidThis.LowPart != luidBatch.LowPart ||
                luidThis.HighPart != luidBatch.HighPart )
            {
                return FALSE;
            }
            else
            {
                return TRUE;
            }
        }
    }
    else
    {
        return TRUE;
    }
}

DWORD CQueueingEventSink::GetMaxDeliverySize()
{
    return MAX_EVENT_DELIVERY_SIZE;
}

#ifdef __WHISTLER_UNCUT
//
// used to capture callbacks from MsgReceiver. The Msg Receiver interfaces 
// use callbacks to avoid unnecessary copying.
//
struct MsgReceive 
: public CUnkBase<IWmiMessageSendReceive, &IID_IWmiMessageSendReceive>
{
    BYTE* m_pData;
    ULONG m_cData;
    BYTE* m_pAuxData;
    ULONG m_cAuxData;

    STDMETHOD(SendReceive)( BYTE* pData,
                            ULONG cData,
                            BYTE* pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pUnk )
    {
        m_pData = pData;
        m_cData = cData;
        m_pAuxData = pAuxData;
        m_cAuxData = cAuxData;
        return S_OK;
    }
};

HRESULT CQueueingEventSink::OpenReceiver( LPCWSTR wszQueueName,
                                          DWORD dwQos,
                                          IWmiMessageSendReceive* pRecv,
                                          IWmiMessageQueueReceiver** ppRcvr )
{
    HRESULT hr;

    *ppRcvr = NULL;

    CWbemPtr<IWmiMessageQueue> pQueue;

    hr = CoCreateInstance( CLSID_WmiMessageQueue,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageQueue,
                           (void**)&pQueue );
    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWmiMessageQueueReceiver> pRcvr;

    hr = pQueue->Open( wszQueueName, dwQos, pRecv, &pRcvr );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    pRcvr->AddRef();

    *ppRcvr = pRcvr;
    
    return WBEM_S_NO_ERROR;
}

HRESULT CQueueingEventSink::OpenSender( LPCWSTR wszQueueName,
                                        DWORD dwQos, 
                                        IWmiMessageSendReceive** ppSend )
{
    HRESULT hr;

    *ppSend = NULL;

    //
    // make sure that the queue has been created.
    // 

    hr = m_pNamespace->GetEss()->CreatePersistentQueue( wszQueueName, dwQos );

    if ( FAILED(hr) )
    {
        if ( hr != WBEM_E_ALREADY_EXISTS )
        {
            return hr;
        }
    }

    //
    // now open a sender on the queue.
    //

    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( CLSID_WmiMessageMsmqSender,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageSender,
                           (void**)&pSender );
    if ( FAILED(hr) )
    {
        return hr;
    }
        
    hr = pSender->Open( wszQueueName, dwQos, NULL, NULL, NULL, ppSend );
    
    return hr;
}

HRESULT CQueueingEventSink::GetPersistentRecord( ULONG cEvents,
                                                 IWbemEvent** apEvents,
                                                 DWORD dwQos,
                                                 CEventContext* pContext,
                                                 CDeliveryRecord** ppRecord )
{
    HRESULT hr;
      
    CInCritSec ics( &m_csQueue );

    //
    // the idea here is that the act of saving/removing messages and 
    // performing recovery can never take place at the same time.  This 
    // is we because we must ensure that the message removed from the   
    // front of the persistent queues corresponds with the guaranteed 
    // delivery pulled off of the transient queue.
    //
   
    while ( m_bRecovering )
    {
        DEBUGTRACE((LOG_ESS, "%S queue sink waiting for recovery.\n", m_wszName ));

        assert( m_hRecoveryComplete != NULL );
	LeaveCriticalSection( &m_csQueue );
	WaitForSingleObject( m_hRecoveryComplete, INFINITE );
	EnterCriticalSection( &m_csQueue );

        DEBUGTRACE((LOG_ESS, "%S queue sink waited for recovery.\n", m_wszName ));
    }

    //
    // check to see if we're in a bad state.  If so, return the error 
    // that got us there.
    //
    if ( FAILED(m_hrRecovery) )
    {
        return m_hrRecovery;
    }

    //
    // first ensure that the objects associated with the QoS are initialized. 
    // once this happens, we'll save the record in the appropriate queue.
    // there's a bit of indirect referencing here to address the case when
    // we have multiple types of senders and receivers ( right now only one ).
    //

    IWmiMessageSendReceive** ppSend;
    IWmiMessageQueueReceiver** ppRcvr;

    //
    // TODO:XACT later use persistent base class
    //
    CWbemPtr<CGuaranteedDeliveryRecord> pRecord; 

    if ( dwQos == WMIMSG_FLAG_QOS_GUARANTEED )
    { 
        pRecord = new CGuaranteedDeliveryRecord;
        ppSend = &m_pSend;
        ppRcvr = &m_pRcvr;
    }
    else
    {
        //
        // TODO : XACT delivery.
        //
        return WBEM_E_CRITICAL_ERROR;
    }

    if ( pRecord == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    WString wsQueueName;

    if ( *ppSend == NULL || *ppRcvr == NULL )
    {
        //
        // construct the queue name from our sinkname, namespace, and qos.
        //
     
        hr = SinkNameToQueueName( m_wszName, 
                                  m_pNamespace->GetName(), 
                                  dwQos, 
                                  wsQueueName );    
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    
    if ( *ppSend == NULL )
    {
        hr = OpenSender( wsQueueName, dwQos, ppSend );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( *ppRcvr == NULL )
    {
        //
        // we don't need to pass a callback for receiving messages,
        // because all we're ever going to do with this receiver is 
        // remove messages.
        //

        hr = OpenReceiver( wsQueueName, dwQos, NULL, ppRcvr );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    hr = pRecord->Initialize( apEvents, cEvents );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // set the receiver on the record so that later it can come back and 
    // remove the message from the queue.
    //

    pRecord->SetCB( this, *ppRcvr );

    hr = SaveDeliveryRecord( *ppSend, pRecord );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pRecord->AddRef();
    *ppRecord = pRecord;
 
    return WBEM_S_NO_ERROR;
}

HRESULT CQueueingEventSink::SaveDeliveryRecord( IWmiMessageSendReceive* pSend,
					        CDeliveryRecord* pRecord )
{
    HRESULT hr;

    //
    // reset the message buffer.
    //

    m_MsgData.Reset();

    //
    // first set the message data.
    //

    hr = pRecord->Persist( &m_MsgData );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // TODO: Later we need to store some random bytes with the header so
    // that it can act as a signature.  Since no one can read the messages
    // but us, the data of the message does not have to be hashed.  We just
    // want to know if the sender has the private key.
    // Since the header will be the same for all messages, we can probably
    // set it up somewhere once.
    //

    return pSend->SendReceive( m_MsgData.GetRawData(), 
                               m_MsgData.GetIndex(), 
                               NULL, 
                               0, 
                               0,
                               NULL );
}

#endif

HRESULT CQueueingEventSink::GetDeliveryRecord( ULONG cEvents,
                                               IWbemEvent** apEvents,
                                               DWORD dwQos,
                                               CEventContext* pContext,
                                               IWbemCallSecurity* pCallSec,
                                               CDeliveryRecord** ppRecord )
{
    HRESULT hr;

    *ppRecord = NULL;

    CWbemPtr<CDeliveryRecord> pRecord;

    if ( dwQos == WMIMSG_FLAG_QOS_EXPRESS )
    {
        pRecord = new CExpressDeliveryRecord;

        if ( pRecord == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = pRecord->Initialize( apEvents, cEvents, pCallSec );
    }
#ifdef __WHISTLER_UNCUT
    else
    {
        //
        // this is a guaranteed type of QoS, we will need to save the 
	// record before returning it.
        //

        if ( pCallSec != NULL )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

        hr = GetPersistentRecord( cEvents, 
                                  apEvents,
                                  dwQos,
                                  pContext, 
                                  &pRecord );
        
        if ( FAILED(hr) && HandlePersistentQueueError(hr, dwQos ) === S_OK )
        {
            //
            // we should retry once more
            //

            hr = GetPersistentRecord( cEvents, 
                                      apEvents,
                                      dwQos,
                                      pContext, 
                                      &pRecord );   
        }
    }
#endif 
      
    if ( FAILED(hr) )
    {
        return hr;
    }

    pRecord->AddRef();
    *ppRecord = pRecord;

    return WBEM_S_NO_ERROR;
}

#ifdef __WHISTLER_UNCUT

HRESULT CQueueingEventSink::GuaranteedPostDeliverAction( 
                                        IWmiMessageQueueReceiver* pRcvr )
{
    //
    // we pass along the receiver that existed at the time the delivery 
    // was saved because Recovery may have occurred and completed
    // between the time the delivery was saved and now. If this was the 
    // case, we would have released that receiver connection.  To see 
    // if this case has occurred we just compare the receiver pointers.
    //

    HRESULT hr;

    CInCritSec ics( &m_cs );

    //
    // XACT note: when a message is read using a transaction we cannot 
    // allow recovery to occur until that transaction is completed.  
    // this is because recovery uses a cursor on the queue and if a txn 
    // is aborted, it goes back into the queue and screws up the cursor.
    // what we'll do is hold the lock when there are outstanding txns.
    //

    if ( m_bRecovering || FAILED(m_hrRecovery) || m_pRcvr != pRcvr )
    {
        DEBUGTRACE((LOG_ESS, "ignoring removal of persistent delivery "
              "due to recovery of %S sink\n", m_wszName));
        return S_OK; // recovery will handle removing this message.
    }

    hr =  pRcvr->ReceiveMessage( INFINITE, 
                                 NULL, 
                                 WMIMSG_ACTION_QRCV_REMOVE, 
                                 NULL );
    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS, "Couldn't remove persistent delivery for %S "
                   " sink. HR = 0x%x\n", m_wszName, hr ));
        HandlePersistentQueueError( hr, WMIMSG_FLAG_QOS_GUARANTEED );
    }

    return hr;
}

HRESULT CQueueingEventSink::HandlePersistentQueueError( HRESULT hr, 
                                                        DWORD dwQos )
{
    //
    // returns S_OK if caller should retry the request that caused the error.
    //

    DEBUGTRACE((LOG_ESS, "Received error from persistent queue for %S sink "
                    "HR = 0x%x\n", m_wszName, hr));

    if ( hr != WMIMSG_E_REQSVCNOTAVAIL )
    {
	return S_FALSE;
    }

    //
    // the msmq service is down.  Restart it and initiate recovery.
    //

    WString wsQueueName;
	
    hr = SinkNameToQueueName( m_wszName, 
			      m_pNamespace->GetName(), 
			      dwQos,
			      wsQueueName );
    if ( FAILED(hr) )
    {
	return hr;
    }

    //
    // reset msmq connections.
    //

    if ( dwQos == WMIMSG_FLAG_QOS_GUARANTEED )
    {
        m_pSend.Release();
        m_pRcvr.Release();
    }
    else
    {
        m_pXactSend.Release();
        m_pXactRcvr.Release();
    }

    Recover( wsQueueName, dwQos );

    return S_OK; // if recovery failed we'll pick it up later.
}

HRESULT CQueueingEventSink::Recover( LPCWSTR wszQueueName, DWORD dwQoS )
{
    HRESULT hr;

    DEBUGTRACE((LOG_ESS, "Recovering Queue %S\n", wszQueueName ));

    {
        CInCritSec ics( &m_cs );

        m_hRecoveryComplete = CreateEvent( NULL, TRUE, FALSE, NULL );
            
        if ( m_hRecoveryComplete == NULL )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        ResetEvent( m_hRecoveryComplete );
        m_bRecovering = TRUE;
    }

    hr = InternalRecover( wszQueueName, dwQoS );

    {
        CInCritSec ics( &m_cs );
        SetEvent( m_hRecoveryComplete );
        CloseHandle( m_hRecoveryComplete );
        m_bRecovering = FALSE;
        m_hrRecovery = hr;
    }

    if ( FAILED(hr) )
    {
        ERRORTRACE(( LOG_ESS, "Failed Recovering %S queue. HR=0x%x\n", 
                    wszQueueName, hr ));
        return hr;
    }

    DEBUGTRACE((LOG_ESS, "Recovered Queue %S\n", wszQueueName ));

    return hr;
}

HRESULT CQueueingEventSink::InternalRecover(LPCWSTR wszQueueName, DWORD dwQoS)
{
    HRESULT hr;
    
    CWbemPtr<MsgReceive> pRecv = new MsgReceive;

    //
    // here we open a new receiver.  We don't want to keep this receiver 
    // open afterwards though because recovery would open all the persistent
    // queues - which could be a lot of handles.  We'll close this receiver 
    // after we're done and wait until someone actually indicates a persistent
    // message before initializing the receiver that we'll hold on to.
    //

    CWbemPtr<IWmiMessageQueueReceiver> pRcvr;

    hr = OpenReceiver( wszQueueName, dwQoS, pRecv, &pRcvr );  

    if ( FAILED(hr) )
    {
        return hr;
    }

    PVOID pvCursor;

    hr = pRcvr->CreateCursor( &pvCursor );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BOOL bSchedule = FALSE;

    hr = pRcvr->ReceiveMessage( 0, 
                                pvCursor, 
                                WMIMSG_ACTION_QRCV_PEEK_CURRENT,
                                NULL );
    
    while( SUCCEEDED(hr) )
    {
        CBuffer Data( pRecv->m_pData, pRecv->m_cData, FALSE ); 

        CWbemPtr<CGuaranteedDeliveryRecord> pRecord;

        pRecord = new CGuaranteedDeliveryRecord;  // TODO : XACT

        if ( pRecord == NULL )
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }

        pRecord->SetCB( this, pRcvr );

        hr = pRecord->Unpersist( &Data );

        if ( FAILED(hr) )
        {
            ERRORTRACE(( LOG_ESS, "Invalid Delivery Message in %S queue\n",
                         m_wszName));
            hr = WBEM_S_NO_ERROR;
            continue;
        }

        //
        // add the record to the transient queue. 
        //

        DWORD dwThisSleep;
        BOOL bFirst;

        if( !AddRecord( pRecord, FALSE, &dwThisSleep, &bFirst) )
        {
            //
            // We can't add the record because of out of memory. 
            // we're going to have to bail on our recovery.
            //
            return WBEM_E_OUT_OF_MEMORY;
            break;
        }

        bSchedule = TRUE; // at least one was added successfully .

        hr = pRcvr->ReceiveMessage( 0, 
                                    pvCursor, 
                                    WMIMSG_ACTION_QRCV_PEEK_NEXT,
                                    NULL );
    }

    if ( SUCCEEDED(hr) && bSchedule )
    {
        m_pNamespace->ScheduleDelivery( this );
    }

    pRcvr->DestroyCursor( pvCursor );

    if ( hr != WMIMSG_E_TIMEDOUT )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueueingEventSink::CleanupPersistentQueues()
{
    HRESULT hr;

    if ( m_wszName == NULL )
    {
        return WBEM_S_NO_ERROR; // not a permanent event consumer. Temporary.
    }

    DWORD dwQoS = WMIMSG_FLAG_QOS_GUARANTEED; // TODO : XACT

    WString wsQueueName;

    hr = SinkNameToQueueName( m_wszName,
                              m_pNamespace->GetName(),
                              dwQoS,
                              wsQueueName );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pNamespace->GetEss()->DestroyPersistentQueue( wsQueueName );
}

const LPCWSTR g_wszGuaranteed = L"Guaranteed";

//
// queue name must be a valid msmq pathname to a private queue where the 
// logical name is of the formate sinkname!namespace!qos
//

HRESULT CQueueingEventSink::QueueNameToSinkName( LPCWSTR wszQueueName,
                                                 WString& rwsSinkName,
                                                 WString& rwsNamespace,
                                                 DWORD& rdwQoS )
{
    wszQueueName = wcschr( wszQueueName, '\\');

    if ( wszQueueName == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    wszQueueName++; // advance past delimiter.

    //
    // pathname is always private so advance one more slash.
    //
    wszQueueName = wcschr( wszQueueName, '\\');

    if ( wszQueueName == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    wszQueueName++; // advance past delimiter.

    WCHAR* pwchNamespace = wcschr( wszQueueName, '!' );

    if ( pwchNamespace == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    pwchNamespace++;
        
    WCHAR* pwchQoS = wcschr( pwchNamespace, '!' );

    if ( pwchQoS == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    pwchQoS++;

    rwsNamespace = pwchNamespace;
    rwsSinkName = wszQueueName;

    LPWSTR wszSinkName = rwsSinkName;
    LPWSTR wszNamespace = rwsNamespace;

    wszSinkName[pwchNamespace-wszQueueName-1] = '\0';
    wszNamespace[pwchQoS-pwchNamespace-1] = '\0';

    //
    // substitute the slashes back into the namespace.
    //

    WCHAR* pwch = wszNamespace;

    while( (pwch=wcschr(pwch,'~')) != NULL )
    {
        *pwch++ = '\\';
    }
    

    rdwQoS = WMIMSG_FLAG_QOS_GUARANTEED; // TODO : XACT check

    return WBEM_S_NO_ERROR;
}


HRESULT CQueueingEventSink::SinkNameToQueueName( LPCWSTR wszSinkName,
                                                 LPCWSTR wszNamespace,
                                                 DWORD dwQoS,
                                                 WString& rwsQueueName )
{
    LPCWSTR wszQos;

    if ( dwQoS != WMIMSG_FLAG_QOS_GUARANTEED ) // TODO : XACT
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // the logical part of the pathname cannot contain any slashes, so 
    // when saving the namespace, we must remove them and replace them with
    // something else.
    //

    WString wsNormNamespace = wszNamespace;

    WCHAR* pwch = wsNormNamespace;

    while( (pwch=wcschr(pwch,'\\')) != NULL )
    {
        *pwch++ = '~';
    }

    wszQos = g_wszGuaranteed; // TODO : XACT

    rwsQueueName = L".\\private$\\";
    rwsQueueName += wszSinkName;
    rwsQueueName += L"!";
    rwsQueueName += wsNormNamespace;
    rwsQueueName += L"!";
    rwsQueueName += wszQos;

    return WBEM_S_NO_ERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\qsink.h ===
//******************************************************************************
//
//  QSINK.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __QSINK_H__
#define __QSINK_H__

#include <sync.h>
#include <unk.h>
#include <winntsec.h>
#include <callsec.h>
#include <newnew.h>
#include <buffer.h>
#include <comutl.h>
#include <wmimsg.h>
#include <map>

#include "eventrep.h"
#include "evsink.h"
#include "delivrec.h"

/***************************************************************************
  CQueueingEventSink
****************************************************************************/

class CQueueingEventSink : public CEventSink
{
protected:

    CUniquePointerQueue<CDeliveryRecord> m_qpEvents;
    CCritSec m_cs;
    CCritSec m_sl;
    BOOL m_bDelivering;
    DWORD m_dwTotalSize;
    DWORD m_dwMaxSize;
    CEssNamespace* m_pNamespace;

    //
    // the logical name of this queueing sink.  Queueing sinks can be
    // as fined grained ( e.g one per logical consumer instance ) or 
    // they can be more coarse grained (e.g one per consumer provider)
    // 
    LPWSTR m_wszName;

    //
    // aquired when performing and testing persistent queue initialization.
    //
    CCritSec m_csQueue;

    //
    // if recovery fails, then it stores its failure here.  When new 
    // deliveries come in we use this to tell us if we should reinitiate
    // recovery. 
    //
    HRESULT m_hrRecovery;

    //
    // Used to synchronize with recovery.  
    //
    HANDLE m_hRecoveryComplete;
    BOOL m_bRecovering;
    
    //
    // These buffers are used to marshal guaranteed deliveries.  This
    // happens in SaveDeliveryRecord().  All calls to SaveDeliveryRecord()
    // are serialized, so we can keep re-using the buffers.
    //
    CBuffer m_MsgData;
    CBuffer m_MsgAuxData;

    //
    // Is used for removing messages after delivery. 
    //
    CWbemPtr<IWmiMessageQueueReceiver> m_pRcvr;
    CWbemPtr<IWmiMessageQueueReceiver> m_pXactRcvr; // TODO : XACT

    //
    // Is used for saving deliveries before they are put into the 
    // transient queue.
    //
    CWbemPtr<IWmiMessageSendReceive> m_pSend;
    CWbemPtr<IWmiMessageSendReceive> m_pXactSend; // TODO : XACT
    
    //
    // saves the record in the specified queue.  called before the 
    // delivery record is put on the transient queue.  after a 
    // guaranteed type record is actually delivered to the 
    // consumer, then it will be removed from the queue.  This happens
    // in delivery record's PostDeliveryAction. 
    //
    HRESULT SaveDeliveryRecord( IWmiMessageSendReceive* pSend,
                                CDeliveryRecord* pRecord );

    //
    // Handles the creation of the appropriate persistent record type
    // based on QoS ( right now just guaranteed ).  Saves records before 
    // returning.
    //
    HRESULT GetPersistentRecord( ULONG cEvents,
                                 IWbemEvent** apEvents,
                                 DWORD dwQoS,
                                 CEventContext* pContext,
                                 CDeliveryRecord** ppRecord );
    // 
    // Handles creation of the appropriate record type based on the 
    // QoS specified.  If the QoS is a guaranteed type, then
    // it will call GetPersistentRecord().
    //
    HRESULT GetDeliveryRecord( ULONG cEvents,
                               IWbemEvent** apEvents,
                               DWORD dwQoS,
                               CEventContext* pContext,
                               IWbemCallSecurity* pCallSec,
                               CDeliveryRecord** ppRecord );

    // 
    // Called if GetPersistentRecord() returns an error.  If the problem
    // can be corrected ( e.g. msmq service can be restarted ), then 
    // recovery will be initiated.  a return code of S_OK indicates to 
    // the caller that they should retry their GetPersistentRecord() request.
    // 
    HRESULT HandlePersistentQueueError( HRESULT hr, DWORD dwQos ); 

    HRESULT InternalRecover( LPCWSTR wszQueueName, DWORD dwQoS );

    HRESULT OpenReceiver( LPCWSTR wszQueueName,
                          DWORD dwQoS, 
                          IWmiMessageSendReceive* pRecv,
                          IWmiMessageQueueReceiver** pRcvr );

    HRESULT OpenSender( LPCWSTR wszQueueName,
                        DWORD dwQoS, 
                        IWmiMessageSendReceive** ppSend );

    ~CQueueingEventSink();
 
public:

    CQueueingEventSink( CEssNamespace* pNamespace );

    HRESULT SetName( LPCWSTR wszName );

    void SetMaxQueueSize(DWORD dwMaxSize) {m_dwMaxSize = dwMaxSize;}

    // TODO : a lot of these parameters should go inside the context.
    STDMETHODIMP SecureIndicate( long lNumEvents, 
                                 IWbemEvent** apEvents,
                                 BOOL bMaintainSecurity, 
                                 BOOL bSlowDown,
                                 DWORD dwQoS, 
                                 CEventContext* pContext );

    HRESULT Indicate( long lNumEvents, 
                      IWbemEvent** apEvents, 
                      CEventContext* pContext )
    {
        return SecureIndicate( lNumEvents, 
                               apEvents, 
                               TRUE, 
                               FALSE, 
                               WMIMSG_FLAG_QOS_EXPRESS,
                               pContext);
    }

    HRESULT DeliverAll();
    virtual HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                    BOOL bSecure, CEventContext* pContext) = 0;

    virtual HRESULT ReportQueueOverflow(IWbemEvent* pEvent, DWORD dwQueueSize) 
        {return S_OK;}
    virtual HRESULT ReportQosFailure(IWbemEvent* pEvent, HRESULT hresError )
        {return S_OK;}
 
    static HRESULT QueueNameToSinkName( LPCWSTR wszQueueName,
                                        WString& rwsSinkName,
                                        WString& rwsNamespace,
                                        DWORD& rdwQoS );

    static HRESULT SinkNameToQueueName( LPCWSTR wszSinkName,
                                        LPCWSTR wszNamespace,
                                        DWORD dwQoS,
                                        WString& rwsQueueName );

    // 
    // called by guaranteed delivery record when it needs to remove a 
    // delivery from the guaranteed queue.
    //
    HRESULT GuaranteedPostDeliverAction( IWmiMessageQueueReceiver* pRcvr );

    //
    // Opens the specified queue and initiates the delivery of persisted
    // records.  Called on startup by the ess object on a background thread.
    // Also called when encountering errors with saving or removing 
    // delivery records from the persistent queues.
    //
    HRESULT Recover( LPCWSTR wszQueueName, DWORD dwQoS );

    //
    // this method is called when a queueing sink is removed because all of 
    // the consumers associated with it have been removed.   
    // 
    HRESULT CleanupPersistentQueues();

protected:

    DWORD GetMaxDeliverySize();

    BOOL DoesRecordFitBatch( CDeliveryRecord* pRecord, 
                             IWbemCallSecurity* pBatchSecurity,
                             LUID luidBatch );

    HRESULT DeliverSome( );
    void ClearAll();
    HRESULT DeliverEvents( IWbemCallSecurity* pBatchSecurity, 
                           long lNumEvents, 
                           IWbemEvent** apEvents);

    BOOL AddRecord( ACQUIRE CDeliveryRecord* pRecord, 
                    BOOL bSlowDown, 
                    DWORD* pdwSleep, 
                    BOOL* pbFirst);
    
    void WaitABit();
};

#endif // __QSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\quota.cpp ===
//=============================================================================
//
//  Copyright (c) 2000, Microsoft Corporation, All rights reserved
//
//  Quota.CPP
//
//  Implements the class that keeps track of quotas within ESS.
//
//=============================================================================

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "essutils.h"
#include "nsrep.h"
#include "Quota.h"
#include <cominit.h>
#include <callsec.h>

// Global instance.
CQuota g_quotas;

#define WMICOREQUOTAS_NAMESPACE L"root"
#define WMICOREQUOTAS_OBJPATH   L"__ArbitratorConfiguration=@"
#define WMICOREQUOTAS_CLASS     L"__ArbitratorConfiguration"


CUserInfo::CUserInfo() :
    m_pData(NULL),
    m_dwSize(0),
    m_bAlloced(FALSE)
{
    ZeroMemory(m_dwUserCount, sizeof(m_dwUserCount));
}

CUserInfo::CUserInfo(LPBYTE pData, DWORD dwSize) :
    m_pData(pData),
    m_dwSize(dwSize),
    m_bAlloced(FALSE)
{
    ZeroMemory(m_dwUserCount, sizeof(m_dwUserCount));
}

CUserInfo::~CUserInfo()
{
    if (m_pData && m_bAlloced)
        delete m_pData;
}

BOOL CUserInfo::CopyData(LPBYTE pData, DWORD dwSize)
{
    BOOL bRet;

    m_pData = new BYTE[dwSize];
    if (m_pData)
    {
        memcpy(m_pData, pData, dwSize);
        m_dwSize = dwSize;
        m_bAlloced = TRUE;
        bRet = TRUE;
    }
    else
        bRet = FALSE;

    return bRet;
}

const CUserInfo& CUserInfo::operator = (const CUserInfo& other)
{
    if (other.m_bAlloced)
    {
        m_pData = other.m_pData;
        m_dwSize = other.m_dwSize;
        ((CUserInfo&)other).m_bAlloced = FALSE;
        m_bAlloced = TRUE;
    }
    else
        CopyData(other.m_pData, other.m_dwSize);

    memcpy(m_dwUserCount, other.m_dwUserCount, sizeof(m_dwUserCount));

    return *this;
}

BOOL CUserInfo::Init(LPBYTE pData, DWORD dwSize)
{
    BOOL bRet;

    // See if we need to get the data out of the token.
    if (!pData)
    {
        IWbemCallSecurity *pSecurity = NULL;

        bRet = FALSE;

        WbemCoGetCallContext(IID_IWbemCallSecurity, (void**) &pSecurity);        

        if (pSecurity)
        {
            // Get the client's SID.
            TOKEN_USER tu;
            DWORD      dwLen = 0;
            HANDLE     hToken = pSecurity->GetToken();
            
            GetTokenInformation(
                hToken, 
                TokenUser, 
                &tu, 
                sizeof(tu), 
                &dwLen);

            if (dwLen != 0)
            {
                BYTE  *pTemp = new BYTE[dwLen];
                DWORD dwRealLen = dwLen;

                if (pTemp)
                {
                    if (GetTokenInformation(
                        hToken, 
                        TokenUser, 
                        pTemp, 
                        dwRealLen, 
                        &dwLen))
                    {
                        // Make a copy of the SID
                        PSID  pSid = ((TOKEN_USER*)pTemp)->User.Sid;
                        DWORD dwSidLen = GetLengthSid(pSid);
                        
                        m_pData = new BYTE[dwSidLen];

                        if (m_pData)
                        {
                            CopySid(dwSidLen, m_pData, pSid);
                            m_dwSize = dwSidLen;
                            m_bAlloced = TRUE;

                            bRet = TRUE;
                        }
                    }

                    delete [] pTemp;
                }
            }

            pSecurity->Release();
        }    
    }
    else
    {
        m_pData = pData;
        m_dwSize = dwSize;
        m_bAlloced = FALSE;

        bRet = TRUE;
    }

    return bRet;
}

#define DEF_GLOBAL_LIMIT    100
#define DEF_USER_LIMIT      20

CQuota::CQuota() :
    m_pEss(NULL)
{
    // Zero this out.
    ZeroMemory(m_dwGlobalCount, sizeof(m_dwGlobalCount));
    
    // Setup some defaults.  These will eventually get overridden once 
    // Init() is called.
    for (int i = 0; i < ESSQ_INDEX_COUNT; i++)
    {
        m_dwGlobalLimits[i] = DEF_GLOBAL_LIMIT;
        m_dwUserLimits[i] = DEF_USER_LIMIT;
    }        

    m_dwGlobalLimits[ESSQ_POLLING_MEMORY] = 10000000;
    m_dwUserLimits[ESSQ_POLLING_MEMORY] = 5000000;

    try
    {
        InitializeCriticalSection(&m_cs);
    }
    catch(...)
    {
        throw CX_MemoryException();
    }
}

HRESULT CQuota::Init(CEss *pEss)
{
    HRESULT hr;

    m_pEss = pEss;

    CEssNamespace *pNamespace = NULL;

    hr = 
        pEss->GetNamespaceObject(
            WMICOREQUOTAS_NAMESPACE,
            TRUE,
            &pNamespace );
            
    if (SUCCEEDED(hr))
    {    
        _IWmiObject *pObj = NULL;

        hr = 
            pNamespace->GetInstance(
                WMICOREQUOTAS_OBJPATH,
                &pObj);

        if (SUCCEEDED(hr))
        {
            UpdateQuotaSettings(pObj);
            pObj->Release();

            {
                CInUpdate iu( pNamespace );

                hr = pNamespace->InternalRegisterNotificationSink(
                    L"WQL", 
                    L"select * from __InstanceModificationEvent "
                        L"where targetinstance isa '" WMICOREQUOTAS_CLASS L"'",
                    0, WMIMSG_FLAG_QOS_SYNCHRONOUS,
                    GetCurrentEssContext(), 
                    this,
                    true,
                    NULL );
            }
            pNamespace->FirePostponedOperations();
        }

        pNamespace->Release();
    }

    // Always return S_OK in case WMICOREQUOTAS_OBJPATH doesn't exist yet.
    // Hopefully at some point this instance will always be there.
    return S_OK;
}


HRESULT CQuota::Shutdown()
{
    if (m_pEss)
        m_pEss->RemoveNotificationSink(this);
    m_pEss = NULL;
    return S_OK;
}

CQuota::~CQuota()
{
    DeleteCriticalSection(&m_cs);
}

bool CUserInfo::operator == (const CUserInfo& other) const
{ 
    return m_dwSize == other.m_dwSize &&
            !memcmp(m_pData, other.m_pData, m_dwSize);
}

bool CUserInfo::operator < (const CUserInfo& other) const
{ 
    if (m_dwSize < other.m_dwSize)
        return TRUE;
    else if (m_dwSize > other.m_dwSize)
        return FALSE;
    else
        return memcmp(m_pData, other.m_pData, m_dwSize) < 0;
}

void GetSidInfo(CEventFilter *pFilter, LPVOID *ppSid, DWORD *pdwSize)
{
    if (pFilter)
    {
        *ppSid = pFilter->GetOwner();

        *pdwSize = *ppSid ? GetLengthSid(*ppSid) : 0;
    }
    else
    {
        *ppSid = NULL;
        *pdwSize = 0;
    }
}

HRESULT CQuota::FindUser(CEventFilter* pFilter, void** pUser)
{
    HRESULT hr = S_OK;
    LPVOID  pSid = NULL;
    DWORD   dwSize;

    GetSidInfo(pFilter, &pSid, &dwSize);

    // We'll save the context if there's not a Sid.
    BOOL             bDoSwitchContext = pSid == NULL;
    CSaveCallContext save(bDoSwitchContext);

    if (bDoSwitchContext)
    {
        hr = pFilter->SetThreadSecurity();
        if(FAILED(hr))
            return hr;
    }

    CInCritSec ics(&m_cs);
    
    CUserInfo user;
    if (user.Init((LPBYTE) pSid, dwSize))
    {
        CUserMapIterator it;
    
        it= m_mapUserInfo.find(user);
        if (it!= m_mapUserInfo.end())
        {
            *pUser = new CUserMapIterator(it);
            if(*pUser == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            return S_OK;
        }
        else
        {
            // Add it to the map.
            
            try
            {
                m_mapUserInfo[user] = 0;
            }
            catch(CX_MemoryException)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            *pUser = new CUserMapIterator(m_mapUserInfo.find(user));
            if(*pUser == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            return S_OK;
        }
    }
    else
    {
        // Special case for calls Winmgmt makes: doesn't count against any 
        // user.

        *pUser = NULL;
        return S_FALSE;
    }
}
    
HRESULT CQuota::FreeUser(void* pUser)
{
    delete (CUserMapIterator*)pUser;
    return S_OK;
}

HRESULT CQuota::IncrementQuotaIndex(
    ESS_QUOTA_INDEX dwIndex, 
    CEventFilter *pFilter,
    DWORD dwToAdd)
{
    HRESULT hr = S_OK;
    LPVOID  pSid = NULL;
    DWORD   dwSize;

    GetSidInfo(pFilter, &pSid, &dwSize);

    // We'll save the context if there's not a Sid.
    BOOL             bDoSwitchContext = pSid == NULL;
    CSaveCallContext save(bDoSwitchContext);

    if (bDoSwitchContext)
    {
        hr = pFilter->SetThreadSecurity();
        if(FAILED(hr))
            return hr;
    }

    Lock();
    
    if (m_dwGlobalCount[dwIndex] + dwToAdd <= m_dwGlobalLimits[dwIndex])
    {
        CUserInfo user;

        if (user.Init((LPBYTE) pSid, dwSize))
        {
            CUserMapIterator item;
        
            item = m_mapUserInfo.find(user);
        
            if (item != m_mapUserInfo.end())
            {
                CUserInfo &itemRef = (CUserInfo&) (*item).first;

                if (itemRef.m_dwUserCount[dwIndex] + dwToAdd <= m_dwUserLimits[dwIndex])
                {
                    itemRef.m_dwUserCount[dwIndex] += dwToAdd;
                    m_dwGlobalCount[dwIndex] += dwToAdd;
                }
                else
                    hr = WBEM_E_QUOTA_VIOLATION;
            }
            else
            {
                // Set the number of items to dwToAdd.

                user.m_dwUserCount[dwIndex] = dwToAdd;

                // Add it to the map.
                try
                {
                    m_mapUserInfo[user] = 0;
                }
                catch(CX_MemoryException)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;
                }

                if(SUCCEEDED(hr))
                {
                    m_dwGlobalCount[dwIndex] += dwToAdd;
                }
            }
        }
        else
        {
            // Special case for calls Winmgmt makes: doesn't count against any 
            // user.
            // Should this event count against our global counts?
            m_dwGlobalCount[dwIndex] += dwToAdd;
        }
    }
    else
        hr = WBEM_E_QUOTA_VIOLATION;

    Unlock();

    return hr;
}
    
HRESULT CQuota::DecrementQuotaIndex(
    ESS_QUOTA_INDEX dwIndex,
    CEventFilter *pFilter,
    DWORD dwToRemove)
{
    CUserInfo user;
    BOOL      bRet = FALSE;
    LPVOID    pSid;
    DWORD     dwSize;
    HRESULT hr;

    GetSidInfo(pFilter, &pSid, &dwSize);

    // We'll save the context if there's not a Sid.
    BOOL             bDoSwitchContext = pSid == NULL;
    CSaveCallContext save(bDoSwitchContext);

    if (bDoSwitchContext)
    {
        hr = pFilter->SetThreadSecurity();
        if(FAILED(hr))
            return hr;
    }

    Lock();
    
    m_dwGlobalCount[dwIndex] -= dwToRemove;

    if (user.Init((LPBYTE) pSid, dwSize))
    {
        CUserMapIterator item;
        
        item = m_mapUserInfo.find(user);
        
        if (item != m_mapUserInfo.end())
        {
            CUserInfo &itemRef = (CUserInfo&) (*item).first;

            itemRef.m_dwUserCount[dwIndex] -= dwToRemove;
        }
    }

    Unlock();
    
    return ERROR_SUCCESS;
}



HRESULT CQuota::IncrementQuotaIndexByUser(
    ESS_QUOTA_INDEX dwIndex, 
    void *pUser,
    DWORD dwToAdd)
{
    CUserMapIterator* pIt = (CUserMapIterator*)pUser;

    HRESULT hr = S_OK;

    Lock();
    
    if (m_dwGlobalCount[dwIndex] + dwToAdd <= m_dwGlobalLimits[dwIndex])
    {
        if(pIt)
        {
            CUserInfo &itemRef = (CUserInfo&) (*pIt)->first;
    
            if (itemRef.m_dwUserCount[dwIndex] + dwToAdd <= 
                    m_dwUserLimits[dwIndex])
            {
                itemRef.m_dwUserCount[dwIndex] += dwToAdd;
                m_dwGlobalCount[dwIndex] += dwToAdd;
            }
            else
            {
                hr = WBEM_E_QUOTA_VIOLATION;
            }
        }
        else
        {
            // Special case for calls Winmgmt makes: doesn't count against any 
            // user.
            // Should this event count against our global counts?
            m_dwGlobalCount[dwIndex] += dwToAdd;
        }
    }
    else
        hr = WBEM_E_QUOTA_VIOLATION;

    Unlock();

    return hr;
}
    
HRESULT CQuota::DecrementQuotaIndexByUser(
    ESS_QUOTA_INDEX dwIndex,
    void *pUser,
    DWORD dwToRemove)
{
    CUserMapIterator* pIt = (CUserMapIterator*)pUser;

    Lock();
    
    m_dwGlobalCount[dwIndex] -= dwToRemove;

    if (pIt)
    {
        CUserInfo &itemRef = (CUserInfo&) (*pIt)->first;

        _ASSERT(itemRef.m_dwUserCount[dwIndex] >= dwToRemove, 
                L"Negative quotas!");

        itemRef.m_dwUserCount[dwIndex] -= dwToRemove;
    }

    Unlock();

    return S_OK;
}

const LPCWSTR szUserProps[] =
{
    L"TemporarySubscriptionsPerUser",
    L"PermanentSubscriptionsPerUser",
    L"PollingInstructionsPerUser", 
    L"PollingMemoryPerUser",
};

const LPCWSTR szGlobalProps[] =
{
    L"TemporarySubscriptionsTotal",
    L"PermanentSubscriptionsTotal",
    L"PollingInstructionsTotal", 
    L"PollingMemoryTotal",
};

void CQuota::UpdateQuotaSettings(IWbemClassObject *pObj)
{
    VARIANT vTemp;

    VariantInit(&vTemp);

    Lock();

    for (int i = 0; i < ESSQ_INVALID_INDEX; i++)
    {
        if (SUCCEEDED(pObj->Get(szUserProps[i], 0, &vTemp, NULL, NULL)))
            m_dwUserLimits[i] = V_I4(&vTemp);

        if (SUCCEEDED(pObj->Get(szGlobalProps[i], 0, &vTemp, NULL, NULL)))
            m_dwGlobalLimits[i] = V_I4(&vTemp);
    }             

    Unlock();
}

HRESULT WINAPI CQuota::Indicate(long lNumEvents, IWbemClassObject **ppEvents)
{
    VARIANT vTemp;

    VariantInit(&vTemp);

    if (SUCCEEDED(ppEvents[lNumEvents - 1]->Get(
        L"TARGETINSTANCE", 0, &vTemp, NULL, NULL)))
    {
        IWbemClassObject *pObj = NULL;
        
        vTemp.punkVal->QueryInterface(IID_IWbemClassObject, (LPVOID*) &pObj);

        if (pObj)
        {
            UpdateQuotaSettings(pObj);

            pObj->Release();
        }
    }

    VariantClear(&vTemp);

    return S_OK;
}

CSaveCallContext::CSaveCallContext(BOOL bSave) :
    m_pSecurity(NULL)
{
    m_bSaved = bSave;

    if (bSave)
        WbemCoGetCallContext(IID_IWbemCallSecurity, (LPVOID*) &m_pSecurity);
}

CSaveCallContext::~CSaveCallContext()
{
    if (m_bSaved)
    {
        IUnknown *pPrev = NULL;

        CoSwitchCallContext(m_pSecurity, &pPrev);

        if (m_pSecurity)
            m_pSecurity->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tempcons.cpp ===
//******************************************************************************
//
//  TEMPCONS.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "tempcons.h"

CTempConsumer::CTempConsumer(CEssNamespace* pNamespace)
    : CEventConsumer(pNamespace), m_pSink(NULL), m_bEffectivelyPermanent(FALSE)
{
    pNamespace->IncrementObjectCount();
}

HRESULT CTempConsumer::Initialize( BOOL bEffectivelyPermanent, 
                                   IWbemObjectSink* pSink)
{
    m_bEffectivelyPermanent = bEffectivelyPermanent;

    // Save the sink
    // =============

    m_pSink = pSink;
    if(m_pSink)
        m_pSink->AddRef();

    // Compute the key from the sink pointer
    // =====================================

    LPWSTR wszKey = ComputeKeyFromSink(pSink);

    if ( NULL == wszKey )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<WCHAR> vdm(wszKey);

    // Save the key into the compressed format
    // =======================================

    if( !( m_isKey = wszKey ) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

// This class represents a postponed request to disconnect a temporary consumer
// Its implementation is to call SetStatus followed by a release
class CPostponedDisconnect : public CPostponedRequest
{
protected:
    IWbemObjectSink* m_pSink;

public:
    CPostponedDisconnect(IWbemObjectSink* pSink) : m_pSink(pSink)
    {
        m_pSink->AddRef();
    }
    ~CPostponedDisconnect()
    {
        m_pSink->Release();
    }
    
    HRESULT Execute(CEssNamespace* pNamespace)
    {
        m_pSink->SetStatus(0, WBEM_S_OPERATION_CANCELLED, NULL, NULL);
        m_pSink->Release();
        return WBEM_S_NO_ERROR;
    }
};
        
HRESULT CTempConsumer::Shutdown(bool bQuiet)
{
    IWbemObjectSink* pSink = NULL;
    {
        CInCritSec ics(&m_cs);
        if(m_pSink)
        {
            pSink = m_pSink;
            m_pSink = NULL;
        }
    }

    if(pSink)
    {
        if(!bQuiet)
            pSink->SetStatus(0, WBEM_E_CALL_CANCELLED, NULL, NULL);
        pSink->Release();
    }

    return WBEM_S_NO_ERROR;
}

CTempConsumer::~CTempConsumer()
{
    if(m_pSink)
    {
        //
        // Postpone disconnect request --- don't want the consumer to hand us
        // here
        //

        CPostponedList* pList = GetCurrentPostponedList();
        if(pList != NULL)
        {
            CPostponedDisconnect* pReq = new CPostponedDisconnect(m_pSink);
            
            if(pReq != NULL)
                pList->AddRequest( m_pNamespace, pReq);

            m_pSink = NULL;
        }
        else
        {
            m_pSink->Release();
            m_pSink = NULL;
        }
    }
    m_pNamespace->DecrementObjectCount();
}

HRESULT CTempConsumer::ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents,
                                        BOOL bSecure, CEventContext* pContext)
{
    HRESULT hres;
    IWbemObjectSink* pSink = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pSink)
        {
            pSink = m_pSink;
            pSink->AddRef();
        }
    }

    CReleaseMe rm1(pSink);

    if( pSink )
    {
        //
        // TODO: Separate out an InternalTempConsumer class that is used 
        // for cross-namespace delivery.  This way, we can remove all of the
        // cross-namespace hacks ( like one below ) from this class.
        // 
        if ( !m_bEffectivelyPermanent )
        {
            hres = pSink->Indicate(lNumEvents, apEvents);
        }
        else
        {
            //
            // before indicating to the sink, decorate the event so that 
            // the subscribers can tell which namespace the event originated
            // from.  
            // 

/*
BUGBUG: Removing because we do not support an event being modified by one 
of its consumers.  This is because we do not clone the event when delivering 
to each consumer.  

            for( long i=0; i < lNumEvents; i++ )
            {
                hres = m_pNamespace->DecorateObject( apEvents[i] );

                if ( FAILED(hres) )
                {
                    ERRORTRACE((LOG_ESS, "Failed to decorate a "
                     " cross-namespace event in namespace %S.\n", 
                     m_pNamespace->GetName() ));
                }        
            }
*/                
            hres = ((CAbstractEventSink*)pSink)->Indicate( lNumEvents,
                                                           apEvents,
                                                           pContext );
        }
    }
    else
        hres = WBEM_E_CRITICAL_ERROR;

    if(FAILED(hres) && hres != WBEM_E_CALL_CANCELLED)
    {
        ERRORTRACE((LOG_ESS, "An attempt to deliver an evento to a "
            "temporary consumer failed with %X\n", hres));

        // The wraper for the sink took care of cancellation
    }
    return hres;
}

HRESULT CTempConsumer::ReportQueueOverflow(IWbemEvent* pEvent, 
                                            DWORD dwQueueSize)
{
    IWbemObjectSink* pSink = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pSink)
        {
            pSink = m_pSink;
            pSink->AddRef();
        }
    }

    CReleaseMe rm1(pSink);

    // Call SetStatus to report
    // ========================

    if(pSink)
    {
        pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_QUEUE_OVERFLOW, 
                            NULL, NULL);

        // Keep sink up.  Hope it recovers
        // ===============================

    }
    return S_OK;
}


DELETE_ME LPWSTR CTempConsumer::ComputeKeyFromSink(IWbemObjectSink* pSink)
{
    LPWSTR wszKey = _new WCHAR[20];

    if ( wszKey )
    {
        swprintf(wszKey, L"$%p", pSink);
    }

    return wszKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\quota.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************
// Quota.h

#ifndef __QUOTA_H
#define __QUOTA_H

#include <map>

enum ESS_QUOTA_INDEX
{
    ESSQ_TEMP_SUBSCRIPTIONS,
    ESSQ_PERM_SUBSCRIPTIONS,
    ESSQ_POLLING_INSTRUCTIONS,
    ESSQ_POLLING_MEMORY,
    ESSQ_INVALID_INDEX
};

#define ESSQ_INDEX_COUNT    ESSQ_INVALID_INDEX

class CSaveCallContext
{
public:
    CSaveCallContext(BOOL bSave);
    ~CSaveCallContext();

protected:
    IWbemCallSecurity *m_pSecurity;
    BOOL              m_bSaved;
};
    
class CUserInfo
{
public:
    CUserInfo();
    CUserInfo(LPBYTE pData, DWORD dwLen);
    CUserInfo(const CUserInfo &other)
    {
        *this = other;
    }

    ~CUserInfo();

    BOOL Init(LPBYTE pData, DWORD dwLen);

    const CUserInfo& operator = (const CUserInfo& other);
    bool operator == (const CUserInfo& other) const;
    bool operator < (const CUserInfo& other) const;

    DWORD  m_dwUserCount[ESSQ_INDEX_COUNT];

protected:
    LPBYTE m_pData;
    DWORD  m_dwSize;
    BOOL   m_bAlloced;

    BOOL CopyData(LPBYTE pData, DWORD dwLen);
};

class CQuota : public IWbemObjectSink
{
public:
    CQuota();
    ~CQuota();

    HRESULT IncrementQuotaIndex(
        ESS_QUOTA_INDEX dwIndex,
        CEventFilter *pFilter,
        DWORD dwToAdd);
    HRESULT DecrementQuotaIndex(
        ESS_QUOTA_INDEX dwIndex,
        CEventFilter *pFilter,
        DWORD dwToRemove);
    HRESULT FindUser(CEventFilter* pFilter, void** pUser);
    HRESULT FreeUser(void* pUser);
    HRESULT IncrementQuotaIndexByUser(ESS_QUOTA_INDEX dwIndex, 
                                void *pUser, DWORD dwToAdd);
    HRESULT DecrementQuotaIndexByUser(ESS_QUOTA_INDEX dwIndex, void *pUser,
                                DWORD dwToRemove);

    HRESULT Init(CEss *pEss);
    HRESULT Shutdown();

protected:
    typedef std::map<CUserInfo, DWORD, std::less<CUserInfo>, 
                    wbem_allocator<DWORD> > CUserMap;
    typedef CUserMap::iterator CUserMapIterator;

    CEss             *m_pEss;
    CUserMap         m_mapUserInfo;
    DWORD            m_dwGlobalCount[ESSQ_INDEX_COUNT],
                     m_dwUserLimits[ESSQ_INDEX_COUNT],
                     m_dwGlobalLimits[ESSQ_INDEX_COUNT];
    CRITICAL_SECTION m_cs;

    void UpdateQuotaSettings(IWbemClassObject *pObj);

    void Lock()
    {
        EnterCriticalSection(&m_cs);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_cs);
    }

    DWORD WINAPI AddRef()
    {
        return 1;
    }

    DWORD WINAPI Release()
    {
        return 1;
    }

    HRESULT WINAPI QueryInterface(REFIID riid, void **ppv)
    {
        if (riid == IID_IUnknown || riid == IID_IWbemObjectSink)
        {
            *ppv = (IWbemObjectSink*) this;
            AddRef();
            
            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }
    HRESULT WINAPI Indicate(long lNumEvents, IWbemEvent** apEvents);
    HRESULT WINAPI SetStatus(long, long, BSTR, IWbemClassObject*)
    {
        return E_NOTIMPL;
    }
};

// Global instance of CQuota.
extern CQuota g_quotas;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tempcons.h ===
//******************************************************************************
//
//  TEMPCONS.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TEMP_CONSUMER__H_
#define __WMI_ESS_TEMP_CONSUMER__H_

#include "binding.h"
#include "tempfilt.h"

class CTempConsumer : public CEventConsumer
{
    //
    // ESS can internally use temporary subscriptions to satisfy cross
    // namespace subscriptions.  We need to be able to propagate the
    // 'permanent'-ness with the temporary subscription to the target
    // namespace.
    //
    BOOL m_bEffectivelyPermanent;

    IWbemObjectSink* m_pSink;

public:
    CTempConsumer(CEssNamespace* pNamespace);
    HRESULT Initialize( BOOL bEffectivelyPermanent, IWbemObjectSink* pSink);
    ~CTempConsumer();

    BOOL IsPermanent() const { return m_bEffectivelyPermanent; }

    HRESULT ActuallyDeliver(long lNumEvents, IWbemEvent** apEvents, 
                            BOOL bSecure, CEventContext* pContext);
    
    static DELETE_ME LPWSTR ComputeKeyFromSink(IWbemObjectSink* pSink);

    HRESULT ReportQueueOverflow(IWbemEvent* pEvent, DWORD dwQueueSize);
    HRESULT Shutdown(bool bQuiet = false);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tempfilt.cpp ===
//******************************************************************************
//
//  TEMPFILT.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "tempfilt.h"
#include <cominit.h>
#include <tkncache.h>
#include <callsec.h>
#include <wbemutil.h>

CTempFilter::CTempFilter(CEssNamespace* pNamespace)
    : CGenericFilter(pNamespace), m_wszQueryLanguage(NULL), 
      m_wszQuery(NULL), m_pSecurity(NULL), m_bInternal( false )
{
}

HRESULT CTempFilter::Initialize( LPCWSTR wszQueryLanguage, 
                                 LPCWSTR wszQuery, 
                                 long lFlags, 
                                 PSID pOwnerSid,
                                 bool bInternal,
                                 IWbemContext* pContext, 
                                 IWbemObjectSink* pSink )
{
    HRESULT hres;

    m_bInternal = bInternal;

    hres = CGenericFilter::Create(wszQueryLanguage, wszQuery);
    if(FAILED(hres))
        return hres;

    LPWSTR wszKey = ComputeThisKey();
    if(wszKey == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<WCHAR> vdm(wszKey);
    if(!(m_isKey = wszKey))
        return WBEM_E_OUT_OF_MEMORY;

    m_wszQueryLanguage = CloneWstr(wszQueryLanguage);
    if(m_wszQueryLanguage == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    m_wszQuery = CloneWstr(wszQuery);
    if(m_wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // if this filter is effectively permanent, that is it is being created
    // on behalf of a permanent subscription ( for cross namespace purposes ),
    // then we need to propagate the SID of the original subscription.
    // For a normal temp filter, we save the call context and use that later 
    // for checking access.
    //

    if ( pOwnerSid == NULL )
    {
        //
        // if this call is an on behalf of an internal call, no need to 
        // check security.
        // 
        if ( !bInternal )
        {
            WbemCoGetCallContext( IID_IWbemCallSecurity, (void**)&m_pSecurity);
        }
    }
    else
    {
        int cOwnerSid = GetLengthSid( pOwnerSid );

        m_pOwnerSid = new BYTE[cOwnerSid];

        if ( m_pOwnerSid == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy( m_pOwnerSid, pOwnerSid, cOwnerSid );
    }

    return WBEM_S_NO_ERROR;
}

CTempFilter::~CTempFilter()
{
    delete [] m_wszQuery;
    delete [] m_wszQueryLanguage;
    if(m_pSecurity)
        m_pSecurity->Release();
}

DELETE_ME LPWSTR CTempFilter::ComputeThisKey()
{
    LPWSTR wszKey = _new WCHAR[20];

    if ( wszKey )
    {
        swprintf(wszKey, L"$%p", this);
    }
    return wszKey;
}

HRESULT CTempFilter::GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp)
{
    bExact = TRUE;
    wszQueryLanguage = CloneWstr(m_wszQueryLanguage);
    if(wszQueryLanguage == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    wszQuery = CloneWstr(m_wszQuery);
    if(wszQuery== NULL)
    {
        delete [] wszQueryLanguage;
        wszQueryLanguage = NULL;
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    if(ppExp)
    {
        CTextLexSource src((LPWSTR)wszQuery);
        QL1_Parser parser(&src);
        int nRes = parser.Parse(ppExp);
        if (nRes)
        {
            delete [] wszQueryLanguage;
            delete [] wszQuery;
            wszQueryLanguage = NULL;
            wszQuery = NULL;

            ERRORTRACE((LOG_ESS, "Unable to construct event filter with "
                "unparsable "
                "query '%S'.  The filter is not active\n", wszQuery));
            return WBEM_E_UNPARSABLE_QUERY;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CTempFilter::SetThreadSecurity()
{
    HRESULT hr;

    if ( m_pSecurity != NULL )
    {
        IUnknown* pOld;
        hr = WbemCoSwitchCallContext( m_pSecurity, &pOld );
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}
    
HRESULT CTempFilter::ObtainToken(IWbemToken** ppToken)
{
    HRESULT hr;
    *ppToken = NULL;

    //
    // Construct an IWbemToken object to return.
    //

    if ( m_pSecurity != NULL )
    {
        CWmiToken* pNewToken = new CWmiToken(m_pSecurity->GetToken());
    
        if ( pNewToken != NULL )
        {
            hr = pNewToken->QueryInterface(IID_IWbemToken, (void**)ppToken);
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if ( m_pOwnerSid != NULL )
    {
        hr = m_pNamespace->GetToken( m_pOwnerSid, ppToken );
    }
    else if ( m_bInternal )
    {
        hr = WBEM_S_FALSE;
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\wbemtss.cpp ===
//*****************************************************************************
//
//  WBEMTSS.CPP
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  This file implements the classes used by the Timer Subsystem. 
//
//  Classes implemented:
//
//  26-Nov-96   raymcc      Draft
//  28-Dec-96   a-richm     Alpha PDK Release
//  12-Apr-97   a-levn      Extensive changes
//
//*****************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "ess.h"
#include "wbemtss.h"

CCritSec CWBEMTimerInstruction::mstatic_cs;

CWBEMTimerInstruction::CWBEMTimerInstruction() 
    : m_lRefCount(1), m_bSkipIfPassed(FALSE), m_pNamespace(NULL), 
        m_pGenerator(NULL), m_bRemoved(FALSE)
{
}


CWBEMTimerInstruction::~CWBEMTimerInstruction()
{
    if(m_pNamespace) m_pNamespace->Release();
}


CWbemTime CWBEMTimerInstruction::GetFirstFiringTime() const
{
    CWbemTime FirstTime = ComputeFirstFiringTime();
    
    if(FirstTime.IsZero())
    {
        // Instruction says: fire now
        // ==========================
        FirstTime = CWbemTime::GetCurrentTime();
    }
    else if(SkipIfPassed())
    {
        FirstTime = SkipMissed(FirstTime);
    }
    return FirstTime;
}

CWbemTime CWBEMTimerInstruction::GetStartingFiringTime(CWbemTime OldTime) const
{
    //
    // If SkipIfPassed is set, we need to set the starting firing time to the
    // next one after current
    //

    if(SkipIfPassed())
        return SkipMissed(OldTime);

    //
    // Otherwise, just leave it be --- the firing logic will figure out how many
    // we must have missed
    //

    return OldTime;
}

CWbemTime CWBEMTimerInstruction::SkipMissed(IN CWbemTime OldTime, 
                                         OUT long* plMissedFiringCount) const
{
    long lMissedCount = 0;
    CWbemTime Firing = OldTime;
    CWbemTime CurrentTime = CWbemTime::GetCurrentTime();
    while(Firing < CurrentTime)
    {
        Firing = ComputeNextFiringTime(Firing);
        lMissedCount++;
    }

    if(SkipIfPassed())
        lMissedCount = 0;

    if(plMissedFiringCount) 
        *plMissedFiringCount = lMissedCount;

    return Firing;
}

CWbemTime CWBEMTimerInstruction::GetNextFiringTime(IN CWbemTime LastFiringTime, 
                                         OUT long* plMissedFiringCount) const
{
    CWbemTime NextFiring = ComputeNextFiringTime(LastFiringTime);
    
    NextFiring = SkipMissed(NextFiring, plMissedFiringCount);

    return NextFiring;
}

HRESULT CWBEMTimerInstruction::CheckObject(IWbemClassObject* pInst)
{
    HRESULT hres;
    VARIANT v;

    VariantInit(&v);
    CClearMe cm(&v);

    hres = pInst->Get(L"SkipIfPassed", 0, &v, NULL, NULL);
    if(FAILED(hres)) 
        return hres;
    if(V_VT(&v) != VT_BOOL) 
        return WBEM_E_INVALID_OBJECT;

    hres = pInst->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;

    if(!_wcsicmp(V_BSTR(&v), 
                CAbsoluteTimerInstruction::GetWbemClassName()))
    {
        return CAbsoluteTimerInstruction::CheckObject(pInst);
    }
    else if(!_wcsicmp(V_BSTR(&v), 
                CIntervalTimerInstruction::GetWbemClassName()))
    {
        return CIntervalTimerInstruction::CheckObject(pInst);
    }
    else if(!_wcsicmp(V_BSTR(&v),
                CRecurringTimerInstruction::GetWbemClassName()))
    {
        return CRecurringTimerInstruction::CheckObject(pInst);
    }
    else
    {
        return WBEM_E_INVALID_CLASS;
    }
}

    

HRESULT CWBEMTimerInstruction::LoadFromWbemObject(
        LPCWSTR wszNamespace,
        ADDREF IWbemServices* pNamespace,
        CWinMgmtTimerGenerator* pGenerator,
        IN IWbemClassObject* pObject, 
        OUT RELEASE_ME CWBEMTimerInstruction*& pInstruction)
{
    HRESULT hres;
    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pObject->Get(L"__CLASS", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR) return WBEM_E_INVALID_OBJECT;

    if(!_wcsicmp(V_BSTR(&v), CAbsoluteTimerInstruction::GetWbemClassName()))
    {
        pInstruction = _new CAbsoluteTimerInstruction;
    }
    else if(!_wcsicmp(V_BSTR(&v), CIntervalTimerInstruction::GetWbemClassName()))
    {
        pInstruction = _new CIntervalTimerInstruction;
    }
    else if(!_wcsicmp(V_BSTR(&v),CRecurringTimerInstruction::GetWbemClassName()))
    {
        pInstruction = _new CRecurringTimerInstruction;
    }
    else
    {
        return WBEM_E_INVALID_CLASS;
    }

    if(pInstruction == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    pInstruction->m_wsNamespace = wszNamespace;
    pInstruction->m_pGenerator = pGenerator;

    pInstruction->m_pNamespace = pNamespace;
    if(pNamespace) pNamespace->AddRef();    

    VariantClear(&v);

    hres = pObject->Get(L"TimerId", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR) return WBEM_E_INVALID_OBJECT;

    pInstruction->m_wsTimerId = V_BSTR(&v);
    VariantClear(&v);

    hres = pObject->Get(L"SkipIfPassed", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BOOL) return WBEM_E_INVALID_OBJECT;

    pInstruction->m_bSkipIfPassed = (V_BOOL(&v) != VARIANT_FALSE);
  
    return pInstruction->LoadFromWbemObject(pObject);
}

HRESULT CWBEMTimerInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    // Notify the sink
    // ===============

    HRESULT hres = m_pGenerator->FireInstruction(this, lNumTimes);
    return hres;
}


HRESULT CWBEMTimerInstruction::StoreNextFiring(CWbemTime When)
{
    SCODE  sc;

    // Create an instance of the NextFiring class
    // ==========================================

    IWbemClassObject* pClass = NULL;
    sc = m_pNamespace->GetObject(L"__TimerNextFiring", 0, NULL, &pClass, NULL);
    if(FAILED(sc)) return sc;
    CReleaseMe rm0(pClass);

    IWbemClassObject* pInstance = NULL;
    sc = pClass->SpawnInstance(0, &pInstance);
    if(FAILED(sc)) return sc;
    CReleaseMe rm1(pInstance);

    // Set the timer id
    // ================

    VARIANT varID;
    V_VT(&varID) = VT_BSTR;
    V_BSTR(&varID) = SysAllocString(m_wsTimerId);
    if(V_BSTR(&varID) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    sc = pInstance->Put(L"TimerID", 0, &varID, 0);
    VariantClear(&varID);
    if(FAILED(sc)) 
        return sc;

    // Set the next firing time
    // ========================

    VARIANT varNext;
    V_VT(&varNext) = VT_BSTR;
    V_BSTR(&varNext) = SysAllocStringLen(NULL, 100);
    if(V_BSTR(&varNext) == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    swprintf(V_BSTR(&varNext), L"%I64d", When.Get100nss());

    sc = pInstance->Put(L"NextEvent64BitTime", 0, &varNext, 0);
    VariantClear(&varNext);
    if(FAILED(sc)) 
        return sc;

    //
    // Save the instance in the repository using an internal API
    //

    IWbemInternalServices* pIntServ = NULL;
    sc = m_pNamespace->QueryInterface(IID_IWbemInternalServices, 
                                        (void**)&pIntServ);
    if(FAILED(sc))
    {
        ERRORTRACE((LOG_ESS, "Unable to aquire internal services from core: "
                    "0x%X\n", sc));
        return sc;
    }
    CReleaseMe rm2(pIntServ);

    sc = pIntServ->InternalPutInstance(pInstance);
    return sc;
}

HRESULT CWBEMTimerInstruction::MarkForRemoval()
{
    CInCritSec incs(&mstatic_cs);
    m_bRemoved = TRUE;
    LPWSTR wszPath = _new WCHAR[wcslen(m_wsTimerId)+100];
    if(wszPath == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    swprintf(wszPath, L"__TimerNextFiring=\"%S\"", (LPCWSTR)m_wsTimerId);
    HRESULT hres = m_pNamespace->DeleteInstance(wszPath, 0, NULL, NULL);
    delete [] wszPath;
    return hres;
}







CWbemTime CAbsoluteTimerInstruction::ComputeFirstFiringTime() const
{
    return m_When;
}

CWbemTime CAbsoluteTimerInstruction::ComputeNextFiringTime(
                                               CWbemTime LastFiringTime) const
{
    return CWbemTime::GetInfinity();
}

// static
HRESULT CAbsoluteTimerInstruction::CheckObject(IWbemClassObject* pInst)
{
    //
    // Check if EventDateTime is actually a date, and not an interval
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    HRESULT hres = pInst->Get(L"EventDateTime", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_ILLEGAL_NULL;

    //
    // Check for * --- invalid
    //

    if(wcschr(V_BSTR(&v), L'*'))
        return WBEM_E_INVALID_PROPERTY;

    //
    // Check for ':' --- interval --- invalid
    //

    if(V_BSTR(&v)[21] == L':')
        return WBEM_E_INVALID_PROPERTY_TYPE;

    return WBEM_S_NO_ERROR;
}

HRESULT CAbsoluteTimerInstruction::LoadFromWbemObject(IWbemClassObject* pObject)
{
    VARIANT v;
    VariantInit(&v);

    HRESULT hres = pObject->Get(L"EventDateTime", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;
    if(V_VT(&v) != VT_BSTR) return WBEM_E_INVALID_OBJECT;

    BOOL bRes = m_When.SetDMTF(V_BSTR(&v));
    VariantClear(&v);
    return (bRes ? WBEM_S_NO_ERROR : WBEM_E_INVALID_OBJECT);
}

HRESULT CAbsoluteTimerInstruction::Fire(long lNumTimes, 
                                            CWbemTime NextFiringTime)
{
    // Fire it
    // =======

    HRESULT hres = CWBEMTimerInstruction::Fire(lNumTimes, NextFiringTime);

    {
        CInCritSec incs(&mstatic_cs);
        if(!m_bRemoved)
        {
            // Save the next firing time in WinMgmt
            // ====================================

            StoreNextFiring(NextFiringTime);
        }
    }
    return hres;
}

CWbemTime CIntervalTimerInstruction::ComputeFirstFiringTime() const
{
    if(!m_Start.IsZero())
        return m_Start;
    else
    {
        // Indicate that current time should be used
        return CWbemTime::GetCurrentTime() + m_Interval;
    }
}

CWbemTime CIntervalTimerInstruction::ComputeNextFiringTime(
                                               CWbemTime LastFiringTime) const
{
    if(m_Interval.IsZero()) 
    {
        return CWbemTime::GetInfinity();
    }
    return LastFiringTime + m_Interval;
}

HRESULT CIntervalTimerInstruction::LoadFromWbemObject(IWbemClassObject* pObject)
{
    VARIANT v;
    VariantInit(&v);

    HRESULT hres = pObject->Get(L"IntervalBetweenEvents", 0, &v, NULL, NULL);
    if(FAILED(hres)) return hres;

    if(V_VT(&v) != VT_I4 || V_I4(&v) == 0)
        return WBEM_E_INVALID_OBJECT;
    m_Interval.SetMilliseconds(V_I4(&v));
    return S_OK;
}




CWinMgmtTimerGenerator::CWinMgmtTimerGenerator(CEss* pEss) : CTimerGenerator(),
        m_pEss(pEss)
{
}   


HRESULT CWinMgmtTimerGenerator::LoadTimerEventObject(
                                            LPCWSTR wszNamespace,
                                            IWbemServices* pNamespace, 
                                            IWbemClassObject * pInstObject,
                                            IWbemClassObject * pNextFiring)
{
    CWBEMTimerInstruction* pInst;
    CWbemTime When;
    HRESULT hres;

    hres = CWBEMTimerInstruction::LoadFromWbemObject(wszNamespace, pNamespace, 
                                                this, pInstObject, pInst);
    if(FAILED(hres)) return hres;

    if(pNextFiring)
    {
        VARIANT v;
        VariantInit(&v);

        pNextFiring->Get(L"NextEvent64BitTime", 0 ,&v, NULL, NULL);
        if(V_VT(&v) != VT_BSTR)
        {
            delete pInst;
            return WBEM_E_FAILED;
        }
        __int64 i64;
        swscanf(V_BSTR(&v), L"%I64d", &i64);
        VariantClear(&v);

        When.Set100nss(i64);

        //
        // Ask the instruction to determine what the real first firing time
        // should be, given the fact what it was planned to be before we shut 
        // down
        //

        When = pInst->GetStartingFiringTime(When);
    }
    else
    {
        When = CWbemTime::GetZero();
    }
   
    // Remove old
    // ==========

    VARIANT vID;
    VariantInit(&vID);
    hres = pInstObject->Get(TIMER_ID_PROPNAME, 0, &vID, NULL, NULL);
    if(FAILED(hres)) return hres;

    Remove(wszNamespace, V_BSTR(&vID));
    VariantClear(&vID);

    hres = Set(pInst, When);
    pInst->Release();
    return hres;
}

HRESULT CWinMgmtTimerGenerator::CheckTimerInstruction(IWbemClassObject* pInst)
{
    return CWBEMTimerInstruction::CheckObject(pInst);
}

HRESULT CWinMgmtTimerGenerator::LoadTimerEventObject(
                                            LPCWSTR wszNamespace,
                                            IWbemClassObject * pInstObject)
{
    IWbemServices* pNamespace;
    HRESULT hres = m_pEss->GetNamespacePointer(wszNamespace,TRUE,&pNamespace);
    if(FAILED(hres))
        return hres;

    hres = LoadTimerEventObject(wszNamespace, pNamespace, pInstObject);
    pNamespace->Release();
    return hres;
}

SCODE CWinMgmtTimerGenerator::LoadTimerEventQueue(LPCWSTR wszNamespace,
                                               IWbemServices* pNamespace)
{
    SCODE  sc;

    ULONG uRet;
    WCHAR  pwcsCount[4] = L"";
    int iInstanceCount = 1;

    IEnumWbemClassObject* pEnum;
    sc = pNamespace->CreateInstanceEnum(L"__TimerInstruction", 
                                           WBEM_FLAG_DEEP, NULL, 
                                           &pEnum);
    if(FAILED(sc)) return sc;

    while (1) 
    {
        IWbemClassObject* pInstruction;
        sc = pEnum->Next( WBEM_INFINITE, 1, &pInstruction, &uRet);
        if(FAILED(sc)) return sc;
        if(sc != WBEM_S_NO_ERROR)
            break;

        // Get the next firing object
        // ==========================

        VARIANT vID;
        VariantInit(&vID);
        sc = pInstruction->Get(L"TimerID", 0, &vID, NULL, NULL);
        if(FAILED(sc)) return sc;

        LPWSTR wszPath = _new WCHAR[wcslen(V_BSTR(&vID)) + 100];
        if(wszPath == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        swprintf(wszPath, L"__TimerNextFiring.TimerID=\"%s\"", V_BSTR(&vID));
        VariantClear(&vID);

        IWbemClassObject* pNextFiring = 0;
        if(FAILED(pNamespace->GetObject(wszPath, 0, NULL, &pNextFiring, NULL)))
        {
            pNextFiring = NULL;
        }
        delete [] wszPath;

        LoadTimerEventObject(wszNamespace, pNamespace, pInstruction,
                                pNextFiring);
        
        if(pNextFiring) pNextFiring->Release();
        pInstruction->Release();
    }


    pEnum->Release();
    return WBEM_S_NO_ERROR;
}

HRESULT CWinMgmtTimerGenerator::Remove(LPCWSTR wszNamespace, LPCWSTR wszId)
{
    CIdTest test(wszNamespace, wszId);
    return CTimerGenerator::Remove(&test);
}

BOOL CWinMgmtTimerGenerator::CIdTest::operator()(CTimerInstruction* pInst)
{
    if(pInst->GetInstructionType() != INSTTYPE_WBEM)
        return FALSE;
    CWBEMTimerInstruction* pWbemInst = (CWBEMTimerInstruction*)pInst;

    if(wcscmp(m_wszId, pWbemInst->GetTimerId()))
        return FALSE;

    if(_wcsicmp(m_wszNamespace, pWbemInst->GetNamespace()))
        return FALSE;

    return TRUE;
}

HRESULT CWinMgmtTimerGenerator::Remove(LPCWSTR wszNamespace)
{
    CNamespaceTest test(wszNamespace);
    return CTimerGenerator::Remove(&test);
}

BOOL CWinMgmtTimerGenerator::CNamespaceTest::operator()(
                                                    CTimerInstruction* pInst)
{
    if(pInst->GetInstructionType() != INSTTYPE_WBEM)
        return FALSE;
    CWBEMTimerInstruction* pWbemInst = (CWBEMTimerInstruction*)pInst;

    if(_wcsicmp(m_wszNamespace, pWbemInst->GetNamespace()))
        return FALSE;

    return TRUE;
}

HRESULT CWinMgmtTimerGenerator::FireInstruction(
                            CWBEMTimerInstruction* pInst, long lNumFirings)
{
    HRESULT hres;

    CEventRepresentation Event;
    Event.type = e_EventTypeTimer;
    Event.wsz1 = (LPWSTR)pInst->GetNamespace();
    Event.wsz2 = (LPWSTR)pInst->GetTimerId();
    Event.wsz3 = NULL;
    Event.dw1 = (DWORD)lNumFirings;

    // Create the actual IWbemClassObject representing the event 
    // ========================================================

    Event.nObjects = 1;
    Event.apObjects = _new IWbemClassObject*[1];
    if(Event.apObjects == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<IWbemClassObject*> vdm1(Event.apObjects);

    IWbemClassObject* pClass = // internal
        CEventRepresentation::GetEventClass(m_pEss, e_EventTypeTimer);
    if(pClass == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = pClass->SpawnInstance(0, &(Event.apObjects[0]));
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(Event.apObjects[0]);

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(pInst->GetTimerId());
    if(V_BSTR(&v) == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    hres = Event.apObjects[0]->Put(L"TimerId", 0, &v, 0);
    VariantClear(&v);
    if(FAILED(hres))
        return hres;

    V_VT(&v) = VT_I4;
    V_I4(&v) = lNumFirings;
    hres = Event.apObjects[0]->Put(L"NumFirings", 0, &v, 0);
    VariantClear(&v);
    if(FAILED(hres))
        return hres;

    // Decorate it
    // ===========

    hres = m_pEss->DecorateObject(Event.apObjects[0], pInst->GetNamespace());
    if(FAILED(hres))
        return hres;

    // Give it to the ESS
    // ==================

    hres = m_pEss->ProcessEvent(Event, 0);
    
    // ignore error

    return WBEM_S_NO_ERROR;
}

HRESULT CWinMgmtTimerGenerator::Shutdown()
{
    // Get the base class to shut everything down
    // ==========================================

    HRESULT hres = CTimerGenerator::Shutdown();

    hres = SaveAndRemove((LONG)FALSE);
    return hres;
}

HRESULT CWinMgmtTimerGenerator::SaveAndRemove(LONG lIsSystemShutDown)
{
    // Store next firing times for all the instructions in the list
    // ============================================================

    CTimerInstruction* pInst;
    CWbemTime NextTime;
    while(m_Queue.Dequeue(pInst, NextTime) == S_OK)
    {
        // Convert to the right class
        // ==========================

        if(pInst->GetInstructionType() == INSTTYPE_WBEM)
        {
            CWBEMTimerInstruction* pWbemInst = (CWBEMTimerInstruction*)pInst;
            pWbemInst->StoreNextFiring(NextTime);
        }
        if (!lIsSystemShutDown)
        {
            pInst->Release();
        }
    }

    return S_OK;
}


void CWinMgmtTimerGenerator::DumpStatistics(FILE* f, long lFlags)
{
    fprintf(f, "%d timer instructions in queue\n", 
                m_Queue.GetNumInstructions());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\analyser.cpp ===
//******************************************************************************
//
//  ANALYSER.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include "pragmas.h"
#include "analyser.h"
#include <stack>
#include <strutils.h>
#include <objpath.h>
#include <fastval.h>
#include <genutils.h>
#include <datetimeparser.h>
#include "CWbemTime.h"
#include <wstlallc.h>

CClassInfoArray::CClassInfoArray()
    : m_bLimited( FALSE )
{
    m_pClasses = new CUniquePointerArray<CClassInformation>;

    if ( m_pClasses )
    {
        m_pClasses->RemoveAll();
    }
}

CClassInfoArray::~CClassInfoArray()
{
    delete m_pClasses;
}

bool CClassInfoArray::operator=(CClassInfoArray& Other)
{
    SetLimited(Other.IsLimited());
    m_pClasses->RemoveAll();

    for(int i = 0; i < Other.m_pClasses->GetSize(); i++)
    {
        CClassInformation* pInfo = new CClassInformation(*(*Other.m_pClasses)[i]);
        if(pInfo == NULL)
            return false;

        m_pClasses->Add(pInfo);
    }
    return true;
}

bool CClassInfoArray::SetOne(LPCWSTR wszClass, BOOL bIncludeChildren)
{
    CClassInformation* pNewInfo = _new CClassInformation;
    if(pNewInfo == NULL)
        return false;

    pNewInfo->m_wszClassName = CloneWstr(wszClass);
    if(pNewInfo->m_wszClassName == NULL)
    {
        delete pNewInfo;
        return false;
    }
    pNewInfo->m_bIncludeChildren = bIncludeChildren;

    m_pClasses->RemoveAll();
    m_pClasses->Add(pNewInfo);
    SetLimited(TRUE);
    return true;
}

HRESULT CQueryAnalyser::GetPossibleInstanceClasses(
                                       QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       CClassInfoArray*& paInfos)
{
    // Organize a stack of classinfo arrays
    // ====================================

    std::stack<CClassInfoArray*,std::deque<CClassInfoArray*,wbem_allocator<CClassInfoArray*> > > InfoStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        paInfos = _new CClassInfoArray;
        if(paInfos == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        paInfos->SetLimited(FALSE);
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        CClassInfoArray* paNew = _new CClassInfoArray;
        if(paNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CClassInfoArray* paFirst;
        CClassInfoArray* paSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            hres = GetInstanceClasses(Token, *paNew);
            InfoStack.push(paNew);
            break;

        case QL1_AND:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = AndPossibleClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_OR:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = OrPossibleClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_NOT:
            if(InfoStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();

            hres = NegatePossibleClassArray(paFirst, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete paNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && InfoStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!InfoStack.empty())
        {
            delete InfoStack.top();
            InfoStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    paInfos = InfoStack.top();
    return S_OK;
}

HRESULT CQueryAnalyser::AndPossibleClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // For now, simply pick one
    // ========================

    if(paFirst->IsLimited())
        *paNew = *paFirst;
    else
        *paNew = *paSecond;

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrPossibleClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // Append them together
    // ====================

    paNew->Clear();

    if(paFirst->IsLimited() && paSecond->IsLimited())
    {
        paNew->SetLimited(TRUE);
        for(int i = 0; i < paFirst->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paFirst->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        for(i = 0; i < paSecond->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paSecond->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::NegatePossibleClassArray(IN CClassInfoArray* paOrig,
                                        OUT CClassInfoArray* paNew)
{
    // No information!
    // ===============

    paNew->Clear();

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetDefiniteInstanceClasses(
                                       QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       CClassInfoArray*& paInfos)
{
    // Organize a stack of classinfo arrays
    // ====================================

    std::stack<CClassInfoArray*, std::deque<CClassInfoArray*,wbem_allocator<CClassInfoArray*> > > InfoStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        paInfos = _new CClassInfoArray;
        if(paInfos == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        paInfos->SetLimited(FALSE);
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        CClassInfoArray* paNew = _new CClassInfoArray;
        if(paNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        CClassInfoArray* paFirst;
        CClassInfoArray* paSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            hres = GetInstanceClasses(Token, *paNew);
            InfoStack.push(paNew);
            break;

        case QL1_AND:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = AndDefiniteClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_OR:
            if(InfoStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();
            paSecond = InfoStack.top(); InfoStack.pop();

            hres = OrDefiniteClassArrays(paFirst, paSecond, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            delete paSecond;
            break;

        case QL1_NOT:
            if(InfoStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            paFirst = InfoStack.top(); InfoStack.pop();

            hres = NegateDefiniteClassArray(paFirst, paNew);

            InfoStack.push(paNew);
            delete paFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete paNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && InfoStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!InfoStack.empty())
        {
            delete InfoStack.top();
            InfoStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    paInfos = InfoStack.top();
    return S_OK;
}

HRESULT CQueryAnalyser::AndDefiniteClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // Nothing is definite if both conditions have to hold
    // ===================================================

    paNew->Clear();
    paNew->SetLimited(TRUE);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrDefiniteClassArrays(IN CClassInfoArray* paFirst,
                                      IN CClassInfoArray* paSecond,
                                      OUT CClassInfoArray* paNew)
{
    // Append them together
    // ====================

    paNew->Clear();

    if(paFirst->IsLimited() && paSecond->IsLimited())
    {
        paNew->SetLimited(TRUE);
        for(int i = 0; i < paFirst->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paFirst->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        for(i = 0; i < paSecond->GetNumClasses(); i++)
        {
            CClassInformation* pInfo =
                new CClassInformation(*paSecond->GetClass(i));
            if(pInfo == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            if(!paNew->AddClass(pInfo))
            {
                delete pInfo;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::NegateDefiniteClassArray(IN CClassInfoArray* paOrig,
                                        OUT CClassInfoArray* paNew)
{
    // No information
    // ==============

    paNew->Clear();
    paNew->SetLimited(TRUE);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetInstanceClasses(QL_LEVEL_1_TOKEN& Token,
                                         CClassInfoArray& aInfos)
{
    // Preset aInfos to the "no information" value
    // ===========================================

    aInfos.Clear();

    // See if this token talks about TargetInstance or PreviousInstance
    // ================================================================

    if(Token.PropertyName.GetNumElements() < 1)
        return WBEM_S_NO_ERROR;

    LPCWSTR wszPrimaryName = Token.PropertyName.GetStringAt(0);
    if(wszPrimaryName == NULL ||
        (_wcsicmp(wszPrimaryName, TARGET_INSTANCE_PROPNAME) &&
         _wcsicmp(wszPrimaryName, PREVIOUS_INSTANCE_PROPNAME))
      )
    {
        // This token is irrelevant
        // =========================

        return WBEM_S_NO_ERROR;
    }

    // TargetInstance or PreviousInstance is found
    // ===========================================

    if(Token.PropertyName.GetNumElements() == 1)
    {
        // It's "TargetInstance <op> <const>" : look for ISA
        // =================================================

        if(Token.nOperator == QL1_OPERATOR_ISA &&
            V_VT(&Token.vConstValue) == VT_BSTR)
        {
            // Of this class; children included
            // ================================

            if(!aInfos.SetOne(V_BSTR(&Token.vConstValue), TRUE))
                return WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            // No information
            // ==============
        }

        return WBEM_S_NO_ERROR;
    }

    if(Token.PropertyName.GetNumElements() > 2)
    {
        // X.Y.Z --- too deep to be useful
        // ===============================

        return WBEM_S_NO_ERROR;
    }

    // It's "TargetInstance.X <op> <const>" : look for __CLASS
    // =======================================================

    LPCWSTR wszSecondaryName = Token.PropertyName.GetStringAt(1);
    if(wszSecondaryName == NULL || _wcsicmp(wszSecondaryName, L"__CLASS"))
    {
        // Not __CLASS --- not useful
        // ==========================

        return WBEM_S_NO_ERROR;
    }
    else
    {
        // __CLASS --- check that the operator is =
        // ========================================

        if(Token.nOperator == QL1_OPERATOR_EQUALS &&
            V_VT(&Token.vConstValue) == VT_BSTR)
        {
            // Of this class -- children not included
            // ======================================

            if(!aInfos.SetOne(V_BSTR(&Token.vConstValue), FALSE))
                return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_NO_ERROR;
    }
}

HRESULT CQueryAnalyser::GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutProperty(Token, PropName))
            {
                pNew->AddToken(Token);
            }
            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();
    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName)
{
    CPropertyName& TokenPropName = Token.PropertyName;

    if(PropName.GetNumElements() != TokenPropName.GetNumElements())
        return FALSE;

    for(int i = 0; i < PropName.GetNumElements(); i++)
    {
        LPCWSTR wszPropElement = PropName.GetStringAt(i);
        LPCWSTR wszTokenElement = TokenPropName.GetStringAt(i);

        if(wszPropElement == NULL || wszTokenElement == NULL)
            return FALSE;

        if(_wcsicmp(wszPropElement, wszTokenElement))
            return FALSE;
    }

    return TRUE;
}

void CQueryAnalyser::AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource)
{
    for(int i = 0; i < pSource->nNumTokens; i++)
    {
        pDest->AddToken(pSource->pArrayOfTokens[i]);
    }
}

HRESULT CQueryAnalyser::AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If either one is NULL (false), the result is NULL
    // =================================================

    if(pFirst == NULL || pSecond == NULL)
        return WBEM_S_FALSE;

    // If either one is empty, take the other
    // ======================================

    if(pFirst->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond->nNumTokens == 0)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- and together
    // ===============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_AND;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew)
{
    // If both are NULL (false) so is the result
    // =========================================

    if(pFirst == NULL && pSecond == NULL)
        return WBEM_S_FALSE;

    // If one is NULL (false) return the other
    // =======================================

    if(pFirst == NULL)
    {
        AppendQueryExpression(pNew, pSecond);
        return WBEM_S_NO_ERROR;
    }

    if(pSecond == NULL)
    {
        AppendQueryExpression(pNew, pFirst);
        return WBEM_S_NO_ERROR;
    }

    // If either one is empty, so is the result
    // ========================================

    if(pFirst->nNumTokens == 0 || pSecond->nNumTokens == 0)
    {
        return WBEM_S_NO_ERROR;
    }

    // Both are there --- or together
    // ==============================

    AppendQueryExpression(pNew, pFirst);
    AppendQueryExpression(pNew, pSecond);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_OR;
    pNew->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetPropertiesThatMustDiffer(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       CWStringArray& awsProperties)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    //
    // "Evaluate" the query, looking for
    // PreviousInstance.Prop != TargetInstance.Prop expressions
    //

    awsProperties.Empty();
    std::stack<CWStringArray*, std::deque<CWStringArray*,wbem_allocator<CWStringArray*> > > PropArrayStack;

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        CWStringArray* pNew = NULL;
        CWStringArray* pFirst = NULL;
        CWStringArray* pSecond = NULL;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            //
            // Check if this token conforms to the
            // PreviousInstance.Prop != TargetInstance.Prop format
            //

            if(Token.m_bPropComp &&
                (Token.nOperator == QL1_OPERATOR_NOTEQUALS ||
                 Token.nOperator == QL1_OPERATOR_LESS ||
                 Token.nOperator == QL1_OPERATOR_GREATER) &&
                Token.PropertyName.GetNumElements() == 2 &&
                Token.PropertyName2.GetNumElements() == 2)
            {
                //
                // Make sure that one of them is talking about TargetInstance,
                // and another about PreviousInstance.
                //

                bool bRightForm = false;
                if(!wbem_wcsicmp(Token.PropertyName.GetStringAt(0),
                                L"TargetInstance") &&
                   !wbem_wcsicmp(Token.PropertyName2.GetStringAt(0),
                                L"PreviousInstance"))
                {
                    bRightForm = true;
                }

                if(!wbem_wcsicmp(Token.PropertyName.GetStringAt(0),
                                L"PreviousInstance") &&
                   !wbem_wcsicmp(Token.PropertyName2.GetStringAt(0),
                                L"TargetInstance"))
                {
                    bRightForm = true;
                }

                if(bRightForm)
                {
                    pNew = new CWStringArray;
                    if(pNew == NULL)
                        return WBEM_E_OUT_OF_MEMORY;

                    pNew->Add(Token.PropertyName.GetStringAt(1));
                }
            }

            PropArrayStack.push(pNew);
            break;

        case QL1_AND:
            if(PropArrayStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = PropArrayStack.top(); PropArrayStack.pop();
            pSecond = PropArrayStack.top(); PropArrayStack.pop();

            //
            // If either one of them is non-NULL, take either --- since every
            // array means "no unless one of these properties is different",
            // adding them together is at least as good as having one
            //

            if(pFirst)
            {
                pNew = pFirst;
                delete pSecond;
            }
            else
                pNew = pSecond;

            PropArrayStack.push(pNew);
            break;

        case QL1_OR:
            if(PropArrayStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = PropArrayStack.top(); PropArrayStack.pop();
            pSecond = PropArrayStack.top(); PropArrayStack.pop();

            //
            // Concatenate them --- since every
            // array means "no unless one of these properties is different",
            // oring them together means "no unless one of the properties in
            // either list is different".  If one is NULL, though, then we know
            // nothing
            //

            if(pFirst && pSecond)
            {
                pNew = new CWStringArray;
                if(pNew == NULL)
                    return WBEM_E_OUT_OF_MEMORY;

                CWStringArray::Union(*pFirst, *pSecond, *pNew);
            }

            PropArrayStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(PropArrayStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = PropArrayStack.top(); PropArrayStack.pop();

            // No information

            PropArrayStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if( SUCCEEDED(hres))
    {
        if( PropArrayStack.size() > 0 && PropArrayStack.top() )
            awsProperties = *PropArrayStack.top();
        else
            return WBEM_S_FALSE;
    }

    while(!PropArrayStack.empty())
    {
        delete PropArrayStack.top();
        PropArrayStack.pop();
    }

    return hres;
}

HRESULT CQueryAnalyser::GetLimitingQueryForInstanceClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       OUT DELETE_ME LPWSTR& wszQuery)
{
    HRESULT hres;

    //
    // "Evaluate" the query, looking for keys and other properties that do not
    // change over the life time of an instance (marked as [fixed]).  The idea
    // here is that if an instance creation/deletion/modification subscription
    // is issue and we need to poll, we can only utilize the parts of the WHERE
    // clause that talk about the properties that cannot change during the life
    // of an instance.  Otherwise, we will not be able to tell if an instance
    // changed or was created or deleted (when it walks in or out of our polling
    // results.
    //
    // The way we know that a property is such is if it is marked as [key], or
    // if it is marked as [fixed] --- the designation by the schema creator that
    // the property never changes.
    //

    //
    // Construct an array of all those property names
    //

    _IWmiObject* pClass = NULL;
    hres = Info.m_pClass->QueryInterface(IID__IWmiObject, (void**)&pClass);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;
    CReleaseMe rm1(pClass);


    CWStringArray awsFixed;
    hres = pClass->BeginEnumeration(0);
    if(FAILED(hres))
        return hres;

    BSTR strPropName = NULL;
    while((hres = pClass->Next(0, &strPropName, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strPropName);

        //  
        // Check qualifiers
        //

        DWORD dwSize;
        hres = pClass->GetPropQual(strPropName, L"key", 0, 0, NULL, 
                                    NULL, &dwSize, NULL);
        if(SUCCEEDED(hres) ||  hres == WBEM_E_BUFFER_TOO_SMALL)
        {
            awsFixed.Add(strPropName);
        }
        else if(hres != WBEM_E_NOT_FOUND)
        {
            return hres;
        }

        hres = pClass->GetPropQual(strPropName, L"fixed", 0, 0, NULL, 
                                    NULL, &dwSize, NULL);
        if(SUCCEEDED(hres) ||  hres == WBEM_E_BUFFER_TOO_SMALL)
        {
            awsFixed.Add(strPropName);
        }
        else if(hres != WBEM_E_NOT_FOUND)
        {
            return hres;
        }
    }

    pClass->EndEnumeration();
    if(FAILED(hres))
        return hres;
        
    //
    // Now "evaluate" the query
    // 

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(Token.PropertyName.GetNumElements() > 1 &&
                awsFixed.FindStr(Token.PropertyName.GetStringAt(1),
                           CWStringArray::no_case) != CWStringArray::not_found)
            {
                //
                // This token is about a fixed property --- we can keep it
                //

                QL_LEVEL_1_TOKEN NewToken = Token;
                NewToken.PropertyName.Empty();
                NewToken.PropertyName.AddElement(
                                            Token.PropertyName.GetStringAt(1));
                pNew->AddToken(NewToken);
            }
            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(FAILED(hres))
    {
        //
        // An error occurred. Clear the stack
        //

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    QL_LEVEL_1_RPN_EXPRESSION* pNewExpr = NULL;
    if(ExprStack.size() != 0)
    {
        pNewExpr = ExprStack.top();
    }
    else
    {
        pNewExpr = new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm1(pNewExpr);

    //
    // Figure out the list of property names
    //

    bool bMayLimit;
    if(pExpr->bStar)
    {
        bMayLimit = false;
    }
    else if(wbem_wcsicmp(pExpr->bsClassName, L"__InstanceCreationEvent") &&
           wbem_wcsicmp(pExpr->bsClassName, L"__InstanceDeletionEvent"))
    {
        //
        // Instance modification events are included.  That means we need
        // to get enough properties from the provider to be able to compare
        // instances for changes. Check if this list is smaller than
        // everything
        //

        CWStringArray awsProperties;
        hres = GetPropertiesThatMustDiffer(pExpr, Info, awsProperties);
        if(hres == S_OK)
        {
            //
            // Got our list --- add it to the properties to get
            //

            for(int i = 0; i < awsProperties.Size(); i++)
            {
                CPropertyName NewProp;
                NewProp.AddElement(awsProperties[i]);
                pNewExpr->AddProperty(NewProp);
            }
            bMayLimit = true;
        }
        else
            bMayLimit = false;
    }
    else
    {
        //
        // No * in select and no modification events asked for --- limit
        //

        bMayLimit = true;
    }

    if(bMayLimit)
    {
        //
        // Add RELPATH and DERIVATION, for without them filtering is hard
        //

        CPropertyName NewProp;
        NewProp.AddElement(L"__RELPATH");
        pNewExpr->AddProperty(NewProp);

        NewProp.Empty();
        NewProp.AddElement(L"__DERIVATION");
        pNewExpr->AddProperty(NewProp);

        //
        // Add all the proeperties from the select clause, with
        // TargetInstance and PreviousInstance removed
        //

        for(int i = 0; i < pExpr->nNumberOfProperties; i++)
        {
            CPropertyName& Prop = pExpr->pRequestedPropertyNames[i];
            if(Prop.GetNumElements() > 1)
            {
                //
                // Embedded object property --- add it to the list
                //

                CPropertyName LocalProp;
                LocalProp.AddElement(Prop.GetStringAt(1));
                pNewExpr->AddProperty(LocalProp);
            }
        }

        //
        // Add all the properties from the where clause, on both sides of
        // the comparison
        //

        for(i = 0; i < pExpr->nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
            CPropertyName& Prop = Token.PropertyName;
            if(Prop.GetNumElements() > 1)
            {
                //
                // Embedded object property --- add it to the list
                //

                CPropertyName LocalProp;
                LocalProp.AddElement(Prop.GetStringAt(1));
                pNewExpr->AddProperty(LocalProp);
            }
            if(Token.m_bPropComp)
            {
                CPropertyName& Prop2 = Token.PropertyName2;
                if(Prop2.GetNumElements() > 1)
                {
                    //
                    // Embedded object property --- add it to the list
                    //

                    CPropertyName LocalProp;
                    LocalProp.AddElement(Prop2.GetStringAt(1));
                    pNewExpr->AddProperty(LocalProp);
                }
            }
        }
    }
    else
    {
        //
        // May not limit the set of properties to ask for
        //

        pNewExpr->bStar = TRUE;
    }

    //
    // Set the class name
    //

    pNewExpr->SetClassName(Info.m_wszClassName);

    //
    // Produce the text
    //

    wszQuery = pNewExpr->GetText();
    if(wszQuery == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}

BOOL CQueryAnalyser::CompareRequestedToProvided(
                    CClassInfoArray& aRequestedInstanceClasses,
                    CClassInfoArray& aProvidedInstanceClasses)
{
    if(!aRequestedInstanceClasses.IsLimited() ||
       !aProvidedInstanceClasses.IsLimited())
    {
        // Provided provides all or client wants all --- they intersect.
        // =============================================================

        return TRUE;
    }

    for(int nReqIndex = 0;
        nReqIndex < aRequestedInstanceClasses.GetNumClasses();
        nReqIndex++)
    {
        CClassInformation* pRequestedClass =
            aRequestedInstanceClasses.GetClass(nReqIndex);
        LPWSTR wszRequestedClass = pRequestedClass->m_wszClassName;

        for(int nProvIndex = 0;
            nProvIndex < aProvidedInstanceClasses.GetNumClasses();
            nProvIndex++)
        {
            // Check if this provided class is derived from the requested one
            // ==============================================================

            CClassInformation* pProvClass =
                aProvidedInstanceClasses.GetClass(nProvIndex);

            if(pProvClass->m_pClass != NULL &&
                (pProvClass->m_pClass->InheritsFrom(pRequestedClass->m_wszClassName) == S_OK ||
                 pRequestedClass->m_pClass->InheritsFrom(pProvClass->m_wszClassName) == S_OK)
                )
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

HRESULT CQueryAnalyser::NegateQueryExpression(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            OUT QL_LEVEL_1_RPN_EXPRESSION* pNewExpr)
{
    if(pExpr == NULL)
    {
        // pNewExpr is empty --- true
        return WBEM_S_NO_ERROR;
    }

    if(pExpr->nNumTokens == 0)
    {
        return WBEM_S_FALSE;
    }

    AppendQueryExpression(pNewExpr, pExpr);

    QL_LEVEL_1_TOKEN Token;
    Token.nTokenType = QL1_NOT;
    pNewExpr->AddToken(Token);

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::SimplifyQueryForChild(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            LPCWSTR wszClassName, IWbemClassObject* pClass,
                            CContextMetaData* pMeta,
                            DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- no information
        // ==============================

        pNewExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        return WBEM_S_NO_ERROR;
    }

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;
        int nDisposition;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            nDisposition = SimplifyTokenForChild(Token, wszClassName, pClass,
                                                        pMeta);
            if(nDisposition == e_Keep)
            {
                pNew->AddToken(Token);
            }
            else if(nDisposition == e_True)
            {
            }
            else if(nDisposition == e_False)
            {
                delete pNew;
                pNew = NULL;
            }
            else
            {
                // the whole thing is invalid
                hres = WBEM_E_INVALID_QUERY;
                delete pNew;
                break;
            }

            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);
            if(hres != S_OK)
            {
                delete pNew;
                pNew = NULL;
            }

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);
            if(hres != S_OK)
            {
                delete pNew;
                pNew = NULL;
            }

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }

            pFirst = ExprStack.top();  ExprStack.pop();
            hres = NegateQueryExpression(pFirst, pNew);
            if(hres != S_OK)
            {
                delete pNew;
                pNew = NULL;
            }

            ExprStack.push(pNew);
            delete pFirst;

            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(SUCCEEDED(hres) && ExprStack.size() != 1)
    {
        hres = WBEM_E_CRITICAL_ERROR;
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    // All is good
    // ===========

    pNewExpr = ExprStack.top();

    return S_OK;
}

int CQueryAnalyser::SimplifyTokenForChild(QL_LEVEL_1_TOKEN& Token,
                            LPCWSTR wszClassName, IWbemClassObject* pClass,
                            CContextMetaData* pMeta)
{
    HRESULT hres;

    //
    // Check if the main property exists
    //

    CIMTYPE ct;
    hres = pClass->Get((LPWSTR)Token.PropertyName.GetStringAt(0), 0, NULL,
                        &ct, NULL);
    if(FAILED(hres))
    {
        return e_Invalid;
    }

    //
    // Check if it is complex
    //

    if(Token.PropertyName.GetNumElements() > 1 && ct != CIM_OBJECT)
        return e_Invalid;

    //
    // Check if it's an array
    //
    if(ct & CIM_FLAG_ARRAY)
        return e_Invalid;

    //
    // If a CIM DateTime type, normalize it to have a zero UTC offset. Helps
    // providers to cope.
    //
    if (ct == CIM_DATETIME && Token.m_bPropComp == FALSE && V_VT(&Token.vConstValue) == VT_BSTR)
    {
        BSTR strSource = V_BSTR(&Token.vConstValue);
        if (strSource && wcslen(strSource))
        {
            BSTR strAdjusted = 0;
            BOOL bRes = NormalizeCimDateTime(strSource, &strAdjusted);
            if (bRes)
            {
                SysFreeString(strSource);
                V_BSTR(&Token.vConstValue) = strAdjusted;
            }
        }
    }

    //
    // Check operator validity for this type
    //

    //
    // Ensure that only valid operators are applied to boolean props.
    //

    if(ct == CIM_BOOLEAN && (Token.nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL &&
                             Token.nOperator != QL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
        return e_Invalid;

    //
    // Ensure that only valid operators are applied to reference props.
    //

    if(ct == CIM_REFERENCE && (Token.nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL &&
                             Token.nOperator != QL_LEVEL_1_TOKEN::OP_NOT_EQUAL))
        return e_Invalid;

    if(Token.m_bPropComp)
    {
        //
        // Check if the other property exists
        //

        CIMTYPE ct2;
        hres = pClass->Get((LPWSTR)Token.PropertyName2.GetStringAt(0), 0, NULL,
                            &ct2, NULL);
        if(FAILED(hres))
        {
            return e_Invalid;
        }

        //
        // Check if it is complex
        //

        if(Token.PropertyName2.GetNumElements() > 1 && ct2 != CIM_OBJECT)
            return e_Invalid;

        //
        // Check if it's an array
        //

        if(ct2 & CIM_FLAG_ARRAY)
            return e_Invalid;

        //
        // Nothing else to say about prop-to-ptop
        //

        return e_Keep;
    }

    //
    // Check if the value is NULL
    //

    if(V_VT(&Token.vConstValue) == VT_NULL)
    {
        if(Token.nOperator != QL1_OPERATOR_EQUALS &&
                Token.nOperator != QL1_OPERATOR_NOTEQUALS)
        {
            return e_Invalid;
        }
        else
        {
            return e_Keep;
        }
    }

    if(ct == CIM_OBJECT)
        return e_Keep;

    // For boolean props ensure that only 1 or 0 or (-1, 0xFFFF [VARIANT_TRUE])
    // are used as numeric tests.
    // ========================================================================

    if (ct == CIM_BOOLEAN && V_VT(&Token.vConstValue) == VT_I4)
    {
        int n = V_I4(&Token.vConstValue);
        if (n != 0 && n != 1 && n != -1 && n != 0xFFFF)
            return e_Invalid;
    }


    //
    // If the constant is a real and the target is an integer, then fail the
    // query
    //

    if((V_VT(&Token.vConstValue) == VT_R8 || V_VT(&Token.vConstValue) == VT_R4 ) &&
        (ct == CIM_CHAR16 || ct == CIM_UINT8 || ct == CIM_SINT8 ||
         ct == CIM_UINT16 || ct == CIM_SINT16 || ct == CIM_UINT32 ||
         ct == CIM_SINT32 || ct == CIM_UINT64 || ct == CIM_SINT64))
        return e_Invalid;

    // Convert the constant to the right type
    // ======================================

    if(ct == CIM_CHAR16 && V_VT(&Token.vConstValue) == VT_BSTR)
    {
        BSTR str = V_BSTR(&Token.vConstValue);
        if(wcslen(str) != 1)
            return e_Invalid;

        return e_Keep;
    }

    VARTYPE vt = CType::GetVARTYPE(ct);
    if(ct == CIM_UINT32)
        vt = CIM_STRING;

    if(FAILED(VariantChangeType(&Token.vConstValue, &Token.vConstValue, 0, vt)))
    {
        return e_Invalid;
    }

    // Verify ranges
    // =============

    __int64 i64;
    unsigned __int64 ui64;

    switch(ct)
    {
    case CIM_UINT8:
        break;
    case CIM_SINT8:
        if(V_I2(&Token.vConstValue) < -128 || V_I2(&Token.vConstValue) > 127)
            return e_Invalid;
        break;
    case CIM_UINT16:
        if(V_I4(&Token.vConstValue) < 0 || V_I4(&Token.vConstValue) >= 1<<16)
            return e_Invalid;
        break;
    case CIM_SINT16:
        break;
    case CIM_SINT32:
        break;
    case CIM_UINT32:
        if(!ReadI64(V_BSTR(&Token.vConstValue), i64))
            return e_Invalid;
        if(i64 < 0 || i64 >= (__int64)1 << 32)
            return e_Invalid;
        break;
    case CIM_UINT64:
        if(!ReadUI64(V_BSTR(&Token.vConstValue), ui64))
            return e_Invalid;
        break;
    case CIM_SINT64:
        if(!ReadI64(V_BSTR(&Token.vConstValue), i64))
            return e_Invalid;
        break;
    case CIM_REAL32:
    case CIM_REAL64:
        break;
    case CIM_STRING:
        break;
    case CIM_DATETIME:
        if(!ValidateSQLDateTime(V_BSTR(&Token.vConstValue)))
            return e_Invalid;
    case CIM_REFERENCE:
        break;
    }

    // Check if it is a reference
    // ==========================

    if(ct != CIM_REFERENCE)
        return e_Keep;

    // Reference. Parse the path in the value
    // ======================================

    if(V_VT(&Token.vConstValue) != VT_BSTR)
        return e_Keep;

    CObjectPathParser Parser;
    ParsedObjectPath* pOutput = NULL;
    int nRes = Parser.Parse(V_BSTR(&Token.vConstValue), &pOutput);
    if(nRes != CObjectPathParser::NoError)
        return e_Invalid;

    WString wsPathClassName = pOutput->m_pClass;
    BOOL bInstance = (pOutput->m_bSingletonObj || pOutput->m_dwNumKeys != 0);

    // TBD: analyse the path for validity

    delete pOutput;

    hres = CanPointToClass(pClass, (LPWSTR)Token.PropertyName.GetStringAt(0),
                            wsPathClassName, pMeta);
    if(FAILED(hres))
        return e_Invalid;
    else if(hres == WBEM_S_NO_ERROR)
        return e_Keep;
    else
    {
        // Equality can never be achieved. The token is either always true,
        // or always false, depending on the operator

        if(Token.nOperator == QL1_OPERATOR_EQUALS)
            return e_False;
        else
            return e_True;
    }
}

BOOL CQueryAnalyser::ValidateSQLDateTime(LPCWSTR wszDateTime)
{
#ifndef UNICODE
    char* szBuffer = new char[wcslen(wszDateTime)*4+1];
    if(szBuffer == NULL)
        return FALSE;
    sprintf(szBuffer, "%S", wszDateTime);
    CDateTimeParser dtParser(szBuffer);
    delete [] szBuffer;
#else
    CDateTimeParser dtParser(wszDateTime);
#endif


    if(!dtParser.IsValidDateTime())
        return FALSE;

    WCHAR wszDMTF[26];
    dtParser.FillDMTF(wszDMTF);
    CWbemTime wt;
    if(!wt.SetDMTF(wszDMTF))
        return FALSE;

    return TRUE;
}



HRESULT CQueryAnalyser::CanPointToClass(IWbemClassObject* pRefClass,
                    LPCWSTR wszPropName, LPCWSTR wszTargetClassName,
                    CContextMetaData* pMeta)
{
    // Check if the reference is typed
    // ===============================

    IWbemQualifierSet* pSet;
    if(FAILED(pRefClass->GetPropertyQualifierSet((LPWSTR)wszPropName, &pSet)))
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    VARIANT v;
    HRESULT hres;
    hres = pSet->Get(L"cimtype", 0, &v, NULL);
    pSet->Release();
    if(FAILED(hres) || V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_PROPERTY;

    CClearMe cm(&v);
    if(wbem_wcsicmp(V_BSTR(&v), L"ref") == 0)
        return WBEM_S_NO_ERROR; // can point to anything

    WString wsPropClassName = V_BSTR(&v) + 4;

    // Reference is strongly typed.
    // ============================

    if(!_wcsicmp(wsPropClassName, wszTargetClassName))
        return WBEM_S_NO_ERROR;

    // Retrieve class def
    // ==================

    _IWmiObject* pPropClass = NULL;
    hres = pMeta->GetClass(wsPropClassName, &pPropClass);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1((IWbemClassObject*)pPropClass);

    // Make sure that the class in the reference is related to our cimtype
    // ===================================================================

    if(pPropClass->InheritsFrom((LPWSTR)wszTargetClassName) != S_OK)
    {
        // Get the class in the path to see if it inherits from us
        // =======================================================

        _IWmiObject* pPathClass = NULL;
        hres = pMeta->GetClass(wszTargetClassName, &pPathClass);
        if(FAILED(hres))
            return hres;

        hres = pPathClass->InheritsFrom(wsPropClassName);
        pPathClass->Release();

        if(hres != S_OK)
        {
            return WBEM_S_FALSE;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CQueryAnalyser::GetNecessaryQueryForClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IWbemClassObject* pClass,
                                       CWStringArray& awsOverriden,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr)
{
    pNewExpr = NULL;

    // Class name and selected properties are ignored; we look at tokens only
    // ======================================================================

    std::stack<QL_LEVEL_1_RPN_EXPRESSION*, std::deque<QL_LEVEL_1_RPN_EXPRESSION*,wbem_allocator<QL_LEVEL_1_RPN_EXPRESSION*> > > ExprStack;
    HRESULT hres = WBEM_S_NO_ERROR;

    // "Evaluate" the query
    // ====================

    for(int i = 0; i < pExpr->nNumTokens; i++)
    {
        QL_LEVEL_1_TOKEN& Token = pExpr->pArrayOfTokens[i];
        QL_LEVEL_1_RPN_EXPRESSION* pNew = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        QL_LEVEL_1_RPN_EXPRESSION* pFirst;
        QL_LEVEL_1_RPN_EXPRESSION* pSecond;

        switch(Token.nTokenType)
        {
        case QL1_OP_EXPRESSION:
            if(IsTokenAboutClass(Token, pClass, awsOverriden))
            {
                pNew->AddToken(Token);
            }

            ExprStack.push(pNew);
            break;

        case QL1_AND:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = AndQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_OR:
            if(ExprStack.size() < 2)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();
            pSecond = ExprStack.top(); ExprStack.pop();

            hres = OrQueryExpressions(pFirst, pSecond, pNew);

            ExprStack.push(pNew);
            delete pFirst;
            delete pSecond;
            break;

        case QL1_NOT:
            if(ExprStack.size() < 1)
            {
                hres = WBEM_E_CRITICAL_ERROR;
                break;
            }
            pFirst = ExprStack.top(); ExprStack.pop();

            // No information

            ExprStack.push(pNew);
            delete pFirst;
            break;

        default:
            hres = WBEM_E_CRITICAL_ERROR;
            delete pNew;
        }

        if(FAILED(hres))
        {
            // An error occurred, break out of the loop
            // ========================================

            break;
        }
    }

    if(FAILED(hres))
    {
        // An error occurred. Clear the stack
        // ==================================

        while(!ExprStack.empty())
        {
            delete ExprStack.top();
            ExprStack.pop();
        }

        return hres;
    }

    if(pExpr->nNumTokens == 0)
    {
        // Empty query --- stays empty
        pNewExpr = _new QL_LEVEL_1_RPN_EXPRESSION;
        if(pNewExpr == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    else if(ExprStack.size() != 1)
    {
        // internal error
        return WBEM_E_CRITICAL_ERROR;
    }
    else
    {
        // All is good
        // ===========

        pNewExpr = ExprStack.top();
    }

    //
    // Copy the class name
    //

    VARIANT vName;
    hres = pClass->Get(L"__CLASS", 0, &vName, NULL, NULL);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;

    pNewExpr->bsClassName = V_BSTR(&vName);
    // Variant intentionally not cleared

    //
    // Copy all the properties in the select clause except for irrelevant ones
    //

    pNewExpr->bStar = pExpr->bStar;
    if(!pNewExpr->bStar)
    {
        delete [] pNewExpr->pRequestedPropertyNames;
        pNewExpr->nCurPropSize = pExpr->nCurPropSize+1;
        pNewExpr->pRequestedPropertyNames =
            new CPropertyName[pNewExpr->nCurPropSize];
        if(pNewExpr->pRequestedPropertyNames == NULL)
        {
            delete pNewExpr;
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // Add __RELPATH, as we always need that!
        //

        pNewExpr->pRequestedPropertyNames[0].AddElement(L"__RELPATH");
        pNewExpr->nNumberOfProperties = 1;

        for(int i = 0; i < pExpr->nNumberOfProperties; i++)
        {
            //
            // Check if the property exists in the class
            //

            CIMTYPE ct;
            hres = pClass->Get(pExpr->pRequestedPropertyNames[i].GetStringAt(0),
                                0, NULL, &ct, NULL);
            if(SUCCEEDED(hres))
            {
                //
                // Add it to the list
                //

                pNewExpr->pRequestedPropertyNames[
                        pNewExpr->nNumberOfProperties++] =
                    pExpr->pRequestedPropertyNames[i];
            }
        }
    }

    return S_OK;
}

BOOL CQueryAnalyser::IsTokenAboutClass(QL_LEVEL_1_TOKEN& Token,
                        IWbemClassObject* pClass,
                        CWStringArray& awsOverriden)
{
    //
    // Check if the property being compared is in our class
    // and not overriden
    //

    if(!IsPropertyInClass(Token.PropertyName, pClass, awsOverriden))
        return FALSE;

    //
    // If comparing to another property, check if that one is
    // likewise good
    //

    if(Token.m_bPropComp &&
            !IsPropertyInClass(Token.PropertyName2, pClass, awsOverriden))
        return FALSE;

    return TRUE;
}

BOOL CQueryAnalyser::IsPropertyInClass(CPropertyName& Prop,
                        IWbemClassObject* pClass,
                        CWStringArray& awsOverriden)
{
    //
    // Check if the property exists in the class
    //

    CIMTYPE ct;
    HRESULT hres = pClass->Get(Prop.GetStringAt(0), 0, NULL, &ct, NULL);
    if(FAILED(hres))
        return FALSE;

    //
    // Check if the property is overriden by any of our children
    //

    if(awsOverriden.FindStr(Prop.GetStringAt(0), CWStringArray::no_case) >= 0)
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tkncache.cpp ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <tkncache.h>
#include <groupsforuser.h>
#include <selfinst.h>

#include <tchar.h>

CWmiToken::CWmiToken(ADDREF CTokenCache* pCache, const PSID pSid, 
                        ACQUIRE HANDLE hToken) :
    CUnkBase<IWbemToken, &IID_IWbemToken>(NULL), m_hToken(hToken), 
    m_pCache(pCache), m_pSid(NULL), m_bOwnHandle(true)
{
    if(m_pCache)
        m_pCache->AddRef();
    if(pSid)
    {
        m_pSid = (PSID)new BYTE[GetLengthSid(pSid)];
        if(m_pSid == NULL)
            return;
        CopySid(GetLengthSid(pSid), m_pSid, pSid);
    }
}

CWmiToken::CWmiToken(READ_ONLY HANDLE hToken) :
    CUnkBase<IWbemToken, &IID_IWbemToken>(NULL), m_hToken(hToken), 
    m_pCache(NULL), m_pSid(NULL), m_bOwnHandle(false)
{
}

CWmiToken::~CWmiToken()
{
    if(m_pCache)
        m_pCache->Release();
    if(m_bOwnHandle)
        CloseHandle(m_hToken);
    delete [] (BYTE*)m_pSid;
}    

STDMETHODIMP CWmiToken::AccessCheck(DWORD dwDesiredAccess, const BYTE* pSD,
                                            DWORD* pdwGrantedAccess)
{
    if(m_hToken == NULL)
        return WBEM_E_CRITICAL_ERROR;

    // BUGBUG: figure out what this is for!
    GENERIC_MAPPING map;
    map.GenericRead = 1;
    map.GenericWrite = 0x1C;
    map.GenericExecute = 2;
    map.GenericAll = 0x6001f;
    PRIVILEGE_SET ps;
    DWORD dwPrivLength = sizeof(ps);

    BOOL bStatus;
    BOOL bRes = ::AccessCheck((SECURITY_DESCRIPTOR*)pSD, m_hToken, 
                                dwDesiredAccess, &map, &ps, 
                                &dwPrivLength, pdwGrantedAccess, &bStatus);
    if(!bRes)
    {
        return WBEM_E_ACCESS_DENIED;
    }
    else
    {
        return WBEM_S_NO_ERROR;
    }
}

#ifdef __NOAUTHZ_

typedef NTSTATUS (NTAPI *PNtCreateToken)(
    OUT PHANDLE TokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
    IN TOKEN_TYPE TokenType,
    IN PLUID AuthenticationId,
    IN PLARGE_INTEGER ExpirationTime,
    IN PTOKEN_USER User,
    IN PTOKEN_GROUPS Groups,
    IN PTOKEN_PRIVILEGES Privileges,
    IN PTOKEN_OWNER Owner OPTIONAL,
    IN PTOKEN_PRIMARY_GROUP PrimaryGroup,
    IN PTOKEN_DEFAULT_DACL DefaultDacl OPTIONAL,
    IN PTOKEN_SOURCE TokenSource
    );

void EnableAllPrivileges()
{
    BOOL bRes;
    HANDLE hToken = NULL;

    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, FALSE, &hToken);

    // Get the privileges
    // ==================

    DWORD dwLen;
    TOKEN_USER tu;
    memset(&tu,0,sizeof(TOKEN_USER));
    bRes = GetTokenInformation(hToken, TokenPrivileges, &tu, sizeof(TOKEN_USER), &dwLen);

    BYTE* pBuffer = new BYTE[dwLen];
    if(pBuffer == NULL)
    {
        CloseHandle(hToken);
        return ;
    }

    bRes = GetTokenInformation(hToken, TokenPrivileges, pBuffer, dwLen,
                                &dwLen);
    if(!bRes)
    {
        CloseHandle(hToken);
        delete [] pBuffer;
        return ;
    }

    // Iterate through all the privileges and enable them all
    // ======================================================

    TOKEN_PRIVILEGES* pPrivs = (TOKEN_PRIVILEGES*)pBuffer;
    for(DWORD i = 0; i < pPrivs->PrivilegeCount; i++)
    {
        pPrivs->Privileges[i].Attributes |= SE_PRIVILEGE_ENABLED;
        TCHAR szBuffer[256];
        DWORD dwLen = 256;
        LookupPrivilegeName(NULL, &pPrivs->Privileges[i].Luid, szBuffer, &dwLen);
    }

    // Store the information back into the token
    // =========================================

    bRes = AdjustTokenPrivileges(hToken, FALSE, pPrivs, 0, NULL, NULL);
    delete [] pBuffer;
    CloseHandle(hToken);
}

BOOL CTokenCache::ConstructTokenFromHandle(HANDLE hToken, const BYTE* pSid,
                                                IWbemToken** ppToken)
{
    BOOL bRes;

    //
    // Retrieve the user sid from the token given to us
    //

    DWORD dwSidLen = 0;
    bRes = GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSidLen);
    if(dwSidLen == 0)
        return FALSE;

    TOKEN_USER* pUser = (TOKEN_USER*)new BYTE[dwSidLen];
    if(pUser == NULL)
        return FALSE;
    CVectorDeleteMe<BYTE> vdm1((BYTE*)pUser);

    bRes = GetTokenInformation(hToken, TokenUser, pUser, dwSidLen, &dwSidLen);
    if(!bRes)
        return FALSE;

    //
    // Compare to the required SID --- must match for success
    //

    if(!EqualSid((PSID)pSid, pUser->User.Sid))
        return FALSE;

    // 
    // Construct an IWbemToken object to return.  
    //

    CWmiToken* pNewToken = new CWmiToken(this, (const PSID)pSid, hToken);
    if(pNewToken == NULL)
        return FALSE;

    pNewToken->QueryInterface(IID_IWbemToken, (void**)ppToken);
    return TRUE;
}
    
    
        
    
    
HRESULT STDMETHODCALLTYPE CTokenCache::GetToken(const BYTE* pSid, 
                                                IWbemToken** ppToken)
{
    //
    // Search for the SID in the array
    //

    {
        CInCritSec ics(&m_cs);

        DWORD dwLen = GetLengthSid((const PSID)pSid);
    
        for(int i = 0; i < m_apTokens.GetSize(); i++)
        {
            CWmiToken* pToken = m_apTokens[i];
            if(EqualSid(pToken->m_pSid, (const PSID)pSid))
            {
                // Found it!
                *ppToken = pToken;
                pToken->AddRef();
                return S_OK;
            }
        }
    }
    
    //
    // Not there.  Examine the currently available tokens to see if they match.
    // Note that we are not going to cache them if found --- we do not want to
    // hold on to normally available tokens after the user logs off.
    //

    BOOL bRes;
    HRESULT hres;

    // Thread token first

    HANDLE hThreadToken = NULL;
    bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, 
                            &hThreadToken);
    if(bRes)
    {
        CCloseMe cm(hThreadToken);
        if(ConstructTokenFromHandle(hThreadToken, pSid, ppToken))
            return WBEM_S_NO_ERROR;
    }

    // Process token next

    RevertToSelf();

    HANDLE hProcessToken = NULL;
    bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken);
    if(bRes)
    {
        CCloseMe cm(hProcessToken);
        if(ConstructTokenFromHandle(hProcessToken, pSid, ppToken))
            return WBEM_S_NO_ERROR;
    }

    // COM impersonation last

    hres = CoImpersonateClient();
    if(SUCCEEDED(hres))
    {
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, 
                                &hThreadToken);
        CoRevertToSelf();
        if(bRes)
        {
            CCloseMe cm(hThreadToken);
            if(ConstructTokenFromHandle(hThreadToken, pSid, ppToken))
                return WBEM_S_NO_ERROR;
        }
    }
        
    // 
    // 
    // No standard token matched --- we are going to have to construct our own 
    // token. Get the DC to enumerate all the SIDs for this user
    //

    PSID* aGroupSids = NULL;
    DWORD dwSidCount = 0;

    try
    {
    NTSTATUS ntst = EnumGroupsForUser((const PSID)pSid, NULL, &aGroupSids, 
                                        &dwSidCount);
    if(ntst != STATUS_SUCCESS)
    {
        WMI_REPORT((WMI_CANNOT_GET_USER_GROUPS, pSid));
    
        // 
        // Continue --- even though we don't have all the groups, we might be
        // able to get there
        //
    }

    //
    // Get the NtCreateToken entry point in NTDLL
    //

    ImpersonateSelf(SecurityImpersonation);

    EnableAllPrivileges();
    HINSTANCE hInst = LoadLibrary(_TEXT("ntdll.dll"));
    PNtCreateToken pNtCreateToken = (PNtCreateToken)GetProcAddress(hInst, "NtCreateToken");
    FreeLibrary(hInst);

    //
    // Prepare the paramters for NtCreateToken
    //

    HANDLE hHandle;
    LUID luidAuth = SYSTEM_LUID;
    LARGE_INTEGER exp;
    exp.QuadPart = 0;

    TOKEN_USER User;    
    User.User.Sid = (const PSID)pSid;
    User.User.Attributes = 0;

    //  
    // Allocate a TOKEN_GROUPS large enough for all the SIDs
    //

    TOKEN_GROUPS* pGroups = (TOKEN_GROUPS*)
        new BYTE[sizeof(TOKEN_GROUPS) + dwSidCount* sizeof(SID_AND_ATTRIBUTES)];
    if(pGroups == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CVectorDeleteMe<BYTE> vdm((BYTE*)pGroups);

    pGroups->GroupCount = dwSidCount;
    for(DWORD i = 0; i < dwSidCount; i++)
    {
        pGroups->Groups[i].Sid = aGroupSids[i];
        pGroups->Groups[i].Attributes = 0;
    }

    TOKEN_PRIVILEGES Privs;
    Privs.PrivilegeCount = 0;

    TOKEN_PRIMARY_GROUP Prim;
    if(dwSidCount > 0)
        Prim.PrimaryGroup = aGroupSids[0];
    else
        Prim.PrimaryGroup = (const PSID)pSid;

    TOKEN_SOURCE Source;
    strcpy(Source.SourceName, "me");
    Source.SourceIdentifier.HighPart = 0;
    Source.SourceIdentifier.LowPart = 0;

    NTSTATUS st = (*pNtCreateToken)(
        &hHandle, 
        TOKEN_ALL_ACCESS,
        NULL, // attr
        TokenPrimary,
        &luidAuth,
        &exp, 
        &User, 
        pGroups,
        &Privs,
        NULL, // owner
        &Prim,
        NULL, // dacl
        &Source);

    if(st != STATUS_SUCCESS)
    {
        WMI_REPORT((WMI_CANNOT_CREATE_TOKEN, pSid, st));
        return WBEM_E_FAILED;
    }

    //
    // Construct a new CWmiToken object and add it to the list
    //

    {
        CInCritSec ics(&m_cs);

        CWmiToken* pNewToken = new CWmiToken(this, (const PSID) pSid, hHandle);
        if(pNewToken == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        m_apTokens.Add(pNewToken);

        return pNewToken->QueryInterface(IID_IWbemToken, (void**)ppToken);
    }
    }
    catch(...)
    {
        RevertToSelf();
        if(aGroupSids)
        {
            for(DWORD i = 0; i < dwSidCount; i++)
                delete [] aGroupSids[i];
            delete [] aGroupSids;
        }
        throw;
    }
}

HRESULT STDMETHODCALLTYPE CTokenCache::Shutdown()
{
    m_apTokens.RemoveAll();
    return WBEM_S_NO_ERROR;
}
  
#endif // __NOAUTHZ_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tempfilt.h ===
//******************************************************************************
//
//  TEMPFILT.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WMI_ESS_TEMP_FILTER__H_
#define __WMI_ESS_TEMP_FILTER__H_

#include "binding.h"
#include "filter.h"

class CTempFilter : public CGenericFilter
{
    LPWSTR m_wszQuery;
    LPWSTR m_wszQueryLanguage;
    IWbemCallSecurity* m_pSecurity;
    bool m_bInternal;

public:
    CTempFilter(CEssNamespace* pNamespace);
    HRESULT Initialize( LPCWSTR wszQueryLanguage, 
                        LPCWSTR wszQuery, 
                        long lFlags,
                        PSID pOwnerSid,
                        bool bInternal,
                        IWbemContext* pContext, 
                        IWbemObjectSink* pSink );
    ~CTempFilter();

    virtual bool IsInternal() { return m_bInternal; }

    virtual HRESULT GetCoveringQuery(DELETE_ME LPWSTR& wszQueryLanguage, 
                DELETE_ME LPWSTR& wszQuery, BOOL& bExact,
                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION** ppExp);
    BOOL IsPermanent() { return m_pOwnerSid != NULL; }
    virtual DWORD GetForceFlags() {return WBEM_FLAG_STRONG_VALIDATION;}
    virtual HRESULT SetThreadSecurity();
    HRESULT ObtainToken(IWbemToken** ppToken);
    DELETE_ME LPWSTR ComputeThisKey();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\tkncache.h ===
//******************************************************************************
//
//  Copyright (c) 1999-2000, Microsoft Corporation, All rights reserved
//
//*****************************************************************************

#ifndef __WBEM_TOKEN_CACHE__H_
#define __WBEM_TOKEN_CACHE__H_

#include <wbemcomn.h>
#include <wbemint.h>
#include <sync.h>

class CWmiToken;
class CTokenCache : public CUnkBase<IWbemTokenCache, &IID_IWbemTokenCache>
{
protected:
    CCritSec m_cs;
    CRefedPointerArray<CWmiToken> m_apTokens;

protected:
    BOOL ConstructTokenFromHandle(HANDLE hToken, const BYTE* pSid,
                                                IWbemToken** ppToken);

public:
    CTokenCache(CLifeControl* pControl) : 
        CUnkBase<IWbemTokenCache, &IID_IWbemTokenCache>(pControl){}
    HRESULT STDMETHODCALLTYPE GetToken(const BYTE* pSid, IWbemToken** ppToken);
    HRESULT STDMETHODCALLTYPE Shutdown();
};

class CWmiToken : public CUnkBase<IWbemToken, &IID_IWbemToken>
{
protected:
    HANDLE m_hToken;
    CTokenCache* m_pCache;
    PSID m_pSid;
    bool m_bOwnHandle;

    friend CTokenCache;

public:
    CWmiToken(ADDREF CTokenCache* pCache, const PSID pSid, 
                ACQUIRE HANDLE hToken);
    CWmiToken(READ_ONLY HANDLE hToken);
    virtual ~CWmiToken();

    HRESULT STDMETHODCALLTYPE AccessCheck(DWORD dwDesiredAccess, 
                                            const BYTE* pSD, 
                                            DWORD* pdwGrantedAccess);
        
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\analyser.h ===
//******************************************************************************
//
//  ANALYSER.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_ANALYSER__H_
#define __WBEM_ANALYSER__H_

#include "esscpol.h"
#include <stdio.h>
#include "wbemidl.h"
#include "wbemcomn.h"
#include "parmdefs.h"
#include "ql.h"
#include "eventrep.h"
#include "evaltree.h"

struct ESSCLI_POLARITY CClassInformation
{
    IWbemClassObject* m_pClass;
    LPWSTR m_wszClassName;
    BOOL m_bIncludeChildren;
    DWORD m_dwEventMask;
public:
    CClassInformation()
    {
        m_wszClassName = NULL;
        m_pClass = NULL;
    }
    CClassInformation(const CClassInformation& Other)
    {
        m_wszClassName = CloneWstr(Other.m_wszClassName);
        if (!m_wszClassName)
        	throw CX_MemoryException();
        m_pClass = Other.m_pClass;
        if(m_pClass) m_pClass->AddRef();        
        m_bIncludeChildren = Other.m_bIncludeChildren;
        m_dwEventMask = Other.m_dwEventMask;
    }

    ~CClassInformation()
    {
        delete [] m_wszClassName;
        if(m_pClass) m_pClass->Release();
    }
};

class ESSCLI_POLARITY CClassInfoArray
{
protected:
    BOOL m_bLimited;
    CUniquePointerArray<CClassInformation>* m_pClasses;

public:
    CClassInfoArray();
    ~CClassInfoArray(); 
    BOOL IsLimited() {return m_bLimited;}
    int GetNumClasses() {return m_pClasses->GetSize();}
    INTERNAL CClassInformation* GetClass(int nIndex) 
     {return (*m_pClasses)[nIndex]; }

    void SetLimited(BOOL bLimited) {m_bLimited = bLimited;}
    bool operator=(CClassInfoArray& Other);
    bool SetOne(LPCWSTR wszClass, BOOL bIncludeChildren);
    void Clear() {m_bLimited = FALSE; m_pClasses->RemoveAll();}
    bool AddClass(ACQUIRE CClassInformation* pInfo) 
        {return m_pClasses->Add(pInfo) >= 0;}
    void RemoveClass(int nIndex) {m_pClasses->RemoveAt(nIndex);}
};

class ESSCLI_POLARITY CQueryAnalyser
{
public:
    static HRESULT GetPossibleInstanceClasses(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                              CClassInfoArray*& paInfos);
    static HRESULT GetDefiniteInstanceClasses(QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                              CClassInfoArray*& paInfos);
    static HRESULT GetLimitingQueryForInstanceClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       OUT LPWSTR& wszQuery);
    static HRESULT GetNecessaryQueryForProperty(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CPropertyName& PropName,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
    static HRESULT GetNecessaryQueryForClass(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IWbemClassObject* pClass,
                                       CWStringArray& awsOverriden,
                                DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
    static BOOL CompareRequestedToProvided(
                    CClassInfoArray& aRequestedInstanceClasses,
                    CClassInfoArray& aProvidedInstanceClasses);

    static HRESULT SimplifyQueryForChild(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            LPCWSTR wszClassName, IWbemClassObject* pClass,
                            CContextMetaData* pMeta,
                            DELETE_ME QL_LEVEL_1_RPN_EXPRESSION*& pNewExpr);
    static HRESULT CanPointToClass(IWbemClassObject* pRefClass, 
                    LPCWSTR wszPropName, LPCWSTR wszTargetClassName,
                    CContextMetaData* pMeta);
protected:
    enum 
    {
        e_Keep, e_True, e_False, e_Invalid
    };
    static HRESULT GetInstanceClasses(QL_LEVEL_1_TOKEN& Token, 
                                              CClassInfoArray& aInfos);
    static HRESULT AndPossibleClassArrays(IN CClassInfoArray* paFirst, 
                                 IN CClassInfoArray* paSecond, 
                                 OUT CClassInfoArray* paNew);
    static HRESULT OrPossibleClassArrays(IN CClassInfoArray* paFirst, 
                                IN CClassInfoArray* paSecond, 
                                OUT CClassInfoArray* paNew);
    static HRESULT NegatePossibleClassArray(IN CClassInfoArray* paOrig, 
                                   OUT CClassInfoArray* paNew);
    static HRESULT AndDefiniteClassArrays(IN CClassInfoArray* paFirst, 
                                 IN CClassInfoArray* paSecond, 
                                 OUT CClassInfoArray* paNew);
    static HRESULT OrDefiniteClassArrays(IN CClassInfoArray* paFirst, 
                                IN CClassInfoArray* paSecond, 
                                OUT CClassInfoArray* paNew);
    static HRESULT NegateDefiniteClassArray(IN CClassInfoArray* paOrig, 
                                   OUT CClassInfoArray* paNew);
    static BOOL IsTokenAboutProperty(
                                       IN QL_LEVEL_1_TOKEN& Token,
                                       IN CPropertyName& PropName);
    static void AppendQueryExpression(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pDest,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSource);
    static HRESULT AndQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT OrQueryExpressions(
                                IN QL_LEVEL_1_RPN_EXPRESSION* pFirst,
                                IN QL_LEVEL_1_RPN_EXPRESSION* pSecond,
                                OUT QL_LEVEL_1_RPN_EXPRESSION* pNew);
    static HRESULT NegateQueryExpression(
                            IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                            OUT QL_LEVEL_1_RPN_EXPRESSION* pNewExpr);
    static int SimplifyTokenForChild(QL_LEVEL_1_TOKEN& Token, 
                            LPCWSTR wszClass, IWbemClassObject* pClass, 
                            CContextMetaData* pMeta);
    static BOOL ValidateSQLDateTime(LPCWSTR wszDateTime);
    static HRESULT GetPropertiesThatMustDiffer(
                                       IN QL_LEVEL_1_RPN_EXPRESSION* pExpr,
                                       IN CClassInformation& Info,
                                       CWStringArray& wsProperties);
    static BOOL IsTokenAboutClass(QL_LEVEL_1_TOKEN& Token,
                        IWbemClassObject* pClass,
                        CWStringArray& awsOverriden);
    static BOOL IsPropertyInClass(CPropertyName& Prop,
                        IWbemClassObject* pClass, 
                        CWStringArray& awsOverriden);
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\dumbnode.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DUMBNODE.CPP

Abstract:

    WBEM Dumb Node

History:

--*/

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "dumbnode.h"
#include "CWbemTime.h"
#include "datetimeparser.h"

#define DUMBNODE_FALSE_BRANCH_INDEX 0
#define DUMBNODE_TRUE_BRANCH_INDEX 1


CDumbNode::CDumbNode(QL_LEVEL_1_TOKEN& Token) 
    : m_Token(Token)
{
    //
    // Add the branches for TRUE and FALSE
    //

    if(m_apBranches.Add(CValueNode::GetStandardFalse()) < 0)
        throw CX_MemoryException();

    CEvalNode* pNode = CValueNode::GetStandardTrue();
    if(pNode == NULL)
        throw CX_MemoryException();

    if(m_apBranches.Add( pNode ) < 0)
    {
        delete pNode;
        throw CX_MemoryException();
    }
}

HRESULT CDumbNode::Validate(IWbemClassObject* pClass)
{
    HRESULT hres;

    //
    // Check if the property is even in the class
    //

    CIMTYPE ct;
    hres = pClass->Get(m_Token.PropertyName.GetStringAt(0), 0, NULL, &ct, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_PROPERTY;

    if(m_Token.m_bPropComp)
    {
        hres = pClass->Get(m_Token.PropertyName2.GetStringAt(0), 0, NULL, &ct, 
                            NULL);
        if(FAILED(hres))
            return WBEM_E_INVALID_PROPERTY;
    }

    if(ct == CIM_REFERENCE)
    {
        // 
        // Make sure that the operator is = or <>
        //
        
        if(m_Token.nOperator != QL_LEVEL_1_TOKEN::OP_EQUAL &&
           m_Token.nOperator != QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
        {
            return WBEM_E_INVALID_OPERATOR;
        }
    
        // 
        // Make sure the path is parsable
        //

        if(!m_Token.m_bPropComp)
        {
            if(V_VT(&m_Token.vConstValue) != VT_BSTR)
            {
                if(V_VT(&m_Token.vConstValue) != VT_NULL)
                    return WBEM_E_TYPE_MISMATCH;
            }
            else
            {
                LPWSTR wszNormal = NormalizePath(V_BSTR(&m_Token.vConstValue));
                if(wszNormal == NULL)
                    return WBEM_E_INVALID_OBJECT_PATH;
                else
                    delete [] wszNormal;
            }
        }
    }
    else if(ct == CIM_DATETIME)
    {
        //
        // If comparing to a constant, make sure the constant is a date
        //

        if(!m_Token.m_bPropComp)
        {
            if(V_VT(&m_Token.vConstValue) != VT_BSTR)
            {
                if(V_VT(&m_Token.vConstValue) != VT_NULL)
                    return WBEM_E_TYPE_MISMATCH;
            }
            else
            {
                BSTR strConstVal = V_BSTR(&m_Token.vConstValue);
#ifdef UNICODE
                CDateTimeParser dtConst(strConstVal);
#else
                char* szBuffer = new char[wcslen(strConstVal) * 4 + 1];
                if(szBuffer == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
                sprintf(szBuffer, "%S", strConstVal);
        
                CDateTimeParser dtConst(szBuffer);

                delete [] szBuffer;
#endif
        
                if(!dtConst.IsValidDateTime())
                    return WBEM_E_VALUE_OUT_OF_RANGE;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

CDumbNode::CDumbNode(const CDumbNode& Other, BOOL bChildren)
    : CBranchingNode(Other, bChildren), m_Token(Other.m_Token)
{
}

/* virtual */ long CDumbNode::GetSubType()
{
    return EVAL_NODE_TYPE_DUMB;
}

CDumbNode::~CDumbNode()
{
}

int CDumbNode::ComparePrecedence(CBranchingNode* pOther)
{
    //
    // Dumb nodes can only be merged if they are identical.  So, there 
    // precedence (level) is the same as theie comparison order
    //

    return SubCompare(pOther);
}

int CDumbNode::SubCompare(CEvalNode* pOther)
{
    CDumbNode* pDumbOther = (CDumbNode*)pOther;
    
    //
    // The easiest way to compare two tokens is to compare their textual
    // representations.  Optimizations paths for the future abound.
    //

    LPWSTR wszThisText = m_Token.GetText();
    CVectorDeleteMe<WCHAR> vdm1(wszThisText);

    LPWSTR wszOtherText = pDumbOther->m_Token.GetText();
    CVectorDeleteMe<WCHAR> vdm2(wszOtherText);

    return wbem_wcsicmp(wszThisText, wszOtherText);
}
    
HRESULT CDumbNode::OptimizeSelf()
{
    //
    // Nothing to optimize for now.  Optimizations abound.
    //

    return WBEM_S_NO_ERROR;
}

#define INVALID 2

int CDumbNode::EvaluateToken(
    IWbemPropertySource *pTestObj,
    QL_LEVEL_1_TOKEN& Tok
    )
{
    VARIANT PropVal, CompVal;
    VariantInit(&PropVal);
    VariantInit(&CompVal);
    CClearMe clv(&PropVal);
    CClearMe clv2(&CompVal);

    WBEM_WSTR wszCimType, wszCimType2;
    HRESULT hRes;

    // Special-case 'this'
    // ===================

    if(Tok.PropertyName.GetNumElements() == 1 &&
        !wbem_wcsicmp(Tok.PropertyName.GetStringAt(0), L"__THIS"))
    {
        wszCimType = WbemStringCopy(L"object");
        V_VT(&PropVal) = VT_UNKNOWN;
        hRes = pTestObj->QueryInterface(IID_IWbemClassObject,
                                            (void**)&V_UNKNOWN(&PropVal));
    }
    else
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName, 0,
                                                &wszCimType, &PropVal);
    }
    if (FAILED(hRes))
        return FALSE;
    CMemFreeMe wsf(wszCimType);

    // Handle a property-to-property comparison,

    if (Tok.m_bPropComp != FALSE)
    {
        hRes = pTestObj->GetPropertyValue(&Tok.PropertyName2, 0,
                                                &wszCimType2, &CompVal);
        if (FAILED(hRes))
            return FALSE;
    }
    else
    {
        if(FAILED(VariantCopy(&CompVal, &Tok.vConstValue)))
            return INVALID;
    }

    // Handle NULLs
    // ============

    if(V_VT(&PropVal) == VT_NULL)
    {
        if(V_VT(&CompVal) == VT_NULL)
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL ||
               Tok.nOperator == QL_LEVEL_1_TOKEN::OP_LIKE )
                return TRUE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL ||
                    Tok.nOperator == QL_LEVEL_1_TOKEN::OP_UNLIKE )
                return FALSE;
            else
                return INVALID;
        }
        else
        {
            if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL || 
               Tok.nOperator == QL_LEVEL_1_TOKEN::OP_LIKE )
                return FALSE;
            else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL || 
                    Tok.nOperator == QL_LEVEL_1_TOKEN::OP_UNLIKE )
                return TRUE;
            else
                return INVALID;
        }
    }
    else if(V_VT(&CompVal) == VT_NULL)
    {
        if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL)
            return FALSE;
        else if(Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL)
            return TRUE;
        else
            return INVALID;
    }

    // Handle references
    // =================

    if(wszCimType &&
        _wcsnicmp(wszCimType, L"ref", 3) == 0 &&
        (wszCimType[3] == 0 || wszCimType[3] == L':'))
    {
        // This is a reference. The only operators allowed are = and !=
        // ============================================================

        if(V_VT(&PropVal) != VT_BSTR || V_VT(&CompVal) != VT_BSTR)
            return INVALID;

        LPWSTR va = CDumbNode::NormalizePath(V_BSTR(&PropVal));
        LPWSTR vb = CDumbNode::NormalizePath(V_BSTR(&CompVal));
        if(va == NULL || vb == NULL)
        {
            if(va)
                delete [] va;
            if(vb)
                delete [] vb;
            ERRORTRACE((LOG_ESS, "Invalid path %S or %S specified in an "
                "association\n", V_BSTR(&PropVal), V_BSTR(&CompVal)));
            return INVALID;
        }

        int nRet;
        switch (Tok.nOperator)
        {
        case QL_LEVEL_1_TOKEN::OP_EQUAL:
            nRet = (wbem_wcsicmp(va,vb) == 0);
            break;
        case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
            nRet = (wbem_wcsicmp(va, vb) != 0);
            break;
        default:
            nRet = INVALID;
            break;
        }

        delete [] va;
        delete [] vb;


        return nRet;
    }


    // Check if ISA is used
    // ====================

    if(Tok.nOperator == QL1_OPERATOR_ISA ||
       Tok.nOperator == QL1_OPERATOR_ISNOTA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISA ||
       Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
    {
        // Account for inversion
        // =====================

        VARIANT* pv1;
        VARIANT* pv2;
        int bNeedDerived;

        if(Tok.nOperator == QL1_OPERATOR_ISA ||
           Tok.nOperator == QL1_OPERATOR_ISNOTA)
        {
            pv2 = &CompVal;
            pv1 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_ISA);
        }
        else
        {
            pv1 = &CompVal;
            pv2 = &PropVal;
            bNeedDerived = (Tok.nOperator == QL1_OPERATOR_INV_ISA);
        }

        // The second argument has to be a string
        // ======================================

        if(V_VT(pv2) != VT_BSTR)
        {
            return INVALID;
        }

        BSTR strParentClass = V_BSTR(pv2);

        // The first argument has to be an object or a string
        // ==================================================

        BOOL bDerived;
        if(V_VT(pv1) == VT_EMBEDDED_OBJECT)
        {
            IWbemClassObject* pObj = (IWbemClassObject*)V_EMBEDDED_OBJECT(pv1);
            bDerived = (pObj->InheritsFrom(strParentClass) == WBEM_S_NO_ERROR);
        }
        else if(V_VT(pv1) == VT_BSTR)
        {
            // TBD
            // ===

            return INVALID;
        }
        else
        {
            return INVALID;
        }

        // Now that we have bDerived, see if it matches the requirement
        // ============================================================

        if(bDerived == bNeedDerived)
            return TRUE;
        else
            return FALSE;

    }
    else if ( Tok.nOperator == QL1_OPERATOR_LIKE || 
              Tok.nOperator == QL1_OPERATOR_UNLIKE )
    {
        if ( Tok.m_bPropComp != FALSE ) 
        {
            return INVALID;
        }

        if ( FAILED(VariantChangeType( &PropVal, &PropVal, 0, VT_BSTR )) ||
             V_VT(&CompVal) != VT_BSTR ) 
        {
            return INVALID;
        }

        try 
        {
            CLike Like( V_BSTR(&CompVal) );

            if ( Like.Match( V_BSTR(&PropVal) ) )
            {
                return Tok.nOperator == QL1_OPERATOR_LIKE ? TRUE : FALSE;
            }
            else
            {
                return Tok.nOperator == QL1_OPERATOR_UNLIKE ? TRUE : FALSE;
            }
        }
        catch( CX_MemoryException )
        {
            return INVALID;
        }
    }

    // Perform UINT32 workaround
    // =========================

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"uint32") &&
        V_VT(&PropVal) == VT_I4)
    {
        DWORD dwVal = (DWORD)V_I4(&PropVal);
        WCHAR wszVal[20];
        swprintf(wszVal, L"%lu", dwVal);
        V_VT(&PropVal) = VT_BSTR;
        V_BSTR(&PropVal) = SysAllocString(wszVal);
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"sint64") ||
             !wbem_wcsicmp(wszCimType, L"uint64") ||
             !wbem_wcsicmp(wszCimType, L"uint32")) &&
        V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        BOOL bUnsigned = (wbem_wcsicmp(wszCimType, L"uint64") == 0);

        // We have a 64-bit comparison where both sides are present.
        // =========================================================

        hRes = VariantChangeType(&CompVal, &CompVal, 0,
                                    VT_BSTR);
        if(FAILED(hRes))
        {
            return INVALID;
        }

        if(bUnsigned)
        {
            unsigned __int64 ui64Prop, ui64Const;

            if(!ReadUI64(V_BSTR(&PropVal), ui64Prop))
                return INVALID;

            if(!ReadUI64(V_BSTR(&CompVal), ui64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (ui64Prop == ui64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (ui64Prop != ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (ui64Prop >= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (ui64Prop <= ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (ui64Prop < ui64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (ui64Prop > ui64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (ui64Prop == ui64Const);
            }
            return INVALID;
        }
        else
        {
            __int64 i64Prop, i64Const;

            if(!ReadI64(V_BSTR(&PropVal), i64Prop))
                return INVALID;

            if(!ReadI64(V_BSTR(&CompVal), i64Const))
                return INVALID;

            switch (Tok.nOperator)
            {
                case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
                case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                    return (i64Prop != i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                    return (i64Prop >= i64Const);
                case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                    return (i64Prop <= i64Const);
                case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                    return (i64Prop < i64Const);
                case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                    return (i64Prop > i64Const);
                case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
            }
            return INVALID;
        }
    }

    if(wszCimType && !wbem_wcsicmp(wszCimType, L"char16") &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) != VT_NULL)
    {
        // Coerce strings correctly
        // ========================

        BSTR str = V_BSTR(&CompVal);
        if(wcslen(str) != 1)
            return INVALID;

        short va = V_I2(&PropVal);
        short vb = str[0];

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
        }

        return INVALID;
    }

    if(wszCimType &&
            (!wbem_wcsicmp(wszCimType, L"datetime")) &&
        V_VT(&CompVal) == VT_BSTR && V_VT(&PropVal) == VT_BSTR)
    {
        // Parse the constant specified in the query according to the
        // SQL rules
        // ==========================================================

        BSTR strConstVal = V_BSTR(&CompVal);
#ifdef UNICODE
        CDateTimeParser dtConst(strConstVal);
#else
        char* szBuffer = new char[wcslen(strConstVal) * 4 + 1];
        if(szBuffer == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        sprintf(szBuffer, "%S", strConstVal);

        CDateTimeParser dtConst(szBuffer);
        delete [] szBuffer;
#endif
        if(!dtConst.IsValidDateTime())
            return INVALID;

        WCHAR wszConstValDMTF[26];
        dtConst.FillDMTF(wszConstValDMTF);

        // Read both DMTF values and parse them
        // ====================================

        CWbemTime wtConst, wtProp;
        if(!wtConst.SetDMTF(wszConstValDMTF))
            return INVALID;
        if(!wtProp.SetDMTF(V_BSTR(&PropVal)))
            return INVALID;

        __int64 i64Const = wtConst.Get100nss();
        __int64 i64Prop = wtProp.Get100nss();

        switch (Tok.nOperator)
        {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: return (i64Prop == i64Const);
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                return (i64Prop != i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                return (i64Prop >= i64Const);
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                return (i64Prop <= i64Const);
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                return (i64Prop < i64Const);
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                return (i64Prop > i64Const);
            case QL_LEVEL_1_TOKEN::OP_LIKE: return (i64Prop == i64Const);
        }
    }

    // Coerce types to match.
    // ======================

    if(V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        hRes = VariantChangeType(&CompVal, &CompVal, 0, V_VT(&PropVal));
        if(FAILED(hRes))
        {
            return INVALID;
        }
    }


    switch (V_VT(&CompVal))
    {
        case VT_NULL:
            return INVALID; // handled above

        case VT_I4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LONG va = V_I4(&PropVal);
                LONG vb = V_I4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_I2:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                short va = V_I2(&PropVal);
                short vb = V_I2(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_UI1:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                BYTE va = V_I1(&PropVal);
                BYTE vb = V_I1(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BSTR:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
                LPWSTR vb = (LPWSTR) V_BSTR(&CompVal);

                int retCode = 0;
                BOOL bDidIt = TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL:
                        retCode = ( wbem_wcsicmp(va,vb) == 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                        retCode = (wbem_wcsicmp(va, vb) != 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) >= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) <= 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                        retCode = (wbem_wcsicmp(va, vb) < 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                        retCode = (wbem_wcsicmp(va, vb) > 0);
                        break;
                    case QL_LEVEL_1_TOKEN::OP_LIKE:
                        retCode = (wbem_wcsicmp(va,vb) == 0);
                        break;
                    default:
                        bDidIt = FALSE;
                        break;
                }
                VariantClear(&CompVal);
                if (bDidIt)
                {
                    return retCode;
                }
            }
            break;

        case VT_R8:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                double va = V_R8(&PropVal);
                double vb = V_R8(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_R4:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                float va = V_R4(&PropVal);
                float vb = V_R4(&CompVal);

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return (va >= vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return (va <= vb);
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return (va < vb);
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return (va > vb);
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;

        case VT_BOOL:
            {
                if(V_VT(&PropVal) == VT_NULL)
                    return INVALID;

                VARIANT_BOOL va = V_BOOL(&PropVal);
                if(va != VARIANT_FALSE) va = VARIANT_TRUE;
                VARIANT_BOOL vb = V_BOOL(&CompVal);
                if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

                switch (Tok.nOperator)
                {
                    case QL_LEVEL_1_TOKEN::OP_EQUAL: return (va == vb);
                    case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: return (va != vb);
                    case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LESSTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: return INVALID;
                    case QL_LEVEL_1_TOKEN::OP_LIKE: return (va == vb);
                }
            }
            break;
    }

    return FALSE;
}

LPWSTR CDumbNode::NormalizePath(LPCWSTR wszObjectPath)
{
    CObjectPathParser Parser;
    ParsedObjectPath* pParsedPath;

    if(Parser.Parse((LPWSTR)wszObjectPath, &pParsedPath) !=
                        CObjectPathParser::NoError ||
        !pParsedPath->IsObject())
    {
        return NULL;
    }

    if(pParsedPath->m_pClass == NULL)
    {
        return NULL;
    }

    //
    // Ignore the server and the namespaze
    //

    //
    // Check for it being a class
    //

    LPWSTR wszKey = NULL;
    if(!pParsedPath->IsInstance())
    {
        // 
        // It's a class
        //

        WCHAR* wszBuffer = new WCHAR[wcslen(pParsedPath->m_pClass) +1];
        if(wszBuffer == NULL)
            return NULL;
        wcscpy(wszBuffer,  pParsedPath->m_pClass);
        return wszBuffer;
    }
    else
    {
        //
        // It's an instance
        //
        
        wszKey = pParsedPath->GetKeyString();
        if(wszKey == NULL)
            return NULL;
    
        CVectorDeleteMe<WCHAR> vdm(wszKey);
        WCHAR* wszBuffer = new WCHAR[wcslen(pParsedPath->m_pClass) + 
                                     wcslen(wszKey)+2];
        if(wszBuffer == NULL)
            return NULL;

        swprintf(wszBuffer, L"%s.%s", pParsedPath->m_pClass, wszKey);
        return wszBuffer;
    }
}

HRESULT CDumbNode::Evaluate(CObjectInfo& ObjInfo, 
                                    INTERNAL CEvalNode** ppNext)
{
    _IWmiObject* pInst;
    HRESULT hres = GetContainerObject(ObjInfo, &pInst);
    if(FAILED(hres)) return hres;
    if(pInst == NULL)
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    //
    // Just evaluate the token, ala core.
    //

    IWbemPropertySource* pPropSource = NULL;
    hres = pInst->QueryInterface(IID_IWbemPropertySource, (void**)&pPropSource);
    if(FAILED(hres))
        return WBEM_E_CRITICAL_ERROR;
    CReleaseMe rm1(pPropSource);

    int nRes = EvaluateToken(pPropSource, m_Token);
    if(nRes == INVALID)
        *ppNext = m_pNullBranch;
    else if(nRes == FALSE)
        *ppNext = m_apBranches[DUMBNODE_FALSE_BRANCH_INDEX];
    else
        *ppNext = m_apBranches[DUMBNODE_TRUE_BRANCH_INDEX];
    
    return WBEM_S_NO_ERROR;
}

HRESULT CDumbNode::Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
{
    if (!m_pInfo)
    {
        try
        {
            m_pInfo = new CEmbeddingInfo;
        }
        catch(CX_MemoryException)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(m_pInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
            

    HRESULT hres = CompileEmbeddingPortion(pNamespace, Implications, NULL);
    return hres;
}

HRESULT CDumbNode::CombineBranchesWith(CBranchingNode* pRawArg2, int nOp,
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
                                            bool bDeleteThis, bool bDeleteArg2,
                                            CEvalNode** ppRes)
{
    HRESULT hres;

    // 
    // There is only one case in which combining dumb nodes is allowed ---
    // when both of them are exactly the same
    //

    CDumbNode* pArg2 = (CDumbNode*)pRawArg2;
    if(SubCompare(pArg2) != 0)
        return WBEM_E_CRITICAL_ERROR;

    if(!bDeleteThis && bDeleteArg2)
    {
        // It is easier to combine in the other direction
        // ==============================================

        return pArg2->CombineBranchesWith(this, FlipEvalOp(nOp), pNamespace,
                        OrigImplications, bDeleteArg2, bDeleteThis, ppRes);
    }

    // Either clone or use our node
    // ============================

    CDumbNode* pNew = NULL;
    if(bDeleteThis)
    {
        pNew = this;
    }
    else
    {
        // Clone this node without cloning the branches.
        // =============================================

        pNew = (CDumbNode*)CloneSelf();
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    CImplicationList Implications(OrigImplications);
    pNew->AdjustCompile(pNamespace, Implications);

    // Merge all branches
    // ==================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        // Prepare implications for taking this branch
        // ===========================================

        CImplicationList BranchImplications(Implications);

        CEvalNode* pNewBranch = NULL;
        hres = CEvalTree::Combine(m_apBranches[i], 
                           pArg2->m_apBranches[i],
                           nOp, pNamespace, BranchImplications, 
                           bDeleteThis, bDeleteArg2,
                           &pNewBranch);
        if(FAILED(hres))
            return hres;

        if(bDeleteThis)
        {
            m_apBranches.Discard(i);
            pNew->m_apBranches.SetAt(i, pNewBranch);
        }
        else
        {
            if(pNew->m_apBranches.Add(pNewBranch) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }

        if(bDeleteArg2)
            pArg2->m_apBranches.Discard(i);
    }

    // Merge the nulls
    // ===============
    
    CImplicationList NullImplications(Implications);
    CEvalNode* pNewBranch = NULL;
    hres = CEvalTree::Combine(m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                pNamespace, NullImplications, bDeleteThis, bDeleteArg2, 
                &pNewBranch);
    if(FAILED(hres))
        return hres;

    // Clear the old new branch, whatever it was, and replace it with the 
    // new one.
    // ==================================================================

    pNew->m_pNullBranch = pNewBranch;
        
    // Clear deleted branches
    // ======================

    if(bDeleteArg2)
        pArg2->m_pNullBranch = NULL;

    // Delete Arg2, if needed (reused portions have been nulled out)
    // =============================================================

    if(bDeleteArg2)
        delete pArg2;

    *ppRes = pNew;
    return WBEM_S_NO_ERROR;
}

void CDumbNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);
    LPWSTR wszText = m_Token.GetText();
    CVectorDeleteMe<WCHAR> vdm1(wszText);

    PrintOffset(f, nOffset);
    fprintf(f, "token %S:\n", wszText);

    PrintOffset(f, nOffset);
    fprintf(f, "FALSE->\n");
    DumpNode(f, nOffset+1, m_apBranches[DUMBNODE_FALSE_BRANCH_INDEX]);

    PrintOffset(f, nOffset);
    fprintf(f, "TRUE->\n");
    DumpNode(f, nOffset+1, m_apBranches[DUMBNODE_TRUE_BRANCH_INDEX]);

    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ess3\wbemtss.h ===
//*****************************************************************************
//
//  WBEMTSS.H
//
//  Copyright (c) 1996-1999, Microsoft Corporation, All rights reserved
//
//  This file defines the classes used by the Timer Subsystem. 
//
//  Classes defined:
//
//      RecurrenceInstruction       Complex recurrence information.
//      TimerInstruction            Single instruction for the timer
//      
//      
//
//  26-Nov-96   raymcc      Draft
//  28-Dec-96   a-richm     Alpha PDK Release
//  12-Apr-97   a-levn      Extensive changes
//
//*****************************************************************************


#ifndef _WBEMTSS_H_
#define _WBEMTSS_H_

#include <wbemidl.h>
#include <wbemint.h>
#include <stdio.h>
#include "sync.h"
#include "CWbemTime.h"
#include "parmdefs.h"
#include "tss.h"
#include "wstring.h"


//*****************************************************************************
//
//  class CTimerInstruction
//
//  Generic timer instruction class. Has a name (m_wsTimerId) and knows 
//  whether events that were missed due to the system being halted or dead 
//  should be fired. 
//
//  Derived classes must be able to tell when their next firing time is.
//
//*****************************************************************************

class CEss;
class CWinMgmtTimerGenerator;
class CWBEMTimerInstruction : public CTimerInstruction
{
protected:
    long m_lRefCount;

    CWinMgmtTimerGenerator* m_pGenerator;
    IWbemServices* m_pNamespace;
    WString m_wsNamespace;
    WString m_wsTimerId;
    BOOL m_bSkipIfPassed;

    BOOL m_bRemoved;

public:
    CWBEMTimerInstruction();
    virtual ~CWBEMTimerInstruction();

    void AddRef()
        {InterlockedIncrement(&m_lRefCount);}
    void Release()
        {if(InterlockedDecrement(&m_lRefCount) == 0) delete this;}

    BOOL SkipIfPassed() const {return m_bSkipIfPassed;}
    void SetSkipIfPassed(BOOL bSkip) {m_bSkipIfPassed = bSkip;}

    INTERNAL LPCWSTR GetTimerId() {return m_wsTimerId;}
    INTERNAL LPCWSTR GetNamespace() {return m_wsNamespace;}
    void SetTimerId(LPCWSTR wszTimerId)
    {
        m_wsTimerId = wszTimerId;
    }

public:
    static HRESULT CheckObject(IWbemClassObject* pObject);
    static HRESULT LoadFromWbemObject(LPCWSTR wszNamespace,
        ADDREF IWbemServices* pNamespace,
        CWinMgmtTimerGenerator* pGenerator,
        IN IWbemClassObject* pObject, 
        OUT RELEASE_ME CWBEMTimerInstruction*& pInstruction);

    virtual CWbemTime GetNextFiringTime(CWbemTime LastFiringTime,
        OUT long* plFiringCount) const;
    virtual CWbemTime GetFirstFiringTime() const;
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFitingTime);
    virtual HRESULT MarkForRemoval();
    virtual int GetInstructionType() {return INSTTYPE_WBEM;}
    HRESULT StoreNextFiring(CWbemTime When);
    CWbemTime GetStartingFiringTime(CWbemTime OldTime) const;

protected:
    CWbemTime SkipMissed(CWbemTime Firing, long* plMissedCount = NULL) const;

    virtual CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const = 0;
    virtual CWbemTime ComputeFirstFiringTime() const = 0;
    virtual HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject) = 0;

protected:
    static CCritSec mstatic_cs;
};

//*****************************************************************************
//
//  class CAbsoluteTimerInstruction
//
//  A type of timer instruction which only fires once --- at the preset time.
//
//*****************************************************************************

class CAbsoluteTimerInstruction : public CWBEMTimerInstruction
{
protected:
    CWbemTime m_When;

public:
    CAbsoluteTimerInstruction() : CWBEMTimerInstruction(){}
    CWbemTime GetFiringTime() const{return m_When;}
    void SetFiringTime(CWbemTime When) {m_When = When;}

public:
    CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const;
    CWbemTime ComputeFirstFiringTime() const;

    static HRESULT CheckObject(IWbemClassObject* pObject);
    HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject);
    static INTERNAL LPCWSTR GetWbemClassName()
        {return L"__AbsoluteTimerInstruction";}
    virtual HRESULT Fire(long lNumTimes, CWbemTime NextFitingTime);
};

//*****************************************************************************
//
//  class CIntervalTimerInstruction
//
//  A type of timer instruction which fires every N milliseconds starting at 
//  a given time.
//
//*****************************************************************************

class CIntervalTimerInstruction : public CWBEMTimerInstruction
{
protected:
    CWbemTime m_Start; // not used
    CWbemInterval m_Interval;

public:
    CIntervalTimerInstruction() 
        : CWBEMTimerInstruction(), m_Start(), m_Interval()
    {}

    CWbemTime GetStart() const {return m_Start;}
    void SetStart(CWbemTime Start) {m_Start = Start;}

    CWbemInterval GetInterval() const {return m_Interval;}
    void SetInterval(CWbemInterval Interval) {m_Interval = Interval;}

public:
    static HRESULT CheckObject(IWbemClassObject* pObject) {return S_OK;}
    CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const;
    CWbemTime ComputeFirstFiringTime() const;

    HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject);
    static INTERNAL LPCWSTR GetWbemClassName() 
        {return L"__IntervalTimerInstruction";}
};

//*****************************************************************************
//
//  class CRecurringInstruction
//
//  A more complex recurrence instruction. TBD
//
//*****************************************************************************

class CRecurringTimerInstruction : public CWBEMTimerInstruction
{
    // TBD
public:
    CWbemTime ComputeNextFiringTime(CWbemTime LastFiringTime) const
        {return CWbemTime::GetInfinity();}
    CWbemTime ComputeFirstFiringTime() const
        {return CWbemTime::GetInfinity();}

    HRESULT LoadFromWbemObject(IN IWbemClassObject* pObject) 
        {return E_UNEXPECTED;}
    static INTERNAL LPCWSTR GetWbemClassName() 
        {return L"__RecurringTimerInstruction";}
    static HRESULT CheckObject(IWbemClassObject* pObject) {return S_OK;}
};

class CWinMgmtTimerGenerator : public CTimerGenerator
{
public:
    CWinMgmtTimerGenerator(CEss* pEss);
    HRESULT LoadTimerEventQueue(LPCWSTR wszNamespace, 
                                IWbemServices* pNamespace);
    HRESULT LoadTimerEventObject(LPCWSTR wszNamespace, 
                                 IWbemServices* pNamespace, 
                                 IWbemClassObject * pTimerInstruction,
                                 IWbemClassObject * pNextFiring = NULL);
    HRESULT LoadTimerEventObject(LPCWSTR wszNamespace, 
                                 IWbemClassObject * pTimerInstruction);
    HRESULT CheckTimerInstruction(IWbemClassObject* pInst);

    HRESULT Remove(LPCWSTR wszNamespace, LPCWSTR wszId);
    HRESULT Remove(LPCWSTR wszNamespace);
    HRESULT FireInstruction(CWBEMTimerInstruction* pInst, long lNumFirings);
    virtual HRESULT Shutdown();
    HRESULT SaveAndRemove(LONG bIsSystemShutDown);
    void DumpStatistics(FILE* f, long lFlags);

protected:
    class CIdTest : public CInstructionTest
    {
    protected:
        LPCWSTR m_wszId;
        LPCWSTR m_wszNamespace;
    public:
        CIdTest(LPCWSTR wszNamespace, LPCWSTR wszId) 
            : m_wszId(wszId), m_wszNamespace(wszNamespace) {}
        BOOL operator()(CTimerInstruction* pInst);
    };

    class CNamespaceTest : public CInstructionTest
    {
    protected:
        LPCWSTR m_wszNamespace;
    public:
        CNamespaceTest(LPCWSTR wszNamespace) 
            : m_wszNamespace(wszNamespace) {}
        BOOL operator()(CTimerInstruction* pInst);
    };
    
protected:

    CEss* m_pEss;
};                                                               


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\esscpol.h ===
#ifndef ESSCPOL_HEADERFILE_IS_INCLUDED
#define ESSCPOL_HEADERFILE_IS_INCLUDED

#ifdef USE_POLARITY
  #ifdef BUILDING_ESSCLI_DLL
   #define ESSCLI_POLARITY __declspec( dllexport )
  #else 
   #define ESSCLI_POLARITY __declspec( dllimport )
  #endif
 #else
  #define ESSCLI_POLARITY
 #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\evaltree.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EVALTREE.H

Abstract:

    WBEM Evaluation Tree

History:

--*/

#ifndef __WBEM_EVALUTAION_TREE__H_
#define __WBEM_EVALUTAION_TREE__H_

#include "esscpol.h"
#include <parmdefs.h>
#include <ql.h>
#include <sync.h>
#include <limits.h>
#include <sortarr.h>
#include <newnew.h>
#include <wbemmeta.h>
#include <wbemdnf.h>
#include <fastall.h>
#include <like.h>

// Uncomment this to enable tree checking.
//#define CHECK_TREES

#ifdef CHECK_TREES
    class CTreeChecker;
#endif

typedef DWORD_PTR QueryID;
#define InvalidID UINT_MAX

enum {EVAL_VALUE_TRUE, EVAL_VALUE_FALSE, EVAL_VALUE_INVALID};

#define WBEM_FLAG_MANDATORY_MERGE 0x100

// This is where we keep the extracted embedded objects
class ESSCLI_POLARITY CObjectInfo
{
protected:
    long m_lLength;
    _IWmiObject** m_apObj;

public:
    CObjectInfo() : m_apObj(NULL), m_lLength(0){}
    ~CObjectInfo();

    long GetLength() {return m_lLength;}
    bool SetLength(long lLength);
    void Clear();

    INTERNAL _IWmiObject* GetObjectAt(long lIndex) 
        {return m_apObj[lIndex];}
    void SetObjectAt(long lIndex, READ_ONLY _IWmiObject* pObj);
};

// This is where we keep what we've learned about the object in the query
// as we move down the tree.
class CImplicationList
{
public:
    struct CRecord
    {
        CPropertyName m_PropName;
        _IWmiObject* m_pClass;
        long m_lObjIndex;
        CWStringArray m_awsNotClasses;
        int m_nNull;

    public:
        CRecord(CPropertyName& PropName, long lObjIndex)
            : m_PropName(PropName), m_pClass(NULL), m_lObjIndex(lObjIndex),
            m_nNull(EVAL_VALUE_INVALID)
        {}
        CRecord(const CRecord& Other);
        ~CRecord();

        HRESULT ImproveKnown(_IWmiObject* pClass);
        HRESULT ImproveKnownNot(LPCWSTR wszClassName);
        HRESULT ImproveKnownNull();

        void Dump(FILE* f, int nOffset);
    };

protected:
    long m_lRequiredDepth;
    CUniquePointerArray<CRecord> m_apRecords;
    long m_lNextIndex;
    CImplicationList* m_pParent;
    long m_lFlags;
   
protected:
    void FindBestComputedContainer(CPropertyName* pPropName,
                                             long* plRecord, long* plMatched);
    HRESULT MergeIn(CImplicationList::CRecord* pRecord);
    HRESULT FindRecordForProp(CPropertyName* pPropName, long lNumElements,
                                             long* plRecord);
    HRESULT FindOrCreateRecordForProp(CPropertyName* pPropName, 
                                        CImplicationList::CRecord** ppRecord);
public:
    CImplicationList(long lFlags = 0);
    CImplicationList(CImplicationList& Other, bool bLink = true);
    ~CImplicationList();


    HRESULT FindBestComputedContainer(CPropertyName* pPropName,
            long* plFirstUnknownProp, long* plObjIndex, 
            RELEASE_ME _IWmiObject** ppContainerClass);
    HRESULT FindClassForProp(CPropertyName* pPropName,
            long lNumElements, RELEASE_ME _IWmiObject** ppClass);
    HRESULT AddComputation(CPropertyName& PropName, 
                                _IWmiObject* pClass, long* plObjIndex);
    HRESULT MergeIn(CImplicationList* pList);


    long GetRequiredDepth();
    void RequireDepth(long lDepth);
    HRESULT ImproveKnown(CPropertyName* pPropName, _IWmiObject* pClass);
    HRESULT ImproveKnownNot(CPropertyName* pPropName, LPCWSTR wszClassName);
    HRESULT ImproveKnownNull(CPropertyName* pPropName);

    bool IsMergeMandatory() 
        {return ((m_lFlags & WBEM_FLAG_MANDATORY_MERGE) != 0);}

    bool IsEmpty() {return m_apRecords.GetSize() == 0;}
    void Dump(FILE* f, int nOffset);
};
    
// Wrapper for arbitrary values
class CTokenValue
{
protected:
    VARIANT m_v;
public:
    CTokenValue();
    CTokenValue(CTokenValue& Other);
    ~CTokenValue();

    bool SetVariant(VARIANT& v);
    void operator=(CTokenValue& Other);

    operator signed char() const {return (signed char)V_I4(&m_v);}
    operator unsigned char() const {return (unsigned char)V_I4(&m_v);}
    operator unsigned short() const {return (unsigned short)V_I4(&m_v);}
    operator long() const {return (long)V_I4(&m_v);}
    operator unsigned long() const;
    operator __int64() const;
    operator unsigned __int64() const;
    operator float() const;
    operator double() const;
    operator short() const;
    operator WString() const;
    operator CInternalString() const {return CInternalString((WString)*this);}

    int Compare(const CTokenValue& Other) const;

    BOOL operator<(const CTokenValue& Other) const
    {return Compare(Other) < 0;}
    BOOL operator>(const CTokenValue& Other) const
    {return Compare(Other) > 0;}
    BOOL operator==(const CTokenValue& Other) const
    {return Compare(Other) == 0;}
};

enum {EVAL_OP_AND, EVAL_OP_OR, EVAL_OP_COMBINE, EVAL_OP_INVERSE_COMBINE};
inline int FlipEvalOp(int nOp)
{
    if(nOp == EVAL_OP_COMBINE) return EVAL_OP_INVERSE_COMBINE;
    else if(nOp == EVAL_OP_INVERSE_COMBINE) return EVAL_OP_COMBINE;
    else return nOp;
}

enum
{
    EVAL_NODE_TYPE_VALUE,
    EVAL_NODE_TYPE_BRANCH,
    EVAL_NODE_TYPE_OR,
    EVAL_NODE_TYPE_INHERITANCE,
    EVAL_NODE_TYPE_SCALAR,
    EVAL_NODE_TYPE_TWO_SCALARS,
    EVAL_NODE_TYPE_STRING,
    EVAL_NODE_TYPE_TWO_STRINGS,
    EVAL_NODE_TYPE_MISMATCHED_INTS,
    EVAL_NODE_TYPE_MISMATCHED_FLOATS,
    EVAL_NODE_TYPE_MISMATCHED_STRINGS,
    EVAL_NODE_TYPE_DUMB,
    EVAL_NODE_TYPE_LIKE_STRING
};

// Base class for all sorts of operations one can perform on leaf nodes of a 
// tree.  When applied to a leaf, it can change it, and return a value from the
// list below to control the rest of the traversal
enum 
{
    WBEM_DISPOSITION_NORMAL = 0, 
    WBEM_DISPOSITION_STOPLEVEL = 1,
    WBEM_DISPOSITION_STOPALL = 2,
    WBEM_DISPOSITION_FLAG_DELETE = 16,
    WBEM_DISPOSITION_FLAG_INVALIDATE = 32
};

class CLeafPredicate
{
public:
    virtual DWORD operator()(class CValueNode* pLeaf) = 0;

};

class CProjectionFilter
{
public:
    virtual bool IsInSet(class CEvalNode* pNode) = 0;
};

typedef enum {e_Sufficient, e_Necessary} EProjectionType;

// Base class for all nodes in the tree
class ESSCLI_POLARITY CEvalNode
{
protected:
    // int m_nType;
    virtual int GetType() = 0;
    
public:
    CEvalNode();
	CEvalNode(const CEvalNode& other);
    virtual ~CEvalNode();
    
    // NULL EvalNode interpreted as a Value Node with all false
    static int GetType(CEvalNode *pNode)
    {
        if (pNode)
            return pNode->GetType();
        else
            return EVAL_NODE_TYPE_VALUE;
    }


    virtual CEvalNode* Clone() const = 0;
    virtual HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes)=0;
    virtual int Compare(CEvalNode* pOther) = 0;
    virtual DWORD ApplyPredicate(CLeafPredicate* pPred) = 0;
    virtual void Dump(FILE* f, int nOffset) = 0;
#ifdef CHECK_TREES
	virtual void CheckNode(CTreeChecker *pCheck);
#endif

    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew) 
        {*ppNew = this; return WBEM_S_NO_ERROR;}
    virtual bool IsInvalid() {return false;}

    static bool IsInvalid(CEvalNode* pNode)
    {
        if(pNode)
            return pNode->IsInvalid();
        else
            return false;
    }

    virtual bool IsAllFalse() {return false;}
    static bool IsAllFalse(CEvalNode* pNode)
    {
        if(pNode)
            return pNode->IsAllFalse();
        else
            return true; // empty node is FALSE
    }
            
    virtual bool IsNoop(int nOp) {return false;}
    static bool IsNoop(CEvalNode* pNode, int nOp);

    virtual CImplicationList* GetExtraImplications() = 0;
    virtual HRESULT SetExtraImplications(CImplicationList* pList) = 0;

    static void PrintOffset(FILE* f, int nOffset);
    static CEvalNode* CloneNode(const CEvalNode* pNode);
    virtual HRESULT Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode) = 0;
    static void DumpNode(FILE* f, int nOffset, CEvalNode* pNode);

};

// just like CFlexArray, except:
//     array is always sorted
//     duplicates are not allowed
//     deals with QueryIDs (unsigneds), rather than pointers
//     intended for use by CValueNode, not necessarily as a generic sorted array
//     ASSUMPTION: pointer is same size as an unsigned 
class ESSCLI_POLARITY CSortedArray : protected CFlexArray
{
public:
    // Constructs a sorted array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CSortedArray(int nInitialSize = 32,
                int nGrowBy = 32
                ) : CFlexArray(nInitialSize, nGrowBy)
    {}


    CSortedArray(unsigned nElements, QueryID* pArray);
    // ~CSortedArray(); don't need it, yet...

    void operator=(const CSortedArray &that) 
        {((CFlexArray&)*this = (CFlexArray&)that); }

    int inline Size() const { return CFlexArray::Size(); }

    inline QueryID GetAt(int nIndex)  
        { return (QueryID)CFlexArray::GetAt(nIndex); }

    inline void Empty() { CFlexArray::Empty(); }
    inline void SetSize(int nSize) {CFlexArray::SetSize(nSize);}

    void DebugDump() { CFlexArray::DebugDump(); }

    // copies this array to destination
    // returns number of elements copied
    unsigned CopyTo(QueryID* pDest, unsigned size);

    //returns zero if arrays are equivalent
    // same number of USED elements w/ same values
    int Compare(CSortedArray& otherArray);

    // finds n in array
    // return index of found element
    // returns -1 if not found
    unsigned Find(QueryID n);

    // inserts n in proper position in array
    void Insert(QueryID n);

    // removes n from array
    // returns true if it did
    bool Remove(QueryID n);

    // add to end of array
    inline int Add(QueryID n) { return CFlexArray::Add((void *)n); };

    // changes all QueryID's to begin at newBase
    // e.g. if the array is {0,1,5}
    // Rebase(6) will change to {6,7,11}
    void Rebase(QueryID newBase);

    // Retrieves internal pointer to the data in the array
    inline QueryID* GetArrayPtr() {return (QueryID*)CFlexArray::GetArrayPtr();}

    // Retrieves the pointer to the data in the array and empties the array
    // The caller is responsible for the memory returned
    inline QueryID* UnbindPtr() {return (QueryID*)CFlexArray::UnbindPtr();}

    // Copies the data (but not the extent) from another array
    // Its own data is overwritten
    inline int CopyDataFrom(const CSortedArray& aOther) 
        {return CFlexArray::CopyDataFrom(aOther);}

    int AddDataFrom(const CSortedArray& aOther);
    int AddDataFrom(const QueryID* pOtherArray, unsigned nValues);


    int CopyDataFrom(const QueryID* pArray, unsigned nElements);

protected:

};
                                
// Leaf node --- contains the list of queries that matched
class  CValueNode : public CEvalNode
{
protected:
    DWORD m_nValues;
    // this data member MUST be the last in the class
    // to allow an array size defined at runtime
    // this array is always assumed to be sorted
    QueryID m_trueIDs[1];
    
    void ORarrays(CSortedArray& array1, CSortedArray& array1Not, 
                  CSortedArray& array2, CSortedArray& array2Not, 
                  CSortedArray& output);

    void ORarrays(CSortedArray& array1,  
                  CSortedArray& array2,  
                  CSortedArray& output);

    unsigned ORarrays(QueryID* pArray1, unsigned size1,
                      QueryID* pArray2, unsigned size2, 
                      QueryID* pOutput);

    void ANDarrays(CSortedArray& array1, CSortedArray& array2, 
                   CSortedArray& output);
    unsigned ANDarrays(QueryID* pArray1, unsigned size1,
                       QueryID* pArray2, unsigned size2, 
                       QueryID* pOutput);


    void CombineArrays(CSortedArray& array1, CSortedArray& array2, 
                       CSortedArray& output);
    unsigned CombineArrays(QueryID* pArray1, unsigned size1,
                           QueryID* pArray2, unsigned size2, 
                           QueryID* pOutput);


    // ctors moved to 'protected' to force callers to use the CreateNode function
    CValueNode() 
    {}

    CValueNode(int nNumValues);
    virtual int GetType();

public:
    
    virtual ~CValueNode();
    static CValueNode* CreateNode(size_t nNumValues);
    static CValueNode* CreateNode(CSortedArray& values);

    void *operator new( size_t stAllocateBlock, unsigned nEntries = 0);

    // VC 5 only allows one delete operator per class
#if _MSC_VER >= 1200
    void operator delete( void *p, unsigned nEntries );
#endif
    void operator delete(void* p) { ::delete[] (byte*)p; };


    // changes all QueryID's to begin at newBase
    // e.g. if the array is {0,1,5}
    // Rebase(6) will change to {6,7,11}

    DWORD GetNumTrues() {return m_nValues;}
    void Rebase(QueryID newBase);

    unsigned FindQueryID(QueryID n);

    int GetAt(int nIndex) 
    { 
        if (FindQueryID(nIndex) != InvalidID)
            return EVAL_VALUE_TRUE;                         
        else
            return EVAL_VALUE_FALSE;
    }

    bool IsAllFalse()
    {
            return (m_nValues == 0);
    }
    static bool IsAllFalse(CValueNode* pNode)
    {
        if (pNode)
            return pNode->IsAllFalse();
        else
            return true;
    }
    
    static bool IsNoop(CValueNode* pNode, int nOp);
    bool IsNoop(int nOp)
    {
        return IsNoop(this, nOp);
    }

    static bool AreAnyTrue(CValueNode* pNode)
    {    
        if (pNode)
            return (pNode->m_nValues > 0);
        else
            return false;
    }

    CEvalNode* Clone() const;
    HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications,
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes);
    int Compare(CEvalNode* pOther);
    HRESULT TryShortCircuit(CEvalNode* pArg2, int nOp, bool bDeleteThis,
                            bool bDeleteArg2, CEvalNode** ppRes);

    DWORD ApplyPredicate(CLeafPredicate* pPred) {return (*pPred)(this);}

    bool RemoveQueryID(QueryID nQuery);

    void CopyTruesTo(CSortedArray& trueIDs) const 
        {trueIDs.CopyDataFrom(m_trueIDs, m_nValues);}

    void AddTruesTo(CSortedArray& trueIDs) const
    {
        int nWasSize = trueIDs.Size();
        if(nWasSize == 0)
            trueIDs.CopyDataFrom((QueryID*)&m_trueIDs, m_nValues);
        else if (m_nValues > 0)
            trueIDs.AddDataFrom((QueryID*)&m_trueIDs, m_nValues);
    }


    static CValueNode* GetStandardTrue();
    static CValueNode* GetStandardFalse() { return NULL; };
    static CValueNode* GetStandardInvalid();

    virtual CImplicationList* GetExtraImplications() {return NULL;}
    virtual HRESULT SetExtraImplications(CImplicationList* pList)
    {
        // CValueNodes don't use or need this, so just delete it.
		delete pList;

        return S_OK;
    }

    virtual HRESULT Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode);

    virtual void Dump(FILE* f, int nOffset);
};

class CInvalidNode : public CValueNode
{
public:
    CInvalidNode() : CValueNode(0){}

    bool IsInvalid() {return true;}
    void Dump(FILE* f, int nOffset);
};

    

// Contains information about the portion of the node exclusing the last 
// component of the property name

class CEmbeddingInfo
{
protected:
    CPropertyName m_EmbeddedObjPropName;
    
    long m_lStartingObjIndex;
    long m_lNumJumps;
    
    struct JumpInfo {
        long lJump;
        long lTarget; 
    }* m_aJumps;

public:
    CEmbeddingInfo();
    CEmbeddingInfo(const CEmbeddingInfo& Other);
    ~CEmbeddingInfo();
    void operator=(const CEmbeddingInfo& Other);

    CPropertyName* GetEmbeddedObjPropName() {return &m_EmbeddedObjPropName;}
    void SetEmbeddedObjPropName(CPropertyName& Name) 
        {m_EmbeddedObjPropName = Name;}

    bool SetPropertyNameButLast(const CPropertyName& Name);

    BOOL operator==(const CEmbeddingInfo& Other);
    BOOL operator!=(const CEmbeddingInfo& Other)
        {return !(*this == Other);}

    HRESULT Compile(CContextMetaData* pNamespace, 
                    CImplicationList& Implications, 
                    _IWmiObject** ppResultClass);
    HRESULT GetContainerObject(CObjectInfo& ObjInfo, 
                                INTERNAL _IWmiObject** ppInst);
    int ComparePrecedence(const CEmbeddingInfo* pOther);
    bool AreJumpsRelated( const CEmbeddingInfo* pInfo );
    bool MixInJumps(const CEmbeddingInfo* pInfo );
    bool IsEmpty() const;
    void Dump(FILE* f);
};


// A node that is interested in the implications that have accrued

class CNodeWithImplications : public CEvalNode
{
protected:
    CImplicationList* m_pExtraImplications;

public:
    CNodeWithImplications() : m_pExtraImplications(NULL){}
    CNodeWithImplications(const CNodeWithImplications& Other);
    ~CNodeWithImplications()
    {
        delete m_pExtraImplications;
    }

    virtual CImplicationList* GetExtraImplications()
    {
        return m_pExtraImplications;
    }
    virtual HRESULT SetExtraImplications(ACQUIRE CImplicationList* pList)
    {
        if(m_pExtraImplications)
            delete m_pExtraImplications;
        m_pExtraImplications = pList;
        return S_OK;
    }
    void Dump(FILE* f, int nOffset);
};


class CBranchIterator
{
public:
    virtual ~CBranchIterator(){}
    virtual INTERNAL CEvalNode* GetNode() = 0;
    virtual void SetNode(ACQUIRE CEvalNode* pNode) = 0;

    virtual bool IsValid() = 0;
    virtual void Advance() = 0;

    virtual HRESULT RecordBranch(CContextMetaData* pMeta, 
                                    CImplicationList& Implications) = 0;
};

// A node with a test and a whole bunch of branches, including a special one for
// the case where the thing being tested was NULL

class CBranchingNode : public CNodeWithImplications
{
// protected:
public: // because I don't know how to make a template a friend
    CUniquePointerArray<CEvalNode> m_apBranches;
    CEvalNode* m_pNullBranch;

    CEmbeddingInfo* m_pInfo;

protected:
    void operator=(const CBranchingNode& Other);
    HRESULT CompileEmbeddingPortion(CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                _IWmiObject** ppResultClass)
    {
        if (!m_pInfo)
            return WBEM_S_NO_ERROR;
        else
            return m_pInfo->Compile(pNamespace, Implications, ppResultClass);
    }

    HRESULT GetContainerObject(CObjectInfo& ObjInfo, 
                                INTERNAL _IWmiObject** ppInst)
    {
        if (!m_pInfo)
        {
            // this SEEMS to be the behavior of the code prior to changes
            *ppInst = ObjInfo.GetObjectAt(0);
            return WBEM_S_NO_ERROR;
        }                
        else
            return m_pInfo->GetContainerObject(ObjInfo, ppInst);
    }

    bool SetEmbeddedObjPropName(CPropertyName& Name);
    bool MixInJumps(const CEmbeddingInfo* pInfo);

    HRESULT StoreBranchImplications(CContextMetaData* pNamespace,
                            int nBranchIndex, CEvalNode* pResult);
public:
    CBranchingNode();
    CBranchingNode(const CBranchingNode& Other, BOOL bChildren = TRUE);
    ~CBranchingNode();

    virtual int GetType();
    virtual long GetSubType() = 0;
    CUniquePointerArray<CEvalNode>& GetBranches() {return m_apBranches;}
    CEvalNode* GetNullBranch() {return m_pNullBranch;}
    void SetNullBranch(CEvalNode* pBranch);
    CPropertyName* GetEmbeddedObjPropName() 
    {
        if (!m_pInfo)
            return NULL;
        else                
            return m_pInfo->GetEmbeddedObjPropName();
    }

    virtual DWORD ApplyPredicate(CLeafPredicate* pPred);
    virtual DELETE_ME CBranchIterator* GetBranchIterator();
    
    virtual int ComparePrecedence(CBranchingNode* pOther) = 0;
    virtual int Compare(CEvalNode* pNode);
    virtual int SubCompare(CEvalNode* pNode) = 0;

    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, 
                                INTERNAL CEvalNode** ppNext) = 0;
    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes) = 0;
    virtual HRESULT RecordBranch(CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                long lBranchIndex)
        {return WBEM_S_NO_ERROR;}
    virtual HRESULT OptimizeSelf() {return WBEM_S_NO_ERROR;}

    HRESULT AdjustCompile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
    {   
        if (!m_pInfo)
            return WBEM_S_NO_ERROR;
        else
            return m_pInfo->Compile(pNamespace, Implications, NULL);
    }

    HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications, 
                        bool bDeleteThis, bool bDeleteArg2, 
                        CEvalNode** ppRes);
    virtual HRESULT CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes);
    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    BOOL AreAllSame(CEvalNode** apNodes, int nSize, int* pnFoundIndex);
    static int ComparePrecedence(CBranchingNode* pArg1, CBranchingNode* pArg2);

    HRESULT Project(CContextMetaData* pMeta, CImplicationList& Implications,
                            CProjectionFilter* pFilter, EProjectionType eType, 
                            bool bDeleteThis, CEvalNode** ppNewNode);
    void Dump(FILE* f, int nOffset);
#ifdef CHECK_TREES
	virtual void CheckNode(CTreeChecker *pCheck);
#endif
    friend class CDefaultBranchIterator;
};

class CDefaultBranchIterator : public CBranchIterator
{
protected:
    CBranchingNode* m_pNode;
    int m_nIndex;

public:
    CDefaultBranchIterator(CBranchingNode* pNode) : m_pNode(pNode), m_nIndex(-1)
    {}

    virtual INTERNAL CEvalNode* GetNode()
    {
        if(m_nIndex == -1)
            return m_pNode->m_pNullBranch;
        else
            return m_pNode->m_apBranches[m_nIndex];
    }
    virtual void SetNode(ACQUIRE CEvalNode* pNode)
    {
        CEvalNode* pOld;
        if(m_nIndex == -1)
            m_pNode->m_pNullBranch = pNode;
        else
            m_pNode->m_apBranches.SetAt(m_nIndex, pNode, &pOld);
    }

    virtual bool IsValid() { return m_nIndex < m_pNode->m_apBranches.GetSize();}
    virtual void Advance() { m_nIndex++;}
    virtual HRESULT RecordBranch(CContextMetaData* pMeta, 
                                    CImplicationList& Implications)
    {
        return m_pNode->RecordBranch(pMeta, Implications, m_nIndex);
    }
};
    



// The node where a property is tested against a value.  The property is 
// identified by a handle
class CPropertyNode : public CBranchingNode
{
protected:
    long m_lPropHandle;
    WString m_wsPropName;

public:
    CPropertyNode() 
        : m_lPropHandle(-1)
    {}
    CPropertyNode(const CPropertyNode& Other, BOOL bChildren = TRUE)
        : CBranchingNode(Other, bChildren), m_lPropHandle(Other.m_lPropHandle),
            m_wsPropName(Other.m_wsPropName)
    {}
    virtual ~CPropertyNode(){}

    virtual int ComparePrecedence(CBranchingNode* pOther);
    bool SetPropertyInfo(LPCWSTR wszPropName, long lPropHandle);
    LPCWSTR GetPropertyName() {return m_wsPropName;}
    bool SetEmbeddingInfo(const CEmbeddingInfo* pInfo);
    virtual HRESULT SetNullTest(int nOperator);
    virtual HRESULT SetOperator(int nOperator);

    virtual HRESULT SetTest(VARIANT& v) = 0;
};

// An element in the array of test points
template<class TPropType>
struct CTestPoint
{
    TPropType m_Test;
    CEvalNode* m_pLeftOf;
    CEvalNode* m_pAt;

    CTestPoint() : m_pLeftOf(NULL), m_pAt(NULL){}
    void Destruct() {delete m_pLeftOf; delete m_pAt;}
};

template<class TPropType>
struct CTestPointCompare
{
    typedef CTestPoint<TPropType> TTestPoint;

    inline int Compare(const TPropType& t, const TTestPoint& p) const
    {
        if(t < p.m_Test)
            return -1;
        else if(t == p.m_Test)
            return 0;
        else return 1;
    }
    inline int Compare(const TPropType& t1, const TPropType& t2) const
    {
        if(t1 < t2)
            return -1;
        else if(t1 == t2)
            return 0;
        else return 1;
    }
    inline int Compare(const TTestPoint& p1, const TTestPoint& p2) const
    {
        return Compare(p1.m_Test, p2);
    }
    inline const TPropType& Extract(const TTestPoint& p) const
    {
        return p.m_Test;
    }
};

template<class TPropType>
struct CTestPointManager
{
    typedef CTestPoint<TPropType> TTestPoint;

    void AddRefElement(TTestPoint& p){}
    void ReleaseElement(TTestPoint& p) {p.Destruct();}
};
        
template<class TPropType>
class CFullCompareNode : public CPropertyNode
{
// protected:
public: // because I can't make a template a friend of this one??
    typedef CSmartSortedTree<
                TPropType, 
                CTestPoint<TPropType>, 
                CTestPointManager<TPropType>,
                CTestPointCompare<TPropType> > TTestPointArray;

    typedef TTestPointArray::TIterator TTestPointIterator;
    typedef TTestPointArray::TConstIterator TConstTestPointIterator;
    TTestPointArray m_aTestPoints;
    CEvalNode* m_pRightMost;

public:
    CFullCompareNode() : m_pRightMost(NULL) 
    {}
    CFullCompareNode(const CFullCompareNode<TPropType>& Other, 
                            BOOL bChildren = TRUE);
    virtual ~CFullCompareNode();

    HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                bool bDeleteThis, bool bDeleteArg2,
                                CEvalNode** ppRes);
    HRESULT CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes);
    int SubCompare(CEvalNode* pOther);
    virtual HRESULT OptimizeSelf();
    virtual HRESULT SetTest(VARIANT& v);

    virtual DWORD ApplyPredicate(CLeafPredicate* pPred);
    virtual DELETE_ME CBranchIterator* GetBranchIterator()
    {
        return new CFullCompareBranchIterator<TPropType>(this);
    }
    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    HRESULT SetNullTest(int nOperator);
    HRESULT SetOperator(int nOperator);

protected:
    HRESULT CombineWithBranchesToLeft(
            TTestPointIterator itWalk, TTestPointIterator itLast,
            CEvalNode* pArg2,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& OrigImplications);
    HRESULT InsertLess(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& OrigImplications, bool bDeleteArg2);
    HRESULT InsertMatching(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& OrigImplications, bool bDeleteArg2);

};

template<class TPropType>
class CFullCompareBranchIterator : public CBranchIterator
{
protected:
    CFullCompareNode<TPropType>* m_pNode;
    CFullCompareNode<TPropType>::TTestPointIterator m_it;
    CFullCompareNode<TPropType>::TTestPointIterator m_itEnd;
    bool m_bLeft;
    bool m_bValid;

public:
    CFullCompareBranchIterator(CFullCompareNode<TPropType>* pNode) 
        : m_pNode(pNode), m_it(pNode->m_aTestPoints.Begin()), m_bLeft(true),
          m_itEnd(pNode->m_aTestPoints.End()), m_bValid(true)
    {}

    virtual INTERNAL CEvalNode* GetNode()
    {
        if(m_it == m_itEnd)
        {
            if(m_bLeft)
                return m_pNode->m_pRightMost;
            else
                return m_pNode->m_pNullBranch;
        }
        else 
        {
            if(m_bLeft)
                return m_it->m_pLeftOf;
            else
                return m_it->m_pAt;
        }
    }
    virtual void SetNode(ACQUIRE CEvalNode* pNode)
    {
        if(m_it == m_itEnd)
        {
            if(m_bLeft)
                m_pNode->m_pRightMost = pNode;
            else
                m_pNode->m_pNullBranch = pNode;
        }
        else 
        {
            if(m_bLeft)
                m_it->m_pLeftOf = pNode;
            else
                m_it->m_pAt = pNode;
        }
    }

    virtual bool IsValid() { return m_bValid;}
    virtual void Advance()
    {
        if(m_bLeft)
            m_bLeft = false;
        else if(m_it == m_itEnd)
            m_bValid = false;
        else
        {
            m_it++;
            m_bLeft = true;
        }
    } 
    virtual HRESULT RecordBranch(CContextMetaData* pMeta, 
                                    CImplicationList& Implications)
    {
        return S_OK; // fullcompare nodes don't have implications
    }
};
    


template<class TPropType>
class CScalarPropNode : public CFullCompareNode<TPropType>
{
public:
    CScalarPropNode() : CFullCompareNode<TPropType>()
    {}
    CScalarPropNode(const CScalarPropNode<TPropType>& Other, 
                        BOOL bChildren = TRUE)
        : CFullCompareNode<TPropType>(Other, bChildren)
    {}
    virtual ~CScalarPropNode(){}

    virtual long GetSubType() {return EVAL_NODE_TYPE_SCALAR; }
    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);
    virtual CEvalNode* Clone() const 
        {return new CScalarPropNode<TPropType>(*this);}
    virtual CBranchingNode* CloneSelf() const
       {return new CScalarPropNode<TPropType>(*this, FALSE);}
    virtual void Dump(FILE* f, int nOffset);
};

class CStringPropNode : public CFullCompareNode<CInternalString>
{
public:
    CStringPropNode() 
        : CFullCompareNode<CInternalString>()
    {}
    CStringPropNode(const CStringPropNode& Other, BOOL bChildren = TRUE);
    virtual ~CStringPropNode();

    virtual long GetSubType() { return EVAL_NODE_TYPE_STRING; }

    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);
    virtual CEvalNode* Clone() const {return new CStringPropNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CStringPropNode(*this, FALSE);}
    virtual void Dump(FILE* f, int nOffset);
};

class CLikeStringPropNode : public CPropertyNode
{
protected:

    CLike m_Like;

public:

    CLikeStringPropNode() {} ;
    CLikeStringPropNode(const CLikeStringPropNode& Other, BOOL bChildren=TRUE);

    virtual long GetSubType() { return EVAL_NODE_TYPE_LIKE_STRING; }

    virtual int ComparePrecedence(CBranchingNode* pNode);
    virtual int SubCompare(CEvalNode* pNode);

    virtual HRESULT SetTest( VARIANT& v );

    virtual HRESULT Evaluate( CObjectInfo& ObjInfo, CEvalNode** ppNext );

    virtual HRESULT CombineBranchesWith( CBranchingNode* pArg2, int nOp, 
                                         CContextMetaData* pNamespace, 
                                         CImplicationList& Implications,
                                         bool bDeleteThis, bool bDeleteArg2,
                                         CEvalNode** ppRes );
    virtual HRESULT OptimizeSelf();

    virtual CEvalNode* Clone() const {return new CLikeStringPropNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CLikeStringPropNode(*this, FALSE);}
    virtual void Dump(FILE* f, int nOffset);
};
    

class CInheritanceNode : public CBranchingNode
{
protected:
    long m_lDerivationIndex;
    
    long m_lNumPoints;
    CCompressedString** m_apcsTestPoints;
public:
    CInheritanceNode();
    CInheritanceNode(const CInheritanceNode& Other, BOOL bChildren = TRUE);
    virtual ~CInheritanceNode();

    virtual long GetSubType();
    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);
    virtual int ComparePrecedence(CBranchingNode* pOther);
    virtual CEvalNode* Clone() const {return new CInheritanceNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CInheritanceNode(*this, FALSE);}
    virtual HRESULT Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications);
    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes);
    virtual HRESULT RecordBranch(CContextMetaData* pNamespace, 
                                CImplicationList& Implications,
                                long lBranchIndex);
    virtual int SubCompare(CEvalNode* pOther);
    virtual HRESULT OptimizeSelf();
    HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    void RemoveTestPoint(int nIndex);
    HRESULT Project(CContextMetaData* pMeta, CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode);
    virtual void Dump(FILE* f, int nOffset);
public:
    HRESULT AddClass(CContextMetaData* pNamespace, LPCWSTR wszClassName,
                        CEvalNode* pDestination);
    HRESULT AddClass(CContextMetaData* pNamespace, 
                                    LPCWSTR wszClassName, _IWmiObject* pClass,
                                    CEvalNode* pDestination);
    bool SetPropertyInfo(CContextMetaData* pNamespace, CPropertyName& PropName);
protected:
	void RemoveAllTestPoints();

	HRESULT ComputeUsageForMerge(CInheritanceNode* pArg2, 
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
											bool bDeleteThis, bool bDeleteArg2,
											DWORD* pdwFirstNoneCount,
											DWORD* pdwSecondNoneCount,
											bool* pbBothNonePossible);

};
    
class COrNode : public CNodeWithImplications
{
protected:
    CUniquePointerArray<CEvalNode> m_apBranches;

    void operator=(const COrNode& Other);

public:
    COrNode(){}
    COrNode(const COrNode& Other) {*this = Other;}
    virtual ~COrNode(){}
    HRESULT AddBranch(CEvalNode* pNewBranch);
    
    virtual int GetType() {return EVAL_NODE_TYPE_OR;}
    virtual CEvalNode* Clone() const {return new COrNode(*this);}

    virtual HRESULT CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes);
    virtual int Compare(CEvalNode* pOther);
    virtual DWORD ApplyPredicate(CLeafPredicate* pPred);
    virtual void Dump(FILE* f, int nOffset);
    virtual HRESULT Evaluate(CObjectInfo& Info, CSortedArray& trueIDs);
    virtual HRESULT Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew);
    HRESULT Project(CContextMetaData* pMeta, CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode);

protected:
    HRESULT CombineWithOrNode(COrNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes);
};


class ESSCLI_POLARITY CEvalTree
{
protected:
    long m_lRef;
    CCritSec m_cs;

    CEvalNode* m_pStart;
    CObjectInfo m_ObjectInfo;
    int m_nNumValues;

protected:
    class CRemoveIndexPredicate : public CLeafPredicate
    {
    protected:
        int m_nIndex;
    public:
        CRemoveIndexPredicate(int nIndex) : m_nIndex(nIndex){}
        DWORD operator()(CValueNode* pLeaf);
    };

    class CRemoveFailureAtIndexPredicate : public CLeafPredicate
    {
    protected:
        int m_nIndex;
    public:
        CRemoveFailureAtIndexPredicate(int nIndex) : m_nIndex(nIndex){}
        DWORD operator()(CValueNode* pLeaf);
    };

    class CRebasePredicate : public CLeafPredicate
    {
    public:
        CRebasePredicate(QueryID newBase) :
            m_newBase(newBase)
            {}

        virtual DWORD operator()(class CValueNode* pLeaf);

    private:
        QueryID m_newBase;
    };


protected:
    static HRESULT InnerCombine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications,
                        bool bDeleteArg1, bool bDeleteArg2, CEvalNode** ppRes);
public:
    CEvalTree();
    CEvalTree(const CEvalTree& Other);
    ~CEvalTree();
    void operator=(const CEvalTree& Other);

    bool SetBool(BOOL bVal);
    bool IsFalse();
    bool IsValid();

    HRESULT CreateFromQuery(CContextMetaData* pNamespace, 
                            LPCWSTR wszQuery, long lFlags, long lMaxTokens);
    HRESULT CreateFromQuery(CContextMetaData* pNamespace, 
                            QL_LEVEL_1_RPN_EXPRESSION* pQuery, long lFlags,
                            long lMaxTokens);
    HRESULT CreateFromQuery(CContextMetaData* pNamespace, 
                            LPCWSTR wszClassName, int nNumTokens, 
                            QL_LEVEL_1_TOKEN* apTokens, long lFlags,
                            long lMaxTokens);
    static HRESULT CreateFromConjunction(CContextMetaData* pNamespace, 
                                  CImplicationList& Implications,
                                  CConjunction* pConj,
                                  CEvalNode** ppRes);
    HRESULT CreateFromDNF(CContextMetaData* pNamespace, 
                                  CImplicationList& Implications,
                                  CDNFExpression* pDNF,
                                  CEvalNode** ppRes);
    HRESULT CombineWith(CEvalTree& Other, CContextMetaData* pNamespace, 
                        int nOp, long lFlags = 0);

    HRESULT Optimize(CContextMetaData* pNamespace);
    HRESULT Evaluate(IWbemObjectAccess* pObj, CSortedArray& aTrues);
    static HRESULT Evaluate(CObjectInfo& Info, CEvalNode* pStart, 
                                CSortedArray& trueIDs);
    static HRESULT Combine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications,
                        bool bDeleteArg1, bool bDeleteArg2, CEvalNode** ppRes);
    static HRESULT CombineInOrder(CBranchingNode* pArg1, CEvalNode* pArg2,
                        int nOp, 
                        CContextMetaData* pNamespace, 
                        CImplicationList& Implications,
                        bool bDeleteArg1, bool bDeleteArg2,
                        CEvalNode** ppRes);
    static HRESULT IsMergeAdvisable(CEvalNode* pArg1, CEvalNode* pArg2, 
                                    CImplicationList& Implications);
    static HRESULT BuildFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes);

    static HRESULT BuildTwoPropFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes);


    static int Compare(CEvalNode* pArg1, CEvalNode* pArg2);

    HRESULT RemoveIndex(int nIndex);
    HRESULT UtilizeGuarantee(CEvalTree& Guaranteed, 
                                CContextMetaData* pNamespace);
    HRESULT ApplyPredicate(CLeafPredicate* pPred);
    static inline bool IsNotEmpty(CEvalNode* pNode);

    void Rebase(QueryID newBase);

    HRESULT CreateProjection(CEvalTree& Old, CContextMetaData* pMeta,
                            CProjectionFilter* pFilter, 
                            EProjectionType eType, bool bDeleteOld);
    static HRESULT Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications, 
                            CEvalNode* pOldNode, CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteOld,
                            CEvalNode** ppNewNode);
    bool Clear();
    void Dump(FILE* f);
#ifdef CHECK_TREES
	void CheckNodes(CTreeChecker *pCheck);
#endif

protected:
    static HRESULT CombineLeafWithBranch(CValueNode* pArg1, 
                            CBranchingNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes);
    
};

class ESSCLI_POLARITY CPropertyProjectionFilter : public CProjectionFilter
{
    CUniquePointerArray<CPropertyName>* m_papProperties;
public:
    CPropertyProjectionFilter();
    ~CPropertyProjectionFilter();
    virtual bool IsInSet(CEvalNode* pNode);

    bool AddProperty(const CPropertyName& Prop);
};

//#include "evaltree.inl"
HRESULT CoreGetNumParents(_IWmiObject* pClass, ULONG *plNumParents);
RELEASE_ME _IWmiObject* CoreGetEmbeddedObj(_IWmiObject* pObj, long lHandle);
INTERNAL CCompressedString* CoreGetPropertyString(_IWmiObject* pObj, 
                                long lHandle);
INTERNAL CCompressedString* CoreGetClassInternal(_IWmiObject* pObj);
INTERNAL CCompressedString* CoreGetParentAtIndex(_IWmiObject* pObj, 
                                long lIndex);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\dumbnode.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DUMBNODE.H

Abstract:

    WBEM Dumb Node

History:

--*/

#ifndef __WMI_DUMBNODE__H_
#define __WMI_DUMBNODE__H_

#include "evaltree.h"

//
// This node is used when not enough information exists about the objects being
// tested to perform fast, strongly typed, handle-based comparisons.  Instead,
// it is based on the core query engine code for evaluating a token. Having 
// evaluated a token, it can take a NULL, TRUE, or FALSE branches.
//

class CDumbNode : public CBranchingNode
{
protected:
    QL_LEVEL_1_TOKEN m_Token;
    
    int EvaluateToken(IWbemPropertySource *pTestObj, QL_LEVEL_1_TOKEN& Tok);
    LPWSTR NormalizePath(LPCWSTR wszObjectPath);

public:
    CDumbNode(QL_LEVEL_1_TOKEN& Token);
    CDumbNode(const CDumbNode& Other, BOOL bChildren = TRUE);
    virtual ~CDumbNode();
    HRESULT Validate(IWbemClassObject* pClass);

    virtual CEvalNode* Clone() const {return new CDumbNode(*this);}
    virtual CBranchingNode* CloneSelf() const
        {return new CDumbNode(*this, FALSE);}
    virtual HRESULT Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications);
    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes);

    virtual long GetSubType();
    virtual int SubCompare(CEvalNode* pOther);
    virtual int ComparePrecedence(CBranchingNode* pOther);

    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);

    virtual void Dump(FILE* f, int nOffset);

    virtual HRESULT OptimizeSelf();
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\evaltree.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    EVALTREE.CPP

Abstract:

    WBEM Evaluation Tree

History:

--*/

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <fastall.h>
#include <genutils.h>
#include "evaltree.h"
#include "TreeChecker.h"
#include "evaltree.inl"
#include "TwoPropNode.h"
#include "dumbnode.h"

// #define DUMP_EVAL_TREES 1

HRESULT CoreGetNumParents(_IWmiObject* pClass, ULONG *plNumParents)
{
/*
    *plNumParents = ((CWbemObject*)pClass)->GetNumParents();
*/
    DWORD dwSize;
    HRESULT hres = pClass->GetDerivation(0, 0, plNumParents, &dwSize, NULL);
    if(hres != WBEM_E_BUFFER_TOO_SMALL && hres != S_OK)
        return WBEM_E_FAILED;

    return S_OK;
}

RELEASE_ME _IWmiObject* CoreGetEmbeddedObj(_IWmiObject* pObj, long lHandle)
{
    _IWmiObject* pEmbedded = NULL;
    HRESULT hres = pObj->GetPropAddrByHandle(lHandle, 0, NULL, 
                                                (void**)&pEmbedded);
    if(FAILED(hres))
            return NULL;

    return pEmbedded;
}

INTERNAL CCompressedString* CoreGetPropertyString(_IWmiObject* pObj, 
                                                    long lHandle)
{
    CCompressedString* pcs = NULL;
    HRESULT hres = pObj->GetPropAddrByHandle(lHandle, 
                                WMIOBJECT_FLAG_ENCODING_V1, NULL,
                                (void**)&pcs);
    if(FAILED(hres))
            return NULL;

    return pcs;
}

INTERNAL CCompressedString* CoreGetClassInternal(_IWmiObject* pObj)
{
    CCompressedString* pcs = NULL;
    HRESULT hres = pObj->GetPropAddrByHandle(FASTOBJ_CLASSNAME_PROP_HANDLE, 
                                WMIOBJECT_FLAG_ENCODING_V1, NULL,
                                (void**)&pcs);
    if(FAILED(hres))
            return NULL;

    return pcs;
}

INTERNAL CCompressedString* CoreGetParentAtIndex(_IWmiObject* pObj, long lIndex)
{
    return ((CWbemObject*)pObj)->GetParentAtIndex(lIndex);
}

bool CoreIsDerived(_IWmiObject* pThis, _IWmiObject* pFrom)
{
    CCompressedString* pcs = CoreGetClassInternal(pFrom);
    if(pcs == NULL)
        return false;

    try
    {
	    return (pThis->InheritsFrom(pcs->CreateWStringCopy()) == S_OK);
    }
	catch (CX_MemoryException)
	{
		return false;
	}
}

//******************************************************************************
//******************************************************************************
//                  TOKEN VALUE
//******************************************************************************
//******************************************************************************
CTokenValue::CTokenValue()
{
    VariantInit(&m_v);
}
CTokenValue::CTokenValue(CTokenValue& Other)
{
    VariantInit(&m_v);
    *this = Other;
}

CTokenValue::~CTokenValue()
{
    VariantClear(&m_v);
}

bool CTokenValue::SetVariant(VARIANT& v)
{
    if(FAILED(VariantCopy(&m_v, &v)))
        return false;

    // Convert to a better type
    // ========================

    if(V_VT(&v) == VT_I2 || V_VT(&v) == VT_UI1)
    {
        if(FAILED(VariantChangeType(&m_v, &m_v, 0, VT_I4)))
            return false;
    }
    else if(V_VT(&v) == VT_R4)
    {
        if(FAILED(VariantChangeType(&m_v, &m_v, 0, VT_R8)))
            return false;
    }

    return true;
}

void CTokenValue::operator=(CTokenValue& Other)
{
    if(!SetVariant(Other.m_v))
        throw CX_MemoryException();
}

CTokenValue::operator unsigned __int64() const
{
    if(V_VT(&m_v) == VT_I4)
    {
        return V_I4(&m_v);
    }
    else if(V_VT(&m_v) == VT_BSTR)
    {
        unsigned __int64 ui64;
        if(ReadUI64(V_BSTR(&m_v), ui64))
            return ui64;
        else
            return 0; // TBD: errors
    }
    else return 0;
}

CTokenValue::operator unsigned long() const
{
    if(V_VT(&m_v) == VT_I4)
    {
        return V_I4(&m_v);
    }
    else if(V_VT(&m_v) == VT_BSTR)
    {
        unsigned __int64 ui64;
        if(ReadUI64(V_BSTR(&m_v), ui64))
            return (unsigned long)ui64;
        else
            return 0; // TBD: errors
    }
    else return 0;
}

CTokenValue::operator __int64() const
{
    if(V_VT(&m_v) == VT_I4)
    {
        return V_I4(&m_v);
    }
    else if(V_VT(&m_v) == VT_BSTR)
    {
        __int64 i64;
        if(ReadI64(V_BSTR(&m_v), i64))
            return i64;
        else
            return 0; // TBD: errors
    }
    else return 0;
}
CTokenValue::operator short() const
{
    if(V_VT(&m_v) == VT_I4)
        return V_I4(&m_v);
    else if(V_VT(&m_v) == VT_BOOL)
        return V_BOOL(&m_v);
    else return 0;
}
CTokenValue::operator float() const
{
    if(V_VT(&m_v) == VT_I4)
        return V_I4(&m_v);
    else if(V_VT(&m_v) == VT_R8)
        return V_R8(&m_v);
    else return 0;
}

CTokenValue::operator double() const
{
    if(V_VT(&m_v) == VT_I4)
        return V_I4(&m_v);
    else if(V_VT(&m_v) == VT_R8)
        return V_R8(&m_v);
    else return 0;
}

CTokenValue::operator WString() const
{
    if(V_VT(&m_v) == VT_BSTR)
        return WString(V_BSTR(&m_v));
    else
        return WString(L"");
}

int CTokenValue::Compare(const CTokenValue& Other) const
{
    switch(V_VT(&m_v))
    {
    case VT_I4:
        return V_I4(&m_v) - V_I4(&Other.m_v);
    case VT_R8:
        return (V_R8(&m_v) - V_R8(&Other.m_v)<0 ? -1 : 1);
    case VT_BSTR:
        return wbem_wcsicmp(V_BSTR(&m_v), V_BSTR(&Other.m_v));
    case VT_BOOL:
        return V_BOOL(&m_v) - V_BOOL(&Other.m_v);
    }
    return 0;
}
//******************************************************************************
//******************************************************************************
//                  OBJECT INFO
//******************************************************************************
//******************************************************************************

bool CObjectInfo::SetLength(long lLength)
{
    if(lLength > m_lLength)
    {
        delete [] m_apObj;
        m_apObj = new _IWmiObject*[lLength];
        if (m_apObj == NULL)
            return false;

        memset(m_apObj, 0, lLength * sizeof(_IWmiObject*));
    }
    m_lLength = lLength;
    return true;
}

void CObjectInfo::Clear()
{
    for(long i = 1; i < m_lLength; i++)
    {
        if(m_apObj[i])
            m_apObj[i]->Release();
        m_apObj[i] = NULL;
    }
    m_apObj[0] = NULL; // do not release
}

void CObjectInfo::SetObjectAt(long lIndex, READ_ONLY _IWmiObject* pObj) 
{
    if(m_apObj[lIndex])
        m_apObj[lIndex]->Release();

    m_apObj[lIndex] = pObj;
}


CObjectInfo::~CObjectInfo()
{
    for(long i = 0; i < m_lLength; i++)
    {
        if(m_apObj[i])
            m_apObj[i]->Release();
    }
    delete [] m_apObj;
}

//******************************************************************************
//******************************************************************************
//                  IMPLICATION LIST
//******************************************************************************
//******************************************************************************

CImplicationList::CRecord::CRecord(const CImplicationList::CRecord& Other)
    : m_PropName(Other.m_PropName), m_pClass(Other.m_pClass),
    m_lObjIndex(Other.m_lObjIndex), m_nNull(Other.m_nNull)
{
    if(m_pClass)
        m_pClass->AddRef();

    for(int i = 0; i < Other.m_awsNotClasses.Size(); i++)
    {
        if(m_awsNotClasses.Add(Other.m_awsNotClasses[i]) != 
                CWStringArray::no_error)
        {
            throw CX_MemoryException();
        }
    }
}

CImplicationList::CRecord::~CRecord()
{
    if(m_pClass)
        m_pClass->Release();
}

HRESULT CImplicationList::CRecord::ImproveKnown(_IWmiObject* pClass)
{
    if ( pClass == NULL )
    {
        //
        // not much we can improve on, but NULL is still a valid param.
        //
        return WBEM_S_NO_ERROR;
    }

    if(m_nNull == EVAL_VALUE_TRUE)
    {
        // Contradiction
        // =============

        return WBEM_E_TYPE_MISMATCH;
    }

    m_nNull = EVAL_VALUE_FALSE;

    ULONG lNumParents, lRecordNumParents;
    HRESULT hres = CoreGetNumParents(pClass, &lNumParents);
    if(FAILED(hres))
        return hres;

	if(m_pClass)
    {
		hres = CoreGetNumParents(m_pClass, &lRecordNumParents);
        if(FAILED(hres))
            return hres;
    }
    
    if(m_pClass == NULL || lNumParents > lRecordNumParents)
    {
        // Better than before. Check for inconsistencies
        // =============================================

        if(m_pClass)
        {
            if(!CoreIsDerived(pClass, m_pClass))
                return WBEM_E_TYPE_MISMATCH;
        }

        for(int i = 0; i < m_awsNotClasses.Size(); i++)
        {
            if(pClass->InheritsFrom(m_awsNotClasses[i]) == S_OK)
            {
                // Contradiction
                // =============

                return WBEM_E_TYPE_MISMATCH;
            }
        }

        // Replace
        // =======

        pClass->AddRef();
        if(m_pClass)
            m_pClass->Release();
        m_pClass = pClass;
    }
    else
    {
        // Verify that we are a parent of the selected and do not replace
        // ==============================================================

        if(!CoreIsDerived(m_pClass, pClass))
            return WBEM_E_TYPE_MISMATCH;
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CImplicationList::CRecord::ImproveKnownNot(LPCWSTR wszClassName)
{
    if(m_nNull == EVAL_VALUE_TRUE)
    {
        // Contradiction
        // =============

        return WBEM_E_TYPE_MISMATCH;
    }

    // Check for inconsistencies
    // =========================

    if(m_nNull == EVAL_VALUE_FALSE && m_pClass &&
        m_pClass->InheritsFrom(wszClassName) == S_OK)
    {
        // Contradiction
        // =============

        return WBEM_E_TYPE_MISMATCH;
    }

    try
    {
        if(m_awsNotClasses.Add(wszClassName) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    m_nNull = EVAL_VALUE_FALSE;
    return WBEM_S_NO_ERROR;
}
        
HRESULT CImplicationList::CRecord::ImproveKnownNull()
{
    if(m_nNull == EVAL_VALUE_FALSE)
    {
        return WBEM_E_TYPE_MISMATCH;
    }
    m_nNull = EVAL_VALUE_TRUE;

    return WBEM_S_NO_ERROR;
}

void CImplicationList::CRecord::Dump(FILE* f, int nOffset)
{
    LPWSTR wszProp = m_PropName.GetText();
    CEvalNode::PrintOffset(f, nOffset);
    fprintf(f, "Learn about %S:\n", wszProp);

    if(m_pClass)
    {
        VARIANT v;
        m_pClass->Get(L"__CLASS", 0, &v, NULL, NULL);
        CEvalNode::PrintOffset(f, nOffset+1);
        fprintf(f, "Is of class %S\n", V_BSTR(&v));
    }
    for(int i = 0; i < m_awsNotClasses.Size(); i++)
    {
        CEvalNode::PrintOffset(f, nOffset+1);
        fprintf(f, "Not of class %S\n", m_awsNotClasses[i]);
    }
    if(m_nNull == EVAL_VALUE_TRUE)
    {
        CEvalNode::PrintOffset(f, nOffset+1);
        fprintf(f, "Is NULL\n");
    }
}

CImplicationList::CImplicationList(long lFlags) 
    : m_lNextIndex(1), m_lRequiredDepth(1), m_pParent(NULL), m_lFlags(lFlags)
{
    CPropertyName Empty;
    CRecord* pRecord = new CRecord(Empty, 0);
    if(pRecord == NULL)
        throw CX_MemoryException();

    if(m_apRecords.Add(pRecord) < 0)
        throw CX_MemoryException();
}

CImplicationList::CImplicationList(CImplicationList& Other, bool bLink)
    : m_lNextIndex(Other.m_lNextIndex), 
        m_lRequiredDepth(Other.m_lRequiredDepth),
        m_pParent(NULL), m_lFlags(Other.m_lFlags)
{
    if(bLink)
        m_pParent = &Other;

    for(int i = 0; i < Other.m_apRecords.GetSize(); i++)
    {
        CRecord* pOtherRecord = Other.m_apRecords[i];
        CRecord* pNewRecord = new CRecord(*pOtherRecord);
        if(pNewRecord == NULL)
            throw CX_MemoryException();
            
        if(m_apRecords.Add(pNewRecord) < 0)
            throw CX_MemoryException();
    }
}

CImplicationList::~CImplicationList()
{
    m_lNextIndex = 0;
}

void CImplicationList::FindBestComputedContainer(CPropertyName* pPropName,
                                             long* plRecord, long* plMatched)
{
    // Look for the largest match
    // ==========================

    long lMax = -1;
    long lMaxRecord = -1;
    for(long lRecord = 0; lRecord < m_apRecords.GetSize(); lRecord++)
    {
        CRecord* pRecord = m_apRecords[lRecord];
        
        if ( pRecord->m_lObjIndex == -1 )
        {
            //
            // we only consider computed records
            //
            continue;
        }

        for(int i = 0; i < pPropName->GetNumElements() && 
                       i < pRecord->m_PropName.GetNumElements();
                i++)
        {
            if(wbem_wcsicmp(pPropName->GetStringAt(i), 
                        pRecord->m_PropName.GetStringAt(i)))
                break;
        }

        if(i > lMax)
        {
            lMax = i;
            lMaxRecord = lRecord;
        }
    }
    
    if(plRecord)
        *plRecord = lMaxRecord;
    if(plMatched)
        *plMatched = lMax;
}

HRESULT CImplicationList::FindRecordForProp(CPropertyName* pPropName,
                                             long lNumElements,
                                             long* plRecord)
{
    if(lNumElements == -1)
    {
        if(pPropName)
            lNumElements = pPropName->GetNumElements();
        else
            lNumElements = 0;
    }

    //
    // Look for the exact match
    //

    for(long lRecord = 0; lRecord < m_apRecords.GetSize(); lRecord++)
    {
        CRecord* pRecord = m_apRecords[lRecord];
        
        if(pRecord->m_PropName.GetNumElements() != lNumElements)
            continue;

        for(int i = 0; i < lNumElements; i++)
        {
            if(wbem_wcsicmp(pPropName->GetStringAt(i), 
                        pRecord->m_PropName.GetStringAt(i)))
                break;
        }

        if(i  == lNumElements)
        {
            break;
        }
    }
    
    if(lRecord < m_apRecords.GetSize())
    {
        // Found it!

        *plRecord = lRecord;
        return S_OK;
    }
    else
        return WBEM_E_NOT_FOUND;
}

HRESULT CImplicationList::FindBestComputedContainer(CPropertyName* pPropName,
            long* plFirstUnknownProp, long* plObjIndex, 
            RELEASE_ME _IWmiObject** ppContainerClass)
{
    if (!pPropName)
        return WBEM_E_FAILED;
    
    long lMax, lMaxRecord;
    FindBestComputedContainer(pPropName, &lMaxRecord, &lMax);
    if(lMaxRecord < 0)
        return WBEM_E_FAILED;

    if(plFirstUnknownProp)
        *plFirstUnknownProp = lMax;

    CRecord* pRecord = m_apRecords[lMaxRecord];
    if(plObjIndex)
        *plObjIndex = pRecord->m_lObjIndex;

    if(ppContainerClass)
    {
        *ppContainerClass = pRecord->m_pClass;
        if(pRecord->m_pClass)
            pRecord->m_pClass->AddRef();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CImplicationList::FindClassForProp(CPropertyName* pPropName,
            long lNumElements, RELEASE_ME _IWmiObject** ppClass)
{
    // don't have a property name? djinn one up for use...
    CPropertyName* pPropNameLocal;
    CPropertyName blank;
    
    if (pPropName)
        pPropNameLocal = pPropName;
    else
        pPropNameLocal = &blank;
    
    long lRecord;
    CRecord* pRecord;
    if(SUCCEEDED(FindRecordForProp(pPropNameLocal, -1, &lRecord)))
    {
        //
        // A record is there --- return its class
        //

        *ppClass = m_apRecords[lRecord]->m_pClass;
        if(*ppClass)
        {
            (*ppClass)->AddRef();
            return WBEM_S_NO_ERROR;
        }
        else
            return WBEM_E_NOT_FOUND;
    }
    else
        return WBEM_E_NOT_FOUND;
}
        
HRESULT CImplicationList::FindOrCreateRecordForProp(CPropertyName* pPropName, 
                                        CImplicationList::CRecord** ppRecord)
{
    // don't have a property name? djinn one up for use...
    CPropertyName* pPropNameLocal;
    CPropertyName blank;
    
    if (pPropName)
        pPropNameLocal = pPropName;
    else
        pPropNameLocal = &blank;
    
    long lRecord;
    CRecord* pRecord;
    if(SUCCEEDED(FindRecordForProp(pPropNameLocal, -1, &lRecord)))
    {
        //
        // A record is there --- improve it
        //

        pRecord = m_apRecords[lRecord];
    }
    else
    {
        try
        {
            pRecord = new CRecord(*pPropNameLocal, -1);
            if(pRecord == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }
        if(m_apRecords.Add(pRecord) < 0)
            return WBEM_E_OUT_OF_MEMORY;
    }

    *ppRecord = pRecord;
    return WBEM_S_NO_ERROR;
}

HRESULT CImplicationList::ImproveKnown(CPropertyName* pPropName, 
                                        _IWmiObject* pClass)
{   
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(pPropName, &pRecord);
    if(FAILED(hres))
        return hres;

    return pRecord->ImproveKnown(pClass);
}

HRESULT CImplicationList::ImproveKnownNot(CPropertyName* pPropName,
                                        LPCWSTR wszClassName)
{
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(pPropName, &pRecord);
    if(FAILED(hres))
        return hres;

    return pRecord->ImproveKnownNot(wszClassName);
}

HRESULT CImplicationList::ImproveKnownNull(CPropertyName* pPropName)
{
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(pPropName, &pRecord);
    if(FAILED(hres))
        return hres;

    return pRecord->ImproveKnownNull();
}
    
HRESULT CImplicationList::AddComputation(CPropertyName& PropName, 
                                _IWmiObject* pClass, long* plObjIndex)
{
    CRecord* pRecord;
    HRESULT hres = FindOrCreateRecordForProp(&PropName, &pRecord);
    if(FAILED(hres))
        return hres;

    if(pClass)
    {
        hres = pRecord->ImproveKnown(pClass);
        if(FAILED(hres))
            return hres;
    }

    pRecord->m_lObjIndex = m_lNextIndex;
    *plObjIndex = m_lNextIndex++;

    RequireDepth(m_lNextIndex);
    return WBEM_S_NO_ERROR;
}

long CImplicationList::GetRequiredDepth()
{
    return m_lRequiredDepth;
}

void CImplicationList::RequireDepth(long lDepth)
{
    if(lDepth > m_lRequiredDepth)
    {
        m_lRequiredDepth = lDepth;
        if(m_pParent)
            m_pParent->RequireDepth(lDepth);
    }
}

HRESULT CImplicationList::MergeIn(CImplicationList* pList)
{
    //
    // Add everything we learn from the second list into our own
    //

    HRESULT hres;
    for(int i = 0; i < pList->m_apRecords.GetSize(); i++)
    {
        CRecord* pRecord = pList->m_apRecords[i];

        hres = MergeIn(pRecord);
        if(FAILED(hres))
            return hres;
    }

    return S_OK;
}

HRESULT CImplicationList::MergeIn(CImplicationList::CRecord* pRecord)
{
    HRESULT hres;

    //
    // Add everything we learn from the record into our own list
    //

    if(pRecord->m_pClass)
    {
        hres = ImproveKnown(&pRecord->m_PropName, pRecord->m_pClass);
        if(FAILED(hres))
            return hres;
    }

    for(int i = 0; i < pRecord->m_awsNotClasses.Size(); i++)
    {
        hres = ImproveKnownNot(&pRecord->m_PropName, 
                                pRecord->m_awsNotClasses[i]);
        if(FAILED(hres))
            return hres;
    }

    if(pRecord->m_nNull == EVAL_VALUE_TRUE)
    {
        hres = ImproveKnownNull(&pRecord->m_PropName);
        if(FAILED(hres))
            return hres;
    }

    return WBEM_S_NO_ERROR;
}

    
void CImplicationList::Dump(FILE* f, int nOffset)
{
    for(int i = 0; i < m_apRecords.GetSize(); i++)
        m_apRecords[i]->Dump(f, nOffset);
}




//******************************************************************************
//******************************************************************************
//                  EVAL NODE
//******************************************************************************
//******************************************************************************
CEvalNode::CEvalNode()
{
#ifdef CHECK_TREES
	g_treeChecker.AddNode(this);
#endif
}

CEvalNode::CEvalNode(const CEvalNode& other)
{
#ifdef CHECK_TREES
	g_treeChecker.AddNode(this);
#endif
}

CEvalNode::~CEvalNode()
{
#ifdef CHECK_TREES
	g_treeChecker.RemoveNode(this);
#endif
}

void CEvalNode::PrintOffset(FILE* f, int nOffset)
{
    for(int i = 0; i < nOffset; i++)
    {
        fprintf(f, "   ");
    }
}

void CEvalNode::DumpNode(FILE* f, int nOffset, CEvalNode* pNode)
{
    if(pNode == NULL)
    {
        PrintOffset(f, nOffset);
        fprintf(f, "FALSE\n");
    }
    else pNode->Dump(f, nOffset);
}

CEvalNode* CEvalNode::CloneNode(const CEvalNode* pNode)
{
    if(pNode == NULL)
        return NULL;
    else
        return pNode->Clone();
}

bool CEvalNode::IsNoop(CEvalNode* pNode, int nOp)
{
    if(pNode)
        return pNode->IsNoop(nOp);
    else
        return CValueNode::IsNoop(NULL, nOp);
}

#ifdef CHECK_TREES
void CEvalNode::CheckNode(CTreeChecker *pCheck)
{
	pCheck->CheckoffNode(this);
}
#endif

//******************************************************************************
//******************************************************************************
//                  SORTED ARRAY
//******************************************************************************
//******************************************************************************

// construct from a 'normal' array
CSortedArray::CSortedArray(unsigned nElements, QueryID* pArray)  : CFlexArray(nElements)
{
    memcpy(GetArrayPtr(), pArray, nElements * sizeof(void*));
    SetSize(nElements);
}


int CSortedArray::CopyDataFrom(const QueryID* pArray, unsigned nElements)
{
    EnsureExtent(nElements);
    SetSize(nElements);

    memcpy(GetArrayPtr(), pArray, nElements * sizeof(void*));

    return nElements;
}


unsigned CSortedArray::Find(QueryID n)
{
    unsigned ret = InvalidID;

    // bailout if empty
    if(Size() == 0)
        return InvalidID;

    unsigned lBound = 0;
    unsigned uBound = Size() -1;
    
    // bailout checks - if it's on the boundary, don't search
    // if it's outside the boundaries, we ain't got it
    if (n == GetAt(uBound))
        ret = uBound;
    else if (n == GetAt(lBound))
        ret = lBound;
    else if ((n > GetAt(lBound)) && (n < GetAt(uBound)))
    {
        // binary search
        // warning: break in middle of loop
        do 
        {
            unsigned testBound = (lBound + uBound) / 2;

            if (n < GetAt(testBound))
                uBound = testBound;
            else if (n > GetAt(testBound))
                lBound = testBound;
            else
            {
                ret = testBound;
                break;
            }
        } while (lBound < uBound -1);
    }
    
    return ret;
}

// inserts n in proper position
// no dups allowed
void CSortedArray::Insert(QueryID n)
{
    // looks a lot like 'find'
    unsigned lBound = 0;
    unsigned uBound = Size() == 0 ? 0 : Size() -1;
    unsigned testBound = InvalidID;
    
    // check boundaries, empty array, out of bounds conditions...
    if ((Size() == 0) || (n < GetAt(lBound)))
        CFlexArray::InsertAt(0, (void *)n);
    else if (n > GetAt(uBound))
        Add(n);
    else if ((n != GetAt(uBound)) && (n != GetAt(lBound)))
    {
        // binary search
        // warning: break in middle of loop
        do 
        {
            testBound = (lBound + uBound) / 2;

            if (n < GetAt(testBound))
                uBound = testBound;
            else if (n > GetAt(testBound))
                lBound = testBound;
            else
                break;
        } while (lBound < uBound -1);

        // at this point, three cases:
        //  1) we found the item at testBound
        //  2) we didn't find it, uBound  = lBound +1
        //  3) we didn't find it, uBound == lBound
        if (n != GetAt(testBound))
        {
            if (n < GetAt(lBound))
                InsertAt(lBound, (void *)n);
            else
                InsertAt(uBound, (void *)n);
        }
    }
}

// removes element with value of n
// NOT the nth element
bool CSortedArray::Remove(QueryID n)
{
    unsigned index;
    index = Find(n);
    
    if (index != InvalidID)
    {
        CFlexArray::RemoveAt(index);
        return true;
    }
    else
        return false;
}

//returns zero if arrays are equivalent
// same number of USED elements w/ same values
// LEVN: changed to return < 0 if less, > 0  if more
int CSortedArray::Compare(CSortedArray& otherArray)
{
    int nCompare = Size() - otherArray.Size();
    if(nCompare)
        return nCompare;

    nCompare = memcmp(GetArrayPtr(), otherArray.GetArrayPtr(),
                      Size() * sizeof(void*));
    return nCompare;
}

// changes all QueryID's to begin at newBase
// e.g. if the array is {0,1,5}
// Rebase(6) will change to {6,7,11}
void CSortedArray::Rebase(QueryID newBase)
{
    for (int i = 0; i < Size(); i++)
        SetAt(i, (void *)(GetAt(i) + newBase));
}

// adds the values from the other array into this one
int CSortedArray::AddDataFrom(const CSortedArray& otherArray)
{
    // Check for emptiness
    if(otherArray.Size() == 0)
        return no_error;

    // Ensure there is enough room in our array for the union
    // ======================================================

    if(EnsureExtent(m_nSize + otherArray.m_nSize))
        return out_of_memory;
    
    // Start merging from the end
    // ==========================

    int nThisSourceIndex = m_nSize - 1;
    int nThisDestIndex = m_nSize + otherArray.m_nSize - 1;
    int nOtherIndex = otherArray.m_nSize - 1;
    while(nThisSourceIndex >= 0 && nOtherIndex >= 0)
    {
        int nCompare = 
            (QueryID)m_pArray[nThisSourceIndex] - (QueryID)otherArray[nOtherIndex];
        if(nCompare < 0)
        {
            m_pArray[nThisDestIndex--] = otherArray[nOtherIndex--];
        }
        else if(nCompare > 0)
        {
            m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];
        }
        else
        {
            m_pArray[nThisDestIndex--] = otherArray[nOtherIndex--];
            nThisSourceIndex--;
        }
    }

    // Add remainders
    // ==============

    while(nThisSourceIndex >= 0)
        m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];

    while(nOtherIndex >= 0)
        m_pArray[nThisDestIndex--] = otherArray[nOtherIndex--];

    // Move the array forward if needed
    // ================================

    if(nThisDestIndex >= 0)
    {
        for(int i = nThisDestIndex+1; i < m_nSize + otherArray.m_nSize; i++)
        {
            m_pArray[i-nThisDestIndex-1] = m_pArray[i];
        }
    }

    m_nSize = m_nSize + otherArray.m_nSize - (nThisDestIndex+1);
    return no_error;
}

// adds the values from the other array into this one
int CSortedArray::AddDataFrom(const QueryID* pOtherArray, unsigned nValues)
{
    // Check for emptiness
    if(nValues == 0)
        return no_error;

    // Ensure there is enough room in our array for the union
    // ======================================================

    if(EnsureExtent(m_nSize + nValues))
        return out_of_memory;
    
    // Start merging from the end
    // ==========================

    int nThisSourceIndex = m_nSize - 1;
    int nThisDestIndex = m_nSize + nValues - 1;
    int nOtherIndex = nValues - 1;
    while(nThisSourceIndex >= 0 && nOtherIndex >= 0)
    {
        int nCompare = 
            (QueryID)m_pArray[nThisSourceIndex] - (QueryID)pOtherArray[nOtherIndex];
        if(nCompare < 0)
        {
            m_pArray[nThisDestIndex--] = (void*)pOtherArray[nOtherIndex--];
        }
        else if(nCompare > 0)
        {
            m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];
        }
        else
        {
            m_pArray[nThisDestIndex--] = (void*)pOtherArray[nOtherIndex--];
            nThisSourceIndex--;
        }
    }

    // Add remainders
    // ==============

    while(nThisSourceIndex >= 0)
        m_pArray[nThisDestIndex--] = m_pArray[nThisSourceIndex--];

    while(nOtherIndex >= 0)
        m_pArray[nThisDestIndex--] = (void*)pOtherArray[nOtherIndex--];

    // Move the array forward if needed
    // ================================

    if(nThisDestIndex >= 0)
    {
        for(int i = nThisDestIndex+1; i < m_nSize + nValues; i++)
        {
            m_pArray[i-nThisDestIndex-1] = m_pArray[i];
        }
    }

    m_nSize = m_nSize + nValues - (nThisDestIndex+1);
    return no_error;
}

// copies this array to destination
// only copies size number of elements
// returns number of elements copied
unsigned CSortedArray::CopyTo(QueryID* pDest, unsigned size)
{
    unsigned mySize = Size();
    unsigned nElementsToCopy = min(size, mySize);

    if (nElementsToCopy) 
        memcpy(pDest, GetArrayPtr(), nElementsToCopy * sizeof(void*));

    return nElementsToCopy;
}


//******************************************************************************
//******************************************************************************
//                  VALUE NODE
//******************************************************************************
//******************************************************************************

CValueNode::CValueNode(int nNumValues) 
{
}

CValueNode::~CValueNode()
{
    // this page intentionally left blank
}

/* virtual */ int CValueNode::GetType()
{
    return EVAL_NODE_TYPE_VALUE;
}


// changes all QueryID's in all arrays to begin at newBase
// e.g. if the array is {0,1,5}
// Rebase(6) will change to {6,7,11}
void CValueNode::Rebase(QueryID newBase)
{
    for (int i = 0; i < m_nValues; i++)
        m_trueIDs[i] += newBase;
}
 

// returns array index of n
// or InvalidID if not found
unsigned CValueNode::FindQueryID(QueryID n)
{
    unsigned ret = InvalidID;

    if ( m_nValues == 0 )
    {
        return ret;
    }

    unsigned lBound = 0;
    unsigned uBound = m_nValues - 1;

    // bailout checks - if it's on the boundary, don't search
    // if it's outside the boundaries, we ain't got it
    if (n == m_trueIDs[uBound])
        ret = uBound;
    else if (n == m_trueIDs[lBound])
        ret = lBound;
    else if ((n > m_trueIDs[lBound]) && (n < m_trueIDs[uBound]))
    {
        // binary search
        // warning: break in middle of loop
        do 
        {
            unsigned testBound = (lBound + uBound) / 2;

            if (n < m_trueIDs[testBound])
                uBound = testBound;
            else if (n > m_trueIDs[testBound])
                lBound = testBound;
            else
            {
                ret = testBound;
                break;
            }
        } while (lBound < uBound -1);
    }

    return ret;
}

bool CValueNode::RemoveQueryID(QueryID nQuery)
{
    unsigned n;
    if ((n = FindQueryID(nQuery)) != InvalidID)
    {
        if ((m_nValues > 1) && (n != m_nValues -1))
            memcpy(&(m_trueIDs[n]), &(m_trueIDs[n+1]), (m_nValues -n -1) * sizeof(QueryID));
            
        if (m_nValues > 0)
            m_trueIDs[--m_nValues] = InvalidID;
    }
    return (n != InvalidID);
}

// combines two arrays, new array has all elements that appear in either
// BUT NOT in the corresponding NOT array
void CValueNode::ORarrays(CSortedArray& array1, CSortedArray& array1Not, 
                          CSortedArray& array2, CSortedArray& array2Not, 
                          CSortedArray& output)
{
    unsigned array1Index = 0;
    unsigned array2Index = 0;
    
    // walk through both arrays, always adding smallest value to new array
    while (array1Index < array1.Size() && array2Index < array2.Size())
    {
        if (array1.GetAt(array1Index) == array2.GetAt(array2Index))
        {
            // found match, add to array & bump up both cursors
            output.Add(array1.GetAt(array1Index));
            array1Index++; 
            array2Index++; 
        }
        else if (array2.GetAt(array2Index) < array1.GetAt(array1Index))
        {
            // add it, but only if it's NOT in the NOT array
            if (array2Not.Find(array2.GetAt(array2Index)) != InvalidID)
                output.Add(array2.GetAt(array2Index));
            array2Index++;
        }
        else
        {
            if (array1Not.Find(array1.GetAt(array1Index)) != InvalidID)
                output.Add(array1.GetAt(array1Index));
            array1Index++;
        }
    }

    // run out whichever array we didn't finish
    while (array1Index < array1.Size())
        if (array1Not.Find(array1.GetAt(array1Index)) != InvalidID)
            output.Add(array1.GetAt(array1Index++));

    while (array2Index < array2.Size())
        if (array2Not.Find(array2.GetAt(array2Index)) != InvalidID)
            output.Add(array2.GetAt(array2Index++));
}

void CValueNode::ORarrays(CSortedArray& array1,  
                          CSortedArray& array2,  
                          CSortedArray& output)
{
    unsigned array1Index = 0;
    unsigned array2Index = 0;
    
    // walk through both arrays, always adding smallest value to new array
    while (array1Index < array1.Size() && array2Index < array2.Size())
    {
        if (array1.GetAt(array1Index) == array2.GetAt(array2Index))
        {
            // found match, add to array & bump up both cursors
            output.Add(array1.GetAt(array1Index));
            array1Index++; 
            array2Index++; 
        }
        else if (array2.GetAt(array2Index) < array1.GetAt(array1Index))
        {
            // add it
            output.Add(array2.GetAt(array2Index));
            array2Index++;
        }
        else
        {
            output.Add(array1.GetAt(array1Index));
            array1Index++;
        }
    }

    // run out whichever array we didn't finish
    while (array1Index < array1.Size())
        output.Add(array1.GetAt(array1Index++));

    while (array2Index < array2.Size())
        output.Add(array2.GetAt(array2Index++));
}

// pointers point to arrays that are at the corresponding sizes
// caller is responsible for ensuring that the output array is large enough
// return value #elements inserted into new array;
unsigned CValueNode::ORarrays(QueryID* pArray1, unsigned size1,
                              QueryID* pArray2, unsigned size2, 
                              QueryID* pOutput)
{
    unsigned nElements = 0;

    // if ((pArray1 == NULL) && (pArray2 == NULL))
    //      really shouldn't happen - one side has should have come from this
    // else
    if (pArray2 == NULL)
    {
        nElements = size1;
        memcpy(pOutput, pArray1, sizeof(QueryID) * size1);
    }
    else if (pArray2 == NULL)
    {
        nElements = size1;
        memcpy(pOutput, pArray1, sizeof(QueryID) * size1);
    }
    else
    {    
        QueryID* pQID1 = pArray1;
        QueryID* pQID2 = pArray2;
        QueryID* pOut  = pOutput;

        // note that the 'ends' are really one past the end, careful now...
        QueryID* pEnd1 = pQID1 + size1;
        QueryID* pEnd2 = pQID2 + size2;

        // walk through both arrays, always adding smallest value to new array
        while ((pQID1 < pEnd1) && (pQID2 < pEnd2))
        {
            if (*pQID1 == *pQID2)
            {
                // found match, add to array & bump up both cursors
                *pOut++ = *pQID1++;
                pQID2++;
                nElements++;
            }
            else if (*pQID2 < *pQID1)
            {
                // add it
                *pOut++ = *pQID2++;
                nElements++;
            }
            else
            {
                // other side must be smaller, add IT.
                *pOut++ = *pQID1++;
                nElements++;
            }
        }

        // run out whichever array we didn't finish
        // only one should ever hit
        while (pQID1 < pEnd1)
        {
            *pOut++ = *pQID1++;
            nElements++;
        }
        while (pQID2 < pEnd2)
        {
            *pOut++ = *pQID2++;
            nElements++;
        }
    }

    return nElements;
}

void CValueNode::ANDarrays(CSortedArray& array1, CSortedArray& array2, CSortedArray& output)
{
        // going to march down both arrays
        // only put value in new array if it appears in both.
        unsigned array1Index = 0;
        unsigned array2Index = 0;

        while (array1Index < array1.Size() && array2Index < array2.Size())
        {
            if (array1.GetAt(array1Index) == array2.GetAt(array2Index))
            {
                // found match, add to array & bump up both cursors
                output.Add(array1.GetAt(array1Index));
                array1Index++; 
                array2Index++; 
            }
            else if (array1.GetAt(array1Index) > array2.GetAt(array2Index))
                array2Index++;
            else
                array1Index++;
        }
}

unsigned CValueNode::ANDarrays(QueryID* pArray1, unsigned size1,
                               QueryID* pArray2, unsigned size2, 
                               QueryID* pOutput)
{
    unsigned nElements = 0;
    
    if ((pArray1 != NULL) &&
        (pArray2 != NULL))
    {

        QueryID* pQID1 = pArray1;
        QueryID* pQID2 = pArray2;
        QueryID* pOut  = pOutput;

        // note that the 'ends' are really one past the end, careful now...
        QueryID* pEnd1 = pQID1 + size1;
        QueryID* pEnd2 = pQID2 + size2;

        // walk through both arrays, adding any values that appear in both
        while ((pQID1 < pEnd1) && (pQID2 < pEnd2))
        {
            if (*pQID1 == *pQID2)
            {
                // found match, add to array & bump up both cursors
                *pOut++ = *pQID1++;
                pQID2++;
                nElements++;
            }
            else if (*pQID2 < *pQID1)
                pQID2++;
            else
                pQID1++;
        }
    }

    return nElements;
}

void CValueNode::CombineArrays(CSortedArray& array1, CSortedArray& array2, CSortedArray& output)
{
    // march down both arrays
    unsigned array1Index = 0;
    unsigned array2Index = 0;

    while (array1Index < array1.Size() && array2Index < array2.Size())
    {
        if (array1.GetAt(array1Index) == array2.GetAt(array2Index))
        {
            // found match, add to array & bump up both cursors
            output.Add(array1.GetAt(array1Index));
            array1Index++; 
            array2Index++; 
        }
        else if (array1.GetAt(array1Index) > array2.GetAt(array2Index))
        {
            output.Add(array2.GetAt(array2Index));
            array2Index++;
        }
        else
        {
            output.Add(array1.GetAt(array1Index));            
            array1Index++;
        }
    }    
    // run out whichever array we didn't finish
    while (array1Index < array1.Size())
        output.Add(array1.GetAt(array1Index++));

    while (array2Index < array2.Size())
        output.Add(array2.GetAt(array2Index++));
}

unsigned CValueNode::CombineArrays(QueryID* pArray1, unsigned size1,
                                   QueryID* pArray2, unsigned size2, 
                                   QueryID* pOutput)
{
    unsigned nElements = 0;
    
    // if ((pArray1 == NULL) && (pArray2 == NULL))
    //      really shouldn't happen - one side has should have come from this
    // else
    if (pArray2 == NULL)
    {
        nElements = size1;
        memcpy(pOutput, pArray1, sizeof(QueryID) * size1);
    }
    else if (pArray1 == NULL)
    {
        nElements = size2;
        memcpy(pOutput, pArray2, sizeof(QueryID) * size2);
    }
    else
    {    
        QueryID* pQID1 = pArray1;
        QueryID* pQID2 = pArray2;
        QueryID* pOut  = pOutput;

        // note that the 'ends' are really one past the end, careful now...
        QueryID* pEnd1 = pQID1 + size1;
        QueryID* pEnd2 = pQID2 + size2;

        while ((pQID1 < pEnd1) && (pQID2 < pEnd2))
        {
            if (*pQID1 == *pQID2)
            {
                // found match, add to array & bump up both cursors
                *pOut++ = *pQID1++;
                pQID2++;
                nElements++;
            }
            else if (*pQID2 < *pQID1)
            {
                // add it
                *pOut++ = *pQID2++;
                nElements++;
            }
            else
            {
                // other side must be smaller, add IT.
                *pOut++ = *pQID1++;
                nElements++;
            }
       }    

        // run out whichever array we didn't finish
        // only one should ever hit
        while (pQID1 < pEnd1)
        {
            *pOut++ = *pQID1++;
            nElements++;
        }
        while (pQID2 < pEnd2)
        {
            *pOut++ = *pQID2++;
            nElements++;
        }
    }

    return nElements;
}

// size of new arrays is predicated on the assumption that
// there will usually be more TRUE nodes than INVALID ones
HRESULT CValueNode::CombineWith(CEvalNode* pRawArg2, int nOp, 
                            CContextMetaData* pNamespace, 
                            CImplicationList& Implications, 
                            bool bDeleteThis, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CValueNode* pArg2 = (CValueNode*)pRawArg2;

    // Check for immediate solutions
    // =============================

    if(nOp != EVAL_OP_AND)
    {
        if(IsAllFalse(pArg2) && bDeleteThis)
        {
            // Just return this!
            // =================
            
            *ppRes = this;
            if(bDeleteArg2)
                delete pArg2;
            return WBEM_S_NO_ERROR;
        }
        else if(IsAllFalse(this) && bDeleteArg2)
        {
            // Just return arg2!
            // =================
            
            *ppRes = pRawArg2;
            if(bDeleteThis)
                delete this;
            return WBEM_S_NO_ERROR;
        }
    }

    // if we got enough room in a stack array, we'll use that,
    // elsewise we'll allocate one from the heap
    const unsigned NewArraySize = 128;
    QueryID  newArray[NewArraySize];
    QueryID* pNewArray = newArray;
    CDeleteMe<QueryID> deleteMe;

    CValueNode* pNew;
    unsigned nElements;

    unsigned arg2Values;
    QueryID* arg2Array;
    if (pArg2)
    {
        arg2Values = pArg2->m_nValues;
        arg2Array  = pArg2->m_trueIDs; 
    }
    else
    {
        arg2Values = 0;
        arg2Array  = NULL; 
    }

    if (nOp == EVAL_OP_AND)
    {
        if (max(m_nValues, arg2Values) > NewArraySize)
        {
            pNewArray = new QueryID[max(m_nValues, arg2Values)];
            if(pNewArray == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            deleteMe = pNewArray;
        }
    
        nElements = ANDarrays(m_trueIDs, m_nValues, 
                              arg2Array, arg2Values, 
                              pNewArray);
    }
    // HMH: it sure looks to me like OR and COMBINE are the same for this case
    //      I'm too afraid to risk changing it, tho
    else if (nOp == EVAL_OP_OR)
    {
        if (max(m_nValues, arg2Values) > NewArraySize)
        {
            pNewArray = new QueryID[max(m_nValues, arg2Values)];
            if(pNewArray == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            deleteMe = pNewArray;
        }

        nElements = ORarrays(m_trueIDs, m_nValues, 
                             arg2Array, arg2Values, 
                             pNewArray);
    }
    else if ((nOp == EVAL_OP_COMBINE) || (nOp == EVAL_OP_INVERSE_COMBINE))
    {
        if ((m_nValues + arg2Values) > NewArraySize)
        {
            pNewArray = new QueryID[m_nValues + arg2Values];
            if(pNewArray == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            deleteMe = pNewArray;
        }

        nElements = CombineArrays(m_trueIDs, m_nValues, 
                                  arg2Array, arg2Values, 
                                  pNewArray);
    }

    // check to see if we can reuse a node, note this could result in the array 'shrinking'
    if (nElements == 0)
        *ppRes = NULL;
    else if (bDeleteThis && (nElements <= m_nValues))
    {
        *ppRes = this;
        memcpy(m_trueIDs, pNewArray, nElements * sizeof(QueryID));
        m_nValues = nElements;
        bDeleteThis = false;
    }
    else if (bDeleteArg2 && pArg2 && (nElements <= pArg2->m_nValues))
    {
        *ppRes = pArg2;
        memcpy(pArg2->m_trueIDs, pNewArray, nElements * sizeof(QueryID));
        pArg2->m_nValues = nElements;
        bDeleteArg2 = false;
    }
    else if (pNew = CreateNode(nElements))
    {   // can't reuse one, start a new one
        *ppRes = pNew;
        memcpy(pNew->m_trueIDs, pNewArray, nElements * sizeof(QueryID));
    }
    else
        hRes = WBEM_E_OUT_OF_MEMORY;

    // Delete what needed deletion
    // ===========================
    // deleteMe will take care of the array pointer if allocated
    if(bDeleteThis)
        delete this;
    if(bDeleteArg2)
        delete pArg2;

    return WBEM_S_NO_ERROR;
}    

//static 
bool CValueNode::IsNoop(CValueNode* pNode, int nOp)
{
    if(nOp == EVAL_OP_OR)
        return IsAllFalse(pNode);
    else if(nOp == EVAL_OP_AND)
        return false; // BUGBUG: would be nice to have IsAllTrue, but can't
    else if(nOp == EVAL_OP_COMBINE || nOp == EVAL_OP_INVERSE_COMBINE)
        return IsAllFalse(pNode);
    else 
    {
        //?
        return false;
    }
}
        

HRESULT CValueNode::TryShortCircuit(CEvalNode* pArg2, int nOp, 
                                    bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes)
{
    if(IsAllFalse(this))
    {
        if(nOp == EVAL_OP_AND)
        {
            // FALSE & X is FALSE
            if(bDeleteThis)
                *ppRes = this;
            else
            {
                *ppRes = Clone();
                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            if(bDeleteArg2)
                delete pArg2;
            return WBEM_S_NO_ERROR;
        }
        else // OR and COMBINE are identical in this case
        {
            // FALSE | X is X

            //
            // Well, this is true, but the problem is with optimizations.  
            // Some branches in X might not be valid under the implications in
            // this branch of the tree, and so need to be removed. For now, I
            // will simply turn off this short-circuiting path.  It may turn out
            // that there are some critical performance gains to be had by 
            // keeping it, in which case we would need to put this back and
            // make an efficient pass through it, checking branches.
            //
        
            return WBEM_S_FALSE;
/*
            if(bDeleteArg2)
                *ppRes = pArg2;
            else if (pArg2)
            {
                *ppRes = pArg2->Clone();
                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
                *ppRes = NULL;

            if(bDeleteThis)
                delete this;
            return WBEM_S_NO_ERROR;
*/
        }
    }
        
    return WBEM_S_FALSE;
}

HRESULT CValueNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode)
{
    //
    // Projection of a constant is, again, a constant
    //

    if(bDeleteThis)
    {
        *ppNewNode = this;
    }
    else
    {
        *ppNewNode = Clone();
        if(*ppNewNode == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    return S_OK;
}

CEvalNode* CValueNode::Clone() const
{
    
    CValueNode* pNew;
        
    if (pNew = CreateNode(m_nValues))
        memcpy(pNew->m_trueIDs, m_trueIDs, m_nValues * sizeof(QueryID));

    return pNew;
}

int CValueNode::Compare(CEvalNode* pRawOther)
{
    if (!pRawOther)
        return m_nValues;
    
    CValueNode* pOther = (CValueNode*)pRawOther;
    int nCompare = m_nValues - pOther->m_nValues;

    if ((nCompare == 0) && (m_nValues != 0))
        nCompare = memcmp(m_trueIDs, pOther->m_trueIDs, m_nValues * sizeof(QueryID));

    return nCompare;
}

CValueNode* CValueNode::GetStandardTrue()
{
    CValueNode* pNew = CreateNode(1);
    if(pNew)
        pNew->m_trueIDs[0] = 0;

    return pNew;
}

CValueNode* CValueNode::GetStandardInvalid()
{
    return new CInvalidNode;
}

/*static*/ CValueNode* CValueNode::CreateNode(size_t nNumValues)
{
    return new(nNumValues) CValueNode;
}

/*static*/ CValueNode* CValueNode::CreateNode(CSortedArray& values)
{
    CValueNode* pNode;
    
    pNode = new(values.Size()) CValueNode;
    if (pNode)
        values.CopyTo(pNode->m_trueIDs, values.Size());

    return pNode;
}

void* CValueNode::operator new( size_t stAllocateBlock, unsigned nEntries)
{
    void *pvTemp;
    if (pvTemp = ::new byte[ stAllocateBlock + ((nEntries ==0)? 0 : ((nEntries -1)* sizeof(QueryID)))] )
        ((CValueNode*)pvTemp)->m_nValues = nEntries;

    return pvTemp;
}

//    VC 5 only allows one delete operator per class
#if _MSC_VER >= 1200
void CValueNode::operator delete( void *p, unsigned nEntries )
{
    ::delete[] (byte*)p;
}
#endif


void CValueNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);
    fprintf(f, "TRUE: ");

    for (int i = 0; i < m_nValues; i++)
    {
        fprintf(f, "%u", m_trueIDs[i]);
        if(i < m_nValues-1)
            fprintf(f, ", %u", m_trueIDs[i]);
    }

    fprintf(f, "\n");
}
        

void CInvalidNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);
    fprintf(f, "Invalid node (0x%p)\n", this);
}
//******************************************************************************
//******************************************************************************
//                  EMBEDDING INFO
//******************************************************************************
//******************************************************************************
    
CEmbeddingInfo::CEmbeddingInfo()
: m_lNumJumps(0), m_aJumps(NULL), m_lStartingObjIndex(0)
{
}

CEmbeddingInfo::CEmbeddingInfo(const CEmbeddingInfo& Other)
: m_lNumJumps(0), m_aJumps(NULL), m_lStartingObjIndex(0) 
{
    *this = Other;
}

void CEmbeddingInfo::operator=(const CEmbeddingInfo& Other)
{
    m_EmbeddedObjPropName = Other.m_EmbeddedObjPropName;
    m_lNumJumps = Other.m_lNumJumps;
    m_lStartingObjIndex = Other.m_lStartingObjIndex;

    delete [] m_aJumps;

    if(m_lNumJumps > 0)
    {
        m_aJumps = new JumpInfo[m_lNumJumps];
        if (m_aJumps == NULL)
            throw CX_MemoryException();   
        memcpy(m_aJumps, Other.m_aJumps, m_lNumJumps * sizeof(JumpInfo));
    }
    else m_aJumps = NULL;
}

CEmbeddingInfo::~CEmbeddingInfo()
{
    delete [] m_aJumps;
}

bool CEmbeddingInfo::IsEmpty() const
{
    return (m_EmbeddedObjPropName.GetNumElements() == 0);
}

bool CEmbeddingInfo::SetPropertyNameButLast(const CPropertyName& Name)
{
    try
    {
        m_EmbeddedObjPropName.Empty();
        for(int i = 0; i < Name.GetNumElements() - 1; i++)
        {
            m_EmbeddedObjPropName.AddElement(Name.GetStringAt(i));
        }
        return true;
    }
    catch (CX_MemoryException)
    {
        return false;
    }
}

int CEmbeddingInfo::ComparePrecedence(const CEmbeddingInfo* pOther)
{
    if (pOther)
    {   
        int nCompare = m_EmbeddedObjPropName.GetNumElements() - 
                        pOther->m_EmbeddedObjPropName.GetNumElements();
        if(nCompare) return nCompare;
    
        for(int i = 0; i < m_EmbeddedObjPropName.GetNumElements(); i++)
        {
            nCompare = wbem_wcsicmp(m_EmbeddedObjPropName.GetStringAt(i),
                                pOther->m_EmbeddedObjPropName.GetStringAt(i));
            if(nCompare) return nCompare;
        }
    }

    return 0;
}

BOOL CEmbeddingInfo::operator==(const CEmbeddingInfo& Other)
{
    if(m_lStartingObjIndex != Other.m_lStartingObjIndex)
        return FALSE;
    if(m_lNumJumps != Other.m_lNumJumps)
        return FALSE;
    if(m_aJumps == NULL)
    {
        if(Other.m_aJumps == NULL)
            return TRUE;
        else
            return FALSE;
    }
    else
    {
        if(Other.m_aJumps == NULL)
            return FALSE;
        else
            return (memcmp(m_aJumps, Other.m_aJumps, 
                            m_lNumJumps * sizeof(JumpInfo)) == 0);
    }
}
    
HRESULT CEmbeddingInfo::Compile( CContextMetaData* pNamespace, 
                                 CImplicationList& Implications,
                                _IWmiObject** ppResultClass )
{
    HRESULT hres;

    long lFirstUnknownProp;
    _IWmiObject* pContainerClass;

    hres = Implications.FindBestComputedContainer( &m_EmbeddedObjPropName,
                                                   &lFirstUnknownProp, 
                                                   &m_lStartingObjIndex, 
                                                   &pContainerClass );

    if(FAILED(hres))
        return hres;

    int nNumEmbeddedJumps = m_EmbeddedObjPropName.GetNumElements();

    if(lFirstUnknownProp < nNumEmbeddedJumps)
    {
        // Not everything is already loaded
        // ================================

        delete [] m_aJumps;
        
        m_lNumJumps = nNumEmbeddedJumps - lFirstUnknownProp;
        m_aJumps = new JumpInfo[m_lNumJumps];
        if (!m_aJumps)
            return WBEM_E_OUT_OF_MEMORY;

        JumpInfo* pji = NULL;

        for(int i = lFirstUnknownProp; i < nNumEmbeddedJumps; i++)
        {
            if(pContainerClass == NULL)
                return WBEMESS_E_REGISTRATION_TOO_BROAD;

            // Get the handle of this property
            // ===============================

            CIMTYPE ct;

            pji = m_aJumps + i - lFirstUnknownProp;
            pji->lTarget = -1;

            hres = pContainerClass->GetPropertyHandleEx(
                (LPWSTR)m_EmbeddedObjPropName.GetStringAt(i), 0L, &ct,
                &pji->lJump );

            if(FAILED(hres) || ct != CIM_OBJECT)
            {
                // Invalid. Return 
                pContainerClass->Release();
                return WBEM_E_INVALID_PROPERTY;
            }

            //
            // Check if the implications know anything about the class name
            // for this property
            //

            _IWmiObject* pNewContainerClass = NULL;
            hres = Implications.FindClassForProp(&m_EmbeddedObjPropName,
                        i+1, &pNewContainerClass);
            if(FAILED(hres))
            {
                // 
                // Nothing implied --- have to go with the CIMTYPE qualifier
                //
            
                //
                // Get CIMTYPE qualifier
                // 
    
                CVar vCimtype;
                DWORD dwSize;
                hres = pContainerClass->GetPropQual(
                    (LPWSTR)m_EmbeddedObjPropName.GetStringAt(i), 
                    L"CIMTYPE", 0, 0, NULL, NULL, &dwSize, NULL);
                if(hres != WBEM_E_BUFFER_TOO_SMALL)
                    return WBEM_E_INVALID_PROPERTY;
    
                LPWSTR wszCimType = (LPWSTR)new BYTE[dwSize];
                if(wszCimType == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
                CVectorDeleteMe<BYTE> vdm((BYTE*)wszCimType);
    
                CIMTYPE ctQualType;
                hres = pContainerClass->GetPropQual(
                    (LPWSTR)m_EmbeddedObjPropName.GetStringAt(i), 
                    L"CIMTYPE", 0, dwSize, &ctQualType, NULL, &dwSize, 
                    wszCimType);
                if(FAILED(hres) || ctQualType != CIM_STRING)
                    return WBEM_E_INVALID_PROPERTY;
    

                //
                // Figure out what it references, if available
                //
    
                WCHAR* pwc = wcschr(wszCimType, L':');
                if(pwc)
                {
                    // Information about the class is available
                    // ========================================
    
                    hres = pNamespace->GetClass(pwc+1, &pNewContainerClass);
                    if(FAILED(hres))
                    {
                        return WBEM_E_INVALID_CIM_TYPE;
                    }
                }
            }

            pContainerClass->Release();
            pContainerClass = pNewContainerClass;
        }

        // Get a location for the result and store in the last jump info elem
        // ==================================================================
    
        Implications.AddComputation( m_EmbeddedObjPropName, 
                                     pContainerClass, 
                                     &pji->lTarget );
    }
    else
    {
        // Everything is covered
        // =====================

        delete [] m_aJumps;
        m_aJumps = NULL;
        m_lNumJumps = 0;
    }

    if(ppResultClass)
    {
        *ppResultClass = pContainerClass;
    }
    else
    {
        if(pContainerClass)
            pContainerClass->Release();
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEmbeddingInfo::GetContainerObject( CObjectInfo& ObjInfo, 
                                            INTERNAL _IWmiObject** ppInst)
{
    if( m_lNumJumps == 0 )
    {
        *ppInst = ObjInfo.GetObjectAt(m_lStartingObjIndex);
        return WBEM_S_NO_ERROR;
    }

    _IWmiObject* pCurrent = ObjInfo.GetObjectAt(m_lStartingObjIndex);
    pCurrent->AddRef();
    
    for(int i = 0; i < m_lNumJumps; i++)
    {
       _IWmiObject* pNew = NULL;
        HRESULT hres = pCurrent->GetPropAddrByHandle( m_aJumps[i].lJump, 0, NULL, ( void** )&pNew );

        if( FAILED( hres ) )
        {
            return hres;
        }
        
        pCurrent->Release();
        pCurrent = pNew;
        
        if(pNew == NULL)
        {
            *ppInst = pCurrent;
            return WBEM_S_FALSE;
        }

        //
        // save the object if required.
        //

        if ( m_aJumps[i].lTarget != -1 )
        {
            ObjInfo.SetObjectAt( m_aJumps[i].lTarget, pCurrent );
        }
    }

    *ppInst = pCurrent;
    return WBEM_S_NO_ERROR;
}

bool CEmbeddingInfo::AreJumpsRelated(const CEmbeddingInfo* pInfo)
{
    if ( !pInfo )
    {
        return false;
    }

    //
    // look through the targets of the info and see if we depend on any.
    //

    for( int i=0; i < pInfo->m_lNumJumps; i++ )
    {
        if ( pInfo->m_aJumps[i].lTarget == m_lStartingObjIndex )
        {
            return true;
        }
    }

    return false;
}

bool CEmbeddingInfo::MixInJumps(const CEmbeddingInfo* pInfo)
{
    //
    // Assumes AreJumpsRelated() has been called and returned TRUE.
    //

    m_lStartingObjIndex = pInfo->m_lStartingObjIndex;

    JumpInfo* aNewJumps = new JumpInfo[m_lNumJumps + pInfo->m_lNumJumps];
    if(aNewJumps == NULL)
        return false;

    if( pInfo->m_lNumJumps > 0 )
    {
        memcpy( aNewJumps, 
                pInfo->m_aJumps, 
                sizeof(JumpInfo)*(pInfo->m_lNumJumps) );
    }

    if( m_lNumJumps > 0 )
    {
        memcpy( aNewJumps + pInfo->m_lNumJumps, 
                m_aJumps, 
                sizeof(JumpInfo)*m_lNumJumps );
    }

    m_lNumJumps += pInfo->m_lNumJumps;

    delete [] m_aJumps;
    m_aJumps = aNewJumps;

    return true;
}


void CEmbeddingInfo::Dump(FILE* f)
{
    fprintf(f, "Name=");
    int i;
    for(i = 0; i < m_EmbeddedObjPropName.GetNumElements(); i++)
    {
        if(i != 0)
            fprintf(f, ".");
        fprintf(f, "%S", m_EmbeddedObjPropName.GetStringAt(i));
    }

    fprintf(f, ", Alg=%d -> (", m_lStartingObjIndex);
    for(i = 0; i < m_lNumJumps; i++)
    {
        if(i != 0)
            fprintf(f, ", ");
        fprintf(f, "0x%x : %d", m_aJumps[i].lJump, m_aJumps[i].lTarget );
    }
    fprintf(f, ")");
}
    
//******************************************************************************
//******************************************************************************
//                  BRANCHING NODE
//******************************************************************************
//******************************************************************************

CNodeWithImplications::CNodeWithImplications(const CNodeWithImplications& Other)
    : CEvalNode(Other), m_pExtraImplications(NULL)
{
    if(Other.m_pExtraImplications)
    {
        m_pExtraImplications = 
            new CImplicationList(*Other.m_pExtraImplications, false); // no link
        if(m_pExtraImplications == NULL)
            throw CX_MemoryException();
    }
}

void CNodeWithImplications::Dump(FILE* f, int nOffset)
{
    if(m_pExtraImplications)
        m_pExtraImplications->Dump(f, nOffset);
}

CBranchingNode::CBranchingNode() 
    : CNodeWithImplications(), m_pNullBranch(NULL), m_pInfo(NULL)
{
    m_pNullBranch = CValueNode::GetStandardFalse();
}

CBranchingNode::CBranchingNode(const CBranchingNode& Other, BOOL bChildren)
    : CNodeWithImplications(Other), m_pInfo(NULL)
{
    if (Other.m_pInfo)
    {
        m_pInfo = new CEmbeddingInfo(*(Other.m_pInfo));
        if(m_pInfo == NULL)
            throw CX_MemoryException();
    }

    int i;
    if(bChildren)
    {
        m_pNullBranch = (CBranchingNode*)CloneNode(Other.m_pNullBranch);
        if(m_pNullBranch == NULL && Other.m_pNullBranch != NULL)
            throw CX_MemoryException();

        for(i = 0; i < Other.m_apBranches.GetSize(); i++)
        {
            CBranchingNode* pNewBranch = 
                (CBranchingNode*)CloneNode(Other.m_apBranches[i]);

            if(pNewBranch == NULL && Other.m_apBranches[i] != NULL)
                throw CX_MemoryException();

            if(m_apBranches.Add(pNewBranch) < 0)
                throw CX_MemoryException();
        }
    }
    else
    {
        m_pNullBranch = CValueNode::GetStandardFalse();
    }
}

/* virtual */ int CBranchingNode::GetType()
{
    return EVAL_NODE_TYPE_BRANCH;
}

CBranchingNode::~CBranchingNode()
{
    delete m_pNullBranch;
    delete m_pInfo;
}

bool CBranchingNode::MixInJumps( const CEmbeddingInfo* pJump )
{            
    bool bRet;

    if ( !pJump )
    {
        return true;
    }

    //
    // we want to find the first node in the tree that is related to the 
    // ancestor embedding info. If this node is related, then we mix in the
    // jumps and return.  If not, then we propagate the info down the tree.
    // 
    
    if ( m_pInfo )
    {
        if ( m_pInfo->AreJumpsRelated( pJump ) )
        {
            return m_pInfo->MixInJumps( pJump );
        }
    }

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if ( CEvalNode::GetType(m_apBranches[i]) == EVAL_NODE_TYPE_BRANCH )
        {
            if ( !((CBranchingNode*)m_apBranches[i])->MixInJumps( pJump ) )
            {
                return false;
            }
        }
    }

    return true;
}

bool CBranchingNode::SetEmbeddedObjPropName(CPropertyName& Name) 
{ 
    try
    {
        if (!m_pInfo)
        {
            m_pInfo = new CEmbeddingInfo;
            if(m_pInfo == NULL)
                return false;
        }
    
        m_pInfo->SetEmbeddedObjPropName(Name);
        return true;
    }
	catch (CX_MemoryException)
	{
		return false;
	}
}

void CBranchingNode::SetNullBranch(CEvalNode* pBranch)
{
    delete m_pNullBranch;
    m_pNullBranch = pBranch;
}

DELETE_ME CBranchIterator* CBranchingNode::GetBranchIterator()
{
    return new CDefaultBranchIterator(this);
}

int CBranchingNode::ComparePrecedence(CBranchingNode* pArg1, 
                                        CBranchingNode* pArg2)
{
    int nCompare;
    nCompare = pArg1->GetSubType() - pArg2->GetSubType();
    if(nCompare) return nCompare;

    // Compare embedding specs
    // =======================

    if (pArg1->m_pInfo && pArg2->m_pInfo) 
    {
        nCompare = pArg1->m_pInfo->ComparePrecedence(pArg2->m_pInfo);
        if(nCompare) return nCompare;
    }
    else if (pArg2->m_pInfo)
        return -1;
    else if (pArg1->m_pInfo)
        return 1;


    // Embedding are the same --- compare lower levels
    // ===============================================

    return pArg1->ComparePrecedence(pArg2);
}
    
DWORD CBranchingNode::ApplyPredicate(CLeafPredicate* pPred)
{
    DWORD dwRes;
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if(m_apBranches[i] == NULL)
            dwRes = (*pPred)(NULL);
        else
            dwRes = m_apBranches[i]->ApplyPredicate(pPred);

        if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
        {
            m_apBranches.SetAt(i, NULL);
            dwRes &= ~WBEM_DISPOSITION_FLAG_DELETE;
        }

        if(dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE)
        {
            m_apBranches.SetAt(i, CValueNode::GetStandardInvalid());
            dwRes &= ~WBEM_DISPOSITION_FLAG_INVALIDATE;
        }

        if(dwRes == WBEM_DISPOSITION_STOPLEVEL)
            return WBEM_DISPOSITION_NORMAL;
        if(dwRes == WBEM_DISPOSITION_STOPALL)
            return dwRes;
    }

    if(m_pNullBranch)
		dwRes = m_pNullBranch->ApplyPredicate(pPred);
	else
		dwRes = (*pPred)(NULL);

    if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
    {
        delete m_pNullBranch;
        m_pNullBranch = NULL;
        dwRes &= ~WBEM_DISPOSITION_FLAG_DELETE;
    }
    if(dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE)
    {
        delete m_pNullBranch;
        m_pNullBranch = CValueNode::GetStandardInvalid();
        dwRes &= ~WBEM_DISPOSITION_FLAG_INVALIDATE;
    }

    if(dwRes == WBEM_DISPOSITION_STOPALL)
        return dwRes;
        
    return WBEM_DISPOSITION_NORMAL;
}
        
HRESULT CBranchingNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter, EProjectionType eType, 
                            bool bDeleteThis, CEvalNode** ppNewNode) 
{ 
	HRESULT hres;

    try
    {
        //
        // Record what we learn by even getting here
        //
    
        CImplicationList TheseImplications(Implications);
        if(GetExtraImplications())
        {
            hres = TheseImplications.MergeIn(GetExtraImplications());
            if(FAILED(hres))
                return hres;
        }
    
        // BUGBUG: we could be more efficient and not clone the node when 
        // bDeleteThis is not specified. 
    
        CBranchingNode* pNew; 
        if(bDeleteThis) 
        {
            pNew = this;
        }
        else
        {
            pNew = (CBranchingNode*)Clone();
            if(pNew == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        // BUGBUG: it is not always necessary to project all children.  Could be
        // more efficient, but can't find the perfect algorithm...
        
        //
        // Project all our children
        //
    
        CBranchIterator* pit = pNew->GetBranchIterator();
        if(pit == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CDeleteMe<CBranchIterator> dm(pit);
    
        while(pit->IsValid())
        {
            if(CEvalNode::IsInvalid(pit->GetNode()))
                continue;
    
            CImplicationList BranchImplications(TheseImplications);
            pit->RecordBranch(pMeta, BranchImplications);
    
            CEvalNode* pNewBranch;
            hres = CEvalTree::Project(pMeta, BranchImplications, 
                                    pit->GetNode(), pFilter, eType, 
                                    true, &pNewBranch);
            if(FAILED(hres))
                return hres;
            pit->SetNode(pNewBranch); // old one already deleted
    
            pit->Advance();
        }
    
        //
        // Determine if this is an "in" node for this filter
        //
    
        bool bIn = pFilter->IsInSet(this);
    
        if(bIn)
        {
            //
            // For nodes martching the filter that's it --- both necessary and
            // sufficient conditions are simply projections of what's below
            //
    
            *ppNewNode = pNew;
        }
        else
        {
            //
            // The node does not match the filter.  Now is when the difference
            // between sufficient and necessary conditions applies
            //
    
            int nBranchOp;
            if(eType == e_Sufficient)
            {
                //
                // For a condition to be sufficient for the truth of the entire
                // node, it should appear in every single branch of the node.
                // Therefore, we must AND all the branches together. Except for 
                // invalid ones --- they can't happen, so we can omit them from 
                // the analysis
                //
            
                nBranchOp = EVAL_OP_AND;
            }
            else if(eType == e_Necessary)
            {
                //
                // For a condition to be necessary for this node, it has to 
                // appear in at least one branch.  Therefore, we must OR all 
                // the branches together.  Except for invalid ones.
                //
    
                nBranchOp = EVAL_OP_OR;
            }
            else
                return WBEM_E_INVALID_PARAMETER;
    
            //  
            // Perform the needed operation on them all
            //
                
            CBranchIterator* pitInner = pNew->GetBranchIterator();
            if(pitInner == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            CDeleteMe<CBranchIterator> dm(pitInner);
    
            //
            // Merge all of the, in, one at a time, deleting them as we go.  
            // It is safe to delete them always, since we cloned the entire node
            // in the beginning if deletion was not allowed.
            //
    
            CEvalNode* pCombination = NULL;
            bool bInited = false;
            while(pitInner->IsValid())
            {
                if(CEvalNode::IsInvalid(pitInner->GetNode()))
                    continue;
    
                if(bInited)
                {
                    hres = CEvalTree::Combine(pCombination, pitInner->GetNode(), 
                                                nBranchOp,
                                                pMeta, Implications, 
                                                true, true, &pCombination);
                    if(FAILED(hres))
                        return hres;
                }
                else
                {
                    pCombination = pitInner->GetNode();
                    bInited = true;
                }
    
                pitInner->SetNode(NULL);
                pitInner->Advance();
            }
    
            if(!bInited)
            {
                // 
                // No valid nodes??
                //
    
                pCombination = CValueNode::GetStandardInvalid();
            }
    
            //
            // The combination is it.
            //
    
            *ppNewNode = pCombination;
            delete pNew;
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    return S_OK;
}
            
        
int CBranchingNode::Compare(CEvalNode* pRawOther)
{
    CBranchingNode* pOther = (CBranchingNode*)pRawOther;

    int nCompare;
    nCompare = GetSubType() - pOther->GetSubType();
    if(nCompare) return nCompare;

    // First, compare embeddings
    // =========================

    if(m_pInfo == NULL && pOther->m_pInfo != NULL)
        return -1;

    if(m_pInfo != NULL && pOther->m_pInfo == NULL)
        return 1;

    if(m_pInfo != NULL && pOther->m_pInfo != NULL)
    {
        nCompare = m_pInfo->ComparePrecedence(pOther->m_pInfo);
        if(nCompare)
            return nCompare;
    }

    if(m_apBranches.GetSize() != pOther->m_apBranches.GetSize())
        return m_apBranches.GetSize() - pOther->m_apBranches.GetSize();

    // Then, compare derived portions
    // ==============================

    nCompare = SubCompare(pOther);
    if(nCompare)
        return nCompare;

    // Finally, compare children
    // =========================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        nCompare = CEvalTree::Compare(m_apBranches[i], pOther->m_apBranches[i]);
        if(nCompare)
            return nCompare;
    }

    return 0;
}

HRESULT CBranchingNode::CombineWith(CEvalNode* pRawArg2, int nOp, 
                                    CContextMetaData* pNamespace, 
                                    CImplicationList& Implications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes)
{
    CBranchingNode* pArg2 = (CBranchingNode*)pRawArg2;
    HRESULT hres;

    // Compare arguments for precedence
    // ================================

    int nCompare = ComparePrecedence(this, pArg2);
    if(nCompare < 0)
    {
        // Put pArg1 first and continue
        // ============================

        hres = CombineInOrderWith(pArg2, nOp, 
            pNamespace, Implications, bDeleteThis, bDeleteArg2, ppRes);
    }
    else if(nCompare > 0)
    {
        // Put pArg2 first and continue (reverse delete indicators!!)
        // ==========================================================

        hres = pArg2->CombineInOrderWith(this, FlipEvalOp(nOp), 
            pNamespace, Implications, bDeleteArg2, bDeleteThis, ppRes);
    }
    else
    {
        // They are about the same property. Combine lookup lists.
        // =======================================================

        hres = CombineBranchesWith(pArg2, nOp, pNamespace, Implications, 
                                    bDeleteThis, bDeleteArg2, ppRes);
    }

    return hres;
}

HRESULT CBranchingNode::CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes)
{
    HRESULT hres;
	CBranchingNode* pNew = NULL;

	if(bDeleteThis)
	{
		pNew = this;
	}
	else
	{
		// 
		// I'd like to clone self here, but can't because there is no 
		// such virtual method.  Something to be improved, perhaps
		//

		pNew = (CBranchingNode*)Clone();
		if(pNew == NULL)
			return WBEM_E_OUT_OF_MEMORY;
	}

    try
    {
        CImplicationList Implications(OrigImplications);
        hres = pNew->AdjustCompile(pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    
        //
        // Maintain a counter telling us whether any invalid branches (that 
        // cannot occur under these implications) were detected.  If so, we 
        // need to re-optimize this node
        //
    
        bool bInvalidBranchesDetected = false;
    
        for(int i = 0; i < m_apBranches.GetSize(); i++)
        {
            CEvalNode* pNewBranch = NULL;
            
            CImplicationList BranchImplications(Implications);
            hres = RecordBranch(pNamespace, BranchImplications, i);
            if(SUCCEEDED(hres))
            {
                // Always delete the branch --- if bDeleteThis, we should, and
                // if not, we cloned it!
    
                hres = CEvalTree::Combine(pNew->m_apBranches[i], pArg2, nOp, 
                    pNamespace, BranchImplications, true, false, &pNewBranch);
                if(FAILED(hres))
                {
                    delete pNew;
                    return hres;
                }
                pNew->m_apBranches.Discard(i);
            }
            else
            {
                pNewBranch = CValueNode::GetStandardInvalid();
                bInvalidBranchesDetected = true;
            }
            
            pNew->m_apBranches.SetAt(i, pNewBranch);
        }
    
        CEvalNode* pNewBranch = NULL;
        CImplicationList BranchImplications(Implications);
        hres = RecordBranch(pNamespace, BranchImplications, -1);
    
        if(SUCCEEDED(hres))
        {
            //
            // Always delete the branch --- if bDeleteThis, we should, and
            // if not, we cloned it!
            //

            hres = CEvalTree::Combine(pNew->GetNullBranch(), pArg2, nOp, 
                pNamespace, BranchImplications, true, false, &pNewBranch);
            if(FAILED(hres))
            {
                delete pNew;
                return hres;
            }
            pNew->m_pNullBranch = NULL;
        }
        else
        {
            pNewBranch = CValueNode::GetStandardInvalid();
            bInvalidBranchesDetected = true;
        }
    
        pNew->SetNullBranch(pNewBranch);
    
        if(bDeleteArg2)         
            delete pArg2;
    
        //
        // If invalid branches were cut, re-optimize
        //
    
        if(bInvalidBranchesDetected)
        {
            HRESULT hr = pNew->Optimize(pNamespace, ppRes);
    
            if (*ppRes != pNew)
                delete pNew;
    
            return hr;
        }
        else
        {
            *ppRes = pNew;
            return WBEM_S_NO_ERROR;
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

BOOL CBranchingNode::AreAllSame(CEvalNode** apNodes, int nSize, 
                                int* pnFoundIndex) 
{
    BOOL bFoundTwo = FALSE;

    *pnFoundIndex = -1;
    CEvalNode* pFound = NULL;    

    for(int i = 0; i < nSize; i++)
    {
        // ignore invalid nodes --- they don't count
        if(CEvalNode::IsInvalid(apNodes[i]))
            continue;

        if(*pnFoundIndex == -1)
        {
            //
            // This is the first valid chils this node has. Record it --- it 
            // might be the only one
            //

            *pnFoundIndex = i;
            pFound = apNodes[i];
        }
        else if(CEvalTree::Compare(apNodes[i], pFound) != 0)
        {
            bFoundTwo = TRUE;
            break;
        }
    }

    return !bFoundTwo;
}

HRESULT CBranchingNode::StoreBranchImplications(CContextMetaData* pNamespace,
                            int nBranchIndex, CEvalNode* pResult)
{
    if(pResult)
    {
        CImplicationList* pBranchImplications = NULL;
        try
        {
            pBranchImplications = new CImplicationList;
            if(pBranchImplications == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

        HRESULT hres = RecordBranch(pNamespace, *pBranchImplications, 
                                        nBranchIndex);
        if(FAILED(hres))
		{
			delete pBranchImplications;
            return hres;
		}

        if(pBranchImplications->IsEmpty())
        {
            // Nothing useful to say!
            delete pBranchImplications;
            pBranchImplications = NULL;
        }

        pResult->SetExtraImplications(pBranchImplications); // acquires
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CBranchingNode::Optimize(CContextMetaData* pNamespace, 
                                CEvalNode** ppNew)
{
    int i;
    HRESULT hres;

    // Optimize all branches
    // =====================

    for(i = 0; i < m_apBranches.GetSize(); i++)
    {
        if(m_apBranches[i])
        {
            CEvalNode* pNew = NULL;
            m_apBranches[i]->Optimize(pNamespace, &pNew);
            if(pNew != m_apBranches[i])
            {
                m_apBranches.SetAt(i, pNew);
            }
        }
    }

    if(CEvalNode::GetType(m_pNullBranch) == EVAL_NODE_TYPE_BRANCH)
    {
        CEvalNode* pNew;
        ((CBranchingNode*)m_pNullBranch)->Optimize(pNamespace, &pNew);
        if(pNew != m_pNullBranch)
        {
            SetNullBranch(pNew);
        }
    }


    // Self-optimize
    // =============

    OptimizeSelf();

    // Count the number of branches
    // ============================

    int nFoundIndex = -1;
    
    BOOL bFoundTwo = !AreAllSame(m_apBranches.GetArrayPtr(), 
        m_apBranches.GetSize(), &nFoundIndex);

    if(bFoundTwo)
    {
        *ppNew = this;
        return WBEM_S_NO_ERROR;
    }

    if(nFoundIndex == -1)
    {

        if(CEvalNode::IsInvalid(m_pNullBranch))
        {
            //
            // Totally invalid, the whole lot
            //

            *ppNew = m_pNullBranch;
            m_pNullBranch = NULL;
        }
        else
        {
            //
            // There are no valid branches, except for the NullBranch.
            // We can replace ourselves with the NullBranch
            //

            *ppNew = m_pNullBranch;
			m_pNullBranch = NULL;

            //
            // Now, we need to copy
            // the branch implications into the "extras".  This is because
            // the information about which branch was taken in this test is
            // critical to the compilation of the lower nodes --- it tells them
            // about the classes of some of our embedded objects.
            //

            hres = StoreBranchImplications(pNamespace, -1, *ppNew);
            if(FAILED(hres))
                return hres;
           
            //
            // since this node is going away, mix in the embedding info it 
            // has with the child node. 
            //

            if ( CEvalNode::GetType(*ppNew) == EVAL_NODE_TYPE_BRANCH )
            {
                CBranchingNode* pBranchNode = (CBranchingNode*)*ppNew;
                if(!pBranchNode->MixInJumps( m_pInfo ))
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else 
    {
        //
        // There is one valid branch in the regular list.  Two hopes: that the
        // NullBranch is invalid, or that it is the same as the only valid 
        // branch in the regular list
        //

        if(CEvalNode::IsInvalid(m_pNullBranch) || 
            CEvalTree::Compare(m_pNullBranch, m_apBranches[nFoundIndex]) == 0)
        {
            //
            // Hurray.  We could replace ourselves with the remaining branch.
            //

            m_apBranches.SetAt(nFoundIndex, NULL, ppNew);

            //
            // Now, we need to copy
            // the branch implications into the "extras".  This is because
            // the information about which branch was taken in this test is
            // critical to the compilation of the lower nodes --- it tells them
            // about the classes of some of our embedded objects.
            //

            hres = StoreBranchImplications(pNamespace, nFoundIndex, *ppNew);
            if(FAILED(hres))
                return hres;

            //
            // since this node is going away, mix in the embedding info it 
            // has with the child node. 
            //

            if ( CEvalNode::GetType(*ppNew) == EVAL_NODE_TYPE_BRANCH )
            {
                CBranchingNode* pBranchNode = (CBranchingNode*)*ppNew;
                if(!pBranchNode->MixInJumps( m_pInfo ))
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else
        {
            *ppNew = this;
        }
        return WBEM_S_NO_ERROR;
    }
    return WBEM_S_NO_ERROR;
}


void CBranchingNode::Dump(FILE* f, int nOffset)
{
    CNodeWithImplications::Dump(f, nOffset);
    if (m_pInfo)
    {
        PrintOffset(f, nOffset);
        fprintf(f, "Embedding: ");
        m_pInfo->Dump(f);
        fprintf(f, "\n");
    }
}
        


//******************************************************************************
//******************************************************************************
//                         PROPERTY NODE
//******************************************************************************
//******************************************************************************
    
bool CPropertyNode::SetPropertyInfo(LPCWSTR wszPropName, long lPropHandle)
{
    m_lPropHandle = lPropHandle;
    try
    {
        m_wsPropName = wszPropName;
    }
	catch (CX_MemoryException)
	{
		return false;
	}
    return true;
}

int CPropertyNode::ComparePrecedence(CBranchingNode* pOther)
{
    CPropertyNode* pOtherNode = (CPropertyNode*)pOther;
    return m_lPropHandle - pOtherNode->m_lPropHandle;
}

bool CPropertyNode::SetEmbeddingInfo(const CEmbeddingInfo* pInfo)
{
    try
    {
        if ((pInfo == NULL) || (pInfo->IsEmpty()))
        {
            delete m_pInfo;
            m_pInfo = NULL;
        }
        else if (!m_pInfo)
        {
            m_pInfo = new CEmbeddingInfo(*pInfo);
            if(m_pInfo == NULL)
                return false;
        }
        else
            *m_pInfo = *pInfo;
    }
	catch (CX_MemoryException)
	{
		return false;
	}

    return true;
}

HRESULT CPropertyNode::SetNullTest(int nOperator)
{
    if(nOperator == QL1_OPERATOR_EQUALS)
    {
        if(m_apBranches.Add(CValueNode::GetStandardFalse()) < 0)
            return WBEM_E_OUT_OF_MEMORY;

        CEvalNode* pTrue = CValueNode::GetStandardTrue();
        if(pTrue == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        SetNullBranch(pTrue);
    }
    else if(nOperator == QL1_OPERATOR_NOTEQUALS)
    {
        CEvalNode* pTrue = CValueNode::GetStandardTrue();
        if(pTrue == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        if(m_apBranches.Add(pTrue) < 0)
        {
            delete pTrue;
            return WBEM_E_OUT_OF_MEMORY;
        }

        SetNullBranch(CValueNode::GetStandardFalse());
    }
    else
        return WBEM_E_INVALID_QUERY;

    return WBEM_S_NO_ERROR;
}

HRESULT CPropertyNode::SetOperator(int nOperator)
{
    m_apBranches.RemoveAll();

    #define GET_STD_TRUE CValueNode::GetStandardTrue()
    #define GET_STD_FALSE CValueNode::GetStandardFalse()

    #define ADD_STD_TRUE  {CEvalNode* p = GET_STD_TRUE; \
        if(p == NULL) return WBEM_E_OUT_OF_MEMORY; \
        if(m_apBranches.Add(p) < 0) {delete p; return WBEM_E_OUT_OF_MEMORY;}}

    #define ADD_STD_FALSE {CEvalNode* p = GET_STD_FALSE; \
        if(m_apBranches.Add(p) < 0) {delete p; return WBEM_E_OUT_OF_MEMORY;}}
        
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        break;

    case QL1_OPERATOR_NOTEQUALS:
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        break;

    case QL1_OPERATOR_LESS:
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        ADD_STD_FALSE;
        break;
        
    case QL1_OPERATOR_GREATER:
        ADD_STD_FALSE;
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        break;
    
    case QL1_OPERATOR_LESSOREQUALS:
        ADD_STD_TRUE;
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        break;

    case QL1_OPERATOR_GREATEROREQUALS:
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        ADD_STD_TRUE;
        break;

    case QL1_OPERATOR_LIKE:
        ADD_STD_TRUE;
        ADD_STD_FALSE;
        break;

    case QL1_OPERATOR_UNLIKE:
        ADD_STD_FALSE;
        ADD_STD_TRUE;
        break;

    default:
        return WBEM_E_CRITICAL_ERROR;
    }

    return WBEM_S_NO_ERROR;
}


//******************************************************************************
//******************************************************************************
//                  STRING PROPERTY NODE
//******************************************************************************
//******************************************************************************

CStringPropNode::CStringPropNode(const CStringPropNode& Other, BOOL bChildren)
    : CFullCompareNode<CInternalString>(Other, bChildren)
{
}

CStringPropNode::~CStringPropNode()
{
}


HRESULT CStringPropNode::Evaluate(CObjectInfo& ObjInfo, 
                                    INTERNAL CEvalNode** ppNext)
{
    *ppNext = NULL;
    
    HRESULT hres;
    _IWmiObject* pObj;
    
    hres = GetContainerObject(ObjInfo, &pObj);
    if( S_OK != hres ) 
    {
        return hres;
    }

    // Get the property from the object
    // ================================

    CCompressedString* pcs = CoreGetPropertyString(pObj, m_lPropHandle);
    CInternalString is;
    if(pcs == NULL)
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    is.AcquireCompressedString(pcs);

    // Search for the value
    // ====================

    TTestPointIterator it;
    bool bMatch = m_aTestPoints.Find(is, &it);
    if(bMatch)
        *ppNext = it->m_pAt;
    else if(it == m_aTestPoints.End())
        *ppNext = m_pRightMost;
    else
        *ppNext = it->m_pLeftOf;

    is.Unbind();

    return WBEM_S_NO_ERROR;
}

void CStringPropNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);

    PrintOffset(f, nOffset);
    fprintf(f, "LastPropName = (0x%x)\n", m_lPropHandle);

    for(TConstTestPointIterator it = m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++)
    {
        PrintOffset(f, nOffset);
        if (it != m_aTestPoints.Begin())
        {
            TConstTestPointIterator itPrev(it);
            itPrev--;
            fprintf(f, "%s < ", itPrev->m_Test.GetText());
        }
        fprintf(f, "X < %s\n", it->m_Test.GetText());
        DumpNode(f, nOffset +1, it->m_pLeftOf);

        PrintOffset(f, nOffset);
        fprintf(f, "X = %s\n", it->m_Test.GetText());
        DumpNode(f, nOffset +1, it->m_pAt);
    }

    PrintOffset(f, nOffset);
    if (it != m_aTestPoints.Begin())
    {
        TConstTestPointIterator itPrev(it);
        itPrev--;
        fprintf(f, "X > %s\n", itPrev->m_Test.GetText());
    }
    else
        fprintf(f, "ANY\n");
    DumpNode(f, nOffset+1, m_pRightMost);

    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}

/*****************************************************************************
  CLikeStringPropNode
******************************************************************************/

CLikeStringPropNode::CLikeStringPropNode( const CLikeStringPropNode& Other, 
                                          BOOL bChildren )
: CPropertyNode( Other, bChildren )
{
    m_Like = Other.m_Like;
}

int CLikeStringPropNode::ComparePrecedence( CBranchingNode* pRawOther )
{
    int nCompare = CPropertyNode::ComparePrecedence( pRawOther );
    
    if( nCompare )
    {
        return nCompare;
    }

    CLikeStringPropNode* pOther = (CLikeStringPropNode*)pRawOther;

    return _wcsicmp( m_Like.GetExpression(), pOther->m_Like.GetExpression() );
}

int CLikeStringPropNode::SubCompare( CEvalNode* pRawOther )
{
    int nCompare;

    CLikeStringPropNode* pOther = (CLikeStringPropNode*)pRawOther;

    _DBG_ASSERT( m_apBranches.GetSize() == 2 );
    _DBG_ASSERT( pOther->m_apBranches.GetSize() == 2 );

    nCompare = CEvalTree::Compare( m_apBranches[0], pOther->m_apBranches[0] );

    if ( nCompare )
    {
        return nCompare;
    }

    nCompare = CEvalTree::Compare( m_apBranches[1], pOther->m_apBranches[1] );
    
    if ( nCompare )
    {
        return nCompare;
    }

    return CEvalTree::Compare( m_pNullBranch, pOther->m_pNullBranch );

}

HRESULT CLikeStringPropNode::Evaluate( CObjectInfo& ObjInfo,
                                       CEvalNode** ppNext )
{
    *ppNext = NULL;

    HRESULT hr;

    //
    // get the string value.
    //

    _IWmiObject* pObj;
    hr = GetContainerObject( ObjInfo, &pObj );

    if( S_OK != hr )
    {
        return hr;
    }

    CCompressedString* pcs = CoreGetPropertyString( pObj, m_lPropHandle );

    //
    // if null, then simply take null branch.
    //

    if( pcs == NULL )
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    CInternalString is;
    is.AcquireCompressedString(pcs);

    WString ws = is;

    //
    // run through like filter.  take branch accordingly. 
    //

    if ( m_Like.Match( ws ) )
    {
        *ppNext = m_apBranches[0];
    }
    else
    {
        *ppNext = m_apBranches[1];
    }

    is.Unbind();

    return WBEM_S_NO_ERROR;
}


HRESULT CLikeStringPropNode::SetTest( VARIANT& v )
{
    if ( V_VT(&v) != VT_BSTR )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    try
    {
        m_Like.SetExpression( V_BSTR(&v) );
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CLikeStringPropNode::CombineBranchesWith( 
                                       CBranchingNode* pRawArg2, 
                                       int nOp, 
                                       CContextMetaData* pNamespace, 
                                       CImplicationList& Implications,
                                       bool bDeleteThis, 
                                       bool bDeleteArg2,
                                       CEvalNode** ppRes )
{
    HRESULT hres;
    *ppRes = NULL;
    
    CLikeStringPropNode* pArg2 = (CLikeStringPropNode*)pRawArg2;
    
    if ( !bDeleteThis )
    {
        return ((CLikeStringPropNode*)Clone())->CombineBranchesWith(
            pRawArg2, nOp, pNamespace, Implications, true, // reuse clone!
            bDeleteArg2, ppRes );
    }

    CEvalNode* pNew = NULL;

    //
    // merge the 'match' branches
    //

    hres = CEvalTree::Combine( m_apBranches[0], pArg2->m_apBranches[0], nOp, 
                               pNamespace, Implications, true, bDeleteArg2, 
                               &pNew );
    if(FAILED(hres))
        return hres;

    m_apBranches.Discard( 0 );
    m_apBranches.SetAt( 0, pNew );

    if( bDeleteArg2 )
    {
        pArg2->m_apBranches.Discard( 0 );
    }

    //
    // merge the 'nomatch' branches
    //

    hres = CEvalTree::Combine( m_apBranches[1], pArg2->m_apBranches[1], nOp, 
                               pNamespace, Implications, true, bDeleteArg2, 
                               &pNew );
    if(FAILED(hres))
        return hres;

    m_apBranches.Discard( 1 );
    m_apBranches.SetAt( 1, pNew );

    if( bDeleteArg2 )
    {
        pArg2->m_apBranches.Discard( 1 );
    }

    //
    // merge the 'null' branches
    //

    hres = CEvalTree::Combine( m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                               pNamespace, Implications, true, bDeleteArg2, 
                               &pNew );
    if(FAILED(hres))
        return hres;

    m_pNullBranch = pNew;

    if( bDeleteArg2 )
        pArg2->m_pNullBranch = NULL;

    //
    // Delete what needs deleting
    //

    if(bDeleteArg2)
        delete pArg2;
    
    *ppRes = this;
    return WBEM_S_NO_ERROR;
}

HRESULT CLikeStringPropNode::OptimizeSelf()
{
    _DBG_ASSERT( m_apBranches.GetSize() == 2 );

    return WBEM_S_NO_ERROR;
}
        
void CLikeStringPropNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);

    PrintOffset(f, nOffset);
    fprintf(f, "LastPropName = (0x%x)\n", m_lPropHandle);

    PrintOffset( f, nOffset );
    fprintf(f, "Like Expression : %S\n", m_Like.GetExpression() );

    PrintOffset( f, nOffset );
    fprintf(f, "Match : \n" );
    DumpNode(f, nOffset+1, m_apBranches[0] );

    PrintOffset( f, nOffset );
    fprintf(f, "NoMatch : \n" );
    DumpNode(f, nOffset+1, m_apBranches[1] );

    PrintOffset( f, nOffset );
    fprintf(f, "NULL : \n" );
    DumpNode(f, nOffset+1, m_pNullBranch );
}


//******************************************************************************
//******************************************************************************
//                  INHERITANCE NODE
//******************************************************************************
//******************************************************************************

CInheritanceNode::CInheritanceNode() 
    : m_lDerivationIndex(-1),
        m_lNumPoints(0), m_apcsTestPoints(NULL)
{
    // Add a none-of-the-above node
    // ============================

    m_apBranches.Add(CValueNode::GetStandardFalse());
}

CInheritanceNode::CInheritanceNode(const CInheritanceNode& Other, 
                                    BOOL bChildren)
    : CBranchingNode(Other, bChildren), 
        m_lDerivationIndex(Other.m_lDerivationIndex)
{
    m_lNumPoints = Other.m_lNumPoints;
    m_apcsTestPoints = new CCompressedString*[m_lNumPoints];
    if(m_apcsTestPoints == NULL)
        throw CX_MemoryException();

    for(int i = 0; i < m_lNumPoints; i++)
    {
        m_apcsTestPoints[i] = (CCompressedString*)
            _new BYTE[Other.m_apcsTestPoints[i]->GetLength()];

        if(m_apcsTestPoints[i] == NULL)
            throw CX_MemoryException();

        memcpy((void*)m_apcsTestPoints[i],
                (void*)Other.m_apcsTestPoints[i], 
                Other.m_apcsTestPoints[i]->GetLength());
    }
}

/* virtual */ long CInheritanceNode::GetSubType()
{
    return EVAL_NODE_TYPE_INHERITANCE;
}

CInheritanceNode::~CInheritanceNode()
{
	RemoveAllTestPoints();
}

void CInheritanceNode::RemoveAllTestPoints()
{
    for(int i = 0; i < m_lNumPoints; i++)
    {
        delete [] (BYTE*)m_apcsTestPoints[i];
    }
    delete [] m_apcsTestPoints;
	m_apcsTestPoints = NULL;
}

bool CInheritanceNode::SetPropertyInfo(CContextMetaData* pNamespace, 
                                        CPropertyName& PropName)
{
    return SetEmbeddedObjPropName(PropName);
}

HRESULT CInheritanceNode::AddClass(CContextMetaData* pNamespace, 
                                    LPCWSTR wszClassName, CEvalNode* pDestination)
{
    HRESULT hres;

    // Get the class from the namespace
    // ================================

    _IWmiObject* pObj = NULL;
    hres = pNamespace->GetClass(wszClassName, &pObj);
    if(FAILED(hres)) 
        return hres;

    hres = AddClass(pNamespace, wszClassName, pObj, pDestination);
    pObj->Release();
    return hres;
}

HRESULT CInheritanceNode::AddClass(CContextMetaData* pNamespace, 
                                    LPCWSTR wszClassName, _IWmiObject* pClass,
                                    CEvalNode* pDestination)
{
    // Get the number of items in its derivation --- that's the index where we
    // need to look for its name in its children
    // =======================================================================

    ULONG lDerivationIndex;
    HRESULT hRes = CoreGetNumParents(pClass, &lDerivationIndex);
    if (FAILED (hRes))
        return hRes;

    if(m_lDerivationIndex == -1)
    {
        // We don't have a currently set derivation index --- this is the first
        // ====================================================================

        m_lDerivationIndex = lDerivationIndex;
    }
    else if(m_lDerivationIndex != lDerivationIndex)
    {
        // Can't add this class --- derivation index mismatch
        // ==================================================

        return WBEM_E_FAILED;
    }

    // Allocate a compressed string
    // ============================

    int nLength = CCompressedString::ComputeNecessarySpace(wszClassName);
    CCompressedString* pcs = (CCompressedString*)new BYTE[nLength];
    if (pcs)
        pcs->SetFromUnicode(wszClassName);
    else
        return WBEM_E_OUT_OF_MEMORY;

    // Extend the lists by one
    // =======================

    CCompressedString** apcsNewTestPoints = 
        new CCompressedString*[m_lNumPoints+1];
    if (!apcsNewTestPoints)
        return WBEM_E_OUT_OF_MEMORY;

    // Insert it into the list of tests and the list of branches
    // =========================================================

    int i = 0;
    while(i < m_lNumPoints && pcs->CheapCompare(*m_apcsTestPoints[i]) > 0)
    {
        apcsNewTestPoints[i] = m_apcsTestPoints[i];
        i++;
    }

    apcsNewTestPoints[i] = pcs;
    m_apBranches.InsertAt(i+1, pDestination);

    while(i < m_lNumPoints)
    {
        apcsNewTestPoints[i+1] = m_apcsTestPoints[i];
    }
        
    // Set the new list
    // ================

    delete [] m_apcsTestPoints;
    m_apcsTestPoints = apcsNewTestPoints;
    m_lNumPoints++;

    return WBEM_S_NO_ERROR;
}

HRESULT CInheritanceNode::RecordBranch(CContextMetaData* pNamespace, 
                             CImplicationList& Implications, long lBranchIndex)
{
    HRESULT hres = WBEM_S_NO_ERROR;
    if(lBranchIndex == -1)
    {
        // Recording NULL branch
        // =====================

        hres = Implications.ImproveKnownNull(GetEmbeddedObjPropName());
    }
    else if(lBranchIndex == 0)
    {
        // Recording none of the above branch
        // ==================================

        for(int i = 0; i < m_lNumPoints; i++)
        {
            LPWSTR wszClassName = NULL;
            try
            {
                wszClassName = 
                    m_apcsTestPoints[i]->CreateWStringCopy().UnbindPtr();
            }
	        catch (CX_MemoryException)
	        {
                return WBEM_E_OUT_OF_MEMORY;
	        }
           
            if(wszClassName == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            CVectorDeleteMe<WCHAR> vdm(wszClassName);

            hres = Implications.ImproveKnownNot(GetEmbeddedObjPropName(), 
                                                wszClassName);
            if(FAILED(hres))
            {
                // Contradicts known information --- fail recording
                // ================================================

                return hres;
            }
        }
    }
    else
    {
        // Normal branch --- record the class
        // ==================================

        BSTR strClassName = m_apcsTestPoints[lBranchIndex - 1]->
                                CreateBSTRCopy();
        _IWmiObject* pObj = NULL;
        hres = pNamespace->GetClass(strClassName, &pObj);
        SysFreeString(strClassName);
        if(FAILED(hres))
            return hres;

        hres = Implications.ImproveKnown(GetEmbeddedObjPropName(), pObj);
        pObj->Release();
    }
    
    return hres;
}

int CInheritanceNode::ComparePrecedence(CBranchingNode* pOther)
{
    CInheritanceNode* pInhOther = (CInheritanceNode*)pOther;
    return (m_lDerivationIndex - pInhOther->m_lDerivationIndex);
}

int CInheritanceNode::SubCompare(CEvalNode* pOther)
{
    CInheritanceNode* pInhOther = (CInheritanceNode*)pOther;
    int nCompare;

    nCompare = m_lDerivationIndex - pInhOther->m_lDerivationIndex;
    if(nCompare)
        return nCompare;

    nCompare = m_lNumPoints - pInhOther->m_lNumPoints;
    if(nCompare)
        return nCompare;

    for(int i = 0; i < m_lNumPoints; i++)
    {
        nCompare = m_apcsTestPoints[i]->CompareNoCase(
                                    *pInhOther->m_apcsTestPoints[i]);
        if(nCompare)
            return nCompare;
    }

    return 0;
}
    
void CInheritanceNode::RemoveTestPoint(int i)
{
    delete [] m_apcsTestPoints[i];
    memcpy((void*)(m_apcsTestPoints + i), 
           (void*)(m_apcsTestPoints + i + 1),
            sizeof(CCompressedString*) * (m_lNumPoints - i - 1));
    m_lNumPoints--;
}

HRESULT CInheritanceNode::OptimizeSelf()
{
    for(int i = 0; i < m_lNumPoints; i++)
    {
        // Compare this branch to the "nothing" branch
        // ===========================================

        if(CEvalNode::IsInvalid(m_apBranches[i+1]) ||
            CEvalTree::Compare(m_apBranches[0], m_apBranches[i+1]) == 0)
        {
            RemoveTestPoint(i);
            m_apBranches.RemoveAt(i+1);
            i--;
            continue;
        }

        // Check if this node is another class check on the same object
        // ============================================================

        if(CEvalNode::GetType(m_apBranches[i+1]) != EVAL_NODE_TYPE_BRANCH)
            continue;
        CBranchingNode* pBranch = (CBranchingNode*)(m_apBranches[i+1]);
        if(pBranch->GetSubType() == EVAL_NODE_TYPE_INHERITANCE &&
            pBranch->GetEmbeddedObjPropName() == GetEmbeddedObjPropName())
        {
            // If the "none-of-the-above" branch of this child is the same
            // as the "none-of-the-above" branch of ourselves, we can replace
            // our "none-of-the-above" branch with this node, since anything
            // that is falling under none-of-the-above now will fall under
            // none-of-the-above of our child (otherwise there is an 
            // optimization flaw in the child). 
            // IMPORTANT: this will no longer be true if we change the 
            // precedence order of inheritance nodes!!!

            if(CEvalTree::Compare(m_apBranches[0], pBranch->GetBranches()[0])
                == 0)
            {
                m_apBranches.SetAt(0, pBranch);
                m_apBranches.GetArrayPtr()[i+1] = NULL;
                m_apBranches.RemoveAt(i+1);
                RemoveTestPoint(i);
                i--;
            }
        }        
    }

    return S_OK;
}

HRESULT CInheritanceNode::Optimize(CContextMetaData* pNamespace, 
                                    CEvalNode** ppNew)
{
    // Delegate to the normal branch optimization process
    // ==================================================

    *ppNew = NULL;
    HRESULT hres = CBranchingNode::Optimize(pNamespace, ppNew);
    if(FAILED(hres) || *ppNew != this)
        return hres;

    // Specific post-processing
    // ========================

    if(m_apBranches.GetSize() == 1)
    {
        // We are reduced to checking for NULL. If our non-NULL branch is
        // talking about the same property, push the test there.
        // ==============================================================

        if (CEvalNode::GetType(m_apBranches[0]) != EVAL_NODE_TYPE_BRANCH)
            return hres;

        CBranchingNode* pBranch = (CBranchingNode*)(m_apBranches[0]);
        if(pBranch && pBranch->GetSubType() == EVAL_NODE_TYPE_INHERITANCE &&
            pBranch->GetEmbeddedObjPropName() == GetEmbeddedObjPropName())
        {
            pBranch->SetNullBranch(m_pNullBranch);
            pBranch->Optimize(pNamespace, ppNew);
            if(*ppNew != pBranch)
                m_apBranches.RemoveAll();
            else
                m_apBranches.GetArrayPtr()[0] = NULL;

            m_pNullBranch = NULL;

            return S_OK;
        }
    }

    return S_OK;
}

HRESULT CInheritanceNode::Evaluate(CObjectInfo& ObjInfo, 
                                    INTERNAL CEvalNode** ppNext)
{
    _IWmiObject* pInst;
    HRESULT hres = GetContainerObject(ObjInfo, &pInst);
    if(FAILED(hres)) return hres;
    if(pInst == NULL)
    {
        *ppNext = m_pNullBranch;
        return WBEM_S_NO_ERROR;
    }

    // Get the parent at the right index
    // =================================
    
    CCompressedString* pcs;
    ULONG lNumParents;
    HRESULT hRes = CoreGetNumParents(pInst, &lNumParents);
    if (FAILED(hRes))
        return hRes;
        
    if(lNumParents < m_lDerivationIndex)
    {
        if (m_apBranches.GetSize())
            *ppNext = m_apBranches[0];
        else
            *ppNext = NULL;
        return WBEM_S_NO_ERROR;
    }
    else if(lNumParents == m_lDerivationIndex)
    {
        pcs = CoreGetClassInternal(pInst);
    }
    else
    {        
        pcs = CoreGetParentAtIndex(pInst, m_lDerivationIndex);
    }

    if(pcs == NULL)
    {
        //
        // This class does not even have that long an ancestry --- clearly
        // not derived from any of those
        //

        if (m_apBranches.GetSize())
            *ppNext = m_apBranches[0];
        else
            *ppNext = NULL;

        return WBEM_S_NO_ERROR;
    }

    
    // Search for the value
    // ====================

    long lLeft = -1;
    long lRight = m_lNumPoints;
    while(lRight > lLeft + 1)
    {
        long lMiddle = (lRight + lLeft) >> 1;
        int nCompare = pcs->CheapCompare(*m_apcsTestPoints[lMiddle]);
        if(nCompare < 0)
        {
            lRight = lMiddle;
        }
        else if(nCompare > 0)
        {
            lLeft = lMiddle;
        }
        else
        {
            *ppNext = m_apBranches[lMiddle+1];
            return WBEM_S_NO_ERROR;
        }
    }

    if (m_apBranches.GetSize())
        *ppNext = m_apBranches[0];
    else
        *ppNext = NULL;

    return WBEM_S_NO_ERROR;
}

HRESULT CInheritanceNode::Compile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
{
    if (!m_pInfo)
    {
        m_pInfo = new CEmbeddingInfo;
        if(m_pInfo == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }

    HRESULT hres = CompileEmbeddingPortion(pNamespace, Implications, NULL);
    return hres;
}

// Computes preliminary parameters for merging two inheritance nodes at the
// same level --- which children will be used, and how many times.
HRESULT CInheritanceNode::ComputeUsageForMerge(CInheritanceNode* pArg2, 
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
											bool bDeleteThis, bool bDeleteArg2,
											DWORD* pdwFirstNoneCount,
											DWORD* pdwSecondNoneCount,
											bool* pbBothNonePossible)
{
	HRESULT hres;

	*pdwFirstNoneCount = 0;
	*pdwSecondNoneCount = 0;
	*pbBothNonePossible = false;

    try
    {
        CImplicationList Implications(OrigImplications);
    
        BOOL bFirstNonePossible, bSecondNonePossible;
    
        CImplicationList NoneImplications(Implications);
        hres = RecordBranch(pNamespace, NoneImplications, 0);
        if(FAILED(hres))
        {	
            bFirstNonePossible = FALSE;
            bSecondNonePossible = 
                SUCCEEDED(pArg2->RecordBranch(pNamespace, NoneImplications, 0));
        }
        else
        {
            bFirstNonePossible = TRUE;
            hres = pArg2->RecordBranch(pNamespace, NoneImplications, 0);
            if(FAILED(hres))
            {
                // Check if the second one can survive in isolation
                // ================================================
    
                CImplicationList NoneImplications1(Implications);
                bSecondNonePossible = 
                   SUCCEEDED(pArg2->RecordBranch(pNamespace, NoneImplications1, 0));
            }
            else
            {
                bSecondNonePossible = TRUE;
            }
        }
    
        if(bFirstNonePossible && bSecondNonePossible)
        {
            //
            // Both of them will be used at least once: with each other!
            //
    
            *pdwFirstNoneCount = *pdwSecondNoneCount = 1;
            *pbBothNonePossible = true;
        }
    
        //
        // If we are not deleting something, the usage count should be infinite!
        //
    
        if(!bDeleteThis)
            *pdwFirstNoneCount = 0xFFFFFFFF;
        if(!bDeleteArg2)
            *pdwSecondNoneCount = 0xFFFFFFFF;
        //
        // Merge lookup lists
        // 
    
        long lFirstIndex = 0;
        long lSecondIndex = 0;
    
        while(lFirstIndex < m_lNumPoints || lSecondIndex < pArg2->m_lNumPoints)
        {
            //
            // Retrieve the test points from both lists and compare them,
            // taking care of boundary conditions
            //
    
            int nCompare;
            CCompressedString* pcsFirstVal = NULL;
            CCompressedString* pcsSecondVal = NULL;
    
            if(lFirstIndex == m_lNumPoints)
            {
                nCompare = 1;
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
            }
            else if(lSecondIndex == pArg2->m_lNumPoints)
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                nCompare = -1;
            }
            else
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
                nCompare = pcsFirstVal->CheapCompare(*pcsSecondVal);
            }
    
            if(nCompare < 0)
            {
                //
                // At this index is the first value combined with second none
                // 
    
                if(!bDeleteArg2) // not interesting
                {
                    lFirstIndex++;
                    continue;
                }
                if(!bSecondNonePossible)
                {
                    lFirstIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 
                                        lFirstIndex+1)))
                {
                    lFirstIndex++;
                    continue;
                }
                if(FAILED(pArg2->RecordBranch(pNamespace, BranchImplications, 0)))
                {
                    lFirstIndex++;
                    continue;
                }
                
                (*pdwSecondNoneCount)++;
                lFirstIndex++;
            }
            else if(nCompare > 0)
            {
                // At this index is the second value combined with first none
                // ==========================================================
    
                if(!bDeleteThis) // not interesting
                {
                    lSecondIndex++;
                    continue;
                }
    
                if(!bFirstNonePossible)
                {
                    lSecondIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(pArg2->RecordBranch(pNamespace, BranchImplications, 
                                        lSecondIndex+1)))
                {
                    lSecondIndex++;
                    continue;
                }
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 0)))
                {
                    lSecondIndex++;
                    continue;
                }
                
                (*pdwFirstNoneCount)++;
                lSecondIndex++;
            }
            else
            {
                // At this index is the combinations of the ats
                // ============================================
                            
                lFirstIndex++;
                lSecondIndex++;
            }
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

	return S_OK;
}


HRESULT CInheritanceNode::CombineBranchesWith(CBranchingNode* pRawArg2, int nOp,
                                            CContextMetaData* pNamespace, 
                                            CImplicationList& OrigImplications,
                                            bool bDeleteThis, bool bDeleteArg2,
                                            CEvalNode** ppRes)
{
    HRESULT hres;

    CInheritanceNode* pArg2 = (CInheritanceNode*)pRawArg2;

    if(!bDeleteThis && bDeleteArg2)
    {
        // It is easier to combine in the other direction
        // ==============================================

        return pArg2->CombineBranchesWith(this, FlipEvalOp(nOp), pNamespace,
                        OrigImplications, bDeleteArg2, bDeleteThis, ppRes);
    }

    try
    {
        // Either clone or use our node
        // ============================
    
        CInheritanceNode* pNew = NULL;
        if(bDeleteThis)
        {
            pNew = this;
        }
        else
        {
            // Clone this node without cloning the branches.
            // =============================================
    
            pNew = (CInheritanceNode*)CloneSelf();
            if(pNew == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        CImplicationList Implications(OrigImplications);
        hres = pNew->AdjustCompile(pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    
        //
        // Get overall information
        //
    
        DWORD dwFirstNoneCount, dwSecondNoneCount;
        bool bBothNonePossible;
    
        hres = ComputeUsageForMerge(pArg2, pNamespace, Implications, 
                    bDeleteThis, bDeleteArg2,
                    &dwFirstNoneCount, &dwSecondNoneCount,
                    &bBothNonePossible);
        if(FAILED(hres))
        {
            if(!bDeleteThis)
                delete pNew;
            return hres;
        }
    
        bool bFirstNonePossible = (dwFirstNoneCount > 0);
        bool bSecondNonePossible = (dwSecondNoneCount > 0);
    
        //
        // Allocate a new array of test points and a new array of branches.  We 
        // can't use the ones in pNew because we are using some of the 
        // elements in those arrays in this many times and don't want to trample
        // them (since pNew and this might be the same).  Therefore, we create 
        // and fill these arrays outside of the node and then place them into 
        // pNew when we are done.
        //
        // As we delete the child nodes in the Branches array, we will set them
        // to NULL so that we can clear the branch array in the end
        //
    
        CCompressedString** apcsTestPoints = 
            new CCompressedString*[m_lNumPoints + pArg2->m_lNumPoints];                                               
        if(apcsTestPoints == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    
        CUniquePointerArray<CEvalNode> apBranches;
    
        //
        // Merge none-of-the-above branches
        // 
    
        if(bBothNonePossible)
        {
            //
            // They have to be merged
            //
    
            CImplicationList NoneImplications(Implications);
            hres = RecordBranch(pNamespace, NoneImplications, 0);
            if(FAILED(hres))
                return hres;
            hres = pArg2->RecordBranch(pNamespace, NoneImplications, 0);
            if(FAILED(hres))
                return hres;
    
            //
            // We may delete our None nodes if and only if there predicted usage
            // count (adjusted for usage that has already occurred) is dropping
            // to 0 --- that is, noone will use these nodes further during this
            // merge
            //
    
            CEvalNode* pNone = NULL;
            bool bDeleteFirstBranch = (--dwFirstNoneCount == 0);
            bool bDeleteSecondBranch = (--dwSecondNoneCount == 0);
            CEvalTree::Combine(m_apBranches[0], pArg2->m_apBranches[0], nOp, 
                                pNamespace, NoneImplications, bDeleteFirstBranch, 
                                bDeleteSecondBranch, &pNone);
            if(bDeleteSecondBranch)
                pArg2->m_apBranches.Discard(0);
            if(bDeleteFirstBranch)
                m_apBranches.Discard(0);
    
            if(apBranches.Add(pNone) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
        else
        {
            //
            // Since both none is not possible, we set this branch to FALSE
            //
    
            if(apBranches.Add(NULL) < 0)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        //
        // Merge lookup lists
        // 
    
        long lFirstIndex = 0;
        long lSecondIndex = 0;
        long lNewIndex = 0;
    
        while(lFirstIndex < m_lNumPoints || lSecondIndex < pArg2->m_lNumPoints)
        {
            //
            // Retrieve the test points from both lists and compare them,
            // taking care of boundary conditions
            //
    
            int nCompare;
            CCompressedString* pcsFirstVal = NULL;
            CCompressedString* pcsSecondVal = NULL;
    
            if(lFirstIndex == m_lNumPoints)
            {
                nCompare = 1;
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
            }
            else if(lSecondIndex == pArg2->m_lNumPoints)
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                nCompare = -1;
            }
            else
            {
                pcsFirstVal = m_apcsTestPoints[lFirstIndex];
                pcsSecondVal = pArg2->m_apcsTestPoints[lSecondIndex];
                nCompare = pcsFirstVal->CheapCompare(*pcsSecondVal);
            }
    
            //
            // Compute the branch to be added and its test point
            //
            CEvalNode* pNewBranch = NULL;
            CCompressedString* pcsCurrentVal = NULL;
    
            if(nCompare < 0)
            {
                //
                // At this index is the first value combined with second none
                // 
    
                if(!bSecondNonePossible)
                {
                    lFirstIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 
                                        lFirstIndex+1)))
                {
                    lFirstIndex++;
                    continue;
                }
                pArg2->RecordBranch(pNamespace, BranchImplications, 0);
                
                //
                // We may delete our None nodes if and only if there predicted 
                // usage count (adjusted for usage that has already occurred) is
                // dropping to 0 --- that is, noone will use these nodes further
                // during this merge
                //

                bool bDeleteOtherBranch = (--dwSecondNoneCount == 0);
                CEvalTree::Combine(m_apBranches[lFirstIndex+1], 
                                   pArg2->m_apBranches[0],
                                   nOp, pNamespace, BranchImplications, 
                                   bDeleteThis, bDeleteOtherBranch,
                                   &pNewBranch);
                
                if(bDeleteOtherBranch)
                    pArg2->m_apBranches.Discard(0);
                if(bDeleteThis)
                    m_apBranches.Discard(lFirstIndex+1);
    
                pcsCurrentVal = pcsFirstVal;
                lFirstIndex++;
            }
            else if(nCompare > 0)
            {
                // At this index is the second value combined with first none
                // ==========================================================
    
                if(!bFirstNonePossible)
                {
                    lSecondIndex++;
                    continue;
                }
                CImplicationList BranchImplications(Implications);
                if(FAILED(pArg2->RecordBranch(pNamespace, BranchImplications, 
                                        lSecondIndex+1)))
                {
                    lSecondIndex++;
                    continue;
                }
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 0)))
                {
                    lSecondIndex++;
                    continue;
                }
                
                //
                // We may delete our None nodes if and only if there predicted 
                // usage count (adjusted for usage that has already occurred) is
                // dropping to 0 --- that is, noone will use these nodes further
                // during this merge
                //
    
                bool bDeleteThisBranch = (--dwFirstNoneCount == 0);
                CEvalTree::Combine(m_apBranches[0], 
                                   pArg2->m_apBranches[lSecondIndex+1],
                                   nOp, pNamespace, BranchImplications, 
                                   bDeleteThisBranch, bDeleteArg2,
                                   &pNewBranch);
    
                if(bDeleteArg2)
                    pArg2->m_apBranches.Discard(lSecondIndex+1);
                if(bDeleteThisBranch)
                    m_apBranches.Discard(0);
    
                pcsCurrentVal = pcsSecondVal;
                lSecondIndex++;
            }
            else
            {
                // At this index is the combinations of the ats
                // ============================================
                
                CImplicationList BranchImplications(Implications);
                if(FAILED(RecordBranch(pNamespace, BranchImplications, 
                                        lFirstIndex+1)))
                {
                    lSecondIndex++;
                    lFirstIndex++;
                    continue;
                }
    
                CEvalTree::Combine(m_apBranches[lFirstIndex+1], 
                                   pArg2->m_apBranches[lSecondIndex+1],
                                   nOp, pNamespace, BranchImplications, 
                                   bDeleteThis, bDeleteArg2,
                                   &pNewBranch);
    
                if(bDeleteArg2)
                    pArg2->m_apBranches.Discard(lSecondIndex+1);
                if(bDeleteThis)
                    m_apBranches.Discard(lFirstIndex+1);
    
    
                pcsCurrentVal = pcsFirstVal; // doesn't matter --- same
                lFirstIndex++;
                lSecondIndex++;
            }
    
            //
            // Add the newely constructed branch
            //
    
            if(apBranches.Add(pNewBranch) < 0)
                return WBEM_E_OUT_OF_MEMORY;
    
            //
            // Add the newely constructed test point
            //
    
            apcsTestPoints[lNewIndex] = 
                (CCompressedString*)_new BYTE[pcsCurrentVal->GetLength()];
    
            if(apcsTestPoints[lNewIndex] == NULL)
                return WBEM_E_OUT_OF_MEMORY;
    
            memcpy((void*)apcsTestPoints[lNewIndex],
                (void*)pcsCurrentVal, pcsCurrentVal->GetLength());
    
            lNewIndex++;
        }
    
        //
        // Now that we are done with testing, place the test-point array into 
        // pNew
        //
    
        pNew->RemoveAllTestPoints();
        pNew->m_apcsTestPoints = apcsTestPoints;
        pNew->m_lNumPoints = lNewIndex;
    
        //
        // Replace the array of branches that we may have had (guaranteed to 
        // all be NULL, since we were NULLing them out as we went).
        //
    
        pNew->m_apBranches.RemoveAll();
    
        for(int i = 0; i < apBranches.GetSize(); i++)
        {
            pNew->m_apBranches.Add(apBranches[i]);
            apBranches.Discard(i);
        }
                
        //
        // Merge the nulls
        // 
        
        CImplicationList NullImplications(Implications);
        hres = RecordBranch(pNamespace, Implications, -1);
    
        if(SUCCEEDED(hres))
        {
            CEvalNode* pNewBranch = NULL;
            hres = CEvalTree::Combine(m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                        pNamespace, NullImplications, bDeleteThis, bDeleteArg2, 
                        &pNewBranch);
            if(FAILED(hres))
                return hres;
    
            //
            // Clear the old new branch, whatever it was, (it has been deleted,
            // if it ever were there at all) and replace it with the new one.
            // 
    
            pNew->m_pNullBranch = pNewBranch;
                
            // Clear deleted branches
            // ======================
    
            if(bDeleteArg2)
                pArg2->m_pNullBranch = NULL;
        }
    
        // Delete Arg2, if needed (reused portions have been nulled out)
        // =============================================================
    
        if(bDeleteArg2)
            delete pArg2;
    
        *ppRes = pNew;
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}


HRESULT CInheritanceNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode)
{
    //
    // There are two choices here: either it is about us, or we are not
    // interested.
    //

    if(pFilter->IsInSet(this))  
    {
        return CBranchingNode::Project(pMeta, Implications, pFilter, eType,
                                        bDeleteThis, ppNewNode);
    }
    else
    {
        if(eType == e_Sufficient)
            *ppNewNode = CValueNode::GetStandardFalse();
        else
        {
            *ppNewNode = CValueNode::GetStandardTrue();
            if(*ppNewNode == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }

        if(bDeleteThis)
            delete this;

        return S_OK;
    }
}

void CInheritanceNode::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);
    PrintOffset(f, nOffset);
    fprintf(f, "inheritance index %d: (0x%p)\n", m_lDerivationIndex, this);

    for(int i = 0; i < m_lNumPoints; i++)
    {
        WString ws = m_apcsTestPoints[i]->CreateWStringCopy();
        PrintOffset(f, nOffset);
        fprintf(f, "%S->\n", (LPWSTR)ws);
        DumpNode(f, nOffset+1, m_apBranches[i+1]);
    }

    PrintOffset(f, nOffset);
    fprintf(f, "none of the above->\n");
    DumpNode(f, nOffset+1, m_apBranches[0]);

    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}

#ifdef CHECK_TREES
void CBranchingNode::CheckNode(CTreeChecker *pCheck)
{
    pCheck->CheckoffNode(this);

	int nItems = m_apBranches.GetSize();

	for (int i = 0; i < nItems; i++)
    {
        CEvalNode *pNode = m_apBranches[i];

		if (pNode)
			m_apBranches[i]->CheckNode(pCheck);
    }

	if (m_pNullBranch)
		m_pNullBranch->CheckNode(pCheck);
}
#endif

//******************************************************************************
//******************************************************************************
//
//                          OR NODE
// 
//******************************************************************************
//******************************************************************************

void COrNode::operator=(const COrNode& Other)
{
    // Remove all our children
    // =======================

    m_apBranches.RemoveAll();

    // Clone all the branches from the other
    // =====================================

    for(int i = 0; i < Other.m_apBranches.GetSize(); i++)
    {
        CEvalNode* pNewBranch = CloneNode(Other.m_apBranches[i]);

        if(pNewBranch == NULL && Other.m_apBranches[i] != NULL)
            throw CX_MemoryException();

        if(m_apBranches.Add(pNewBranch) < 0)
            throw CX_MemoryException();
    }
}

HRESULT COrNode::CombineWith(CEvalNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2,
        CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = NULL;

    // We don't support AND combines on OR nodes
    // =========================================

    if(nOp == EVAL_OP_AND)
        return WBEM_E_CRITICAL_ERROR; 

    // If the other is another OR node, delegate to the iterator
    // =========================================================

    if(CEvalNode::GetType(pArg2) == EVAL_NODE_TYPE_OR)
    {
        return CombineWithOrNode((COrNode*)pArg2, nOp, pNamespace, Implications,
                                    bDeleteThis, bDeleteArg2, ppRes);
    }

    // Make a copy --- the new node will be mostly us
    // ==============================================

    COrNode* pNew = NULL;

    if(!bDeleteThis)
    {
        pNew = (COrNode*)Clone();
        if(pNew == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        pNew = this;
    }

    *ppRes = pNew;

    // Combining an OR node with a non-OR --- try all branches
    // =======================================================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        // Check if this branch is a good fit for the other node
        // =====================================================

        if(CEvalTree::IsMergeAdvisable(m_apBranches[i], pArg2, Implications) == 
                WBEM_S_NO_ERROR)
        {
            // It is --- merge it in
            // =====================

            CEvalNode* pNewBranch = NULL;
            hres = CEvalTree::Combine(m_apBranches[i], pArg2, nOp,
                                pNamespace, Implications, 
                                bDeleteThis, bDeleteArg2, &pNewBranch);
            if(FAILED(hres))
                return hres;

            if(bDeleteThis)
                m_apBranches.Discard(i);

            pNew->m_apBranches.SetAt(i, pNewBranch);

            return WBEM_S_NO_ERROR;
        }
    }

    // No branch was a good fit --- add the node to our list
    // =====================================================

    if(bDeleteArg2)
    {
        hres = pNew->AddBranch(pArg2);
    }
    else
    {
        CEvalNode* pNode = pArg2->Clone();
        if(pNode == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        hres = pNew->AddBranch(pNode);
    }

    if(FAILED(hres))
        return hres;    

    return WBEM_S_NO_ERROR;
}

HRESULT COrNode::AddBranch(CEvalNode* pNewBranch)
{
    // Search for a place in our array of branches
    // ===========================================

    
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        int nCompare = CEvalTree::Compare(pNewBranch, m_apBranches[i]);
        if(nCompare == 0) 
        {
            // Could happen: sometimes we force an OR-merge
            nCompare = -1;
        }

        if(nCompare < 0)
        {
            // pNewBranch comes before this branch, so insert it right here
            // ============================================================

            if(!m_apBranches.InsertAt(i, pNewBranch))
                return WBEM_E_OUT_OF_MEMORY;

            return WBEM_S_NO_ERROR;
        }
    }

    // It is after all branches --- append
    // ===================================

    if(m_apBranches.Add(pNewBranch) < 0)
        return WBEM_E_OUT_OF_MEMORY;

    return WBEM_S_NO_ERROR;
}
            
HRESULT COrNode::CombineWithOrNode(COrNode* pArg2, int nOp, 
        CContextMetaData* pNamespace, CImplicationList& Implications, 
        bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes)
{
    // NOTE: this function may delete THIS in the middle of execution!!
    // ================================================================

    // Combine us with every branch of the other
    // =========================================

    CEvalNode* pCurrent = this;
    bool bDeleteCurrent = bDeleteThis;
    for(int i = 0; i < pArg2->m_apBranches.GetSize(); i++)
    {
        CEvalNode* pNew = NULL;
        HRESULT hres = pCurrent->CombineWith(pArg2->m_apBranches[i], nOp, 
                            pNamespace, Implications, 
                            bDeleteCurrent, bDeleteArg2, &pNew);
        if(FAILED(hres))
            return hres;

        pCurrent = pNew;

        // At this point, we can safely delete pCurrent if needed --- it's ours
        // ====================================================================

        bDeleteCurrent = TRUE;

        // If pArg2's branch has been deleted, reset it
        // ============================================

        if(bDeleteArg2)
            pArg2->m_apBranches.Discard(i);
    }

    *ppRes = pCurrent;

    if(bDeleteArg2)
        delete pArg2;
    
    return WBEM_S_NO_ERROR;
}
        

int COrNode::Compare(CEvalNode* pOther)
{
    COrNode* pOtherNode = (COrNode*)pOther;

    // Compare array sizes
    // ===================

    if(m_apBranches.GetSize() != pOtherNode->m_apBranches.GetSize())
        return m_apBranches.GetSize() - pOtherNode->m_apBranches.GetSize();

    // Compare individual nodes
    // ========================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        int nCompare = CEvalTree::Compare(m_apBranches[i], 
                                        pOtherNode->m_apBranches[i]);
        if(nCompare != 0)
            return nCompare;
    }

    return 0;
}


DWORD COrNode::ApplyPredicate(CLeafPredicate* pPred)
{
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if (m_apBranches[i])
            m_apBranches[i]->ApplyPredicate(pPred);
    }
    return WBEM_DISPOSITION_NORMAL;
}

HRESULT COrNode::Optimize(CContextMetaData* pNamespace, CEvalNode** ppNew)
{
    HRESULT hres = WBEM_S_NO_ERROR;

    // First, optimize all its branches
    // ================================

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        CEvalNode* pNew = NULL;
        if (m_apBranches[i])
        {
            hres = m_apBranches[i]->Optimize(pNamespace, &pNew);
            if(FAILED(hres))
                return hres;
        }

        if(pNew != m_apBranches[i])
        {
            // Replace, but check for emptiness first
            // ======================================

            if(!CEvalNode::IsAllFalse(pNew))
                m_apBranches.SetAt(i, pNew);
            else
            {
                delete pNew;
                m_apBranches.RemoveAt(i);
                i--;
            }
        }
    }

    if(m_apBranches.GetSize() == 0)
    {
        // We have no branches --- equivalent to no successes
        // ==================================================

        *ppNew = CValueNode::GetStandardFalse();
        return WBEM_S_NO_ERROR;
    }
    else if(m_apBranches.GetSize() == 1)
    {
        // One branch --- equivalent to that branch
        // ========================================

        m_apBranches.RemoveAt(0, ppNew);
    }
    else 
    {
        *ppNew = this;
    }
    return WBEM_S_NO_ERROR;
}

void COrNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);
    fprintf(f, "FOREST\n");

    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if (m_apBranches[i])
            m_apBranches[i]->Dump(f, nOffset+1);
        else
            fprintf(f, "all false ValueNode (or error?)\n");
    }
}

HRESULT COrNode::Evaluate(CObjectInfo& Info, CSortedArray& trueIDs)
{
    for(int i = 0; i < m_apBranches.GetSize(); i++)
    {
        if (m_apBranches[i])
        {
            HRESULT hres = CEvalTree::Evaluate(Info, m_apBranches[i], trueIDs);
            if(FAILED(hres))
                return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT COrNode::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications,
                            CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteThis,
                            CEvalNode** ppNewNode)
{
    COrNode* pNew;
    if(bDeleteThis)
        pNew = this;
    else
        pNew = (COrNode*)Clone();

    if(pNew == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Simply project all the branches
    //

    for(int i = 0; i < pNew->m_apBranches.GetSize(); i++)
    {
        CEvalNode* pProjected = NULL;

        HRESULT hres = CEvalTree::Project(pMeta, Implications, 
                            pNew->m_apBranches[i], pFilter, eType,
                            true, // always delete --- has been cloned
                            &pProjected);
        if(FAILED(hres))
            return hres;

        pNew->m_apBranches.Discard(i);
        pNew->m_apBranches.SetAt(i, pProjected);
    }

    *ppNewNode = pNew;
    return S_OK;
}
    
            

//******************************************************************************
//******************************************************************************
//                  PREDICATES
//******************************************************************************
//******************************************************************************

// NOTE: Not checking for NULL leaves, should be checked by caller
DWORD CEvalTree::CRemoveIndexPredicate::operator()(CValueNode* pLeaf)
{
    if(pLeaf)
    {
        pLeaf->RemoveQueryID(m_nIndex);
        if(pLeaf->GetNumTrues() == 0)
            return WBEM_DISPOSITION_FLAG_DELETE;
    }
    return WBEM_DISPOSITION_NORMAL;
}

// NOTE: Not checking for NULL leaves, should be checked by caller
DWORD CEvalTree::CRebasePredicate::operator()(CValueNode* pLeaf)
{
    if(pLeaf)
        pLeaf->Rebase(m_newBase);
    return WBEM_DISPOSITION_NORMAL;
}

// NOTE: Not checking for NULL leaves, should be checked by caller
DWORD CEvalTree::CRemoveFailureAtIndexPredicate::operator()(CValueNode* pLeaf)
{
    if(pLeaf == NULL || pLeaf->GetAt(m_nIndex) != EVAL_VALUE_TRUE)
        return WBEM_DISPOSITION_FLAG_INVALIDATE;
    
    pLeaf->RemoveQueryID(m_nIndex);
    if(pLeaf->GetNumTrues() == 0)
        return WBEM_DISPOSITION_FLAG_DELETE;

    return WBEM_DISPOSITION_NORMAL;
}

//******************************************************************************
//******************************************************************************
//                  EVALUATION TREE
//******************************************************************************
//******************************************************************************

CEvalTree::CEvalTree() 
    : m_lRef(0), m_pStart(NULL), m_nNumValues(0)
{
#ifdef CHECK_TREES
	g_treeChecker.AddTree(this);
#endif
}

CEvalTree::CEvalTree(const CEvalTree& Other) 
    : m_lRef(0), m_pStart(NULL), m_nNumValues(0)
{
#ifdef CHECK_TREES
	g_treeChecker.AddTree(this);
#endif

    *this = Other;
}
        
CEvalTree::~CEvalTree() 
{
#ifdef CHECK_TREES
	g_treeChecker.RemoveTree(this);
#endif

	delete m_pStart;
}


bool CEvalTree::SetBool(BOOL bVal)
{
    CInCritSec ics(&m_cs);

    delete m_pStart;
    CValueNode* pNode;
    
    if (bVal)
    {
        pNode = CValueNode::GetStandardTrue();
        if(pNode == NULL)
            return false;
    }
    else
        pNode = CValueNode::GetStandardFalse();
    
    m_pStart = pNode;
    m_nNumValues = 1;
    if(!m_ObjectInfo.SetLength(1))
        return false;

    return true;
}

bool CEvalTree::IsFalse()
{
    return (m_pStart == NULL);
}

bool CEvalTree::IsValid()
{
    return !CEvalNode::IsInvalid(m_pStart);
}

int CEvalTree::Compare(CEvalNode* pArg1, CEvalNode* pArg2)
{
    if(pArg1 == NULL)
    {
        if(pArg2 == NULL)
            return 0;
        else
            return 1;
    }
    else if(pArg2 == NULL)
        return -1;
    else if(CEvalNode::GetType(pArg1) != CEvalNode::GetType(pArg2))
        return CEvalNode::GetType(pArg1) - CEvalNode::GetType(pArg2);
    else return pArg1->Compare(pArg2);
}


HRESULT CEvalTree::CreateFromQuery(CContextMetaData* pNamespace, 
                            LPCWSTR wszQuery, long lFlags, long lMaxTokens)
{
    CTextLexSource src((LPWSTR)wszQuery);
    QL1_Parser parser(&src);
    QL_LEVEL_1_RPN_EXPRESSION *pExp = 0;
    int nRes = parser.Parse(&pExp);
    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> deleteMe(pExp);

    if (nRes)
        return WBEM_E_INVALID_QUERY;
 
    HRESULT hres = CreateFromQuery(pNamespace, pExp, lFlags, lMaxTokens);
    return hres;
}
    
HRESULT CEvalTree::CreateFromQuery(CContextMetaData* pNamespace, 
           QL_LEVEL_1_RPN_EXPRESSION* pQuery, long lFlags, long lMaxTokens)
{
    return CreateFromQuery(pNamespace, pQuery->bsClassName, pQuery->nNumTokens,
                            pQuery->pArrayOfTokens, lFlags, lMaxTokens);
}

HRESULT CEvalTree::CreateFromQuery(CContextMetaData* pNamespace, 
           LPCWSTR wszClassName, int nNumTokens, QL_LEVEL_1_TOKEN* apTokens,
           long lFlags, long lMaxTokens)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    // Create basic implication list
    // =============================

    _IWmiObject* pObj = NULL;
    hres = pNamespace->GetClass(wszClassName, &pObj);
    if(FAILED(hres))
    {
        return hres;
    }

	CReleaseMe rm1(pObj);

    try
    {
        CImplicationList Implications(lFlags);
        CPropertyName EmptyName;
        Implications.ImproveKnown(&EmptyName, pObj);
    
    #ifdef CHECK_TREES
        CheckTrees();
    #endif
        
        CEvalNode* pWhere = NULL;
    
        if(nNumTokens)
        {
            // Convert the token list to DNF
            // =============================
    
            CDNFExpression DNF;
            QL_LEVEL_1_TOKEN* pEnd = apTokens + nNumTokens - 1;
            hres = DNF.CreateFromTokens(pEnd, 0, lMaxTokens);
			if(FAILED(hres))
				return hres;

            if(pEnd != apTokens - 1)
            {
                return WBEM_E_CRITICAL_ERROR;
            }
            DNF.Sort();
    
            // Build a tree for the token list
            // ===============================
    
            hres = CreateFromDNF(pNamespace, Implications, &DNF, &pWhere);
    
            if(FAILED(hres))
            {
                return hres;
            }
        }
        else
        {
            pWhere = CValueNode::GetStandardTrue();
            if(pWhere == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        // Add inheritance check
        // =====================
    
        CInheritanceNode* pInhNode = new CInheritanceNode;
        if (!pInhNode)
            return WBEM_E_OUT_OF_MEMORY;
    
        hres = pInhNode->AddClass(pNamespace, wszClassName, (_IWmiObject*)pObj, 
                                    pWhere);
        if(FAILED(hres))
        {
            delete pWhere;
            delete pInhNode;
            return hres;
        }
    
        if(!m_ObjectInfo.SetLength(Implications.GetRequiredDepth()))
        {
            delete pInhNode;
            return WBEM_E_OUT_OF_MEMORY;
        }
            
        delete m_pStart;
        m_pStart = pInhNode;
        m_nNumValues = 1;
    
    #ifdef CHECK_TREES
        CheckTrees();
    #endif
    
        Optimize(pNamespace);
    
    #ifdef CHECK_TREES
        CheckTrees();
    #endif
    
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

// extension of BuildFromToken to build nodes that have two properties
// e.g. this would service "select * from class where prop1 < prop2"
HRESULT CEvalTree::BuildTwoPropFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes)
{
    HRESULT hres;
    
    CEmbeddingInfo leftInfo, rightInfo;
    if(!leftInfo.SetPropertyNameButLast(Token.PropertyName))
        return WBEM_E_OUT_OF_MEMORY;
    if(!rightInfo.SetPropertyNameButLast(Token.PropertyName2))
        return WBEM_E_OUT_OF_MEMORY;

    _IWmiObject* pLeftClass;
    hres = leftInfo.Compile(pNamespace, Implications, &pLeftClass);
    if(FAILED(hres))
        return hres;
    if(pLeftClass == NULL)
        return WBEMESS_E_REGISTRATION_TOO_BROAD;

    _IWmiObject* pRightClass;
    hres = rightInfo.Compile(pNamespace, Implications, &pRightClass);
    if(FAILED(hres))
        return hres;
    if(pRightClass == NULL)
    {
        pLeftClass->Release();
        return WBEMESS_E_REGISTRATION_TOO_BROAD;
    }


    // Get the property types and handles
    // ==================================

    LPCWSTR wszLeftPropName = Token.PropertyName.GetStringAt(
        Token.PropertyName.GetNumElements() - 1);
    LPCWSTR wszRightPropName = Token.PropertyName2.GetStringAt(
        Token.PropertyName2.GetNumElements() - 1);

    CIMTYPE ctLeft, ctRight;
    long lLeftPropHandle, lRightPropHandle;
    hres = pLeftClass->GetPropertyHandleEx(wszLeftPropName, 0L, &ctLeft, 
                                            &lLeftPropHandle);
    pLeftClass->Release();  
    if(FAILED(hres)) return hres;   
    hres = pRightClass->GetPropertyHandleEx(wszRightPropName, 0L, &ctRight, 
                                            &lRightPropHandle);
    pRightClass->Release();  
    if(FAILED(hres)) return hres;   

    if(    ((ctLeft & CIM_FLAG_ARRAY) != 0) || (ctLeft == CIM_OBJECT)
        || ((ctRight & CIM_FLAG_ARRAY) != 0) || (ctRight == CIM_OBJECT) )
        return WBEM_E_NOT_SUPPORTED;

    // if the type of either node is reference or date, go to dumb
    if (  (ctLeft == CIM_DATETIME)   ||
          (ctLeft == CIM_REFERENCE)   ||
          (ctRight == CIM_DATETIME) ||
          (ctRight == CIM_REFERENCE) 
       )
    {
        if(ctLeft != ctRight)
            return WBEM_E_TYPE_MISMATCH;

        CDumbNode* pDumb = NULL;
        try
        {
            pDumb = new CDumbNode(Token);
            if(pDumb == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

        hres = pDumb->Validate(pLeftClass);
        if(FAILED(hres))
        {
            delete pDumb;
            return hres;
        }
        
        *ppRes = pDumb;
        return WBEM_S_NO_ERROR;
    }
    
    // if the node is mismatched (different types in either node)
    // we'll want to create the most flexible node needed to hold both types
    CIMTYPE ctNode = ctLeft;

    CPropertyNode* pNode = NULL;

    try
    {
        bool bMismatchedNode = (ctLeft != ctRight);
        if (bMismatchedNode)
        {
            // we'll be real forgiving about strings matching strings
            if (  (ctLeft == CIM_STRING)    ||
                  (ctRight == CIM_STRING)
               )
               pNode = new CTwoMismatchedStringNode;
            else if ( (ctRight == CIM_REAL32) ||
                      (ctRight == CIM_REAL64)  ||
                      (ctLeft  == CIM_REAL32) ||
                      (ctLeft  == CIM_REAL64)
                    )
                pNode = new CTwoMismatchedFloatNode;
            else if ( (ctLeft  == CIM_UINT64)  ||
                      (ctRight == CIM_UINT64)
                    )
                pNode = new CTwoMismatchedUInt64Node;
            else if ( (ctLeft  == CIM_SINT64 ) ||
                      (ctRight == CIM_SINT64 )
                    )
                pNode = new CTwoMismatchedInt64Node;
            else if ( (ctRight == CIM_UINT32)  ||
                      (ctLeft  == CIM_UINT32)
                    )
                pNode = new CTwoMismatchedUIntNode;
            else 
                pNode = new CTwoMismatchedIntNode;           
        }
        else
        // not mistmatched - go with the exact type
        {
            // Create the Proper node
            // =====================
    
            switch(ctNode)
            {
            case CIM_SINT8:
                pNode = new TTwoScalarPropNode<signed char>;
                break;
            case CIM_UINT8:
                pNode = new TTwoScalarPropNode<unsigned char>;
                break;
            case CIM_SINT16:
                pNode = new TTwoScalarPropNode<short>;
                break;
            case CIM_UINT16:
            case CIM_CHAR16:
                pNode = new TTwoScalarPropNode<unsigned short>;
                break;
            case CIM_SINT32:
                pNode = new TTwoScalarPropNode<long>;
                break;
            case CIM_UINT32:
                pNode = new TTwoScalarPropNode<unsigned long>;
                break;
            case CIM_SINT64:
                pNode = new TTwoScalarPropNode<__int64>;
                break;
            case CIM_UINT64:
                pNode = new TTwoScalarPropNode<unsigned __int64>;
                break;
            case CIM_REAL32:
                pNode = new TTwoScalarPropNode<float>;
                break;
            case CIM_REAL64:
                pNode = new TTwoScalarPropNode<double>;
                break;
            case CIM_BOOLEAN:
                pNode = new TTwoScalarPropNode<VARIANT_BOOL>;
                break;
            case CIM_STRING:
                pNode = new CTwoStringPropNode;
                break;
            case CIM_DATETIME:
            case CIM_REFERENCE:
                {
                    CDumbNode* pDumb = new CDumbNode(Token);
                    hres = pDumb->Validate(pLeftClass);
                    if(FAILED(hres))
                    {
                        delete pDumb;
                        return hres;
                    }
                    else
                    {
                        *ppRes = pDumb;
                        return WBEM_S_NO_ERROR;
                    }
                }
                return WBEM_S_NO_ERROR;
            default:
                return WBEM_E_CRITICAL_ERROR;
            }
        }
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}

    if (!pNode)
        return WBEM_E_OUT_OF_MEMORY;

    if(!pNode->SetEmbeddingInfo(&leftInfo))
        return WBEM_E_OUT_OF_MEMORY;
        
    if(!pNode->SetPropertyInfo(wszLeftPropName, lLeftPropHandle))
        return WBEM_E_OUT_OF_MEMORY;

    ((CTwoPropNode*)pNode)->SetRightEmbeddingInfo(&rightInfo);
    ((CTwoPropNode*)pNode)->SetRightPropertyInfo(wszRightPropName, 
                                                    lRightPropHandle);

    hres = pNode->SetOperator(Token.nOperator);
    if(FAILED(hres))
        return hres;

    *ppRes = pNode;
    return WBEM_S_NO_ERROR;
}
    

HRESULT CEvalTree::BuildFromToken(CContextMetaData* pNamespace, 
                    CImplicationList& Implications,
                    QL_LEVEL_1_TOKEN& Token, CEvalNode** ppRes)
{
    HRESULT hres;

    if (Token.m_bPropComp)
    {
        hres = BuildTwoPropFromToken(pNamespace, Implications, Token, ppRes);
        if(hres == WBEMESS_E_REGISTRATION_TOO_BROAD ||
			hres == WBEM_E_INVALID_PROPERTY)
        {
            //
            // Not enough information to use efficient evaluation
            //

            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }

            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
        else 
            return hres;
    }
            

    //
    // Retrieve event class definition
    //

    _IWmiObject* pEventClass;
    hres = Implications.FindClassForProp(NULL, 0, &pEventClass);
    if(FAILED(hres))
        return hres;
    if(pEventClass == NULL)
        return WBEM_E_INVALID_QUERY;
    CReleaseMe rm1((IWbemClassObject*)pEventClass);

    if(Token.nOperator == QL1_OPERATOR_ISA)
    {
        //
        // Inheritance node are rarely applicable in Nova --- we have no way
        // of telling *which definition* of the class is being referenced. Thus,
        // we only construct an inheritance node in one case --- where the 
        // embedded object in question is a property of an instance operation
        // event.  These we trust.
        //

        if(pEventClass->InheritsFrom(L"__InstanceOperationEvent") == S_OK)
        {
            // 
            // OK, can use an inheritance node
            //

            if(V_VT(&Token.vConstValue) != VT_BSTR)
                return WBEM_E_INVALID_QUERY;
            BSTR strClassName = V_BSTR(&Token.vConstValue);
    
            CInheritanceNode* pNode = NULL;
            try
            {
                pNode = new CInheritanceNode;
                if (!pNode)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }
    
            CDeleteMe<CInheritanceNode> deleteMe(pNode);
            
            CEvalNode* pTrue = CValueNode::GetStandardTrue();
            if(pTrue == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            hres = pNode->AddClass(pNamespace, strClassName, pTrue);
            if(FAILED(hres))
                return hres;
    
            if(!pNode->SetPropertyInfo(pNamespace, Token.PropertyName))
                return WBEM_E_OUT_OF_MEMORY;
               
            hres = pNode->Compile(pNamespace, Implications);
            if(FAILED(hres))
                return hres;
    
            // Record the fact that TRUE branch is being taken
            // ===============================================
            pNode->RecordBranch(pNamespace, Implications, 1);
    
            // in the event that we made it this far,
            // we no longer WANT to delete node
            deleteMe = NULL;
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
        else
        {
            //
            // May not use an inheritance node --- use a dumb one instead
            //

            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }

            hres = pNode->Validate(pEventClass);
            if(FAILED(hres))
            {
                delete pNode;
                return hres;
            }
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
    }
    else 
    {
        //
        // Attempt to compile the embedding portion.  This will only succeed if
        // the rest of the query implies enough information for us to know
        // exactly what class the embedded object is
        // 

        CEmbeddingInfo Info;
        if(!Info.SetPropertyNameButLast(Token.PropertyName))
            return WBEM_E_OUT_OF_MEMORY;

        _IWmiObject* pClass;
        hres = Info.Compile(pNamespace, Implications, &pClass);
        if(hres == WBEMESS_E_REGISTRATION_TOO_BROAD || 
			hres == WBEM_E_INVALID_PROPERTY || // invalid or not yet known?
			pClass == NULL)
        {
            //
            // Not enough information --- have to use the dumb node
            //
            
            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }
        
            hres = pNode->Validate(pEventClass);
            if(FAILED(hres))
            {
                delete pNode;
                return hres;
            }
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
   
        if(FAILED(hres))
            return hres;

        //
        // We do know the class definition.  Check if this is a system property,
        // though, in which case we still have toi use a dumb node
        //

        LPCWSTR wszPropName = Token.PropertyName.GetStringAt(
            Token.PropertyName.GetNumElements() - 1);

        if(wszPropName == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        if(wszPropName[0] == '_')
        {
            CDumbNode* pNode = NULL;
            try
            {
                pNode = new CDumbNode(Token);
                if(pNode == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
	        catch (CX_MemoryException)
	        {
		        return WBEM_E_OUT_OF_MEMORY;
	        }

            hres = pNode->Validate(pEventClass);
            if(FAILED(hres))
            {
                delete pNode;
                return hres;
            }
            *ppRes = pNode;
            return WBEM_S_NO_ERROR;
        }
            
        // Get the property type and handle
        // ================================

        CIMTYPE ct;
        long lPropHandle;
        hres = pClass->GetPropertyHandleEx(wszPropName, 0L, &ct, &lPropHandle);
        pClass->Release();  
        if(FAILED(hres)) return hres;   
    
        if(((ct & CIM_FLAG_ARRAY) != 0) || (ct == CIM_OBJECT))
            return WBEM_E_NOT_SUPPORTED;

        // Coerce the constant to the right type
        // =====================================

        VARIANT v;
        VariantInit(&v);
        CClearMe cm(&v);
        if(V_VT(&Token.vConstValue) != VT_NULL)
        {
            hres = ChangeVariantToCIMTYPE(&v, &Token.vConstValue, ct);
            if(FAILED(hres)) return hres;
        }
        else
        {
            V_VT(&v) = VT_NULL;
        }

        
        //
        // Create the right node
        //

        CPropertyNode* pNode = NULL;
        
        try
        {
            if ( Token.nOperator != QL1_OPERATOR_LIKE &&
                 Token.nOperator != QL1_OPERATOR_UNLIKE )
            {
                switch(ct)
                {
                case CIM_SINT8:
                    pNode = new CScalarPropNode<signed char>;
                    break;
                case CIM_UINT8:
                    pNode = new CScalarPropNode<unsigned char>;
                    break;
                case CIM_SINT16:
                    pNode = new CScalarPropNode<short>;
                    break;
                case CIM_UINT16:
                case CIM_CHAR16:
                    pNode = new CScalarPropNode<unsigned short>;
                    break;
                case CIM_SINT32:
                    pNode = new CScalarPropNode<long>;
                    break;
                case CIM_UINT32:
                    pNode = new CScalarPropNode<unsigned long>;
                    break;
                case CIM_SINT64:
                    pNode = new CScalarPropNode<__int64>;
                    break;
                case CIM_UINT64:
                    pNode = new CScalarPropNode<unsigned __int64>;
                    break;
                case CIM_REAL32:
                    pNode = new CScalarPropNode<float>;
                    break;
                case CIM_REAL64:
                    pNode = new CScalarPropNode<double>;
                    break;
                case CIM_BOOLEAN:
                    pNode = new CScalarPropNode<VARIANT_BOOL>;
                    break;
                case CIM_STRING:
                    pNode = new CStringPropNode;
                    break;
                case CIM_DATETIME:
                case CIM_REFERENCE:
                    {
                        CDumbNode* pDumb = new CDumbNode(Token);
                        if(pDumb == NULL)
                        return WBEM_E_OUT_OF_MEMORY;

                        hres = pDumb->Validate(pEventClass);
                        if(FAILED(hres))
                        {
                            delete pDumb;
                            return hres;
                        }
                        else
                        {
                            *ppRes = pDumb;
                            return WBEM_S_NO_ERROR;
                        }
                    }
                default:
                    return WBEM_E_CRITICAL_ERROR;
                }
            }
            else
            {
                if ( V_VT(&v) != VT_BSTR )
                    return WBEM_E_INVALID_QUERY;

                pNode = new CLikeStringPropNode;
            }
        }            
        catch (CX_MemoryException)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        if (!pNode)
            return WBEM_E_OUT_OF_MEMORY;

        if(!pNode->SetEmbeddingInfo(&Info))
        {
            delete pNode;
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(!pNode->SetPropertyInfo(wszPropName, lPropHandle))
        {
            delete pNode;
            return WBEM_E_OUT_OF_MEMORY;
        }

        if(V_VT(&v) == VT_NULL)
        {
            pNode->SetNullTest(Token.nOperator);
        }
        else
        {
            //
            // Check if the operator makes sense for the type
            //

            if(ct == CIM_BOOLEAN &&
                (Token.nOperator != QL1_OPERATOR_EQUALS &&
                    Token.nOperator != QL1_OPERATOR_NOTEQUALS))
            {
                // No < > for booleans
                return WBEM_E_INVALID_QUERY;
            }

            hres = pNode->SetOperator(Token.nOperator);
            if(FAILED(hres))
                return hres;
            
            hres = pNode->SetTest(v);
            if(FAILED(hres))
                return hres;
        }

        *ppRes = pNode;
        return WBEM_S_NO_ERROR;
    }
}
        
        
HRESULT CEvalTree::Combine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hres;

    try
    {
        //
        // Apply the extra implications of the nodes being combined
        //
    
        CImplicationList* pArg1List = NULL;
        if(pArg1 && pArg1->GetExtraImplications())
        {
            pArg1List = new CImplicationList(*pArg1->GetExtraImplications(), 
                                                    false);
            if(pArg1List == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
        CDeleteMe<CImplicationList> dm1(pArg1List);
    
        CImplicationList* pArg2List = NULL;
        if(pArg2 && pArg2->GetExtraImplications())
        {
            pArg2List = new CImplicationList(*pArg2->GetExtraImplications(), 
                                                false);
            if(pArg2List == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
    
        CDeleteMe<CImplicationList> dm2(pArg2List);
    
        if(pArg1List || pArg2List)
        {
            CImplicationList TheseImplications(Implications);
    
            if(pArg1List)
            {
                hres = TheseImplications.MergeIn(pArg1List);
                if(FAILED(hres))
                    return hres;
            }
    
            if(pArg2List)
            {
                hres = TheseImplications.MergeIn(pArg2List);
                if(FAILED(hres))
                    return hres;
            }
    
            //
            // Call inner combine to do everything but the implications
            //
        
            hres = InnerCombine(pArg1, pArg2, nOp, pNamespace, 
                                        TheseImplications,
                                        bDeleteArg1, bDeleteArg2, ppRes);
        }
        else
        {
            //
            // Call inner combine to do everything but the implications
            //
        
            hres = InnerCombine(pArg1, pArg2, nOp, pNamespace, Implications,
                                        bDeleteArg1, bDeleteArg2, ppRes);
        }
    
        if(FAILED(hres))
            return hres;
    
        //
        // The implication of the combined node is the combination of the 
        // individual node implications.  It does not matter what the operation 
        // is: by the time we have arrived here, we have arrived to these 
        // respective
        // points in the individual trees, so the implications have commenced.
        // OK, I am convinced :-)
        //
    
        if(*ppRes)
        {
            CImplicationList* pResultList = NULL;
        
            if(pArg1List || pArg2List)
            {
                // 
                // There is actually some implication info in one of them --- 
                // merge them
                //
            
                if(pArg1List == NULL)
                {
                    pResultList = new CImplicationList(*pArg2List, false); 
                    if(pResultList == NULL)
                        return WBEM_E_OUT_OF_MEMORY;
                }
                else 
                {
                    pResultList = new CImplicationList(*pArg1List, false); 
                    if(pResultList == NULL)
                        return WBEM_E_OUT_OF_MEMORY;
                    if(pArg2List != NULL)
                    {
                        hres = pResultList->MergeIn(pArg2List);
                        if(FAILED(hres))
                        {
                            delete pResultList;
                            return hres;
                        }
                    }
                }
        
            }
        
            return (*ppRes)->SetExtraImplications(pResultList); // acquires
        }
        else
            return S_OK;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::InnerCombine(CEvalNode* pArg1, CEvalNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = NULL;

    if ((pArg1 == NULL) && (pArg2 == NULL))
        return WBEM_S_NO_ERROR;

	if(CEvalNode::IsInvalid(pArg1) || CEvalNode::IsInvalid(pArg2))
	{
		// 
		// Invalid branches cannot be taken, so the result is invalid
		//

		*ppRes = CValueNode::GetStandardInvalid();
        if(bDeleteArg1)
            delete pArg1;
        if(bDeleteArg2)
            delete pArg2;
		return S_OK;
	}

    int arg1Type = CEvalNode::GetType(pArg1);
    int arg2Type = CEvalNode::GetType(pArg2);

    // Check if merging the nodes is called for
    // ========================================

    if(nOp != EVAL_OP_AND && 
        IsMergeAdvisable(pArg1, pArg2, Implications) != WBEM_S_NO_ERROR)
    {
        // Create an OR node instead
        // =========================

        COrNode* pNew = NULL;
        try
        {
            pNew = new COrNode;
            if(pNew == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }
	    catch (CX_MemoryException)
	    {
		    return WBEM_E_OUT_OF_MEMORY;
	    }

        if(bDeleteArg1)
        {
            hres = pNew->AddBranch(pArg1);
        }
        else
        {
            CEvalNode* pClone = pArg1->Clone();
            if(pClone == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            hres = pNew->AddBranch(pClone);
        }
        if(FAILED(hres))
            return hres;
        
        if(bDeleteArg2)
        {
            hres = pNew->AddBranch(pArg2);
        }
        else
        {
            CEvalNode* pClone = pArg2->Clone();
            if(pClone == NULL)
                return WBEM_E_OUT_OF_MEMORY;
            hres = pNew->AddBranch(pClone);
        }
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }

        *ppRes = pNew;
        return WBEM_S_NO_ERROR;
    }
        
    // Delegate same-type operations to the type
    // =========================================


    if(arg1Type == arg2Type)
    {
        if ( ((pArg1 == NULL) || (pArg2 == NULL))
        // well, gosh - if we've already decided they're the same type, no reason for redundant checks...
         && (arg1Type == EVAL_NODE_TYPE_VALUE))
        {
            if(nOp == EVAL_OP_AND)
            {
                // FALSE AND anything is FALSE
                // ===========================

                *ppRes = NULL;
                if(bDeleteArg1)
                    delete pArg1;
                if(bDeleteArg2)
                    delete pArg2;

                return WBEM_S_NO_ERROR;
            }

            // FALSE combined in any other way with anything is that thing
            // ===========================================================

            if (pArg1)
            {

                if (bDeleteArg1)
                    *ppRes = pArg1;
                else
                    *ppRes = pArg1->Clone();

                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else if (pArg2)
            {
                if (bDeleteArg2)
                    *ppRes = pArg2;
                else
                    *ppRes = pArg2->Clone();

                if(*ppRes == NULL)
                    return WBEM_E_OUT_OF_MEMORY;
            }
            else
                // can't touch this
                *ppRes = NULL;

            return WBEM_S_NO_ERROR;
        }
        else // not value nodes
            return pArg1->CombineWith(pArg2, nOp, pNamespace, Implications, 
                                      bDeleteArg1, bDeleteArg2, ppRes);
    }
    
    // Check if one is an OR
    // =====================

    if(arg1Type == EVAL_NODE_TYPE_OR)
        return pArg1->CombineWith(pArg2, nOp, pNamespace, Implications, 
                        bDeleteArg1, bDeleteArg2, ppRes); 

    if(arg2Type == EVAL_NODE_TYPE_OR)
        return pArg2->CombineWith(pArg1, FlipEvalOp(nOp), pNamespace, 
                        Implications, bDeleteArg2, bDeleteArg1, ppRes); 
        
    // One leaf, one branch
    // ====================

    if(arg1Type == EVAL_NODE_TYPE_VALUE)
    {
        return CombineLeafWithBranch((CValueNode*)pArg1, (CBranchingNode*)pArg2,
                nOp, pNamespace, Implications, bDeleteArg1, bDeleteArg2, ppRes);
    }
    else // it's pArg2
    {
        return CombineLeafWithBranch((CValueNode*)pArg2, (CBranchingNode*)pArg1,
                FlipEvalOp(nOp), pNamespace, Implications, 
                bDeleteArg2, bDeleteArg1, ppRes);
    }
}

// static
HRESULT CEvalTree::CombineLeafWithBranch(CValueNode* pArg1, 
                            CBranchingNode* pArg2, int nOp, 
                            CContextMetaData* pNamespace,
                            CImplicationList& Implications, 
                            bool bDeleteArg1, bool bDeleteArg2, 
                            CEvalNode** ppRes)
{
    HRESULT hres;

    if (pArg1 == NULL)
    {
        *ppRes = NULL;
        if(nOp == EVAL_OP_AND)
        {
            // Anding a FALSE with something --- getting a FALSE!
            // ==================================================

            if(bDeleteArg2)
                delete pArg2;

	        return WBEM_S_NO_ERROR;
        }
        else
        {
            // Anything else combined with FALSE gives itself!
            // ===============================================

            // Well, this is true, but the problem is with optimizations.  
            // Some branches in X might not be valid under the implications in
            // this branch of the tree, and so need to be removed. For now, I
            // will simply turn off this short-circuiting path.  It may turn out
            // that there are some critical performance gains to be had by 
            // keeping it, in which case we would need to put this back and
            // make an efficient pass through it, checking branches.
            //

			/*
            if(bDeleteArg2)
                *ppRes = pArg2;
            else
                *ppRes = pArg2->Clone();

			return WBEM_S_NO_ERROR;
			*/
        }
    }
    else
    {
        // Try to short-circuit
        // ====================

        hres = pArg1->TryShortCircuit(pArg2, nOp, bDeleteArg1, bDeleteArg2, ppRes);
        if(FAILED(hres))
            return hres; // hard-failure
        if(hres == WBEM_S_NO_ERROR)
            return WBEM_S_NO_ERROR; // short-circuit succeeded
    }

    // Didn't short-circuit
    // ====================
    
    return ((CBranchingNode*)pArg2)->CombineInOrderWith(pArg1, 
                              FlipEvalOp(nOp), pNamespace, Implications, 
                              bDeleteArg2, bDeleteArg1, ppRes);
}

HRESULT CEvalTree::Evaluate(CObjectInfo& Info, CEvalNode* pStart, 
                                CSortedArray& trueIDs)
{
    HRESULT hres;

    // Loop as long as we are still seeing branching nodes
    // ===================================================

    CEvalNode* pCurrent = pStart;
    int nType;
    while((nType = CEvalNode::GetType(pCurrent)) == EVAL_NODE_TYPE_BRANCH)
    {   
        hres = ((CBranchingNode*)pCurrent)->Evaluate(Info, &pCurrent);
        if(FAILED(hres)) return hres;
    }

    if(nType == EVAL_NODE_TYPE_OR)
    {
        hres = ((COrNode*)pCurrent)->Evaluate(Info, trueIDs);
        if(FAILED(hres)) return hres;
    }
    else  // VALUE
    {
        if (CValueNode::AreAnyTrue((CValueNode*)pCurrent))
            ((CValueNode*)pCurrent)->AddTruesTo(trueIDs);
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CEvalTree::Evaluate(IWbemObjectAccess* pObj, CSortedArray& trueIDs)
{
    CInCritSec ics(&m_cs);

    trueIDs.SetSize(0);

    HRESULT hres = WBEM_S_NO_ERROR;
    
    if(m_pStart != NULL)
    {
        m_ObjectInfo.SetObjectAt(0, (_IWmiObject*)pObj);

        hres = Evaluate(m_ObjectInfo, m_pStart, trueIDs);

        m_ObjectInfo.Clear();
    }

    return hres;
}

HRESULT CEvalTree::Optimize(CContextMetaData* pNamespace)
{
    CInCritSec ics(&m_cs);

    if(m_pStart == NULL)
        return WBEM_S_NO_ERROR;

    CEvalNode* pNew = NULL;
    HRESULT hres = m_pStart->Optimize(pNamespace, &pNew);
    if(pNew != m_pStart)
    {
        delete m_pStart;
        m_pStart = pNew;
    }

    if(CEvalNode::GetType(m_pStart) == EVAL_NODE_TYPE_VALUE)
    {
        if(!m_ObjectInfo.SetLength(1))
            return WBEM_E_OUT_OF_MEMORY;
    }

    return hres;
}

HRESULT CEvalTree::CombineWith(CEvalTree& Other, CContextMetaData* pNamespace, 
                               int nOp, long lFlags)
{
    CInCritSec ics(&m_cs);

    HRESULT hres;

    try
    {
        CImplicationList Implications(lFlags);
    
        //
        // Compute required object info depth.  We are not set up to configure 
        // it properly, so we'll estimate the upper bound as the sum of the 
        // depths of the trees being merged.  Except that the first object 
        // doesn't count --- it's the event itself.  Unless one of the objects 
        // is empty --- in that case it doesn't mention the event itself, and 
        // so we should not subtract that 1.
        //
    
        long lRequiredDepth = 
            m_ObjectInfo.GetLength() + Other.m_ObjectInfo.GetLength();
        if(m_ObjectInfo.GetLength() > 0 && Other.m_ObjectInfo.GetLength() > 0)
            lRequiredDepth--;
            
        //
        // Combine our Start node with the new tree's.  Ours will be deleted in
        // the process.
        //
    
        CEvalNode* pNew;
        hres = CEvalTree::Combine(m_pStart, Other.m_pStart, nOp, pNamespace, 
                                    Implications, 
                                    true, // delete ours
                                    false, // don't touch theirs
                                    &pNew);
        if(FAILED(hres))
        {
            m_pStart = NULL;
            return hres;
        }
        m_pStart = pNew;
    
        if(!m_ObjectInfo.SetLength(lRequiredDepth))
            return WBEM_E_OUT_OF_MEMORY;
    
        if(nOp == EVAL_OP_COMBINE || nOp == EVAL_OP_INVERSE_COMBINE)
            m_nNumValues += Other.m_nNumValues;
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::IsMergeAdvisable(CEvalNode* pArg1, CEvalNode* pArg2, 
                                    CImplicationList& Implications)
{
    if(Implications.IsMergeMandatory())
        return S_OK;

    int arg1Type = CEvalNode::GetType(pArg1);
    int arg2Type = CEvalNode::GetType(pArg2);
    
    // if we have ONE non-false ValueNode, and ONE Branch Node, do not merge
    if  ( ((arg1Type == EVAL_NODE_TYPE_VALUE)
            && 
           (arg2Type == EVAL_NODE_TYPE_BRANCH)
            &&
          !CValueNode::IsAllFalse((CValueNode*)pArg1))
        ||
          ((arg2Type == EVAL_NODE_TYPE_VALUE)
             && 
           (arg1Type == EVAL_NODE_TYPE_BRANCH)
             &&
          !CValueNode::IsAllFalse((CValueNode*)pArg2))
        )
        return WBEM_S_FALSE;
    else
         // otherwise, if one of the nodes is not Branching, certainly yes (how hard can it be?)
        if(arg1Type != EVAL_NODE_TYPE_BRANCH ||
           arg2Type != EVAL_NODE_TYPE_BRANCH)
        {
            return WBEM_S_NO_ERROR;
        }

    // They are both branching.  If not about the same property, then certainly
    // inadvisable, since there is very little to be gained
    // ========================================================================

    CBranchingNode* pBranching1 = (CBranchingNode*)pArg1;
    CBranchingNode* pBranching2 = (CBranchingNode*)pArg2;

    if(CBranchingNode::ComparePrecedence(pBranching1, pBranching2))
        return WBEM_S_FALSE;
    
    // Check if the nodes are inheritance --- in that case we can only merge if
    // they have identical checks
    // ========================================================================

    if(pBranching1->GetSubType() == EVAL_NODE_TYPE_INHERITANCE)
    {
        // So is the other one, given that precedence is identical
        // =======================================================

        if(((CInheritanceNode*)pBranching1)->SubCompare(
            (CInheritanceNode*)pBranching2) != 0)
        {
            return WBEM_S_FALSE;
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }
    else if(pBranching1->GetSubType() == EVAL_NODE_TYPE_DUMB)
    {
        //
        // Only merge if identical
        //

        if(((CDumbNode*)pBranching1)->SubCompare(
            (CDumbNode*)pBranching2) != 0)
        {
            return WBEM_S_FALSE;
        }
        else
        {
            return WBEM_S_NO_ERROR;
        }
    }
        
    // Same property.  TBD: better checks
    // ==================================

    return WBEM_S_NO_ERROR;
}

HRESULT CEvalTree::RemoveIndex(int nIndex)
{
    CInCritSec ics(&m_cs);

    if(m_pStart != NULL)
    {
        CRemoveIndexPredicate P(nIndex);
        m_pStart->ApplyPredicate(&P);

        m_nNumValues--;
    }

    return S_OK;
}

HRESULT CEvalTree::UtilizeGuarantee(CEvalTree& Guaranteed, 
                                    CContextMetaData* pNamespace)
{
    CInCritSec ics(&m_cs);
#ifdef DUMP_EVAL_TREES
	FILE* f;
    f = fopen("c:\\log", "a");
    fprintf(f, "\n\nORIGINAL:\n");
    Dump(f);
    fprintf(f, "\n\nGUARANTEE:\n");
    Guaranteed.Dump(f);
    fflush(f);
#endif

#ifdef CHECK_TREES
	CheckTrees();
#endif

    //
    // Combine them together
    //

	//
	// This is a single-valued tree -- rebase it to 1 to distinguish from
	// the guarantee
	//

	Rebase(1);
    HRESULT hres = CombineWith(Guaranteed, pNamespace, EVAL_OP_COMBINE,
                                WBEM_FLAG_MANDATORY_MERGE);
    if(FAILED(hres)) return hres;

#ifdef DUMP_EVAL_TREES
    fprintf(f, "AFTER MERGE:\n");
    Dump(f);
    fflush(f);
#endif

	// Eliminate all nodes where Guaranteed is failing
    // ===============================================

    if(m_pStart)
    {
        CRemoveFailureAtIndexPredicate P(0);
        hres = m_pStart->ApplyPredicate(&P);
        if(FAILED(hres)) return hres;
    }
    m_nNumValues--;

#ifdef CHECK_TREES
	CheckTrees();
#endif

#ifdef DUMP_EVAL_TREES
    fprintf(f, "AFTER REMOVE:\n");
    Dump(f);
    fflush(f);
#endif

    hres = Optimize(pNamespace);
    if(FAILED(hres)) return hres;
	Rebase((QueryID)-1);

#ifdef CHECK_TREES
	CheckTrees();
#endif

#ifdef DUMP_EVAL_TREES
    fprintf(f, "AFTER OPTIMIZE:\n");
    Dump(f);

    fclose(f);
#endif
	
    return S_OK;
}

HRESULT CEvalTree::ApplyPredicate(CLeafPredicate* pPred)
{
    CInCritSec ics(&m_cs);

    if(m_pStart != NULL)
        m_pStart->ApplyPredicate(pPred);

    return S_OK;
}


void CEvalTree::operator=(const CEvalTree& Other)
{
    CInCritSec ics(&m_cs);

    delete m_pStart;
    m_pStart  = (Other.m_pStart ? Other.m_pStart->Clone() : NULL);

    if(m_pStart == NULL && Other.m_pStart != NULL)
        throw CX_MemoryException();
    
    m_nNumValues = Other.m_nNumValues;
    if(!m_ObjectInfo.SetLength(m_nNumValues))
        throw CX_MemoryException();
}
        
// renumber the QueryIDs in the leaves of the tree
void CEvalTree::Rebase(QueryID newBase)
{
    CRebasePredicate predRebase(newBase);
    ApplyPredicate(&predRebase);
}

bool CEvalTree::Clear()
{
    CInCritSec ics(&m_cs);

    delete m_pStart;
    m_pStart = CValueNode::GetStandardFalse();
    if(!m_ObjectInfo.SetLength(1))
        return false;

    m_nNumValues = 0;
    return true;
}

void CEvalTree::Dump(FILE* f)
{
    CEvalNode::DumpNode(f, 0, m_pStart);
}

#ifdef CHECK_TREES
void CEvalTree::CheckNodes(CTreeChecker *pChecker)
{
	CInCritSec ics2(&m_cs);
	
	if (m_pStart)
		m_pStart->CheckNode(pChecker);
}
#endif

HRESULT CEvalTree::CreateFromConjunction(CContextMetaData* pNamespace, 
                                  CImplicationList& Implications,
                                  CConjunction* pConj,
                                  CEvalNode** ppRes)
{
    HRESULT hres;

    *ppRes = NULL;

    // Build them for all tokens and AND together
    // ==========================================

    try
    {
        CImplicationList BranchImplications(Implications);
        for(int i = 0; i < pConj->GetNumTokens(); i++)
        {
            CEvalNode* pNew = NULL;
            hres = CEvalTree::BuildFromToken(pNamespace, BranchImplications,
                *pConj->GetTokenAt(i), &pNew);
            if(FAILED(hres))
            {
                delete *ppRes;
                return hres;
            }
    
            if(i > 0)
            {
                CEvalNode* pOld = *ppRes;
                CEvalTree::Combine(pOld, pNew, EVAL_OP_AND, pNamespace, 
                    Implications, true, true, ppRes); // delete both
            }
            else
            {
                *ppRes = pNew;
            }
        }
        return WBEM_S_NO_ERROR;
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::CreateFromDNF(CContextMetaData* pNamespace, 
                                 CImplicationList& Implications,
                                 CDNFExpression* pDNF,
                                 CEvalNode** ppRes)
{
    HRESULT hres;

    // Check if there is only one conjunction to talk about
    // ====================================================

    if(pDNF->GetNumTerms() == 1)
    {
        // Just build that one
        // ===================

        return CreateFromConjunction(pNamespace, Implications, 
                                     pDNF->GetTermAt(0), ppRes);
    }

    // Build them for all conjunctions and OR together
    // ===============================================

    CEvalNode* pRes = NULL;
    for(int i = 0; i < pDNF->GetNumTerms(); i++)
    {
        CEvalNode* pNew;
        hres = CreateFromConjunction(pNamespace, Implications, 
                                     pDNF->GetTermAt(i), &pNew);
        if(FAILED(hres))
        {
            delete pRes;
            return hres;
        }

        if(pRes == NULL)
        {
            pRes = pNew;
        }
        else
        {
            CEvalNode* pNewRes = NULL;
            hres = CEvalTree::Combine(pRes, pNew, EVAL_OP_COMBINE, 
                    pNamespace, Implications, true, true, &pNewRes);
            if(FAILED(hres))
            {
                delete pRes;
                delete pNew;
                return hres;
            }
            pRes = pNewRes;
        }
    }

    *ppRes = pRes;
    return WBEM_S_NO_ERROR;
}

HRESULT CEvalTree::CreateProjection(CEvalTree& Old, CContextMetaData* pMeta,
                            CProjectionFilter* pFilter, 
                            EProjectionType eType, bool bDeleteOld)
{
    delete m_pStart;
    m_pStart = NULL;

    try
    {
        CImplicationList Implications;
        return CEvalTree::Project(pMeta, Implications, Old.m_pStart, pFilter, 
                                    eType, bDeleteOld, &m_pStart);
    }
	catch (CX_MemoryException)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
}

HRESULT CEvalTree::Project(CContextMetaData* pMeta, 
                            CImplicationList& Implications, 
                            CEvalNode* pOldNode, CProjectionFilter* pFilter,
                            EProjectionType eType, bool bDeleteOld,
                            CEvalNode** ppNewNode)
{
    if(pOldNode == NULL)
    {
        *ppNewNode = NULL;
        return WBEM_S_NO_ERROR;
    }

    return pOldNode->Project(pMeta, Implications, pFilter, eType, bDeleteOld, 
                                ppNewNode);
}
    



CPropertyProjectionFilter::CPropertyProjectionFilter()
{
    m_papProperties = new CUniquePointerArray<CPropertyName>;
    if(m_papProperties == NULL)
        throw CX_MemoryException();
}

CPropertyProjectionFilter::~CPropertyProjectionFilter()
{
    delete m_papProperties;
}

bool CPropertyProjectionFilter::IsInSet(CEvalNode* pNode)
{
    if(CEvalNode::GetType(pNode) != EVAL_NODE_TYPE_BRANCH)
        return false;

    CBranchingNode* pBranchingNode = (CBranchingNode*)pNode;
    CPropertyName* pEmbeddedObjName = pBranchingNode->GetEmbeddedObjPropName();
    
    CPropertyName ThisName;
    if(pEmbeddedObjName)
        ThisName = *pEmbeddedObjName;

    int nSubType = pBranchingNode->GetSubType();
    if(nSubType == EVAL_NODE_TYPE_SCALAR || nSubType == EVAL_NODE_TYPE_STRING)
    {
        //
        // Derived from CPropertyNode --- get its property name
        //

        ThisName.AddElement(
            ((CPropertyNode*)pBranchingNode)->GetPropertyName());
    }
    else if(nSubType == EVAL_NODE_TYPE_INHERITANCE)
    {
        // No extra name parts
    }
    else
    {
        //
        // Two-prop, perhaps.  Just say no
        //

        return false;
    }

    //
    // Search for the name in our list
    //

    for(int i = 0; i < m_papProperties->GetSize(); i++)
    {
        if(*(m_papProperties->GetAt(i)) == ThisName)
            return true;
    }

    return false;
}

bool CPropertyProjectionFilter::AddProperty(const CPropertyName& Prop)
{
    CPropertyName* pProp = NULL;
    try
    {
        pProp = new CPropertyName(Prop);
        if(pProp == NULL)
            return false;
    }
	catch (CX_MemoryException)
	{
		return false;
	}

    if(m_papProperties->Add(pProp) < 0)
        return false;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\evaltree.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    DUMBNODE.H

Abstract:

    WBEM Evaluation Tree

History:

--*/

template<class TPropType>
CFullCompareNode<TPropType>::CFullCompareNode(
                                    const CFullCompareNode<TPropType>& Other,
                                    BOOL bChildren)
    : CPropertyNode(Other, FALSE), // copy without children
      m_pRightMost(NULL)  
{
    if(bChildren)
    {
        // Need to copy the children.  Iterate over our test point array
        // =============================================================

        for(TConstTestPointIterator it = Other.m_aTestPoints.Begin(); 
                it != Other.m_aTestPoints.End(); it++)
        {
            CTestPoint<TPropType> NewPoint;
            NewPoint.m_Test = it->m_Test;

            // Make copies of the child branches
            // =================================

            NewPoint.m_pLeftOf = CEvalNode::CloneNode(it->m_pLeftOf);
            NewPoint.m_pAt = CEvalNode::CloneNode(it->m_pAt);

            // Add the test point to the array
            // ===============================

            m_aTestPoints.Append(NewPoint);
        }

        // Copy right-most
        // ===============

        m_pRightMost = CEvalNode::CloneNode(Other.m_pRightMost);
    }
}


template<class TPropType>
HRESULT CFullCompareNode<TPropType>::SetTest(VARIANT& v)
{
    try
    {
        CTokenValue Value;
        if(!Value.SetVariant(v))
            return WBEM_E_OUT_OF_MEMORY;
        m_aTestPoints.Begin()->m_Test = Value;
    
        return WBEM_S_NO_ERROR;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}
    
template<class TPropType>
CFullCompareNode<TPropType>::~CFullCompareNode()
{
    delete m_pRightMost;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::InsertMatching(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications, bool bDeleteArg2)
{
    //=====================================================================
    // 'it' points to the node in 'this' that has the same value as the one 
    // 'it2' points to in pArg2. 'itLast' points to the last unhandled node
    // in 'this' (looking left from 'it').
    //=====================================================================

    CEvalNode* pNew;
    HRESULT hres;

    // Merge our at-values
    // ===================

    hres = CEvalTree::Combine(it->m_pAt, it2->m_pAt, nOp, pNamespace, 
                Implications, true, bDeleteArg2, &pNew);
    if(FAILED(hres))
        return hres;

    if(bDeleteArg2)
        it2->m_pAt = NULL;

    it->m_pAt = pNew;

    // Merge our left-ofs
    // ==================

    hres = CEvalTree::Combine(it->m_pLeftOf, it2->m_pLeftOf, nOp, pNamespace, 
                Implications, true, bDeleteArg2, &pNew);
    if(FAILED(hres))
        return hres;

    if(bDeleteArg2)
        it2->m_pLeftOf = NULL;

    it->m_pLeftOf = pNew;

    //
    // At this point, we need to merge the LeftOf of it2 with all the branches
    // in this that are between the current insertion point and the previous
    // insertion point.  However, we do not need to do this if it2's LeftOf node
    // is a noop for this operation (e.g. TRUE for an AND)
    //

    if(it != itLast && !CEvalNode::IsNoop(it2->m_pLeftOf, nOp))
    {
        hres = CombineWithBranchesToLeft(it, itLast, it2->m_pLeftOf, nOp,
                    pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    }

    // Move first unhandled iterator to the node beyond itLast
    // =======================================================

    itLast = it;
    itLast++;

    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::InsertLess(
            TTestPointIterator it,
            TTestPointIterator it2, TTestPointIterator& itLast,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications, bool bDeleteArg2)
{
    //
    // 'it' points to the node in 'this' that has a slightly larger value than
    // the one 'it2' points to in pArg2. 'itLast' points to the last unhandled 
    // node in 'this' (looking left from 'it').
    //

    HRESULT hres;

    // Check if 'it' is point to the end of the list --- in that case it's
    // "left-of" is actually right-most
    // ===================================================================

    CEvalNode* pItLeft = NULL;
    if(it == m_aTestPoints.End())
        pItLeft = m_pRightMost;
    else
        pItLeft = it->m_pLeftOf;
    

    // First of all, we need to insert the node at it2 into 'this' list, just 
    // before 'it'.
    // ======================================================================

    CTestPoint<TPropType> NewNode = *it2;
    
    // It's at branch is the combination of our left and arg2 at
    // =========================================================

    hres = CEvalTree::Combine(pItLeft, it2->m_pAt, nOp, pNamespace, 
                Implications, false, bDeleteArg2, &NewNode.m_pAt);
    if(FAILED(hres))
        return hres;

    if(bDeleteArg2)
        it2->m_pAt = NULL;

    // It's left-of branch is the combination of our left and arg2 left
    // ================================================================

    // We can reuse it2->Left iff every node left of 'it' in 'this' has been 
    // handled
    // =====================================================================

    bool bDeleteIt2Left = (bDeleteArg2 && (it == itLast));

    hres = CEvalTree::Combine(pItLeft, it2->m_pLeftOf, nOp, pNamespace, 
                Implications, false, bDeleteIt2Left, &NewNode.m_pLeftOf);
    if(FAILED(hres))
        return hres;

    if(bDeleteIt2Left)
        it2->m_pLeftOf = NULL;

    // IMPORTANT: Once we insert the new node, all the iterators into 'this'
    // will be invalidated --- that includes it and itLast. So, we need to do
    // out left-walk before we actually insert.
    // ===================================================

    //
    // At this point, we need to merge the LeftOf of it2 with all the branches
    // in this that are between the current insertion point and the previous
    // insertion point.  However, we do not need to do this if it2's LeftOf node
    // is a noop for this operation (e.g. TRUE for an AND)
    //

    if(it != itLast && !CEvalNode::IsNoop(it2->m_pLeftOf, nOp))
    {
        //
        // Note to self: bDeleteIt2Left could not have been true, so 
        // it2->m_pLeftOf could not have been deleted.  We are OK here
        //

        hres = CombineWithBranchesToLeft(it, itLast, it2->m_pLeftOf, nOp,
                    pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    }

    // Now we can actually insert
    // ==========================

    TTestPointIterator itNew = m_aTestPoints.Insert(it, NewNode);

    // Move first unhandled iterator to the node just right of insertion
    // =================================================================

    itLast = itNew;
    itLast++;

    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::CombineWithBranchesToLeft(
            TTestPointIterator itWalk, TTestPointIterator itLast,
            CEvalNode* pArg2,
            int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications)
{
    HRESULT hres;
    CEvalNode* pNew = NULL;

    // Walk left until we reach the first unhandled node
    // =================================================

    do
    {
        if(itWalk == m_aTestPoints.Begin())
            break;

        itWalk--;

        // Merge at-value
        // ==============
    
        hres = CEvalTree::Combine(itWalk->m_pAt, pArg2, nOp, 
                    pNamespace, Implications, true, false, &pNew);
        if(FAILED(hres))
            return hres;
    
        itWalk->m_pAt = pNew;
    
        // Merge left-ofs
        // ==============
    
        hres = CEvalTree::Combine(itWalk->m_pLeftOf, pArg2, nOp, 
                    pNamespace, Implications, true, false, &pNew);
        if(FAILED(hres))
            return hres;
    
        itWalk->m_pLeftOf = pNew;
    }
    while(itWalk != itLast);

    return WBEM_S_NO_ERROR;
}
                

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::CombineBranchesWith(
            CBranchingNode* pRawArg2, int nOp, CContextMetaData* pNamespace,
            CImplicationList& Implications, 
            bool bDeleteThis, bool bDeleteArg2, CEvalNode** ppRes)
{
    HRESULT hres;
    CFullCompareNode<TPropType>* pArg2 = (CFullCompareNode<TPropType>*)pRawArg2;
    *ppRes = NULL;

    // Check which one is larger
    // =========================

    if(m_aTestPoints.GetSize() < pArg2->m_aTestPoints.GetSize())
    {
        return pArg2->CombineBranchesWith(this, FlipEvalOp(nOp), pNamespace,
                            Implications, bDeleteArg2, bDeleteThis, ppRes);
    }

    if(!bDeleteThis)
    {
        // Damn. Clone. 
        // ============

        return ((CFullCompareNode<TPropType>*)Clone())->CombineBranchesWith(
            pRawArg2, nOp, pNamespace, Implications, true, // reuse clone!
            bDeleteArg2, ppRes);
    }
    
    CEvalNode* pNew = NULL;

    TTestPointIterator itLast = m_aTestPoints.Begin();
    
    // 
    // itLast points to the left-most location in our list of test points that 
    // we have not considered yet --- it is guaranteed that any further 
    // insertions from the second list will occur after this point
    //

    //
    // it2, on the other hand, iterates simply over the second list of test 
    // points, inserting each one into the combined list one by one
    //

    for(TTestPointIterator it2 = pArg2->m_aTestPoints.Begin();
        it2 != pArg2->m_aTestPoints.End(); it2++)
    {
        
        //
        // First, we search for the location in our list of test points of the
        // insertion point for the value of it2.  bMatch is set to true if the
        // same test point exists, and false if it does not and the returned
        // iterator points to the element to the right of the insertion point.
        //

        TTestPointIterator it;
        bool bMatch = m_aTestPoints.Find(it2->m_Test, &it);
        if(bMatch)
        {
            hres = InsertMatching(it, it2, itLast, nOp, pNamespace,
                        Implications, bDeleteArg2);
        }
        else
        {
            hres = InsertLess(it, it2, itLast, nOp, pNamespace,
                        Implications, bDeleteArg2);
            // invalidates 'it'!
        }

        if(FAILED(hres))
            return hres;
    }
        
    //
    // At this point, we need to merge the RightMost of arg2 with all the 
    // branches in this that come after the last insertion point.
    // However, we do not need to do this if arg2's RightMost node
    // is a noop for this operation (e.g. TRUE for an AND)
    //

    if(itLast != m_aTestPoints.End() && 
        !CEvalNode::IsNoop(pArg2->m_pRightMost, nOp))
    {
        hres = CombineWithBranchesToLeft(m_aTestPoints.End(), itLast, 
                    pArg2->m_pRightMost, nOp, pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    }

    hres = CEvalTree::Combine(m_pRightMost, pArg2->m_pRightMost, nOp, 
                    pNamespace, Implications, true, bDeleteArg2, 
                    &pNew);
    if(FAILED(hres))
        return hres;

    m_pRightMost = pNew;

    if(bDeleteArg2)
        pArg2->m_pRightMost = NULL;

    // Merge the nulls
    // ===============

    CEvalTree::Combine(m_pNullBranch, pArg2->m_pNullBranch, nOp, 
                        pNamespace, Implications, true, bDeleteArg2, 
                        &pNew);
    m_pNullBranch = pNew;

    // Reset them in deleted versions
    // ==============================

    if(bDeleteArg2)
        pArg2->m_pNullBranch = NULL;

    // Delete what needs deleting
    // ==========================

    if(bDeleteArg2)
        delete pArg2;

    *ppRes = this;
    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::CombineInOrderWith(CEvalNode* pArg2,
                                    int nOp, CContextMetaData* pNamespace, 
                                    CImplicationList& OrigImplications,
                                    bool bDeleteThis, bool bDeleteArg2,
                                    CEvalNode** ppRes)
{
    HRESULT hres;
    *ppRes = Clone();
    if(*ppRes == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CFullCompareNode<TPropType>* pNew = (CFullCompareNode<TPropType>*)*ppRes;

    try
    {
        CImplicationList Implications(OrigImplications);
        hres = pNew->AdjustCompile(pNamespace, Implications);
        if(FAILED(hres))
            return hres;
    
        CEvalNode* pNewBranch = NULL;
    
        for(TTestPointIterator it = pNew->m_aTestPoints.Begin(); 
            it != pNew->m_aTestPoints.End(); it++)
        {
            // Combine our At-branch with pArg2
            // ================================
    
            hres = CEvalTree::Combine(it->m_pAt, pArg2, nOp, pNamespace, 
                Implications, true, false, &pNewBranch);
            if(FAILED(hres))
            {
                delete pNew;
                return hres;
            }
            it->m_pAt = pNewBranch;
    
            // Now do the same for our left-of branch
            // ======================================
    
            hres = CEvalTree::Combine(it->m_pLeftOf, pArg2, nOp, pNamespace, 
                Implications, true, false, &pNewBranch);
            if(FAILED(hres))
            {
                delete pNew;
                return hres;
            }
            it->m_pLeftOf = pNewBranch;
        }
    
        hres = CEvalTree::Combine(pNew->m_pRightMost, pArg2, nOp, pNamespace, 
            Implications, true, false, &pNewBranch);
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }
    
        pNew->m_pRightMost = pNewBranch;
    
        hres = CEvalTree::Combine(pNew->m_pNullBranch, pArg2, nOp, pNamespace, 
            Implications, true, false, &pNewBranch);
        if(FAILED(hres))
        {
            delete pNew;
            return hres;
        }
    
        pNew->m_pNullBranch = pNewBranch;
    
        if(bDeleteThis)
            delete this;
        if(bDeleteArg2)
            delete pArg2;
        return WBEM_S_NO_ERROR;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}

template<class TPropType>
int CFullCompareNode<TPropType>::SubCompare(CEvalNode* pRawOther)
{
    CFullCompareNode<TPropType>* pOther = 
        (CFullCompareNode<TPropType>*)pRawOther;

    // Compare handles
    // ===============

    int nCompare;
    nCompare = m_lPropHandle - pOther->m_lPropHandle;
    if(nCompare)
        return nCompare;

    // Compare array sizes
    // ===================

    nCompare = m_aTestPoints.GetSize() - pOther->m_aTestPoints.GetSize();
    if(nCompare)
        return nCompare;

    // Compare all points
    // ==================

    TTestPointIterator it;
    TTestPointIterator itOther;
    for(it = m_aTestPoints.Begin(), itOther = pOther->m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++, itOther++)
    {
        if(it->m_Test < itOther->m_Test)
            return -1;
        else if(it->m_Test > itOther->m_Test)
            return 1;
    }

    // Compare all branches
    // ====================

    for(it = m_aTestPoints.Begin(), itOther = pOther->m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++, itOther++)
    {
        nCompare = CEvalTree::Compare(it->m_pLeftOf, itOther->m_pLeftOf);
        if(nCompare)
            return nCompare;

        nCompare = CEvalTree::Compare(it->m_pAt, itOther->m_pAt);
        if(nCompare)
            return nCompare;
    }

    return 0;
}
    
template<class TPropType>
HRESULT CFullCompareNode<TPropType>::OptimizeSelf()
{
    TTestPointIterator it = m_aTestPoints.Begin();
    while(it != m_aTestPoints.End())
    {
        TTestPointIterator itPrev = it;
        it++;

        CEvalNode** ppLeft = &itPrev->m_pLeftOf;
        CEvalNode** ppMiddle = &itPrev->m_pAt;
        CEvalNode** ppRight = it != m_aTestPoints.End() ? 
                                       &it->m_pLeftOf : &m_pRightMost;

        //
        // compare all three test point nodes.  If all the same then we 
        // can optimize the test point out.  Also, two nodes are treated 
        // the same if at least one of them is the invalid node.
        // 

        if ( !CEvalNode::IsInvalid( *ppLeft ) )
        {
            if ( !CEvalNode::IsInvalid( *ppMiddle ) )
            {     
                if( CEvalTree::Compare( *ppLeft, *ppMiddle ) != 0 )
                {
                    continue;
                }
            }
            else
            {
                ppMiddle = ppLeft;
            }
        }

        if ( !CEvalNode::IsInvalid( *ppMiddle ) )
        {
            if ( !CEvalNode::IsInvalid( *ppRight ) )
            {       
                if( CEvalTree::Compare( *ppMiddle, *ppRight ) != 0 )
                {
                    continue;
                }    
            }
                
            //
            // we're going to optimize the test point out, but first 
            // make sure to set rightmost to point to the middle branch. 
            // Make sure to unhook appropriate pointers before removing 
            // the test node, since it owns the memory for them.
            //
 
            delete *ppRight;
            *ppRight = *ppMiddle;
            *ppMiddle = NULL;
        }

        //
        // optimize the test point out.
        // 
        it = m_aTestPoints.Remove( itPrev );
    }

    return S_OK;
}

template<class TPropType>
DWORD CFullCompareNode<TPropType>::ApplyPredicate(CLeafPredicate* pPred)
{
    DWORD dwRes;
    for(TTestPointIterator it = m_aTestPoints.Begin();
        it != m_aTestPoints.End(); it++)
    {
        if (it->m_pLeftOf)
        {
            dwRes = it->m_pLeftOf->ApplyPredicate(pPred);
            if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
            {
                delete it->m_pLeftOf;
                it->m_pLeftOf = NULL;
            }
            else if ( dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE )
            {
                delete it->m_pLeftOf;
                it->m_pLeftOf = CValueNode::GetStandardInvalid();
            }
        }

        if (it->m_pAt)
        {
            dwRes = it->m_pAt->ApplyPredicate(pPred);
            if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
            {
                delete it->m_pAt;
                it->m_pAt = NULL;
            }
            else if ( dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE )
            {
                delete it->m_pAt;
                it->m_pAt = CValueNode::GetStandardInvalid();
            }
        }
    }

    if (m_pRightMost)
    {
        dwRes = m_pRightMost->ApplyPredicate(pPred);
        if(dwRes & WBEM_DISPOSITION_FLAG_DELETE)
        {
            delete m_pRightMost;
            m_pRightMost = NULL;
        }
        else if ( dwRes & WBEM_DISPOSITION_FLAG_INVALIDATE )
        {
            delete m_pRightMost;
            m_pRightMost = CValueNode::GetStandardInvalid();
        }
    }

    return CBranchingNode::ApplyPredicate(pPred);
}

        
    
template<class TPropType>
HRESULT CFullCompareNode<TPropType>::Optimize(CContextMetaData* pNamespace, 
                                                CEvalNode** ppNew)
{
    CEvalNode* pNew = NULL;
    HRESULT hres;

    // Optimize all branches
    // =====================

    for(TTestPointIterator it = m_aTestPoints.Begin();
        it != m_aTestPoints.End(); it++)
    {
        if (it->m_pLeftOf)
        {
            hres = it->m_pLeftOf->Optimize(pNamespace, &pNew);
            if(FAILED(hres))
                return hres;

            if(pNew != it->m_pLeftOf)
            {
                delete it->m_pLeftOf;
                it->m_pLeftOf = pNew;
            }
        }

        if (it->m_pAt)
        {
            hres = it->m_pAt->Optimize(pNamespace, &pNew);

            if(FAILED(hres))
                return hres;

            if(pNew != it->m_pAt)
            {
                delete it->m_pAt;
                it->m_pAt = pNew;
            }
        }
    }

    if (m_pRightMost)
    {
        hres = m_pRightMost->Optimize(pNamespace, &pNew);
        if(FAILED(hres))
            return hres;

        if(pNew != m_pRightMost)
        {
            delete m_pRightMost;
            m_pRightMost = pNew;
        }
    }

    if (m_pNullBranch)
    {
        hres = m_pNullBranch->Optimize(pNamespace, &pNew);
   
        if(FAILED(hres))
            return hres;

        if(pNew != m_pNullBranch)
        {
            delete m_pNullBranch;
            m_pNullBranch = pNew;
        }
    }


    // Optimize ourselves
    // ==================

    hres = OptimizeSelf();
    if(FAILED(hres))
        return hres;
    
    *ppNew = this;

    //
    // Check if this node has become superflous
    // 

    if( m_aTestPoints.GetSize() == 0 )
    {
        if ( !CEvalNode::IsInvalid( m_pRightMost ) )
        {
            if ( !CEvalNode::IsInvalid( m_pNullBranch ) )
            {
                if ( CEvalTree::Compare(m_pNullBranch, m_pRightMost) == 0 ) 
                {
                    // 
                    // both the null and rightmost are the same.  Optimize 
                    // this node out and return the rightmost branch.
                    // 
                    *ppNew = m_pRightMost;

                    //
                    // Untie m_pRightMost (so it is not deleted when we are)
                    //
                    m_pRightMost = NULL;
                }
            }
            else if ( m_pRightMost == NULL )
            {
                //
                // the right branch is false and the null branch is invalid.  
                // Optimize this node to false.
                //                 
                *ppNew = NULL;
            }
        }
        else if ( m_pNullBranch == NULL )
        {
            //
            // the null branch is false and the rightmost is invalid.  
            // Optimize this node to false. 
            // 
            *ppNew = NULL;
        }
        else if ( CEvalNode::IsInvalid( m_pNullBranch ) )
        {       
            //
            // both are invalid, but we can't invalidate the whole node 
            // because we're not sure what we optimized out in the test
            // points, so just optimize this node to false.
            //
            *ppNew = NULL;
        }
    }

    return S_OK;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::SetNullTest(int nOperator)
{
    if(nOperator == QL1_OPERATOR_EQUALS)
    {
        m_pRightMost = CValueNode::GetStandardFalse();

        CEvalNode* pNode = CValueNode::GetStandardTrue();
        if(pNode == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        SetNullBranch(pNode);
    }
    else if(nOperator == QL1_OPERATOR_NOTEQUALS)
    {
        m_pRightMost = CValueNode::GetStandardTrue();
        if(m_pRightMost == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        SetNullBranch(CValueNode::GetStandardFalse());
    }
    else
        return WBEM_E_INVALID_QUERY;

    return WBEM_S_NO_ERROR;
}

template<class TPropType>
HRESULT CFullCompareNode<TPropType>::SetOperator(int nOperator)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    #define GET_STD_TRUE CValueNode::GetStandardTrue()
    #define GET_STD_FALSE CValueNode::GetStandardFalse()

    #define SET_TRUE(NODE) { \
            NODE = GET_STD_TRUE; \
            if(NODE == NULL) { \
                hr = WBEM_E_OUT_OF_MEMORY; \
                break; } }

    #define SET_FALSE(NODE) {NODE = GET_STD_FALSE;}

    CTestPoint<TPropType> NewNode;
    
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        SET_FALSE(NewNode.m_pLeftOf);
        SET_TRUE(NewNode.m_pAt);
        SET_FALSE(m_pRightMost);
        break;

    case QL1_OPERATOR_NOTEQUALS:
        SET_TRUE(NewNode.m_pLeftOf);
        SET_FALSE(NewNode.m_pAt);
        SET_TRUE(m_pRightMost);
        break;

    case QL1_OPERATOR_LESS:
        SET_TRUE(NewNode.m_pLeftOf);
        SET_FALSE(NewNode.m_pAt);
        SET_FALSE(m_pRightMost);
        break;
        
    case QL1_OPERATOR_GREATER:
        SET_FALSE(NewNode.m_pLeftOf);
        SET_FALSE(NewNode.m_pAt);
        SET_TRUE(m_pRightMost);
        break;
    
    case QL1_OPERATOR_LESSOREQUALS:
        SET_TRUE(NewNode.m_pLeftOf);
        SET_TRUE(NewNode.m_pAt);
        SET_FALSE(m_pRightMost);
        break;

    case QL1_OPERATOR_GREATEROREQUALS:
        SET_FALSE(NewNode.m_pLeftOf);
        SET_TRUE(NewNode.m_pAt);
        SET_TRUE(m_pRightMost);
        break;
    default:
        hr = WBEM_E_CRITICAL_ERROR;
    }

    if ( SUCCEEDED(hr) )
    {       
        m_aTestPoints.Append(NewNode);
    }
    else
    {        
        NewNode.Destruct();
    }

    return hr;
}


//******************************************************************************
//******************************************************************************
//                  SCALAR PROPERTY NODE
//******************************************************************************
//******************************************************************************

template<class TPropType>
HRESULT CScalarPropNode<TPropType>::Evaluate(CObjectInfo& ObjInfo, 
                                                INTERNAL CEvalNode** ppNext)
{
    HRESULT hres;
    _IWmiObject* pObj;
    hres = GetContainerObject(ObjInfo, &pObj);
    if(FAILED(hres)) return hres;

    // Get the property from the object
    // ================================

    long lRead;
    TPropType Value;
    hres = pObj->ReadPropertyValue(m_lPropHandle, sizeof(TPropType), 
                                            &lRead, (BYTE*)&Value);
    if( S_OK != hres )
    {
        if(hres == WBEM_S_FALSE)
        {
            *ppNext = m_pNullBranch;
            return WBEM_S_NO_ERROR;
        }
        else
        {
            return hres;
        }
    }
    
    // Search for the value
    // ====================

    TTestPointIterator it;
    bool bMatch = m_aTestPoints.Find(Value, &it);
    if(bMatch)
        *ppNext = it->m_pAt;
    else if(it == m_aTestPoints.End())
        *ppNext = m_pRightMost;
    else
        *ppNext = it->m_pLeftOf;
        
    return WBEM_S_NO_ERROR;
}

template<class TPropType>
void CScalarPropNode<TPropType>::Dump(FILE* f, int nOffset)
{
    CBranchingNode::Dump(f, nOffset);
    PrintOffset(f, nOffset);
    fprintf(f, "LastPropName = (0x%x), size=%d\n", 
        m_lPropHandle, sizeof(TPropType));

   TConstTestPointIterator it;
   for(it = m_aTestPoints.Begin(); 
        it != m_aTestPoints.End(); it++)
    {
        PrintOffset(f, nOffset);
        if (it != m_aTestPoints.Begin())
        {
            TConstTestPointIterator itPrev(it);
            itPrev--;
            fprintf(f, "%d < ", (int)(itPrev->m_Test));
        }
        fprintf(f, "X < %d\n", (int)(it->m_Test));
        DumpNode(f, nOffset+1, it->m_pLeftOf);

        PrintOffset(f, nOffset);
        fprintf(f, "X = %d\n", (int)(it->m_Test));
        DumpNode(f, nOffset+1, it->m_pAt);
    }    
    
    PrintOffset(f, nOffset);
    if (it != m_aTestPoints.Begin())
    {
        TConstTestPointIterator itPrev(it);
        itPrev--;
        fprintf(f, "X > %d\n", (int)(itPrev->m_Test));
    }
    else
        fprintf(f, "ANY\n");
    DumpNode(f, nOffset+1, m_pRightMost);


    PrintOffset(f, nOffset);
    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\groupsforuser.h ===
//****************************************************************************
//
//  Copyright (C) 1999 Microsoft Corporation
//
//  GROUPSFORUSER.H
//
//****************************************************************************

#ifndef __Groups_For_User_Compiled__
#define __Groups_For_User_Compiled__

#include <authz.h>
#include "esscpol.h"
#include <NTSECAPI.H>

// you'll need to link to netapi32.lib for this to fly

// retireves access mask corresponding to permissions granted
// by dacl to account denoted by pSid
NTSTATUS ESSCLI_POLARITY GetAccessMask( PSID pSid, PACL pDacl, DWORD *pAccessMask );

// returns STATUS_SUCCESS if user is in group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
NTSTATUS ESSCLI_POLARITY IsUserInGroup( PSID pSidUser, PSID pSidGroup );
NTSTATUS ESSCLI_POLARITY IsUserAdministrator( PSID pSidUser );


#ifndef __AUTHZ_H__

#include <wbemcli.h>
#include <winntsec.h>
#include "esscpol.h"
#include <NTSECAPI.H>


// given a SID & server name
// will return all groups of which user is a member
// callers responsibility to HeapFree apSids & the memory to which they point.
// pdwCount points to dword to receive count of group sids returned.
// serverName may be NULL, in which case this function will look up 
// the sid on the local computer, and query the DC if required.
NTSTATUS ESSCLI_POLARITY EnumGroupsForUser( LPCWSTR userName, 
                                            LPCWSTR domainName, 
                                            LPCWSTR serverName, 
                                            PSID **apGroupSids, 
                                            DWORD *pdwCount );

// much the same as above except we are
// given user name, domain name & server name
// server name must not be NULL, it can, however
// be the name of the local computer
NTSTATUS ESSCLI_POLARITY EnumGroupsForUser( PSID pSid, 
                                            LPCWSTR serverName, 
                                            PSID **apGroupSids, 
                                            DWORD *pdwCount ); 

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\filtprox.h ===
//******************************************************************************
//
//  FILTPROX.H
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************
#ifndef __WBEM_FILTER_PROXY__H_
#define __WBEM_FILTER_PROXY__H_

#include <evaltree.h>

class CTimeKeeper
{
protected:
    CCritSec m_cs;
    FILETIME m_ftLastEvent;
    DWORD m_dwEventCount;
    long m_lTimeHandle;
    bool m_bHandleInit;

public:
    CTimeKeeper() : m_dwEventCount(0), m_lTimeHandle(0), m_bHandleInit(false)
    {
        m_ftLastEvent.dwLowDateTime = m_ftLastEvent.dwHighDateTime = 0;
    }

    bool DecorateObject(_IWmiObject* pObj);
};

class CWrappingMetaData : public CMetaData
{
protected:
    IWbemMetaData* m_pDest;
public:
    CWrappingMetaData(IWbemMetaData* pDest) : m_pDest(pDest)
        {m_pDest->AddRef();}
    ~CWrappingMetaData()
        {m_pDest->Release();}

    STDMETHOD(GetClass)(LPCWSTR wszName, IWbemContext* pContext,
                            IWbemClassObject** ppClass)
        {return m_pDest->GetClass(wszName, pContext, ppClass);}

    virtual HRESULT GetClass(LPCWSTR wszName, IWbemContext* pContext,
                            _IWmiObject** ppClass);
};

class CEventBatch
{
public:
    CEventBatch();
    ~CEventBatch();

    BOOL EnsureAdditionalSize(DWORD nAdditionalNeeded);
    BOOL AddEvent(IWbemClassObject *pObj, CSortedArray *pTrues);
    void RemoveAll();

    void SetItemCount(DWORD nItems) { m_nItems = nItems; }
    DWORD GetItemCount() { return m_nItems; }
    IWbemClassObject **GetObjs() { return m_ppObjs; }
    WBEM_REM_TARGETS *GetTargets() { return m_pTargets; }

protected:
    DWORD            m_nItems,
                     m_dwSize;
    IWbemClassObject **m_ppObjs;
    WBEM_REM_TARGETS *m_pTargets;
};

class CFilterProxyManager;
class CFilterProxy : public IWbemEventSink, public IMarshal
{
protected:
    long m_lRef;
    CFilterProxyManager* m_pManager;
    CWrappingMetaData* m_pMetaData;

    CEvalTree m_SourceDefinition;
    CEvalTree m_Filter;
    WORD m_wSourceVersion;
    WORD m_wAppliedSourceVersion;

    long m_lSDLength;
    BYTE* m_pSD;

    IWbemEventProvider* m_pProvider;
    IWbemEventProviderQuerySink* m_pQuerySink;
    bool m_bRunning;
    bool m_bUtilizeGuarantee;

    CCritSec m_cs;

    static CTimeKeeper mstatic_TimeKeeper;

    /////////////////////////////////////////////////////////////////////////
    // Batching members
    
    void BatchEvent(IWbemClassObject *pObj, CSortedArray *pTrues);
    HRESULT BatchMany(long nEvents, IUnknown **ppObjects);
    BOOL IsBatching() { return m_bBatching; }
    
    WBEM_BATCH_TYPE m_typeBatch;
    DWORD           m_dwCurrentBufferSize,
                    m_dwMaxBufferSize,
                    m_dwMaxSendLatency,
                    m_dwLastSentStamp;
    BOOL            m_bBatching;


public:
    static BYTE mstatic_EmptySD;

    HRESULT Lock();
    HRESULT Unlock();
    HRESULT AddFilter(IWbemContext* pContext, LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT RemoveFilter(IWbemContext* pContext, 
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT RemoveAllFilters(IWbemContext* pContext);
    HRESULT AddDefinitionQuery(IWbemContext* pContext, LPCWSTR wszQuery);
    HRESULT RemoveAllDefinitionQueries(IWbemContext* pContext);

    HRESULT AllowUtilizeGuarantee();
    HRESULT TransferFiltersFromMain(CFilterProxy* pMain);
    HRESULT FilterEvent( _IWmiObject* pEvent, CSortedArray& raTrues );

public:
    CFilterProxy(CFilterProxyManager* pManager, IUnknown* pCallback = NULL);
    ~CFilterProxy();

    HRESULT SetRunning();

    // IUnknown

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    // IWbemObjectSink

    HRESULT STDMETHODCALLTYPE Indicate(long lNumObjects, 
                                        IWbemClassObject** apObjects);
    HRESULT STDMETHODCALLTYPE SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj);

    HRESULT STDMETHODCALLTYPE IndicateWithSD(
                long lNumObjects,
                IUnknown** apObjects,
                long lSDLength,
                BYTE* pSD);

    HRESULT STDMETHODCALLTYPE SetSinkSecurity(
                long lSDLength,
                BYTE* pSD);

    HRESULT STDMETHODCALLTYPE IsActive();

    HRESULT STDMETHODCALLTYPE GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink);

    HRESULT STDMETHODCALLTYPE SetBatchingParameters(
                LONG lFlags,
                DWORD dwMaxBufferSize,
                DWORD dwMaxSendLatency);

    // IMarshal

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv)
            {return E_NOTIMPL;}
    STDMETHOD(ReleaseMarshalData)(IStream* pStream)
            {return E_NOTIMPL;}
    STDMETHOD(DisconnectObject)(DWORD dwReserved)
            {return E_NOTIMPL;}

protected:
    HRESULT ProcessOne(IUnknown* pObj, long lSDLength, BYTE* pSD);
    HRESULT ProcessMany(long lNumObjects, IUnknown** apObjects, 
                        long lSDLength, BYTE* pSD);
    static void SetGenerationTime(_IWmiObject* pObj);
};

class CFilterProxyManagerBase
{
    CLifeControl* m_pControl;
    
public:

    CFilterProxyManagerBase( CLifeControl* pControl ) : m_pControl(pControl)
    {
        if( m_pControl != NULL )
        {
            m_pControl->ObjectCreated( (IUnknown*)this );
        }
    }

    ~CFilterProxyManagerBase()
    {
       if( m_pControl != NULL )
       {
           m_pControl->ObjectDestroyed( (IUnknown*)this );
       }
    }
};

class CFilterProxyManager : public IMarshal, CFilterProxyManagerBase
{
protected:
    long m_lRef;
    long m_lExtRef;

    IWbemMultiTarget* m_pMultiTarget; 
    CWrappingMetaData* m_pMetaData;
    IWbemFilterStub* m_pStub;
    IWbemContext* m_pSpecialContext;

    CCritSec m_cs;
    CWbemCriticalSection m_Lock;

    CUniquePointerArray<CFilterProxy> m_apProxies;

    typedef std::map< WBEM_REMOTE_TARGET_ID_TYPE, 
                      WString, 
                      std::less< WBEM_REMOTE_TARGET_ID_TYPE >, 
                      wbem_allocator< WString > > TMap;
    typedef TMap::iterator TIterator;
    TMap m_mapQueries;

    /////////////////////////////////////////////////////////////////////////
    // Protected batching members
    typedef std::map< CFilterProxy*, 
                      DWORD, 
                      std::less< CFilterProxy* >, 
                      wbem_allocator< DWORD > > CLatencyMap;
    typedef CLatencyMap::iterator CLatencyMapItor;

    CLatencyMap m_mapLatencies;
    HANDLE      m_heventDone,
                m_hthreadSend,
                m_heventEventsPending,
                m_heventBufferNotFull,
                m_heventBufferFull;
    DWORD       m_dwMaxSendLatency,
                m_dwLastSentStamp;
    CCritSec    m_csBuffer;
    CEventBatch m_batch;
    IStream     *m_pMultiTargetStream;

    void LockBatching() { EnterCriticalSection(&m_csBuffer); }
    void UnlockBatching() { LeaveCriticalSection(&m_csBuffer); }
    BOOL IsBatching() { return m_hthreadSend != NULL; }
    CEventBatch *GetBatch(LPBYTE pSD, DWORD dwLength);
    void CalcMaxSendLatency();

    static DWORD WINAPI SendThreadProc(CFilterProxyManager *pThis);

    BOOL StartSendThread();
    void StopSendThread();

protected:

    class XProxy : public IWbemLocalFilterProxy
    {
    protected:
        CFilterProxyManager* m_pObject;
    public:

        XProxy(CFilterProxyManager* pObject) : m_pObject(pObject){}

        // IUnknown
    
        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    
        // IWbemFilterProxy
    
        HRESULT STDMETHODCALLTYPE Initialize(IWbemMetaData* pMetaData,
                            IWbemMultiTarget* pMultiTarget);
        HRESULT STDMETHODCALLTYPE Lock();
        HRESULT STDMETHODCALLTYPE Unlock();
        HRESULT STDMETHODCALLTYPE AddFilter(IWbemContext* pContext, 
                            LPCWSTR wszQuery, 
                            WBEM_REMOTE_TARGET_ID_TYPE Id);
        HRESULT STDMETHODCALLTYPE RemoveFilter(IWbemContext* pContext, 
                            WBEM_REMOTE_TARGET_ID_TYPE Id);
        HRESULT STDMETHODCALLTYPE RemoveAllFilters(IWbemContext* pContext);
    
        HRESULT STDMETHODCALLTYPE AddDefinitionQuery(IWbemContext* pContext, 
                            LPCWSTR wszQuery);
        HRESULT STDMETHODCALLTYPE RemoveAllDefinitionQueries(
                            IWbemContext* pContext);
        HRESULT STDMETHODCALLTYPE AllowUtilizeGuarantee();
        HRESULT STDMETHODCALLTYPE Disconnect();

        HRESULT STDMETHODCALLTYPE SetStub(IWbemFilterStub* pStub);
        HRESULT STDMETHODCALLTYPE LocalAddFilter(IWbemContext* pContext, 
                        LPCWSTR wszQuery, 
                        void* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
        HRESULT STDMETHODCALLTYPE GetMainSink(IWbemEventSink** ppSink);
    } m_XProxy;

    IWbemContext* GetProperContext(IWbemContext* pCurrentContext);
public:
    CFilterProxyManager(CLifeControl* pControl = NULL);
    ~CFilterProxyManager();

    HRESULT SetStub(IWbemFilterStub* pStub);
    HRESULT AddFilter(IWbemContext* pContext, LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id);

    INTERNAL IWbemEventSink* GetMainProxy();
    HRESULT RemoveProxy(CFilterProxy* pProxy);
    HRESULT GetMetaData(RELEASE_ME CWrappingMetaData** ppMeta);
    HRESULT DeliverEvent(long lNumToSend, IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                        long lSDLength, BYTE* pSD);
    HRESULT DeliverEventMT(long lNumToSend, IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                        long lSDLength, BYTE* pSD,
                                        IWbemMultiTarget *pMultiTarget);

    ULONG STDMETHODCALLTYPE AddRefProxy();
    ULONG STDMETHODCALLTYPE ReleaseProxy();

    HRESULT SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj);

    // Batching
    void AddEvent(IWbemClassObject *pObj, CSortedArray *pTrues);
    HRESULT SetProxyLatency(CFilterProxy *pProxy, DWORD dwLatency);
    void RemoveProxyLatency(CFilterProxy *pProxy);
    DWORD GetLastSentStamp();
    void WaitForEmptyBatch();

    // IUnknown

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);

    // IWbemFilterProxy

    HRESULT STDMETHODCALLTYPE Initialize(IWbemMetaData* pMetaData,
                        IWbemMultiTarget* pMultiTarget);
    HRESULT STDMETHODCALLTYPE Lock();
    HRESULT STDMETHODCALLTYPE Unlock();
    HRESULT STDMETHODCALLTYPE AddFilter(IWbemContext* pContext, 
                        LPCWSTR wszQuery, 
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT STDMETHODCALLTYPE RemoveFilter(IWbemContext* pContext, 
                        WBEM_REMOTE_TARGET_ID_TYPE Id);
    HRESULT STDMETHODCALLTYPE RemoveAllFilters(IWbemContext* pContext);

    HRESULT STDMETHODCALLTYPE AddDefinitionQuery(IWbemContext* pContext, 
                        LPCWSTR wszQuery);
    HRESULT STDMETHODCALLTYPE RemoveAllDefinitionQueries(
                        IWbemContext* pContext);
    HRESULT STDMETHODCALLTYPE AllowUtilizeGuarantee();
    HRESULT STDMETHODCALLTYPE Disconnect();

    HRESULT STDMETHODCALLTYPE GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink);

    // IMarshal

    STDMETHOD(GetUnmarshalClass)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, CLSID* pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, void* pv, DWORD dwDestContext,
        void* pvReserved, DWORD mshlFlags, ULONG* plSize);
    STDMETHOD(MarshalInterface)(IStream* pStream, REFIID riid, void* pv, 
        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags);
    STDMETHOD(UnmarshalInterface)(IStream* pStream, REFIID riid, void** ppv);
    STDMETHOD(ReleaseMarshalData)(IStream* pStream);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\filtprox.cpp ===
//******************************************************************************
//
//  FILTPROX.CPP
//
//  Copyright (C) 1996-1999 Microsoft Corporation
//
//******************************************************************************

#include "precomp.h"
#include <stdio.h>
#include "pragmas.h"
#include <wbemcomn.h>
#include "filtprox.h"
#include <eventrep.h>
#include <evtools.h>
#include <wbemdcpl.h>
#include <newnew.h>

#define MAX_TOKENS_IN_DNF 100

#ifdef DBG
#define _ESSCLI_ASSERT(X) { if (!(X)) { DebugBreak(); } }
#else
#define _ESSCLI_ASSERT(X)
#endif

CTempMemoryManager g_TargetsManager;

bool TempSetTargets(WBEM_REM_TARGETS* pTargets, CSortedArray* pTrues)
{
    int nSize = pTrues->Size();
    pTargets->m_lNumTargets = nSize;
    pTargets->m_aTargets = (WBEM_REMOTE_TARGET_ID_TYPE*)
                                g_TargetsManager.Allocate(
                                    sizeof(WBEM_REMOTE_TARGET_ID_TYPE) * nSize);
    if(pTargets->m_aTargets == NULL)
        return false;

    for(int i = 0; i < nSize; i++)
    {
        pTargets->m_aTargets[i] = (WBEM_REMOTE_TARGET_ID_TYPE)pTrues->GetAt(i);
    }

    return true;
}

void TempClearTargets(WBEM_REM_TARGETS* pTargets)
{
    g_TargetsManager.Free(pTargets->m_aTargets,
                 sizeof(WBEM_REMOTE_TARGET_ID_TYPE) * pTargets->m_lNumTargets);
}



//#define DUMP_DEBUG_TREES 1
bool CTimeKeeper::DecorateObject(_IWmiObject* pObj)
{
    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);
    
    {
        CInCritSec ics(&m_cs);

        if(ft.dwLowDateTime == m_ftLastEvent.dwLowDateTime &&
           ft.dwHighDateTime == m_ftLastEvent.dwHighDateTime)
        {
            //
            // This event has the same timestamp as the previous one ---
            // let's add the counter to it.  
            //

            if(0xFFFFFFFF - ft.dwLowDateTime > m_dwEventCount)
            {
                ft.dwLowDateTime += m_dwEventCount++;
            }
            else
            {
                ft.dwLowDateTime += m_dwEventCount++;
                ft.dwHighDateTime++;
            }
        }
        else
        {
            //
            // Different timestamp --- reset the counter
            //

            m_dwEventCount = 1; // 0 has been used by us
            m_ftLastEvent = ft;
        }
    }

    __int64 i64Stamp = ft.dwLowDateTime + ((__int64)ft.dwHighDateTime << 32);
    if(m_lTimeHandle == 0 && !m_bHandleInit)
    {
        HRESULT hres = 
            pObj->GetPropertyHandleEx(L"TIME_CREATED", 0, NULL, &m_lTimeHandle);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to retrieve TIME_CREATED handle: 0x%X\n",
                hres));
            m_lTimeHandle=0;
        }
        m_bHandleInit = true;
    }

    if(m_lTimeHandle)
    {
        pObj->SetPropByHandle(m_lTimeHandle, 0, sizeof(__int64), 
                                &i64Stamp);
        return true;
    }
    else
        return false;
}


//******************************************************************************
//******************************************************************************
//                      META DATA
//******************************************************************************
//******************************************************************************


HRESULT CWrappingMetaData::GetClass(LPCWSTR wszName, IWbemContext* pContext, 
                                        _IWmiObject** ppClass)
{
    HRESULT hres;
    IWbemClassObject* pObj;
    
    *ppClass = NULL;
    
    hres = m_pDest->GetClass(wszName, pContext, &pObj);
    
    if ( FAILED(hres) )
    {
        return hres;
    }

    CReleaseMe rm1(pObj);
    return pObj->QueryInterface(IID__IWmiObject, (void**)ppClass);
}

//******************************************************************************
//******************************************************************************
//                      FILTER PROXY MANAGER
//******************************************************************************
//******************************************************************************


CFilterProxyManager::CFilterProxyManager(CLifeControl* pControl)
      : CFilterProxyManagerBase( pControl ), m_lRef(0), m_pStub(NULL), 
        m_pMetaData(NULL), m_pMultiTarget(NULL), m_pSpecialContext(NULL),
        m_XProxy(this), m_lExtRef(0),
        m_hthreadSend(NULL), 
        m_heventDone(NULL), 
        m_heventBufferNotFull(NULL),
        m_heventBufferFull(NULL), 
        m_heventEventsPending(NULL),
        m_dwLastSentStamp(0),
        m_pMultiTargetStream( NULL )
{
}

CFilterProxyManager::~CFilterProxyManager()
{
    StopSendThread();

    if(m_pMetaData)
        m_pMetaData->Release();
    if(m_pStub)
        m_pStub->Release();
    if(m_pMultiTarget)
        m_pMultiTarget->Release();
}
    

ULONG STDMETHODCALLTYPE CFilterProxyManager::AddRef()
{
    // This is an AddRef from a client. Increment a special counter as well
    // ====================================================================
    InterlockedIncrement(&m_lExtRef);

    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFilterProxyManager::Release()
{
    // This is a Release from a client. Check if the client has released all 
    // references to the proxy, in which case we need to disconnect ourselves
    // ======================================================================

    if(InterlockedDecrement(&m_lExtRef) == 0)
    {
        EnterCriticalSection(&m_cs);
        IWbemFilterStub* pStub = m_pStub;
        InterlockedIncrement(&m_lRef);
        LeaveCriticalSection(&m_cs);
        
        if(pStub)
            pStub->UnregisterProxy(&m_XProxy);

        InterlockedDecrement(&m_lRef);
        
    }

    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

ULONG STDMETHODCALLTYPE CFilterProxyManager::AddRefProxy()
{
    // AddRef from proxy.
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFilterProxyManager::ReleaseProxy()
{
    // Release from proxy.
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0) delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown)
        *ppv = (IUnknown*)this;
    else if(riid == IID_IMarshal)
        *ppv = (IMarshal*)this;
    else if(riid == IID_IWbemFilterProxy || riid == IID_IWbemLocalFilterProxy)
        *ppv = (IWbemLocalFilterProxy*)&m_XProxy;
    else
        return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE CFilterProxyManager::Initialize(IWbemMetaData* pMetaData,
                    IWbemMultiTarget* pMultiTarget)
{
    CInCritSec ics(&m_cs);

    if(m_pMetaData)
        m_pMetaData->Release();
    m_pMetaData = new CWrappingMetaData(pMetaData);
    if(m_pMetaData)
        m_pMetaData->AddRef();
    else
        return WBEM_E_OUT_OF_MEMORY;

    if(m_pMultiTarget)
        m_pMultiTarget->Release();
    m_pMultiTarget = pMultiTarget;
    if(m_pMultiTarget)
        m_pMultiTarget->AddRef();

	if(GetMainProxy() == NULL)
		return WBEM_E_OUT_OF_MEMORY;

    // Leave ourselves locked for further initialization
    // =================================================

    Lock();
    return S_OK;
}

HRESULT CFilterProxyManager::SetStub(IWbemFilterStub* pStub)
{
    if(m_pStub)
        m_pStub->Release();
    m_pStub = pStub;
    if(m_pStub)
        m_pStub->AddRef();

    // Initialize ourselves
    // ====================

    HRESULT hres = m_pStub->RegisterProxy(&m_XProxy);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to register proxy with stub: %X\n", hres));
        return hres;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::Lock()
{
    if(m_Lock.Enter()) // old implementation: == WAIT_OBJECT_0)
    {
        return S_OK;
    }
    else
        return WBEM_E_CRITICAL_ERROR;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::Unlock()
{
    m_Lock.Leave();
    return S_OK;
}
    

HRESULT STDMETHODCALLTYPE CFilterProxyManager::AddFilter(IWbemContext* pContext,
                        LPCWSTR wszQuery, 
                        WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    // Parse the query
    // ===============

    CTextLexSource Source((LPWSTR)wszQuery);
    QL1_Parser Parser(&Source);
    QL_LEVEL_1_RPN_EXPRESSION* pExp;
    if(Parser.Parse(&pExp) != QL1_Parser::SUCCESS)
    {
        ERRORTRACE((LOG_ESS, "Filter proxy unable to parse %S\n", wszQuery));
        return WBEM_E_UNPARSABLE_QUERY;
    }

    CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExp);
    return AddFilter(pContext, wszQuery, pExp, idFilter);
}
    
HRESULT CFilterProxyManager::AddFilter(IWbemContext* pContext,
                        LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    CInCritSec ics(&m_cs);

    //
    // Record the filter in our array
    //

    m_mapQueries[idFilter] = wszQuery;

    //
    // Add the filter to all our subproxies
    //

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres;
        if(m_apProxies[i] == NULL)
            continue;
        hres = m_apProxies[i]->AddFilter(GetProperContext(pContext), 
                                            wszQuery, pExp, idFilter);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to add filter %S to sub-proxy in "
                "process %d.\n", wszQuery, GetCurrentProcessId()));
            hresGlobal = hres;
        }
    }
    return hresGlobal;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::RemoveFilter(
                                            IWbemContext* pContext, 
                                            WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    CInCritSec ics(&m_cs);

    //
    // Remove the filter from our array
    //

    m_mapQueries.erase(idFilter);

    //
    // Remove the filter from all our subproxies
    //

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres;
        if(m_apProxies[i] == NULL)
            continue;
        hres = m_apProxies[i]->RemoveFilter(GetProperContext(pContext), 
                                            idFilter);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove filter from sub-proxy in "
                "process %d.\n", GetCurrentProcessId()));
            hresGlobal = hres;
        }
    }
    return hresGlobal;
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::RemoveAllFilters(IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);

    //
    // Clear our filter array
    //

    m_mapQueries.clear();

    //
    // Remove all filters from all our subproxies
    //

    HRESULT hresGlobal = S_OK;
    for(int i = 0; i < m_apProxies.GetSize(); i++)
    {
        HRESULT hres;
        if(m_apProxies[i] == NULL)
            continue;
        hres = m_apProxies[i]->RemoveAllFilters(GetProperContext(pContext));
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove all filters from sub-proxy "
                "in process %d.\n", GetCurrentProcessId()));
            hresGlobal = hres;
        }
    }
    return hresGlobal;
}
    
HRESULT STDMETHODCALLTYPE CFilterProxyManager::AllowUtilizeGuarantee()
{
    CInCritSec ics(&m_cs);

    //  
    // Definition queries should be sent to the main (first) proxy only
    // 

    if(m_apProxies.GetSize() == 0)
        return WBEM_E_UNEXPECTED;

    if(m_apProxies[0] == NULL)
        return WBEM_S_FALSE;

    return m_apProxies[0]->AllowUtilizeGuarantee();
}
 
HRESULT STDMETHODCALLTYPE CFilterProxyManager::AddDefinitionQuery(
                                      IWbemContext* pContext, LPCWSTR wszQuery)
{
    CInCritSec ics(&m_cs);

    //  
    // Definition queries should be sent to the main (first) proxy only
    // 

    if(m_apProxies.GetSize() == 0)
        return WBEM_E_UNEXPECTED;
    if(m_apProxies[0] == NULL)
        return WBEM_S_FALSE;
    return m_apProxies[0]->AddDefinitionQuery(GetProperContext(pContext), 
                                                wszQuery);
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::RemoveAllDefinitionQueries(
                                            IWbemContext* pContext)
{
    //  
    // Definition queries should be sent to the main (first) proxy only
    //

    if(m_apProxies.GetSize() == 0)
        return WBEM_E_UNEXPECTED;
    if(m_apProxies[0] == NULL)
        return WBEM_S_FALSE;

    return m_apProxies[0]->RemoveAllDefinitionQueries(
                                    GetProperContext(pContext));
}

HRESULT STDMETHODCALLTYPE CFilterProxyManager::Disconnect()
{
    // We must make sure that once Disconnect returns, no events will be
    // delivered
    // =================================================================

    CInLock<CFilterProxyManager> il(this);
    {
        CInCritSec ics(&m_cs);
    
        if(m_pMetaData)
            m_pMetaData->Release();
        m_pMetaData = NULL;
    
        if(m_pStub)
            m_pStub->Release();
        m_pStub = NULL;
    
        if(m_pMultiTarget)
            m_pMultiTarget->Release();
        m_pMultiTarget = NULL;
    }

    return WBEM_S_NO_ERROR;
}


IWbemContext* CFilterProxyManager::GetProperContext(IWbemContext* pCurrentContext)
{
    // If we are a real, out-of-proc, proxy, we should not use this context,
    // because the thread that owns it is currently stuck in an RPC call to us
    // and will not be able to process dependent requests.  Instead, we must
    // use the "special" context that will cause the thread pool to always 
    // create a new thread if needed
    // =======================================================================

    if(m_pSpecialContext)
        return m_pSpecialContext;
    else
        return pCurrentContext;
}


HRESULT CFilterProxyManager::SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj)
{
    HRESULT hres;

    if(m_pMultiTarget == NULL)
        return WBEM_E_UNEXPECTED;

    // 
    // There is only one reason we support this call: to re-check all
    // subscriptions for validity/security
    //

    if(lFlags != WBEM_STATUS_REQUIREMENTS || 
        hResult != WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS)
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Retrieve "special" interface we use for this purpose
    //

    IWbemEventProviderRequirements* pReq = NULL;
    hres = m_pMultiTarget->QueryInterface(IID_IWbemEventProviderRequirements,
                                            (void**)&pReq);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pReq);
    
    return pReq->DeliverProviderRequest(hResult);
}

STDMETHODIMP CFilterProxyManager::GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink)
{
    // Basic parameter validation

    if(lNumQueries < 1)
        return WBEM_E_INVALID_PARAMETER;
    if(ppSink == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *ppSink = NULL;
    HRESULT hres;
    
    //
    // Construct a new filter proxy
    //

    CFilterProxy* pNewProxy = new CFilterProxy(this, pCallback);
    if(pNewProxy == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    //
    // Add all the definition queries
    //

    for(long i = 0; i < lNumQueries; i++)
    {
        LPCWSTR wszQuery = awszQueries[i];
        if(wszQuery == NULL)
        {
            delete pNewProxy;
            return WBEM_E_INVALID_PARAMETER;
        }

        hres = pNewProxy->AddDefinitionQuery(NULL, wszQuery);
        if(FAILED(hres))
        {
            delete pNewProxy;
            return hres;
        }
    }

    //
    // if we made it here, then all definition queries were correctly added 
    // and we can now utilize these definitions for optimizing the filter.
    //
    pNewProxy->AllowUtilizeGuarantee();

    {
        CInCritSec ics(&m_cs);
        
        for(TIterator it = m_mapQueries.begin(); it != m_mapQueries.end(); it++)
        {
            // Parse the query
            // ===============
        
            LPCWSTR wszQuery = it->second;
            WBEM_REMOTE_TARGET_ID_TYPE idFilter = it->first;

            CTextLexSource Source(wszQuery);
            QL1_Parser Parser(&Source);
            QL_LEVEL_1_RPN_EXPRESSION* pExp;
            if(Parser.Parse(&pExp) != QL1_Parser::SUCCESS)
            {
                ERRORTRACE((LOG_ESS, "Filter proxy unable to parse %S\n", 
                    wszQuery));
                continue;
            }
        
            CDeleteMe<QL_LEVEL_1_RPN_EXPRESSION> dm(pExp);
            pNewProxy->AddFilter(NULL, wszQuery, pExp, idFilter);
        }

        if(m_apProxies.Add(pNewProxy) < 0)
        {
            delete pNewProxy;
            return WBEM_E_OUT_OF_MEMORY;
        }

        pNewProxy->SetRunning();
    }
   
    return pNewProxy->QueryInterface(IID_IWbemEventSink, (void**)ppSink);
}

STDMETHODIMP CFilterProxyManager::GetUnmarshalClass(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        CLSID* pClsid)
{
    *pClsid = CLSID_WbemFilterProxy;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxyManager::GetMarshalSizeMax(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        ULONG* plSize)
{
    return CoGetMarshalSizeMax(plSize, IID_IWbemFilterStub, m_pStub, 
                                dwDestContext, pvReserved, mshlFlags);
}

STDMETHODIMP CFilterProxyManager::MarshalInterface(IStream* pStream, REFIID riid, 
                        void* pv, DWORD dwDestContext, void* pvReserved, 
                        DWORD mshlFlags)
{
    return CoMarshalInterface(pStream, IID_IWbemFilterStub, 
                                m_pStub, dwDestContext, pvReserved, mshlFlags);
}

STDMETHODIMP CFilterProxyManager::UnmarshalInterface(IStream* pStream, REFIID riid, 
                        void** ppv)
{
    // Unmarshal the stub pointer
    // ==========================

    HRESULT hres = CoUnmarshalInterface(pStream, IID_IWbemFilterStub, 
                        (void**)&m_pStub);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to unmarshal filter stub: %X\n", hres));
        return hres;
    }

    // Since we are unmarshalling, this must be a real proxy.  Real proxies 
    // should use a "special" context when calling back into CIMOM to make sure
    // that they do not cause a deadlock, because a thread in CIMOM is stuck in
    // an RPC call to this proxy and is not processing dependent requests.
    // ========================================================================

    IWbemCausalityAccess* pCausality = NULL;
    hres = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER,
                            IID_IWbemCausalityAccess, (void**)&pCausality);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to create a context object in proxy: "
            "error code 0x%X\n", hres));
        return hres;
    }
    CReleaseMe rm1(pCausality);

    hres = pCausality->MakeSpecial();
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Unable to construct special context object in "
            "proxy: error code 0x%X\n", hres));
        return hres;
    }
    
    hres = pCausality->QueryInterface(IID_IWbemContext, 
                                        (void**)&m_pSpecialContext);
    if(FAILED(hres))
    {
        // Out of memory?
        // ==============
        return hres;
    }
    
    // Initialize ourselves
    // ====================

    hres = m_pStub->RegisterProxy(&m_XProxy);

    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Failed to register proxy with stub: %X\n", hres));
        return hres;
    }

    //
    // What we must return is our main proxy
    //
    
    if(GetMainProxy())
        return GetMainProxy()->QueryInterface(riid, ppv);
    else
        return WBEM_E_CRITICAL_ERROR;
}

INTERNAL IWbemEventSink* CFilterProxyManager::GetMainProxy()
{
	//
	// We are being asked for the sink to give to the provider.  It is possible
	// that we do not have a sink --- that will be the case if the provider
	// has unloaded.  In that case, we must be sure to create it!
	//

    if(m_apProxies.GetSize() == 0)
	{
		CFilterProxy* pMainProxy = new CFilterProxy(this);
		if(pMainProxy == NULL)
			return NULL;
        pMainProxy->SetRunning();

		if(m_apProxies.Add(pMainProxy) < 0)
		{
			delete pMainProxy;
			return NULL;
		}
		return pMainProxy;
	}
    else
	{
		if(m_apProxies[0] == NULL)
		{
			CFilterProxy* pMainProxy = new CFilterProxy(this);
			if(pMainProxy == NULL)
				return NULL;
            pMainProxy->SetRunning();

			m_apProxies.SetAt(0, pMainProxy);
		}
        return m_apProxies[0];
	}
}

HRESULT CFilterProxyManager::GetMetaData(RELEASE_ME CWrappingMetaData** ppMeta)
{
    *ppMeta = m_pMetaData;
    (*ppMeta)->AddRef();
    return S_OK;
}

HRESULT CFilterProxyManager::RemoveProxy(CFilterProxy* pProxy)
{
    //
    // Called when a proxy is fully released by the client, and calls on the
    // manager to self-destruct
    //

    CFilterProxy* pOldProxy = NULL;

    {
        CInCritSec ics(&m_cs);
    
        for(int i = 0; i < m_apProxies.GetSize(); i++)
        {
            if(m_apProxies[i] == pProxy)
            {
                RemoveProxyLatency(pProxy);
                m_apProxies.RemoveAt(i, &pOldProxy);
                break;
            }
        }
    }
            
    if(pOldProxy)
    {
        // We don't do a release because pProxy's refcount is already 0 (which
        // is why we're in this function).  Normally RemoveAt would have
        // deleted it, but since we passed in &pOldProxy, it didn't.  We do this
        // so pOldProxy doesn't do its final release of the manager which could
        // destruct the manager while we're holding onto the manager's lock.
        delete pOldProxy;

        return WBEM_S_NO_ERROR;
    }
    else
        return WBEM_E_NOT_FOUND;
}

STDMETHODIMP CFilterProxyManager::ReleaseMarshalData(IStream* pStream)
{
    return CoReleaseMarshalData(pStream);
}

STDMETHODIMP CFilterProxyManager::DisconnectObject(DWORD dwReserved)
{
    // BUGBUG
    return WBEM_E_UNEXPECTED;
}

HRESULT CFilterProxyManager::DeliverEvent(long lNumToSend, 
                                            IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                        long lSDLength, BYTE* pSD)
{
    //
    // we need to hold the proxy lock when signalling an event.
    // the reason for this is that when a call to disconnect() returns, 
    // we can be absolutely sure that no events will be delivered to the 
    // stub.  Without locking here, just after the check for multitarget, 
    // disconnect could be called setting multitarget to null and then 
    // returning, however, just after the DeliverEvent call is made.
    //

    CInLock<CFilterProxyManager> il(this);

    if(m_pMultiTarget)
        return m_pMultiTarget->DeliverEvent(lNumToSend, apEvents, aTargets, 
                                        lSDLength, pSD);
    else
        return CO_E_OBJNOTCONNECTED;
}


HRESULT CFilterProxyManager::DeliverEventMT(long lNumToSend, 
                                            IWbemClassObject** apEvents,
                                            WBEM_REM_TARGETS* aTargets,
                                            long lSDLength, BYTE* pSD,
                                            IWbemMultiTarget * pMultiTarget)
{
    //
    // we need to hold the proxy lock when signalling an event.  There are 
    // two reasons for this.  The first is that during resync of ess, it 
    // must ensure that no events are delivered, else they would be lost.  
    // the way ess ensures this is by grabbing the locks of all the proxies.
    // The other reason is so that when a call to disconnect() returns, 
    // we can be absolutely sure that no events will be delivered to the 
    // stub.  Without locking here, just after the check for multitarget, 
    // disconnect could be called setting multitarget to null and then 
    // returning, however, just after the DeliverEvent call is made.
    //

    // This assertion is for this func to be called in other place than
    // SendThreadProc in the future. 

    _DBG_ASSERT( pMultiTarget );

    CInLock<CFilterProxyManager> il(this);

    return pMultiTarget->DeliverEvent(lNumToSend, apEvents, aTargets, lSDLength, pSD);
}


ULONG CFilterProxyManager::XProxy::AddRef()
{
    return m_pObject->AddRefProxy();
}

ULONG CFilterProxyManager::XProxy::Release()
{
    return m_pObject->ReleaseProxy();
}

HRESULT CFilterProxyManager::XProxy::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemFilterProxy ||
        riid == IID_IWbemLocalFilterProxy)
    {
        *ppv = (IWbemLocalFilterProxy*)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

HRESULT CFilterProxyManager::XProxy::Initialize(IWbemMetaData* pMetaData,
                    IWbemMultiTarget* pMultiTarget)
{
    return m_pObject->Initialize(pMetaData, pMultiTarget);
}
HRESULT CFilterProxyManager::XProxy::Lock()     // Deprecated ? 
{
    return m_pObject->Lock();
}
HRESULT CFilterProxyManager::XProxy::Unlock()   // Deprecated ? 
{
    return m_pObject->Unlock();
}
HRESULT CFilterProxyManager::XProxy::AddFilter(IWbemContext* pContext, 
                    LPCWSTR wszQuery, 
                    WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    return m_pObject->AddFilter(pContext, wszQuery, idFilter);
}
HRESULT CFilterProxyManager::XProxy::RemoveFilter(IWbemContext* pContext, 
                    WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    return m_pObject->RemoveFilter(pContext, idFilter);
}
HRESULT CFilterProxyManager::XProxy::RemoveAllFilters(IWbemContext* pContext)
{
    return m_pObject->RemoveAllFilters(pContext);
}

HRESULT CFilterProxyManager::XProxy::AddDefinitionQuery(IWbemContext* pContext, 
                    LPCWSTR wszQuery)
{
    return m_pObject->AddDefinitionQuery(pContext, wszQuery);
}

HRESULT CFilterProxyManager::XProxy::AllowUtilizeGuarantee()
{
    return m_pObject->AllowUtilizeGuarantee();
}

HRESULT CFilterProxyManager::XProxy::RemoveAllDefinitionQueries(
                    IWbemContext* pContext)
{
    return m_pObject->RemoveAllDefinitionQueries(pContext);
}
HRESULT CFilterProxyManager::XProxy::Disconnect()
{
    return m_pObject->Disconnect();
}

HRESULT CFilterProxyManager::XProxy::SetStub(IWbemFilterStub* pStub)
{
    return m_pObject->SetStub(pStub);
}

HRESULT CFilterProxyManager::XProxy::LocalAddFilter(IWbemContext* pContext, 
                        LPCWSTR wszQuery, 
                        void* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE Id)
{
    return m_pObject->AddFilter(pContext, wszQuery, 
                                (QL_LEVEL_1_RPN_EXPRESSION*)pExp, Id);
}

HRESULT CFilterProxyManager::XProxy::GetMainSink(IWbemEventSink** ppSink)
{
    *ppSink = m_pObject->GetMainProxy();
    if(*ppSink)
    {
        (*ppSink)->AddRef();
        return S_OK;
    }
    else
        return E_UNEXPECTED;
}

void CFilterProxyManager::CalcMaxSendLatency()
{
    LockBatching();

    DWORD dwLatency = 0xFFFFFFFF;

    for (CLatencyMapItor i = m_mapLatencies.begin();
        i != m_mapLatencies.end();
        i++)
    {
        if ((*i).second < dwLatency)
            dwLatency = (*i).second;
    }

    m_dwMaxSendLatency = dwLatency;

    UnlockBatching();
}


HRESULT CFilterProxyManager::SetProxyLatency(CFilterProxy *pProxy, DWORD dwLatency)
{
    LockBatching();

    BOOL bWasEmpty = m_mapLatencies.size() == 0;
    
    // Add this proxy.
    m_mapLatencies[pProxy] = dwLatency;

    HRESULT hr = S_OK;

    // If our map was previously empty, start the send thread.
    if ( bWasEmpty )
    {
        m_dwMaxSendLatency = dwLatency;

        _DBG_ASSERT( NULL == m_hthreadSend );

        if ( NULL == m_hthreadSend )
        {
            _DBG_ASSERT( NULL == m_pMultiTargetStream );

            //
            // IWbemMultiTarget interface pointer is mashaled to make the 
            // interface pointer available for cross apartment access
            //

            hr = CoMarshalInterThreadInterfaceInStream( IID_IWbemMultiTarget,
                                                        m_pMultiTarget,
                                                        &m_pMultiTargetStream );

            if ( SUCCEEDED( hr ) )
            {
                if ( FALSE == StartSendThread( ) )
                {
                    ERRORTRACE((LOG_ESS, "Failed to set proxy latency due to thread creation error : 0x%X\n", GetLastError( ) ) );
                    m_pMultiTargetStream->Release( );
                    m_pMultiTargetStream = NULL;
                    hr = E_FAIL;
                }
            }
            else
            {
                m_pMultiTargetStream = NULL;
                ERRORTRACE((LOG_ESS, "Failed to set proxy latency due to marshaling error : 0x%X\n", hr ) );
            }
        }
    }
    else
    {
        // If dwLatency is smaller than m_dwMaxSendLatency, set 
        // m_dwMaxSendLatency to the new smallest value.
        if (dwLatency < m_dwMaxSendLatency)
            m_dwMaxSendLatency = dwLatency;
    }
    
    UnlockBatching();

    return hr;
}

void CFilterProxyManager::RemoveProxyLatency(CFilterProxy *pProxy)
{
    LockBatching();

    // Try to find the proxy.
    CLatencyMapItor item = m_mapLatencies.find(pProxy);

    // Did we find it?
    if (item != m_mapLatencies.end())
    {
        // Remove it.
        m_mapLatencies.erase(item);

        // If there are no more proxies that care about batching, stop the
        // send thread.
        if (m_mapLatencies.size() == 0)
            StopSendThread();
        else
        {
            DWORD dwLatency = (*item).second;

            // If the latency value we just removed is the same as 
            // m_dwMaxSendLatency, recalc m_dwMaxSendLatency.
            if (dwLatency == m_dwMaxSendLatency)
                CalcMaxSendLatency();
        }
    }

    UnlockBatching();
}


BOOL CFilterProxyManager::StartSendThread()
{
    LockBatching();

    if ( NULL == m_hthreadSend )
    {
        DWORD dwID;

        do
        {
            m_heventDone = CreateEvent( NULL, FALSE, FALSE, NULL );
            if ( NULL == m_heventDone )
            {
                break;
            }

            m_heventBufferNotFull = CreateEvent( NULL, TRUE, TRUE, NULL );
            if ( NULL == m_heventBufferNotFull ) 
            {
                break;
            }

            m_heventBufferFull = CreateEvent( NULL, TRUE, FALSE, NULL );
            if ( NULL == m_heventBufferFull )
            {
                break;
            }

            m_heventEventsPending = CreateEvent( NULL, TRUE, FALSE, NULL );
            if ( NULL == m_heventEventsPending )
            {
                break;
            }

            m_hthreadSend = CreateThread( NULL, 
                                          0, 
                                          (LPTHREAD_START_ROUTINE) SendThreadProc,
                                          this,
                                          0,
                                          &dwID );
        }
        while( FALSE );

        if ( NULL == m_hthreadSend )
        {
            if (m_heventDone)
            {
                CloseHandle(m_heventDone);
                m_heventDone = NULL;
            }

            if (m_heventBufferNotFull)
            {
                CloseHandle(m_heventBufferNotFull);
                m_heventBufferNotFull = NULL;
            }

            if (m_heventBufferFull)
            {
                CloseHandle(m_heventBufferFull);
                m_heventBufferFull = NULL;
            }

            if (m_heventEventsPending)
            {
                CloseHandle(m_heventEventsPending);
                m_heventEventsPending = NULL;
            }
        }
    }

    UnlockBatching();

    return ( NULL != m_hthreadSend );
}

void CFilterProxyManager::StopSendThread()
{
    LockBatching();

    if (m_hthreadSend && m_heventDone)
    {
        SetEvent(m_heventDone);
        WaitForSingleObject(m_hthreadSend, 3000);
        CloseHandle(m_hthreadSend);
        m_hthreadSend = NULL;
    }

    if (m_heventDone)
    {
        CloseHandle(m_heventDone);
        m_heventDone = NULL;
    }

    if (m_heventBufferNotFull)
    {
        CloseHandle(m_heventBufferNotFull);
        m_heventBufferNotFull = NULL;
    }

    if (m_heventBufferFull)
    {
        CloseHandle(m_heventBufferFull);
        m_heventBufferFull = NULL;
    }

    if (m_heventEventsPending)
    {
        CloseHandle(m_heventEventsPending);
        m_heventEventsPending = NULL;
    }

    UnlockBatching();
}


DWORD WINAPI CFilterProxyManager::SendThreadProc(CFilterProxyManager *pThis)
{
    HANDLE  hWait[2] = { pThis->m_heventDone, pThis->m_heventEventsPending },
            hwaitSendLatency[2] = { pThis->m_heventDone, pThis->m_heventBufferFull },
            heventBufferNotFull = pThis->m_heventBufferNotFull;
    HRESULT hres;
    IWbemMultiTarget * pMultiTarget = NULL;

    _DBG_ASSERT( pThis->m_pMultiTargetStream );

    if ( NULL == pThis->m_pMultiTargetStream )
    {
        return 1;
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    //
    // IWbemMultiTarget interface pointer is unmarshaled to use in this
    // thread (in case of cross apartment).
    //

    hres = CoGetInterfaceAndReleaseStream( pThis->m_pMultiTargetStream,
                                           IID_IWbemMultiTarget,
                                           ( void ** )&pMultiTarget );

    if( FAILED( hres ) )
    {
        ERRORTRACE((LOG_ESS, "Failed to run batching thread due to unmarshaling errors: 0x%X\n", hres));
        // pThis->m_pMultiTargetStream->Release( );
        pThis->m_pMultiTargetStream = NULL;
        CoUninitialize( );
        return 1;
    }

    pThis->m_pMultiTargetStream = NULL;

    _DBG_ASSERT( pMultiTarget );

    while (WaitForMultipleObjects(2, hWait, FALSE, INFINITE) != 0)
    {
        // If we have a send latency, wait for that time or until the send 
        // buffer is full.  If the done event fires, get out.
        if (pThis->m_dwMaxSendLatency)
        {
            if (WaitForMultipleObjects(2, hwaitSendLatency, FALSE, 
                pThis->m_dwMaxSendLatency) == 0)
                break;

            // Reset m_heventBufferFull.
            ResetEvent(hwaitSendLatency[1]);
        }

        CInCritSec csBuffer(&pThis->m_csBuffer);
        int        nItems = pThis->m_batch.GetItemCount();
        
        hres = pThis->DeliverEventMT(
                    nItems, 
                    pThis->m_batch.GetObjs(), 
                    pThis->m_batch.GetTargets(),
                    0, 
                    &CFilterProxy::mstatic_EmptySD,
                    pMultiTarget);

        // Increment this so the filter proxies will know to clear out their
        // buffer size when they next get an event to batch.
        pThis->m_dwLastSentStamp++; 

        pThis->m_batch.RemoveAll();

        SetEvent(heventBufferNotFull);

        // Reset m_heventEventsPending
        ResetEvent(hWait[1]);
    }

    // Make sure our batch buffer is empty before we exit.
    CInCritSec csBuffer(&pThis->m_csBuffer);
    int        nItems = pThis->m_batch.GetItemCount();
    
    if ( nItems )
    {
        pThis->DeliverEventMT(
            nItems, 
            pThis->m_batch.GetObjs(), 
            pThis->m_batch.GetTargets(),
            0, 
            &CFilterProxy::mstatic_EmptySD,
            pMultiTarget);
    }

    CoUninitialize( );

    return 0;
}

DWORD CFilterProxyManager::GetLastSentStamp()
{
    return m_dwLastSentStamp;
}

//*****************************************************************************
//*****************************************************************************
//
//                  FILTER PROXY
//
//*****************************************************************************
//*****************************************************************************

CTimeKeeper CFilterProxy::mstatic_TimeKeeper;
BYTE CFilterProxy::mstatic_EmptySD = 0;

CFilterProxy::CFilterProxy(CFilterProxyManager* pManager, IUnknown* pCallback) 
    : m_lRef(0), m_pManager(pManager), m_pMetaData(NULL),
        m_lSDLength(0), m_pSD(&mstatic_EmptySD), m_pProvider(NULL),
        m_pQuerySink(NULL), m_bRunning(false),
        m_typeBatch(WBEM_FLAG_MUST_NOT_BATCH), m_bUtilizeGuarantee(false),
        m_dwCurrentBufferSize(0), m_bBatching(FALSE),
        m_wSourceVersion(0), m_wAppliedSourceVersion(0)
{
    m_SourceDefinition.SetBool(FALSE);
    if(m_pManager)
    {
        m_pManager->AddRef();
        m_pManager->GetMetaData(&m_pMetaData);
    }

    if(pCallback)
    {
        pCallback->QueryInterface(IID_IWbemEventProvider, (void**)&m_pProvider);
        pCallback->QueryInterface(IID_IWbemEventProviderQuerySink, 
                                    (void**)&m_pQuerySink);
    }
}

CFilterProxy::~CFilterProxy()
{
    if (m_pManager)
        m_pManager->Release();

    if (m_pMetaData)
        m_pMetaData->Release();
}
    

ULONG STDMETHODCALLTYPE CFilterProxy::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CFilterProxy::Release()
{
    //
    // CFilterProxy is deleted by CFilterProxyManager --- it never goes away
    // on a Release
    //

    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
    {
        //
        // Inform the manager that we are no longer needed.  This call can 
        // destroy this object!
        //

        m_pManager->RemoveProxy(this);
    }

    return lRef;
}

HRESULT STDMETHODCALLTYPE CFilterProxy::QueryInterface(REFIID riid, void** ppv)
{
    if( riid == IID_IUnknown || 
        riid == IID_IWbemObjectSink ||
        riid == IID_IWbemEventSink)
    {
        *ppv = (IWbemEventSink*)this;
    }
    else if(riid == IID_IMarshal)
    {
        *ppv = (IMarshal*)this;
    }
    else
        return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}
        
HRESULT CFilterProxy::Lock()
{
    return m_pManager->Lock();
}

HRESULT CFilterProxy::Unlock()
{
    return m_pManager->Unlock();
}

HRESULT CFilterProxy::SetRunning()
{
    HRESULT hres;

    bool bActive = false;
    IWbemEventProvider* pProvider = NULL; 

    {
        CInCritSec ics(&m_cs);

        if(m_bRunning)
            return WBEM_S_FALSE;
        else
        {
            m_bRunning = true;
            if(m_pProvider)
            {
                bActive = (IsActive() == WBEM_S_NO_ERROR);
                pProvider = m_pProvider;
                pProvider->AddRef();
            }
        }
    }

    //
    // If here, we are just now marking it for running. Notify the callback if
    // there are any sinks
    //
    
    if(bActive && pProvider)
    {
        hres = pProvider->ProvideEvents(NULL, WBEM_FLAG_START_PROVIDING);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused to stop "
                "error code 0x%X\n", hres));
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::AddFilter(IWbemContext* pContext,
                        LPCWSTR wszQuery, 
                        QL_LEVEL_1_RPN_EXPRESSION* pExp,
                        WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    HRESULT hres;


    // Compile the query
    // =================

    CContextMetaData MetaData(m_pMetaData, pContext);

    CEvalTree Tree;
    hres = Tree.CreateFromQuery(&MetaData, pExp, WBEM_FLAG_MANDATORY_MERGE,
                                MAX_TOKENS_IN_DNF);
    if(FAILED(hres))
    {
        ERRORTRACE((LOG_ESS, "Filter proxy unable to parse %S, "
            "error code: %X\n", wszQuery, hres));
        return hres;
    }
        
    //
    // merge the query into the rest of the filter.
    //
    
    {
        CInCritSec ics(&m_cs);

        if ( m_bUtilizeGuarantee )
        {
            //
            // Utilize source definition
            // =========================
            
            //
            // assert that our source definition hasn't changed since the last 
            // time a filter was added.  This would be bad, since the tree 
            // doesn't account for the new source queries. Also assert that 
            // the source tree is valid and is not empty. ( These last two may
            // have to be removed in the future. For now they shouldn't be 
            // false )
            //
            
            _ESSCLI_ASSERT( m_wAppliedSourceVersion == 0 || 
                            m_wAppliedSourceVersion == m_wSourceVersion );
            _ESSCLI_ASSERT( m_SourceDefinition.IsValid() );	
            _ESSCLI_ASSERT( !m_SourceDefinition.IsFalse() );
            
            hres = Tree.UtilizeGuarantee(m_SourceDefinition, &MetaData);
        
            if(FAILED(hres))
            {
                ERRORTRACE((LOG_ESS, 
                            "Filter proxy unable to utilize guarantee for %S, "
                            "error code: %X\n", wszQuery, hres));
                return hres;
            }

            //
            // Check if anything is left of it
            //

            if(!Tree.IsValid())
            {
                //
                // Utilization of the guarantee shows that this filter cannot 
                // be satisftied by events coming through this proxy
                //
                
                return WBEM_S_FALSE;
            }
        }

        //
        // Add consumer information to it
        //

        Tree.Rebase((QueryID)idFilter);

    #ifdef DUMP_DEBUG_TREES
        FILE* f = fopen("c:\\try.log", "a");
        fprintf(f, "\n\nAdding filter\n");
        Tree.Dump(f);
        fprintf(f, " to existing filter: \n");
        m_Filter.Dump(f);
    #endif

        hres = m_Filter.CombineWith(Tree, &MetaData, EVAL_OP_COMBINE);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter proxy unable to combine %S with the "
                "rest, error code: %X\n", wszQuery, hres));
            return hres;
        }

        m_wAppliedSourceVersion = m_wSourceVersion;
    }


    //
    // Now, we need to notify the provider of a new filter being issued
    //

    IWbemEventProviderQuerySink* pQuerySink = NULL;
    IWbemEventProvider* pProvider = NULL;

    {
        CInCritSec ics(&m_cs);

        if(m_pQuerySink)
        {
            pQuerySink = m_pQuerySink;
            pQuerySink->AddRef();
        }

        if(m_pProvider)
        {
            pProvider = m_pProvider;
            pProvider->AddRef();
        }
    }

    //
    // Call provider's NewQuery, if supported
    //

    if(pQuerySink)
    {
        hres = pQuerySink->NewQuery(idFilter, L"WQL", (LPWSTR)wszQuery);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused consumer "
                "registration query %S: error code 0x%X\n", 
                wszQuery, hres));

            // Too bad --- restricted sinks cannot veto subscriptions
        }
    }

    //
    // If we are adding this filter to a running proxy, and this is the very
    // first filter on it, we should call ProvideEvents immediately. Not so if
    // we are configuring a proxy that is not running yet --- in that case, we
    // need to wait until all outstanding filters have been put in place
    //

    if(m_bRunning && (IsActive() == WBEM_S_FALSE) && pProvider)
    {
        hres = pProvider->ProvideEvents((IWbemObjectSink*)this, 
                                        WBEM_FLAG_START_PROVIDING);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused a call to "
                    "ProvideEvents with 0x%X\n", hres));
        }
    }

#ifdef DUMP_DEBUG_TREES
    fprintf(f, " to obtain: \n");
    m_Filter.Dump(f);
    fclose(f);
#endif

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::RemoveFilter(IWbemContext* pContext, 
                                            WBEM_REMOTE_TARGET_ID_TYPE idFilter)
{
    HRESULT hres;

    IWbemEventProviderQuerySink* pQuerySink = NULL;
    IWbemEventProvider* pProvider = NULL;

    bool bActive;
    {
        CInCritSec ics(&m_cs);

        if(m_pQuerySink)
        {
            pQuerySink = m_pQuerySink;
            pQuerySink->AddRef();
        }

        if(m_pProvider)
        {
            pProvider = m_pProvider;
            pProvider->AddRef();
        }
            
        hres = m_Filter.RemoveIndex(idFilter);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Unable to remove index %d from the filter "
                        "proxy\n", idFilter));
            return hres;
        }
    
        CContextMetaData MetaData(m_pMetaData, pContext);

        hres = m_Filter.Optimize(&MetaData);
        if(FAILED(hres))
            return hres;

        bActive = (IsActive() == WBEM_S_NO_ERROR);
    }

    //
    // Call provider's NewQuery, if supported
    //

    if(pQuerySink)
    {
        hres = pQuerySink->CancelQuery(idFilter);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused consumer "
                "registration query cancellation: error code 0x%X\n", 
                hres));
        }
    }

    //
    // If we are left with no queries, notify provider of that fact
    //

    if(!bActive && pProvider)
    {
        hres = pProvider->ProvideEvents(NULL, WBEM_FLAG_STOP_PROVIDING);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Restricted sink refused to stop "
                "error code 0x%X\n", hres));
        }
    }
        
#ifdef DUMP_DEBUG_TREES
    FILE* f = fopen("c:\\try.log", "a");
    fprintf(f, "Removed at %d to obtain: \n", idFilter);
    m_Filter.Dump(f);
    fclose(f);
#endif
    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::RemoveAllFilters(IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);
    m_wAppliedSourceVersion = 0;
    if(!m_Filter.Clear())
        return WBEM_E_OUT_OF_MEMORY;
    
    return WBEM_S_NO_ERROR;
}
    
HRESULT CFilterProxy::AllowUtilizeGuarantee()
{
    //
    // ess shouldn't be calling this function if the tree is invalid.
    // 
    _DBG_ASSERT( m_SourceDefinition.IsValid() );

    //
    // ess thinks its o.k. to utilize the guarantee, however there are cases
    // where the soruce definition could still be false ( e.g. when there are
    // no source definition queries or when all of the source definition 
    // queries are contradictions ).  
    // 

    CInCritSec ics(&m_cs);

    if ( !m_SourceDefinition.IsFalse() )
    {    
        m_bUtilizeGuarantee = true;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::AddDefinitionQuery( IWbemContext* pContext, 
                                          LPCWSTR wszQuery )
{
    HRESULT hres;

    // Compile the query
    // =================

    CContextMetaData MetaData(m_pMetaData, pContext);

    CEvalTree Tree;
    hres = Tree.CreateFromQuery( &MetaData, 
                                 wszQuery, 
                                 WBEM_FLAG_MANDATORY_MERGE,
                                 0x7FFFFFFF ); // no limit
    if(FAILED(hres))
    {
        return hres;
    }

    {
        CInCritSec ics(&m_cs);

        //
        // we shouldn't be adding definition queries when there are currently
        // existing filters. 
        //
        _ESSCLI_ASSERT( m_Filter.IsFalse() );

        // Merge the query into the rest
        // =============================
    
        hres = m_SourceDefinition.CombineWith(Tree, &MetaData, EVAL_OP_OR, 
                                                WBEM_FLAG_MANDATORY_MERGE);
        if(FAILED(hres))
            return hres;

        m_wSourceVersion++;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::RemoveAllDefinitionQueries( IWbemContext* pContext)
{
    CInCritSec ics(&m_cs);

    m_wSourceVersion = 0;
    m_SourceDefinition.SetBool(FALSE);
    m_bUtilizeGuarantee = false;

    return WBEM_S_NO_ERROR;
}

HRESULT CFilterProxy::ProcessOne( IUnknown* pUnk, 
                                  long lSDLength, 
                                  BYTE* pSD )
{
    // 
    // NOTE: not in a critical section yet
    //

    HRESULT hres;

    //
    // Check overall validity
    //
    
    if( pUnk == NULL )
    {
        ERRORTRACE((LOG_ESS, "Event provider returned a NULL event!\n"));
        return WBEM_E_INVALID_PARAMETER;
    }
    
    CWbemObject* pObj = (CWbemObject*)(IWbemClassObject*)pUnk;
    
    if( pObj->IsObjectInstance() != WBEM_S_NO_ERROR )
    {
        ERRORTRACE((LOG_ESS, "CLASS object received from event provider!\n"));
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // Run the event through the filter
    //

    CSortedArray aTrues, aSourceTrues;
    CFilterProxyManager* pManager = NULL;

    {
        CInCritSec ics(&m_cs);
        
        hres = FilterEvent( pObj, aTrues );

        if ( hres == WBEM_S_NO_ERROR )
        {
            _DBG_ASSERT( aTrues.Size() > 0 );
        }
        else
        {
            return hres;
        }

        pManager = m_pManager;
        
        if( pManager )
        {
            pManager->AddRef();
        }
        else
        {
            return WBEM_S_FALSE;
        }
    }

    CReleaseMe rm2(pManager);

    //
    // the event has made it through the filter ..
    // 

    SetGenerationTime(pObj);

    if (IsBatching())
    {
        BatchEvent((IWbemClassObject*) pUnk, &aTrues);

        hres = S_OK;
    }
    else
    {
        // Some delivery is required --- construct the blob and the targets
        // ================================================================

        WBEM_REM_TARGETS RemTargets;
        if(!TempSetTargets(&RemTargets, &aTrues))
            return WBEM_E_OUT_OF_MEMORY;
        
        hres = pManager->DeliverEvent(1, (IWbemClassObject**)&pObj, 
                                      &RemTargets, lSDLength, pSD);
        TempClearTargets(&RemTargets);

        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter stub failed to process an event: "
                        "0x%X\n", hres));
        }
    }

    return hres;
}



void CFilterProxy::SetGenerationTime(_IWmiObject* pObj)
{
    mstatic_TimeKeeper.DecorateObject(pObj);
}

void CFilterProxyManager::AddEvent(
    IWbemClassObject *pObj, 
    CSortedArray *pTrues)
{
    LockBatching();

    BOOL bWasEmpty = m_batch.GetItemCount() == 0;

    m_batch.AddEvent(pObj, pTrues);

    if (bWasEmpty)
        SetEvent(m_heventEventsPending);

    UnlockBatching();
}

void CFilterProxyManager::WaitForEmptyBatch()
{
    LockBatching();

    // Once we get the lock and the batch has already been cleared out, we 
    // don't need to do anything else.
    if (m_batch.GetItemCount() == 0)
    {
        UnlockBatching();

        return;
    }

    // We need to wait for the send thread to finish sending what's 
    // in our buffer.

    // Wake up the send latency thread if necessary.
    if (m_dwMaxSendLatency)
        SetEvent(m_heventBufferFull);
                
    // So we'll block until the send thread sets the event.
    ResetEvent(m_heventBufferNotFull);

    UnlockBatching();

    WaitForSingleObject(m_heventBufferNotFull, INFINITE);
}

void CFilterProxy::BatchEvent(
    IWbemClassObject *pObj, 
    CSortedArray *pTrues)
{
    BOOL        bRet = FALSE;
    _IWmiObject *pWmiObj = (_IWmiObject*) pObj;
    DWORD       dwObjSize = 0;

    pWmiObj->GetObjectMemory(
        NULL,
        0,
        &dwObjSize);

    CInCritSec ics(&m_cs);

    // See if the manager has sent off its batch of events since we last
    // batched an event.
    if (m_dwLastSentStamp != m_pManager->GetLastSentStamp())
        m_dwCurrentBufferSize = 0;

    // See if we have enough room to add our event.
    if (m_dwCurrentBufferSize >= m_dwMaxBufferSize)
    {
        m_pManager->WaitForEmptyBatch();
        m_dwCurrentBufferSize = 0;
    }

    m_dwCurrentBufferSize += dwObjSize;

    m_dwLastSentStamp = m_pManager->GetLastSentStamp();
    m_pManager->AddEvent(pObj, pTrues);
}

HRESULT CFilterProxy::FilterEvent( _IWmiObject* pObj, CSortedArray& raTrues )
{            
    HRESULT hr;    

    //
    // evaluate 
    //

    try 
    {
        //
        // this code is in a try catch because if a provider generates 
        // events that it has not registered to, then we do bad things to 
        // class objects.  A potential fix could be do extra checking on 
        // our part, but is expensive when using the public interfaces. A
        // more advantageous fix should be making the class object code 
        // perform the checking for us ( e.g. when we ask for a property 
        // using an invalid handle, etc ).  It can do this checking much 
        // faster. When this checking is performed by the class object 
        // code, we should remove this try catch. see RAID 166026
        // 

        hr = m_Filter.Evaluate( pObj, raTrues );
    }
    catch( ... )
    {
        //
        // check to see if the provider is generating an event its not 
        // supposed to.  If so, then handle AV and return error, else  
        // rethrow - there's something else wrong. 
        //

        CSortedArray aSourceTrues; 

        hr = m_SourceDefinition.Evaluate( pObj, aSourceTrues );
        
        if ( SUCCEEDED(hr) && aSourceTrues.Size() == 0 )
        {
            ERRORTRACE((LOG_ESS, "Filter Proxy encountered case where "
                        "event provider is signaling events that are not "
                        "covered by its registration!!\n"));        
            
            hr = WBEM_E_INVALID_OBJECT;
        }
        else
        {
            throw;
        }
    }

    //
    // check events that make it through the filter against source definition.
    // if we're not utilizing guarantee, then there's no need to check the
    // event against the source definition because its already factored into
    // the filter.
    //

    if (SUCCEEDED(hr) && raTrues.Size() == 0 )
    {
        hr = WBEM_S_FALSE;
    }
    else if ( SUCCEEDED(hr) && m_bUtilizeGuarantee )
    {
        //
        // run the event through the source tree to ensure that the 
        // provider is providing the events its supposed to.
        // 

        CSortedArray aSourceTrues; 

        hr = m_SourceDefinition.Evaluate( pObj, aSourceTrues );

        if ( SUCCEEDED(hr) && aSourceTrues.Size() == 0 )
        {
            ERRORTRACE((LOG_ESS, "Filter Proxy encountered case where "
                        "event provider is signaling events that are not "
                        "covered by its registration!!\n"));        
            
            hr = WBEM_E_INVALID_OBJECT;
        }
    }

    return hr;
}

HRESULT CFilterProxy::BatchMany(long nEvents, IUnknown **ppObjects)
{
    HRESULT hr = S_OK;

    for ( long i = 0; i < nEvents && SUCCEEDED(hr); i++ )
    {    
        //
        // Check overall validity
        //
    
        if( ppObjects[i] == NULL )
        {
            ERRORTRACE((LOG_ESS, "Event provider returned a NULL event!\n"));
            return WBEM_E_INVALID_PARAMETER;
        }
    
        CWbemObject *pObj = (CWbemObject*)(IWbemClassObject*)ppObjects[i];
    
        if( pObj->IsObjectInstance() != WBEM_S_NO_ERROR )
        {
            ERRORTRACE((LOG_ESS, "CLASS object received from event provider!\n"));
            return WBEM_E_INVALID_PARAMETER;
        }

        //
        // Run the event through the filter
        //

        CInCritSec   ics(&m_cs);
        CSortedArray aTrues;
            
        hr = FilterEvent( pObj, aTrues );
        
        if ( hr == WBEM_S_NO_ERROR )
        {
            _DBG_ASSERT( aTrues.Size() > 0 );

            //
            // Delivery is required --- add this event to the list
            //

            SetGenerationTime(pObj);
            BatchEvent(pObj, &aTrues);
        }
    }

    return hr;
}

class CDeleteTargetsArray
{
protected:
    WBEM_REM_TARGETS *m_pData;
	int              *m_piSize;

public:
    CDeleteTargetsArray(WBEM_REM_TARGETS *pData, int *piSize) : 
		m_pData(pData),
		m_piSize(piSize)
	{
	}

    ~CDeleteTargetsArray() 
	{
		int nSize = *m_piSize;

		for (DWORD i = 0; i < nSize; i++)
            TempClearTargets(m_pData + i);
	}
};

HRESULT CFilterProxy::ProcessMany(long lNumObjects, 
                                    IUnknown** apObjects,
                                    long lSDLength, BYTE* pSD)
{
    //
    // NOTE: not in critical section
    //

    HRESULT hres;

    if (IsBatching())
        return BatchMany(lNumObjects, apObjects);

    //
    // Allocate appropriate arrays on the stack
    //

    CTempArray<IWbemClassObject*> apEventsToSend;
    INIT_TEMP_ARRAY(apEventsToSend, lNumObjects);
    if(apEventsToSend == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CTempArray<WBEM_REM_TARGETS> aTargetsToSend;
    INIT_TEMP_ARRAY(aTargetsToSend, lNumObjects);
    if(aTargetsToSend == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    int lNumToSend = 0;

    // Make sure the array gets cleaned up.
	CDeleteTargetsArray deleteMe(aTargetsToSend, &lNumToSend);
	
	// 
    // Iterate over events supplied and move those that need to be delivered
    // into delivery arrays
    //

    CFilterProxyManager* pManager = NULL;
    {
        //
        // We could choose a smaller window, but I am betting that the cost of
        // entering and exiting the cs many times will outweigh the benefits
        // of slightly smaller windows
        //

        CInCritSec ics(&m_cs);
    
        for(long i = 0; i < lNumObjects; i++)
        {        
            //
            // Check overall validity
            //
            
            if( apObjects[i] == NULL )
            {
                ERRORTRACE((LOG_ESS, "Event provider returned a NULL event!\n"));
                return WBEM_E_INVALID_PARAMETER;
            }
    
            CWbemObject *pObj = (CWbemObject*)(IWbemClassObject*)apObjects[i];
            
            if( pObj->IsObjectInstance() != WBEM_S_NO_ERROR )
            {
                ERRORTRACE((LOG_ESS, "CLASS object received from event provider!\n"));
                return WBEM_E_INVALID_PARAMETER;
            }

            //
            // Run the event through the filter
            //
        
            CSortedArray aTrues;
            
            hres = FilterEvent( pObj, aTrues );

            if ( hres == WBEM_S_FALSE )
            {
                ;
            }
            else if ( hres == WBEM_S_NO_ERROR )
            {
                _DBG_ASSERT( aTrues.Size() > 0 );

                //
                // Delivery is required --- add this event to the list
                //
    
                SetGenerationTime(pObj);
        
                apEventsToSend[lNumToSend] = pObj;

                if(!TempSetTargets(aTargetsToSend + lNumToSend, &aTrues))
                    return WBEM_E_OUT_OF_MEMORY;
            
                lNumToSend++;
            }
            else
            {
                return hres;
            }
        }
    
        //
        // If any events need to be delivered, get the delivery pointer
        //

        if(lNumToSend > 0)
        {
            pManager = m_pManager;
            if(pManager)
                pManager->AddRef();
            else
                return WBEM_S_FALSE;
        }
    }
        
    CReleaseMe rm1(pManager);

    //
    // If any events need to be delivered, deliver
    //

    if(lNumToSend > 0)
    {
        hres = pManager->DeliverEvent(lNumToSend, apEventsToSend, 
                                            aTargetsToSend,
                                            lSDLength, pSD);
        
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter stub failed to process an event: "
                    "error code %X\n", hres));
        }

        return hres;
    }

    return WBEM_S_FALSE;
}

HRESULT STDMETHODCALLTYPE CFilterProxy::Indicate(long lNumObjects, 
                                        IWbemClassObject** apObjects)
{
    return IndicateWithSD(lNumObjects, (IUnknown**)apObjects, 
                            m_lSDLength, m_pSD);
}

HRESULT STDMETHODCALLTYPE CFilterProxy::SetStatus(long lFlags, HRESULT hResult,
                        BSTR strResult, IWbemClassObject* pErrorObj)
{
    return m_pManager->SetStatus(lFlags, hResult, strResult, pErrorObj);
}

STDMETHODIMP CFilterProxy::IndicateWithSD(long lNumObjects,
                IUnknown** apObjects, long lSDLength, BYTE* pSD)
{
    if(lNumObjects <= 0 || apObjects == NULL)
        return WBEM_E_INVALID_PARAMETER;

    if(pSD == NULL)
    {
        //
        // Use proxy defaults
        //
    
        lSDLength = m_lSDLength;
        pSD = m_pSD;
    }

    try
    {
        //
        // Special-case single event
        //

        if(lNumObjects == 1)
            return ProcessOne(*apObjects, lSDLength, pSD);
        else 
            return ProcessMany(lNumObjects, apObjects, lSDLength, pSD);

    }
    catch(...)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
}
    

STDMETHODIMP CFilterProxy::IsActive()
{
    CInCritSec ics(&m_cs);

    return (m_Filter.IsFalse()?WBEM_S_FALSE:WBEM_S_NO_ERROR);
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxy::SetSinkSecurity(
                long lSDLength,
                BYTE* pSD)
{
    CInCritSec ics(&m_cs);

    //
    // Check for validity
    //

    if(lSDLength < 0)
        return WBEM_E_INVALID_PARAMETER;

    if(lSDLength > 0)
    {
        SECURITY_DESCRIPTOR* pDesc = (SECURITY_DESCRIPTOR*)pSD;
        if(!IsValidSecurityDescriptor(pDesc))
            return WBEM_E_INVALID_PARAMETER;
    
        if(pDesc->Owner == NULL || pDesc->Group == NULL)
            return WBEM_E_INVALID_PARAMETER;
    
        if(GetSecurityDescriptorLength(pSD) != (DWORD)lSDLength)
            return WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        if(pSD != NULL)
            return WBEM_E_INVALID_PARAMETER;
    }
        
    //
    // Store the SD in the proxy
    //

    if(m_pSD && m_pSD != &mstatic_EmptySD)
        delete [] m_pSD;

    if(lSDLength)
    {
        m_pSD = new BYTE[lSDLength];
        if(m_pSD == NULL)
            return WBEM_E_OUT_OF_MEMORY;
    
        memcpy(m_pSD, pSD, lSDLength);
    }
    else
    {
        //
        // Cannot let m_pSD be NULL 
        //
        m_pSD = &mstatic_EmptySD;
    }
    m_lSDLength = lSDLength;

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxy::GetRestrictedSink(
                long lNumQueries,
                const LPCWSTR* awszQueries,
                IUnknown* pCallback,
                IWbemEventSink** ppSink)
{
    return m_pManager->GetRestrictedSink(lNumQueries, awszQueries, 
                                                pCallback, ppSink);
}

STDMETHODIMP CFilterProxy::SetBatchingParameters(
    LONG lFlags,
    DWORD dwMaxBufferSize,
    DWORD dwMaxSendLatency)
{
    HRESULT    hr = S_OK;
    CInCritSec ics(&m_cs);

    switch(lFlags)
    {
	    // TODO: WBEM_FLAG_BATCH_IF_NEEDED currently works the same as
        // WBEM_FLAG_MUST_NOT_BATCH.  At some point this needs allow 
        // subscriptions to determine the batching behavior.
        case WBEM_FLAG_BATCH_IF_NEEDED:
	    case WBEM_FLAG_MUST_NOT_BATCH:
            m_typeBatch = (WBEM_BATCH_TYPE) lFlags;
            m_pManager->RemoveProxyLatency(this);
            m_bBatching = FALSE;
            break;

	    case WBEM_FLAG_MUST_BATCH:
            m_typeBatch = (WBEM_BATCH_TYPE) lFlags;
            m_dwMaxSendLatency = dwMaxSendLatency;
            m_dwMaxBufferSize = dwMaxBufferSize;
            m_dwLastSentStamp = m_pManager->GetLastSentStamp();
            hr = m_pManager->SetProxyLatency(this, dwMaxSendLatency);
            m_bBatching = TRUE;
            break;

        default:
            hr = WBEM_E_INVALID_PARAMETER;
            break;
    }

    return hr;
}

// Assumes pMainProxy is locked
HRESULT CFilterProxy::TransferFiltersFromMain(CFilterProxy* pMain)
{
    HRESULT hres;

    //
    // Move all the normal filters
    //

    try
    {
        m_Filter = pMain->m_Filter;
    }
    catch(CX_MemoryException)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
   
    if ( m_bUtilizeGuarantee )
    {
        // Utilize source definition
        // =========================
	
        CContextMetaData MetaData(m_pMetaData, NULL);
        hres = m_Filter.UtilizeGuarantee(m_SourceDefinition, &MetaData);
        if(FAILED(hres))
        {
            ERRORTRACE((LOG_ESS, "Filter proxy unable to utilize guarantee for"
            " a new proxy; error code: %X\n", hres));
            return hres;
        }
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CFilterProxy::GetUnmarshalClass(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        CLSID* pClsid)
{
    return m_pManager->GetUnmarshalClass(riid, pv, dwDestContext, pvReserved,
                        mshlFlags, pClsid);
}

STDMETHODIMP CFilterProxy::GetMarshalSizeMax(REFIID riid, void* pv, 
                        DWORD dwDestContext, void* pvReserved, DWORD mshlFlags, 
                        ULONG* plSize)
{
    return m_pManager->GetMarshalSizeMax(riid, pv, dwDestContext, pvReserved,
                        mshlFlags, plSize);
}

STDMETHODIMP CFilterProxy::MarshalInterface(IStream* pStream, REFIID riid, 
                        void* pv, DWORD dwDestContext, void* pvReserved, 
                        DWORD mshlFlags)
{
    return m_pManager->MarshalInterface(pStream, riid, pv, dwDestContext, 
                        pvReserved, mshlFlags);
}

/////////////////////////////////////////////////////////////////////////////
// CEventBatch

#define INIT_SIZE   32
#define GROW_SIZE   32

CEventBatch::CEventBatch() :
    m_ppObjs(NULL),
    m_pTargets(NULL),
    m_nItems(0),
    m_dwSize(0)
{
    m_ppObjs = new IWbemClassObject*[INIT_SIZE];   
    if (!m_ppObjs)
        throw CX_MemoryException();

    m_pTargets = new WBEM_REM_TARGETS[INIT_SIZE];
    if (!m_pTargets)
        throw CX_MemoryException();

    m_dwSize = INIT_SIZE;
}

CEventBatch::~CEventBatch()
{
    RemoveAll();

    if (m_ppObjs)
        delete [] m_ppObjs;

    if (m_pTargets)
        delete [] m_pTargets;
}

BOOL CEventBatch::EnsureAdditionalSize(DWORD nAdditionalNeeded)
{
    if (m_nItems + nAdditionalNeeded > m_dwSize)
    {
        DWORD            nNewSize = m_nItems + nAdditionalNeeded + GROW_SIZE;
        IWbemClassObject **ppNewObjs;
        WBEM_REM_TARGETS *pNewTargets;

        ppNewObjs = new IWbemClassObject*[nNewSize];
        if (!ppNewObjs)
            throw CX_MemoryException();

        pNewTargets = new WBEM_REM_TARGETS[nNewSize];
        if (!pNewTargets)
        {
            delete [] ppNewObjs;
            throw CX_MemoryException();
        }

        // Copy the data from the old pointers to the new pointers.
        memcpy(ppNewObjs, m_ppObjs, m_nItems * sizeof(ppNewObjs[0]));
        memcpy(pNewTargets, m_pTargets, m_nItems * sizeof(pNewTargets[0]));

        // Get rid of the old pointers.
        delete [] m_ppObjs;
        delete [] m_pTargets;

        // Set our member pointers with the new pointers.
        m_ppObjs = ppNewObjs;
        m_pTargets = pNewTargets;

        m_dwSize = nNewSize;
    }

    return TRUE;
}

BOOL CEventBatch::AddEvent(IWbemClassObject *pObj, CSortedArray *pTrues)
{
    BOOL bRet = FALSE;

    if (EnsureAdditionalSize(1))
    {
        if (SUCCEEDED(pObj->Clone(&m_ppObjs[m_nItems])))
        {
            if(!TempSetTargets(m_pTargets + m_nItems, pTrues))
                return FALSE;

            m_nItems++;

            bRet = TRUE;
        }
    }

    return bRet;
}

void CEventBatch::RemoveAll()
{
    for (DWORD i = 0; i < m_nItems; i++)
    {
        m_ppObjs[i]->Release();
        
        TempClearTargets(m_pTargets + i);
    }

    m_nItems = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\main.cpp ===
#include "precomp.h"
#include <wmiauthz.h>
#include <commain.h>
#include <clsfac.h>
#include "filtprox.h"
#include "wmiauthz.h"

class CEssProxyServer : public CComServer
{
protected:

    HRESULT Initialize()
    {
        AddClassInfo( CLSID_WbemFilterProxy,
            new CSimpleClassFactory<CFilterProxyManager>(GetLifeControl()), 
            __TEXT("Event filter marshaling proxy"), TRUE);
        AddClassInfo( CLSID_WbemTokenCache,
            new CSimpleClassFactory<CWmiAuthz>(GetLifeControl()), 
            __TEXT("Wbem Token Cache"), TRUE );
        
        return S_OK;
    }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\groupsforuser.cpp ===
//****************************************************************************
//
//  Copyright (C) 1999 Microsoft Corporation
//
//  GROUPSFORUSER.CPP
//
//****************************************************************************

// This is done in the sources file: WIN32_WIN32_WINNT=0x0400
//#define _WIN32_WINNT 0x0400

#include "precomp.h"
#include <wbemcomn.h>
#include "wmiauthz.h"
#include "GroupsForUser.h"


//
// Store the error status of CWmiAuthzWrapper and CAdminSID class initialization.
// They are set to ERROR_INVALID_ACCESS error status initially.
//

static DWORD    g_dwWmiAuthzError = ERROR_INVALID_ACCESS;
static DWORD    g_dwAdminSIDError = ERROR_INVALID_ACCESS;


//
// Class definition of CWmiAuthzWrapper class.
// This class wraps CWmiAuthz class:
//  - It creates an instance of CWmiAuthz class in its 
//    constructor and deletes it in descrutor.  
//  - Sets g_dwWmiAuthzError global in case of error otherwise
//    sets it to 0 ( ERROR_SUCCESS )
//

class CWmiAuthzWrapper
{
    // Private member variables
    CWmiAuthz   *m_pWmiAuthz;

public:
    // Constructor 
    CWmiAuthzWrapper( )
    {
        m_pWmiAuthz = new CWmiAuthz( NULL );
        if ( NULL == m_pWmiAuthz )
        {
            g_dwWmiAuthzError = ERROR_OUTOFMEMORY;
        }
        else
        {
            m_pWmiAuthz->AddRef( );
            g_dwWmiAuthzError = ERROR_SUCCESS;
        }
    }

    // Destructor 
    ~CWmiAuthzWrapper( )
    {
        if ( m_pWmiAuthz )
        {
            m_pWmiAuthz->Release( );
        }
    }

    // Accessor method to CWmiClass instance
    CWmiAuthz * GetWmiAuthz( ) const
    {
        return m_pWmiAuthz;
    }

};


//
// Class definition of CAdminSID class.
// - Allocates Admin SID in its constructor and
//   frees it in destructor.
// - Sets g_dwAdminSIDError global in case of error otherwise
//    sets it to 0 ( ERROR_SUCCESS )
//

class CAdminSID
{
    PSID         m_pSIDAdmin;

public:
    // Constructor
    CAdminSID( )
    {
        //
        // Create a System Identifier for the Admin group.
        //

        SID_IDENTIFIER_AUTHORITY    SystemSidAuthority = SECURITY_NT_AUTHORITY;

        if ( FALSE == AllocateAndInitializeSid ( &SystemSidAuthority, 
                                                 2, 
                                                 SECURITY_BUILTIN_DOMAIN_RID, 
                                                 DOMAIN_ALIAS_RID_ADMINS,
                                                 0, 0, 0, 0, 0, 0, 
                                                 &m_pSIDAdmin ) )
        {
            g_dwAdminSIDError = GetLastError( );
            ERRORTRACE( ( LOG_ESS, "AllocateAndInitializeSid failed, error 0x%X\n", g_dwAdminSIDError ) );
            m_pSIDAdmin = NULL;
        }
        else
        {
            g_dwAdminSIDError = ERROR_SUCCESS;
        }
    }

    // Destructor
    ~CAdminSID( )
    {
        if ( m_pSIDAdmin )
        {
            FreeSid ( m_pSIDAdmin );
        }
    }

    // Accessor method to Admin SID
    PSID GetAdminSID( ) const
    {
        return m_pSIDAdmin;
    }
};


//
// Static glabal declaration of CWmiAuthsWrapper class.
//

static CWmiAuthzWrapper g_wmiAuthzWrapper;


//
// Static glabal declaration of CAdminSID class.
//

static CAdminSID g_adminSID;


//
// Returns SD and DACL with a given Access Mask and SID
//

DWORD GetSDAndACLFromSID( DWORD dwAccessMask, PSID pSID, 
                          BYTE **ppNewDACL, 
                          BYTE **ppNewSD )
{
    DWORD   dwError = 0,
            dwDACLLength = sizeof ( ACL ) + 
                           sizeof ( ACCESS_ALLOWED_ACE ) - 
                           sizeof ( DWORD ) + 
                           GetLengthSid ( pSID );
    // 
    // Get memory needed for new DACL
    //

    *ppNewDACL = new BYTE[ dwDACLLength ];
    if ( !*ppNewDACL )
    {
        *ppNewSD = NULL;
        return E_OUTOFMEMORY;
    }

    //
    // Get memory for new SD
    //

    *ppNewSD = new BYTE[ sizeof( SECURITY_DESCRIPTOR ) ];
    if ( !*ppNewSD )
    {
        delete[] *ppNewDACL;
        *ppNewDACL = NULL;
        return E_OUTOFMEMORY;
    }

    do
    {
        //
        // Initialize new SD
        //

        if ( FALSE == InitializeSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                     SECURITY_DESCRIPTOR_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Initialize new DACL
        //

        if ( FALSE == InitializeAcl ( ( PACL )*ppNewDACL, 
                                      dwDACLLength, 
                                      ACL_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Get DACL using Access Mask and SID
        //

        if ( FALSE == AddAccessAllowedAce ( ( PACL )*ppNewDACL, 
                                            ACL_REVISION, 
                                            dwAccessMask, 
                                            pSID ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidAcl ( ( PACL )*ppNewDACL ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set DACL to the SD
        //

        if ( FALSE == SetSecurityDescriptorDacl ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                  TRUE, ( PACL )*ppNewDACL, 
                                                  FALSE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Group to the SD
        //

        if ( FALSE == SetSecurityDescriptorGroup ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   pSID, 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Owner to the SD
        //

        if ( FALSE == SetSecurityDescriptorOwner ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   pSID, 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD ) )
        {
            dwError = GetLastError( );
            break;
        }
    }
    while( FALSE );

    //
    // Delete the stuff in case of error
    //

    if ( dwError )
    {
        delete[] *ppNewDACL;
        delete[] *ppNewSD;
        *ppNewDACL = NULL;
        *ppNewSD = NULL;
    }

    return dwError;
}


//
// Returns SD  with a given DACL
//

DWORD GetSDFromACL( PACL pNewDACL, BYTE **ppNewSD )
{
    //
    // Return if error occured during initialization of Admin SID
    // in CAdminSID static global class declaration;
    //

    _DBG_ASSERT( !g_dwAdminSIDError );

    if ( g_dwAdminSIDError )
    {
        *ppNewSD = NULL;
        return g_dwAdminSIDError;
    }

    //
    // Get memory for new SD
    //

    *ppNewSD = new BYTE[ sizeof( SECURITY_DESCRIPTOR ) ];
    if ( !*ppNewSD )
    {
        return E_OUTOFMEMORY;
    }

    DWORD   dwError = 0;

    do
    {
        //
        // Initialize new SD
        //

        if ( FALSE == InitializeSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                     SECURITY_DESCRIPTOR_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set DACL to the SD
        //

        if ( FALSE == SetSecurityDescriptorDacl ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                  TRUE, pNewDACL, FALSE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Group to the SD with Admin SID
        //

        if ( FALSE == SetSecurityDescriptorGroup ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   g_adminSID.GetAdminSID( ), 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Set Owner to the SD
        //

        if ( FALSE == SetSecurityDescriptorOwner ( ( PSECURITY_DESCRIPTOR )*ppNewSD, 
                                                   g_adminSID.GetAdminSID( ), 
                                                   TRUE ) )
        {
            dwError = GetLastError( );
            break;
        }
        
        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidSecurityDescriptor ( ( PSECURITY_DESCRIPTOR )*ppNewSD ) )
        {
            dwError = GetLastError( );
            break;
        }
    }
    while( FALSE );

    //
    // Delete the security descriptor in case of error
    //

    if ( dwError )
    {
        delete[] *ppNewSD;
        *ppNewSD = NULL;
    }

    return dwError;
}

//
// Returns STATUS_SUCCESS if user is in group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
//

NTSTATUS IsUserInGroup( PSID pSidUser, PSID pSidGroup )
{
    _DBG_ASSERT( IsValidSid( pSidUser ) );
    _DBG_ASSERT( IsValidSid( pSidGroup ) );

    //
    // Return if error occured during creation of CWmiAuthz class
    // in static global CWmiAuthzWrapper class declaration.
    //

    _DBG_ASSERT( !g_dwWmiAuthzError );

    if ( g_dwWmiAuthzError )
    {
        return g_dwWmiAuthzError;
    }

    IWbemToken  *pToken = NULL;
    HRESULT     hr = g_wmiAuthzWrapper.GetWmiAuthz( )->GetToken( ( BYTE * )pSidUser, &pToken );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    BYTE        *pDACL = NULL;
    BYTE        *pSD = NULL;
    DWORD       dwAccess = 0;
    NTSTATUS    stat = GetSDAndACLFromSID( STANDARD_RIGHTS_EXECUTE, 
                                           pSidGroup, 
                                           &pDACL, 
                                           &pSD );

    if ( stat )
    {
        pToken->Release( );
        return stat;
    }

    hr = pToken->AccessCheck( STANDARD_RIGHTS_EXECUTE, pSD, &dwAccess );

    pToken->Release( );

    //
    // Delete allocated memory in GetSDAndACLFromSID
    //

    delete[] pSD;
    delete[] pDACL;

    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( STANDARD_RIGHTS_EXECUTE & dwAccess )
    {
        return STATUS_SUCCESS;
    }

    return STATUS_ACCESS_DENIED;
}


//
// Returns STATUS_SUCCESS if user is in admin group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
//

NTSTATUS IsUserAdministrator( PSID pSidUser )
{
    _DBG_ASSERT( IsValidSid( pSidUser ) );

    //
    // Return if error occured during initialization of Admin SID
    // in CAdminSID static global class declaration;
    //

    _DBG_ASSERT( !g_dwAdminSIDError );

    if ( g_dwAdminSIDError )
    {
        return g_dwAdminSIDError;
    }

    //
    // Call IsUserInGroup with Administrators group SID
    //

    return IsUserInGroup( pSidUser, g_adminSID.GetAdminSID( ) );
}


//
// Retireves access mask corresponding to permissions granted
// by dacl to account denoted in pSid
// only deals with the ACCESS_ALLOWED/DENIED type aces 
// including the ACCESS_ALLOWED/DENIED_OBJECT_ACEs
// - will error out if it finds a SYSTEM_AUDIT or unrecognized type.
//

NTSTATUS GetAccessMask( PSID pSid, PACL pDacl, DWORD *pdwAccessMask )
{
    if ( NULL == pDacl )
    {
        *pdwAccessMask = 0xFFFFFFFF;
        return STATUS_SUCCESS;
    }
    
    _DBG_ASSERT( IsValidSid( pSid ) );
    _DBG_ASSERT( IsValidAcl( pDacl ) );

    *pdwAccessMask = NULL;

    //
    // Return if error occured during creation of CWmiAuthz class
    // in static global CWmiAuthzWrapper class declaration.
    //

    _DBG_ASSERT( !g_dwWmiAuthzError );

    if ( g_dwWmiAuthzError )
    {
        return g_dwWmiAuthzError;
    }

    IWbemToken  *pToken = NULL;
    HRESULT     hr = g_wmiAuthzWrapper.GetWmiAuthz( )->GetToken( ( BYTE * )pSid, &pToken );

    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    BYTE        *pSD = NULL;
    NTSTATUS    stat = GetSDFromACL( pDacl, &pSD );

    if ( stat )
    {
        pToken->Release( );
        return stat;
    }

    //
    // Requested DesiredAccessMask should be MAXIMUM_ALLOWED
    // to be able to retrieve all the accesses with replied
    // access mask
    //

    hr = pToken->AccessCheck( MAXIMUM_ALLOWED, pSD, pdwAccessMask );

    pToken->Release( );

    //
    // Delete allocated memory in GetSDFromACL
    //

    delete[] pSD;

    if ( FAILED( hr ) )
    {
        return hr;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\newnew.h ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

   NEWNEW.H

Abstract:

   CReuseMemoryManager

History:

--*/

#ifndef __WBEM_NEW_NEW__H_
#define __WBEM_NEW_NEW__H_

#include "esscpol.h"
#include <stack>

class ESSCLI_POLARITY CReuseMemoryManager
{
protected:
    CCritSec m_cs;
    CFlexQueue m_Available;
    int m_nSize;
    int m_nMaxQueued;
public:
    CReuseMemoryManager(size_t nSize, size_t nMaxQueued = 0 )
      : m_nSize(nSize)
    {
        m_nMaxQueued = nMaxQueued == 0 ? 256 : nMaxQueued;
    }

    ~CReuseMemoryManager()
    {
        Clear();
    }

    void* Allocate()
    {
        CInCritSec ics(&m_cs);

        if(m_Available.GetQueueSize() == 0)
        {
            return new BYTE[m_nSize];
        }
        else
        {
            void* p = m_Available.Unqueue();
            return p;
        }
    }
    
    void Free(void* p)
    {
        CInCritSec ics(&m_cs);

        if ( m_Available.GetQueueSize() < m_nMaxQueued )
        {
            m_Available.Enqueue(p);
        }
        else
        {
            delete [] (BYTE*)p;
        }
    }
        
    void Clear()
    {
        CInCritSec ics(&m_cs);

        while(m_Available.GetQueueSize())
        {
            delete [] (BYTE*)m_Available.Unqueue();
        }
    }
};

#define DWORD_ALIGNED(x)    (((x) + 3) & ~3)
#define QWORD_ALIGNED(x)    (((x) + 7) & ~7)

#ifdef _WIN64
#define DEF_ALIGNED         QWORD_ALIGNED
#else
#define DEF_ALIGNED         DWORD_ALIGNED
#endif

class ESSCLI_POLARITY CTempMemoryManager
{
protected:
    CCritSec m_cs;
    
    class CAllocation
    {
    private:
        size_t m_dwAllocationSize;
        size_t m_dwUsed;
        size_t m_dwFirstFree;

        static inline size_t GetHeaderSize() {return sizeof(CAllocation);}
        inline byte* GetStart() {return ((byte*)this) + GetHeaderSize();}
        inline byte* GetEnd() {return ((byte*)this) + m_dwAllocationSize;}

    public:
        size_t GetAllocationSize() {return m_dwAllocationSize;}
        size_t GetUsedSize() {return m_dwUsed;}
        static size_t GetMinAllocationSize(size_t dwBlock)
            {return dwBlock + GetHeaderSize();}

        void Init(size_t dwAllocationSize);
        void* Alloc(size_t nBlockSize);
        bool Contains(void* p);
        bool Free(size_t nBlockSize);
        void Destroy();
    };

    CPointerArray<CAllocation>* m_pAllocations;
    DWORD m_dwTotalUsed;
    DWORD m_dwTotalAllocated;
    DWORD m_dwNumAllocations;
    DWORD m_dwNumMisses;

protected:
    inline size_t RoundUp(size_t nSize) {return DEF_ALIGNED(nSize);}

public:
    CTempMemoryManager();
    ~CTempMemoryManager();

    void* Allocate(size_t nBlockSize);
    void Free(void* p, size_t nBlockSize);
    void Clear();
};

#define MAX_ALLOCA_USE 100

template <class TArg>
class CTempArray
{
protected:
    BYTE* m_a;
    BOOL m_bStack;
    int m_nByteSize;

    TArg* GetArray() {return (TArg*)m_a;}
    const TArg* GetArray() const {return (const TArg*)m_a;}
public:
    inline CTempArray() : m_a(NULL), m_bStack(TRUE), m_nByteSize(0){}

    inline ~CTempArray()
    {
        if(!m_bStack)
            delete [] m_a;
    }

    operator TArg*() {return (TArg*)m_a;}
    operator const TArg*() const {return (const TArg*)m_a;}

    TArg& operator[](int nIndex) {return GetArray()[nIndex];}
    const TArg& operator[](int nIndex) const {return GetArray()[nIndex];}
    TArg& operator[](long lIndex) {return GetArray()[lIndex];}
    const TArg& operator[](long lIndex) const {return GetArray()[lIndex];}

    void SetMem(void* p) {m_a = (BYTE*)p;}
    BOOL SetSize(int nSize)
    {
        m_nByteSize = nSize * sizeof(TArg);
        if(m_nByteSize < MAX_ALLOCA_USE)
        {
            m_bStack = TRUE;
            return TRUE;
        }
        else
        {
            m_bStack = FALSE;
            return FALSE;
        }
    }
    int GetByteSize() {return m_nByteSize;}
    BOOL IsNull() {return (m_a == NULL);}
};

    
// This macro initializes the CTempArray with a given size.  First it "sets" the
// size into the array, which returns TRUE if _alloca can be used.  If so, it
// uses alloca on the now-computed byte size of the array.

#define INIT_TEMP_ARRAY(ARRAY, SIZE) \
        ((ARRAY.SetMem(                         \
            (ARRAY.SetSize(SIZE)) ?             \
                _alloca(ARRAY.GetByteSize()) :  \
                new BYTE[ARRAY.GetByteSize()]   \
                     )                          \
        ), !ARRAY.IsNull())                     \

    

        

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\newnew.cpp ===
/*++

Copyright (C) 1998-1999 Microsoft Corporation

Module Name:

   NEWNEW.CPP

Abstract:

   CReuseMemoryManager

History:

--*/

#include "precomp.h"
#include <wbemcomn.h>
#include <sync.h>
#include "newnew.h"

const int constMinAllocationSize = 4096;
const int constMaxAllocationSize = 1024 * 1024;
const double constNextAllocationFactor = 2.0;

void CTempMemoryManager::CAllocation::Init(size_t dwAllocationSize)
{
    m_dwAllocationSize = dwAllocationSize;
    m_dwUsed = 0;
    m_dwFirstFree = GetHeaderSize();
}
    
void* CTempMemoryManager::CAllocation::Alloc(size_t nBlockSize)
{
    if(m_dwFirstFree + nBlockSize <= m_dwAllocationSize)
    {
        m_dwUsed += nBlockSize;
        void* p = ((byte*)this) + m_dwFirstFree;
        m_dwFirstFree += nBlockSize;
        return p;
    }
    else 
        return NULL;
}

bool CTempMemoryManager::CAllocation::Contains(void* p)
{
    return (p > this && p <= GetEnd());
}

void CTempMemoryManager::CAllocation::Destroy()
{
    VirtualFree(this, 0, MEM_RELEASE);
}

bool CTempMemoryManager::CAllocation::Free(size_t nBlockSize)
{
    m_dwUsed -= nBlockSize;
    if(m_dwUsed== 0)
    {
		m_dwFirstFree = GetHeaderSize();
        return true;
    }
    else
        return false;
}



void* CTempMemoryManager::Allocate(size_t nBlockSize)
{
    //
    // Add the space for the length of the block
    //

    nBlockSize += DEF_ALIGNED(sizeof(DWORD));
    nBlockSize = RoundUp(nBlockSize);

    CInCritSec ics(&m_cs);

    // 
    // Check if the last allocation has room
    //

    int nAllocations = m_pAllocations->GetSize();
    CAllocation* pLast = NULL;
    if(nAllocations)
    {
        pLast = (*m_pAllocations)[nAllocations-1];
        void* p = pLast->Alloc(nBlockSize);
        if(p)
        {
            *(DWORD*)p = nBlockSize;
            m_dwTotalUsed += nBlockSize;
            m_dwNumAllocations++;
            return ((BYTE*)p) + DEF_ALIGNED(sizeof(DWORD));
        }
        else if(pLast->GetUsedSize() == 0)
        {
            //
            // The last allocation record is actually empty --- we don't want
            // to leave it there, as it will just dangle
            //

            m_dwTotalAllocated -= pLast->GetAllocationSize();
            pLast->Destroy();
            (*m_pAllocations).RemoveAt(nAllocations-1);
        }
    }
    
    //
    // No room:  need a new allocation.  The size shall be double the previous
    // size, or 1M if too large
    //

    size_t dwAllocationSize = 0;
    if(nAllocations == 0)
    {
        //
        // First time: constant size
        //

        dwAllocationSize = constMinAllocationSize;
    }
    else
    {
        //
        // Not first time: allocation constant factor of the total, but not
        // larger that a constant.
        //

        dwAllocationSize = m_dwTotalUsed * constNextAllocationFactor;

        if(dwAllocationSize > constMaxAllocationSize)
            dwAllocationSize = constMaxAllocationSize;

        if(dwAllocationSize < constMinAllocationSize)
            dwAllocationSize = constMinAllocationSize;
    }

    if(dwAllocationSize < CAllocation::GetMinAllocationSize(nBlockSize))
    {
        dwAllocationSize = CAllocation::GetMinAllocationSize(nBlockSize);
    }

    // 
    // VirtualAlloc it and read back the actual size of the allocation
    //
    
    CAllocation* pAlloc = (CAllocation*)
        VirtualAlloc(NULL, dwAllocationSize, MEM_COMMIT, PAGE_READWRITE);
    if(pAlloc == NULL)
        return NULL;

    MEMORY_BASIC_INFORMATION info;
    VirtualQuery(pAlloc, &info, sizeof(MEMORY_BASIC_INFORMATION));
            
    //
    // Initialize it, and add it to the list of allocations
    //

    pAlloc->Init(info.RegionSize);
    m_pAllocations->Add(pAlloc);
    m_dwTotalAllocated += dwAllocationSize;
    m_dwNumAllocations++;
    m_dwNumMisses++;

    //
    // Allocation memory from it
    //

    void* p = pAlloc->Alloc(nBlockSize);
    if(p)
    {
        *(DWORD*)p = nBlockSize;
        m_dwTotalUsed += nBlockSize;
        return ((BYTE*)p) + DEF_ALIGNED(sizeof(DWORD));
    }
    else
        return NULL;
}
    
void CTempMemoryManager::Free(void* p, size_t nBlockSize)
{
	if (p == NULL)
		return;

    CInCritSec ics(&m_cs);

    //
    // Figure out the size of the allocation
    //

    nBlockSize = *(DWORD*)((BYTE*)p - DEF_ALIGNED(sizeof(DWORD)));

    // 
    // Search for it in the allocations
    //

    for(int i = 0; i < m_pAllocations->GetSize(); i++)
    {
        CAllocation* pAlloc = (*m_pAllocations)[i];
        if(pAlloc->Contains(p))
        {
            //
            // Found it.  Remove and deallocate block if last.  Except that we
            // do not want to deallocate the last minimal block --- otherwise
            // small allocations will just keep VirtualAllocing all the time
            //

            m_dwTotalUsed -= nBlockSize;
        
            bool bLastInAlloc = pAlloc->Free(nBlockSize);
            if(!bLastInAlloc)
                return;

            bool bDestroy = false;
            if(m_pAllocations->GetSize() != i+1)
            {
                //
                // This is not the last record. Destroy it
                //

                bDestroy = true;
            }
            else
            {
                //
                // This is the last record.  Do more tests
                //

                if(m_pAllocations->GetSize() > 1)
                    bDestroy = true;
                else if((*m_pAllocations)[0]->GetAllocationSize() != 
                        constMinAllocationSize)
                    bDestroy = true;
            }

            if(bDestroy)
            {
                m_dwTotalAllocated -= pAlloc->GetAllocationSize();
                pAlloc->Destroy();
                (*m_pAllocations).RemoveAt(i);
            }
            return;
        }
    }

    // 
    // Bad news: freeing something we don't own!
    //

    return;
}

void CTempMemoryManager::Clear()
{
    for(int i = 0; i < m_pAllocations->GetSize(); i++)
    {
        CAllocation* pAlloc = (*m_pAllocations)[i];
        pAlloc->Destroy();
    }
    m_pAllocations->RemoveAll();
}

CTempMemoryManager::CTempMemoryManager() : 
    m_dwTotalUsed(0), m_dwTotalAllocated(0), m_dwNumAllocations(0),
    m_dwNumMisses(0), m_pAllocations(NULL)
{
    m_pAllocations = new CPointerArray<CAllocation>;
}

CTempMemoryManager::~CTempMemoryManager()
{
    Clear();
    delete m_pAllocations;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\precomp.h ===
#define COREPROX_POLARITY __declspec( dllimport )

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <windows.h>
#include <ole2.h>
#include <oleauto.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\treechecker.cpp ===
// TreeChecker.cpp

#include "precomp.h"
//#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "evaltree.h"
#include "evaltree.inl"
#include "TreeChecker.h"

#ifdef CHECK_TREES

CTreeChecker g_treeChecker;

void Trace(LPCTSTR szFormat, ...)
{
	va_list ap;

	char szMessage[512];

	va_start(ap, szFormat);
	vsprintf(szMessage, szFormat, ap);
	va_end(ap);

	lstrcat(szMessage, "\n");
	OutputDebugString(szMessage);
}

void CTreeChecker::AddTree(CEvalTree *pTree)
{
	CInCritSec cs1(&m_cs);

	m_mapTrees[pTree] = TRUE;
}

void CTreeChecker::RemoveTree(CEvalTree *pTree)
{
	CInCritSec cs(&m_cs);

	m_mapTrees.erase(pTree);
}

//int g_nAdded = 0;

void CTreeChecker::AddNode(CEvalNode *pNode)
{
	CInCritSec cs(&m_cs);
	
	//g_nAdded++;

	Trace("Adding node = 0x%p", pNode);

	m_mapNodes[pNode] = TRUE;
}

void CTreeChecker::RemoveNode(CEvalNode *pNode)
{
	CInCritSec cs(&m_cs);

	Trace("Removing node = 0x%p", pNode);

	m_mapNodes.erase(pNode);
}

void CTreeChecker::CheckoffNode(CEvalNode *pNode)
{
	// No critsec needed--already obtained by CheckTrees().
	CNodeMapItor node = m_pmapNodesTemp->find(pNode);

	if (node != m_pmapNodesTemp->end())
		m_pmapNodesTemp->erase(node);
	else
	{
		//DebugBreak();
		
		Trace("CEvalTree is holding on to invalid node: 0x%p", pNode);
	}
}

BOOL CTreeChecker::CheckTreeNodes()
{
	CInCritSec cs(&m_cs);
	CNodeMap   mapNodesTemp(m_mapNodes);
	BOOL	   bRet = TRUE;

	m_pmapNodesTemp = &mapNodesTemp;

	 
// This can be helpful to see what the trees look like before they're checked.
#if 0
	FILE *pFile = fopen("c:\\temp\\trees.txt", "a");
#endif

	for (CTreeMapItor tree = m_mapTrees.begin();
		tree != m_mapTrees.end();
		tree++)
	{
		CEvalTree *pTree = (*tree).first;
		
// This can be helpful to see what the trees look like before they're checked.
#if 0
		fprintf(pFile, "Tree: 0x%p\n");
		pTree->Dump(pFile);
		fprintf(pFile, "\n");
		fflush(pFile);
#endif

		pTree->CheckNodes(this);
	}

// This can be helpful to see what the trees look like before they're checked.
#if 0
	fclose(pFile);
#endif

	int nLeaks = 0;

	for (CNodeMapItor node = mapNodesTemp.begin();
		node != mapNodesTemp.end();
		node++)
	{
		CEvalNode *pNode = (*node).first;
		
		//DebugBreak();
		
		Trace("CEvalTree leaked node: 0x%p", pNode);
		nLeaks++;

		bRet = FALSE;
	}

	if (nLeaks)
		Trace("%d CEvalTree nodes leaked.", nLeaks);

	return bRet;
}

#endif // #ifdef CHECK_TREES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\twopropnode.inl ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TWOPROPNODE.INL

Abstract:

    Two Prop Node Inlines

History:

--*/

// inline support for templates for TwoPropNode

// silly warning about performance hits when converting an int to a bool
#pragma warning(disable: 4800)

// evaluate data in ObjInfo, decide which node (branch) should be evaluated next
template<class TPropType>
HRESULT TTwoScalarPropNode<TPropType>::Evaluate(CObjectInfo& ObjInfo, 
					  INTERNAL CEvalNode** ppNext)
{
	HRESULT herslut = WBEM_S_NO_ERROR;

    _IWmiObject* pLeftObj;
    _IWmiObject* pRightObj;

    if(SUCCEEDED(herslut = GetContainerObject(ObjInfo, &pLeftObj))
		&&
	   SUCCEEDED(herslut = GetRightContainerObject(ObjInfo, &pRightObj)))
	{
	    long lRead;
		TPropType lValue, rValue;

		// ugly compare: "if we get both properties"
		if (SUCCEEDED(herslut = pLeftObj->ReadPropertyValue(m_lPropHandle, sizeof(TPropType), &lRead, (BYTE*)&lValue))
			 &&
			SUCCEEDED(herslut = pRightObj->ReadPropertyValue(m_lRightPropHandle, sizeof(TPropType), &lRead, (BYTE*)&rValue)))
		{
			herslut = WBEM_S_NO_ERROR;
			if (lValue < rValue)
				*ppNext = m_apBranches[LT];
			else if (lValue > rValue)
				*ppNext = m_apBranches[GT];
			else 
				*ppNext = m_apBranches[EQ];						
		}
	}
	
	return herslut;
}

template<class TPropType>
CEvalNode* TTwoScalarPropNode<TPropType>::Clone() const
{
    return (CBranchingNode*) new TTwoScalarPropNode<TPropType>(*this, true);
}

template<class TPropType>
CTwoPropNode* TTwoScalarPropNode<TPropType>::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode*) new TTwoScalarPropNode<TPropType>(*this, false);
}


template<class TPropType>
long TTwoScalarPropNode<TPropType>::GetSubType()
{
    return EVAL_NODE_TYPE_TWO_SCALARS;
}


#pragma warning(default: 4800)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\treechecker.h ===
// TreeChecker.h

#ifndef __TREE_CHECKER_H
#define __TREE_CHECKER_H

#ifdef CHECK_TREES

class CEvalTree;
class CEvalNode;

#include <map>
#include <sync.h>

typedef std::map< CEvalTree*, 
                  BOOL, 
                  std::less<CEvalTree*>, 
                  wbem_allocator< BOOL > > CTreeMap;
typedef CTreeMap::iterator CTreeMapItor;

typedef std::map< CEvalNode*, 
                  BOOL,
                  std::less< CEvalNode* >,
                  wbem_allocator< BOOL > > CNodeMap;
typedef CNodeMap::iterator CNodeMapItor;

class CTreeChecker
{
public:
	CCritSec m_cs;

	// Called by the tree ctor.
	void AddTree(CEvalTree *pTree);
	
	// Called by the tree dtor.
	void RemoveTree(CEvalTree *pTree);

	// Called by the node ctor.
	void AddNode(CEvalNode *pNode);

	// Called by the node dtor.
	void RemoveNode(CEvalNode *pNode);

	// Called by nodes during a CheckTrees() call to indicate
	// a node is accounted for.
	void CheckoffNode(CEvalNode *pNode);

	// Used to check the validity of all trees.
	BOOL CheckTreeNodes();

protected:
	CTreeMap m_mapTrees;
	CNodeMap m_mapNodes,
			 *m_pmapNodesTemp;
};

extern CTreeChecker g_treeChecker;

#define CheckTrees()	 g_treeChecker.CheckTreeNodes();

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\twopropnode.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TWOPROPNODE.CPP

Abstract:

    Two Prop Node

History:

--*/


// classes to support a two-property node for the eval tree
// this will be much like the CPropertyNode defined in EvalTree.h
// but it will compare a property against another property
// rather than a property to a constant

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include "TwoPropNode.h"

// warning about performance hits when converting an int to a bool
#pragma warning(disable: 4800)

// this is only a test
// TTwoScalarPropNode<int> foolishMortal;


// set offset into object for the right property
// "tell me which property I'm operating on"

void CTwoPropNode::SetRightPropertyInfo(LPCWSTR wszPropName, long lPropHandle)
{
    m_lRightPropHandle = lPropHandle;
}



void CTwoPropNode::SetRightEmbeddingInfo(const CEmbeddingInfo* pInfo)
{
    try
    {
        if (pInfo && !pInfo->IsEmpty())
        {
            if (!m_pRightInfo)
                m_pRightInfo = new CEmbeddingInfo(*pInfo);
            else
                *m_pRightInfo = *pInfo;
        }
        else
        {
            delete m_pRightInfo;
            m_pRightInfo = NULL;
        }
    }
    catch(CX_MemoryException)
    {
    }
}



HRESULT CTwoPropNode::GetRightContainerObject(CObjectInfo& ObjInfo, 
                                 INTERNAL _IWmiObject** ppInst)
{
    if (!m_pRightInfo)
    {
        *ppInst = ObjInfo.GetObjectAt(0);
        return WBEM_S_NO_ERROR;
    }                
    else
        return m_pRightInfo->GetContainerObject(ObjInfo, ppInst);
}


HRESULT CTwoPropNode::CompileRightEmbeddingPortion(CContextMetaData* pNamespace, 
                                                              CImplicationList& Implications,
                                                              _IWmiObject** ppResultClass)
{
    if (!m_pRightInfo)
        return WBEM_E_FAILED;
    else
        return m_pRightInfo->Compile(pNamespace, Implications, ppResultClass);
}


void CTwoPropNode::SetRightEmbeddedObjPropName(CPropertyName& Name) 
{ 
    if (m_pRightInfo)
        m_pRightInfo->SetEmbeddedObjPropName(Name);
}


void CTwoPropNode::MixInJumpsRightObj(const CEmbeddingInfo* pParent)
{                                               
    if (pParent && m_pRightInfo)
        m_pRightInfo->MixInJumps(pParent);
}


CPropertyName* CTwoPropNode::GetRightEmbeddedObjPropName() 
{
    if (!m_pRightInfo)
        return NULL;
    else                
        return m_pRightInfo->GetEmbeddedObjPropName();
}

// compare precedence of this node to that node

int CTwoPropNode::ComparePrecedence(CBranchingNode* pOther)
{
    int nCompare;
    nCompare = GetSubType() - pOther->GetSubType();
    if(nCompare) return nCompare;

    CTwoPropNode* pOtherNode = (CTwoPropNode*)pOther;

    nCompare = m_pRightInfo->ComparePrecedence(pOtherNode->m_pRightInfo);
    if (nCompare == 0)
    {
        nCompare = CPropertyNode::ComparePrecedence(pOther);
        if (nCompare == 0)
            nCompare = m_lRightPropHandle - pOtherNode->m_lRightPropHandle;
    }
    
    return nCompare;
}


HRESULT CTwoPropNode::AdjustCompile(CContextMetaData* pNamespace, 
                                CImplicationList& Implications)
{   
    HRESULT hRes;

    if (SUCCEEDED(hRes = CBranchingNode::AdjustCompile(pNamespace, Implications)))
        if (m_pRightInfo)
            hRes = m_pRightInfo->Compile(pNamespace, Implications, NULL);
        else
            hRes = WBEM_E_FAILED;

    return hRes;
}


HRESULT CTwoPropNode::OptimizeSelf()
{
    // can't combine our three branches - nothing to do.
    return WBEM_S_NO_ERROR;
}


HRESULT CTwoPropNode::SetTest(VARIANT& v)
{
    // again, nothing to do, our test is determined by the Right side property
    // (this should never be called, but doesn't hurt anything)
    return WBEM_S_NO_ERROR;
}


void CTwoPropNode::Dump(FILE* f, int nOffset)
{
    PrintOffset(f, nOffset);

    if (m_pInfo)
        m_pInfo->Dump(f);

    if (m_pRightInfo)
        m_pRightInfo->Dump(f);

    fprintf(f, ", LeftPropHandle = (0x%x)\n", m_lPropHandle);
    fprintf(f, ", RightPropHandle = (0x%x)\n", m_lRightPropHandle);

    fprintf(f, "Branches:\n");    
    PrintOffset(f, nOffset);

    // "i = (Operations)((int)(i) + 1)" is basically i++, with all the BS needed to make the compiler happy.
    // thank you K&R for saddling us with a nearly useless enum type!
    for (Operations i = LT; i < NOperations; i = (Operations)((int)(i) + 1))
    {
        DumpNode(f, nOffset+1, m_apBranches[i]);
        fprintf(f, "\n");    
    }

    fprintf(f, "NULL->\n");
    DumpNode(f, nOffset+1, m_pNullBranch);
}
                               

int CTwoPropNode::SubCompare(CEvalNode* pRawOther)
{
    CTwoPropNode* pOther = 
        (CTwoPropNode*)pRawOther;

    int nCompare;
    nCompare = m_lPropHandle - pOther->m_lPropHandle;
    if(nCompare)
        return nCompare;

    nCompare = m_lRightPropHandle - pOther->m_lRightPropHandle;
    if(nCompare)
        return nCompare;

    nCompare = m_apBranches.GetSize() - pOther->m_apBranches.GetSize();
    if(nCompare)
        return nCompare;

    return TRUE;
}

HRESULT CTwoPropNode::CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes)
{
    // step one, determine whether we can reuse a node
    CTwoPropNode* pNewNode     = NULL;
    CTwoPropNode* pDeleteMe    = NULL;

    if (bDeleteThis && bDeleteArg2)
    {
        pNewNode = this;
        pDeleteMe = (CTwoPropNode*) pArg2;
    }
    else if (bDeleteThis)
        pNewNode = this;
    else if (bDeleteArg2)
        pNewNode = (CTwoPropNode*) pArg2;
    else
        pNewNode = CloneSelfWithoutChildren();


    HRESULT hRes = WBEM_S_NO_ERROR;
    CTwoPropNode* pOther = (CTwoPropNode*)pArg2;

    for (int i = LT; i < NOperations && SUCCEEDED(hRes); i++)
    {
        CEvalNode* pNewChildNode = NULL;
        hRes = CEvalTree::Combine(m_apBranches[i], pOther->m_apBranches[i],
                                  nOp, pNamespace, Implications, bDeleteThis, bDeleteArg2, &pNewChildNode);

        if (bDeleteArg2)
            pOther->m_apBranches.Discard(i);
        if (bDeleteThis)
            m_apBranches.Discard(i);
     
        pNewNode->m_apBranches.Discard(i);
        pNewNode->m_apBranches.SetAt(i, pNewChildNode);
    }

    if(pDeleteMe)
    {
        pDeleteMe->m_pNullBranch = NULL;
        delete pDeleteMe;
    }

    if (SUCCEEDED(hRes))
        *ppRes = pNewNode;
    else
    {
        *ppRes = NULL;
    }

    return hRes;
}

// given a property handle, will retrieve proper property, probably.
CVar* CTwoPropNode::GetPropVariant(_IWmiObject* pObj, long lHandle, CIMTYPE* pct)
{
    CVar *pVar = NULL;
    BSTR bstrName;

    if (SUCCEEDED(pObj->GetPropertyInfoByHandle(lHandle, &bstrName, pct)))
    {
        CSysFreeMe sfm(bstrName);

        //
        // Get it into a VARIANT
        //

        VARIANT v;
        if(FAILED(pObj->Get(bstrName, 0, &v, NULL, NULL)))
            return NULL;

        // Convert it to a CVar

        if (pVar = new CVar)
            pVar->SetVariant(&v);
    }

    return pVar;
}


//    ***************************
//  ****  Two String Prop Node ****
//    ***************************


CEvalNode* CTwoStringPropNode::Clone() const
{
    return (CEvalNode *) new CTwoStringPropNode(*this, true);
}

CTwoPropNode* CTwoStringPropNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoStringPropNode(*this, false);
}

long CTwoStringPropNode::GetSubType()
{
    return EVAL_NODE_TYPE_TWO_STRINGS;
}

HRESULT CTwoStringPropNode::Evaluate(CObjectInfo& ObjInfo, 
                        INTERNAL CEvalNode** ppNext)
{
    HRESULT herslut = WBEM_S_NO_ERROR;

    _IWmiObject* pLeftObj;
    _IWmiObject* pRightObj;

    if(SUCCEEDED(herslut = GetContainerObject(ObjInfo, &pLeftObj))
        &&
       SUCCEEDED(herslut = GetRightContainerObject(ObjInfo, &pRightObj)))
    {
        CCompressedString* pLeftStr;
        CCompressedString* pRightStr;
        
        pLeftStr  = CoreGetPropertyString(pLeftObj, m_lPropHandle);
        pRightStr = CoreGetPropertyString(pRightObj, m_lRightPropHandle); 

        if ((pLeftStr == NULL) || (pRightStr == NULL))
        {
            *ppNext = m_pNullBranch;

            herslut = WBEM_S_NO_ERROR;
        }
        else
        {               
            int nCompare = pLeftStr->CheapCompare(*pRightStr);

            // TODO: check to see if CheapCompare is guaranteed to return -1,0,1
            // if so, then the multiple else if becomes
            // *ppNext = m_apBranches[EQ + nCompare];

            if (nCompare < 0)
                *ppNext = m_apBranches[LT];
            else if (nCompare > 0)
                *ppNext = m_apBranches[GT];
            else 
                *ppNext = m_apBranches[EQ];                     

            herslut = WBEM_S_NO_ERROR;
        }
    }
        
    return herslut;
}

//    *******************************
//  ****  Two Mismatched Prop Node ****
//    *******************************

HRESULT CTwoMismatchedPropNode::Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext)
{
    CVar *pLeftVar  = NULL;
    CVar *pRightVar = NULL;

    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    CIMTYPE ct;

    _IWmiObject* pLeftObj  = NULL;
    _IWmiObject* pRightObj = NULL;

    // if we can get the objects and variants...
    if ((SUCCEEDED(hr = GetContainerObject(ObjInfo, &pLeftObj))
            &&
         SUCCEEDED(hr = GetRightContainerObject(ObjInfo, &pRightObj))) 
            &&
        (pLeftVar  = GetPropVariant(pLeftObj, m_lPropHandle, &ct))
            &&
        (pRightVar = GetPropVariant(pRightObj, m_lRightPropHandle, &ct)) )
    {
        if (pLeftVar->IsDataNull() || pRightVar->IsDataNull())
        {
            *ppNext = m_pNullBranch;
            hr      = WBEM_S_NO_ERROR;
        }
        else 
            hr = Evaluate(pLeftVar, pRightVar, ppNext);                        
    }
    else if (SUCCEEDED(hr))
        // if we got here, it's because one of the GetPropVariant's didn't
        hr = WBEM_E_INVALID_PARAMETER;

    delete pLeftVar;
    delete pRightVar;

    return hr;
}
    
//    **************************************
//  ****  Two Mismatched String Prop Node ****
//    **************************************
    
CEvalNode* CTwoMismatchedStringNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedStringNode(*this, true);
}

CTwoPropNode* CTwoMismatchedStringNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedStringNode(*this, false);
}

// type identification
long CTwoMismatchedStringNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_STRINGS;
}

// string evaluation: promote them all to strings
// and do a lexagraphic compare..
HRESULT CTwoMismatchedStringNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    if (pLeftVar->ChangeTypeTo(VT_BSTR) && pRightVar->ChangeTypeTo(VT_BSTR))    
    {
        int nCompare = wcscmp(pLeftVar->GetLPWSTR(), pRightVar->GetLPWSTR());

        if (nCompare < 0)
            *ppNext = m_apBranches[LT];
        else if (nCompare > 0)
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }
    else 
        hr = WBEM_E_FAILED;

    return hr;
}
    

//    ************************************
//  ****  Two Mismatched UINT Prop Node ****
//    ************************************

CEvalNode* CTwoMismatchedUIntNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedUIntNode(*this, true);
}

CTwoPropNode* CTwoMismatchedUIntNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedUIntNode(*this, false);
}

// type identification
long CTwoMismatchedUIntNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedUIntNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    bool bLeftChanged, bRightChanged;

    bLeftChanged = pLeftVar->ChangeTypeTo(VT_UI4);
    bRightChanged = pRightVar->ChangeTypeTo(VT_UI4);
       
    if (bLeftChanged && bRightChanged)
    {
        if (pLeftVar->GetDWORD() < pRightVar->GetDWORD())
            *ppNext = m_apBranches[LT];
        else if (pLeftVar->GetDWORD() > pRightVar->GetDWORD())
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }
    // attempt to handle signed/unsigned mismatches
    else if (bLeftChanged && 
             pRightVar->ChangeTypeTo(VT_I4) &&
             pRightVar->GetLong() < 0)
    {
        *ppNext = m_apBranches[GT];
        hr = WBEM_S_NO_ERROR;            
    }
    else if (bRightChanged && 
             pLeftVar->ChangeTypeTo(VT_I4) &&
             pLeftVar->GetLong() < 0)
    {
        *ppNext = m_apBranches[LT];
        hr = WBEM_S_NO_ERROR;            
    }

    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}
    

        

//    ***********************************
//  ****  Two Mismatched int Prop Node ****
//    ***********************************
    
CEvalNode* CTwoMismatchedIntNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedIntNode(*this, true);
}

CTwoPropNode* CTwoMismatchedIntNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedIntNode(*this, false);
}

// type identification
long CTwoMismatchedIntNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedIntNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    bool bLeftChanged, bRightChanged;

    bLeftChanged = pLeftVar->ChangeTypeTo(VT_I4);
    bRightChanged = pRightVar->ChangeTypeTo(VT_I4);

    if (bLeftChanged && bRightChanged)
    {
        if (pLeftVar->GetLong() < pRightVar->GetLong())
            *ppNext = m_apBranches[LT];
        else if (pLeftVar->GetLong() > pRightVar->GetLong())
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }
    // attempt to handle signed/unsigned mismatches
    else if (bLeftChanged && 
             pRightVar->ChangeTypeTo(VT_UI4) &&
             pRightVar->GetDWORD() > _I32_MAX)
    {
        *ppNext = m_apBranches[LT];
        hr = WBEM_S_NO_ERROR;            
    }
    else if (bRightChanged && 
             pLeftVar->ChangeTypeTo(VT_UI4) &&
             pLeftVar->GetDWORD() > _I32_MAX)
    {
        *ppNext = m_apBranches[GT];
        hr = WBEM_S_NO_ERROR;            
    }
    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}
    
//    **************************************
//  ****  Two Mismatched int 64 Prop Node ****
//    **************************************
    
CEvalNode* CTwoMismatchedInt64Node::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedInt64Node(*this, true);
}

CTwoPropNode* CTwoMismatchedInt64Node::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedInt64Node(*this, false);
}

// type identification
long CTwoMismatchedInt64Node::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedInt64Node::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    __int64 i64Left, i64Right;
    unsigned __int64 ui64;

    if (pLeftVar->ChangeTypeTo(VT_BSTR) && 
        pRightVar->ChangeTypeTo(VT_BSTR))
    {        
        if ((pLeftVar->GetLPWSTR() == NULL) || (pRightVar->GetLPWSTR() == NULL))
            *ppNext = m_pNullBranch;
        else
        {        
            bool bReadLeft, bReadRight;

            bReadLeft =  ReadI64(pLeftVar->GetLPWSTR(),  i64Left);
            bReadRight = ReadI64(pRightVar->GetLPWSTR(), i64Right);

            if (bReadLeft && bReadRight)
            {
                if (i64Left < i64Right)
                    *ppNext = m_apBranches[LT];
                else if (i64Left > i64Right)
                    *ppNext = m_apBranches[GT];
                else 
                    *ppNext = m_apBranches[EQ];                     
                hr = WBEM_S_NO_ERROR;            
            }
            // try to cover ourselves with signed/unsigned mismatches
            // note that this is a redundant check - if the other side
            // were a unsigned int 64, this node should have been a UInt64 node.
            else if (bReadLeft &&
                     ReadUI64(pRightVar->GetLPWSTR(), ui64)
                     && (ui64 >= _I64_MAX))
            {
                *ppNext = m_apBranches[LT];
                hr = WBEM_S_NO_ERROR;            
            }
            else if (bReadRight &&
                     ReadUI64(pLeftVar->GetLPWSTR(), ui64)
                     && (ui64 >= _I64_MAX))
            {
                *ppNext = m_apBranches[GT];
                hr = WBEM_S_NO_ERROR;            
            }
            else
                hr = WBEM_E_TYPE_MISMATCH;
        } // if ((pLeftVar->GetLPWSTR() == NULL)...
    } // if (pLeftVar->ChangeTypeTo(VT_BSTR) 
    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}

//    ***********************************************
//  ****  Two Mismatched unsigned int 64 Prop Node ****
//    ***********************************************
    
CEvalNode* CTwoMismatchedUInt64Node::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedUInt64Node(*this, true);
}

CTwoPropNode* CTwoMismatchedUInt64Node::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedUInt64Node(*this, false);
}

// type identification
long CTwoMismatchedUInt64Node::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_INTS;
}

HRESULT CTwoMismatchedUInt64Node::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_FAILED; // guilty until proven innocent
    unsigned __int64 i64Left, i64Right;
    __int64 i64;

    if (pLeftVar->ChangeTypeTo(VT_BSTR) && 
        pRightVar->ChangeTypeTo(VT_BSTR))
    {        
        if ((pLeftVar->GetLPWSTR() == NULL) || (pRightVar->GetLPWSTR() == NULL))
            *ppNext = m_pNullBranch;
        else
        {        
            bool bReadLeft, bReadRight;

            bReadLeft =  ReadUI64(pLeftVar->GetLPWSTR(),  i64Left);
            bReadRight = ReadUI64(pRightVar->GetLPWSTR(), i64Right);

            if (bReadLeft && bReadRight)
            {
                if (i64Left < i64Right)
                    *ppNext = m_apBranches[LT];
                else if (i64Left > i64Right)
                    *ppNext = m_apBranches[GT];
                else 
                    *ppNext = m_apBranches[EQ];                     

                hr = WBEM_S_NO_ERROR;            
            }
            // try to cover ourselves with signed/unsigned mismatches
            else if (bReadLeft &&
                     ReadI64(pRightVar->GetLPWSTR(), i64)
                     && (i64 < 0))
            {
                *ppNext = m_apBranches[GT];
                hr = WBEM_S_NO_ERROR;            
            }
            else if (bReadRight &&
                     ReadI64(pLeftVar->GetLPWSTR(), i64)
                     && (i64 < 0))
            {
                *ppNext = m_apBranches[LT];
                hr = WBEM_S_NO_ERROR;            
            }
            else
                hr = WBEM_E_TYPE_MISMATCH;
        }
    }
    else
        hr = WBEM_E_TYPE_MISMATCH;
 
    return hr;
}

    
//    *************************************
//  ****  Two Mismatched Float Prop Node ****
//    *************************************
    
CEvalNode* CTwoMismatchedFloatNode::Clone() const
{
    return (CEvalNode *) new CTwoMismatchedFloatNode(*this, true);
}

CTwoPropNode* CTwoMismatchedFloatNode::CloneSelfWithoutChildren() const
{
    return (CTwoPropNode *) new CTwoMismatchedFloatNode(*this, false);
}

// type identification
long CTwoMismatchedFloatNode::GetSubType()
{
    return EVAL_NODE_TYPE_MISMATCHED_FLOATS; 
}

HRESULT CTwoMismatchedFloatNode::Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext)
{
    HRESULT hr = WBEM_E_TYPE_MISMATCH; // guilty until proven innocent
    if (pLeftVar->ChangeTypeTo(VT_R8) && pRightVar->ChangeTypeTo(VT_R8))    
    {
        if (pLeftVar->GetDouble() < pRightVar->GetDouble())
            *ppNext = m_apBranches[LT];
        else if (pLeftVar->GetDouble() > pRightVar->GetDouble())
            *ppNext = m_apBranches[GT];
        else 
            *ppNext = m_apBranches[EQ];                     

        hr = WBEM_S_NO_ERROR;            
    }

    return hr;
}
    



#pragma warning(default: 4800)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\wbemdnf.cpp ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    WBEMDNF.CPP

Abstract:

    WBEM Evaluation Tree

History:

--*/

#include "precomp.h"
#include <stdio.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>
#include <wbemdnf.h>

HRESULT CDNFExpression::CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken, 
                                        BOOL bNegate, long& lTokensAllowed)
{
    HRESULT hres;

    QL_LEVEL_1_TOKEN& Head = *pLastToken;
    if(Head.nTokenType == QL1_OP_EXPRESSION)
    {
        if(lTokensAllowed <= 0)
            return WBEM_E_QUOTA_VIOLATION;
        else
            lTokensAllowed--;

        if(!CreateFromToken(Head, bNegate))
            return WBEM_E_OUT_OF_MEMORY;

        pLastToken--;
        return WBEM_S_NO_ERROR;
    }

    // Build arguments
    // ===============

    pLastToken--;

    if(Head.nTokenType == QL1_NOT)
    {
        if(lTokensAllowed <= 0)
            return WBEM_E_QUOTA_VIOLATION;
        else
            lTokensAllowed--;

        hres = CreateFromTokens(pLastToken, !bNegate, lTokensAllowed);
        return hres;
    }

    long lChildCount = lTokensAllowed;

    CDNFExpression Arg1;
    hres = Arg1.CreateFromTokens(pLastToken, bNegate, lChildCount);
    if(FAILED(hres))
        return hres;

    CDNFExpression Arg2;
    hres = Arg2.CreateFromTokens(pLastToken, bNegate, lChildCount);
    if(FAILED(hres))
        return hres;

    if( Head.nTokenType == QL1_AND )
    {
        if ( !bNegate )
        {
            hres = CreateAnd( Arg1, Arg2, lTokensAllowed );
        }
        else 
        {
            hres = CreateOr( Arg1, Arg2, lTokensAllowed );
        }
    }
    else
    {
        if ( !bNegate )
        {
            hres = CreateOr( Arg1, Arg2, lTokensAllowed );
        }
        else
        {
            hres = CreateAnd( Arg1, Arg2, lTokensAllowed );
        }
    }

    return hres;
}

HRESULT CDNFExpression::CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2,
                                long& lTokensAllowed)
{
    for(long lFirst = 0; lFirst < Arg1.GetNumTerms(); lFirst++)
    {
        for(long lSecond = 0; lSecond < Arg2.GetNumTerms(); lSecond++)
        {
            CConjunction* pNewTerm = NULL;
            try
            {
                pNewTerm = new CConjunction(*Arg1.GetTermAt(lFirst), 
                                    *Arg2.GetTermAt(lSecond));
            }
            catch(...)
            {
                pNewTerm = NULL;
            }
            if(pNewTerm == NULL)
                return WBEM_E_OUT_OF_MEMORY;

            long lTokens = pNewTerm->GetNumTokens();
            if(lTokens > lTokensAllowed)
            {
                delete pNewTerm;
                return WBEM_E_QUOTA_VIOLATION;
            }
            else
            {
                lTokensAllowed -= lTokens;
            }

            m_apTerms.Add(pNewTerm);
        }
    }

    return S_OK;
}

HRESULT CDNFExpression::CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2,
                                long& lTokensAllowed)
{
    int i;
    for(i = 0; i < Arg1.GetNumTerms(); i++)
    {
        CConjunction* pConj = NULL;
        try
        {
            pConj = new CConjunction(*Arg1.GetTermAt(i));
        }
        catch(...)
        {
            pConj = NULL;
        }
        if(pConj == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        long lTokens = pConj->GetNumTokens();
        if(lTokens > lTokensAllowed)
        {
            delete pConj;
            return WBEM_E_QUOTA_VIOLATION;
        }
        else
        {
            lTokensAllowed -= lTokens;
        }

        m_apTerms.Add(pConj);
    }

    for(i = 0; i < Arg2.GetNumTerms(); i++)
    {
        CConjunction* pConj = NULL;
        try
        {
            pConj = new CConjunction(*Arg2.GetTermAt(i));
        }
        catch(...)
        {
            pConj = NULL;
        }
        if(pConj == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        long lTokens = pConj->GetNumTokens();
        if(lTokens > lTokensAllowed)
        {
            delete pConj;
            return WBEM_E_QUOTA_VIOLATION;
        }
        else
        {
            lTokensAllowed -= lTokens;
        }

        m_apTerms.Add(pConj);
    }

    return S_OK;
}

BOOL CDNFExpression::CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    try
    {
        CConjunction* pConj = new CConjunction(Token, bNegate);
        if(pConj == NULL)
            return FALSE;
        if(m_apTerms.Add(pConj) < 0)
            return FALSE;
    }
    catch(...)
    {
        return FALSE;
    }
    return TRUE;
}


void CDNFExpression::Sort()
{
    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        m_apTerms[i]->Sort();
    }
}

HRESULT CDNFExpression::GetNecessaryProjection(CTokenFilter* pFilter, 
                                    CDNFExpression** ppResult)
{
    *ppResult = NULL;
    CDNFExpression* pResult = new CDNFExpression;
    for(int i = 0; i < m_apTerms.GetSize(); i++)
    {
        CConjunction* pConj = NULL;
        HRESULT hres = m_apTerms[i]->GetNecessaryProjection(pFilter, &pConj);
        if(FAILED(hres))
        {
            delete pResult;
            return hres;
        }

        if(pConj->GetNumTokens() == 0)
        {
            // 
            // This conjunction is empty, meaning that no necessary condition
            // exists for the projection in question.  That means that the 
            // entire projection is empty as well --- no restrictions.
            //

            pResult->m_apTerms.RemoveAll();
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pResult->m_apTerms.Add(pConj);
        }
    }
    
    *ppResult = pResult;
    return WBEM_S_NO_ERROR;
}

CReuseMemoryManager CConjunction::mstatic_Manager(sizeof CConjunction);

void *CConjunction::operator new(size_t nBlock)
{
    return mstatic_Manager.Allocate();
}
void CConjunction::operator delete(void* p)
{
    mstatic_Manager.Free(p);
}

CConjunction::CConjunction()
{
}

CConjunction::CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate)
{
    QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( Token );
    
    if ( NULL == pToken )
    {
        throw CX_MemoryException();
    }

    m_apTokens.Add( pToken );

    if(bNegate)
    {
        m_apTokens[0]->nOperator = NegateOperator(m_apTokens[0]->nOperator);
    }
}

CConjunction::CConjunction(CConjunction& Other)
{
    for(int i = 0; i < Other.GetNumTokens(); i++)
    {
        QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( *Other.GetTokenAt( i ) );

        if ( NULL == pToken )
        {
            throw CX_MemoryException();
        }

        m_apTokens.Add( pToken );
    }
}

CConjunction::CConjunction(CConjunction& Other1, CConjunction& Other2)
{
    int i;
    for(i = 0; i < Other1.GetNumTokens(); i++)
    {
        QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( *Other1.GetTokenAt( i ) );

        if ( NULL == pToken )
        {
            throw CX_MemoryException();
        }

        m_apTokens.Add( pToken );
    }

    for(i = 0; i < Other2.GetNumTokens(); i++)
    {
        QL_LEVEL_1_TOKEN * pToken = new QL_LEVEL_1_TOKEN( *Other2.GetTokenAt( i ) );

        if ( NULL == pToken )
        {
            throw CX_MemoryException();
        }

        m_apTokens.Add( pToken );
    }
}

int CConjunction::NegateOperator(int nOperator)
{
    switch(nOperator)
    {
    case QL1_OPERATOR_EQUALS:
        return QL1_OPERATOR_NOTEQUALS;

    case QL1_OPERATOR_NOTEQUALS:
        return QL1_OPERATOR_EQUALS;

    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATEROREQUALS;

    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATER;

    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESS;

    case QL1_OPERATOR_LIKE:
        return QL1_OPERATOR_UNLIKE;

    case QL1_OPERATOR_UNLIKE:
        return QL1_OPERATOR_LIKE;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_ISNOTA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_INV_ISA;
    }

    return nOperator;
}


#pragma optimize("", off)

void CConjunction::Sort()
{
    int i = 0;

    while(i < m_apTokens.GetSize() - 1)
    {
        int nLeft = m_apTokens[i]->PropertyName.GetNumElements();
        int nRight = m_apTokens[i+1]->PropertyName.GetNumElements();
        if(nLeft > nRight)
        {
            m_apTokens.Swap(i, i+1);
            if(i != 0) 
            {
                i--;
            }
        }
        else 
        {
            i++;
        }
    }
}
#pragma optimize("", on)


// returns an empty conjunction if no necessary condition exists
HRESULT CConjunction::GetNecessaryProjection(CTokenFilter* pFilter, 
                                    CConjunction** ppResult)
{
    *ppResult = NULL;
    CConjunction* pResult = new CConjunction;
    if(pResult == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    for(int i = 0; i < m_apTokens.GetSize(); i++)
    {
        if(pFilter->IsRelevant(m_apTokens[i]))
        {
            if(!pResult->AddToken(m_apTokens[i]))
            {
                delete pResult;
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    *ppResult = pResult;
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\wbemdnf.h ===
/*++

Copyright (C) 1999-2000 Microsoft Corporation

Module Name:

    WBEMDNF.H

Abstract:

    WBEM Evaluation Tree

History:

--*/

#ifndef __WBEM_DNF__H_
#define __WBEM_DNF__H_

#include "esscpol.h"
#include <parmdefs.h>
#include <ql.h>
#include <wbemcomn.h>
#include <sync.h>
#include <newnew.h>

class CTokenFilter
{
 public:
    CTokenFilter(){}
    virtual ~CTokenFilter(){}
    virtual BOOL IsRelevant(QL_LEVEL_1_TOKEN* pToken) = 0;
};

class CConjunction
{
protected:
    CUniquePointerArray<QL_LEVEL_1_TOKEN> m_apTokens;
    static CReuseMemoryManager mstatic_Manager;

public:
    CConjunction();
    CConjunction(QL_LEVEL_1_TOKEN& Token, BOOL bNegate);
    CConjunction(CConjunction& Other);
    CConjunction(CConjunction& Other1, CConjunction& Other2);
    
    long GetNumTokens() {return m_apTokens.GetSize();}
    INTERNAL QL_LEVEL_1_TOKEN* GetTokenAt(int nIndex) 
        {return m_apTokens[nIndex];}
    BOOL AddToken(ACQUIRE QL_LEVEL_1_TOKEN* pNew)
        { return m_apTokens.Add(pNew); }

    void Sort();

    HRESULT GetNecessaryProjection( CTokenFilter* pFilter, 
                                    CConjunction** ppResult);

    static int NegateOperator(int nOperator);
    void *operator new(size_t nBlock);
    void operator delete(void* p);
};

class CDNFExpression
{
protected:
    CUniquePointerArray<CConjunction> m_apTerms;

protected:
    BOOL CreateFromToken(QL_LEVEL_1_TOKEN& Token, BOOL bNegate);
    HRESULT CreateOr(CDNFExpression& Arg1, CDNFExpression& Arg2, 
                        long& lMaxTokens);
    HRESULT CreateAnd(CDNFExpression& Arg1, CDNFExpression& Arg2, 
                    long& lMaxTokens);

public:
    long GetNumTerms() {return m_apTerms.GetSize();}
    INTERNAL CConjunction* GetTermAt(int nIndex) 
        {return m_apTerms[nIndex];}
    void AddTerm(ACQUIRE CConjunction* pNew)
        {m_apTerms.Add(pNew);}

    HRESULT CreateFromTokens(QL_LEVEL_1_TOKEN*& pLastToken, BOOL bNegate,
                            long& lMaxTokens);
            
    void Sort();
            
public:

    HRESULT GetNecessaryProjection(CTokenFilter* pFilter, 
                                    CDNFExpression** ppResult);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\wbemmeta.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemmeta.h>
#pragma warning(disable:4786)
#include <wbemcomn.h>
#include <genutils.h>

HRESULT STDMETHODCALLTYPE CMetaData::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemMetaData)
        *ppv = (void*)(IWbemMetaData*)this;
    else return E_NOINTERFACE;

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CMetaData::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CMetaData::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT CMetaData::GetClass(LPCWSTR wszName, IWbemContext* pContext, 
                            IWbemClassObject** ppClass)
{
    _IWmiObject* pClass = NULL;
    HRESULT hres = GetClass(wszName, pContext, &pClass);
    *ppClass = pClass;
    return hres;
}


CContextMetaData::CContextMetaData(CMetaData* pMeta, IWbemContext* pContext)
    : m_pMeta(pMeta), m_pContext(pContext)
{
    if(m_pMeta)
        m_pMeta->AddRef();
    if(m_pContext)
        m_pContext->AddRef();
}

CContextMetaData::~CContextMetaData()
{
    if(m_pMeta)
        m_pMeta->Release();
    if(m_pContext)
        m_pContext->Release();
}

HRESULT CContextMetaData::GetClass(LPCWSTR wszName, _IWmiObject** ppClass)
{
    _IWmiObject* pObj = NULL;
    HRESULT hres = m_pMeta->GetClass(wszName, m_pContext, &pObj);
    *ppClass = pObj;
    return hres;
}

CStandardMetaData::CStandardMetaData(IWbemServices* pNamespace) 
    : m_pNamespace(pNamespace)
{
    if(m_pNamespace)
        m_pNamespace->AddRef();
}

CStandardMetaData::~CStandardMetaData() 
{
    if(m_pNamespace)
        m_pNamespace->Release();
}

void CStandardMetaData::Clear() 
{
    if(m_pNamespace)
        m_pNamespace->Release();
    m_pNamespace = NULL;
}

HRESULT CStandardMetaData::GetClass(LPCWSTR wszName, IWbemContext* pContext, 
                                        _IWmiObject** ppObj)
{
    BSTR strName = SysAllocString(wszName);
    CSysFreeMe sfm(strName);

    IWbemClassObject* pObj = NULL;
    HRESULT hres = m_pNamespace->GetObject(strName, 0, pContext, &pObj, NULL);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pObj);

    return pObj->QueryInterface(IID__IWmiObject, (void**)ppObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\twopropnode.h ===
/*++

Copyright (C) 1996-1999 Microsoft Corporation

Module Name:

    TWOPROPNODE.H

Abstract:

    Two Prop Node

History:

--*/


// classes to support a two-property node for the eval tree
// this will be much like the CPropertyNode defined in EvalTree.h
// but it will compare a property against another property
// rather than a property to a constant

#ifndef _WBEM_TWOPROPNODE_H_
#define _WBEM_TWOPROPNODE_H_

#include "EvalTree.h"

// virtual base class, good stuff derives from this
class CTwoPropNode : public CPropertyNode
{
public:
    // various methods to create a new thingie.
	CTwoPropNode() : m_lRightPropHandle(-1), m_pRightInfo(NULL)
	{}

    CTwoPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE)
        : CPropertyNode(Other, bChildren), m_lRightPropHandle(Other.m_lRightPropHandle)
	{
	    if (Other.m_pRightInfo)
		    m_pRightInfo = new CEmbeddingInfo(*(Other.m_pRightInfo));
	    else
			m_pRightInfo = NULL;
	}
    virtual CTwoPropNode* CloneSelfWithoutChildren() const =0;

    // evaluate
    virtual int SubCompare(CEvalNode* pNode);


    // integrating and combining into tree structure
    void			SetRightPropertyInfo(LPCWSTR wszRightPropName, long lRightPropHandle);
    virtual int		ComparePrecedence(CBranchingNode* pOther);
    HRESULT         OptimizeSelf(void);
    HRESULT         SetTest(VARIANT& v);

	
	// Right-side embedding info access
	void			SetRightEmbeddingInfo(const CEmbeddingInfo* pInfo);
	HRESULT			GetRightContainerObject(CObjectInfo& ObjInfo, 
								 INTERNAL _IWmiObject** ppInst);
	HRESULT			CompileRightEmbeddingPortion(CContextMetaData* pNamespace, 
								CImplicationList& Implications,
								_IWmiObject** ppResultClass);
    void            SetRightEmbeddedObjPropName(CPropertyName& Name); 
    void            MixInJumpsRightObj(const CEmbeddingInfo* pParent);
    CPropertyName*  GetRightEmbeddedObjPropName(); 

    // any or all embedding info
    HRESULT AdjustCompile(CContextMetaData* pNamespace, 
                          CImplicationList& Implications);

   // debugging
   virtual void Dump(FILE* f, int nOffset);

   // property access
   CVar* GetPropVariant(_IWmiObject* pObj, long lHandle, CIMTYPE* pct);


protected:
	// order is important: must match the way the branches array is constructed
	enum Operations {LT, EQ, GT, NOperations};

	// the right hand property we hold onto,
	// we inherit the left hand prop from CPropertyNode
	// we will assume that we always can write something akin to:
	// Prop < RightProp
	// at merge time, must take a RightProp < Prop
	// and turn it into: Prop >= RightProp
    long m_lRightPropHandle;
    CEmbeddingInfo* m_pRightInfo;

    virtual HRESULT CombineBranchesWith(CBranchingNode* pArg2, int nOp, 
                                        CContextMetaData* pNamespace, 
                                        CImplicationList& Implications,
                                        bool bDeleteThis, bool bDeleteArg2,
                                        CEvalNode** ppRes);

private:

};


template<class TPropType>
class TTwoScalarPropNode : public CTwoPropNode
{
public:
    TTwoScalarPropNode() {}

    TTwoScalarPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;


    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, 
                            INTERNAL CEvalNode** ppNext);

    // type identification
    virtual long GetSubType();

};


class CTwoStringPropNode : public CTwoPropNode
{
public:
    CTwoStringPropNode() {}

    CTwoStringPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();


    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, 
                            INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedPropNode : public CTwoPropNode
{
public:
    CTwoMismatchedPropNode() {}
    CTwoMismatchedPropNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                            CTwoPropNode(Other, bChildren)
                            {}
 
    virtual HRESULT Evaluate(CObjectInfo& ObjInfo, INTERNAL CEvalNode** ppNext);

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext) = 0;
};

class CTwoMismatchedIntNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedIntNode() {}

    CTwoMismatchedIntNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                          CTwoMismatchedPropNode(Other, bChildren)
                          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

// TODO: when COM catches up with us, support INT64's as numeric types
//       right now, we store & m anipulate them as strings
class CTwoMismatchedInt64Node : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedInt64Node() {}

    CTwoMismatchedInt64Node(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                          CTwoMismatchedPropNode(Other, bChildren)
                          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedFloatNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedFloatNode() {}

    CTwoMismatchedFloatNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                            CTwoMismatchedPropNode(Other, bChildren)
                            {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedUIntNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedUIntNode() {}

    CTwoMismatchedUIntNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoMismatchedPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

// TODO: when COM catches up with us, support INT64's as numeric types
//       right now, we store & manipulate them as strings
class CTwoMismatchedUInt64Node : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedUInt64Node() {}

    CTwoMismatchedUInt64Node(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
          CTwoMismatchedPropNode(Other, bChildren)
          {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();

protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

class CTwoMismatchedStringNode : public CTwoMismatchedPropNode
{
public:
    CTwoMismatchedStringNode() {}

    CTwoMismatchedStringNode(const CTwoPropNode& Other, BOOL bChildren = TRUE) :
                             CTwoMismatchedPropNode(Other, bChildren)
                             {}

    virtual CEvalNode* Clone() const;
    virtual CTwoPropNode* CloneSelfWithoutChildren() const;

    // type identification
    virtual long GetSubType();


protected:
    virtual HRESULT Evaluate(CVar *pLeftVar, CVar *pRightVar, INTERNAL CEvalNode** ppNext);
    
};

#include "TwoPropNode.inl"


#endif _WBEM_TWOPROPNODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\wbemmeta.h ===
#ifndef __WBEM_METADATA__H_
#define __WBEM_METADATA__H_

#include "esscpol.h"
#include <parmdefs.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>

class ESSCLI_POLARITY CMetaData : public IWbemMetaData
{
protected:
    long m_lRef;

public:
    CMetaData() : m_lRef(0){}
    virtual ~CMetaData(){}

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    STDMETHOD(GetClass)(LPCWSTR wszName, IWbemContext* pContext, 
                            IWbemClassObject** ppClass);

public:
    virtual HRESULT GetClass(LPCWSTR wszName, IWbemContext* pContext,
                            _IWmiObject** ppClass) = 0;
};

class ESSCLI_POLARITY CStandardMetaData : public CMetaData
{
protected:
    IWbemServices* m_pNamespace;
public:
    CStandardMetaData(IWbemServices* pNamespace);
    ~CStandardMetaData();

    virtual HRESULT GetClass(LPCWSTR wszName, IWbemContext* pContext,
                            _IWmiObject** ppClass);
    void Clear();
};


class ESSCLI_POLARITY CContextMetaData
{
protected:
    CMetaData* m_pMeta;
    IWbemContext* m_pContext;
public:
    CContextMetaData(CMetaData* pMeta, IWbemContext* pContext);
    ~CContextMetaData();

    HRESULT GetClass(LPCWSTR wszName, _IWmiObject** ppClass);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\wmiauthz.h ===
#ifndef __WMIAUTHZ_H__
#define __WMIAUTHZ_H__

#include <wbemint.h>
#include <authz.h>
#include <unk.h>
#include <sync.h>

    
class CWmiAuthzApi;

/**************************************************************************
  CWmiAuthz
***************************************************************************/

class CWmiAuthz : public CUnkBase<IWbemTokenCache, &IID_IWbemTokenCache>
{
    CCritSec m_cs;
    BOOL m_bInit;
    AUTHZ_RESOURCE_MANAGER_HANDLE m_hResMgr;
    CWmiAuthzApi* m_pApi;
    PSID m_pLocalSystemSid, m_pAdministratorsSid;
    
    HRESULT EnsureInitialized();

public:

    CWmiAuthz( CLifeControl* pControl );
    ~CWmiAuthz();

    CWmiAuthzApi* GetApi() { return m_pApi; }

    STDMETHOD(GetToken)( const BYTE* pSid, IWbemToken** ppToken );
    STDMETHOD(Shutdown)();
};

/***************************************************************************
  CWmiAuthzToken
****************************************************************************/

class CWmiAuthzToken : public CUnkBase<IWbemToken, &IID_IWbemToken>
{
    AUTHZ_CLIENT_CONTEXT_HANDLE m_hCtx;
    CWmiAuthz* m_pOwner;

public:
    
    CWmiAuthzToken( CWmiAuthz* pOwner, AUTHZ_CLIENT_CONTEXT_HANDLE hCtx );
    ~CWmiAuthzToken();

    STDMETHOD(AccessCheck)( DWORD dwDesiredAccess, 
                            const BYTE* pSD, 
                            DWORD* pdwGrantedAccess);        
};

/****************************************************************************
  WILL NOT BE COMPILED IN PRESENCE OF AUTHZ LIBRARY
*****************************************************************************/


#ifndef __AUTHZ_H__


/***************************************************************************
  CWmiNoAuthzToken
****************************************************************************/


class CWmiNoAuthzToken : public CUnkBase<IWbemToken, &IID_IWbemToken>
{
    CNtSid m_Sid;

public:

    CWmiNoAuthzToken( PSID pSid ) : m_Sid( pSid ) {}

    STDMETHOD( AccessCheck )( DWORD dwDesiredAccess, 
                              const BYTE* pSD, 
                              DWORD* pdwGrantedAccess );        
};


#endif
 
#endif __WMIAUTHZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\test\authz\authztst.cpp ===
#include <windows.h>
#include <wbemint.h>
#include <stdio.h>
#include <sddl.h>
#include <comutl.h>

void RunTest( PSID pSid, PSECURITY_DESCRIPTOR pSD )
{
    HRESULT hr;

    CWbemPtr<IWbemTokenCache> pFact;

    hr = CoCreateInstance( CLSID_WbemTokenCache,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemTokenCache,
                           (void**)&pFact );

    if ( FAILED(hr) )
    {
        printf( "Failed CoCI of TokenCache. HR=0x%x\n", hr );
        return;
    }

    CWbemPtr<IWbemToken> pToken;
               
    hr = pFact->GetToken( (BYTE*)pSid, &pToken );
  
    if ( FAILED(hr) )
    {
        printf("Failed Getting Authz Token. HR=0x%x\n", hr );
        return;
    }

    DWORD dwGranted;
    hr = pToken->AccessCheck( STANDARD_RIGHTS_EXECUTE, (const BYTE*)pSD, &dwGranted );

    if ( FAILED(hr) )
    {
        printf("Failed Access Check. HR=0x%x\n", hr );
        return;
    }

    if ( dwGranted & STANDARD_RIGHTS_EXECUTE )
    {
        printf("Access Check Succeeded. Permission Granted\n" );
    }
    else
    {
        printf("Access Check Succeeded.  Permission Denied" );
    }
}

extern "C" void __cdecl main( int argc, char** argv )
{
    if ( argc < 3 )
    {
        printf("Usage: authztst AccountName StringSD\n");
        return;
    }

    ULONG cSD;
    PSECURITY_DESCRIPTOR pSD;

    if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
                                                  argv[2], 
                                                  SDDL_REVISION_1, 
                                                  &pSD, 
                                                  &cSD ) )
    {
        printf("Couldn't convert string to SD. res = %d\n", GetLastError() );
        return;
    }

    BYTE achSid[1024];
    char achDomain[256];
    DWORD cSid = 1024, cDomain = 256;
    SID_NAME_USE su;

    if ( !LookupAccountName( NULL,
                             argv[1],
                             achSid,
                             &cSid,
                             achDomain,
                             &cDomain,
                             &su ) )
    {
        printf("Couldn't convert account name to Sid. res = %d\n", 
               GetLastError() );
        return;
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    RunTest( achSid, pSD );

    CoUninitialize();

    LocalFree( pSD );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\evaltest\evaltest.cpp ===
#define COREPROX_POLARITY __declspec( dllimport )

#include <windows.h>
#include <wbemcli.h>
#include <stdio.h>
#include "evaltree.h"

extern "C" int __cdecl wmain( int argc, wchar_t** argv )
{
    CoInitialize( NULL );

    if ( argc < 2 )
    {
        wprintf(L"Usage: %s <querylist...>\n", argv[0] );
        return 0;
    }

    HRESULT hr;
    IWbemServices* pSvc;
    IWbemLocator* pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC,
                           IID_IWbemLocator, (void**)&pLocator );

    assert(SUCCEEDED(hr));

    hr = pLocator->ConnectServer( L"root\\default", NULL, NULL,
                                  NULL, 0, NULL, NULL, &pSvc );

    assert(SUCCEEDED(hr));

    CStandardMetaData Meta( pSvc );
    CContextMetaData CtxMeta( &Meta, NULL );
    CEvalTree Tree;

    hr = Tree.CreateFromQuery( &CtxMeta, argv[1] );

    if ( FAILED(hr) )
    {
        printf("FAILED creating tree on init query.  HR = 0x%x\n", hr );
        return 1;
    }

    for( int i=2; i < argc; i++ )
    {
        CEvalTree Tree2;
        hr = Tree2.CreateFromQuery( &CtxMeta, argv[i] );

        if ( FAILED(hr) )
        {
            printf("FAILED creating tree on %d query.  HR = 0x%x\n", hr, i );
            return 1;
        }

        Tree2.Rebase( i );

        hr = Tree.CombineWith( Tree2, &CtxMeta, EVAL_OP_COMBINE, WBEM_FLAG_MANDATORY_MERGE );

        if ( FAILED(hr) )
        {
            printf("FAILED combining tree on %d query.  HR = 0x%x\n", hr, i );
            return 1;
        }
    }

    printf( "Tree is ... \n" );

    Tree.Dump( stdout );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\wmiauthz.cpp ===
#include "precomp.h"
#include <tchar.h>
#include "wmiauthz.h"



/**************************************************************************
  Win32 Authz prototypes
***************************************************************************/

typedef BOOL (WINAPI*PAuthzAccessCheck)(
    IN DWORD Flags,
    IN AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext,
    IN PAUTHZ_ACCESS_REQUEST pRequest,
    IN AUTHZ_AUDIT_EVENT_HANDLE AuditInfo OPTIONAL,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PSECURITY_DESCRIPTOR *OptionalSecurityDescriptorArray OPTIONAL,
    IN DWORD OptionalSecurityDescriptorCount,
    IN OUT PAUTHZ_ACCESS_REPLY pReply,
    OUT PAUTHZ_ACCESS_CHECK_RESULTS_HANDLE pAuthzHandle OPTIONAL );

typedef BOOL (WINAPI*PAuthzInitializeResourceManager)(
    IN DWORD AuthzFlags,
    IN PFN_AUTHZ_DYNAMIC_ACCESS_CHECK pfnAccessCheck OPTIONAL,
    IN PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN PFN_AUTHZ_FREE_DYNAMIC_GROUPS pfnFreeDynamicGroups OPTIONAL,
    IN PCWSTR szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE pAuthzResourceManager
    );

typedef BOOL (WINAPI*PAuthzInitializeContextFromSid)(
    IN DWORD Flags,
    IN PSID UserSid,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    );

typedef BOOL (WINAPI*PAuthzInitializeContextFromToken)(
    IN HANDLE TokenHandle,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    );

typedef BOOL (WINAPI*PAuthzFreeContext)( AUTHZ_CLIENT_CONTEXT_HANDLE );
typedef BOOL (WINAPI*PAuthzFreeResourceManager)( AUTHZ_RESOURCE_MANAGER_HANDLE );

BOOL WINAPI ComputeDynamicGroups(
                  IN  AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
                  IN  PVOID                       Args,
                  OUT PSID_AND_ATTRIBUTES         *pSidAttrArray,
                  OUT PDWORD                      pSidCount,
                  OUT PSID_AND_ATTRIBUTES         *pRestrictedSidAttrArray,
                  OUT PDWORD                      pRestrictedSidCount
                  )
{
    BOOL bRet;
    *pRestrictedSidAttrArray = NULL;
    *pRestrictedSidCount = 0;

    //
    // if sid is not local system, then don't need to do anything.
    // 

    *pSidAttrArray = NULL;
    *pSidCount = 0;

    if ( !*(BOOL*)(Args) )
    {
        bRet = TRUE;
    }
    else
    {
        //
        // need to add authenticated users and everyone groups.
        // 
    
        PSID_AND_ATTRIBUTES psa = new SID_AND_ATTRIBUTES[2];
    
        if ( psa != NULL )
        {
            ZeroMemory( psa, sizeof(SID_AND_ATTRIBUTES)*2 );

            SID_IDENTIFIER_AUTHORITY wid = SECURITY_WORLD_SID_AUTHORITY;
            SID_IDENTIFIER_AUTHORITY ntid = SECURITY_NT_AUTHORITY;
       
            if ( bRet = AllocateAndInitializeSid( &wid,
                                                  1,
                                                  SECURITY_WORLD_RID,
                                                  0,0,0,0,0,0,0,
                                                  &psa[0].Sid ) )
            {
                if ( bRet = AllocateAndInitializeSid( &ntid,
                                                      1,
                                              SECURITY_AUTHENTICATED_USER_RID,
                                                      0,0,0,0,0,0,0,
                                                      &psa[1].Sid ) )
                {
                    *pSidCount = 2;
                    *pSidAttrArray = psa;
                }
                else
                {
                    FreeSid( &psa[0].Sid );
                    delete psa;
                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                }
            }
            else
            {
                delete psa;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            }
        }
        else
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            bRet = FALSE;
        }
    }

    return bRet;
}
    
void WINAPI FreeDynamicGroups( PSID_AND_ATTRIBUTES psa )
{
    if ( psa != NULL )
    {
        FreeSid( psa[0].Sid );
        FreeSid( psa[1].Sid );
        delete [] psa;
    }
}

/**************************************************************************
  CWmiAuthzApi
***************************************************************************/

#define FUNCMEMBER(FUNC) P ## FUNC m_fp ## FUNC;

class CWmiAuthzApi
{
    HMODULE m_hMod;
    
public:

    FUNCMEMBER(AuthzInitializeContextFromToken)
    FUNCMEMBER(AuthzInitializeContextFromSid)
    FUNCMEMBER(AuthzInitializeResourceManager)
    FUNCMEMBER(AuthzAccessCheck)
    FUNCMEMBER(AuthzFreeContext)
    FUNCMEMBER(AuthzFreeResourceManager)

    CWmiAuthzApi() { ZeroMemory( this, sizeof(CWmiAuthzApi) ); }
    ~CWmiAuthzApi() { if ( m_hMod != NULL ) FreeLibrary( m_hMod ); }
   
    HRESULT Initialize();
};

#define SETFUNC(FUNC) \
    m_fp ## FUNC = (P ## FUNC) GetProcAddress( m_hMod, #FUNC ); \
    if ( m_fp ## FUNC == NULL ) return WBEM_E_NOT_SUPPORTED;  

HRESULT CWmiAuthzApi::Initialize()
{
    m_hMod = LoadLibrary( _T("authz") );

    if ( m_hMod == NULL )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    SETFUNC(AuthzInitializeContextFromToken)
    SETFUNC(AuthzInitializeResourceManager)
    SETFUNC(AuthzInitializeContextFromSid)
    SETFUNC(AuthzInitializeContextFromToken)
    SETFUNC(AuthzAccessCheck)
    SETFUNC(AuthzFreeContext)
    SETFUNC(AuthzFreeResourceManager)

    return WBEM_S_NO_ERROR;
};
    
/**************************************************************************
  CWmiAuthz
***************************************************************************/

#define CALLFUNC(API,FUNC) (*API->m_fp ## FUNC)

CWmiAuthz::CWmiAuthz( CLifeControl* pControl )
: CUnkBase<IWbemTokenCache,&IID_IWbemTokenCache>( pControl ), 
  m_hResMgr(NULL), m_pApi(NULL), m_pAdministratorsSid(NULL), 
  m_pLocalSystemSid(NULL)
{

}

HRESULT CWmiAuthz::EnsureInitialized()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );
        
    if ( m_hResMgr != NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    //
    // try to create the API object. 
    // 
    
    if ( m_pApi == NULL )
    {
        m_pApi = new CWmiAuthzApi;

        if ( m_pApi == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    
        hr = m_pApi->Initialize();
    
        if ( FAILED(hr) )
        {
            delete m_pApi;
            m_pApi = NULL;
            return hr;
        }
    }

    //
    // initialize the authz res mgr.
    //

    if ( !CALLFUNC(m_pApi,AuthzInitializeResourceManager)
            ( AUTHZ_RM_FLAG_NO_AUDIT,
              NULL, 
              ComputeDynamicGroups, 
              FreeDynamicGroups, 
              NULL, 
              &m_hResMgr ) )

    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // allocate and initialize well known sids for authz special casing.
    //

    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
    
    if ( !AllocateAndInitializeSid( &id, 
                                    2,
                                    SECURITY_BUILTIN_DOMAIN_RID, 
                                    DOMAIN_ALIAS_RID_ADMINS,
                                    0,0,0,0,0,0, 
                                    &m_pAdministratorsSid) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( !AllocateAndInitializeSid( &id, 
                                    1,
                                    SECURITY_LOCAL_SYSTEM_RID,
                                    0,0,0,0,0,0,0, 
                                    &m_pLocalSystemSid) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CWmiAuthz::Shutdown()
{
    return WBEM_S_NO_ERROR;
}

CWmiAuthz::~CWmiAuthz()
{
    if ( m_hResMgr != NULL )
    {
        CALLFUNC(m_pApi,AuthzFreeResourceManager)( m_hResMgr );
    }

    if ( m_pApi != NULL )
    {
        delete m_pApi;
    }

    if ( m_pAdministratorsSid != NULL )
    {
        FreeSid( m_pAdministratorsSid );
    }

    if ( m_pLocalSystemSid != NULL )
    {
        FreeSid( m_pLocalSystemSid );
    }
}

STDMETHODIMP CWmiAuthz::GetToken( const BYTE* pSid, IWbemToken** ppToken )
{
    HRESULT hr;

    *ppToken = NULL;

    hr = EnsureInitialized();

    if ( SUCCEEDED( hr ) )
    {
        AUTHZ_CLIENT_CONTEXT_HANDLE hCtx = NULL;
        LUID luid;

        ZeroMemory( &luid, sizeof(LUID) );
        
        DWORD dwFlags = 0;
        BOOL bLocalSystem = FALSE;

        if ( EqualSid( PSID(pSid), m_pAdministratorsSid ) )
        {
            //
            // this is a group sid, so specify this in the flags so 
            // authz can handle it properly.
            // 
            dwFlags = AUTHZ_SKIP_TOKEN_GROUPS;
        }
        else if ( EqualSid( PSID(pSid), m_pLocalSystemSid ) )
        {
            //
            // authz doesn't handle local system so have to workaround 
            // by disabling authz's group computation and do it ourselves.
            // 
            bLocalSystem = TRUE;
            dwFlags = AUTHZ_SKIP_TOKEN_GROUPS;
        }

        if ( !CALLFUNC(m_pApi,AuthzInitializeContextFromSid)( dwFlags,
                                                              PSID(pSid), 
                                                              m_hResMgr,
                                                              NULL,
                                                              luid,
                                                              &bLocalSystem,
                                                              &hCtx ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        *ppToken = new CWmiAuthzToken( this, hCtx );

        if ( *ppToken == NULL )
        {
            CALLFUNC(m_pApi,AuthzFreeContext)(hCtx);
            return WBEM_E_OUT_OF_MEMORY;
        }

        (*ppToken)->AddRef();
    
        return WBEM_S_NO_ERROR;
    }

    return hr;
}

/***************************************************************************
  CWmiAuthzToken
****************************************************************************/

CWmiAuthzToken::CWmiAuthzToken( CWmiAuthz* pOwner, AUTHZ_CLIENT_CONTEXT_HANDLE hCtx )
: CUnkBase<IWbemToken,&IID_IWbemToken>(NULL), m_hCtx(hCtx), m_pOwner(pOwner)
{
    //
    // we want to keep the owner alive, in case the caller has released theirs
    // 
    m_pOwner->AddRef();
}

CWmiAuthzToken::~CWmiAuthzToken()
{
    CWmiAuthzApi* pApi = m_pOwner->GetApi();
    CALLFUNC(pApi,AuthzFreeContext)(m_hCtx);
    m_pOwner->Release();
}

STDMETHODIMP CWmiAuthzToken::AccessCheck( DWORD dwDesiredAccess,
                                          const BYTE* pSD, 
                                          DWORD* pdwGrantedAccess )       
{
    HRESULT hr;

    AUTHZ_ACCESS_REQUEST AccessReq;
    ZeroMemory( &AccessReq, sizeof(AUTHZ_ACCESS_REQUEST) );
    AccessReq.DesiredAccess = dwDesiredAccess;
    
    AUTHZ_ACCESS_REPLY AccessRep;
    DWORD dwError;
 
    ZeroMemory( &AccessRep, sizeof(AUTHZ_ACCESS_REPLY) );
    AccessRep.GrantedAccessMask = pdwGrantedAccess;
    AccessRep.ResultListLength = 1;
    AccessRep.Error = &dwError;
    AccessRep.SaclEvaluationResults = NULL;

    CWmiAuthzApi* pApi = m_pOwner->GetApi();

    if ( !CALLFUNC(pApi,AuthzAccessCheck)( 0,
                                           m_hCtx, 
                                           &AccessReq, 
                                           NULL, 
                                           PSECURITY_DESCRIPTOR(pSD), 
                                           NULL, 
                                           NULL, 
                                           &AccessRep, 
                                           NULL ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return WBEM_S_NO_ERROR;
}


/****************************************************************************
  WILL NOT BE COMPILED IN PRESENCE OF AUTHZ LIBRARY
*****************************************************************************/



#ifndef __AUTHZ_H__

#include <ArrTempl.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmwksta.h>
#include <wbemcomn.h>
#include <comutl.h>


/****************************************************************************
  CWmiNoAuthzToken
*****************************************************************************/

STDMETHODIMP CWmiNoAuthzToken::AccessCheck( DWORD dwDesiredAccess,
                                            const BYTE* pSD, 
                                            DWORD* pdwGrantedAccess )       
{
    PACL pDacl;
    BOOL bDaclPresent, bDaclDefault;
    
    *pdwGrantedAccess = 0;
    
    if ( !GetSecurityDescriptorDacl( PSECURITY_DESCRIPTOR(pSD), 
                                     &bDaclPresent, 
                                     &pDacl, 
                                     &bDaclDefault) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( !bDaclPresent )
    {
        *pdwGrantedAccess = 0xffffffff;
    }
    
    NTSTATUS stat = WmiAuthzGetAccessMask( m_Sid.GetPtr(), pDacl, pdwGrantedAccess );

    if ( stat != 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}




/***************************************************************************
  Functions moved from GroupForUser
****************************************************************************/
// critical section to keep us from tripping over our threads
// during initialization
CCritSec CSSamStartup;
CCritSec CSNetAPIStartup;
CCritSec CSAdvAPIStartup;

// copied here to make it easy for this file to be included elsewhere
bool IsPlatformNT(void)
{
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return false;           // should never happen
    return os.dwPlatformId == VER_PLATFORM_WIN32_NT;
}




class CUnicodeString : public UNICODE_STRING
{
public:
    CUnicodeString()
    {
        MaximumLength = Length = 0;
        Buffer = NULL;
    }
    CUnicodeString(LPCWSTR wsz)
    {
        Buffer = NULL;
        MaximumLength = Length = 0;
        *this = wsz;
    }
    ~CUnicodeString()
    {
        delete [] Buffer;
    }
    void operator=(LPCWSTR wsz)
    {
        delete [] Buffer;
        MaximumLength =  sizeof(WCHAR) * (wcslen(wsz)+1);
        Buffer = new WCHAR[MaximumLength];
        Length = MaximumLength - sizeof(WCHAR);
        wcscpy(Buffer, wsz);
    }
    operator LPCWSTR() {return Buffer;}
};


typedef NTSTATUS (NTAPI *PSamConnect)(IN PUNICODE_STRING ServerName,
    OUT PSAM_HANDLE ServerHandle, IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes);

typedef NTSTATUS (NTAPI *PSamCloseHandle)(    OUT SAM_HANDLE SamHandle    );
typedef NTSTATUS (NTAPI *PSamFreeMemory)(    PVOID p    );
typedef NTSTATUS (NTAPI *PSamLookupDomainInSamServer)(
    IN SAM_HANDLE ServerHandle,
    IN PUNICODE_STRING Name,    OUT PSID * DomainId    );

typedef NTSTATUS (NTAPI *PSamLookupNamesInDomain)(    
    IN SAM_HANDLE DomainHandle,    IN ULONG Count,
    IN PUNICODE_STRING Names,    OUT PULONG *RelativeIds,
    OUT PSID_NAME_USE *Use);

typedef NTSTATUS (NTAPI *PSamOpenDomain)(    IN SAM_HANDLE ServerHandle,    
    IN ACCESS_MASK DesiredAccess,
    IN PSID DomainId,    OUT PSAM_HANDLE DomainHandle    );

typedef NTSTATUS (NTAPI *PSamOpenUser)(    IN SAM_HANDLE DomainHandle,    
    IN ACCESS_MASK DesiredAccess,
    IN ULONG UserId,    OUT PSAM_HANDLE UserHandle    );

typedef NTSTATUS (NTAPI *PSamGetGroupsForUser)(    IN SAM_HANDLE UserHandle,
    OUT PGROUP_MEMBERSHIP * Groups,    OUT PULONG MembershipCount);

typedef NTSTATUS (NTAPI *PSamGetAliasMembership)(    IN SAM_HANDLE DomainHandle,    IN ULONG PassedCount,
    IN PSID *Sids,    OUT PULONG MembershipCount,    OUT PULONG *Aliases);


// class to encapsulate the SAM APIs
// make sure that we always free the lib, etc.
class CSamRun
{
public:
    CSamRun()
    {
    }
    
    
    ~CSamRun()
    {
        // oh, all right - DON'T free the lib.
        // FreeLibrary(m_hSamDll);
    }

    bool RunSamRun(void);

//protected:
// okay, so I should make these all protected
// and write accessor functions.  Maybe I will someday.
    static HINSTANCE m_hSamDll;
    static PSamConnect m_pfnSamConnect;
    static PSamCloseHandle m_pfnSamCloseHandle;
    static PSamFreeMemory m_pfnSamFreeMemory;
    static PSamLookupDomainInSamServer m_pfnSamLookupDomainInSamServer;
    static PSamLookupNamesInDomain m_pfnSamLookupNamesInDomain;
    static PSamOpenDomain m_pfnSamOpenDomain;
    static PSamOpenUser m_pfnSamOpenUser;
    static PSamGetGroupsForUser m_pfnSamGetGroupsForUser;
    static PSamGetAliasMembership m_pfnSamGetAliasMembership;
};

HINSTANCE CSamRun::m_hSamDll = NULL;
PSamConnect CSamRun::m_pfnSamConnect = NULL;
PSamCloseHandle CSamRun::m_pfnSamCloseHandle = NULL;
PSamFreeMemory CSamRun::m_pfnSamFreeMemory = NULL;
PSamLookupDomainInSamServer CSamRun::m_pfnSamLookupDomainInSamServer = NULL;
PSamLookupNamesInDomain CSamRun::m_pfnSamLookupNamesInDomain = NULL;
PSamOpenDomain CSamRun::m_pfnSamOpenDomain = NULL;
PSamOpenUser CSamRun::m_pfnSamOpenUser = NULL;
PSamGetGroupsForUser CSamRun::m_pfnSamGetGroupsForUser = NULL;
PSamGetAliasMembership CSamRun::m_pfnSamGetAliasMembership = NULL;


bool CSamRun::RunSamRun()
{
    CInCritSec runInACriticalSectionSam(&CSSamStartup);

    if(m_hSamDll)
        return true;

    m_hSamDll = LoadLibrary(_T("samlib.dll"));
    if(m_hSamDll == NULL)
        return false;

    m_pfnSamConnect = 
        (PSamConnect)GetProcAddress(m_hSamDll, "SamConnect");
    if(m_pfnSamConnect == NULL)
        return false;

    m_pfnSamCloseHandle = 
        (PSamCloseHandle)GetProcAddress(m_hSamDll, "SamCloseHandle");
    if(m_pfnSamCloseHandle == NULL)
        return false;

    m_pfnSamFreeMemory = 
        (PSamFreeMemory)GetProcAddress(m_hSamDll, "SamFreeMemory");
    if(m_pfnSamFreeMemory == NULL)
        return false;

    m_pfnSamLookupDomainInSamServer = 
        (PSamLookupDomainInSamServer)GetProcAddress(m_hSamDll, 
                                    "SamLookupDomainInSamServer");
    if(m_pfnSamLookupDomainInSamServer == NULL)
        return false;

    m_pfnSamLookupNamesInDomain = 
        (PSamLookupNamesInDomain)GetProcAddress(m_hSamDll, 
                                    "SamLookupNamesInDomain");
    if(m_pfnSamLookupNamesInDomain == NULL)
        return false;

    m_pfnSamOpenDomain = 
        (PSamOpenDomain)GetProcAddress(m_hSamDll, 
                                    "SamOpenDomain");
    if(m_pfnSamOpenDomain == NULL)
        return false;

    m_pfnSamOpenUser = 
        (PSamOpenUser)GetProcAddress(m_hSamDll, 
                                    "SamOpenUser");
    if(m_pfnSamOpenUser == NULL)
        return false;

    m_pfnSamGetGroupsForUser = 
        (PSamGetGroupsForUser)GetProcAddress(m_hSamDll, 
                                    "SamGetGroupsForUser");
    if(m_pfnSamGetGroupsForUser == NULL)
        return false;

    m_pfnSamGetAliasMembership = 
        (PSamGetAliasMembership)GetProcAddress(m_hSamDll, 
                                    "SamGetAliasMembership");
    if(m_pfnSamGetAliasMembership == NULL)
        return false;

    return true;
}

typedef BOOL (NTAPI* PLookupAccountSidW) (
  LPCWSTR lpSystemName,  // name of local or remote computer
  PSID Sid,              // security identifier
  LPWSTR Name,           // account name buffer
  LPDWORD cbName,        // size of account name buffer
  LPWSTR DomainName,     // domain name
  LPDWORD cbDomainName,  // size of domain name buffer
  PSID_NAME_USE peUse    // SID type
);

typedef NET_API_STATUS (NTAPI* PNetGetAnyDCName)(
  LPCWSTR servername,  
  LPCWSTR domainname,  
  LPBYTE *bufptr       
);

typedef NET_API_STATUS (NTAPI* PNetGetDCName)(
  LPCWSTR servername,  
  LPCWSTR domainname,  
  LPBYTE *bufptr       
);


typedef NET_API_STATUS (NTAPI* PNetApiBufferFree)(
  LPVOID Buffer  
);

typedef NET_API_STATUS (NTAPI* PNetWkstaGetInfo)(
  LPWSTR servername,  
  DWORD level,        
  LPBYTE *bufptr      
);




// dynamically load NetAPI32.DLL
// so we can run without it on 9X
class NetApiDLL
{
public:
    bool Init(void);

    static PNetGetAnyDCName   m_pfnNetGetAnyDCName;
    static PNetGetAnyDCName   m_pfnNetGetDCName;
    static PNetApiBufferFree  m_pfnNetApiBufferFree;
    static PNetWkstaGetInfo   m_pfnNetWkstaGetInfo;
    
    static HINSTANCE m_hDll;

};

PNetGetAnyDCName   NetApiDLL::m_pfnNetGetAnyDCName = NULL;    
PNetGetDCName      NetApiDLL::m_pfnNetGetDCName = NULL;    
PNetApiBufferFree  NetApiDLL::m_pfnNetApiBufferFree = NULL;
PNetWkstaGetInfo   NetApiDLL::m_pfnNetWkstaGetInfo = NULL;
HINSTANCE          NetApiDLL::m_hDll = NULL;                        

bool NetApiDLL::Init(void)
{
    CInCritSec inCS(&CSNetAPIStartup);

    bool bRet = false;

    if (m_hDll)
        bRet = true;
    else if (m_hDll = LoadLibrary(_T("NetAPI32.dll")))
    {
        m_pfnNetGetAnyDCName   = (PNetGetAnyDCName)   GetProcAddress(m_hDll, "NetGetAnyDCName");
        m_pfnNetGetDCName      = (PNetGetDCName)      GetProcAddress(m_hDll, "NetGetDCName");
        m_pfnNetApiBufferFree  = (PNetApiBufferFree)  GetProcAddress(m_hDll, "NetApiBufferFree");
        m_pfnNetWkstaGetInfo   = (PNetWkstaGetInfo)   GetProcAddress(m_hDll, "NetWkstaGetInfo");
        
        bRet = ((m_pfnNetGetAnyDCName   != NULL) &&
                (m_pfnNetGetDCName      != NULL) &&
                (m_pfnNetApiBufferFree  != NULL) &&
                (m_pfnNetWkstaGetInfo   != NULL));

        if (!bRet)
        {
            FreeLibrary(m_hDll);
            m_hDll = NULL;
        }
    }
    else
        ERRORTRACE((LOG_ESS, "Failed to load NetAPI32.dll, 0x%X", GetLastError()));
       

    return bRet;
}

// dynamically load AdvAPI32.DLL
// so we can run without it on 9X
class AdvApiDLL
{
public:
    bool Init(void);

    static PLookupAccountSidW m_pfnLookupAccountSidW;
    
    static HINSTANCE m_hDll;

};

PLookupAccountSidW AdvApiDLL::m_pfnLookupAccountSidW = NULL;
HINSTANCE          AdvApiDLL::m_hDll = NULL;

bool AdvApiDLL::Init(void)
{
    CInCritSec inCS(&CSAdvAPIStartup);

    bool bRet = false;

    if (m_hDll)
        bRet = true;
    else if (m_hDll = LoadLibrary(_T("AdvAPI32.dll")))
    {
        m_pfnLookupAccountSidW = (PLookupAccountSidW) GetProcAddress(m_hDll, "LookupAccountSidW");
        
        bRet = (m_pfnLookupAccountSidW != NULL);
    }
    else
        ERRORTRACE((LOG_ESS, "Failed to load AdvAPI32.dll, 0x%X", GetLastError()));


    return bRet;
}


class CSamHandle
{
private:
    SAM_HANDLE m_hHandle;
    CSamRun& m_sam;

protected:
    void Close();
public:
    CSamHandle(CSamRun& sam) : m_sam(sam), m_hHandle(NULL)
    { }

    ~CSamHandle();

    // same as operator SAM_HANDLE*()
    // gosh, I sure do love C!
    operator void**()
    {return &((void*)m_hHandle); }

    operator SAM_HANDLE()
    {return m_hHandle; }

};

CSamHandle::~CSamHandle()
{
    Close();
}

void CSamHandle::Close()
{
    if (m_hHandle)
        m_sam.m_pfnSamCloseHandle(m_hHandle);

    m_hHandle = NULL;
}


class CSamFreeMe
{
protected:
    void* m_p;
    CSamRun m_sam;
public:
    CSamFreeMe(CSamRun& sam, void* p) : m_p(p), m_sam(sam) {}
    ~CSamFreeMe() {m_sam.m_pfnSamFreeMemory(m_p);}
};



class CHeapFreeMe
{
protected:
    void* m_p;
public:
    CHeapFreeMe(void* p) : m_p(p){}
    ~CHeapFreeMe() 
    {   
        if (m_p)
            HeapFree(GetProcessHeap(), 0, m_p);
    }
};


PSID CreateUserSid(PSID pDomainSid, DWORD dwUserRid)
{
    DWORD dwOldLen = GetLengthSid(pDomainSid);
    // PISID pSid = (PISID)new BYTE[dwOldLen + sizeof(DWORD)];
    
    PISID pSid = (PISID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwOldLen + sizeof(DWORD));

    if (pSid)
    {
        memcpy(pSid, pDomainSid, dwOldLen);
        pSid->SubAuthority[pSid->SubAuthorityCount] = dwUserRid;
        pSid->SubAuthorityCount++;
    }
    return pSid;
}



class CHeapBigPointerArrayCleanerUpper
{
public:
    CHeapBigPointerArrayCleanerUpper(void** pArray = NULL, DWORD count = 0) :
      m_pArray(pArray),  m_count(count) {}

    ~CHeapBigPointerArrayCleanerUpper()
    {
        if (m_pArray)
            for (DWORD i = 0; i < m_count; i++)
                if (m_pArray[i])
                    HeapFree(GetProcessHeap(), 0, m_pArray[i]);
    }

protected:
    void** m_pArray;
    DWORD  m_count;
};



// returns STATUS_SUCCESS if user is in group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
NTSTATUS IsUserInGroup(PSID pSidUser, PSID pSidGroup)
{
    if (!IsPlatformNT())
        return STATUS_NOT_SUPPORTED;

    PSID* pSids = NULL;
    DWORD dwCount;

    NTSTATUS stat = EnumGroupsForUser(pSidUser, NULL, &pSids, &dwCount);

    // if we can't get to the domain controller, try just local groups
    if (stat)
    {
        WCHAR machineName[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD size = MAX_COMPUTERNAME_LENGTH +1;
        GetComputerNameW(machineName, &size);
        stat =  EnumGroupsForUser(pSidUser, machineName, &pSids, &dwCount);
    }

    // arrange for clean up no matter how we exit
    CHeapFreeMe freeArray(pSids);
    CHeapBigPointerArrayCleanerUpper cleanSids(pSids, dwCount);

    if (stat == STATUS_SUCCESS)
    {
        stat = STATUS_ACCESS_DENIED;
        for(DWORD i = 0; i < dwCount; i++) 
            if (EqualSid(pSidGroup, pSids[i])) 
                stat = STATUS_SUCCESS;
    }

    return stat;
}


// returns STATUS_SUCCESS if user is in admin group
// STATUS_ACCESS_DENIED if not
// some error code or other on error
NTSTATUS IsUserAdministrator(PSID pSidUser)
{
    if (!IsPlatformNT())
        return STATUS_NOT_SUPPORTED;
    
    NTSTATUS stat = STATUS_ACCESS_DENIED;

    PSID pSidAdmins;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_NT_AUTHORITY;
 
    if  (AllocateAndInitializeSid(&id, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0,0,0,0,0,0,&pSidAdmins))
    {
        stat = WmiAuthzIsUserInGroup(pSidUser, pSidAdmins);

        // We're done with this
        FreeSid(pSidAdmins);
    }
    else
    {
        stat = GetLastError();
        ERRORTRACE((LOG_ESS, "AllocateAndInitializeSid failed, error 0x%X\n", stat));
   }

    return stat;
}


// retireves access mask corresponding to permissions granted
// by dacl to account denoted in pSid
// only deals with the ACCESS_ALLOWED/DENIED type aces 
// including the ACCESS_ALLOWED/DENIED_OBJECT_ACEs
// - will error out if it finds a SYSTEM_AUDIT or unrecognized type.
NTSTATUS GetAccessMask(PSID pSid, PACL pDacl, DWORD* pAccessMask)
{
     if (!IsPlatformNT())
        return STATUS_NOT_SUPPORTED;

     NTSTATUS stat = STATUS_SUCCESS;

    // let's zero this puppy out
    // lest someone not check the return code & compare against garbage
    *pAccessMask = 0;

    // will compute each & knock them against each other
    DWORD accessAllowed = 0;
    DWORD accessDenied   = 0;
    PSID* pSids = NULL;
    DWORD dwCount;
    LPVOID pAce;

    stat = EnumGroupsForUser(pSid, NULL, &pSids, &dwCount);

    // arrange for clean up no matter how we exit
    CHeapFreeMe freeArray(pSids);
    CHeapBigPointerArrayCleanerUpper cleanSids(pSids, dwCount);

    // de buggy test harness
    // char name[300];
    // char domain[300];
    // DWORD x = 300, y = 300;
    // SID_NAME_USE eUse;

    //for (int q = 0; q < dwCount; q++)
    //{
    //   x = y = 300;
    //   LookupAccountSid(NULL, pSids[q], name, &x, domain, &y, &eUse);
    //}

    if (stat == STATUS_SUCCESS)
        // iterate through all of the ACE's in the ACL
        // for each, iterate through all of the groups for the user
        // if one matches, OR in its allowed/disallowed mask
        for (DWORD nAce = 0; nAce < pDacl->AceCount; nAce++)
            if (GetAce(pDacl, nAce, &pAce))
            {
                // de buggy test harness
                // x = y = 300;
                // LookupAccountSid(NULL, &(((ACCESS_ALLOWED_ACE*)pAce)->SidStart), name, &x, domain, &y, &eUse);
                for (DWORD nSid = 0; nSid < dwCount; nSid++)
                {
                    // de buggy test harness
                    // x = y = 300;
                    // if (!LookupAccountSid(NULL, pSids[nSid], name, &x, domain, &y, &eUse))
                    //     DWORD gubl = GetLastError();
                    switch (((ACE_HEADER*)pAce)->AceType)
                    {
                        case ACCESS_ALLOWED_ACE_TYPE:
                            if (EqualSid(&(((ACCESS_ALLOWED_ACE*)pAce)->SidStart), pSids[nSid]))
                                accessAllowed |= ((ACCESS_ALLOWED_ACE*)pAce)->Mask;
                            break;
                        case ACCESS_DENIED_ACE_TYPE: 
                            if (EqualSid(&(((ACCESS_DENIED_ACE*)pAce)->SidStart), pSids[nSid]))
                                accessDenied |= ((ACCESS_DENIED_ACE*)pAce)->Mask;
                            break;
                        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                            if (EqualSid(&(((ACCESS_ALLOWED_OBJECT_ACE*)pAce)->SidStart), pSids[nSid]))
                                accessAllowed |= ((ACCESS_ALLOWED_OBJECT_ACE*)pAce)->Mask;
                            break;
                        case ACCESS_DENIED_OBJECT_ACE_TYPE:
                            if (EqualSid(&(((ACCESS_DENIED_OBJECT_ACE*)pAce)->SidStart), pSids[nSid]))
                                accessDenied |= ((ACCESS_DENIED_OBJECT_ACE*)pAce)->Mask;
                            break;
                        default:
                            // in too deep - bail!
                            return STATUS_INVALID_PARAMETER;
                    }
                }
            }
            else
            {
                // GetAce failed

                DWORD dwErr = GetLastError();
                ERRORTRACE((LOG_ESS, "GetAce failed, error 0x%X", dwErr));
                return dwErr;
            }
                    
    if (stat == STATUS_SUCCESS)
        *pAccessMask = accessAllowed & ~accessDenied;

    return stat;
}




// given a SID & server name
// will return all groups from the local domain of which user is a member
// callers responsibility to HeapFree apSids & the memory to which they point.
// pdwCount points to dword to receive count of group sids returned.
// serverName may be NULL, in which case this function will look up 
// the sid on the local computer
NTSTATUS EnumGroupsForUser(PSID pSid, LPCWSTR serverName, PSID** apGroupSids, DWORD* pdwCount) 
{
    if (!IsPlatformNT())
        return STATUS_NOT_SUPPORTED;

    NTSTATUS status = STATUS_SUCCESS;
    NetApiDLL netDll;
    AdvApiDLL advDll;

    if (!(netDll.Init() && advDll.Init()))     
        status = STATUS_DLL_INIT_FAILED;
    else
    {
        // retrieve user name & domain name
        DWORD domainSize = 0, 
              nameSize   = 0;
        SID_NAME_USE sidUse;

        // call once to find out how big a buffer we need
        advDll.m_pfnLookupAccountSidW(serverName, pSid, NULL, &nameSize, NULL, &domainSize, &sidUse);

        // buy bunches o' bigger buffers
        LPWSTR pAccountName = NULL,
               pDomainName  = NULL;

        pAccountName = new WCHAR[nameSize];
        pDomainName  = new WCHAR[domainSize];

        CDeleteMe<WCHAR> delAcct(pAccountName);
        CDeleteMe<WCHAR> delDomain(pDomainName);

        if (pAccountName && pDomainName)
        {
            if (advDll.m_pfnLookupAccountSidW(serverName, pSid, 
                                              pAccountName, &nameSize, 
                                              pDomainName, &domainSize,
                                              &sidUse))
            {            
                WKSTA_INFO_100 *pstInfo = NULL ;
                        
                LPWSTR samServerName;
                // may not get filled in, careful...
                WCHAR serverNameBuffer[MAX_COMPUTERNAME_LENGTH +1] = L"\0";

                if (serverName == NULL)
                {              
                    DWORD dNameSize = MAX_COMPUTERNAME_LENGTH +1;    
                    WCHAR computerName[MAX_COMPUTERNAME_LENGTH +1] = L"\0";
                    GetComputerNameW(computerName, &dNameSize);
                    if (_wcsicmp(computerName, pDomainName) == 0)
                    // local domain is the machine
                        samServerName = pDomainName;
                    else
                    // go grab the Domain Controller
                    {
                        //  use the local domain!
                        status = netDll.m_pfnNetWkstaGetInfo( NULL , 100 , ( LPBYTE * ) &pstInfo );                                                               

                        if (status == 0)
                        {
                            LPBYTE dcName = NULL;
                            status = netDll.m_pfnNetGetDCName(NULL, pstInfo->wki100_langroup, &dcName);                            
                            // if we can't find a/the PDC, try for a backup...
                            // if ((status == 0x54B) || (status == 0x995))
                            if (status)
                                status = netDll.m_pfnNetGetAnyDCName(NULL, pstInfo->wki100_langroup, &dcName);
                            netDll.m_pfnNetApiBufferFree(pstInfo);

                            if (status == 0)
                            {
                                LPWSTR dcNameWithoutWhacks = (LPWSTR)dcName;
                                // name is prefaced with "\\"
                                dcNameWithoutWhacks += 2;
                                wcscpy(serverNameBuffer, dcNameWithoutWhacks);
                                samServerName = serverNameBuffer;
								netDll.m_pfnNetApiBufferFree(dcName);
                            }
                        }
                    }
                }
                else 
                    // tweren't NULL - we'll use it
                    samServerName = (LPWSTR)serverName;

                if (status == 0)
                    status = EnumGroupsForUser(pAccountName, pDomainName, samServerName, apGroupSids, pdwCount);                    
            }
            else
            {
                // lookup account sid failed - dunno why.
                status = GetLastError();
                ERRORTRACE((LOG_ESS, "LookupAccountSid failed: 0x%X\n", status));
           }
        }
        else
        {
            ERRORTRACE((LOG_ESS, "Allocation Failure\n"));
            // couldn't allocate name buffers
            status = STATUS_NO_MEMORY;
        }
    } // if netDll.Init

    return status;
}


// given user name, domain name & server name
// will return all groups of which user is a member
// callers responsibility to HeapFree apSids & the memory to which they point.
// pdwCount points to dword to receive count of group sids returned.
NTSTATUS EnumGroupsForUser(LPCWSTR userName, LPCWSTR domainName, LPCWSTR serverName, PSID** apGroupSids, DWORD* pdwCount) 
{
    if (!IsPlatformNT())
        return STATUS_NOT_SUPPORTED;
    
    CSamRun sam;
    
    if (!sam.RunSamRun())
        return STATUS_DLL_INIT_FAILED;
    else
    {   
        // will reuse this puppy without remorse. 
        CUnicodeString buffer;
    
        NTSTATUS ntst = STATUS_SUCCESS;
        
        // get local handles
        CSamHandle hLocalSam(sam);
        ntst = sam.m_pfnSamConnect(NULL, (void**)hLocalSam, 
                    SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                                NULL);
        if(ntst)
        {
            ERRORTRACE((LOG_ESS, "SamConnect Failed, error 0x%X\n", ntst));
            return ntst;
        }

        PSID pBuiltinDomainId = NULL;
        buffer = L"BUILTIN";
        ntst = sam.m_pfnSamLookupDomainInSamServer(hLocalSam, &buffer, &pBuiltinDomainId);
        if(ntst)
        {
            ERRORTRACE((LOG_ESS, "SamLookupDomainInSamServer Failed on BUILTIN domain, error 0x%X\n", ntst));
            return ntst;
        }
        CSamFreeMe freeBuiltinDomain(sam, pBuiltinDomainId);

        CSamHandle hBuiltinDomain(sam);
        ntst = sam.m_pfnSamOpenDomain(hLocalSam, 
                        DOMAIN_GET_ALIAS_MEMBERSHIP | DOMAIN_LOOKUP,
                        pBuiltinDomainId, (void**)hBuiltinDomain);
        if(ntst)
        {
            ERRORTRACE((LOG_ESS, "SamOpenDomain Failed on BUILTIN domain, error 0x%X\n", ntst));
            return ntst;
        }

        // make an 'everyone' sid
        PSID pSidEveryoneHeapAlloc = NULL;
        PSID pSidEveryone = NULL;
        SID_IDENTIFIER_AUTHORITY sa = SECURITY_WORLD_SID_AUTHORITY;
        if (AllocateAndInitializeSid(&sa, 1, SECURITY_WORLD_RID, 0,0,0,0,0,0,0, &pSidEveryone))
        {            
            DWORD len = GetLengthSid(pSidEveryone);
        
            pSidEveryoneHeapAlloc = (PISID)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, len);            
        
            if (!pSidEveryoneHeapAlloc)
            {
                FreeSid(pSidEveryone);
                return WBEM_E_OUT_OF_MEMORY;
            }

            memcpy(pSidEveryoneHeapAlloc, pSidEveryone, len);

            FreeSid(pSidEveryone);
            pSidEveryone = NULL;
        }
        else
        {
            ntst = GetLastError();
            ERRORTRACE((LOG_ESS, "AllocateAndInitializeSid failed, error 0x%X\n", ntst));
            return ntst;
        }

        CSamHandle hSam(sam);

        // connect & determine global groups
        buffer = serverName;
        ntst = sam.m_pfnSamConnect(&buffer, (void **)hSam, 
                        SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                        NULL);
        if (ntst)
        {
            ERRORTRACE((LOG_ESS, "SamConnect Failed on %S, error 0x%X\n", serverName, ntst));
            return ntst;
        }

        DWORD dwMembershipCount;
        DWORD dwUserId;

        PSID* apSids;

        PSID pDomainId = NULL;
        buffer = domainName;
        ntst = sam.m_pfnSamLookupDomainInSamServer((SAM_HANDLE)hSam, &buffer, &pDomainId);

        if ( ntst == 0 )
        {
            CSamFreeMe freeDomain(sam, pDomainId);                
            CSamHandle hDomain(sam);
            
            ntst = sam.m_pfnSamOpenDomain((SAM_HANDLE)hSam, 
                        DOMAIN_GET_ALIAS_MEMBERSHIP | DOMAIN_LOOKUP,
                        pDomainId, (void**)hDomain);
            
            if(ntst)
                return ntst;
            
            CSamHandle hUser(sam);
        
            buffer = userName;
            ULONG* pdwUserId = NULL;
            SID_NAME_USE* psnu = NULL; 
            
            ntst = sam.m_pfnSamLookupNamesInDomain(hDomain, 1, &buffer, &pdwUserId, &psnu);
            
            if(ntst)
            {
                ERRORTRACE((LOG_ESS, "SamLookupNamesInDomain Failed on %S, error 0x%X\n", userName, ntst));
            
                return ntst;
            }


            CSamFreeMe freeSnu(sam, psnu);
    
            dwUserId = *pdwUserId;
            sam.m_pfnSamFreeMemory(pdwUserId);

            ntst = sam.m_pfnSamOpenUser(hDomain, USER_LIST_GROUPS, dwUserId, (void**)hUser);
            if(ntst)
                return ntst;

            GROUP_MEMBERSHIP* aMemberships = NULL;
            ntst = sam.m_pfnSamGetGroupsForUser(hUser, &aMemberships, &dwMembershipCount);
            if(ntst)
                return ntst;
            CSamFreeMe freeMembers(sam, aMemberships);    

            // got everything we need for the first bunch...
            apSids = (PSID*) HeapAlloc(GetProcessHeap(),  HEAP_ZERO_MEMORY, sizeof(PSID) * (dwMembershipCount +2));
            
            if (apSids)
            {
                PSID pSid = CreateUserSid(pDomainId, dwUserId);
                if (!pSid)
                    return STATUS_NO_MEMORY;

                apSids[0] = pSid;
                apSids[1] = pSidEveryoneHeapAlloc;
                for(DWORD i = 0; i < dwMembershipCount; i++)
                {
                    pSid = CreateUserSid(pDomainId, aMemberships[i].RelativeId);    
                    if (pSid)
                        apSids[i+2] = pSid; 
                    else
                    {
                        CHeapBigPointerArrayCleanerUpper cleanSids(apSids, dwMembershipCount +1);
                        return STATUS_NO_MEMORY;                
                    }
                }
            }
            else 
                return STATUS_NO_MEMORY;
        }
        else
        {
            apSids = (PSID*) HeapAlloc( GetProcessHeap(),  
                                        HEAP_ZERO_MEMORY, 
                                        sizeof(PSID) * 2 );
            if (!apSids)
            {
                return STATUS_NO_MEMORY;
            }

            WCHAR wszDomain[256];
            DWORD cDomain = 256;
            SID_NAME_USE psnu; 

            DWORD cSid = 256;
            apSids[0] = (PSID)HeapAlloc( GetProcessHeap(), 
                                         HEAP_ZERO_MEMORY, 
                                         cSid );             
            if ( apSids[0] == NULL )
            {
                return STATUS_NO_MEMORY;
            }

            //
            // have to join the domain name and user name strings. This is 
            // to qualify the name passed to LookupAccountName, but it also 
            // provides a significant performance improvement in the call.
            //

            WCHAR wszFullName[512];
            int cDomainName = wcslen(domainName);
            wcscpy(wszFullName,domainName);
            wszFullName[cDomainName] = '\\';
            wcscpy(wszFullName+cDomainName+1, userName);

            if ( !LookupAccountNameW( NULL, 
                                      wszFullName, 
                                      apSids[0], 
                                      &cSid,
                                      wszDomain, 
                                      &cDomain, 
                                      &psnu ) )
            {
                return GetLastError();
            }

            dwMembershipCount = 0;
            apSids[1] = pSidEveryoneHeapAlloc;
        }

        CHeapFreeMe freeArray(apSids);

        // do it again for the local case    
        DWORD dwLocalGroupCount;
        DWORD* pdwLocalGroups;
        ntst = sam.m_pfnSamGetAliasMembership(hBuiltinDomain, dwMembershipCount+2, apSids, &dwLocalGroupCount,
                        &pdwLocalGroups);
        if (ntst)
        {
            ERRORTRACE((LOG_ESS, "SamGetAliasMembership Failed, error 0x%X\n", ntst));
            return ntst;
        }
        CSamFreeMe freeGroups(sam, pdwLocalGroups);
    
        // got both the global & the local - build us an array to hold them all:
        PSID* apAllSids = (PSID*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PSID) * (dwMembershipCount + dwLocalGroupCount +2));

        if (apSids)
        {
            for(DWORD i = 0; i < dwMembershipCount +2; i++)
                apAllSids[i] = apSids[i];
    
            for (i = 0; i < dwLocalGroupCount; i++)
            {
                PSID pSid = CreateUserSid(pBuiltinDomainId, pdwLocalGroups[i]);
                if (pSid)
                    apAllSids[i +dwMembershipCount +2] = pSid;
                else
                // lazy man's cleanup - let the dtors do all the work;
                {
                    ERRORTRACE((LOG_ESS, "Allocation Failure\n"));
                    
                    CHeapFreeMe freeArray(apAllSids);
                    CHeapBigPointerArrayCleanerUpper cleanAllSids(apAllSids, dwMembershipCount + dwLocalGroupCount +1);
                    
                    return STATUS_NO_MEMORY;
                }
            }

            *apGroupSids = apAllSids;
            *pdwCount = dwMembershipCount + dwLocalGroupCount +2;
        }
        else 
        {
            ERRORTRACE((LOG_ESS, "Allocation Failure\n"));
            return STATUS_NO_MEMORY;    
        }
    }

    return STATUS_SUCCESS;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\precomp.h ===
#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\scenarios\makefile.inc ===
$(O)\crlntmpl.mof $(O)\crlntmpl.mfl :
    mofcomp -amendment:ms_409 -MOF:$(O)\crlntmpl.mof -MFL:$(O)\crlntmpl.mfl crlntmpl.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\test\newwmiauthztest\newwmiauthztest.cpp ===
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <GroupsForUser.h> 
#include <wbemcomn.h>

#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L) // ntsubauth


//
// Get SID of group or user name
//

PSID CreateSIDForUserOrGroupName( LPTSTR ptszUserOrGroupName )
{
    DWORD           cbSID = GetSidLengthRequired (2),
                    dwDomainNameSize = 80;
    char            szDomainName[80];
    SID_NAME_USE    snuGroup;
    PSID            pSID = ( PSID ) malloc ( cbSID );

    // 
    // Loop if not enough room for SID;
    // otherwise set to NULL
    //

    while ( FALSE == LookupAccountName ( NULL, 
                                         ptszUserOrGroupName, 
                                         pSID,
                                         &cbSID, 
                                         szDomainName, 
                                         &dwDomainNameSize, 
                                         &snuGroup ) )
    {
        DWORD dwError = GetLastError();

        if ( dwError == ERROR_INSUFFICIENT_BUFFER )
        {
            pSID = ( PSID ) realloc ( pSID, cbSID );
        }
        else
        {
            free( pSID );
            return NULL;
        }
    }

    if ( IsValidSid( pSID ) )
    {
        return pSID;
    }

    return NULL;
}


//
// Returns DACL with a given Access Mask and SID
//

DWORD GetACLFromSID( DWORD dwAccessMask, PSID pSID, 
                     BYTE **ppNewDACL )
{
    DWORD   dwError = 0,
            dwDACLLength = sizeof ( ACL ) + 
                           sizeof ( ACCESS_ALLOWED_ACE ) - 
                           sizeof ( DWORD ) + 
                           GetLengthSid ( pSID );
    // 
    // Get memory needed for new DACL
    //

    *ppNewDACL = new BYTE[ dwDACLLength ];
    if ( !*ppNewDACL )
    {
        return GetLastError( );
    }

    do
    {
        //
        // Initialize new DACL
        //

        if ( FALSE == InitializeAcl ( ( PACL )*ppNewDACL, 
                                      dwDACLLength, 
                                      ACL_REVISION ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Get DACL using Access Mask and SID
        //

        if ( FALSE == AddAccessAllowedAce ( ( PACL )*ppNewDACL, 
                                            ACL_REVISION, 
                                            dwAccessMask, 
                                            pSID ) )
        {
            dwError = GetLastError( );
            break;
        }

        //
        // Check if everything went OK
        //

        if ( FALSE == IsValidAcl ( ( PACL )*ppNewDACL ) )
        {
            dwError = GetLastError( );
            break;
        }
    }
    while( FALSE );

    //
    // Free the stuff in case of error
    //

    if ( dwError )
    {
        delete[] *ppNewDACL;
        *ppNewDACL = NULL;
    }

    return dwError;
}


void PrintNtStatus( NTSTATUS stat )
{
    switch( stat )
    {
    case STATUS_SUCCESS:
        printf( "\tSTATUS_SUCCESS\n" );
        break;
    case STATUS_ACCESS_DENIED:
        printf( "\tSTATUS_ACCESS_DENIED\n" );
        break;
    default:
        printf( "\tERROR : stat = 0x%X\n", stat );
    }
}


void TestIsUserAdministrator( PSID pUserSID, const char * ptszUser )
{
    printf( "Testing IsUserAdministrator( PSID ) for:\n\tuser \"%s\" : ", ptszUser );
    NTSTATUS stat = IsUserAdministrator( pUserSID );
    PrintNtStatus( stat );
}


void TestIsUserInGroup( PSID pUserSID, PSID pGroupSID, const char * ptszUser, const char * ptszGroup )
{
    printf( "Testing IsUserInGroup( PSID, PSID ) for:\n\tuser \"%s\" and group \"%s\" : ", ptszUser, ptszGroup );
    NTSTATUS stat = IsUserInGroup( pUserSID, pGroupSID );
    PrintNtStatus( stat );
}


void TestGetAccessMask( PSID pUserSID, PSID pGroupSID, const char * ptszUser, const char * ptszGroup, const char * ptszAccessMask )
{
    printf( "Testing GetAccessMask.\n" );

    BYTE    *pDACLUser = NULL;
    DWORD   dwError = 0,
            dwDesiredAccessMask = ( DWORD )atoi( ptszAccessMask ),
            dwAccessMask;

    printf( "\tGetting ACL from SID of \"%s\"\n", ptszUser );

    dwError = GetACLFromSID( dwDesiredAccessMask, pUserSID, &pDACLUser );

    if ( dwError )
    {
        _DBG_ASSERT( FALSE );
        printf( "ERROR : GetACLFromSID 0x%X\n", dwError );
    }

    printf( "\tGetAccessMask( PSID, PACL, &dwAccessMask ) for\n\t\tPSID of \"%s\" and PACL of \"%s\":", ptszGroup, ptszUser );

    NTSTATUS stat = GetAccessMask( pGroupSID, ( PACL )pDACLUser, &dwAccessMask );
    PrintNtStatus( stat );

    printf( "\t>>dwAccessMask : 0x%X\n", dwAccessMask );

    //
    // free stuff
    //

    delete[] pDACLUser;
}



void TestLocalChecks( PSID pSIDUser, const char * ptszUser )
{
    PSID                        pSidDomainUsers;
    SID_IDENTIFIER_AUTHORITY    SystemSidAuthority = SECURITY_NT_AUTHORITY;
    DWORD                       dwError;

    printf( "Testing IsUserInGroup for User \"%s\" and Group Domain Users\n", ptszUser );

    //
    // Create a System Identifier for the Admin group.
    //

    if ( AllocateAndInitializeSid ( &SystemSidAuthority, 
                                    2, 
                                    SECURITY_BUILTIN_DOMAIN_RID, 
                                    DOMAIN_GROUP_RID_USERS,
                                    0, 0, 0, 0, 0, 0, 
                                    &pSidDomainUsers ) )
    {
        //
        // Call IsUserInGroup with Administrators group SID
        //

        TestIsUserInGroup( pSIDUser, pSidDomainUsers, ptszUser, "Domain Users" );

        //
        // Free the allocated SID for Admins group
        //

        FreeSid ( pSidDomainUsers );
    }
    else
    {
        dwError = GetLastError( );
        printf( "AllocateAndInitializeSid failed, error 0x%X\n", dwError );
    }
}


extern "C" int _cdecl main( int argc, char * argv[] )
{
    if ( argc < 4 )
    {
        printf( "Usage: NewWmiAuthzTest <User Name> <Group Name> <DesiredAccessMask>" );
        return 1;
    }

    PSID    pUserSID = CreateSIDForUserOrGroupName( argv[1] ),
            pGroupSID = CreateSIDForUserOrGroupName( argv[2] );


    if ( NULL == pUserSID )
    {
        _DBG_ASSERT( FALSE );
        printf( "ERROR: CreateSIDForUserOrGroupName failed for \"%s\".\n", argv[1] );
        return 1;
    }

    if ( NULL == pGroupSID )
    {
        _DBG_ASSERT( FALSE );
        printf( "ERROR: CreateSIDForUserOrGroupName failed for \"%s\".\n", argv[2] );
        return 1;
    }

    //
    // IsUserAdministrator test for both User and Group
    //

    TestIsUserAdministrator( pUserSID, argv[1] );
    TestIsUserAdministrator( pGroupSID, argv[2] );


    //
    // IsUserInGroup check for input parameters
    //

    TestIsUserInGroup( pUserSID, pGroupSID, argv[1], argv[2] );
    TestIsUserInGroup( pGroupSID, pUserSID, argv[2], argv[1] );

    //
    // GetAccessMask check
    //

    TestGetAccessMask( pUserSID, pGroupSID, argv[1], argv[2], argv[3] );
    TestGetAccessMask( pGroupSID, pUserSID, argv[2], argv[1], argv[3] );

    //
    // Test Local 

    TestLocalChecks( pUserSID, argv[1] );
    TestLocalChecks( pGroupSID, argv[2] );

    //
    // free stuff
    //

    if ( pUserSID )
    {
        free( pUserSID );
    }

    if ( pGroupSID )
    {
        free( pGroupSID );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscli\test\shell\main.cpp ===
#define COREPROX_POLARITY //__declspec( dllimport )

#include <windows.h>
#include <stdio.h>
#include <wbemcomn.h>
#include <fastall.h>
#include <evaltree.h>

void __cdecl main()
{
    HRESULT hres;

    CoInitialize(NULL);

    IWbemLocator* pLocator = NULL;
    hres = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, 
                IID_IWbemLocator, (void**)&pLocator);
    if(FAILED(hres))
    {
        printf("Can't CoCreate: 0x%X\n", hres);
        return;
    }

    IWbemServices* pNamespace = NULL;
    hres = pLocator->ConnectServer(L"root\\default", NULL, NULL, NULL, 0, NULL, 
                    NULL, &pNamespace);
    if(FAILED(hres))
    {
        printf("Can't Connect: 0x%X\n", hres);
        return;
    }

    CContextMetaData Meta(new CStandardMetaData(pNamespace), NULL);

    CEvalTree Trees[100];
    char szCommand[100];
    WCHAR wszText[4096];
    char szText[4096];
    int nIndex, nArg1, nArg2;
    long lFlags = 0;

    while(1)
    {
        printf("> ");
        scanf("%s", szCommand);

        if(!_stricmp(szCommand, "quit") || !_stricmp(szCommand, "quit"))
            return;
        else if(!_stricmp(szCommand, "load"))
        {
            scanf("%d", &nIndex);
            gets(szText);
            swprintf(wszText, L"%S", szText);
        
            Trees[nIndex].Clear();
            hres = Trees[nIndex].CreateFromQuery(&Meta, wszText, lFlags,100);
            if(FAILED(hres))
            {
                printf("Could not load '%S': 0x%X\n", wszText, hres);
            }
        }
        else if(!_stricmp(szCommand, "print"))
        {
            scanf("%d", &nIndex);

            Trees[nIndex].Dump(stdout);
        }
        else if(!_stricmp(szCommand, "and"))
        {
            scanf("%d %d %d", &nIndex, &nArg1, &nArg2);

            Trees[nIndex].Clear();
            Trees[nIndex] = Trees[nArg1];
            hres = Trees[nIndex].CombineWith(Trees[nArg2], &Meta, EVAL_OP_AND, 
                                                lFlags);
            if(FAILED(hres))
            {
                printf("Could not combine: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "or"))
        {
            scanf("%d %d %d", &nIndex, &nArg1, &nArg2);

            Trees[nIndex].Clear();
            Trees[nIndex] = Trees[nArg1];
        
            hres = Trees[nIndex].CombineWith(Trees[nArg2], &Meta, EVAL_OP_OR, 
                                                lFlags);
            if(FAILED(hres))
            {
                printf("Could not combine: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "combine"))
        {
            scanf("%d %d %d", &nIndex, &nArg1, &nArg2);

            Trees[nIndex].Clear();
            Trees[nIndex] = Trees[nArg1];
            Trees[nIndex].Rebase(nArg1);
            CEvalTree T2 = Trees[nArg2];
            T2.Rebase(nArg2);
        
            hres = Trees[nIndex].CombineWith(T2, &Meta, EVAL_OP_COMBINE, 
                                                lFlags);
            if(FAILED(hres))
            {
                printf("Could not combine: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "guarantee"))
        {
            scanf("%d %d %d", &nIndex, &nArg1, &nArg2);

            Trees[nIndex].Clear();
            Trees[nIndex] = Trees[nArg1];
            hres = Trees[nIndex].UtilizeGuarantee(Trees[nArg2], &Meta);
            if(FAILED(hres))
            {
                printf("Could not: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "remove"))
        {
            scanf("%d %d", &nIndex, &nArg1);

            hres = Trees[nIndex].RemoveIndex(nArg1);
            if(FAILED(hres))
            {
                printf("Could not combine: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "optimize"))
        {
            scanf("%d", &nIndex);

            hres = Trees[nIndex].Optimize(&Meta);
            if(FAILED(hres))
            {
                printf("Could not combine: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "necessary"))
        {
            scanf("%d %d %S", &nIndex, &nArg1, wszText);

            CPropertyName Prop;
            Prop.AddElement(wszText);
            CPropertyProjectionFilter Filter;
            Filter.AddProperty(Prop);

            hres = Trees[nIndex].CreateProjection(Trees[nArg1], &Meta, 
                        &Filter, e_Necessary, false);
            if(FAILED(hres))
            {
                printf("Could not project: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "sufficient"))
        {
            scanf("%d %d %S", &nIndex, &nArg1, wszText);

            CPropertyName Prop;
            Prop.AddElement(wszText);
            CPropertyProjectionFilter Filter;
            Filter.AddProperty(Prop);

            hres = Trees[nIndex].CreateProjection(Trees[nArg1], &Meta, 
                        &Filter, e_Sufficient, false);
            if(FAILED(hres))
            {
                printf("Could not project: 0x%X\n", hres);
            }
        }
        else if(!_stricmp(szCommand, "mandatory"))
        {
            scanf("%d", &nArg1);
            
            if(nArg1)
                lFlags |= WBEM_FLAG_MANDATORY_MERGE;
            else
                lFlags &= ~WBEM_FLAG_MANDATORY_MERGE;
        }
        else
        {
            printf("Unknown command.  'help' for help\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplassc.cpp ===
#include "precomp.h"
#include <assert.h>
#include <pathutl.h>
#include <arrtempl.h>
#include "tmplassc.h"

const LPCWSTR g_wszTmplAssocClass = L"MSFT_TemplateToTargetAssociation";
const LPCWSTR g_wszAssocTarget = L"Target";
const LPCWSTR g_wszAssocTmpl = L"Template";
const LPCWSTR g_wszTmplInfoClass = L"MSFT_TemplateInfo";
const LPCWSTR g_wszInfoTmpl = L"Tmpl";
const LPCWSTR g_wszInfoName = L"Name";
const LPCWSTR g_wszInfoTargets =  L"Targets";
const LPCWSTR g_wszQueryLang = L"WQL";
const LPCWSTR g_wszTmplInfoQuery = L"SELECT * FROM MSFT_TemplateInfo";

HRESULT CTemplateAssocProvider::Init( IWbemServices* pSvc, 
                                      LPWSTR wszNamespace,
                                      IWbemProviderInitSink* pInitSink )
{
    HRESULT hr;

    hr = pSvc->GetObject( CWbemBSTR(g_wszTmplAssocClass), 
                          0, 
                          NULL, 
                          &m_pTmplAssocClass, 
                          NULL );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    m_pSvc = pSvc;
    m_wsNamespace = wszNamespace;

    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
}

HRESULT CTemplateAssocProvider::GetObject( BSTR bstrPath, 
                                           IWbemObjectSink* pResHndlr )
{
    CRelativeObjectPath RelPath;
 
    if ( !RelPath.Parse( bstrPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ParsedObjectPath* pPath = RelPath.m_pPath;

    assert( pPath->m_pClass != NULL );

    if ( _wcsicmp( pPath->m_pClass, g_wszTmplAssocClass ) != 0 )
    {
        return WBEM_E_NOT_FOUND;
    }

    if ( pPath->m_dwNumKeys != 2 ||
         _wcsicmp( pPath->m_paKeys[0]->m_pName, g_wszAssocTmpl ) != 0  ||
         _wcsicmp( pPath->m_paKeys[1]->m_pName, g_wszAssocTarget ) != 0 || 
         V_VT(&pPath->m_paKeys[0]->m_vValue) != VT_BSTR ||
         V_VT(&pPath->m_paKeys[1]->m_vValue) != VT_BSTR )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    CRelativeObjectPath TemplatePath, TargetPath;

    //
    // we need to normalize the paths before calling GetInstances.
    //

    if ( !TemplatePath.Parse( V_BSTR(&pPath->m_paKeys[0]->m_vValue)) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    if ( !TargetPath.Parse( V_BSTR(&pPath->m_paKeys[1]->m_vValue)) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // the tmpl obj path can be a fully qualified path, so make sure to add
    // the namespace back on if necessary.  We should not add it back on
    // if the namespace is specified, but does not name this namespace.
    //

    WString wsTargetPath;
    LPCWSTR wszTargetPath = TargetPath.GetPath();
    LPCWSTR wszNamespace = TargetPath.m_pPath->GetNamespacePart();

/*
    if ( wszNamespace != NULL && _wcsicmp( wszNamespace, m_wsNamespace ) != 0 )
    {
        wsTmplObjPath = L"\\\\";
        wsTmplObjPath += wszNamespace;
        wsTmplObjPath += L":";
        wsTmplObjPath += wszTmplObjPath;
        wszTmplObjPath = wsTmplObjPath;
    }
*/
    
    HRESULT hr = GetInstances( TemplatePath.GetPath(),
                               wszTargetPath, 
                               pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

//
// wszTemplate is used to scope the query for the Assoc Info objects.(optional)
// wszTmplObjPath is used to filter the returned objects. (optional).
//
HRESULT CTemplateAssocProvider::GetInstances( LPCWSTR wszTemplate, 
                                              LPCWSTR wszTargetPath,
                                              IWbemObjectSink* pResHndlr )
{
    HRESULT hr;
    
    CWbemBSTR bsTmplInfoQuery = g_wszTmplInfoQuery;

    CWbemPtr<IEnumWbemClassObject> pTmplInfoObjs;

    if ( wszTemplate != NULL )
    {
        WString wsTmp = wszTemplate;
        WString wsTmp2 = wsTmp.EscapeQuotes();
        bsTmplInfoQuery += L" WHERE Id = \"";
        bsTmplInfoQuery += wsTmp2;
        bsTmplInfoQuery += L"\"";
    }
           
    hr = m_pSvc->ExecQuery( CWbemBSTR(g_wszQueryLang),
                            bsTmplInfoQuery,
                            WBEM_FLAG_FORWARD_ONLY,
                            NULL,
                            &pTmplInfoObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }

    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
	assert( cObjs ==  1 );
        
        //
        // enumerate all of the instantiated refs and create the associations. 
        //

        CPropVar vTargets;

        hr = pTmplInfo->Get( g_wszInfoTargets, 0, &vTargets, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vTargets.CheckType(VT_BSTR|VT_ARRAY)) )
        {
            return hr;
        }

        CPropSafeArray<BSTR> saTargets( V_ARRAY(&vTargets) );

        CPropVar vName;

        hr = pTmplInfo->Get( g_wszInfoName, 0, &vName, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vName.CheckType( VT_BSTR )) )
        {
            return hr;
        }

        for( ULONG i=0; i < saTargets.Length(); i++ )
        {
            //
            // Perform filtering if necessary 
            //

            if ( wszTargetPath != NULL && 
                 _wcsicmp( wszTargetPath, saTargets[i] ) != 0 )
            {
                continue;
            }
         
            //
            // now can create the association instance.
            //

            CWbemPtr<IWbemClassObject> pAssoc;  

            hr = m_pTmplAssocClass->SpawnInstance( 0, &pAssoc );

            if ( FAILED(hr) )
            {
                return hr;
            }

            VARIANT var;
            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = saTargets[i];

            hr = pAssoc->Put( g_wszAssocTarget, 0, &var, NULL );

            if ( FAILED(hr) )
            {
                return hr;
            }

            hr = pAssoc->Put( g_wszAssocTmpl, 0, &vName, NULL );

            if ( FAILED(hr) )
            {
                return hr;
            }

            hr = pResHndlr->Indicate( 1, &pAssoc );
            
            if ( FAILED(hr) )
            {
                return hr;
            }

            if ( wszTargetPath != NULL )
            {
                return WBEM_S_NO_ERROR;
            }
        }

        if ( wszTargetPath != NULL )
        {
            return WBEM_S_NO_ERROR;
        }

        hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );
    }

    return hr;
}

HRESULT 
CTemplateAssocProvider::GetAllInstances( LPWSTR wszClassname,
                                         IWbemObjectSink* pResHndlr )
{
    HRESULT hr = GetInstances( NULL, NULL, pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

CTemplateAssocProvider::CTemplateAssocProvider( CLifeControl* pCtl, 
                                                IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}

void* CTemplateAssocProvider::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }

    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CTemplateAssocProvider::XServices::XServices(CTemplateAssocProvider* pProv)
: CImpl< IWbemServices, CTemplateAssocProvider> ( pProv )
{

}

CTemplateAssocProvider::XInitialize::XInitialize(CTemplateAssocProvider* pProv)
: CImpl< IWbemProviderInit, CTemplateAssocProvider> ( pProv )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplassc.h ===
#ifndef __TMPLASSC_H__
#define __TMPLASSC_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <unk.h>
#include "tmplprov.h"

class CTemplateAssocProvider : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl<IWbemProviderInit,CTemplateAssocProvider>
    {
        XInitialize( CTemplateAssocProvider* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, wszNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl<IWbemServices, CTemplateAssocProvider>
    {
        XServices( CTemplateAssocProvider* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetObject( strObjectPath, pResponseHandler );
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetAllInstances( strClass, pResponseHandler );
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    CWbemPtr<IWbemServices> m_pSvc;    
    WString m_wsNamespace;
    CWbemPtr<IWbemClassObject> m_pTmplAssocClass;
    
public:
    
    CTemplateAssocProvider( CLifeControl* pCtl = NULL, IUnknown* pUnk = NULL );
    void* GetInterface( REFIID riid );

    HRESULT GetInstances( LPCWSTR wszTemplatePath,
                          LPCWSTR wszTmplObjPath, 
                          IWbemObjectSink* pRespHndlr );
public:

    HRESULT Init( IWbemServices* pSvc, 
                  LPWSTR wszNamespace, 
                  IWbemProviderInitSink* pInitSink );

    HRESULT GetObject( BSTR bstrPath, IWbemObjectSink* pResponseHndlr );

    HRESULT GetAllInstances( LPWSTR wszClassname,
                             IWbemObjectSink* pResponseHndlr );
};

#endif // __TMPLASSC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplcomn.cpp ===
#include "precomp.h"
#include <pathutl.h>
#include "tmplcomn.h"

/****************************************************************************
  GetTemplateName() - Fetches value for specified prop name.  Value can be 
  taken from the template object or from an instantiated target object.
*****************************************************************************/

const LPCWSTR g_wszBuilderAlias = L"__BUILDER";

HRESULT GetTemplateValue( LPCWSTR wszPropName,
                          IWbemClassObject* pTmpl,
                          BuilderInfoSet& rBldrInfoSet,
                          VARIANT* pvValue )
{
    HRESULT hr;

    VariantInit( pvValue );

    //
    // This property may exist on the template obejct or it may exist on the
    // instantiated target from this template.  The presence of the builder
    // alias will tell us which one it is.
    //

    WCHAR* pwch = wcschr( wszPropName, '.' );

    if ( pwch == NULL )
    {
        return pTmpl->Get( wszPropName, 0, pvValue, NULL, NULL );
    }
 
    int cAliasName = pwch - wszPropName;
    int cBldrAliasName = wcslen( g_wszBuilderAlias );

    if ( cAliasName != cBldrAliasName || 
         _wcsnicmp( wszPropName, g_wszBuilderAlias, cAliasName ) != 0 )
    {
        //
        // TODO : support embedded object template arguments.
        //
        return WBEM_E_NOT_SUPPORTED;
    }

    LPCWSTR wszBldrName = pwch + 1;
        
    pwch = wcschr( wszBldrName, '.' );

    if ( pwch == NULL )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    int cBldrName = pwch - wszBldrName;

    // 
    // find the builder info using the name.
    //
    
    BuilderInfoSetIter Iter;

    for( Iter = rBldrInfoSet.begin(); Iter != rBldrInfoSet.end(); Iter++ )
    {
        BuilderInfo& rInfo = (BuilderInfo&)*Iter;

        if ( rInfo.m_wsName.Length() != cBldrName || 
             _wcsnicmp( wszBldrName, rInfo.m_wsName, cBldrName ) != 0 )
        {
            continue;
        }

        if ( rInfo.m_wsNewTargetPath.Length() == 0 )
        {
            //
            // this will happen when the builders aren't ordered correctly
            //
            return WBEM_E_NOT_FOUND;
        }

        LPCWSTR wszName = pwch + 1;

        if ( _wcsicmp( wszName, L"__RELPATH" ) == 0 )
        {
            V_VT(pvValue) = VT_BSTR;
            V_BSTR(pvValue) = SysAllocString( rInfo.m_wsNewTargetPath );

            if ( V_BSTR(pvValue) == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            return WBEM_S_NO_ERROR;
        }

        //
        // the name currently must identify a key propery.
        //

        CRelativeObjectPath TargetPath;
        
        if ( !TargetPath.Parse( rInfo.m_wsNewTargetPath ) )
        {
            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        ParsedObjectPath* pTargetPath = TargetPath.m_pPath;

        //
        // look through the keys until we find one that matches propname,
        // then take its value.
        //
        
        for( DWORD i=0; i < pTargetPath->m_dwNumKeys; i++ )
        {
            LPCWSTR wszKey = pTargetPath->m_paKeys[i]->m_pName;
            
            //
            // TODO, if no prop name in key, then we should consult the 
            // target object we have in the builder info.
            // 

            if ( wszKey == NULL || _wcsicmp( wszKey, pwch ) == 0 )
            {
                hr = VariantCopy(pvValue, &pTargetPath->m_paKeys[i]->m_vValue);
                
                if ( FAILED(hr) ) 
                {
                    return hr;
                }

                return WBEM_S_NO_ERROR;
            }
        }

        return WBEM_E_NOT_FOUND;
    }

    return WBEM_E_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplcomn.h ===
#ifndef __TMPLCOMN_H__
#define __TMPLCOMN_H__

#include <wstring.h>
#include <wbemcli.h>
#include <comutl.h>
#include <set>
#include <wstlallc.h>

struct ErrorInfo
{
    WString m_wsErrProp;
    WString m_wsErrStr;
    CWbemPtr<IWbemClassObject> m_pBuilder;
    CWbemPtr<IWbemClassObject> m_pTarget;
    CWbemPtr<IWbemClassObject> m_pExtErr;
};

struct BuilderInfo 
{ 
    CWbemPtr<IWbemClassObject> m_pBuilder;
    CWbemPtr<IWbemClassObject> m_pTarget;
    CWbemPtr<IWbemServices> m_pTargetSvc;
    WString m_wsName;
    WString m_wsTargetNamespace;
    WString m_wsExistingTargetPath;
    WString m_wsNewTargetPath;
    ULONG m_ulOrder;
};

typedef std::set<BuilderInfo,std::less<BuilderInfo>,wbem_allocator<BuilderInfo> > BuilderInfoSet;
typedef BuilderInfoSet::iterator BuilderInfoSetIter;

HRESULT GetTemplateValue( LPCWSTR wszPropName,
                          IWbemClassObject* pTmpl,
                          BuilderInfoSet& rBldrInfoSet,
                          VARIANT* pvValue );
 
#endif __TMPLCOMN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplprov.h ===
#ifndef __TMPLPROV_H__
#define __TMPLPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>
#include <comutl.h>
#include <wstring.h>
#include "tmplcomn.h"

/***************************************************************************
  CTemplateProvider
****************************************************************************/

class CTemplateProvider : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl< IWbemProviderInit, CTemplateProvider>
    {
        XInitialize( CTemplateProvider* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, wszNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl< IWbemServices, CTemplateProvider>
    {
        XServices( CTemplateProvider* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetObject( strObjectPath, pResponseHandler );
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return m_pObject->PutInstance( pInst, lFlags, pResponseHandler );
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->DeleteInstance( strObjectPath, pResponseHandler);
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetAllInstances( strClass, pResponseHandler );
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    WString m_wsNamespace;
    WString m_wsFullNamespace;
    
    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemObjectSink> m_pEventSink;
    CWbemPtr<IWbemDecoupledBasicEventProvider> m_pDES;
    
    CWbemPtr<IWbemClassObject> m_pTargetAssocClass;
    CWbemPtr<IWbemClassObject> m_pTmplInfoClass;
    CWbemPtr<IWbemClassObject> m_pErrorInfoClass;
    CWbemPtr<IWbemClassObject> m_pModifyEventClass;
    CWbemPtr<IWbemClassObject> m_pCreateEventClass;
    CWbemPtr<IWbemClassObject> m_pDeleteEventClass;

    HRESULT GetErrorObj( ErrorInfo& rInfo, IWbemClassObject** ppErrObj );

    HRESULT FireIntrinsicEvent( IWbemClassObject* pClass, 
                                IWbemClassObject* pTarget,
                                IWbemClassObject* pPrev );

    HRESULT StoreTmplInfo( BSTR bstrTmplPath, 
                           IWbemClassObject* pTmpl,
                           BuilderInfoSet& rBldrInfoSet );
    
    HRESULT DeleteTargets( LPCWSTR wszTmplPath, 
                           LPWSTR* wszTargetPaths,
                           ULONG cTargetPaths );

    HRESULT ValidateTemplate( IWbemClassObject* pTmpl, ErrorInfo& rErrInfo );

    HRESULT PutTarget( IWbemClassObject* pTmpl, 
                       BSTR bstrTmplPath,
                       BuilderInfo& rBldrInfo,
                       ErrorInfo& rErrInfo ); 

    HRESULT CheckOptimization( BuilderInfo& rBldrInfo );

    HRESULT DeriveTmplInfoPath( IWbemClassObject* pTmpl,
                                CWbemBSTR& rbstrTmplInfoPath, 
                                CWbemBSTR& rbstrTmplPath );

    HRESULT TmplInfoFromTmplPath( BSTR bstrTmplPath,IWbemClassObject** ppTmpl);

    HRESULT PutInstance( IWbemClassObject* pObj,
                         long lFlags,
                         CWbemBSTR& rbsTmplPath,
                         ErrorInfo& rErrInfo );

public:
    
    CTemplateProvider( CLifeControl* pCtl = NULL, IUnknown* pUnk = NULL );
    void* GetInterface( REFIID riid );
    ~CTemplateProvider();

    HRESULT Init( IWbemServices* pSvc, 
                  LPWSTR wszNamespace, 
                  IWbemProviderInitSink* pInitSink );

    HRESULT DeleteInstance( BSTR bstrPath, IWbemObjectSink* pRspHndlr );

    HRESULT PutInstance( IWbemClassObject* pObj, 
                         long lFlags, 
                         IWbemObjectSink* pRspHndlr );
    
    HRESULT GetObject( BSTR bstrPath, IWbemObjectSink* pResponseHndlr );
    HRESULT GetAllInstances( LPWSTR wszClassname,
                             IWbemObjectSink* pResponseHndlr );
};

#endif // __TMPLPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplsubs.cpp ===
#include "precomp.h"
#include <genlex.h>
#include <stdio.h>
#include <ql.h>
#include <arrtempl.h>
#include <assert.h>
#include <pathutl.h>
#include "tmplsubs.h"

/***************************************************************************
  Lex Table Defined for CTemplateStrSubstitution
****************************************************************************/

#define ST_SUBST1   3
#define ST_SUBST2   5
#define ST_NONSUBST 9

#define ST_EXTEN     13
#define ST_IDENT     16
#define ST_STRING1   23
#define ST_STRING2   26

#define TMPL_TOK_SUBST_STR                           256
#define TMPL_TOK_NONSUBST_STR                        257

#define TMPL_TOK_STRING                              258
#define TMPL_TOK_EXTENSION_IDENT                     259
#define TMPL_TOK_IDENT                               260
#define TMPL_TOK_OPEN_PAREN                          261
#define TMPL_TOK_CLOSE_PAREN                         262
#define TMPL_TOK_COMMA                               263
#define TMPL_TOK_EOF                                 264
#define TMPL_TOK_ERROR                               265

#define TMPL_CONDITIONAL_EXTENSION        L"ConditionalSubstitution"
#define TMPL_PREFIXED_WHERE_EXTENSION     L"PrefixedWhereClause"

#define TMPL_TOK_CONDITIONAL_EXTENSION               266
#define TMPL_TOK_PREFIXED_WHERE_EXTENSION            267

//
// The Tmpl_StrLexTable identifies Substitutable and Non-Substitutable
// tokens of an input string.
//

LexEl Tmpl_StrLexTable[] = 
{
// State    First   Last       New state,   Return tok,         Instruction
// =======================================================================

/* 0 */  '%',      GLEX_EMPTY, ST_SUBST1,    0,                 GLEX_CONSUME,
/* 1 */  0,        GLEX_EMPTY, 0,            TMPL_TOK_EOF,      GLEX_ACCEPT,
/* 2 */  GLEX_ANY, GLEX_EMPTY, ST_NONSUBST,  0,                 GLEX_ACCEPT,

    // -------------------------------------------------------------------
    // ST_SUBST1
    // 
     
/* 3 */  '%',      GLEX_EMPTY, 0,     TMPL_TOK_NONSUBST_STR,    GLEX_ACCEPT,
/* 4 */  GLEX_ANY, GLEX_EMPTY, ST_SUBST2,     0,                GLEX_PUSHBACK,

    // -------------------------------------------------------------------
    // ST_SUBST2
    //

/* 5 */  '%',      GLEX_EMPTY, 0,        TMPL_TOK_SUBST_STR,    GLEX_CONSUME,
/* 6 */  0,        GLEX_EMPTY, 0,        TMPL_TOK_ERROR,        GLEX_RETURN,
/* 7 */  '\n',     GLEX_EMPTY, 0,        TMPL_TOK_ERROR,        GLEX_RETURN,
/* 8 */  GLEX_ANY, GLEX_EMPTY, ST_SUBST2,     0,                GLEX_ACCEPT,

    // -------------------------------------------------------------------
    // ST_NONSUBST
    //

/* 9 */  '%',      GLEX_EMPTY, 0,        TMPL_TOK_NONSUBST_STR, GLEX_PUSHBACK,
/* 10 */  0,        GLEX_EMPTY, 0,        TMPL_TOK_NONSUBST_STR, GLEX_PUSHBACK,
/* 11 */ GLEX_ANY, GLEX_EMPTY, ST_NONSUBST,   0,                GLEX_ACCEPT

};

//
// This table drives the lexer for the substitutable strings.
//

LexEl Tmpl_SubstLexTable[] =
{

// State    First   Last      New state,  Return tok,         Instructions
// =======================================================================

/* 0 */  'A',    'Z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 1 */  'a',    'z',       ST_IDENT,   0,                     GLEX_ACCEPT,
/* 2 */  0x80,  0xfffd,     ST_IDENT,   0,                     GLEX_ACCEPT,
/* 3 */  '!',   GLEX_EMPTY, ST_EXTEN,   0,                     GLEX_CONSUME,
/* 4 */  '(',   GLEX_EMPTY, 0,        TMPL_TOK_OPEN_PAREN,     GLEX_ACCEPT,
/* 5 */  ')',   GLEX_EMPTY, 0,        TMPL_TOK_CLOSE_PAREN,    GLEX_ACCEPT,
/* 6 */  ',',   GLEX_EMPTY, 0,        TMPL_TOK_COMMA,          GLEX_ACCEPT,   
/* 7 */  '"',    GLEX_EMPTY, ST_STRING1,  0,                   GLEX_CONSUME,
/* 8 */  ' ',    GLEX_EMPTY, 0,           0,                   GLEX_CONSUME,
/* 9 */  0,      GLEX_EMPTY, 0,       TMPL_TOK_EOF,            GLEX_ACCEPT,
/* 10 */ '_',   GLEX_EMPTY,  ST_IDENT,    0,                   GLEX_ACCEPT,
/* 11 */ '\'',  GLEX_EMPTY,  ST_STRING2,  0,                   GLEX_CONSUME,
/* 12 */ GLEX_ANY, GLEX_EMPTY, 0,     TMPL_TOK_ERROR, GLEX_CONSUME|GLEX_RETURN,

    // -------------------------------------------------------------------
    // ST_EXTEN

/* 13 */  'a',   'z',          ST_EXTEN,   0,                  GLEX_ACCEPT,
/* 14 */  'A',   'Z',          ST_EXTEN,   0,                  GLEX_ACCEPT,
/* 15 */  GLEX_ANY,GLEX_EMPTY, 0,     TMPL_TOK_EXTENSION_IDENT,GLEX_PUSHBACK,


    // -------------------------------------------------------------------
    // ST_IDENT

/* 16 */  'a',   'z',         ST_IDENT,    0,             GLEX_ACCEPT,
/* 17 */  'A',   'Z',         ST_IDENT,    0,             GLEX_ACCEPT,
/* 18 */  '_',   GLEX_EMPTY,  ST_IDENT,    0,             GLEX_ACCEPT,
/* 19 */  '0',   '9',         ST_IDENT,    0,             GLEX_ACCEPT,
/* 20 */  0x80,   0xfffd,     ST_IDENT,    0,             GLEX_ACCEPT,
/* 21 */  '.',   GLEX_EMPTY,  ST_IDENT,    0,             GLEX_ACCEPT,
/* 22 */  GLEX_ANY,GLEX_EMPTY, 0,      TMPL_TOK_IDENT,    GLEX_PUSHBACK, 

    // ------------------------------------------------------------------
    // ST_STRING1

/* 23 */ '"',  GLEX_EMPTY,      0,     TMPL_TOK_STRING,     GLEX_CONSUME,
/* 24 */ GLEX_ANY, GLEX_EMPTY, ST_STRING1,  0,              GLEX_ACCEPT,
/* 25 */ 0,   GLEX_EMPTY,      0,     TMPL_TOK_ERROR,       GLEX_ACCEPT, 

    // ------------------------------------------------------------------
    // ST_STRING2

/* 26 */ '\'',  GLEX_EMPTY,      0,     TMPL_TOK_STRING,    GLEX_CONSUME,
/* 27 */ GLEX_ANY, GLEX_EMPTY, ST_STRING2,  0,              GLEX_ACCEPT,
/* 28 */ 0,   GLEX_EMPTY,      0,     TMPL_TOK_ERROR,       GLEX_ACCEPT 


};

/***************************************************************************
  CTemplateStrSubstitution
****************************************************************************/

CTemplateStrSubstitution::CTemplateStrSubstitution(CGenLexSource& rLexSrc,
                                                   IWbemClassObject* pTmplArgs,
                                                   BuilderInfoSet& rInfoSet )
: m_Lexer( Tmpl_StrLexTable, &rLexSrc ), m_rBldrInfoSet( rInfoSet ),
  m_pSubstLexer( NULL ), m_pTmplArgs(pTmplArgs), m_cArgList(0)
{
}

inline void PrefixPropertyName( CPropertyName& rProp, WString& rwsPrefix )
{
    CPropertyName PropCopy = rProp;
    rProp.Empty();
    rProp.AddElement(rwsPrefix);
    
    for( long i=0; i < PropCopy.GetNumElements(); i++ )
    {
        rProp.AddElement( PropCopy.GetStringAt( i ) );
    }
}

HRESULT CTemplateStrSubstitution::SubstNext()
{
    assert( m_pSubstLexer != NULL );

    m_nCurrentToken = m_pSubstLexer->NextToken();
    
    if ( m_nCurrentToken == TMPL_TOK_ERROR )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    m_wszSubstTokenText = m_pSubstLexer->GetTokenText();

    if ( m_nCurrentToken == TMPL_TOK_EXTENSION_IDENT )
    {
        if ( _wcsicmp( m_wszSubstTokenText,
                       TMPL_CONDITIONAL_EXTENSION ) == 0 )
        {
            m_nCurrentToken = TMPL_TOK_CONDITIONAL_EXTENSION;
        }
        else if ( _wcsicmp( m_wszSubstTokenText,
                            TMPL_PREFIXED_WHERE_EXTENSION) == 0 )
        {
            m_nCurrentToken = TMPL_TOK_PREFIXED_WHERE_EXTENSION;
        }
        else
        {
            m_nCurrentToken = TMPL_TOK_ERROR;
        }
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::Next()
{
    m_nCurrentToken = m_Lexer.NextToken();
    
    if ( m_nCurrentToken == TMPL_TOK_ERROR )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    if ( m_nCurrentToken == TMPL_TOK_NONSUBST_STR ||
         m_nCurrentToken == TMPL_TOK_SUBST_STR ) 
    {
        m_wszTokenText = m_Lexer.GetTokenText();
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::Parse( BSTR* pbstrOut )
{
    HRESULT hr;
    
    hr = Next();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = parse();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken != TMPL_TOK_EOF ) 
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    *pbstrOut = SysAllocString( m_wsOutput );

    if ( *pbstrOut == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CTemplateStrSubstitution::parse()
{
    HRESULT hr;

    if ( m_nCurrentToken == TMPL_TOK_NONSUBST_STR )
    {
        m_wsOutput += m_wszTokenText;
        
        hr = Next();

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        return parse();
    }
    else if ( m_nCurrentToken == TMPL_TOK_SUBST_STR )
    {
        hr = subst_string();

        if ( FAILED(hr) )
        {
            return hr;
        }

        return parse();
    }
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::subst_string()
{
    HRESULT hr;

    CTextLexSource SubstLexSrc( m_wszTokenText );
    CGenLexer SubstLexer( Tmpl_SubstLexTable, &SubstLexSrc );
    
    m_pSubstLexer = &SubstLexer;

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken == TMPL_TOK_IDENT )
    {
        hr = HandleTmplArgSubstitution();

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = SubstNext();
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        if ( m_nCurrentToken != TMPL_TOK_EOF )
        {
            return WBEM_E_INVALID_PROPERTY;
        }

        return Next();
    }

    int nCurrentToken = m_nCurrentToken;

    // advance the lexer so we can parse the args before calling the 
    // extension function ... 

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = arglist();
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken != TMPL_TOK_EOF )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    if ( nCurrentToken == TMPL_TOK_CONDITIONAL_EXTENSION )
    {    
        hr = HandleConditionalSubstitution();
    }
    else if ( nCurrentToken == TMPL_TOK_PREFIXED_WHERE_EXTENSION  )
    {
        hr = HandlePrefixedWhereSubstitution();
    }
    else
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    // reset the arglist ...

    m_cArgList = 0;

    if ( FAILED(hr) )
    {
        return hr;
    }

    return Next();
}

HRESULT CTemplateStrSubstitution::arglist()
{
    HRESULT hr;

    if ( m_nCurrentToken != TMPL_TOK_OPEN_PAREN )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = arglist2();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_nCurrentToken != TMPL_TOK_CLOSE_PAREN )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    return SubstNext();
}

HRESULT CTemplateStrSubstitution::arglist2()
{
    HRESULT hr;

    if ( m_nCurrentToken != TMPL_TOK_IDENT && 
         m_nCurrentToken != TMPL_TOK_STRING )
    {
        return WBEM_S_NO_ERROR;
    }

    //
    // add the argument to the argument list
    //

    if ( m_cArgList >= MAXARGS ) 
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    m_abArgListString[m_cArgList] = 
        m_nCurrentToken == TMPL_TOK_IDENT ? FALSE : TRUE; 
    
    m_awsArgList[m_cArgList++] = m_wszSubstTokenText;

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    return arglist3();
}

HRESULT CTemplateStrSubstitution::arglist3()
{
    HRESULT hr;

    if ( m_nCurrentToken != TMPL_TOK_COMMA )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = SubstNext();

    if ( FAILED(hr) )
    {
        return hr;
    }

    return arglist2();
}

HRESULT CTemplateStrSubstitution::HandleConditionalSubstitution()
{
    HRESULT hr;

    //
    // Extension Function : Input Arg1:String, Arg2:Ident
    // Substitute Arg1 if Tmpl Args Prop specified by Arg2 is not NULL.
    //

    if ( m_cArgList != 2 || 
         m_abArgListString[0] != TRUE ||
         m_abArgListString[1] != FALSE )
    {
        return WBEM_E_INVALID_PROPERTY;
    }

    CPropVar var;
    CWbemBSTR bstrPropName = m_awsArgList[1];

    hr = m_pTmplArgs->Get( bstrPropName, 0, &var, NULL, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    if ( V_VT(&var) == VT_NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    m_wsOutput += m_awsArgList[0];

    return WBEM_S_NO_ERROR;
}


HRESULT CTemplateStrSubstitution::HandlePrefixedWhereSubstitution()
{
    HRESULT hr;

    //
    // Extension Function : Input Arg1:Ident, Arg2:Ident
    // Substitute where clause of query property of TmplArgs 
    // specified by Arg2.  Prefix each identifier in clause with Arg1.
    // If prop specified by Arg2 is NULL, then this function is a No-Op.
    //

    if ( m_cArgList != 2 || 
         m_abArgListString[0] != FALSE ||
         m_abArgListString[1] != FALSE )
    {
        return WBEM_E_INVALID_PROPERTY;
    }
    
    CWbemBSTR bstrPropName = m_awsArgList[1];

    VARIANT var;

    hr = m_pTmplArgs->Get( bstrPropName, 0, &var, NULL, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    CClearMe cmvar( &var );

    if ( V_VT(&var) == VT_NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    if ( V_VT(&var) != VT_BSTR )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    //
    // Have to add the following so it will parse ..
    //

    WString wsQuery = "SELECT * FROM A WHERE ";
    wsQuery += V_BSTR(&var);

    // 
    // Now need to parse this and go through RPN expression ...
    //

    CTextLexSource TextSource( wsQuery );

    CAbstractQl1Parser Parser( &TextSource );
    QL_LEVEL_1_RPN_EXPRESSION Tokens;

    if ( Parser.Parse( &Tokens, CAbstractQl1Parser::FULL_PARSE ) 
            != QL1_Parser::SUCCESS )
    {
        return WBEM_E_INVALID_QUERY;
    }

    if ( Tokens.nNumTokens < 1 )
    {
        return WBEM_S_NO_ERROR;
    }
        
    for( int i=0; i < Tokens.nNumTokens; i++ )
    {
        QL_LEVEL_1_TOKEN& rToken = Tokens.pArrayOfTokens[i];

        if ( rToken.nTokenType != QL_LEVEL_1_TOKEN::OP_EXPRESSION )
        {
            continue;
        }
    
        if ( rToken.PropertyName.GetNumElements() > 0 )
        {
            PrefixPropertyName( rToken.PropertyName, m_awsArgList[0] );
        }
        
        if ( rToken.m_bPropComp )
        {
            assert( rToken.PropertyName2.GetNumElements() > 0 );
            PrefixPropertyName( rToken.PropertyName2, m_awsArgList[0] );
        }
    }

    //
    // now we have to pull off the select * from classname where ....
    //

    LPWSTR wszText = Tokens.GetText();

    // from peeking at the source, look for substring 'where'(case-insensitive)

    WCHAR* wszWhere = wcsstr( wszText, L"where" );

    if ( wszWhere == NULL )
    {
        delete wszText;
        return WBEM_E_INVALID_OBJECT;
    }

    wszWhere += 5;
    m_wsOutput += wszWhere;
    delete wszText;
 
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateStrSubstitution::HandleTmplArgSubstitution()
{
    HRESULT hr; 

    //
    // Substitute Tmpl Args Prop specified by Arg1.
    // No-Op if prop value is NULL.
    //

    LPCWSTR wszPropName = m_wszSubstTokenText;

    CPropVar vValue;

    hr = GetTemplateValue( wszPropName,
                           m_pTmplArgs, 
                           m_rBldrInfoSet, 
                           &vValue );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vValue) == VT_NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = vValue.SetType( VT_BSTR );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    m_wsOutput += V_BSTR(&vValue);

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\main.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <trnsprov.h>
#include <commain.h>
#include <comutl.h>

#include <tchar.h>

// {405595AA-1E14-11d3-B33D-00105A1F4AAF}
static const GUID CLSID_TransientProvider = 
{ 0x405595aa, 0x1e14, 0x11d3, { 0xb3, 0x3d, 0x0, 0x10, 0x5a, 0x1f, 0x4a, 0xaf } };

// {405595AB-1E14-11d3-B33D-00105A1F4AAF}
static const GUID CLSID_TransientEventProvider = 
{ 0x405595ab, 0x1e14, 0x11d3, { 0xb3, 0x3d, 0x0, 0x10, 0x5a, 0x1f, 0x4a, 0xaf } };

class CMyServer : public CComServer
{
public:

    HRESULT Initialize()
    {
        ENTER_API_CALL

        HRESULT hr;
        CWbemPtr<CBaseClassFactory> pFactory;

        hr = CTransientProvider::ModuleInitialize();

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CClassFactory<CTransientProvider>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_TransientProvider, 
                           pFactory,
                           _T("Transient Instance Provider"),
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory= new CClassFactory<CTransientEventProvider>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }


        hr = AddClassInfo( CLSID_TransientEventProvider, 
                           pFactory,
                           _T("Transient Instance Reboot Event Provider"),
                           TRUE );
        return hr;

        EXIT_API_CALL
    }

    void Uninitialize()
    {
        CTransientProvider::ModuleUninitialize();
    }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplprov.cpp ===
#include "precomp.h"
#include <pathutl.h>
#include <arrtempl.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemutil.h>
#include "tmplprov.h"
#include "tmplassc.h"
#include "tmplsubs.h"

#include <tchar.h>

const LPCWSTR g_wszQueryLang = L"WQL";
const LPCWSTR g_wszRelpath = L"__RelPath";
const LPCWSTR g_wszClass = L"__Class";
const LPCWSTR g_wszIndicationRelated = L"__IndicationRelated";
const LPCWSTR g_wszCreatorSid = L"CreatorSID";
const LPCWSTR g_wszTargetAssoc = L"MSFT_TargetToTemplateAssociation";
const LPCWSTR g_wszTmplInfo = L"MSFT_TemplateInfo";
const LPCWSTR g_wszTmplBldr = L"MSFT_TemplateBuilder";
const LPCWSTR g_wszNamespaceProp = L"NamespaceProperty";
const LPCWSTR g_wszControllingProp = L"ControllingProperty";
const LPCWSTR g_wszName = L"Name";
const LPCWSTR g_wszOrder = L"Order";
const LPCWSTR g_wszTarget = L"Target";
const LPCWSTR g_wszTmplPropQualifier = L"tmpl_prop_val";
const LPCWSTR g_wszTmplSubstQualifier = L"tmpl_subst_str";
const LPCWSTR g_wszTmplNotNullQualifier = L"notnull";
const LPCWSTR g_wszAssocTmpl = L"Template";
const LPCWSTR g_wszAssocTarget = L"Target";
const LPCWSTR g_wszInfoTmpl = L"Template";
const LPCWSTR g_wszInfoName = L"Name";
const LPCWSTR g_wszInfoTargets =  L"Targets";
const LPCWSTR g_wszInfoBuilders =  L"Builders";
const LPCWSTR g_wszActive =  L"Active";

const LPCWSTR g_wszBldrQuery =
     L"SELECT * FROM MSFT_TemplateBuilder WHERE Template = '";
const LPCWSTR g_wszTmplInfoQuery = 
     L"SELECT * FROM MSFT_TemplateInfo WHERE Template ISA '";

const LPCWSTR g_wszModifyEvent = L"__InstanceModificationEvent";
const LPCWSTR g_wszDeleteEvent = L"__InstanceDeletionEvent";
const LPCWSTR g_wszCreateEvent = L"__InstanceCreationEvent";
const LPCWSTR g_wszTargetInstance = L"TargetInstance";
const LPCWSTR g_wszPreviousInstance = L"PreviousInstance";
const LPCWSTR g_wszErrInfoClass = L"MSFT_TemplateErrorStatus";
const LPCWSTR g_wszErrProp = L"Property";
const LPCWSTR g_wszErrStr = L"ErrorStr";
const LPCWSTR g_wszErrBuilder = L"Builder";
const LPCWSTR g_wszErrTarget = L"Target";
const LPCWSTR g_wszErrExtStatus = L"ExtendedStatus";

const LPCWSTR g_wszTmplEventProvName= L"Microsoft WMI Template Event Provider";

#define SUBST_STRING_DELIM '%'

/****************************************************************************
  Utility Functions
*****************************************************************************/

bool operator< ( const BuilderInfo& rA, const BuilderInfo& rB )
{
    if ( rA.m_ulOrder == rB.m_ulOrder )
    {
        return _wcsicmp( rA.m_wsName, rB.m_wsName ) < 0;
    }
    return rA.m_ulOrder < rB.m_ulOrder;
}

inline HRESULT ClassObjectFromVariant( VARIANT* pv, IWbemClassObject** ppObj )
{
    return V_UNKNOWN(pv)->QueryInterface(IID_IWbemClassObject, (void**)ppObj );
}
   
inline void InfoPathFromTmplPath(WString wsTmplPath, CWbemBSTR& bstrInfoPath)
{    
    WString wsTmp = wsTmplPath.EscapeQuotes();
    bstrInfoPath += g_wszTmplInfo;
    bstrInfoPath += L"=\"";
    bstrInfoPath += wsTmp;
    bstrInfoPath += L"\"";
}

HRESULT GetServicePtr( LPCWSTR wszNamespace, IWbemServices** ppSvc )
{
    HRESULT hr;
    *ppSvc = NULL;

    CWbemPtr<IWbemLocator> pLocator;
    
    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWbemLocator, 
                           (void**)&pLocator );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pLocator->ConnectServer( (LPWSTR)wszNamespace, NULL, NULL, 
                                    NULL, 0, NULL, NULL, ppSvc );
}

//
// This method performs substitution on the specified string.
//

HRESULT FixupString( IWbemClassObject* pTmpl,
                     BuilderInfoSet& rBldrInfoSet,
                     LPCWSTR wszSubstStr,
                     ErrorInfo& rErrInfo,
                     BSTR* pbstrOut )
{
    HRESULT hr;
    
    *pbstrOut = NULL;

    CTextLexSource LexSrc( wszSubstStr );
    CTemplateStrSubstitution Parser( LexSrc, pTmpl, rBldrInfoSet );
    
    hr = Parser.Parse( pbstrOut );
    
    if ( FAILED(hr) )
    {
        if ( Parser.GetTokenText() != NULL )
        {
            rErrInfo.m_wsErrStr = Parser.GetTokenText();
        }
    }

    return hr;
}
 
HRESULT HandleTmplPropQualifier( IWbemClassObject* pTmpl,
                                 BuilderInfoSet& rBldrInfoSet,
                                 VARIANT* pvarArgName,
                                 VARIANT* pvarValue,
                                 ErrorInfo& rErrInfo )
{
    HRESULT hr;

    if ( V_VT(pvarArgName) != VT_BSTR )
    {
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    }
    
    hr = GetTemplateValue( V_BSTR(pvarArgName), 
                           pTmpl, 
                           rBldrInfoSet, 
                           pvarValue );
    
    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrStr = V_BSTR(pvarArgName);
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT HandleTmplSubstQualifier( IWbemClassObject* pTmpl,
                                  BuilderInfoSet& rBldrInfoSet,
                                  CIMTYPE CimType,
                                  VARIANT* pvarSubstStr,
                                  VARIANT* pvarValue,
                                  ErrorInfo& rErrInfo )
{
    HRESULT hr;
    BSTR bstrOut;

    if ( V_VT(pvarSubstStr) == VT_BSTR && CimType == CIM_STRING )
    {
        hr = FixupString( pTmpl, 
                          rBldrInfoSet,
                          V_BSTR(pvarSubstStr), 
                          rErrInfo, 
                          &bstrOut );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        V_VT(pvarValue) = VT_BSTR;
        V_BSTR(pvarValue) = bstrOut;
        
        return hr;
    }

    //
    // we have an array of strings to resolve.
    //

    if ( V_VT(pvarSubstStr) != (VT_BSTR | VT_ARRAY) )
    {
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    }

    CPropSafeArray<BSTR> saSubstStr( V_ARRAY(pvarSubstStr) );
    BSTR* abstrValue;

    V_VT(pvarValue) = VT_ARRAY | VT_BSTR;
    V_ARRAY(pvarValue) = SafeArrayCreateVector(VT_BSTR,0,saSubstStr.Length());
    hr = SafeArrayAccessData( V_ARRAY(pvarValue), (void**)&abstrValue );
    _DBG_ASSERT( SUCCEEDED(hr) );

    for( long i=0; i < saSubstStr.Length(); i++ )
    {    
        hr = FixupString( pTmpl, 
                          rBldrInfoSet,
                          saSubstStr[i], 
                          rErrInfo, 
                          &bstrOut );

        if ( FAILED(hr) )
        {
            break;
        }

        abstrValue[i] = bstrOut;
    }

    SafeArrayUnaccessData( V_ARRAY(pvarValue) );

    if ( FAILED(hr) )
    {
        VariantClear( pvarValue );
        return hr;
    }

    return WBEM_S_NO_ERROR;
}
 
HRESULT GetExistingTargetRefs( IWbemClassObject* pTmplInfo,
                               BuilderInfoSet& rBldrInfoSet,
                               CWStringArray& rOrphanedTargets )  
{
    HRESULT hr;

    CPropVar vBldrNames, vTargetRefs;

    hr = pTmplInfo->Get( g_wszInfoBuilders, 0, &vBldrNames, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vBldrNames.CheckType(VT_BSTR | VT_ARRAY) ))
    {
        return hr;
    }

    hr = pTmplInfo->Get( g_wszInfoTargets, 0, &vTargetRefs, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTargetRefs.CheckType(VT_BSTR | VT_ARRAY) ))
    {
        return hr;
    }

    CPropSafeArray<BSTR> saBldrNames( V_ARRAY(&vBldrNames) );
    CPropSafeArray<BSTR> saTargetRefs( V_ARRAY(&vTargetRefs) );

    if ( saBldrNames.Length() != saTargetRefs.Length() )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // try to match each bldr name with one in the BldrInfoSet 
    //

    for( ULONG i=0; i < saBldrNames.Length(); i++ )
    {
        BuilderInfoSetIter Iter;

        for( Iter = rBldrInfoSet.begin(); Iter != rBldrInfoSet.end(); Iter++ )
        {
            BuilderInfo& rInfo = (BuilderInfo&)*Iter;

            if ( *saTargetRefs[i] == '\0' )
            {
                // 
                // this happens when the an error occurred on instantiation
                // preventing the entire target set to be instantiated.
                // there will be no more refs in the list and there's nothing
                // more that can be done.
                // 
                return WBEM_S_NO_ERROR;
            }

            if ( _wcsicmp( saBldrNames[i], rInfo.m_wsName ) == 0 )
            {
                rInfo.m_wsExistingTargetPath = saTargetRefs[i];
                break;
            }
        }

        if ( Iter == rBldrInfoSet.end() )
        {
            if ( rOrphanedTargets.Add( saTargetRefs[i] ) < 0 )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT GetBuilderInfo( IWbemClassObject* pTmpl,
                        IWbemClassObject* pBuilder,
                        IWbemServices* pDefaultSvc,
                        BuilderInfo& rBldrInfo,
                        ErrorInfo& rErrInfo )
{
    HRESULT hr;

    rBldrInfo.m_pBuilder = pBuilder;

    //
    // Target Object
    //
    
    CPropVar vTarget;
    
    hr = pBuilder->Get( g_wszTarget, 0, &vTarget, NULL, NULL );
    
    if ( FAILED(hr) || FAILED(hr=vTarget.CheckType(VT_UNKNOWN)))
    {
        return hr;
    }

    hr = ClassObjectFromVariant( &vTarget, &rBldrInfo.m_pTarget ); 

    if ( FAILED(hr) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // Builder Name
    //

    CPropVar vName;
    
    hr = pBuilder->Get( g_wszName, 0, &vName, NULL, NULL );
    
    if ( FAILED(hr) || FAILED(hr=vName.CheckType(VT_BSTR)))
    {
        return hr;
    }

    rBldrInfo.m_wsName = V_BSTR(&vName);

    //
    // Builder Order
    //
    
    CPropVar vOrder;
    
    hr = pBuilder->Get( g_wszOrder, 0, &vOrder, NULL, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    if ( V_VT(&vOrder) != VT_NULL )
    {
        if ( FAILED(hr=vOrder.SetType(VT_UI4)) )
        {
            return hr;
        }

        rBldrInfo.m_ulOrder = V_UI4(&vOrder);
    }
    else
    {
        rBldrInfo.m_ulOrder = 0;
    }

    //
    // Target Namespace 
    //

    CPropVar vNamespace, vNamespaceProp;

    hr = pBuilder->Get( g_wszNamespaceProp, 0, &vNamespaceProp, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vNamespaceProp) == VT_NULL )
    {
        //
        // no namespace prop, target will go in this namespace.
        //
        rBldrInfo.m_pTargetSvc = pDefaultSvc;
        return WBEM_S_NO_ERROR;
    }
    else if ( V_VT(&vNamespaceProp) != VT_BSTR )
    {
        return WBEM_E_CRITICAL_ERROR;
    }
        
    //
    // Get the target namespace using the namespace prop
    //

    hr = pTmpl->Get( V_BSTR(&vNamespaceProp), 0, &vNamespace, NULL, NULL );

    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrStr = V_BSTR(&vNamespaceProp);
        return hr;
    }

    if ( V_VT(&vNamespace) == VT_NULL )
    {
        rBldrInfo.m_pTargetSvc = pDefaultSvc;
        return WBEM_S_NO_ERROR;
    }
    else if ( V_VT(&vNamespace) != VT_BSTR )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // there is specified namespace.  obtain a connection to it.
    //

    hr = GetServicePtr( V_BSTR(&vNamespace), &rBldrInfo.m_pTargetSvc );

    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrStr = V_BSTR(&vNamespace);
        return hr;
    }

    rBldrInfo.m_wsTargetNamespace = V_BSTR(&vNamespace);

    return WBEM_S_NO_ERROR;
}

HRESULT GetEffectiveBuilders( IWbemClassObject* pTmpl,
                              IWbemServices* pSvc,
                              BuilderInfoSet& rBldrInfoSet,
                              ErrorInfo& rErrInfo )
{
    HRESULT hr;

    //
    // Get the name of the template class
    //
    
    CPropVar vTmplName;

    hr = pTmpl->Get( g_wszClass, 0, &vTmplName, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTmplName.CheckType( VT_BSTR ) ) )
    {
        return hr;
    }

    //
    // obtain the template builder objects associated with the template.
    //
    
    CWbemPtr<IEnumWbemClassObject> pBldrObjs;
    CWbemBSTR bstrQuery = g_wszBldrQuery;                        
    
    bstrQuery += V_BSTR(&vTmplName);
    bstrQuery += L"'";

    long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;

    hr = pSvc->ExecQuery( CWbemBSTR(g_wszQueryLang), 
                          bstrQuery, 
                          lFlags,
                          NULL, 
                          &pBldrObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }
        
    //
    // go through the builder objects and add them to the BuilderInfoSet. 
    // this data structure orders entries based on the order prop on the 
    // builder objects.
    //

    CWbemPtr<IWbemClassObject> pBuilder;
    CWbemPtr<IWbemClassObject> pTarget;
    ULONG cObjs;

    hr = pBldrObjs->Next( WBEM_INFINITE, 1, &pBuilder, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs == 1 );
     
        CPropVar vControlProp;

        // 
        // ignore builder objects where the value of any controlling 
        // property is either null or is a boolean and is false.
        //

        hr = pBuilder->Get(g_wszControllingProp, 0, &vControlProp, NULL, NULL);

        if ( FAILED(hr) )
        {
            return hr;
        }

        BOOL bUseBuilder = TRUE;

        if ( V_VT(&vControlProp) != VT_NULL )
        {
            if ( V_VT(&vControlProp) != VT_BSTR )
            {
                return WBEM_E_CRITICAL_ERROR;
            }

            CPropVar vControl;

            // 
            // now get the property from the template args using this name.
            //

            hr = pTmpl->Get( V_BSTR(&vControlProp), 0, &vControl, NULL, NULL );

            if ( FAILED(hr) )
            {
                rErrInfo.m_wsErrStr = V_BSTR(&vControlProp);
                rErrInfo.m_pBuilder = pBuilder;
                return hr;
            }
            
            if ( V_VT(&vControl) == VT_NULL || 
                 ( V_VT(&vControl) == VT_BOOL && 
                   V_BOOL(&vControl) == VARIANT_FALSE ) )
            {
                bUseBuilder = FALSE;
            }
        }

        if ( bUseBuilder )
        {
            BuilderInfo BldrInfo;
            
            hr = GetBuilderInfo( pTmpl, pBuilder, pSvc, BldrInfo, rErrInfo );
            
            if ( FAILED(hr) )
            {
                return hr;
            }
            
            rBldrInfoSet.insert( BldrInfo );
        }

        pBuilder.Release();

        hr = pBldrObjs->Next( WBEM_INFINITE, 1, &pBuilder, &cObjs );
    }

    return hr;
}

HRESULT ResolveParameterizedProps( IWbemClassObject* pTmpl,
                                   BuilderInfo& rBuilderInfo,
                                   BuilderInfoSet& rBldrInfoSet,
                                   ErrorInfo& rErrInfo )
{
    HRESULT hr;

    IWbemClassObject* pTarget = rBuilderInfo.m_pTarget;

    //
    // enumerate all props looking for ones with the tmpl qualifiers.
    // 

    hr = pTarget->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CIMTYPE CimType;
    CWbemBSTR bsProp;
    CPropVar vProp;

    hr = pTarget->Next( 0, &bsProp, &vProp, &CimType, NULL );

    while( hr == WBEM_S_NO_ERROR )
    {   
        CWbemPtr<IWbemQualifierSet> pQualSet;

        hr = pTarget->GetPropertyQualifierSet( bsProp, &pQualSet );
 
        if ( FAILED(hr) )
        {
            break;
        }

        CPropVar vQProp;

        hr = pQualSet->Get( g_wszTmplPropQualifier, 0, &vQProp, NULL );

        if ( hr == WBEM_S_NO_ERROR )
        {
            VariantClear( &vProp );

            hr = HandleTmplPropQualifier( pTmpl, 
                                          rBldrInfoSet,
                                          &vQProp, 
                                          &vProp, 
                                          rErrInfo );
 
            pQualSet->Delete( g_wszTmplPropQualifier );
        }
        else if ( hr == WBEM_E_NOT_FOUND )
        {
            hr = pQualSet->Get( g_wszTmplSubstQualifier, 0, &vQProp, NULL );

            if ( hr == WBEM_S_NO_ERROR )
            {
                VariantClear( &vProp );

                hr = HandleTmplSubstQualifier( pTmpl, 
                                               rBldrInfoSet,
                                               CimType, 
                                               &vQProp, 
                                               &vProp, 
                                               rErrInfo );

                pQualSet->Delete( g_wszTmplSubstQualifier );
            }
            else if ( hr == WBEM_E_NOT_FOUND )
            {
                hr = WBEM_S_NO_ERROR;
            }
        }
        
        if ( FAILED(hr) )
        {
            break;
        }

        // 
        // only assign if not null.
        //
        if ( V_VT(&vProp) != VT_NULL )
        {
            _DBG_ASSERT( V_VT(&vProp) != VT_EMPTY );

            hr = pTarget->Put( bsProp, 0, &vProp, 0 );
            
            if ( FAILED(hr) )
            {
                break;
            }

            VariantClear( &vProp );
        }

        bsProp.Free();

        hr = pTarget->Next( 0, &bsProp, &vProp, &CimType, NULL );
    }

    if ( FAILED(hr) )
    {
        rErrInfo.m_wsErrProp = bsProp;
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CreateTargetAssociation( LPCWSTR wszTmplRef,
                                 LPCWSTR wszTargetRef,
                                 IWbemClassObject* pTmplAssocClass,
                                 IWbemServices* pSvc )
{
    HRESULT hr;

    CWbemPtr<IWbemClassObject> pAssoc;
    hr = pTmplAssocClass->SpawnInstance( 0, &pAssoc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    VARIANT var;
    
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (BSTR)wszTmplRef;
    
    hr = pAssoc->Put( g_wszAssocTmpl, 0, &var, NULL ); 
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    V_BSTR(&var) = (BSTR)wszTargetRef;

    hr = pAssoc->Put( g_wszAssocTarget, 0, &var, NULL ); 
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // before creating the association, see if one already exists.  
    // Again, this is a hack optimization to get around the slowness of
    // core and ess on instance operation events for static instances.

    //
    // BEGINHACK
    //

    CPropVar vRelpath;

    hr = pAssoc->Get( g_wszRelpath, 0, &vRelpath, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vRelpath.CheckType( VT_BSTR ) ) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pExisting;

    hr = pSvc->GetObject( V_BSTR(&vRelpath), 0, NULL, &pExisting, NULL );

    if ( hr == WBEM_S_NO_ERROR )
    {
        return hr;
    }

    //
    // ENDHACK
    //

    return pSvc->PutInstance( pAssoc, 0, NULL, NULL );
}

/****************************************************************************
  CTemplateProvider
*****************************************************************************/

HRESULT CTemplateProvider::GetErrorObj( ErrorInfo& rInfo, 
                                        IWbemClassObject** ppErrObj )
{
    HRESULT hr;
    VARIANT var;

    CWbemPtr<IWbemClassObject> pErrObj;

    hr = m_pErrorInfoClass->SpawnInstance( 0, &pErrObj );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    if ( rInfo.m_wsErrProp.Length() > 0 )
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = rInfo.m_wsErrProp;

        hr = pErrObj->Put( g_wszErrProp, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_wsErrStr.Length() > 0 )
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = rInfo.m_wsErrStr;

        hr = pErrObj->Put( g_wszErrStr, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_pBuilder != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = rInfo.m_pBuilder;

        hr = pErrObj->Put( g_wszErrBuilder, 0, &var, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_pTarget != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = rInfo.m_pTarget;

        hr = pErrObj->Put( g_wszErrTarget, 0, &var, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    if ( rInfo.m_pExtErr != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = rInfo.m_pExtErr;
        
        hr = pErrObj->Put( g_wszErrExtStatus, 0, &var, NULL );
    }

    pErrObj->AddRef();
    *ppErrObj = pErrObj;

    return hr;
}

HRESULT CTemplateProvider::ValidateTemplate( IWbemClassObject* pTmpl, 
                                             ErrorInfo& rErrInfo )
{
    HRESULT hr;

    //
    // for now, we need just need to check that 'notnull' props don't have
    // null values.
    // 

    //
    // first need to fetch class object.
    //

    CPropVar vClassName;
    CWbemPtr<IWbemClassObject> pTmplClass;

    hr = pTmpl->Get( g_wszClass, 0, &vClassName, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vClassName.CheckType( VT_BSTR ) ) )
    {
        return hr;
    }
      
    hr = m_pSvc->GetObject(V_BSTR(&vClassName), 0, NULL, &pTmplClass, NULL);
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pTmplClass->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemBSTR bsProp;
    
    hr = pTmplClass->Next( 0, &bsProp, NULL, NULL, NULL );

    while( hr == WBEM_S_NO_ERROR )
    {   
        CWbemPtr<IWbemQualifierSet> pQualSet;

        hr = pTmplClass->GetPropertyQualifierSet( bsProp, &pQualSet );
 
        if ( FAILED(hr) )
        {
            break;
        }

        hr = pQualSet->Get( g_wszTmplNotNullQualifier, 0, NULL, NULL );

        if ( hr == WBEM_S_NO_ERROR )
        {
            VARIANT varValue;

            hr = pTmpl->Get( bsProp, 0, &varValue, NULL, NULL );
            
            if ( FAILED(hr) )
            {
                break;
            }

            if ( V_VT(&varValue) == VT_NULL )
            {
                rErrInfo.m_wsErrStr = bsProp;
                return WBEM_E_ILLEGAL_NULL;
            }

            VariantClear( &varValue );
        }
        else if ( hr != WBEM_E_NOT_FOUND )
        {
            break;
        }

        bsProp.Free();

        hr = pTmplClass->Next( 0, &bsProp, NULL, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CTemplateProvider::Init( IWbemServices* pSvc, 
                                 LPWSTR wszNamespace,
                                 IWbemProviderInitSink* pInitSink )
{
    ENTER_API_CALL

    HRESULT hr;
    
    hr = pSvc->GetObject( CWbemBSTR(g_wszTmplInfo), 
                          0, 
                          NULL, 
                          &m_pTmplInfoClass, 
                          NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszTargetAssoc), 
                          0, 
                          NULL, 
                          &m_pTargetAssocClass, 
                          NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszModifyEvent), 
                          0, 
                          NULL, 
                          &m_pModifyEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszCreateEvent), 
                          0, 
                          NULL, 
                          &m_pCreateEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszDeleteEvent), 
                          0, 
                          NULL, 
                          &m_pDeleteEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pSvc->GetObject( CWbemBSTR(g_wszErrInfoClass), 
                          0, 
                          NULL, 
                          &m_pErrorInfoClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }


    m_pSvc = pSvc;
    m_wsNamespace = wszNamespace;

    //
    // register our decoupled event provider 
    //

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Register( 0,
                           NULL,
                           NULL,
                           NULL,
                           wszNamespace,
                           g_wszTmplEventProvName,
                           NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the decoupled event sink
    //

    hr = m_pDES->GetSink( 0, NULL, &m_pEventSink );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // also need to store namespace with server name.
    //

    WCHAR awchBuff[256];
    ULONG cBuff = 256;

    BOOL bRes = GetComputerNameW( awchBuff, &cBuff );
    
    if ( FAILED(hr) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    m_wsFullNamespace = L"\\\\";
    m_wsFullNamespace += awchBuff;
    m_wsFullNamespace += L"\\";
    m_wsFullNamespace += m_wsNamespace;

    return pInitSink->SetStatus( WBEM_S_INITIALIZED , 0 );

    EXIT_API_CALL
}


HRESULT CTemplateProvider::StoreTmplInfo( BSTR bstrTmplPath,
                                          IWbemClassObject* pTmpl,
                                          BuilderInfoSet& rBldrInfoSet )     
{
    HRESULT hr;
    VARIANT var;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    //
    // create both the target and builder safe arrays. We need to 
    // discover how many builders actually have paths for created targets 
    // because those are the only target and builder info elements that we 
    // want to store.
    // 

    int cElem = 0;
    BuilderInfoSetIter Iter;

    for( Iter=rBldrInfoSet.begin(); Iter!=rBldrInfoSet.end(); Iter++)
    {
        BuilderInfo& rInfo = (BuilderInfo&)*Iter;

        if ( rInfo.m_wsNewTargetPath.Length() > 0 )
        {
            cElem++;
        }
    }
    
    SAFEARRAY *psaTargets, *psaBuilders; 

    psaTargets = SafeArrayCreateVector( VT_BSTR, 0, cElem );

    if ( psaTargets == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    psaBuilders = SafeArrayCreateVector( VT_BSTR, 0, cElem );

    if ( psaBuilders == NULL )
    {
        SafeArrayDestroy( psaTargets );
        return WBEM_E_OUT_OF_MEMORY;
    }

    CPropVar vTargets, vBuilders;
    V_VT(&vTargets) = VT_BSTR | VT_ARRAY;
    V_VT(&vBuilders) = VT_BSTR | VT_ARRAY;
    V_ARRAY(&vTargets) = psaTargets;
    V_ARRAY(&vBuilders) = psaBuilders;

    //
    // copy the refs into the arrays.
    //

    CPropSafeArray<BSTR> saTargets( psaTargets );
    CPropSafeArray<BSTR> saBuilders( psaBuilders );

    int iElem = 0;

    for( Iter=rBldrInfoSet.begin(); Iter!=rBldrInfoSet.end(); Iter++ )
    {
        BuilderInfo& rInfo = (BuilderInfo&)*Iter;

        if ( rInfo.m_wsNewTargetPath.Length() > 0 )
        {
            _DBG_ASSERT( iElem < cElem );

            saBuilders[iElem] = SysAllocString( rInfo.m_wsName);
            saTargets[iElem] = SysAllocString( rInfo.m_wsNewTargetPath );

            if ( saBuilders[iElem] == NULL || saTargets[iElem] == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            iElem++;
        }
    }
    
    //
    // set the tmpl info props
    //

    hr = m_pTmplInfoClass->SpawnInstance( 0, &pTmplInfo );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    hr = pTmplInfo->Put( g_wszInfoTargets, 0, &vTargets, 0 );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pTmplInfo->Put( g_wszInfoBuilders, 0, &vBuilders, 0 );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = bstrTmplPath;

    hr = pTmplInfo->Put( g_wszInfoName, 0, &var, 0 );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pTmpl;
    
    hr = pTmplInfo->Put( g_wszInfoTmpl, 0, &var, 0 );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
 
    return m_pSvc->PutInstance( pTmplInfo, 0, NULL, NULL );
}    


HRESULT CTemplateProvider::FireIntrinsicEvent( IWbemClassObject* pClass,
                                               IWbemClassObject* pTarget, 
                                               IWbemClassObject* pPrev )
{
    HRESULT hr;

    //  
    // Spawn an instance
    //

    CWbemPtr<IWbemClassObject> pEvent;
    hr = pClass->SpawnInstance( 0, &pEvent );
    
    if( FAILED(hr) )
    {
        return hr;
    }

    //
    // Set target instance
    //

    VARIANT var;
 
    _DBG_ASSERT( pTarget != NULL );

    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pTarget;

    hr = pEvent->Put( g_wszTargetInstance, 0, &var, 0 );
    
    if( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // Set previous instance
    //

    if( pPrev != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = pPrev;
        
        hr = pEvent->Put( g_wszPreviousInstance, 0, &var, 0);
        
        if( FAILED(hr) )
        {
            return hr;
        }
    }

    //  
    // Fire it off
    //

    return m_pEventSink->Indicate( 1, &pEvent );
}

HRESULT CTemplateProvider::CheckOptimization( BuilderInfo& rBldrInfo )
{
    HRESULT hr;

    //
    // first fetch any existing object, if not there, then no optimization
    // can be performed.  
    //

    if ( rBldrInfo.m_wsExistingTargetPath.Length() == 0 )
    {
        return WBEM_S_FALSE;
    }

    IWbemClassObject* pTarget = rBldrInfo.m_pTarget;
    
    //
    // now fetch the existing object. 
    //

    
    CWbemPtr<IWbemClassObject> pOldTarget;
    
    hr = rBldrInfo.m_pTargetSvc->GetObject( rBldrInfo.m_wsExistingTargetPath, 
                                            0, 
                                            NULL, 
                                            &pOldTarget, 
                                            NULL );
    if ( FAILED(hr) )
    {
        //
        // it doesn't exist.  normally this shouldn't happen, but someone 
        // may have removed the object behind the scenes. 
        // 
        return WBEM_S_FALSE;
    }

    //
    // now we need to see if the target object has key holes.  If so, then 
    // we will steal the values from the existing object.  This is acceptable
    // because either the target object will assume the identity of the 
    // existing object or the existing object will be orphaned and removed.
    // We want to try to avoid orphan-ing objects if possible so we try to 
    // reuse identity where appropriate.
    //

    hr = pTarget->BeginEnumeration( WBEM_FLAG_KEYS_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemBSTR bsKey;
    CPropVar vKey;

    hr = pTarget->Next( 0, &bsKey, &vKey, NULL, NULL );

    while( hr == WBEM_S_NO_ERROR )
    {
        if ( V_VT(&vKey) == VT_NULL )
        {
            //
            // don't need to check values here. will catch in CompareTo().
            // the two instances may not even be of the same class, so 
            // don't error check here.  
            //
            pOldTarget->Get( bsKey, 0, &vKey, 0, NULL );
            pTarget->Put( bsKey, 0, &vKey, NULL );
        }

        bsKey.Free();
        VariantClear(&vKey);

        hr = pTarget->Next( 0, &bsKey, &vKey, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pOldTarget->InheritsFrom( g_wszIndicationRelated );

    if ( hr == WBEM_S_NO_ERROR )
    {
        //
        // This is a major HACK, but then so is this whole function -  
        // Core should be fast enough to handle a 'redundant' PutInstance().  
        // Anyways, we have to be able to perform the CompareTo and 
        // ignore system props as well as the SID on Event Registration 
        // classes.  CompareTo will handle the system props, but it won't 
        // treat the creator sid as a system prop.
        //

        VARIANT varSid;
        PSID pOldSid;        
        HANDLE hToken;
        DWORD dwLen;
        BOOL bRes;
        BYTE achCallerSid[512];

        //
        // first get the Sid of the caller. Need to compare this with the
        // one we obtain from the object.
        //

        bRes = OpenThreadToken( GetCurrentThread(), 
                                TOKEN_QUERY, 
                                TRUE, 
                                &hToken );
        if ( !bRes ) 
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        bRes = GetTokenInformation( hToken, 
                                    TokenUser, 
                                    achCallerSid,
                                    512,
                                    &dwLen );
        if ( !bRes )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        hr = pOldTarget->Get( g_wszCreatorSid, 0, &varSid, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        _DBG_ASSERT( V_VT(&varSid) == (VT_ARRAY | VT_UI1) );
        hr = SafeArrayAccessData( V_ARRAY(&varSid), &pOldSid );
        _DBG_ASSERT( SUCCEEDED(hr) );

        bRes = EqualSid( pOldSid, PSID_AND_ATTRIBUTES(achCallerSid)->Sid );
        
        SafeArrayUnaccessData( V_ARRAY(&varSid) );
        VariantClear( &varSid );

        if ( !bRes )
        {
            return WBEM_S_FALSE;
        }

        //
        // Sids are the same, NULL out the sid prop so CompareTo() will work.
        //
    
        V_VT(&varSid) = VT_NULL;
        
        hr = pOldTarget->Put( g_wszCreatorSid, 0, &varSid, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pTarget->Put( g_wszCreatorSid, 0, &varSid, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // now compare them to see if they are the same ...
    //

    long lFlags = WBEM_FLAG_IGNORE_OBJECT_SOURCE |
                  WBEM_FLAG_IGNORE_QUALIFIERS |
                  WBEM_FLAG_IGNORE_FLAVOR |
                  WBEM_FLAG_IGNORE_CASE ;

    hr = pOldTarget->CompareTo( lFlags, pTarget );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( hr == WBEM_S_DIFFERENT )
    {
        return WBEM_S_FALSE;
    }

    return WBEM_S_NO_ERROR;
}


//
// wszTmplPath is assumed to be Relative. 
//

HRESULT CTemplateProvider::DeleteTargets( LPCWSTR wszTmplPath,
                                          LPWSTR* awszTargetPaths,
                                          ULONG cTargetPaths )
{    
    HRESULT hr;

    //
    // Make sure we go in reverse order, since this array was orinally 
    // built up during construction of these objects (which happens in 
    // ascending order).
    //

    //
    // Now construct the path for the association inst that will accompany
    // the target.  This assoc allows us to go from the target to 
    // the tmpl. We want to delete this along with our target.
    // 

    //
    // The path that identifies the target is always relative.  
    // this is because the assoc inst will always live in the same namespace
    // as the target. The path that identifies the tmpl is always 
    // fully qualified.  
    // 

    WString wsTmplPath = m_wsFullNamespace;
    wsTmplPath += L":";
    wsTmplPath += wszTmplPath;
    
    WString wsTmplRelPath = wszTmplPath;
    WString wsEscTmplRelPath = wsTmplRelPath.EscapeQuotes();
    WString wsEscTmplPath = wsTmplPath.EscapeQuotes();

    for( long i=cTargetPaths-1; i >= 0; i-- )
    {
        //
        // start constructing the assoc path.  It will depend on whether
        // the assoc lives in the same or another namespace.
        //

        CWbemBSTR bstrAssocPath = g_wszTargetAssoc;
    
        bstrAssocPath += L".";
        bstrAssocPath += g_wszAssocTmpl;
        bstrAssocPath += L"=\"";

        //
        // determine if the ref is in our namespace. If not then we 
        // have to get the svc ptr for that namespace. Make sure that
        // the path ends up being relative though.
        // 

        CRelativeObjectPath RelPath;

        if ( !RelPath.Parse( (LPWSTR)awszTargetPaths[i] ) )
        {
            // 
            // this should never happen (unless the db is corrupted)
            //
            return WBEM_E_INVALID_OBJECT_PATH;
        }

        CWbemPtr<IWbemServices> pSvc = m_pSvc;

        LPCWSTR wszNamespace = RelPath.m_pPath->GetNamespacePart();

        if ( wszNamespace == NULL )
        {
            bstrAssocPath += wsEscTmplRelPath;
        }
        else
        {
            bstrAssocPath += wsEscTmplPath;

            hr = GetServicePtr( wszNamespace, &pSvc );
            
            if ( FAILED(hr) )
            {
                return hr;            
            }
        }

        CWbemBSTR bstrRelPath = RelPath.GetPath();
        
        hr = pSvc->DeleteInstance( bstrRelPath, 0, NULL, NULL ); 
        
        //
        // don't check ... try to delete as many as possible.
        //

        //
        // finish constructing the path for the association now. 
        //
        
        bstrAssocPath += L"\",";
        bstrAssocPath += g_wszAssocTarget;
        bstrAssocPath += L"=\"";
        
        WString tmp2 = RelPath.GetPath();
        WString tmp = tmp2.EscapeQuotes();

        bstrAssocPath += tmp;
        bstrAssocPath += L"\"";

        //
        // also delete the association as well... 
        //

        hr = pSvc->DeleteInstance( bstrAssocPath, 0, NULL, NULL );

        //
        // again, don't check ..
        //
    }

    return WBEM_S_NO_ERROR;
}
 
HRESULT CTemplateProvider::DeleteInstance( BSTR bstrTmplPath, 
                                           IWbemObjectSink* pResponseHndlr )
{
    ENTER_API_CALL

    HRESULT hr;
    CWbemBSTR bstrInfoPath;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Get the associated tmpl info object.
    //

    CRelativeObjectPath RelPath;

    if ( !RelPath.Parse( bstrTmplPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    InfoPathFromTmplPath( RelPath.GetPath(), bstrInfoPath );

    hr = m_pSvc->GetObject( bstrInfoPath, 0, NULL, &pTmplInfo, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropVar vTargetPaths;
    
    hr = pTmplInfo->Get( g_wszInfoTargets, 0, &vTargetPaths, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTargetPaths.CheckType(VT_ARRAY|VT_BSTR)) )
    {
        return hr;
    }

    CPropSafeArray<BSTR> saTargetPaths( V_ARRAY(&vTargetPaths) );

    //
    // delete the tmpl info object and all of its associated instances.
    //
    
    hr = DeleteTargets( RelPath.GetPath(), 
                        saTargetPaths.GetArray(), 
                        saTargetPaths.Length() );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->DeleteInstance( bstrInfoPath, 0, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now get the tmpl obj from the info obj. Use this to send an 
    // intrinsic event ...
    //

    CPropVar vTmpl;
    CWbemPtr<IWbemClassObject> pTmpl;

    hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vTmpl, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    ClassObjectFromVariant( &vTmpl, &pTmpl );

    hr = FireIntrinsicEvent( m_pDeleteEventClass, pTmpl, NULL );

    return pResponseHndlr->SetStatus( WBEM_STATUS_COMPLETE, hr, NULL, NULL );

    EXIT_API_CALL
}

HRESULT CTemplateProvider::GetObject( BSTR bstrTmplPath, 
                                      IWbemObjectSink* pResHndlr )
{
    ENTER_API_CALL

    HRESULT hr;
    VARIANT var;
    CWbemBSTR bstrInfoPath;
    CWbemPtr<IWbemClassObject> pTmpl;
    CWbemPtr<IWbemClassObject> pTmplInfo;
    
    //
    // Get the associated tmpl info object 
    //

    CRelativeObjectPath RelPath;

    if ( !RelPath.Parse( bstrTmplPath ) )
    {
        return WBEM_E_INVALID_OBJECT;
    }

    InfoPathFromTmplPath( RelPath.GetPath(), bstrInfoPath );

    hr = m_pSvc->GetObject( bstrInfoPath, 0, NULL, &pTmplInfo, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Get the embedded tmpl object from it. 
    //

    CPropVar vTmpl;

    hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vTmpl, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    ClassObjectFromVariant( &vTmpl, &pTmpl );

    hr = pResHndlr->Indicate( 1, &pTmpl );

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, hr, NULL, NULL );

    EXIT_API_CALL
}

HRESULT CTemplateProvider::PutTarget( IWbemClassObject* pTmpl, 
                                      BSTR bstrTmplPath,
                                      BuilderInfo& rBldrInfo,
                                      ErrorInfo& rErrInfo )
{ 
    HRESULT hr;

    //
    // See if the activation even needs to be performed.
    //
    
    hr = CheckOptimization( rBldrInfo );

    if ( hr == WBEM_S_NO_ERROR )
    {
        rBldrInfo.m_wsNewTargetPath = rBldrInfo.m_wsExistingTargetPath;
        return hr;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }
       
    CWbemPtr<IWbemCallResult> pCallResult;
          
    hr = rBldrInfo.m_pTargetSvc->PutInstance( rBldrInfo.m_pTarget, 
                                              WBEM_FLAG_RETURN_IMMEDIATELY, 
                                              NULL, 
                                              &pCallResult );            
    if ( SUCCEEDED(hr) )
    {
        HRESULT hr2 = pCallResult->GetCallStatus( INFINITE, &hr );

        if ( FAILED(hr2) )
        {
            return WBEM_E_CRITICAL_ERROR;
        }
    }
       
    if ( FAILED(hr) )
    {
        // 
        // see if there is an accompanying error object.
        //
        
        CWbemPtr<IErrorInfo> pErrorInfo;
        
        if ( ::GetErrorInfo( 0, &pErrorInfo ) == S_OK )
        {
            pErrorInfo->QueryInterface( IID_IWbemClassObject,
                                        (void**)&rErrInfo.m_pExtErr );
        }
        
        return hr;
    }
    
    CWbemBSTR bsTargetPath;

    //
    // if the provider doesn't retrun a path, then we'll get it from
    // from the tmpl object (which may not always be possible either)
    // if neither approach works, then return error.
    //

    hr = pCallResult->GetResultString( WBEM_INFINITE, &bsTargetPath );
    
    if ( FAILED(hr) )
    {
        CPropVar vRelpath;

        hr = pTmpl->Get( g_wszRelpath, 0, &vRelpath, NULL, NULL );

        if ( FAILED(hr) )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        if ( FAILED(hr=vRelpath.CheckType( VT_BSTR) ) )
        {
            return hr;
        }

        bsTargetPath = V_BSTR(&vRelpath);
    }

    CRelativeObjectPath TargetPath;
    
    if ( !TargetPath.Parse( bsTargetPath ) )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    rBldrInfo.m_wsNewTargetPath = TargetPath.GetPath();

    //
    // now prefix targetpath with the appropriate namespace if necessary.  
    // This is part of the normalization process. 
    // This will only occur if there a namespace prop on the 
    // builder object.
    // 
    
    //
    // here we will also prepare the necessary paths for the association
    // which accompanies the template instance.  This assoc allows us to
    // go from the instance back to the template instance.  This assoc
    // will live in the same namespace as the instance. 
    //
    
    // 
    // if the assoc is in a different namespace than our namespace
    // we must make the tmpl path fully qualified.
    //
    
    CWbemPtr<IWbemClassObject> pTargetAssocClass;
    WString wsTmplPath;
    WString wsTargetPath;
    
    if ( rBldrInfo.m_wsTargetNamespace.Length() == 0  ) 
    {           
        //
        // when local namespace is used
        //
        pTargetAssocClass = m_pTargetAssocClass;
        wsTargetPath = TargetPath.GetPath();
        wsTmplPath = bstrTmplPath;
    }
    else
    {
        hr = rBldrInfo.m_pTargetSvc->GetObject( CWbemBSTR(g_wszTargetAssoc), 
                                                0, 
                                                NULL,
                                                &pTargetAssocClass, 
                                                NULL );
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        wsTargetPath += rBldrInfo.m_wsTargetNamespace;
        wsTargetPath += L":";
        wsTargetPath += TargetPath.GetPath();
        
        wsTmplPath = m_wsFullNamespace;
        wsTmplPath += L":";
        wsTmplPath += bstrTmplPath;
    }
    
    //
    // now create the static association between the tmpl object and 
    // tmpl. The reason for the static association is so we can assoc 
    // in the direction of template object --> template.  Remember that
    // we don't need the fully qualified path to the inst in the 
    // assoc obj since it will reside in the same namespace.
    //
    
    hr = CreateTargetAssociation( (LPCWSTR)wsTmplPath,
                                  TargetPath.GetPath(), 
                                  pTargetAssocClass,
                                  rBldrInfo.m_pTargetSvc );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateProvider::DeriveTmplInfoPath( IWbemClassObject* pTmpl,
                                               CWbemBSTR& rbstrTmplInfoPath, 
                                               CWbemBSTR& rbstrTmplPath )
{
    HRESULT hr;
    VARIANT var;

    hr = pTmpl->Get( g_wszRelpath, 0, &var, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&var) == VT_NULL )
    {
        // 
        // generate a key here ..
        //
        
        GUID guid;
        CoCreateGuid( &guid );
        CWbemBSTR bstrGuid( 256 );

        if ( StringFromGUID2( guid, bstrGuid, 256 ) == 0 )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        // now go through key props ... 
        
        hr = pTmpl->BeginEnumeration( WBEM_FLAG_KEYS_ONLY  );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CWbemBSTR bstrName;
        CIMTYPE CimType;
        hr = pTmpl->Next( 0, &bstrName, NULL, &CimType, NULL );

        while( hr == WBEM_S_NO_ERROR )
        {
            if ( CimType != CIM_STRING )
            {       
                return WBEM_E_INVALID_OBJECT;
            }

            VARIANT var2;
            V_VT(&var2) = VT_BSTR;
            V_BSTR(&var2) = bstrGuid;
  
            hr = pTmpl->Put( bstrName, 0, &var2, NULL );
            
            if ( FAILED(hr) )
            {
                return hr;
            }

            bstrName.Free();
            hr = pTmpl->Next( 0, &bstrName, NULL, &CimType, NULL );
        }

        hr = pTmpl->Get( g_wszRelpath, 0, &var, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    _DBG_ASSERT( V_VT(&var) == VT_BSTR );

    //
    // normalize the path
    //

    CRelativeObjectPath RelPath;
    BOOL bRes = RelPath.Parse( V_BSTR(&var) );

    VariantClear( &var );

    if ( !bRes )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    rbstrTmplPath = RelPath.GetPath();

    InfoPathFromTmplPath( (BSTR)rbstrTmplPath, rbstrTmplInfoPath );

    return WBEM_S_NO_ERROR;
}

HRESULT CTemplateProvider::PutInstance( IWbemClassObject* pTmpl, 
                                        long lFlags,
                                        IWbemObjectSink* pHndlr )
{
    ENTER_API_CALL

    HRESULT hr;
    ErrorInfo ErrInfo;
    CWbemPtr<IWbemClassObject> pErrObj;
    CWbemBSTR bsTmplPath;
    
    hr = PutInstance( pTmpl, lFlags, bsTmplPath, ErrInfo );

    if ( FAILED(hr) )
    {
        GetErrorObj( ErrInfo, &pErrObj );
    }

    return pHndlr->SetStatus(WBEM_STATUS_COMPLETE, hr, bsTmplPath, pErrObj); 

    EXIT_API_CALL
}

HRESULT CTemplateProvider::PutInstance( IWbemClassObject* pTmpl, 
                                        long lFlags,
                                        CWbemBSTR& rbsTmplPath,
                                        ErrorInfo& rErrInfo )
{
    HRESULT hr;

    CWbemPtr<IWbemClassObject> pErrObj;

    lFlags &= 0x3; // only care about create/update flags...
 
    hr = CoImpersonateClient();

    if ( FAILED(hr) )
    {
        return hr;
    }
 
    //
    // before doing anything else, validate the template ..
    //

    hr = ValidateTemplate( pTmpl, rErrInfo );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // obtain the normalized path to the template and while we're at it,
    // form the path of the associated template info object.
    //

    CWbemBSTR bsTmplInfoPath;

    hr = DeriveTmplInfoPath( pTmpl, bsTmplInfoPath, rbsTmplPath );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // see if there is already a tmpl obj existing
    //

    CWbemPtr<IWbemClassObject> pTmplInfo;

    hr = m_pSvc->GetObject( bsTmplInfoPath, 0, NULL, &pTmplInfo, NULL );

    //
    // check flags
    //

    if ( SUCCEEDED(hr) )
    {
        if ( lFlags & WBEM_FLAG_CREATE_ONLY )
        {
            return WBEM_E_ALREADY_EXISTS;
        }
    }
    else if ( hr == WBEM_E_NOT_FOUND )
    {
        if ( lFlags & WBEM_FLAG_UPDATE_ONLY )
        {
            return WBEM_E_NOT_FOUND;
        }
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now see if the active property is set, if so, activate.
    // if this fails then the template is not derived from TemplateBase
    // ( which is allowed ).
    //

    CPropVar vActive;

    hr = pTmpl->Get( g_wszActive, 0, &vActive, NULL, NULL );

    if ( FAILED(hr) )
    {
        V_VT(&vActive) = VT_BOOL;
        V_BOOL(&vActive) = VARIANT_TRUE;
    }
    else if ( FAILED(hr=vActive.CheckType( VT_BOOL ) ) )
    {
        return hr;
    }

    BuilderInfoSet BldrInfoSet;
    
    if ( V_BOOL(&vActive) == VARIANT_TRUE )
    {
        // 
        // we first want to establish the effective template builder objects.
        // These are the bldrs that do not have a controlling tmpl arg or 
        // ones that do and it is true or not null.
        //

        hr = GetEffectiveBuilders( pTmpl, m_pSvc, BldrInfoSet, rErrInfo );

        if ( FAILED(hr) )
        { 
            return hr;
        }
    }

    //
    // get any existing references and while we're at it determine the
    // oprhaned targets.  Note that there is more than one way for a target
    // to be orphaned.  This can happen when a previously active builder 
    // becomes inactive for whatever reason.  It can also happen when the 
    // the same builder puts an object that has different key values than the
    // one it previously put.  In the next step we will only detect the former.
    // When we actually put the target, we will check for the latter case and
    // add it to the orphaned targets if necessary.
    // 

    CWStringArray awsOrphanedTargets;
    
    if ( pTmplInfo != NULL )
    {
        hr = GetExistingTargetRefs( pTmplInfo, 
                                    BldrInfoSet, 
                                    awsOrphanedTargets );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // activate each builder
    //
    
    BuilderInfoSetIter Iter;

    for( Iter = BldrInfoSet.begin(); Iter != BldrInfoSet.end(); Iter++ )
    {
        BuilderInfo& rBldrInfo = (BuilderInfo&)*Iter;
        
        //
        // first resolve the properties of the target object.
        //

        hr = ResolveParameterizedProps( pTmpl, 
                                        rBldrInfo, 
                                        BldrInfoSet, 
                                        rErrInfo );
        
        if ( SUCCEEDED(hr) )
        {
            hr = PutTarget( pTmpl, rbsTmplPath, rBldrInfo, rErrInfo );
        }

        if ( SUCCEEDED(hr) )
        {
            //
            // see if any previous target was orphaned in this last step.
            // we are guaranteed that the refs here are already normalized,
            // so o.k. to do a string compare.
            //
            
            if( rBldrInfo.m_wsExistingTargetPath.Length() != 0 && 
                rBldrInfo.m_wsNewTargetPath.Length() != 0 && 
                _wcsicmp( rBldrInfo.m_wsExistingTargetPath, 
                          rBldrInfo.m_wsNewTargetPath ) != 0 )
            {
                awsOrphanedTargets.Add( rBldrInfo.m_wsExistingTargetPath );
            }
        }

        if ( FAILED(hr) )
        {
            rErrInfo.m_pBuilder = rBldrInfo.m_pBuilder;
            rErrInfo.m_pTarget = rBldrInfo.m_pTarget;
            break;
        }
    }

    //
    // delete the orphaned instances
    //
    
    LPCWSTR* awszOrhanedTargets = awsOrphanedTargets.GetArrayPtr();
    ULONG cOrhanedTargets = awsOrphanedTargets.Size();    
    DeleteTargets( rbsTmplPath, (LPWSTR*)awszOrhanedTargets, cOrhanedTargets );

    // 
    // store the information about the instatiated objs in the 
    // tmpl info object.  We do this regardless of the outcome of 
    // instantiating targets.  This is so the user can see how far they
    // got in the template, and also, so we can clean the existing instances
    // up every time.
    //

    HRESULT hr2 = StoreTmplInfo( rbsTmplPath, pTmpl, BldrInfoSet );

    if ( FAILED(hr) )
    {
        return hr;
    }
    else if ( FAILED(hr2) )
    {
        return hr2;
    }

    //
    // if this is a modification to a template instance, then remove any 
    // stale instances and fire instmod event.  If not, then just fire a 
    // creation event.
    //

    if ( pTmplInfo.m_pObj != NULL )
    {
        CPropVar vExistingTmpl;        
        CWbemPtr<IWbemClassObject> pExistingTmpl;

        hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vExistingTmpl, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vExistingTmpl.CheckType(VT_UNKNOWN)) )
        {
            return hr;
        }

        ClassObjectFromVariant( &vExistingTmpl, &pExistingTmpl );
        
        hr = FireIntrinsicEvent( m_pModifyEventClass, pTmpl, pExistingTmpl );
    }
    else
    {
        hr = FireIntrinsicEvent( m_pCreateEventClass, pTmpl, NULL );
    }
    
    return hr;
}

HRESULT CTemplateProvider::GetAllInstances( LPWSTR wszClassname, 
                                            IWbemObjectSink* pResponseHndlr )
{
    ENTER_API_CALL

    HRESULT hr; 
    CWbemPtr<IEnumWbemClassObject> pTmplInfoObjs;

    CWbemBSTR bstrQuery = g_wszTmplInfoQuery;
    bstrQuery += wszClassname;
    bstrQuery += L"'";
    
    hr = m_pSvc->ExecQuery( CWbemBSTR(g_wszQueryLang), 
                            bstrQuery, 
                            WBEM_FLAG_FORWARD_ONLY, 
                            NULL, 
                            &pTmplInfoObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemPtr<IWbemClassObject> pTmplInfo;
    ULONG cObjs;

    hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {   
        _DBG_ASSERT( cObjs ==  1 );
        
        CWbemPtr<IWbemClassObject> pTmpl;
       
        CPropVar vTmpl;
        hr = pTmplInfo->Get( g_wszInfoTmpl, 0, &vTmpl, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vTmpl.CheckType( VT_UNKNOWN )) )
        {
            return hr;
        }

        ClassObjectFromVariant( &vTmpl, &pTmpl );

        hr = pResponseHndlr->Indicate( 1, &pTmpl );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pTmplInfoObjs->Next( WBEM_INFINITE, 1, &pTmplInfo, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResponseHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                      WBEM_S_NO_ERROR, 
                                      NULL, 
                                      NULL );

    EXIT_API_CALL
}

CTemplateProvider::CTemplateProvider( CLifeControl* pCtl, IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}

CTemplateProvider::~CTemplateProvider()
{
    if ( m_pDES != NULL )
    {
        m_pDES->UnRegister();
    }
}

void* CTemplateProvider::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }

    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CTemplateProvider::XServices::XServices( CTemplateProvider* pProv )
: CImpl< IWbemServices, CTemplateProvider> ( pProv )
{

}

CTemplateProvider::XInitialize::XInitialize( CTemplateProvider* pProv )
: CImpl< IWbemProviderInit, CTemplateProvider> ( pProv )
{

}

// {C486ABD2-27F6-11d3-865E-00C04F63049B}
static const CLSID CLSID_TemplateProvider =
{ 0xc486abd2, 0x27f6, 0x11d3, {0x86, 0x5e, 0x0, 0xc0, 0x4f, 0x63, 0x4, 0x9b} };
 
// {FD18A1B2-9E61-4e8e-8501-DB0B07846396}
static const CLSID CLSID_TemplateAssocProvider = 
{ 0xfd18a1b2, 0x9e61, 0x4e8e, {0x85, 0x1, 0xdb, 0xb, 0x7, 0x84, 0x63, 0x96} };

class CTemplateProviderServer : public CComServer
{
protected:

    HRESULT Initialize()
    {
        ENTER_API_CALL

        HRESULT hr;
        CWbemPtr<CBaseClassFactory> pFactory;
        
        pFactory = new CClassFactory<CTemplateProvider>( GetLifeControl() );

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_TemplateProvider,
                           pFactory,
                           _T("Template Provider"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

#if ( _WIN32_WINNT < 0x0501 )
        pFactory = new CClassFactory<CTemplateAssocProvider>(GetLifeControl());
        
        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        hr = AddClassInfo( CLSID_TemplateAssocProvider,
                           pFactory,
                           _T("Template Assoc Provider"), 
                           TRUE );

#endif
        return hr;

        EXIT_API_CALL
    }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\tmplprov\tmplsubs.h ===
#ifndef __TMPLSUBS_H__
#define __TMPLSUBS_H__

#include <wstring.h>
#include <genlex.h>
#include <comutl.h>
#include <wbemcli.h>
#include "tmplcomn.h"

#define MAXARGS 2

class CTemplateStrSubstitution
{
    BOOL m_abArgListString[MAXARGS];
    WString m_awsArgList[MAXARGS];
    int m_cArgList;
    int m_nCurrentToken;
    LPWSTR m_wszTokenText;
    LPWSTR m_wszSubstTokenText;

    WString m_wsOutput;
    CGenLexer m_Lexer;
    CGenLexer* m_pSubstLexer; 
    CWbemPtr<IWbemClassObject> m_pTmplArgs;
    BuilderInfoSet& m_rBldrInfoSet;

    HRESULT Next();
    HRESULT SubstNext();

    HRESULT HandleConditionalSubstitution();
    HRESULT HandlePrefixedWhereSubstitution();
    HRESULT HandleTargetKeySubstitution();
    HRESULT HandleTmplArgSubstitution();

    HRESULT parse();
    HRESULT subst_string();
    HRESULT arglist();
    HRESULT arglist2();
    HRESULT arglist3();

public:

    CTemplateStrSubstitution( CGenLexSource& rLexer, 
                              IWbemClassObject* pTmplArgs,
                              BuilderInfoSet& rBldrInfoSet );

    LPCWSTR GetTokenText() { return m_wszTokenText; }
    
    HRESULT Parse( BSTR* pbstrOutput );
};


#endif // __TMPLSUBS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnscls.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <trnscls.h>
#include <trnsprov.h>
#include <malloc.h>

CTransientClass::CTransientClass(CTransientProvider* pProv) 
    : m_wszName(NULL), m_apProperties(NULL), m_lNumProperties(0),
        m_pProvider(pProv)
{
    // 
    // Provider is held without reference --- it owns this object
    //
}

HRESULT CTransientClass::Initialize(IWbemObjectAccess* pClass, LPCWSTR wszName)
{
    HRESULT hres;

    //
    // Copy the name
    //

    m_wszName = new WCHAR[wcslen(wszName)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(m_wszName, wszName);

    //
    // Allocate the space for all the properties
    //

    VARIANT v;
    hres = pClass->Get(L"__PROPERTY_COUNT", 0, &v, NULL, NULL);
    if(FAILED(hres))
        return hres;
    if(V_VT(&v) != VT_I4)
        return WBEM_E_INVALID_CLASS;

    _DBG_ASSERT( m_lNumProperties == 0 );

    long lNumProperties = V_I4(&v);
    VariantClear(&v);

    m_apProperties = new CTransientProperty*[lNumProperties];

    if ( m_apProperties == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Enumerate all the properties
    //

    m_nDataSpace = 0;
    pClass->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
    BSTR strProp;
    while((hres = pClass->Next(0, &strProp, NULL, NULL, NULL)) == S_OK)
    {
        CSysFreeMe sfm(strProp);
        hres = CTransientProperty::CreateNew(m_apProperties + m_lNumProperties,
                                            pClass, 
                                            strProp);
        if(FAILED(hres))
        {
            pClass->EndEnumeration();
            return hres;
        }
        
        //
        // Inform the property of the provider pointer
        //

        m_apProperties[m_lNumProperties]->SetClass(this);

        //
        // See how much data this property will need to store in the instance
        //

        m_apProperties[m_lNumProperties]->SetInstanceDataOffset(m_nDataSpace);
        m_nDataSpace += m_apProperties[m_lNumProperties]->GetInstanceDataSize();
        m_lNumProperties++;
    }
        
    pClass->EndEnumeration();
    return WBEM_S_NO_ERROR;
}

CTransientClass::~CTransientClass()
{
    delete [] m_wszName;
    for(long i = 0; i < m_lNumProperties; i++)
        delete m_apProperties[i];
    delete [] m_apProperties;
}

IWbemObjectAccess* CTransientClass::Clone(IWbemObjectAccess* pInst)
{
    IWbemClassObject* pClone;
    HRESULT hres = pInst->Clone(&pClone);
    if(FAILED(hres))
        return NULL;
    CReleaseMe rm1(pClone);

    IWbemObjectAccess* pCloneAccess;
    pClone->QueryInterface(IID_IWbemObjectAccess, (void**)&pCloneAccess);
    return pCloneAccess;
}

HRESULT CTransientClass::Put(IWbemObjectAccess* pInst, LPCWSTR wszDbKey,
                                long lFlags,
                                IWbemObjectAccess** ppOld,
                                IWbemObjectAccess** ppNew)
{
    //
    // Check if it is already in the map
    //

    CInCritSec ics(&m_cs);

    TIterator it = m_mapInstances.find(wszDbKey);
        
    if( it != m_mapInstances.end() )
    {
        //
        // Check if update is allowed by the flags
        //

        if(lFlags & WBEM_FLAG_CREATE_ONLY)
            return WBEM_E_ALREADY_EXISTS;

        CTransientInstance* pOldInstData = it->second.get();

        if(ppOld)
        {
            Postprocess(pOldInstData);
            *ppOld = Clone(pOldInstData->GetObjectPtr());
        }

        //
        // Update all properties appropriately in the old instance
        // TBD: need to clean up every now and then, or the blob will grow out 
        // of control.  But I don't want to touch pInst --- let the caller 
        // reuse it!
        //
    
        for(long i = 0; i < m_lNumProperties; i++)
        {
            HRESULT hres = m_apProperties[i]->Update(pOldInstData, pInst);
            if(FAILED(hres))
            {
                //
                // Restore the instance to its pre-update state!
                //

                pOldInstData->SetObjectPtr(*ppOld);
                (*ppOld)->Release();
                *ppOld = NULL;
                return hres;
            }
        }

        if(ppNew)
        {
            Postprocess(pOldInstData);
            *ppNew = Clone(pOldInstData->GetObjectPtr());

            if ( *ppNew == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }
    else
    {
        //
        // Check if creation is allowed by the flags
        //

        if(lFlags & WBEM_FLAG_UPDATE_ONLY)
            return WBEM_E_NOT_FOUND;

        //
        // Create a new instance data structure
        //

        CTransientInstance* pInstData = new (m_nDataSpace) CTransientInstance;

        if ( pInstData == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // Clone the object
        //
        
        IWbemObjectAccess* pClone = Clone(pInst);
        if(pClone == NULL)
            return WBEM_E_OUT_OF_MEMORY;

        CReleaseMe rm2(pClone);

        //
        // Configure the data with the object
        //

        pInstData->SetObjectPtr(pClone);

        //
        // Init all the properties
        //

        for(long i = 0; i < m_lNumProperties; i++)
        {
            m_apProperties[i]->Create(pInstData);
        }

        m_mapInstances[wszDbKey] = TElement(pInstData);

        //
        // AddRef the provider to make sure we are not unloaded while we have
        // instances
        //

        m_pProvider->AddRef();

        if(ppOld)
            *ppOld = NULL;

        if(ppNew)
        {
            Postprocess(pInstData);
            *ppNew = Clone(pInstData->GetObjectPtr());

            if ( *ppNew == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientClass::Delete(LPCWSTR wszDbKey, IWbemObjectAccess** ppOld)
{
    CInCritSec ics(&m_cs);

    // 
    // Find it in the map
    //

    TIterator it = m_mapInstances.find(wszDbKey);
    if(it == m_mapInstances.end())
        return WBEM_E_NOT_FOUND;

    CTransientInstance* pInstData = it->second.get();
    if(ppOld)
    {
        Postprocess(pInstData);
        *ppOld = Clone(pInstData->GetObjectPtr());
    }

    //
    // Clean up all the properties
    //

    for(long i = 0; i < m_lNumProperties; i++)
    {
        m_apProperties[i]->Delete(pInstData);
    }
    
    //
    // Remove it from the map
    //

    m_mapInstances.erase(it);

    //
    // Release the provider to make sure that when we are left with no 
    // instances, we can unload
    //

    m_pProvider->Release();

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientClass::Get(LPCWSTR wszDbKey, IWbemObjectAccess** ppInst)
{
    CInCritSec ics(&m_cs);

    // 
    // Find it in the map
    //

    TIterator it = m_mapInstances.find(wszDbKey);
    if(it == m_mapInstances.end())
        return WBEM_E_NOT_FOUND;

    //
    // Apply all the properties
    //

    CTransientInstance* pInstData = it->second.get();
    Postprocess(pInstData);

    //
    // Addref and return it
    //

    IWbemClassObject* pInst;

    HRESULT hr = pInstData->GetObjectPtr()->Clone( &pInst );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CReleaseMe rmInst( pInst );

    return pInst->QueryInterface( IID_IWbemObjectAccess, (void**)ppInst );
}

HRESULT CTransientClass::Postprocess(CTransientInstance* pInstData)
{
    for(long i = 0; i < m_lNumProperties; i++)
    {
        m_apProperties[i]->Get(pInstData);
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CTransientClass::Enumerate(IWbemObjectSink* pSink)
{
    CInCritSec ics(&m_cs);

    //
    // Enumerate everything in the map
    //

    for(TIterator it = m_mapInstances.begin(); it != m_mapInstances.end(); it++)
    {
        CTransientInstance* pInstData = it->second.get();
        
        // 
        // Apply all the properties
        //

        for(long i = 0; i < m_lNumProperties; i++)
        {
            m_apProperties[i]->Get(pInstData);
        }

        //
        // Indicate it back to WinMgmt
        //

        IWbemClassObject* pActualInst = pInstData->GetObjectPtr();
        if(pActualInst == NULL)
            return WBEM_E_CRITICAL_ERROR;

        IWbemClassObject* pInst;
        HRESULT hr = pActualInst->Clone( &pInst );

        if( FAILED(hr) )
        {
            return hr;
        }

        CReleaseMe rm1(pInst);

        hr = pSink->Indicate(1, &pInst);
        if( FAILED(hr) )
        {
            //
            // Call cancelled
            //
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CTransientClass::FireEvent(IWbemClassObject* pEvent)
{
    return m_pProvider->FireEvent(pEvent);
}

INTERNAL IWbemClassObject* CTransientClass::GetEggTimerClass()
{
    return m_pProvider->GetEggTimerClass();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsinst.h ===
#ifndef __TRANSIENT_INSTANCE__H_
#define __TRANSIENT_INSTANCE__H_

class CTransientInstance
{
protected:
    IWbemObjectAccess* m_pObj;

public:
    CTransientInstance(){}
    ~CTransientInstance()
    {
        if(m_pObj)
            m_pObj->Release();
    }

    void* operator new(size_t stReal, size_t stExtra)
    {
        void* p = ::operator new(stReal + stExtra);
        memset(p, 0, stReal + stExtra);
        return p;
    }
    void operator delete(void* p, size_t)
    {
        ::operator delete(p);
    }

    INTERNAL IWbemObjectAccess* GetObjectPtr() {return m_pObj;}
    void SetObjectPtr(IWbemObjectAccess* pObj)
    {
        if(m_pObj) m_pObj->Release();
        m_pObj = pObj;
        if(m_pObj) m_pObj->AddRef();
    }

    void* GetOffset(size_t nOffset)
    {
        return ((BYTE*)this) + sizeof(CTransientInstance) + nOffset;
    }
};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnscls.h ===
#ifndef __WMI_TRANSIENT_CLASS__H_
#define __WMI_TRANSIENT_CLASS__H_

#pragma warning(disable: 4786)

#include <string>
#include <map>
#include <sync.h>
#include <wstlallc.h>
#include "trnsprop.h"
#include "trnsinst.h"

class CObjectPtr
{
protected:
    IWbemObjectAccess* m_p;
public:
    CObjectPtr(IWbemObjectAccess* p = NULL) : m_p(p)
    {
        if(m_p) m_p->AddRef();
    }

    CObjectPtr(const CObjectPtr& Ptr) : m_p(Ptr.m_p)
    {
        if(m_p) m_p->AddRef();
    }
    void operator=(const CObjectPtr& Ptr)
    {
        if(this == &Ptr)
            return;
        if(m_p) m_p->Release();
        m_p = Ptr.m_p;
        if(m_p) m_p->AddRef();
    }

    ~CObjectPtr()
    {
        if(m_p) m_p->Release();
    }

    operator IWbemObjectAccess*() {return m_p;}
};

class CTransientProvider;
class CTransientClass : public CUnk
{
protected:
    LPWSTR m_wszName;
    CTransientProvider* m_pProvider;

    typedef std::map<WString, std::auto_ptr<CTransientInstance>,WSiless, wbem_allocator< std::auto_ptr<CTransientInstance> > > TMap;
    typedef TMap::iterator TIterator;
    typedef TMap::referent_type TElement;

    TMap m_mapInstances;
    CCritSec m_cs;
    CTransientProperty** m_apProperties;
    long m_lNumProperties;
    size_t m_nDataSpace;

    void* GetInterface( REFIID ) { return NULL; }

protected:
    IWbemObjectAccess* Clone(IWbemObjectAccess* pInst);

public:
    CTransientClass(CTransientProvider* pProvider);
    ~CTransientClass();
    LPCWSTR GetName() const {return m_wszName;}

    HRESULT Initialize(IWbemObjectAccess* pClass, LPCWSTR wszName);

    HRESULT Put(IWbemObjectAccess* pInst, LPCWSTR wszDbKey, long lFlags,
                IWbemObjectAccess** ppOld,
                IWbemObjectAccess** ppNew);
    HRESULT Delete(LPCWSTR wszDbKey,
                IWbemObjectAccess** ppOld = NULL);
    HRESULT Get(LPCWSTR wszDbKey, IWbemObjectAccess** ppInst);
    HRESULT Enumerate(IWbemObjectSink* pSink);
    
    HRESULT FireEvent(IWbemClassObject* pEvent);
    INTERNAL IWbemClassObject* GetEggTimerClass();

    HRESULT Postprocess(CTransientInstance* pInstData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsschm.h ===
#define REBOOT_EVENT_CLASS L"MSFT_TransientRebootEvent"
#define EGGTIMER_EVENT_CLASS L"MSFT_TransientEggTimerEvent"
#define EGGTIMER_PROP_CLASSNAME L"ClassName"
#define EGGTIMER_PROP_PROPNAME L"PropertyName"
#define EGGTIMER_PROP_OBJECT L"Object"

#define EGGTIMER_QUALIFIER L"trns_egg_timer"
#define TIMEAVERAGE_QUALIFIER L"trns_time_average"
#define VALUE_QUALIFIER L"trns_value_is"
#define SWITCH_QUALIFIER L"trns_switch_is"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprov.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <comutl.h>
#include <genlex.h>
#include <objpath.h>
#include <cominit.h>
#include "trnsprov.h"
#include "trnsschm.h"

CCritSec g_CS;
typedef std::map<WString, CTransientProvider*, WSiless, wbem_allocator<CTransientProvider*> > TProvMap;
typedef TProvMap::iterator TProvMapIterator;
TProvMap* g_pmapProvs;

const LPCWSTR g_wszTrnsEventProvName=L"Microsoft WMI Transient Event Provider";

HRESULT PlugKeyHoles(IWbemClassObject* pInst);

HRESULT CTransientProvider::ModuleInitialize()
{
    g_pmapProvs = new TProvMap;

    if ( g_pmapProvs == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CTransientProvider::ModuleUninitialize()
{
    delete g_pmapProvs;
    return S_OK;   
}


CTransientProvider::CTransientProvider( CLifeControl* pControl, 
                                        IUnknown* pOuter ) 
: CUnk(pControl, pOuter), m_XProv(this), m_XInit(this), 
  m_XClassChangeSink(this), m_pNamespace(NULL),
  m_pEggTimerClass(NULL), m_pSink(NULL), m_wszName(NULL),
  m_pCreationClass(NULL), m_pDeletionClass(NULL), 
  m_pModificationClass(NULL), m_pRedirectTo(NULL),
  m_pDES(NULL), m_pEventSink(NULL)
{
}

CTransientProvider::~CTransientProvider()
{
    if(m_pNamespace)
        m_pNamespace->Release();

    if(m_pEggTimerClass)
        m_pEggTimerClass->Release();

    if(m_pSink)
        m_pSink->Release();
    
    if(m_pRedirectTo)
        m_pRedirectTo->Release();

    if ( m_pEventSink != NULL )
    {
        m_pEventSink->Release();
    }

    if( m_pDES )
    {
        m_pDES->UnRegister();
        m_pDES->Release();
    }

    delete [] m_wszName;
}

ULONG STDMETHODCALLTYPE CTransientProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);

    ENTER_API_CALL

    if(lRef == 0)
    {
        if(m_pRedirectTo == NULL)
        {
            CInCritSec ics(&g_CS);
            g_pmapProvs->erase(m_wszName);
        }

        delete this;
    }

    EXIT_API_CALL

    return lRef;
}

void* CTransientProvider::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemServices)
        return &m_XProv;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else if(riid == IID_IWbemObjectSink)
        return &m_XClassChangeSink;
    else
        return NULL;
}

HRESULT CTransientProvider::GetObjectAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
    ENTER_API_CALL

    if(m_pRedirectTo)
        return m_pRedirectTo->GetObjectAsync(strObjectPath, lFlags, pCtx, 
                                                pSink);

    //
    // Parse the object path to determine the class and the db key
    //

    CObjectPathParser Parser;
    ParsedObjectPath* pPath = NULL;
    int nRes = Parser.Parse(strObjectPath, &pPath);
    CDeleteMe<ParsedObjectPath> dm1(pPath);

    if(nRes != CObjectPathParser::NoError || 
        !pPath->IsInstance() || pPath->m_pClass == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics( &m_cs );

        TIterator it = m_mapClasses.find(pPath->m_pClass);
        if(it == m_mapClasses.end())
        {
            return WBEM_E_NOT_FOUND;
        }

        pClass = it->second;
    }

    //
    // Get Db key and delegate to class
    //
    
    LPWSTR wszDbKey = pPath->GetKeyString();
    if(wszDbKey == NULL)
        return WBEM_E_INVALID_OBJECT_PATH;
    CVectorDeleteMe<WCHAR> vdm1(wszDbKey);

    IWbemObjectAccess* pInst;
    HRESULT hres = pClass->Get(wszDbKey, &pInst);
    if(FAILED(hres))
        return hres;

    IWbemClassObject* pInstObj;
    pInst->QueryInterface(IID_IWbemClassObject, (void**)&pInstObj);
    CReleaseMe rm1(pInstObj);

    pSink->Indicate(1, &pInstObj);
    pSink->SetStatus(WBEM_STATUS_COMPLETE, WBEM_S_NO_ERROR, NULL, NULL);

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
    ENTER_API_CALL

    if(m_pRedirectTo)
        return m_pRedirectTo->CreateInstanceEnumAsync(strClass, lFlags, pCtx,
                                                        pSink);
    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics(&m_cs);

        TIterator it = m_mapClasses.find(strClass);
        if(it != m_mapClasses.end())
        {
            pClass = it->second;
        }
    }

    if ( pClass == NULL )
    {
            //
            // No instances --- that's not an error
            //

            pSink->SetStatus( WBEM_STATUS_COMPLETE, 
                              WBEM_S_NO_ERROR, 
                              NULL, 
                              NULL);
     
            return WBEM_S_NO_ERROR;
    }

    HRESULT hres = pClass->Enumerate(pSink);
    pSink->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{
    return WBEM_E_NOT_SUPPORTED;
}

HRESULT CTransientProvider::DeleteInstanceAsync( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
{
    ENTER_API_CALL

    if(m_pRedirectTo)
        return m_pRedirectTo->DeleteInstanceAsync(strObjectPath, lFlags, pCtx,
                                                    pSink);

    //
    // Parse the object path to determine the class and the db key
    //

    CObjectPathParser Parser;
    ParsedObjectPath* pPath = NULL;
    int nRes = Parser.Parse(strObjectPath, &pPath);
    CDeleteMe<ParsedObjectPath> dm1(pPath);

    if(nRes != CObjectPathParser::NoError || 
        !pPath->IsInstance() || pPath->m_pClass == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics( &m_cs );

        TIterator it = m_mapClasses.find(pPath->m_pClass);
        if(it == m_mapClasses.end())
            return WBEM_E_NOT_FOUND;
        pClass = it->second;
    }

    //
    // Get Db key and delegate to class
    //
    
    LPWSTR wszDbKey = pPath->GetKeyString();
    if(wszDbKey == NULL)
        return WBEM_E_INVALID_OBJECT_PATH;
    CVectorDeleteMe<WCHAR> vdm1(wszDbKey);

    IWbemObjectAccess* pOld = NULL;
    HRESULT hres = pClass->Delete(wszDbKey, &pOld);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pOld);

    //
    // Fire an instance deletion event
    //

    hres = FireIntrinsicEvent(m_pDeletionClass, pOld);

    pSink->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}
    
HRESULT CTransientProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
{
    ENTER_API_CALL

    if(m_pRedirectTo)
    return m_pRedirectTo->PutInstanceAsync(pInst, lFlags, pCtx, pSink);

    HRESULT hres;

    //
    // Get the class name and the relpath
    //

    VARIANT vClass;
    hres = pInst->Get(L"__CLASS", 0, &vClass, NULL, NULL);
    if(FAILED(hres))
    return hres;
    if(V_VT(&vClass) != VT_BSTR)
    return WBEM_E_INVALID_OBJECT;
    CClearMe cm1(&vClass);

    LPCWSTR wszClassName = V_BSTR(&vClass);

    VARIANT vKey;
    hres = pInst->Get(L"__RELPATH", 0, &vKey, NULL, NULL);
    if(FAILED(hres))
    return hres;
    CClearMe cm2(&vKey);

    if(V_VT(&vKey) != VT_BSTR)
    {
        //
        // No relpath yet.  Try plgging key holes
        //

        hres = PlugKeyHoles(pInst);
        if(FAILED(hres))
        return WBEM_E_INVALID_OBJECT;

        hres = pInst->Get(L"__RELPATH", 0, &vKey, NULL, NULL);
        if(FAILED(hres))
        return hres;
        if(V_VT(&vClass) != VT_BSTR)
        return WBEM_E_INVALID_OBJECT;
    }

    //
    // Parse the object path to determine the db key
    //

    CObjectPathParser Parser;
    ParsedObjectPath* pPath = NULL;
    int nRes = Parser.Parse(V_BSTR(&vKey), &pPath);
    CDeleteMe<ParsedObjectPath> dm1(pPath);

    if(nRes != CObjectPathParser::NoError || 
       !pPath->IsInstance() || pPath->m_pClass == NULL)
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Get Db key
    //
    
    LPWSTR wszDbKey = pPath->GetKeyString();
    if(wszDbKey == NULL)
    return WBEM_E_INVALID_OBJECT_PATH;
    CVectorDeleteMe<WCHAR> vdm1(wszDbKey);

    //
    // Find that class
    //

    CWbemPtr<CTransientClass> pClass;

    {
        CInCritSec ics( &m_cs );
        TIterator it = m_mapClasses.find( wszClassName );

        if( it == m_mapClasses.end() )
        {
            //
            // Time to create one.  Get the class def from the namespace
            //
            
            BSTR strClassName = SysAllocString(wszClassName);
            if(strClassName == NULL)
            {
                return WBEM_E_OUT_OF_MEMORY;
            }
            CSysFreeMe sfm(strClassName);

            IWbemClassObject* pClassDef = NULL;
            
            hres = m_pNamespace->GetObject( strClassName, 
                                            0, 
                                            pCtx, 
                                            &pClassDef, 
                                            NULL );
            if(FAILED(hres))
            {
                return hres;
            }

            CReleaseMe rm1(pClassDef);
        
            //
            // Create a new structure and initialize it
            //
            
            pClass = new CTransientClass(this);

            if ( pClass == NULL )
            {
                return WBEM_E_OUT_OF_MEMORY;
            }

            IWbemObjectAccess* pClassAccess;
            pClassDef->QueryInterface( IID_IWbemObjectAccess, 
                                       (void**)&pClassAccess );
            CReleaseMe rm2(pClassAccess);

            hres = pClass->Initialize(pClassAccess, wszClassName);
            if(FAILED(hres))
            {
                return hres;
            }
        
            m_mapClasses[wszClassName] = pClass;
        }
        else
        {
            pClass = it->second;
        }
    }

    //
    // Delegate to class
    //
    
    IWbemObjectAccess* pInstAccess;
    pInst->QueryInterface(IID_IWbemObjectAccess, (void**)&pInstAccess);
    CReleaseMe rm0(pInstAccess);

    IWbemObjectAccess* pOld = NULL;
    IWbemObjectAccess* pNew = NULL;
    hres = pClass->Put(pInstAccess, wszDbKey, lFlags, &pOld, &pNew);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pOld);
    CReleaseMe rm2(pNew);

    //
    // Fire creation or modification event
    //

    if(pOld)
        hres = FireIntrinsicEvent(m_pModificationClass, pNew, pOld);
    else
        hres = FireIntrinsicEvent(m_pCreationClass, pNew);

    pSink->SetStatus(WBEM_STATUS_COMPLETE, hres, NULL, NULL);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::FireIntrinsicEvent(IWbemClassObject* pClass,
                                               IWbemObjectAccess* pTarget, IWbemObjectAccess* pPrev)
{
    HRESULT hres;

    //  
    // Spawn an instance
    //

    IWbemClassObject* pEvent = NULL;
    hres = pClass->SpawnInstance(0, &pEvent);
    if(FAILED(hres))
    return hres;

    CReleaseMe rm1( pEvent );

    //
    // Set target instance
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    if(pTarget)
    {
        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = pTarget;
        pTarget->AddRef();

        hres = pEvent->Put(L"TargetInstance", 0, &v, 0);
        if(FAILED(hres))
        return hres;
        VariantClear(&v);
    }

    //
    // Set previous instance
    //

    if(pPrev)
    {
        V_VT(&v) = VT_UNKNOWN;
        V_UNKNOWN(&v) = pPrev;
        pPrev->AddRef();

        hres = pEvent->Put(L"PreviousInstance", 0, &v, 0);
        if(FAILED(hres))
        return hres;
        VariantClear(&v);
    }

    //  
    // Fire it off
    //

    hres = FireEvent(pEvent);

    if ( FAILED(hres) )
    {
        return hres;
    }
    
    return WBEM_S_NO_ERROR; 
}


HRESULT CTransientProvider::Init(
                                 /* [in] */ LPWSTR pszNamespace,
                                 /* [in] */ IWbemServices *pNamespace,
                                 /* [in] */ IWbemContext *pCtx,
                                 /* [in] */ IWbemProviderInitSink *pInitSink
                                 )
{
    ENTER_API_CALL

    HRESULT hres;

    //
    // Check if this namespace is already in the map
    //

    CInCritSec ics(&g_CS);

    TProvMapIterator it = g_pmapProvs->find(pszNamespace);
        
    if(it != g_pmapProvs->end())
    {
        //
        // Set the old one as our redirector and return.
        //
        
        m_pRedirectTo = it->second;
        m_pRedirectTo->AddRef();
            
        pInitSink->SetStatus(0, WBEM_S_NO_ERROR);
        return WBEM_S_NO_ERROR;
    }

    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
    
    m_wszName = new WCHAR[wcslen(pszNamespace)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(m_wszName, pszNamespace);

    //
    // Retrieve the class definitions for events
    //

    BSTR strEgg = SysAllocString(EGGTIMER_EVENT_CLASS);
    if ( strEgg == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm1(strEgg);
    hres = m_pNamespace->GetObject(strEgg, 0, pCtx, &m_pEggTimerClass, NULL);
    if(FAILED(hres))
        return hres;

    BSTR strCreate = SysAllocString(L"__InstanceCreationEvent");
    if ( strCreate == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm2(strCreate);
    hres = m_pNamespace->GetObject(strCreate, 0, pCtx, &m_pCreationClass, NULL);
    if(FAILED(hres))
        return hres;

    BSTR strDelete = SysAllocString(L"__InstanceDeletionEvent");
    if ( strDelete == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm3(strDelete);
    hres = m_pNamespace->GetObject(strDelete, 0, pCtx, &m_pDeletionClass, NULL);
    if(FAILED(hres))
        return hres;

    BSTR strMod = SysAllocString(L"__InstanceModificationEvent");
    if ( strMod == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm(strMod);
    hres = m_pNamespace->GetObject(strMod, 0, pCtx, &m_pModificationClass,NULL);
    if(FAILED(hres))
        return hres;

    //
    // Obtain our event sink
    //

    hres = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                             NULL, 
       		     	     CLSCTX_INPROC_SERVER, 
       			     IID_IWbemDecoupledBasicEventProvider,
       			     (void**)&m_pDES );
    if ( FAILED(hres) )
    {
        return hres;
    }

    hres = m_pDES->Register( 0,
                             NULL,
                             NULL,
                             NULL,
                             pszNamespace,
                             g_wszTrnsEventProvName,
                             NULL );
    
    if ( FAILED(hres) )
    {
        return hres;
    }

    //
    // get the decoupled event sink
    //

    hres = m_pDES->GetSink( 0, NULL, &m_pEventSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    pInitSink->SetStatus(0, WBEM_S_NO_ERROR);

    //
    // register for class change/deletion events for transient state base.
    //

    CWbemPtr<IWbemObjectSink> pSink;

    hres = QueryInterface( IID_IWbemObjectSink, (void**)&pSink );

    if ( FAILED(hres) )
    {
        return hres;
    }

    CWbemBSTR bsQuery;
    CWbemBSTR bsQueryLang = L"WQL";

    bsQuery = L"select * from __ClassModificationEvent where "
              L"TargetClass ISA 'MSFT_TransientStateBase'";

    hres = pNamespace->ExecNotificationQueryAsync( bsQueryLang,
                                                   bsQuery,
                                                   0,
                                                   pCtx,
                                                   pSink );
    if ( FAILED(hres) )   
    {
        return hres;
    }

    bsQuery = L"select * from __ClassDeletionEvent where "
              L"TargetClass ISA 'MSFT_TransientStateBase'";

    hres = pNamespace->ExecNotificationQueryAsync( bsQueryLang,
                                                   bsQuery,
                                                   0,
                                                   pCtx,
                                                   pSink );
    if ( FAILED(hres) )  
    {
        return hres;
    }

    //
    // now that we're fully initialized, add ourselves to the provider 
    // list so that others can connect to us.
    //

    (*g_pmapProvs)[pszNamespace] = this;
        
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProvider::FireEvent(IWbemClassObject* pEvent)
{
    return m_pEventSink->Indicate(1, &pEvent);
}
   
HRESULT PlugKeyHoles(IWbemClassObject* pInst)
{
    HRESULT hres;

    //
    // Enumerate all keys
    //

    hres = pInst->BeginEnumeration(WBEM_FLAG_KEYS_ONLY);
    if(FAILED(hres))
        return hres;

    VARIANT vProp;
    BSTR strPropName;
    CIMTYPE ct;
    while(pInst->Next(0, &strPropName, &vProp, &ct, NULL) == S_OK)
    {
        CClearMe cm(&vProp);
        CSysFreeMe sfm(strPropName);
    
        //
        // Check if the value of this key is NULL
        //

        if(V_VT(&vProp) == VT_NULL)
        {
            if(ct != CIM_STRING)
            {
                // We don't support non-string key holes
                return WBEM_E_ILLEGAL_NULL;
            }
            else
            {
                //
                // Get a guid and put it there
                // 

                GUID guid;
                CoCreateGuid(&guid);
                WCHAR wszBuffer[100];
                StringFromGUID2(guid, wszBuffer, 100);
        
                // 
                // Stick it in the variant --- it will get cleared
                //

                V_VT(&vProp) = VT_BSTR;
                V_BSTR(&vProp) = SysAllocString(wszBuffer);
                if ( V_BSTR(&vProp) == NULL )
                    return WBEM_E_OUT_OF_MEMORY;
                hres = pInst->Put(strPropName, 0, &vProp, 0);
                if(FAILED(hres))
                    return WBEM_E_ILLEGAL_NULL;
            }
        }
    }

    pInst->EndEnumeration();
    return WBEM_S_NO_ERROR;
}

//*****************************************************************************
//
//              EVENT PROVIDER
//
//*****************************************************************************

CTransientEventProvider::CTransientEventProvider(CLifeControl* pControl, 
                                                    IUnknown* pOuter)
: CUnk(pControl, pOuter), m_XInit(this), m_XEvent(this), m_wszName(NULL),
  m_pRebootEventClass(NULL),  m_bLoadedOnReboot(FALSE)
{
}

CTransientEventProvider::~CTransientEventProvider()
{
    if(m_pRebootEventClass)
        m_pRebootEventClass->Release();
    delete [] m_wszName;
}

void* CTransientEventProvider::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else if(riid == IID_IWbemEventProvider)
        return &m_XEvent;
    else 
        return NULL;
}



HRESULT CTransientEventProvider::Init(LPWSTR pszNamespace, 
                                        IWbemServices* pNamespace,
                                        IWbemContext* pCtx,
                                        IWbemProviderInitSink *pInitSink)
{
    ENTER_API_CALL

    HRESULT hres;

    m_wszName = new WCHAR[wcslen(pszNamespace)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(m_wszName, pszNamespace);

    //
    // Get the class of the reboot event
    //

    BSTR strClass = SysAllocString(REBOOT_EVENT_CLASS);  
    if ( strClass == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    CSysFreeMe sfm(strClass);
    hres = pNamespace->GetObject(strClass, 0, pCtx, &m_pRebootEventClass, NULL);
    if(FAILED(hres))
        return hres;
        
    //
    // Check if we are being launched on reboot of winmgmt. With Nova WMI, 
    // we check this by seeing if there is any call context on the calling 
    // thread.  If not, then we must be loading due to initialization of
    // winmgmt.  On whistler and greater, we check using the passed in context.
    //

    IServerSecurity* pSec;
    hres = WbemCoGetCallContext(IID_IServerSecurity, (void**)&pSec);

    if ( SUCCEEDED(hres) ) 
    {
        pSec->Release();

        if ( pCtx != NULL )
        {
            //
            // check context object for ess initialization value.
            //

            VARIANT vInit;
            hres = pCtx->GetValue( L"__EssInInitialize", 0, &vInit );
            
            if ( SUCCEEDED(hres) && V_BOOL(&vInit) == VARIANT_TRUE )
            {
                m_bLoadedOnReboot = TRUE;
            }
        }
    }
    else
    {
        m_bLoadedOnReboot = TRUE;
    }

    pInitSink->SetStatus(0, WBEM_S_NO_ERROR);
    
    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

HRESULT CTransientEventProvider::ProvideEvents(long lFlags, 
                                                IWbemObjectSink* pSink)
{
    ENTER_API_CALL

    HRESULT hres;

    if( m_bLoadedOnReboot )
    {
        //
        // Fire a transient reboot event if we're just starting up.
        //
    
        IWbemClassObject* pEvent;
        hres = m_pRebootEventClass->SpawnInstance(0, &pEvent);
        if(FAILED(hres))
            return hres;
        CReleaseMe rm1(pEvent);

        hres = pSink->Indicate(1, &pEvent);
        if(FAILED(hres))
            return hres;
    }

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}

void CTransientProvider::PurgeClass( LPCWSTR wszName )
{
    CInCritSec ics( &m_cs );

    TIterator it = m_mapClasses.find( wszName );

    if ( it != m_mapClasses.end() )
    {
        m_mapClasses.erase( it );
    }
}

STDMETHODIMP CTransientProvider::XClassChangeSink::Indicate(
                                   long cObjs, IWbemClassObject** ppObjs )
{
    HRESULT hr;

    //
    // get the name of the class that was changed or deleted and call purge.
    //

    for( int i=0; i < cObjs; i++ )
    {
        CPropVar vClass;

        hr = ppObjs[i]->Get( L"TargetClass", 0, &vClass, NULL, NULL );

        if ( SUCCEEDED(hr) && V_VT(&vClass) == VT_UNKNOWN )
        {
            CWbemPtr<IWbemClassObject> pClass;

            hr = V_UNKNOWN(&vClass)->QueryInterface( IID_IWbemClassObject, 
                                                     (void**)&pClass );
        
            if ( SUCCEEDED(hr) )
            {
                CPropVar vName;

                hr = pClass->Get( L"__CLASS", 0, &vName, NULL, NULL );

                if ( SUCCEEDED(hr) && V_VT(&vName) == VT_BSTR )
                {
                    m_pObject->PurgeClass( V_BSTR(&vName) );
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprop.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wbemcomn.h>
#include <trnsprop.h>
#include <malloc.h>
#include <trnscls.h>
#include <trnsschm.h>
#include <buffer.h>


#define PROPERTY_LENGTH_TRESHOLD    128

//void* operator new(size_t st, void* p); 

//******************************************************************************
//
//          TRANSIENT PROPERTY --- BASE
//
//******************************************************************************

CTransientProperty::CTransientProperty()
    : m_wszName(NULL), m_lHandle(0)
{
}

CTransientProperty::~CTransientProperty()
{
    delete [] m_wszName;
}

HRESULT CTransientProperty::Initialize( IWbemObjectAccess* pObj, 
                                        LPCWSTR wszName)
{
    //
    // Copy the name
    //

    m_wszName = new WCHAR[wcslen(wszName)+1];

    if ( m_wszName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    wcscpy(m_wszName, wszName);

    //
    // see if the property is defaulted.  If so, then don't use the handle 
    // to obtain the value ( because the interface doesn't tell us if 
    // the property is defaulted or not. ) RAID 164064.  Note that timer 
    // and time avg properties don't support default properties right now, 
    // but they will fail later on in initialization when they notice that the
    // handle is invalid.
    // 

    VARIANT v;
    HRESULT hres = pObj->Get( wszName, 0, &v, &m_ct, NULL );

    if ( FAILED(hres) )
    {
        return hres;
    }

    m_lHandle = -1;

    if ( V_VT(&v) == VT_NULL )
    {
        //
        // Get the handle
        //
        
        long lHandle;
     
        if( SUCCEEDED(pObj->GetPropertyHandle(wszName, &m_ct, &lHandle)) )
        {
            m_lHandle = lHandle;
        }
    }
    else
    {
        VariantClear( &v );
    }

    return hres;
}

HRESULT CTransientProperty::Create(CTransientInstance* pInstData)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProperty::Update(CTransientInstance* pInstData, 
                                    IWbemObjectAccess* pNew)
{
    HRESULT hres;

    //
    // If the value in the new instance is not NULL and is not defaulted, 
    // update it in the old
    //

    if(m_lHandle != -1)
    {    
        BYTE    Buffer[ PROPERTY_LENGTH_TRESHOLD ];
        CBuffer Data( Buffer, PROPERTY_LENGTH_TRESHOLD, FALSE );

        long lRead;
        hres = pNew->ReadPropertyValue(m_lHandle, PROPERTY_LENGTH_TRESHOLD, 
                                &lRead, Data.GetRawData() );

        if ( WBEM_E_BUFFER_TOO_SMALL == hres )
        {
            hres = Data.SetSize( lRead );
            if ( FAILED( hres ) )
            {
                return hres;
            }

            hres = pNew->ReadPropertyValue(m_lHandle, lRead, &lRead, Data.GetRawData() );
        }

        if(FAILED(hres))
            return hres;
        
        if(hres == WBEM_S_NO_ERROR)
        {
            // 
            // Not NULL --- write back into pOld
            //
    
            hres = pInstData->GetObjectPtr()->WritePropertyValue( m_lHandle, lRead, Data.GetRawData()  );
        }
    }
    else
    {
        //
        // Use the name
        //

        VARIANT v;
        IWbemClassObject* pNewObj = NULL;
        pNew->QueryInterface(IID_IWbemClassObject, (void**)&pNewObj);
        CReleaseMe rm1(pNewObj);

        long lFlavor;
        hres = pNewObj->Get(m_wszName, 0, &v, NULL, &lFlavor);
        if(FAILED(hres))
            return hres;

        CClearMe cmv(&v);

        if( V_VT(&v) != VT_NULL && lFlavor == WBEM_FLAVOR_ORIGIN_LOCAL )
        {
            IWbemClassObject* pOldObj = NULL;
            pInstData->GetObjectPtr()->QueryInterface(IID_IWbemClassObject, 
                                                    (void**)&pOldObj);
            CReleaseMe rm2(pOldObj);
            
            hres = pOldObj->Put(m_wszName, 0, &v, 0);
        }
    }

    return hres;
}

HRESULT CTransientProperty::Get(CTransientInstance* pInstData)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProperty::Delete(CTransientInstance* pInstData)
{
    return WBEM_S_NO_ERROR;
}

HRESULT CTransientProperty::CreateNew(CTransientProperty** ppProp, 
                                IWbemObjectAccess* pClass, 
                                LPCWSTR wszName)
{
    //
    // Get the qualifier set
    //

    IWbemQualifierSet* pSet = NULL;
    HRESULT hres = pClass->GetPropertyQualifierSet(wszName, &pSet);
    if(FAILED(hres))
        return hres;

    CReleaseMe rm1(pSet);

    //
    // Create the right kind of node
    //

    hres = CreateNode( ppProp, pSet );

    if(FAILED(hres))
        return hres;
    if(*ppProp == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    
    // 
    //
    // Initialize it
    //

    return (*ppProp)->Initialize(pClass, wszName);
}

HRESULT CTransientProperty::CreateNode(CTransientProperty** ppProp, 
                                        IWbemQualifierSet* pSet)
{
    HRESULT hres; 

    //
    // Check for the standard qualifiers
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pSet->Get(EGGTIMER_QUALIFIER, 0, &v, NULL);

    if ( FAILED(hres) )
    {
        hres = pSet->Get(TIMEAVERAGE_QUALIFIER, 0, &v, NULL);

        if(FAILED(hres))
        {
            *ppProp = new CTransientProperty;
        }
        else
        {
            *ppProp = new CTimeAverageProperty;
        }
    }
    else
    {
        *ppProp = new CTimerProperty;
    }

    return (*ppProp != NULL) ? WBEM_S_NO_ERROR : WBEM_E_OUT_OF_MEMORY;
}


//******************************************************************************
//
//                          EGG TIMER 
//
//******************************************************************************

CTimerGenerator CTimerProperty::mstatic_Generator;

CTimerProperty::~CTimerProperty()
{
}

void CTimerProperty::SetClass(CTransientClass* pClass)
{
    m_pClass = pClass;
}

HRESULT CTimerProperty::Initialize( IWbemObjectAccess* pObj, 
                                    LPCWSTR wszName)
{
    //
    // Initialize like every other
    //

    HRESULT hres = CTransientProperty::Initialize(pObj, wszName);
    if(FAILED(hres))
        return hres;

    if(m_lHandle == -1)
        return WBEM_E_INVALID_PROPERTY_TYPE;

    //
    // Make sure that the type is SINT32, UINT32, REAL32 or DATETIME
    //

    if( m_ct != CIM_SINT32 && m_ct != CIM_UINT32 && 
        m_ct != CIM_DATETIME && m_ct != CIM_REAL32 )
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CTimerProperty::Create(CTransientInstance* pInstData)
{
    //
    // Initialize our data
    //

    CTimerPropertyData* pData = 
    (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    new (pData) CTimerPropertyData;
    
    return Set(pInstData, pInstData->GetObjectPtr());
}

HRESULT CTimerProperty::Set(CTransientInstance* pInstData, 
                            IWbemObjectAccess* pObj)
{
    HRESULT hres;

    CTimerPropertyData* pData = 
    (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    //
    // need to hold this cs because we will be referencing the timer inst 
    // and we don't want a timer to fire and bash it.
    //
    CInCritSec ics(&pData->m_cs); 

    //
    // Check if we are actually being written
    //

    BYTE    Buffer[ PROPERTY_LENGTH_TRESHOLD ];
    CBuffer Data( Buffer, PROPERTY_LENGTH_TRESHOLD, FALSE );

    long lRead;
    hres = pObj->ReadPropertyValue(m_lHandle, PROPERTY_LENGTH_TRESHOLD, &lRead, Data.GetRawData( ) );

    if ( WBEM_E_BUFFER_TOO_SMALL == hres )
    {
        hres = Data.SetSize( lRead );
        if ( FAILED( hres ) )
        {
            return hres;
        }
        hres = pObj->ReadPropertyValue(m_lHandle, lRead, &lRead, Data.GetRawData() );
    }

    if(FAILED(hres))
        return hres;

    if(hres == WBEM_S_FALSE)
        return WBEM_S_NO_ERROR;

    //
    // Cancel the previous instruction
    //

    if(pData->m_pCurrentInst)
    {
        CIdentityTest Test(pData->m_pCurrentInst);
        hres = mstatic_Generator.Remove(&Test);
        if(FAILED(hres))
        return hres;
        pData->m_pCurrentInst->Release();
        pData->m_pCurrentInst = NULL;
    }

    // Extract the value of the interval

    if(m_ct == CIM_DATETIME)
    {
        DWORD dwDays, dwHours, dwMinutes, dwSeconds;
        
        if(swscanf((LPCWSTR)Data.GetRawData( ), L"%8u%2u%2u%2u", 
                   &dwDays, &dwHours, &dwMinutes, &dwSeconds) != 4)
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        dwSeconds += dwMinutes * 60 + dwHours * 3600 + dwDays * 3600 * 24;
        pData->m_Interval.SetMilliseconds(1000 * dwSeconds);
    }
    else if (m_ct == CIM_REAL32)
    {
        float fSeconds = *(float*)Data.GetRawData( );
        pData->m_Interval.SetMilliseconds( 1000 * fSeconds );
    }   
    else
    {
        DWORD dwSeconds = *(DWORD*)Data.GetRawData( );
        pData->m_Interval.SetMilliseconds( 1000 * dwSeconds );
    }

    if(pData->m_Interval.IsZero())
    {
        pData->m_Next = CWbemTime::GetInfinity();
        return WBEM_S_NO_ERROR;
    }

    //
    // Compute the next firing time
    //

    pData->m_Next = CWbemTime::GetCurrentTime() + pData->m_Interval;
    
    //
    // Schedule an instruction to fire then
    //

    pData->m_pCurrentInst = 
    new CEggTimerInstruction(this, pInstData, pData->m_Next);

    if ( pData->m_pCurrentInst == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pData->m_pCurrentInst->AddRef();
    hres = mstatic_Generator.Set(pData->m_pCurrentInst);
    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}
    
HRESULT CTimerProperty::Update(CTransientInstance* pInstData, 
                                IWbemObjectAccess* pNew)
{
    return Set(pInstData, pNew);
}

HRESULT CTimerProperty::Get(CTransientInstance* pInstData)
{
    //
    // Retrieve instance data blob
    //

    CTimerPropertyData* pData = 
        (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    CInCritSec ics(&pData->m_cs);

    HRESULT hres;

    //
    // Check if we are currently active
    //

    DWORD dwMs;
    if(pData->m_pCurrentInst)
    {
        //
        // Subtract the current time from the firing time
        //

        dwMs = (pData->m_Next - CWbemTime::GetCurrentTime()).GetMilliseconds();
    }
    else
    {
        dwMs = 0;
    }
        
    // 
    // Stick it into the property
    //

    if(m_ct == CIM_DATETIME)
    {
        WCHAR wszInterval[25];
        DWORD dwDays = dwMs / (3600 * 1000 * 24);
        dwMs -= dwDays * (3600 * 1000 * 24);
        DWORD dwHours = dwMs / (3600 * 1000);
        dwMs -= dwHours * (3600 * 1000);
        DWORD dwMinutes = dwMs / (60 * 1000);
        dwMs -= dwMinutes * (60 * 1000);
        DWORD dwSeconds = dwMs / 1000;
        dwMs -= dwSeconds * 1000;
        swprintf(wszInterval, L"%08u%02u%02u%02u.%06u:000", 
            dwDays, dwHours, dwMinutes, dwSeconds, dwMs);
            
        hres = pInstData->GetObjectPtr()->WritePropertyValue(m_lHandle, 50, 
                (BYTE*)wszInterval);
    }
    if(m_ct == CIM_REAL32)
    {
        float fSec = dwMs / 1000.0;
        hres = pInstData->GetObjectPtr()->WritePropertyValue( m_lHandle, 
                                                              sizeof(float), 
                                                              (BYTE*)&fSec ); 
    }
    else
    {
        DWORD dwSec = dwMs / 1000;
        hres = pInstData->GetObjectPtr()->WriteDWORD( m_lHandle, dwSec );
    }

    if(FAILED(hres))
        return hres;

    return WBEM_S_NO_ERROR;
}

HRESULT CTimerProperty::Delete(CTransientInstance* pInstData)
{
    //
    // Retrieve instance data blob
    //

    CTimerPropertyData* pData = 
        (CTimerPropertyData*)pInstData->GetOffset(m_nOffset);

    //
    // Clear the data
    //

    pData->~CTimerPropertyData();
    return WBEM_S_NO_ERROR;
}

size_t CTimerProperty::GetInstanceDataSize()
{
    return sizeof(CTimerPropertyData);
}

CTimerPropertyData::~CTimerPropertyData()
{
    //
    // Cancel the timer instruction, if any
    //

    if(m_pCurrentInst)
    {
        CIdentityTest Test(m_pCurrentInst);
        HRESULT hres = CTimerProperty::GetGenerator().Remove(&Test);
        m_pCurrentInst->Release();
    }
}
void CTimerPropertyData::ResetInstruction()
{
    CInCritSec ics(&m_cs);
    m_pCurrentInst->Release();
    m_pCurrentInst = NULL;
}

CEggTimerInstruction::CEggTimerInstruction(CTimerProperty* pProp, 
                            CTransientInstance* pData,
                            const CWbemTime& Time)
    : m_pProp(pProp), m_pData(pData), m_Time(Time), m_lRef(0)
{
}
    
HRESULT CEggTimerInstruction::Fire(long lNumTimes, CWbemTime NextFiringTime)
{
    HRESULT hres;

    //
    // Remove instruction from instance
    //

    CTimerPropertyData* pTimerData = 
        (CTimerPropertyData*)m_pProp->GetData(m_pData);
    pTimerData->ResetInstruction();

    //
    // Create an instance of the egg timer event
    //

    IWbemClassObject* pEvent = NULL;
    hres = m_pProp->m_pClass->GetEggTimerClass()->SpawnInstance(0, &pEvent);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pEvent);

    //
    // Fill in the class name
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_pProp->m_pClass->GetName());
    if ( V_BSTR(&v) == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    hres = pEvent->Put(EGGTIMER_PROP_CLASSNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;
    VariantClear(&v);

    //
    // Fill in the property name
    //

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_pProp->GetName());
    if ( V_BSTR(&v) == NULL )
        return WBEM_E_OUT_OF_MEMORY;
    hres = pEvent->Put(EGGTIMER_PROP_PROPNAME, 0, &v, 0);
    if(FAILED(hres))
        return hres;
    VariantClear(&v);

    //
    // Retrieve a current copy of the object
    //

    hres = m_pProp->m_pClass->Postprocess(m_pData);
    if(FAILED(hres))
        return hres;

    // 
    // Put it into the event
    //

    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = m_pData->GetObjectPtr();
    V_UNKNOWN(&v)->AddRef();
    hres = pEvent->Put(EGGTIMER_PROP_OBJECT, 0, &v, 0);
    if(FAILED(hres))
        return hres;
    VariantClear(&v);

    //
    // Fire event
    //

    return m_pProp->m_pClass->FireEvent(pEvent);
}

void CEggTimerInstruction::AddRef()
{
    InterlockedIncrement(&m_lRef);
}

void CEggTimerInstruction::Release()
{
    if(InterlockedDecrement(&m_lRef) == 0)
        delete this;
}

//******************************************************************************
//
//                          TIME AVERAGE
//
//******************************************************************************

CTimeAverageData::CTimeAverageData()
    : m_bOn(false)
{
}

HRESULT CTimeAverageProperty::Initialize(IWbemObjectAccess* pObj, 
                                            LPCWSTR wszName)
{
    //
    // Initialize like every other
    //

    HRESULT hres = CTransientProperty::Initialize(pObj, wszName);
    if(FAILED(hres))
        return hres;

    if(m_lHandle == -1)
        return WBEM_E_INVALID_PROPERTY_TYPE;

    //
    // Make sure that the type is REAL64
    //

    if(m_ct != CIM_REAL64)
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    //
    // Get the qualifier set
    //

    IWbemClassObject* pObjObj;
    pObj->QueryInterface(IID_IWbemClassObject, (void**)&pObjObj);
    CReleaseMe rm0(pObjObj);

    IWbemQualifierSet* pSet = NULL;
    hres = pObjObj->GetPropertyQualifierSet(wszName, &pSet);
    if(FAILED(hres))
        return hres;
    CReleaseMe rm1(pSet);

    //
    // Get the target property
    //

    VARIANT v;
    VariantInit(&v);
    CClearMe cm(&v);

    hres = pSet->Get(VALUE_QUALIFIER, 0, &v, NULL);
    if(FAILED(hres))
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    if(V_VT(&v) != VT_BSTR)
        return WBEM_E_INVALID_QUALIFIER_TYPE;
    
    //
    // Get it's handle
    //

    hres = pObj->GetPropertyHandle(V_BSTR(&v), &m_ctValue, &m_lValueHandle);
    if(FAILED(hres))
        return WBEM_E_INVALID_PROPERTY;
    if(m_ctValue != CIM_REAL64 && m_ctValue != CIM_SINT32 && 
        m_ctValue != CIM_UINT32)
    {
        return WBEM_E_INVALID_PROPERTY_TYPE;
    }

    VariantClear(&v);

    //
    // Get the switch property 
    //

    hres = pSet->Get(SWITCH_QUALIFIER, 0, &v, NULL);

    if( SUCCEEDED(hres) )
    {
        if(V_VT(&v) != VT_BSTR)
            return WBEM_E_INVALID_QUALIFIER_TYPE;
    
        //
        // Get it's handle
        //
        
        CIMTYPE ct;
        hres = pObj->GetPropertyHandle(V_BSTR(&v), &ct, &m_lSwitchHandle);
        if(FAILED(hres))
            return WBEM_E_INVALID_PROPERTY;
        if(ct != CIM_BOOLEAN)
            return WBEM_E_INVALID_PROPERTY_TYPE;
    }
    else
    {
        m_lSwitchHandle = -1;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CTimeAverageProperty::Create(CTransientInstance* pInstData)
{
    //
    // Initialize our data
    //

    CTimeAverageData* pData = (CTimeAverageData*)GetData(pInstData);

    new (pData) CTimeAverageData;
    
    return Update(pInstData, pInstData->GetObjectPtr());
}
    
HRESULT CTimeAverageProperty::Update(CTransientInstance* pOldData, 
                        IWbemObjectAccess* pNew)
{
    HRESULT hres;

    CTimeAverageData* pData =  (CTimeAverageData*)GetData(pOldData);
    CWbemTime Now = CWbemTime::GetCurrentTime();

    //
    // Check if we are being switched on or off
    //

    VARIANT_BOOL boSwitch;
    
    long lRead;
    if ( m_lSwitchHandle != -1 )
    {
        hres = pNew->ReadPropertyValue( m_lSwitchHandle, 
                                        sizeof(VARIANT_BOOL), 
                                        &lRead, 
                                        (BYTE*)&boSwitch);
        if(FAILED(hres))
            return hres;
    }
    else
    {
        boSwitch = VARIANT_TRUE;
        hres = WBEM_S_NO_ERROR;
    }

    if(hres == WBEM_S_NO_ERROR)
    {
        //
        // Reset value is being written.  See if it is being changed
        //

        if(boSwitch && !pData->m_bOn)
        {
            //
            // We are being turned on.
            // Make the last known value the current one, startiung now
            //

            double dblVal;
            hres = pOldData->GetObjectPtr()->ReadPropertyValue(m_lValueHandle, 
                                                sizeof(double), &lRead, 
                                                (BYTE*)&dblVal);
            if(FAILED(hres))
                return hres;
        
            if(hres != WBEM_S_NO_ERROR)
            {
                // 
                // NULL.  Hard to average.  Set to 0 for now, hope it is being
                // written, in which we will change it down below
                //

                pData->m_dblLastValue = 0;
            }
            else
                SetValue(pData, dblVal);

            pData->m_LastUpdate = Now;
            pData->m_bOn = true;
        }
        if(!boSwitch && pData->m_bOn)
        {
            //
            // We are being turned off
            //
            // Combine the last value into the sum
            //

            CombineLastValue(pData, Now);
            pData->m_bOn = false;
        }
    }

    if(pData->m_bOn)
    {
        //
        // Check if we ourselves are actually being written
        //
    
        double dblVal;
    
        long lReadPropValue;
        hres = pNew->ReadPropertyValue(m_lHandle, 
                                            sizeof(double), 
                                            &lReadPropValue, 
                                            (BYTE*)&dblVal);
        if(FAILED(hres))
            return hres;
    
        if(hres == WBEM_S_NO_ERROR)
        {
            //
            // We are.  The only acceptable value is 0.  Make sure that's the 
            // one we got.
            //
    
            if(dblVal != 0)
                return WBEM_E_VALUE_OUT_OF_RANGE;
    
            // 
            // It is zero.  Reset everything
            //
    
            pData->m_dblWeightedSum = 0;
            pData->m_SumInterval.SetMilliseconds(0);
            pData->m_LastUpdate = Now;
        }

        //
        // Combine the last value into the sum.
        //

        CombineLastValue(pData, Now);
    
        //
        // Check if our value is being written
        //

        hres = pNew->ReadPropertyValue(m_lValueHandle, 
                                            sizeof(double), 
                                            &lReadPropValue, 
                                            (BYTE*)&dblVal);
        if(FAILED(hres))
            return hres;
    
        if(hres == WBEM_S_NO_ERROR)
        {
            //
            // It is.  Set it
            //

            SetValue(pData, dblVal);
        }
    }

    return WBEM_S_NO_ERROR;
}
    
void CTimeAverageProperty::SetValue(CTimeAverageData* pData, double dblVal)
{
    // 
    // Check the type
    //

    switch(m_ctValue)
    {
    case CIM_REAL64:
        pData->m_dblLastValue = dblVal;
        break;
    case CIM_SINT32:
        pData->m_dblLastValue = *(long*)&dblVal;
        break;
    case CIM_UINT32:
        pData->m_dblLastValue = *(DWORD*)&dblVal;
        break;
    default:
        break;
        // invalid!
    }
}

void CTimeAverageProperty::CombineLastValue(CTimeAverageData* pData, 
                                            const CWbemTime& Now)
{
    if(!pData->m_bOn)
        return;

    //
    // Calclulate the amount of time that the last value stayed in effect
    //

    CWbemInterval Duration = Now - pData->m_LastUpdate;
    if(Duration.IsZero())
        return;

    //
    // Multiple the Last value by the number of ms it stayed in effect
    //

    pData->m_dblWeightedSum += 
        pData->m_dblLastValue * Duration.GetMilliseconds();

    //
    // Append the elapsed time to the time for the sum
    //

    pData->m_SumInterval += Duration;

    //
    // Reset last update
    //

    pData->m_LastUpdate = Now;
}
    
HRESULT CTimeAverageProperty::Get(CTransientInstance* pInstData)
{
    HRESULT hres;

    CTimeAverageData* pData =  (CTimeAverageData*)GetData(pInstData);

    //
    // Combine the last value into the sum
    //

    CombineLastValue(pData, CWbemTime::GetCurrentTime());

    // 
    // Place the weighted sum divided by the time it stayed in effect into the
    // object
    //

    DWORD dwMs = pData->m_SumInterval.GetMilliseconds();
    double dblAverage = 0;
    if(dwMs)
        dblAverage = pData->m_dblWeightedSum / dwMs;

    hres = pInstData->GetObjectPtr()->WritePropertyValue(m_lHandle, 
                                sizeof(double), (BYTE*)&dblAverage);

    if(FAILED(hres))
        return hres;
    
    return WBEM_S_NO_ERROR;
}


HRESULT CTimeAverageProperty::Delete(CTransientInstance* pInstData)
{
    CTimeAverageData* pData =  (CTimeAverageData*)GetData(pInstData);
    pData->~CTimeAverageData();
    return WBEM_S_NO_ERROR;
}

size_t CTimeAverageProperty::GetInstanceDataSize()
{
    return sizeof(CTimeAverageData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprop.h ===
#ifndef __WMI_TRANSIENT_PROP__H_
#define __WMI_TRANSIENT_PROP__H_

#pragma warning(disable: 4786)

#include <string>
#include <map>

#include <cwbemtime.h>
#include <tss.h>
#include "trnsinst.h"

class CTransientClass;
class CTransientProperty
{
protected:
    LPWSTR m_wszName;
    long m_lHandle;
    CIMTYPE m_ct;
    size_t m_nOffset;

protected:
    CTransientProperty();
    static HRESULT CreateNode(CTransientProperty** ppProp, 
                                IWbemQualifierSet* pSet);

public:
    virtual ~CTransientProperty();
    LPCWSTR GetName() const {return m_wszName;}

    static HRESULT CreateNew(CTransientProperty** ppProp, 
                                IWbemObjectAccess* pClass, 
                                LPCWSTR wszName);

    virtual size_t GetInstanceDataSize() {return 0;}
    virtual void SetInstanceDataOffset(size_t nOffset) {m_nOffset = nOffset;}
    virtual void SetClass(CTransientClass* pClass) {}

    virtual HRESULT Initialize(IWbemObjectAccess* pObj, LPCWSTR wszName);
    virtual HRESULT Create(CTransientInstance* pInstData);
    virtual HRESULT Update(CTransientInstance* pOldData, 
                            IWbemObjectAccess* pNew);
    virtual HRESULT Get(CTransientInstance* pInstData);
    virtual HRESULT Delete(CTransientInstance* pInstData);
    void* GetData(CTransientInstance* pInst) 
        {return pInst->GetOffset(m_nOffset);}
};

class CTimerProperty;
class CEggTimerInstruction : public CTimerInstruction
{
protected:
    long m_lRef;
    CWbemTime m_Time;
    CTimerProperty* m_pProp;
    CTransientInstance* m_pData;
    
public:
    CEggTimerInstruction(CTimerProperty* pProp, CTransientInstance* pData,
                            const CWbemTime& Time);
    HRESULT Fire(long lNumTimes, CWbemTime NextFiringTime);
    CWbemTime GetFirstFiringTime() const {return m_Time;}
    CWbemTime GetNextFiringTime(CWbemTime LastFiringTime, long* plCount) const
    {
        *plCount = 1;
        return CWbemTime::GetInfinity();
    }
    void AddRef();
    void Release();
    int GetInstructionType() {return 0;}
};

class CTimerProperty : public CTransientProperty
{
protected:
    static CTimerGenerator mstatic_Generator;
    CTransientClass* m_pClass;

public:
    CTimerProperty(){}
    ~CTimerProperty();

    virtual HRESULT Initialize(IWbemObjectAccess* pObj, LPCWSTR wszName);
    virtual HRESULT Create(CTransientInstance* pInstData);
    virtual HRESULT Update(CTransientInstance* pOldData, 
                            IWbemObjectAccess* pNew);
    virtual HRESULT Get(CTransientInstance* pInstData);
    virtual HRESULT Delete(CTransientInstance* pInstData);
    virtual void SetClass(CTransientClass* pClass);
    virtual size_t GetInstanceDataSize();

protected:
    HRESULT Set(CTransientInstance* pInstData, IWbemObjectAccess* pObj);
    static CTimerGenerator& GetGenerator() {return mstatic_Generator;}

    friend class CTimerPropertyData;
    friend class CEggTimerInstruction;
};
    
class CTimerPropertyData
{
protected:
    CEggTimerInstruction* m_pCurrentInst;
    CCritSec m_cs;
    CWbemTime m_Next;
    CWbemInterval m_Interval;

    friend class CTimerProperty;
public:
    CTimerPropertyData() : m_pCurrentInst(NULL){}
    ~CTimerPropertyData();

    void ResetInstruction();

};

class CTimeAverageData;
class CTimeAverageProperty : public CTransientProperty
{
protected:
    CIMTYPE m_ctValue;
    long m_lValueHandle;
    long m_lSwitchHandle;
    
public:
    CTimeAverageProperty(){}
    ~CTimeAverageProperty(){}

    virtual HRESULT Initialize(IWbemObjectAccess* pObj, LPCWSTR wszName);
    virtual HRESULT Create(CTransientInstance* pInstData);
    virtual HRESULT Update(CTransientInstance* pOldData, 
                            IWbemObjectAccess* pNew);
    virtual HRESULT Get(CTransientInstance* pInstData);
    virtual HRESULT Delete(CTransientInstance* pInstData);
    virtual size_t GetInstanceDataSize();
protected:
    void SetValue(CTimeAverageData* pData, double dblVal);
    void CombineLastValue(CTimeAverageData* pData, const CWbemTime& Now);
};

class CTimeAverageData
{
protected:
    double m_dblWeightedSum;
    CWbemInterval m_SumInterval;
    CWbemTime m_LastUpdate;
    double m_dblLastValue;
    bool m_bOn;

    friend CTimeAverageProperty;

public:
    CTimeAverageData();
};

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\trnsprov\trnsprov.h ===
#ifndef __WMI_TRANSIENT_PROVIDER__H_
#define __WMI_TRANSIENT_PROVIDER__H_

#include <unk.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <map>
#include <wstlallc.h>
#include "trnscls.h"

class CTransientProvider : public CUnk
{
protected:
    class XProv : public CImpl<IWbemServices, CTransientProvider>
    {
    public:
        XProv(CTransientProvider* pObject) 
            : CImpl<IWbemServices, CTransientProvider>(pObject)
        {}
		  HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
        {
            return m_pObject->GetObjectAsync(ObjectPath, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
        {
            return m_pObject->PutInstanceAsync(pInst, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
        {
            return m_pObject->DeleteInstanceAsync(ObjectPath, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
        {
            return m_pObject->CreateInstanceEnumAsync(Class, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
        {
            return m_pObject->ExecQueryAsync(QueryLanguage, Query, lFlags, pCtx, pSink);
        }
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
        
        HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
            IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

        HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
            IWbemContext*, IWbemClassObject*, IWbemObjectSink*) {return WBEM_E_NOT_SUPPORTED;}

    } m_XProv;
    friend XProv;

    class XClassChangeSink : public CImpl<IWbemObjectSink, CTransientProvider>
    {
    public:
         XClassChangeSink( CTransientProvider* pObject )
         : CImpl<IWbemObjectSink, CTransientProvider>(pObject) {}

         STDMETHOD(Indicate)( long cObjs, IWbemClassObject** ppObjs );
        
         STDMETHOD(SetStatus)( long lFlags,
                               HRESULT hResult,
                               BSTR strParam,
                               IWbemClassObject* pObjParam )
         {
             return WBEM_S_NO_ERROR;
         }
    } m_XClassChangeSink;

    friend class XClassChangeSink;

    class XInit : public CImpl<IWbemProviderInit, CTransientProvider>
    {
    public:
        XInit(CTransientProvider* pObject) 
            : CImpl<IWbemProviderInit, CTransientProvider>(pObject)
        {}
        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        )
        {
            return m_pObject->Init(pszNamespace, pNamespace, pCtx, pInitSink);
        }
    } m_XInit;
    friend XInit;

protected:

    CCritSec m_cs;

    IWbemServices* m_pNamespace;
    CTransientProvider* m_pRedirectTo;

    LPWSTR m_wszName;
    IWbemObjectSink* m_pSink;
    typedef std::map< WString, 
                      CWbemPtr<CTransientClass>, 
                      WSiless, 
                      wbem_allocator<CWbemPtr<CTransientClass> > > TMap;
    typedef TMap::iterator TIterator;
    TMap m_mapClasses;

    IWbemDecoupledBasicEventProvider* m_pDES;
    IWbemObjectSink* m_pEventSink;

    IWbemClassObject* m_pEggTimerClass;
    IWbemClassObject* m_pCreationClass;
    IWbemClassObject* m_pDeletionClass;
    IWbemClassObject* m_pModificationClass;

    void PurgeClass( LPCWSTR wszName );

public:

    CTransientProvider(CLifeControl* pControl, IUnknown* pOuter = NULL);
    ~CTransientProvider();
    void* GetInterface(REFIID riid);

    ULONG STDMETHODCALLTYPE Release();

    HRESULT GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    HRESULT CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    HRESULT ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    HRESULT DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);
    HRESULT PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink);

    HRESULT Init(
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink );

    static HRESULT ModuleInitialize();
    static HRESULT ModuleUninitialize();

    HRESULT FireEvent(IWbemClassObject* pEvent);
    INTERNAL IWbemClassObject* GetEggTimerClass() {return m_pEggTimerClass;}
    INTERNAL IWbemClassObject* GetCreationClass() {return m_pCreationClass;}
    INTERNAL IWbemClassObject* GetDeletionClass() {return m_pDeletionClass;}
    INTERNAL IWbemClassObject* GetModificationClass() 
        {return m_pModificationClass;}
protected:

    HRESULT FireIntrinsicEvent(IWbemClassObject* pClass,
            IWbemObjectAccess* pTarget, IWbemObjectAccess* pPrev = NULL);
};



class CTransientEventProvider : public CUnk
{
    class XInit : public CImpl<IWbemProviderInit, CTransientEventProvider>
    {
    public:
        XInit(CTransientEventProvider* pObject) 
        : CImpl<IWbemProviderInit, CTransientEventProvider>(pObject)
        {}
        HRESULT STDMETHODCALLTYPE Initialize(
             /* [in] */ LPWSTR pszUser,
             /* [in] */ LONG lFlags,
             /* [in] */ LPWSTR pszNamespace,
             /* [in] */ LPWSTR pszLocale,
             /* [in] */ IWbemServices *pNamespace,
             /* [in] */ IWbemContext *pCtx,
             /* [in] */ IWbemProviderInitSink *pInitSink
                        )
        {
            return m_pObject->Init(pszNamespace, pNamespace, pCtx, pInitSink);
        }
    } m_XInit;
    friend XInit;

    class XEvent : public CImpl<IWbemEventProvider, CTransientEventProvider>
    {
    public:
        XEvent(CTransientEventProvider* pObject) 
        : CImpl<IWbemEventProvider, CTransientEventProvider>(pObject)
        {}
        HRESULT STDMETHODCALLTYPE ProvideEvents(IWbemObjectSink* pSink, 
                                                long lFlags)
        {
            return m_pObject->ProvideEvents(lFlags, pSink);
        }
    } m_XEvent;
    friend XEvent;

 protected:
    LPWSTR m_wszName;
    IWbemClassObject* m_pRebootEventClass;
    BOOL m_bLoadedOnReboot;
    
 protected:
    HRESULT Init(LPWSTR pszNamespace, IWbemServices* pNamespace, 
                    IWbemContext* pCtx, IWbemProviderInitSink *pInitSink);
    HRESULT ProvideEvents(long lFlags, IWbemObjectSink* pSink);

 public:
    CTransientEventProvider(CLifeControl* pControl, IUnknown* pOuter = NULL);
    ~CTransientEventProvider();
    void* GetInterface(REFIID riid);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updassoc.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <clsfac.h>
#include <pathutl.h>
#include "updassoc.h"

static CWbemBSTR g_bsAssocClass= L"MSFT_UCScenarioAssociation";
static CWbemBSTR g_bsQueryLang = L"WQL";

const LPWSTR g_wszClass = L"__Class";
const LPWSTR g_wszScenario = L"Scenario";
const LPWSTR g_wszId = L"Id";
const LPWSTR g_wszScenarioClass = L"MSFT_UCScenario";
const LPWSTR g_wszState = L"Object";
const LPWSTR g_wszStateQuery = L"Query";
const LPWSTR g_wszRelpath = L"__Relpath";
const LPWSTR g_wszAssocInfoQuery = 
   L"SELECT * FROM MSFT_UCScenarioAssociationInfo";

HRESULT CUpdConsAssocProvider::Init( IWbemServices* pSvc, 
                                     IWbemProviderInitSink* pInitSink ) 
{
    HRESULT hr;

    m_pSvc = pSvc;
    
    hr = m_pSvc->GetObject( g_bsAssocClass, 0, NULL, &m_pAssocClass, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pInitSink->SetStatus( WBEM_S_INITIALIZED, WBEM_S_NO_ERROR ); 
}

HRESULT CUpdConsAssocProvider::GetObject( BSTR bstrPath, 
                                          IWbemObjectSink* pResHndlr )
{
    CRelativeObjectPath RelPath;

    if ( !RelPath.Parse( bstrPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ParsedObjectPath* pPath = RelPath.m_pPath;

    _DBG_ASSERT( pPath->m_pClass != NULL );

    if ( _wcsicmp( pPath->m_pClass, g_bsAssocClass ) != 0 )
    {
        return WBEM_E_NOT_FOUND;
    }

    if ( pPath->m_dwNumKeys != 2 ||
         _wcsicmp( pPath->m_paKeys[0]->m_pName, g_wszState ) != 0 || 
         _wcsicmp( pPath->m_paKeys[1]->m_pName, g_wszScenario ) != 0  ||
         V_VT(&pPath->m_paKeys[0]->m_vValue) != VT_BSTR ||
         V_VT(&pPath->m_paKeys[1]->m_vValue) != VT_BSTR )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Get and validate scenario path.
    //

    LPWSTR wszScenarioPath = V_BSTR(&pPath->m_paKeys[1]->m_vValue);

    CRelativeObjectPath ScenarioPath;

    if ( !ScenarioPath.Parse( wszScenarioPath ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    ParsedObjectPath* pScenarioPath = ScenarioPath.m_pPath;

    _DBG_ASSERT( pScenarioPath->m_pClass != NULL );

    if ( _wcsicmp( pScenarioPath->m_pClass, g_wszScenarioClass ) != 0 || 
         pScenarioPath->m_dwNumKeys != 1 || 
         V_VT(&pScenarioPath->m_paKeys[0]->m_vValue) != VT_BSTR || 
         (pScenarioPath->m_paKeys[0]->m_pName != NULL && 
         _wcsicmp( pScenarioPath->m_paKeys[0]->m_pName, g_wszId ) != 0 ) )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    //
    // Derive the Scenario name from the path.
    //

    LPWSTR wszScenario = V_BSTR(&pScenarioPath->m_paKeys[0]->m_vValue);

    //
    // Get the state path. We do not need to validate it, since it will be
    // compared with validated paths.  However, since it will be compared
    // with other paths, it needs to be normalized.  This will be done 
    // in GetInstances though.
    // 

    LPWSTR wszStatePath = V_BSTR(&pPath->m_paKeys[0]->m_vValue);

    HRESULT hr = GetInstances( wszScenario, wszStatePath, pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

//
// wszScenario is used to scope the query for the Assoc Info objects.(optional)
// wszStatePath is used to filter the returned objects. (optional).
//
HRESULT CUpdConsAssocProvider::GetInstances( LPCWSTR wszScenario, 
                                             LPCWSTR wszStatePath,
                                             IWbemObjectSink* pResHndlr )
{
    HRESULT hr;
    
    CWbemBSTR bsAssocInfoQuery = g_wszAssocInfoQuery;
    
    if ( wszScenario != NULL )
    {
        bsAssocInfoQuery += L" WHERE Scenario = '";
        bsAssocInfoQuery += wszScenario;
        bsAssocInfoQuery += L"'";
    }

    CWbemPtr<IEnumWbemClassObject> pAssocInfoObjs;

    hr = m_pSvc->ExecQuery( g_bsQueryLang,
                            bsAssocInfoQuery,
                            WBEM_FLAG_FORWARD_ONLY,
                            NULL,
                            &pAssocInfoObjs );
    if ( FAILED(hr) )
    {
        return hr;
    }

    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pAssocInfo;
    
    hr = pAssocInfoObjs->Next( WBEM_INFINITE, 1, &pAssocInfo, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs ==  1 );

        //
        // first get the scenario name from the assoc info ...
        //

        CPropVar vScenario;
        
        hr = pAssocInfo->Get( g_wszScenario, 0, &vScenario, NULL, NULL);
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        CWbemBSTR bsScenarioPath = g_wszScenarioClass;
        bsScenarioPath += L"='";
        bsScenarioPath += V_BSTR(&vScenario);
        bsScenarioPath += L"'";
    
        //
        // Now get the state query from the assoc info and execute it
        //

        CPropVar vStateQuery;

        hr = pAssocInfo->Get( g_wszStateQuery, 0, &vStateQuery, NULL, NULL );

        if ( FAILED(hr) && FAILED( hr = vStateQuery.CheckType( VT_BSTR ) ) )
        {
            return hr;
        }
        
        CWbemPtr<IEnumWbemClassObject> pStateObjs;

        hr = m_pSvc->ExecQuery( g_bsQueryLang,
                                V_BSTR(&vStateQuery),
                                WBEM_FLAG_FORWARD_ONLY,
                                NULL,
                                &pStateObjs );
        if ( FAILED(hr) )
        {
            return hr;
        }

        // 
        // Enumerate the state objects and for each one create an assoc obj
        //

        CWbemPtr<IWbemClassObject> pState;
        
        hr = pStateObjs->Next( WBEM_INFINITE, 1, &pState, &cObjs );

        while( hr == WBEM_S_NO_ERROR )
        {
            _DBG_ASSERT( cObjs ==  1 );

            VARIANT varStatePath;
            hr = pState->Get( g_wszRelpath, 0, &varStatePath, NULL, NULL );

            if ( FAILED(hr) )
            {
                return hr;
            }
            
            _DBG_ASSERT( V_VT(&varStatePath) );

            BOOL bCheck = TRUE;

            if ( wszStatePath != NULL )
            {
                CRelativeObjectPath PathA, PathB;
                if ( !PathA.Parse( wszStatePath ) || 
                     !PathB.Parse( V_BSTR(&varStatePath) ) )
                {
                    return WBEM_E_INVALID_OBJECT_PATH;
                }

                bCheck = PathA == PathB;
            }

            if ( bCheck )
            {            
                CWbemPtr<IWbemClassObject> pAssoc;
                hr = m_pAssocClass->SpawnInstance( 0, &pAssoc );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                VARIANT var;

                V_VT(&var) = VT_BSTR;
                V_BSTR(&var) = bsScenarioPath;

                hr = pAssoc->Put( g_wszScenario, 0, &var, NULL );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                hr = pAssoc->Put( g_wszState, 0, &varStatePath, NULL );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                hr = pResHndlr->Indicate( 1, &pAssoc );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                if ( wszStatePath != NULL )
                {
                    return WBEM_S_NO_ERROR;
                }
            }

            hr = pStateObjs->Next( WBEM_INFINITE, 1, &pState, &cObjs );
        }
 
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pAssocInfoObjs->Next( WBEM_INFINITE, 1, &pAssocInfo, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( wszStatePath != NULL )
    {
        //
        // we did not find a match for the state path
        //

        return WBEM_E_NOT_FOUND;
    }

    return WBEM_S_NO_ERROR;
}


HRESULT CUpdConsAssocProvider::GetAllInstances( LPWSTR wszClassname, 
                                                IWbemObjectSink* pResHndlr)
{
    if ( _wcsicmp( wszClassname, g_bsAssocClass ) != 0 )
    {
        return WBEM_E_NOT_FOUND;
    }
    
    HRESULT hr = GetInstances( NULL, NULL, pResHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pResHndlr->SetStatus( WBEM_STATUS_COMPLETE, 
                                 WBEM_S_NO_ERROR, 
                                 NULL, 
                                 NULL );
}

void* CUpdConsAssocProvider::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInitialize;
    }
    
    if ( riid == IID_IWbemServices )
    {
        return &m_XServices;
    }

    return NULL;
}

CUpdConsAssocProvider::CUpdConsAssocProvider( CLifeControl* pCtl, 
                                              IUnknown* pUnk )
: m_XServices(this), m_XInitialize(this), CUnk( pCtl, pUnk )
{

}    

CUpdConsAssocProvider::XServices::XServices( CUpdConsAssocProvider* pProv )
: CImpl< IWbemServices, CUpdConsAssocProvider> ( pProv )
{

}

CUpdConsAssocProvider::XInitialize::XInitialize( CUpdConsAssocProvider* pProv )
: CImpl< IWbemProviderInit, CUpdConsAssocProvider> ( pProv )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updassoc.h ===
#ifndef __UPDASSOC_H__
#define __UPDASSOC_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <unk.h>

class CUpdConsAssocProvider : public CUnk
{
    // IWbemProviderInit
    struct XInitialize : public CImpl< IWbemProviderInit, 
                                       CUpdConsAssocProvider >
    {
        XInitialize( CUpdConsAssocProvider* pProv );

        STDMETHOD(Initialize)( 
            /* [string][unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [string][in] */ LPWSTR wszNamespace,
            /* [string][unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices* pNamespace,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, pInitSink );
        }

    } m_XInitialize;

    // IWbemServices
    struct XServices : public CImpl<IWbemServices, CUpdConsAssocProvider>
    {
        XServices( CUpdConsAssocProvider* pProv );

	STDMETHOD(OpenNamespace)( 
            /* [in] */ const BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemServices** ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult** ppResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
  
        STDMETHOD(CancelAsyncCall)( /* [in] */ IWbemObjectSink* pSink )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(QueryObjectSink)( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink** ppResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObject)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemClassObject** ppObject,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(GetObjectAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetObject( strObjectPath, pResponseHandler );
        }
        
        STDMETHOD(PutClass)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutClassAsync)( 
            /* [in] */ IWbemClassObject* pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
             
        STDMETHOD(DeleteClass)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteClassAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnum)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateClassEnumAsync)( 
            /* [in] */ const BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstance)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(PutInstanceAsync)( 
            /* [in] */ IWbemClassObject* pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(DeleteInstance)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(DeleteInstanceAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnum)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(CreateInstanceEnumAsync)( 
            /* [in] */ const BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return m_pObject->GetAllInstances( strClass, pResponseHandler );
        }
        
        STDMETHOD(ExecQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        STDMETHOD(ExecQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQuery)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [out] */ IEnumWbemClassObject** ppEnum ) 
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecNotificationQueryAsync)( 
            /* [in] */ const BSTR strQueryLanguage,
            /* [in] */ const BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethod)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemClassObject *pInParams,
            /* [unique][in][out] */ IWbemClassObject** ppOutParams,
            /* [unique][in][out] */ IWbemCallResult** ppCallResult)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        STDMETHOD(ExecMethodAsync)( 
            /* [in] */ const BSTR strObjectPath,
            /* [in] */ const BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemClassObject* pInParams,
            /* [in] */ IWbemObjectSink* pResponseHandler )
        {
            return WBEM_E_NOT_SUPPORTED;
        }

    } m_XServices;

    CWbemPtr<IWbemClassObject> m_pAssocClass;
    CWbemPtr<IWbemServices> m_pSvc;

    HRESULT GetInstances( LPCWSTR wszScenario,
                          LPCWSTR wszStatePath,
                          IWbemObjectSink* pResHndlr );

public:

    CUpdConsAssocProvider( CLifeControl* pCtl = NULL, IUnknown* pUnk = NULL );
    void* GetInterface( REFIID );

    HRESULT Init( IWbemServices* pSvc, IWbemProviderInitSink* pInitSink );
    HRESULT GetObject( BSTR bstrPath, IWbemObjectSink* pResponseHndlr );
    HRESULT GetAllInstances( LPWSTR wszClassname, IWbemObjectSink* pResHndlr );
};

#endif // __UPDASSOC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcmd.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <wbemcli.h>
#include <arrtempl.h>
#include "updcmd.h"
#include "updnspc.h"
#include "updsink.h"

const LPCWSTR g_wszDataAlias = L"__THISDATA";
const LPCWSTR g_wszEventAlias = L"__THISEVENT";
const LPCWSTR g_wszUpdateEventClass = L"MSFT_UCEventBase";
const LPCWSTR g_wszDynamic = L"Dynamic";
const LPCWSTR g_wszProvider = L"Provider";
const LPCWSTR g_wszServer = L"__Server";
const LPCWSTR g_wszNamespace = L"__Namespace";
const LPCWSTR g_wszTransientProvider = L"Microsoft WMI Transient Provider";

// {405595AA-1E14-11d3-B33D-00105A1F4AAF}
static const GUID CLSID_TransientProvider =
{ 0x405595aa, 0x1e14, 0x11d3, {0xb3, 0x3d, 0x0, 0x10, 0x5a, 0x1f, 0x4a, 0xaf}};

class CWbemProviderInitSink : public IWbemProviderInitSink
{
    STDMETHOD_(ULONG, AddRef)() { return 1; }
    STDMETHOD_(ULONG, Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID, void** ) { return NULL; }
    STDMETHOD(SetStatus) ( long lStatus, long lFlags ) { return lFlags; }
};

inline void RemoveAliasKeyword( CPropertyName& rAlias )
{
    CPropertyName NewProp;

    long cElements = rAlias.GetNumElements();
    
    for( long i=1; i < cElements; i++ )
    {
        NewProp.AddElement( rAlias.GetStringAt(i) );
    }
    
    rAlias = NewProp;
}

// this should be a global function of qllex.cpp or something.
int FlipOperator(int nOp)
{
    switch(nOp)
    {
    case QL1_OPERATOR_GREATER:
        return QL1_OPERATOR_LESS;
        
    case QL1_OPERATOR_LESS:
        return QL1_OPERATOR_GREATER;
        
    case QL1_OPERATOR_LESSOREQUALS:
        return QL1_OPERATOR_GREATEROREQUALS;
        
    case QL1_OPERATOR_GREATEROREQUALS:
        return QL1_OPERATOR_LESSOREQUALS;

    case QL1_OPERATOR_ISA:
        return QL1_OPERATOR_INV_ISA;

    case QL1_OPERATOR_ISNOTA:
        return QL1_OPERATOR_INV_ISNOTA;

    case QL1_OPERATOR_INV_ISA:
        return QL1_OPERATOR_ISA;

    case QL1_OPERATOR_INV_ISNOTA:
        return QL1_OPERATOR_ISNOTA;

    default:
        return nOp;
    }
}

inline HRESULT SetPropHandle( CPropertyName& rPropName, 
                              IWmiObjectAccessFactory* pAccessFact )
{
    HRESULT hr;
    LPVOID pvHandle;
    
    LPWSTR wszPropName = rPropName.GetText();

    if ( wszPropName == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pAccessFact->GetPropHandle( wszPropName, 0, &pvHandle );

    delete wszPropName;

    if ( FAILED(hr) )
    {
        return hr;
    }

    rPropName.SetHandle( pvHandle );

    return WBEM_S_NO_ERROR;
}  

HRESULT IsClassTransient( IWbemClassObject* pClassObj )
{
    //
    // We can tell for sure a class is transient if it is backed by
    // the transient provider.
    //

    HRESULT hr;

    CWbemPtr<IWbemQualifierSet> pQualSet;

    hr = pClassObj->GetQualifierSet( &pQualSet );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pQualSet->Get( g_wszDynamic, 0, NULL, NULL );

    if ( hr == WBEM_E_NOT_FOUND )
    {
        return WBEM_S_FALSE;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    VARIANT varProvider;
    VariantInit( &varProvider );
    CClearMe cmvarProvider( &varProvider );

    hr = pQualSet->Get( g_wszProvider, 0, &varProvider, NULL );

    if ( hr == WBEM_E_NOT_FOUND || V_VT(&varProvider) != VT_BSTR )
    {
        return WBEM_E_INVALID_OBJECT;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    if ( _wcsicmp( V_BSTR(&varProvider), g_wszTransientProvider ) != 0 )
    {
        return WBEM_S_FALSE;
    }
    return WBEM_S_NO_ERROR;
}

//
// if S_FALSE is returned, then ppDirectSvc will be NULL.
//
HRESULT GetDirectSvc( IWbemClassObject* pClassObj, 
                      IWbemServices* pUpdSvc,
                      IWbemServices** ppDirectSvc )
{
    HRESULT hr;
    *ppDirectSvc = NULL;

    // 
    // if the svc pointer is remote, then we cannot perform the optimization.  
    // this is because queries for the state will be issued to the svc ptr 
    // and will return nothing, because the state will only live in this 
    // process.  In short, the transient state must ALWAYS exist in the 
    // winmgmt process.
    //

    CWbemPtr<IClientSecurity> pClientSec;
    hr = pUpdSvc->QueryInterface( IID_IClientSecurity, (void**)&pClientSec );
    
    if ( SUCCEEDED(hr) )
    {
        return WBEM_S_FALSE;
    }

    // 
    // we can perform the optimization.  Get the namespace str and 
    // instantiate the transient provider.
    //

    VARIANT varNamespace;

    hr = pClassObj->Get( g_wszNamespace, 0, &varNamespace, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    _DBG_ASSERT( V_VT(&varNamespace) == VT_BSTR );
    CClearMe cmvarNamespace( &varNamespace );

    CWbemPtr<IWbemProviderInit> pDirectInit;
    hr = CoCreateInstance( CLSID_TransientProvider, 
                           NULL, 
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemProviderInit,
                           (void**)&pDirectInit );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemProviderInitSink InitSink;
    hr = pDirectInit->Initialize( NULL, 0, V_BSTR(&varNamespace), 
                                  NULL, pUpdSvc, NULL, &InitSink );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pDirectInit->QueryInterface(IID_IWbemServices, (void**)ppDirectSvc);
}

/********************************************************************
  CUpdConsCommand
*********************************************************************/

HRESULT CUpdConsCommand::ProcessUpdateQuery( LPCWSTR wszUpdateQuery,
                                             IWbemServices* pUpdSvc,
                                             CUpdConsState& rState,
                                             IWbemClassObject** ppUpdClass )  
{
    HRESULT hr;
    *ppUpdClass = NULL;

    CTextLexSource Lexer( wszUpdateQuery );
    CSQLParser Parser( Lexer );

    if ( Parser.Parse( m_SqlCmd ) != 0 )
    {  
        rState.SetErrStr( Parser.CurrentToken() );
        return WBEM_E_INVALID_QUERY;
    }

    if ( m_SqlCmd.m_eCommandType == SQLCommand::e_Select )
    {
        rState.SetErrStr( wszUpdateQuery );
        return WBEM_E_QUERY_NOT_IMPLEMENTED;
    }

    hr = pUpdSvc->GetObject( m_SqlCmd.bsClassName, 
                             0, 
                             NULL, 
                             ppUpdClass, 
                             NULL);
    if ( FAILED(hr) ) 
    {
        rState.SetErrStr( m_SqlCmd.bsClassName );
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::ProcessDataQuery( LPCWSTR wszDataQuery,
                                           IWbemServices* pDataSvc,
                                           CUpdConsState& rState,
                                           IWbemClassObject** ppDataClass )  
{
    *ppDataClass = NULL;
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::ProcessEventQuery( LPCWSTR wszEventQuery,
                                            IWbemServices* pEventSvc,
                                            CUpdConsState& rState,
                                            IWbemClassObject** ppEventClass )  
{
    //
    // TODO: in the future we should be able to optimize the correlator 
    // for the incoming events too.  It would be nice to know the type of 
    // incoming events so that we can obtain fast accessors.
    //
    *ppEventClass = NULL;
    return WBEM_S_NO_ERROR;
}
    

HRESULT CUpdConsCommand::InitializeAccessFactories(IWbemClassObject* pUpdClass)
{
    HRESULT hr;

    //
    // obtain access factories and prepare them for fetching prop access hdls.
    //

    CWbemPtr<IClassFactory> pClassFact;

    hr = CoGetClassObject( CLSID_WmiSmartObjectAccessFactory,
                           CLSCTX_INPROC,
                           NULL,
                           IID_IClassFactory,
                           (void**)&pClassFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pClassFact->CreateInstance( NULL, 
                                     IID_IWmiObjectAccessFactory, 
                                     (void**)&m_pEventAccessFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pClassFact->CreateInstance( NULL, 
                                     IID_IWmiObjectAccessFactory, 
                                     (void**)&m_pDataAccessFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pClassFact->CreateInstance( NULL, 
                                     IID_IWmiObjectAccessFactory, 
                                     (void**)&m_pInstAccessFact );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pInstAccessFact->SetObjectTemplate( pUpdClass );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

/********************************************************************

  InitializePropertyInfo() - This method examines the SQLCommand object and 
  constructs a summary to aid in its execution. It also finishes checking 
  the semantics of the SQL command.  Since the parser does not have
  the alias support built into it, it is checked here.
  
  This method does modify the SQLCommand by removing the ALIAS keywords
  DATA/OBJECT from the property names.  

  This method also obtains a property access handle from the appropriate 
  access factory for the each referenced property and stores it with the 
  prop structure.

********************************************************************/

HRESULT CUpdConsCommand::InitializePropertyInfo( CUpdConsState& rState )      
{
    HRESULT hr;
    LPCWSTR wszAlias;

    //
    // process properties in the assignment tokens.
    // 

    _DBG_ASSERT( m_SqlCmd.nNumberOfProperties == 
                 m_SqlCmd.m_AssignmentTokens.size() );

    int i;
    for( i=0; i < m_SqlCmd.m_AssignmentTokens.size(); i++ )
    {
        SQLAssignmentToken& rAssignToken = m_SqlCmd.m_AssignmentTokens[i];

        for( int j=0; j < rAssignToken.size(); j++ )
        {
            CPropertyName& rPropName = rAssignToken[j].m_PropName;

            if ( rPropName.GetNumElements() == 0 )
            {
                continue;
            }
        
            wszAlias = rPropName.GetStringAt(0);
        
            _DBG_ASSERT(wszAlias != NULL);

            if ( _wcsicmp( wszAlias, g_wszDataAlias ) == 0 )
            {
                m_DataAliasOffsets.AddAssignOffset( i, j );
                RemoveAliasKeyword( rPropName );
                hr = SetPropHandle( rPropName, m_pDataAccessFact );
            }
            else if ( _wcsicmp( wszAlias, g_wszEventAlias ) == 0 )
            {
                m_EventAliasOffsets.AddAssignOffset( i, j );
                RemoveAliasKeyword( rPropName );
                hr = SetPropHandle( rPropName, m_pEventAccessFact );
            }
            else
            {
                hr = SetPropHandle( rPropName, m_pInstAccessFact );
            }

            if ( FAILED(hr) )
            {
                rState.SetErrStr( wszAlias );
                return hr;
            }
        }

        //
        // process property on the left side of the assignment.
        //
        
        CPropertyName& rPropName = m_SqlCmd.pRequestedPropertyNames[i];

        _DBG_ASSERT( rPropName.GetNumElements() > 0 );

        hr = SetPropHandle( rPropName, m_pInstAccessFact );

        if ( FAILED(hr) )
        {
            rState.SetErrStr( wszAlias );
            return hr;
        }
    }

    //
    // process properties in the condition clause 
    // 

    // TODO : I should be setting the bPropComp value in a token 
    // to FALSE after detecting the presence of an alias. However, 
    // the alias name is stored in the Prop2 member of the token and
    // that will not be copied by the assignment op or copy ctor if 
    // bPropComp is false.  This should be fixed, but in the meanwhile I'm
    // going to use the presence of a value in the vConstValue to signal
    // that it is not a real prop compare.

    for( i=0; i < m_SqlCmd.nNumTokens; i++ )
    {
        CPropertyName& rProp1 = m_SqlCmd.pArrayOfTokens[i].PropertyName; 
        CPropertyName& rProp2 = m_SqlCmd.pArrayOfTokens[i].PropertyName2;

        if ( m_SqlCmd.pArrayOfTokens[i].nTokenType != 
             QL_LEVEL_1_TOKEN::OP_EXPRESSION )
        {
            continue;
        }

        _DBG_ASSERT( rProp1.GetNumElements() > 0 );

        wszAlias = rProp1.GetStringAt(0);
        
        _DBG_ASSERT( wszAlias != NULL );
        BOOL bAlias = FALSE;
        
        if ( _wcsicmp( wszAlias, g_wszDataAlias ) == 0 )
        {
            bAlias = TRUE;
            m_DataAliasOffsets.AddWhereOffset(i);
            RemoveAliasKeyword( rProp1 );
            hr = SetPropHandle( rProp1, m_pDataAccessFact );
        }
        else if ( _wcsicmp( wszAlias, g_wszEventAlias ) == 0 )
        {
            bAlias = TRUE;
            m_EventAliasOffsets.AddWhereOffset(i);
            RemoveAliasKeyword( rProp1 );
            hr = SetPropHandle( rProp1, m_pEventAccessFact );
        }
        else
        {
            hr = SetPropHandle( rProp1, m_pInstAccessFact );
        }

        if ( FAILED(hr) )
        {
            rState.SetErrStr( wszAlias );
            return hr;
        }

        if ( !m_SqlCmd.pArrayOfTokens[i].m_bPropComp ) 
        {
            if ( bAlias )
            {
                //
                // this means that someone is trying to compare an 
                // alias to const val.  Not a valid use of aliases.
                //

                rState.SetErrStr( wszAlias );
                return WBEM_E_INVALID_QUERY;
            }
            else
            {
                continue;
            }
        }
                
        _DBG_ASSERT( rProp2.GetNumElements() > 0 );
        wszAlias = rProp2.GetStringAt(0);
        _DBG_ASSERT( wszAlias != NULL );
        
        if ( _wcsicmp( wszAlias, g_wszDataAlias ) == 0 )
        {
            if ( !bAlias )
            {
                m_DataAliasOffsets.AddWhereOffset(i);
                RemoveAliasKeyword( rProp2 );
                hr = SetPropHandle( rProp2, m_pDataAccessFact );
            }
            else
            {
                hr = WBEM_E_INVALID_QUERY;
            }
        }
        else if ( _wcsicmp( wszAlias, g_wszEventAlias ) == 0 )
        {
            if ( !bAlias )
            {
                m_EventAliasOffsets.AddWhereOffset(i);
                RemoveAliasKeyword( rProp2 );
                hr = SetPropHandle( rProp2, m_pEventAccessFact );
            }
            else
            {
                hr = WBEM_E_INVALID_QUERY;
            }
        }
        else
        {
            hr = SetPropHandle( rProp2, m_pInstAccessFact );

            if ( bAlias )
            {
                // this is the case we where have a real propname as the 
                // second prop and an alias as the first.  We must adjust 
                // the token so that the real propname is first and the alias 
                // is second because we need to stay consistent 
                // with the prop <rel_operator> const model which the QL1 
                // Parser has established.
                
                CPropertyName Tmp = rProp1;
                rProp1 = rProp2;
                rProp2 = Tmp;
                
                // of course the operator must be flipped ..
                int& nOp = m_SqlCmd.pArrayOfTokens[i].nOperator;
                nOp = FlipOperator( nOp );
            }
        }

        if ( FAILED(hr) )
        {
            rState.SetErrStr( wszAlias );
            return hr;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::InitializeDefaultAccessors()
{
    HRESULT hr;

    //
    // get default accessors from the factories.  These are only used 
    // we're guaranteed that calls to Execute() are serialized.  If not, 
    // then Execute() will be responsible for allocating new ones.
    //

    hr = m_pEventAccessFact->GetObjectAccess( &m_pEventAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDataAccessFact->GetObjectAccess( &m_pDataAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pInstAccessFact->GetObjectAccess( &m_pInstAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pInstAccessFact->GetObjectAccess( &m_pOrigInstAccess );

    return hr;
}

HRESULT CUpdConsCommand::InitializeExecSinks( ULONG ulFlags,
                                              IWbemServices* pUpdSvc,
                                              IWbemClassObject* pUpdClass,
                                              LPCWSTR wszDataQuery,
                                              IWbemServices* pDataSvc )
{
    HRESULT hr;

    CUpdConsNamespace* pNamespace = m_pScenario->GetNamespace();

    //
    // only care about update disposition flags
    //
    ulFlags &= 0x3;

    //
    // only set pEventSink if our class is derived from our 
    // extrinsic event class. The presence of this pointer will be 
    // used to tell us which sink to create.
    //

    CWbemPtr<IWbemObjectSink> pEventSink;

    hr = pUpdClass->InheritsFrom( g_wszUpdateEventClass );

    if ( hr == WBEM_S_NO_ERROR )
    {
        pEventSink = pNamespace->GetEventSink();
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // here we determine if we can use the direct svc optimization
    // first check to see if the class is transient.
    //

    BOOL bTransient = FALSE;

    hr = IsClassTransient( pUpdClass );

    CWbemPtr<IWbemServices> pSvc;

    if ( hr == WBEM_S_NO_ERROR )
    {
        hr = GetDirectSvc( pUpdClass, pUpdSvc, &pSvc );
    
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        bTransient = TRUE;
        ulFlags |= WBEM_FLAG_RETURN_IMMEDIATELY;
    }
    else
    {
        pSvc = pUpdSvc;
    } 
   
    CWbemPtr<IWbemClassObject> pCmdTraceClass;
    CWbemPtr<IWbemClassObject> pInstTraceClass;

    //
    // now that we've got everything set, set up the sink chain that 
    // we'll use to do the execute.
    //

    CWbemPtr<CUpdConsSink> pSink;

    //
    // create sink chain based on command type
    //

    if ( m_SqlCmd.m_eCommandType == SQLCommand::e_Update )
    {
        pCmdTraceClass = pNamespace->GetUpdateCmdTraceClass();
        pInstTraceClass = pNamespace->GetUpdateInstTraceClass();

        pSink = new CPutSink( pSvc, ulFlags, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CAssignmentSink( bTransient,
                                     pUpdClass,
                                     m_SqlCmd.m_eCommandType, 
                                     pSink );
        
        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CTraceSink( m_pScenario, pInstTraceClass, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CFilterSink( pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        //
        // use the async version only in the case where we go directly to
        // the transient provider.
        //
        if ( bTransient )
        {
            pSink = new CFetchTargetObjectsAsync( pSvc, pSink );
        }
        else
        {
            pSink = new CFetchTargetObjectsSync( pSvc, pSink );
        }

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if ( m_SqlCmd.m_eCommandType == SQLCommand::e_Insert )
    {
        pCmdTraceClass = pNamespace->GetInsertCmdTraceClass();
        pInstTraceClass = pNamespace->GetInsertInstTraceClass();

        // 
        // If inserts are going to be done on an Extrinsic event class, 
        // then use the event sink instead of an update sink.
        //

        if ( pEventSink != NULL )
        {
            pSink = new CBranchIndicateSink( pEventSink, pSink );
        }
        else
        {
            pSink = new CPutSink( pSvc, ulFlags, pSink );
        }

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CAssignmentSink( bTransient,
                                     pUpdClass,
                                     m_SqlCmd.m_eCommandType, 
                                     pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        pSink = new CTraceSink( m_pScenario, pInstTraceClass, pSink );


        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CNoFetchTargetObjects( pUpdClass, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }
    else
    {
        //
        // we never go direct with deletes because we would have to queue
        // objects to delete until we were done enumerating them.
        //

        pCmdTraceClass = pNamespace->GetDeleteCmdTraceClass();
        pInstTraceClass = pNamespace->GetDeleteInstTraceClass();

        pSink = new CDeleteSink( pUpdSvc, 0, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CTraceSink( m_pScenario, pInstTraceClass, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
       
        pSink = new CFilterSink( pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink = new CFetchTargetObjectsSync( pUpdSvc, pSink );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    pSink = new CTraceSink( m_pScenario, pCmdTraceClass, pSink );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pSink = new CResolverSink( m_EventAliasOffsets, m_DataAliasOffsets, pSink );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( wszDataQuery != NULL && *wszDataQuery != '\0' )
    {
        pSink = new CFetchDataSink( wszDataQuery, pDataSvc, pSink );       

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    m_pSink = pSink;

    return WBEM_S_NO_ERROR;
}

/*****************************************************************************
  CUpdConsCommand
******************************************************************************/

HRESULT CUpdConsCommand::Create( LPCWSTR wszUpdateQuery, 
                                 LPCWSTR wszDataQuery,
                                 ULONG ulFlags,
                                 IWbemServices* pUpdSvc,
                                 IWbemServices* pDataSvc,
                                 CUpdConsScenario* pScenario,
                                 CUpdConsState& rState,
                                 CUpdConsCommand** ppCmd )
{
    HRESULT hr;    

    *ppCmd = NULL;

    CWbemPtr<CUpdConsCommand> pCmd = new CUpdConsCommand( pScenario );

    if ( pCmd == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }
    
    CWbemPtr<IWbemClassObject> pUpdClass, pDataClass, pEventClass;

    hr = pCmd->ProcessUpdateQuery( wszUpdateQuery, 
                                   pUpdSvc, 
                                   rState, 
                                   &pUpdClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->ProcessDataQuery( wszDataQuery, 
                                 pDataSvc, 
                                 rState, 
                                 &pDataClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->ProcessEventQuery( NULL, NULL, rState, &pEventClass );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializeAccessFactories( pUpdClass );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializePropertyInfo( rState );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializeDefaultAccessors();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCmd->InitializeExecSinks( ulFlags, 
                                    pUpdSvc, 
                                    pUpdClass, 
                                    wszDataQuery, 
                                    pDataSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }
     
    pCmd->AddRef();
    *ppCmd = pCmd;
                           
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsCommand::Execute( CUpdConsState& rState, BOOL bConcurrent )
{
    HRESULT hr;

    if ( !bConcurrent )
    {
        rState.SetSqlCmd( &m_SqlCmd, FALSE );
        
        hr = rState.SetEventAccess(m_pEventAccess);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = rState.SetDataAccess(m_pDataAccess);
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = rState.SetInstAccess(m_pInstAccess);

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = rState.SetOrigInstAccess(m_pOrigInstAccess);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        SQLCommand* pCmd = new SQLCommand( m_SqlCmd );

        if ( pCmd == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        rState.SetSqlCmd( pCmd, TRUE );

        CWbemPtr<IWmiObjectAccess> pAccess;

        hr = m_pEventAccessFact->GetObjectAccess( &pAccess );
        
        if ( FAILED(hr) || FAILED(hr=rState.SetEventAccess(pAccess)) )
        {
            return hr;
        }
        
        pAccess.Release();

        hr = m_pDataAccessFact->GetObjectAccess( &pAccess );
        
        if ( FAILED(hr) || FAILED(hr=rState.SetDataAccess(pAccess)) )
        {
            return hr;
        }

        pAccess.Release();

        hr = m_pInstAccessFact->GetObjectAccess( &pAccess );

        if ( FAILED(hr) || FAILED(hr=rState.SetInstAccess(pAccess)) )
        {
            return hr;
        }

        pAccess.Release();

        hr = m_pInstAccessFact->GetObjectAccess( &pAccess );

        if ( FAILED(hr) || FAILED(hr=rState.SetOrigInstAccess(pAccess)) )
        {
            return hr;
        }

        pAccess.Release();        
    }

    hr = m_pSink->Execute( rState );

    //
    // at this point we reset any state that is not needed 
    // by caller.
    //

    rState.SetInst( NULL );
    rState.SetData( NULL );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcmd.h ===
#ifndef __UPDCMD_H__
#define __UPDCMD_H__

#include <wbemcli.h>
#include <unk.h>
#include <comutl.h>
#include <wmimsg.h>
#include "updsql.h"
#include "updscen.h"
#include "updsink.h"

class CUpdConsCommand : public CUnk
{
protected:

    SQLCommand m_SqlCmd;
    AliasInfo m_DataAliasOffsets;
    AliasInfo m_EventAliasOffsets;

    CWbemPtr<IWmiObjectAccessFactory> m_pEventAccessFact;
    CWbemPtr<IWmiObjectAccessFactory> m_pDataAccessFact;
    CWbemPtr<IWmiObjectAccessFactory> m_pInstAccessFact;

    CWbemPtr<IWmiObjectAccess> m_pEventAccess;
    CWbemPtr<IWmiObjectAccess> m_pDataAccess;
    CWbemPtr<IWmiObjectAccess> m_pInstAccess;
    CWbemPtr<IWmiObjectAccess> m_pOrigInstAccess;

    //
    // this is the beginning of the sink chain that we use to execute the 
    // command.  It is built up on Initialization.
    //
    CWbemPtr<CUpdConsSink> m_pSink;
    
    CWbemPtr<CUpdConsScenario> m_pScenario;

    CUpdConsCommand( CUpdConsScenario* pScenario ) : m_pScenario(pScenario) {}

    HRESULT ProcessUpdateQuery( LPCWSTR wszUpdateQuery,
                                IWbemServices* pUpdSvc,
                                CUpdConsState& rState,
                                IWbemClassObject** ppUpdClass );

    HRESULT ProcessDataQuery( LPCWSTR wszDataQuery,
                              IWbemServices* pDataSvc,
                              CUpdConsState& rState,
                              IWbemClassObject** ppDataClass );

    HRESULT ProcessEventQuery( LPCWSTR wszEventQuery,
                               IWbemServices* pEventSvc,
                               CUpdConsState& rState,
                               IWbemClassObject** ppEventClass );
    
    HRESULT InitializeAccessFactories( IWbemClassObject* pUpdClass );
    HRESULT InitializePropertyInfo( CUpdConsState& rState );
    HRESULT InitializeDefaultAccessors();       
    HRESULT InitializeExecSinks( ULONG ulFlags, 
                                 IWbemServices* pUpdSvc,
                                 IWbemClassObject* pUpdClass,
                                 LPCWSTR wszDataQuery,
                                 IWbemServices* pDataSvc );

public:

    enum { e_UpdateOrCreate = 0, 
           e_UpdateOnly = 1, 
           e_CreateOnly = 2 };

    HRESULT Execute( CUpdConsState& rState, BOOL bConcurrent );
    
    void* GetInterface( REFIID ) { return NULL; }
    
    static HRESULT Create( LPCWSTR wszUpdateQuery, 
                           LPCWSTR wszDataQuery,
                           ULONG ulFlags,
                           IWbemServices* pUpdSvc,
                           IWbemServices* pDataSvc,
                           CUpdConsScenario* pScenario,
                           CUpdConsState& rState,
                           CUpdConsCommand** ppCmd ); 
};

#endif // __UPDCMD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcons.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <GroupsForUser.h>
#include "updcons.h"
#include "updcmd.h"
#include "updscen.h"
#include "updnspc.h"
#include "updprov.h"
#include "updstat.h"
#include "updmain.h"

const LPCWSTR g_wszScenarioClass = L"MSFT_UCScenario";
const LPCWSTR g_wszFlags = L"Flags";
const LPCWSTR g_wszTargetInst =  L"TargetInstance";
const LPCWSTR g_wszDataQuery = L"DataQueries";
const LPCWSTR g_wszDataNamespace = L"DataNamespace";
const LPCWSTR g_wszUpdateNamespace = L"UpdateNamespace";
const LPCWSTR g_wszCommands = L"Commands";
const LPCWSTR g_wszName = L"Name";
const LPCWSTR g_wszSid = L"CreatorSid";
const LPCWSTR g_wszQueryLang = L"WQL";

/************************************************************************
  CUpdCons
*************************************************************************/

CUpdCons::CUpdCons( CLifeControl* pControl, CUpdConsScenario* pScenario )
: CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink >( pControl ),
  m_pScenario( pScenario ), m_bInitialized(FALSE)
{

}

HRESULT CUpdCons::Create( CUpdConsScenario* pScenario,
                          IWbemUnboundObjectSink** ppSink )
{
    CLifeControl* pControl = CUpdConsProviderServer::GetGlobalLifeControl();

    CUpdCons* pSink = new CUpdCons( pControl, pScenario );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return pSink->QueryInterface( IID_IWbemUnboundObjectSink, (void**)ppSink );
}

HRESULT CUpdCons::Initialize( IWbemClassObject* pCons, CUpdConsState& rState )
{
    HRESULT hr;

    if ( m_bInitialized ) 
    {
        return WBEM_S_NO_ERROR;
    }

    // 
    // make sure that pObj (our logical consumer) is valid. Currently, this 
    // means that it was created by an account belonging to the administrators
    // group.
    //
    
    CPropVar vSid;
    hr = pCons->Get( g_wszSid, 0, &vSid, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vSid.CheckType(VT_UI1 | VT_ARRAY)) )
    {
        return hr;
    }
    
    CPropSafeArray<BYTE> saSid(V_ARRAY(&vSid));

    NTSTATUS stat = IsUserAdministrator( saSid.GetArray() );
    
    if ( stat != 0 )
    {
        return WBEM_E_ACCESS_DENIED;
    }

    // 
    // Get the list of commands
    //

    CPropVar vCommands;
    hr = pCons->Get( g_wszCommands, 0, &vCommands, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vCommands) != VT_NULL )
    {
        if ( FAILED(hr=vCommands.CheckType( VT_BSTR | VT_ARRAY ) ) )
        {
            return hr;
        }
    }
    else
    {
        // 
        // No-Op command, no need to go any further
        //  
        return WBEM_S_NO_ERROR;
    }

    CPropSafeArray<BSTR> saCommands( V_ARRAY(&vCommands) );

    //
    // obtain the namespace ptr to use for obtaining data. This namespace 
    // can be null in which case it is assumed that data will be obtained  
    // from the namespace that this consumer belongs to.
    //
    
    CPropVar vDataNamespace;
    hr = pCons->Get( g_wszDataNamespace, 0, &vDataNamespace, NULL, NULL);

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemServices> pDataSvc;

    if ( V_VT(&vDataNamespace) == VT_NULL )
    {
        pDataSvc = m_pScenario->GetNamespace()->GetDefaultService();
    }
    else if ( V_VT(&vDataNamespace) == VT_BSTR )
    {
        hr = CUpdConsProviderServer::GetService( V_BSTR(&vDataNamespace), 
                                                 &pDataSvc );
        
        if ( FAILED(hr) )
        {            
            rState.SetErrStr( V_BSTR(&vDataNamespace) );
            return hr;
        }
    }
    else 
    {
        return WBEM_E_INVALID_OBJECT;
    }

    _DBG_ASSERT( pDataSvc != NULL );

    //
    // obtain the namespace ptr to use for updating state. This namespace 
    // can be null in which case it is assumed that state will be updated  
    // in the namespace that this consumer belongs to.
    //

    CPropVar vUpdateNamespace;
    hr = pCons->Get( g_wszUpdateNamespace, 0, &vUpdateNamespace, NULL, NULL);

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemServices> pUpdSvc;

    if ( V_VT(&vUpdateNamespace) == VT_NULL )
    {
        pUpdSvc = m_pScenario->GetNamespace()->GetDefaultService();
    }
    else if ( V_VT(&vUpdateNamespace) == VT_BSTR )
    {
        hr = CUpdConsProviderServer::GetService( V_BSTR(&vUpdateNamespace), 
                                                 &pUpdSvc );
        
        if ( FAILED(hr) )
        {            
            rState.SetErrStr( V_BSTR(&vUpdateNamespace) );
            return hr;
        }
    }
    else 
    {
        return WBEM_E_INVALID_OBJECT;
    }

    _DBG_ASSERT( pUpdSvc != NULL );

    // 
    // Get Flags Array
    //

    CPropVar vFlags;
    hr = pCons->Get( g_wszFlags, 0, &vFlags, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropSafeArray<ULONG> saFlags;

    if ( V_VT(&vFlags) != VT_NULL )
    {
        if ( FAILED(hr=vFlags.CheckType( VT_I4 | VT_ARRAY ) ) )
        {
            return hr;
        }
        saFlags = V_ARRAY(&vFlags);
    }

    // 
    // Get Data Query Array
    //

    CPropVar vDataQuery;
    hr = pCons->Get( g_wszDataQuery, 0, &vDataQuery, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropSafeArray<BSTR> saDataQuery;

    if ( V_VT(&vDataQuery) != VT_NULL )
    {
        if ( FAILED(hr=vDataQuery.CheckType( VT_BSTR | VT_ARRAY ) ) )
        {
            return hr;
        }

        saDataQuery = V_ARRAY(&vDataQuery);
    }

    //
    // now create the command objects using the info we've obtained. first
    // make sure that we remove any existing commands.
    //

    m_CmdList.clear();

    for( long i=0; i < saCommands.Length(); i++ )
    {
        CWbemPtr<CUpdConsCommand> pCmd; 

        ULONG ulFlags = 0;
        LPCWSTR wszDataQuery = NULL;

        if ( i < saFlags.Length() )
        {
            ulFlags = saFlags[i];
        }

        if ( i < saDataQuery.Length() )
        {
            wszDataQuery = saDataQuery[i];
        } 
   
        hr = CUpdConsCommand::Create( saCommands[i], 
                                      wszDataQuery,
                                      ulFlags,
                                      pUpdSvc,
                                      pDataSvc,
                                      m_pScenario,
                                      rState,
                                      &pCmd );
        if ( FAILED(hr) )
        {
            //
            // set which command index we're on before returning
            //        
            rState.SetCommandIndex( i );
            break;
        }
        
        m_CmdList.insert( m_CmdList.end(), pCmd );
    }

    return hr;
}

HRESULT CUpdCons::IndicateOne( IWbemClassObject* pObj, CUpdConsState& rState ) 
{
    HRESULT hr;

    //
    // see if our scenario object has been deactivated.  If so, try to obtain
    // a new one.  
    // 
    
    if ( !m_pScenario->IsActive() )
    {
        CWbemPtr<CUpdConsScenario> pScenario;

        hr = m_pScenario->GetNamespace()->GetScenario( m_pScenario->GetName(),
                                                       &pScenario );

        if ( hr == WBEM_S_NO_ERROR )
        {
            m_pScenario = pScenario; // it was reactivated
        }
        else if ( hr == WBEM_S_FALSE )
        {
            //
            // the scenario is not currently active.  If this event has to
            // do with an operation on the scenario obj itself, then allow 
            // it to go through, otherwise return.
            //

            IWbemClassObject* pEvent = rState.GetEvent();

            if ( pEvent->InheritsFrom( L"__InstanceOperationEvent" ) 
                 == WBEM_S_NO_ERROR )
            {
                CPropVar vTarget;

                hr = pEvent->Get( L"TargetInstance", 0, &vTarget, NULL, NULL );

                if ( FAILED(hr) || FAILED(hr=vTarget.CheckType( VT_UNKNOWN)) )
                {
                    return hr;
                }

                CWbemPtr<IWbemClassObject> pTarget;
                hr = V_UNKNOWN(&vTarget)->QueryInterface( IID_IWbemClassObject,
                                                          (void**)&pTarget );

                if ( FAILED(hr) )
                {
                    return hr;
                }

                hr = pTarget->InheritsFrom( g_wszScenarioClass );

                if ( hr != WBEM_S_NO_ERROR )
                {
                    return hr; // return WBEM_S_FALSE, scenario is inactive.
                }
            }
            else
            {
                return hr; // return WBEM_S_FALSE, scenario is inactive.
            }
        }
        else
        {
            return hr;
        }
    }

    //
    // Lock the scenario. 
    //

    CInCritSec ics( m_pScenario->GetLock() );

    _DBG_ASSERT( rState.GetEvent() != NULL );

    //
    // execute each command object. 
    //

    for( int i=0; i < m_CmdList.size(); i++ )
    {
        //
        // set the current command we're on in the state object. 
        //
        
        rState.SetCommandIndex( i );

        //
        // by specifying false for the concurrent param on Execute(),
        // we're saying that there's going to be no concurrent access
        // to the command, in which case it can save a bit on memory
        // allocation.
        //

        hr = m_CmdList[i]->Execute( rState, FALSE );

        if ( FAILED(hr) )
        {
            return hr;
        }            
    }

    //
    // reset the current command index, since we're sucessfully execute 
    // all of them. 
    //

    rState.SetCommandIndex( -1 );

    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CUpdCons::IndicateToConsumer( IWbemClassObject* pCons,
                                           long cObjs,
                                           IWbemClassObject** ppObjs )
{
    ENTER_API_CALL

    HRESULT hr = WBEM_S_NO_ERROR;

    IWbemClassObject* pTraceClass;
    pTraceClass = m_pScenario->GetNamespace()->GetTraceClass();
    
    //
    // workaround for bogus context object left on thread by wmi.
    // just remove it. shouldn't leak because this call doesn't addref it.
    //

    IUnknown* pCtx;
    CoSwitchCallContext( NULL, &pCtx ); 

    //
    // state that is passed through the command execution chain.
    //

    CUpdConsState ExecState;

    ExecState.SetCons( pCons );

    //
    // execute the updating consumer using one event at a time. 
    //

    for( int i=0; i < cObjs; i++ ) 
    {
        //
        // each time set the event and a new guid on the state object ..
        //
        
        ExecState.SetEvent( ppObjs[i] );

        GUID guidExec;

        hr = CoCreateGuid( &guidExec );
        _DBG_ASSERT( SUCCEEDED(hr) );

        ExecState.SetExecutionId( guidExec );
        
        //
        // if not already initialized, do so now.  We wait until here 
        // because we now enough info to generate a trace event in case 
        // something goes wrong with initialization.
        //

        if ( !m_bInitialized )
        {
            hr = Initialize( pCons, ExecState );

            if ( FAILED(hr) )
            {
                m_pScenario->FireTraceEvent( pTraceClass, ExecState, hr );
                return WBEM_S_NO_ERROR; // we've notified the user already
            }

            m_bInitialized = TRUE;
        }

        //
        // Actual Indicate. 
        //
    
        hr = IndicateOne( ppObjs[i], ExecState );
  
        //
        // generate trace event. It is intentional that we are not returning
        // errors from the Indicate().  The policy is that as long as we 
        // generate a trace event, then the error is handled.  The rational 
        // here is that we don't want to screw up the user's state by 
        // executing a portion of the commands again ( which happens when the
        // error is not in the first command. )
        //

        m_pScenario->FireTraceEvent( pTraceClass, ExecState, hr ); 
    }

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updmain.h ===
#ifndef __UPDMAIN_H__
#define __UPDMAIN_H__

#include <wbemcli.h>
#include <commain.h>

class CUpdConsNamespace;

class CUpdConsProviderServer : public CComServer
{  

protected:

    HRESULT Initialize();
    void Uninitialize();

public:

    static HRESULT GetService( LPCWSTR wszNamespace, IWbemServices** ppSvc );
    
    static HRESULT GetNamespace( LPCWSTR wszNamespace, 
                                 CUpdConsNamespace** ppNamespace );
    
    static CLifeControl* GetGlobalLifeControl();
};

#endif // __UPDMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updcons.h ===
#ifndef __UPDCONS_H__
#define __UPDCONS_H__

#include <wbemcli.h>
#include <map>
#include <comutl.h>
#include <unk.h>
#include <wstlallc.h>
#include "updcmd.h"

class CUpdConsNamespace;
class CUpdConsScenario;

/*************************************************************************
  CUpdCons
**************************************************************************/
 
class CUpdCons 
: public CUnkBase<IWbemUnboundObjectSink,&IID_IWbemUnboundObjectSink>
{
    //
    // we lock the scenario object when executing, ensuring that all
    // updating consumers belonging to the same scenario are serialized.
    // we also use the scenario object for tracing.
    //
    CWbemPtr<CUpdConsScenario> m_pScenario;

    //
    // the list of updating consumer commands.
    //
    typedef CWbemPtr<CUpdConsCommand> CUpdConsCommandP;
    typedef std::vector<CUpdConsCommandP,wbem_allocator<CUpdConsCommandP> > UpdConsCommandList;
    typedef UpdConsCommandList::iterator UpdConsCommandListIter;
    UpdConsCommandList m_CmdList;

    BOOL m_bInitialized;

    CUpdCons( CLifeControl* pControl, CUpdConsScenario* pScenario );

    HRESULT Initialize( IWbemClassObject* pCons, CUpdConsState& rState );

    HRESULT IndicateOne( IWbemClassObject* pObj, CUpdConsState& rState );

public:
 
    static HRESULT Create( CUpdConsScenario* pScenario,
                           IWbemUnboundObjectSink** ppSink );

    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pCons, 
                                   long cObjs, 
                                   IWbemClassObject** ppObjs );        
};

#endif __UPDCONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updmain.cpp ===
#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include <wstring.h>
#include <wbemutil.h>
#include <comutl.h>
#include "updmain.h"
#include "updprov.h"
#include "updassoc.h"

#include <tchar.h>

// {A3A16907-227B-11d3-865D-00C04F63049B}
static const CLSID CLSID_UpdConsProvider =  
{ 0xa3a16907, 0x227b, 0x11d3, {0x86, 0x5d, 0x0, 0xc0, 0x4f, 0x63, 0x4, 0x9b}};

// {74E3B84C-C7BE-4e0a-9BD2-853CA72CD435}
static const CLSID CLSID_UpdConsAssocProvider = 
{0x74e3b84c, 0xc7be, 0x4e0a, {0x9b, 0xd2, 0x85, 0x3c, 0xa7, 0x2c, 0xd4, 0x35}};

CCritSec g_CS;
CUpdConsProviderServer g_Server;

typedef CWbemPtr<CUpdConsNamespace> UpdConsNamespaceP;
std::map<WString,UpdConsNamespaceP,WSiless, wbem_allocator<UpdConsNamespaceP> >* g_pNamespaceCache;

HRESULT CUpdConsProviderServer::Initialize() 
{
    ENTER_API_CALL

    HRESULT hr;
    CWbemPtr<CUnkInternal> pFactory; 

    pFactory = new CSimpleClassFactory<CUpdConsProvider>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_UpdConsProvider, 
                       pFactory,
                       _T("Updating Consumer Provider"), 
                       TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }
     
    pFactory = new CClassFactory<CUpdConsAssocProvider>(GetLifeControl());

    if ( pFactory == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = AddClassInfo( CLSID_UpdConsAssocProvider, 
                       pFactory,
                       _T("Updating Consumer Assoc Provider"), 
                       TRUE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    g_pNamespaceCache = new std::map< WString, UpdConsNamespaceP, WSiless, wbem_allocator<UpdConsNamespaceP> >;

    if ( g_pNamespaceCache == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}

void CUpdConsProviderServer::Uninitialize()
{
    delete g_pNamespaceCache;
}

HRESULT CUpdConsProviderServer::GetService( LPCWSTR wszNamespace, 
                                            IWbemServices** ppSvc )
{
    HRESULT hr;

    *ppSvc = NULL;

    CWbemPtr<IWbemLocator> pLocator;
    
    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWbemLocator, 
                           (void**)&pLocator );        
    if ( FAILED(hr) )
    {
        return hr;
    }
   
    return pLocator->ConnectServer( (LPWSTR)wszNamespace, 
                                    NULL, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                    NULL, 
                                    NULL, 
                                    ppSvc );
}
 
HRESULT CUpdConsProviderServer::GetNamespace( LPCWSTR wszNamespace, 
                                              CUpdConsNamespace** ppNamespace )
{
    HRESULT hr;
    *ppNamespace = NULL;

    CInCritSec ics( &g_CS );

    CWbemPtr<CUpdConsNamespace> pNamespace;

    pNamespace = (*g_pNamespaceCache)[wszNamespace];

    if ( pNamespace == NULL )
    {
        hr = CUpdConsNamespace::Create( wszNamespace, &pNamespace );

        if ( FAILED(hr) )
        {
            return hr;
        }

        (*g_pNamespaceCache)[wszNamespace] = pNamespace;
    }
        
    _DBG_ASSERT( pNamespace != NULL );

    pNamespace->AddRef();
    *ppNamespace = pNamespace;

    return WBEM_S_NO_ERROR;
}

CLifeControl* CUpdConsProviderServer::GetGlobalLifeControl() 
{ 
    return g_Server.GetLifeControl(); 
}

/*

This code will register the Updating Consumer to work under a Dll Surrogate.

extern void CopyOrConvert( TCHAR*, WCHAR*, int );

void CUpdConsProviderServer::Register()
{
    // must register the Updating provider to be able to be instantiated 
    // from within a surrogate. 

    TCHAR szID[128];
    WCHAR wszID[128];
    TCHAR szCLSID[128];
    TCHAR szAPPID[128];

    HKEY hKey;

    StringFromGUID2( CLSID_UpdConsProvider, wszID, 128 );
    CopyOrConvert( szID, wszID, 128 );

    lstrcpy( szCLSID, TEXT( "SOFTWARE\\Classes\\CLSID\\") );
    lstrcat( szCLSID, szID );

    lstrcpy( szAPPID, TEXT( "SOFTWARE\\Classes\\APPID\\") );
    lstrcat( szAPPID, szID );

    RegCreateKey( HKEY_LOCAL_MACHINE, szCLSID, &hKey );
    
    RegSetValueEx( hKey, 
                   TEXT("AppID"), 
                   0, 
                   REG_SZ, 
                   (BYTE*)szID, 
                   lstrlen(szID)+1 );
    
    // now set up the appid entries ... 

    RegCloseKey(hKey);

    RegCreateKey( HKEY_LOCAL_MACHINE, szAPPID, &hKey );

    LPCTSTR szEmpty = TEXT("");
    RegSetValueEx( hKey, TEXT("DllSurrogate"), 0, REG_SZ, (BYTE*)szEmpty, 1 );
    
    DWORD nAuth = 2; // AUTHN_LEVEL_CONNECT
    RegSetValueEx( hKey, TEXT("AuthenticationLevel"), 
                   0, REG_DWORD, (BYTE*)&nAuth, 4);

    // now build a self relative SD for Access and Launch Permissions 
    // allowing Everyone access.
    
    SID_IDENTIFIER_AUTHORITY SIDAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    BYTE achAcl[256], achDesc[256], achSRDesc[256];
    PSID pWorldSid;
    BOOL bRes;

    // first have to get the owner ...
    //
    HANDLE hProcTok;
    bRes = OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hProcTok );
    _DBG_ASSERT(bRes);

    PSID pOwnerSid;
    DWORD dummy;
    BYTE achSidAndAttrs[256];
    bRes = GetTokenInformation( hProcTok,
                                TokenUser,
                                &achSidAndAttrs,
                                sizeof(achSidAndAttrs),
                                &dummy );
    _DBG_ASSERT(bRes);

    pOwnerSid = PSID_AND_ATTRIBUTES(achSidAndAttrs)->Sid;
  
    bRes = AllocateAndInitializeSid( &SIDAuthWorld, 1,
                                     SECURITY_WORLD_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pWorldSid );
    DWORD cSidLen = GetLengthSid(pWorldSid);
    _DBG_ASSERT(bRes);
    bRes = InitializeAcl( (PACL)achAcl, sizeof(ACL)+sizeof(ACCESS_ALLOWED_ACE) 
                          - 4 + cSidLen, ACL_REVISION2 ); 
    _DBG_ASSERT(bRes);
    bRes = AddAccessAllowedAce( (PACL)achAcl, ACL_REVISION, 
                                1, pWorldSid ); 
    _DBG_ASSERT(bRes);
    bRes = InitializeSecurityDescriptor( achDesc, 
                                         SECURITY_DESCRIPTOR_REVISION );
    _DBG_ASSERT(bRes);
    bRes = SetSecurityDescriptorDacl( achDesc, TRUE, (PACL)achAcl, FALSE );
    _DBG_ASSERT(bRes);
    bRes = SetSecurityDescriptorOwner( achDesc, pOwnerSid, FALSE );
    _DBG_ASSERT(bRes);
    bRes = SetSecurityDescriptorGroup( achDesc, pOwnerSid, FALSE );
    _DBG_ASSERT(bRes);

    DWORD dwLen = 256;
    bRes = MakeSelfRelativeSD( achDesc, achSRDesc, &dwLen );
    _DBG_ASSERT(bRes);
    bRes = IsValidSecurityDescriptor( achSRDesc );
    _DBG_ASSERT(bRes);

    dwLen = GetSecurityDescriptorLength( achSRDesc );

    RegSetValueEx( hKey, TEXT("AccessPermission"), 0, REG_BINARY,
                   (BYTE*)achSRDesc, dwLen );
    
    RegSetValueEx( hKey, TEXT("LaunchPermission"), 0, REG_BINARY,
                   (BYTE*)achSRDesc, dwLen );

    FreeSid( pWorldSid );

    RegCloseKey( hKey );
}

void CUpdConsProviderServer::Unregister()
{
    TCHAR szID[128];
    WCHAR wszID[128];

    HKEY hKey;
    DWORD dwRet;
    StringFromGUID2( CLSID_UpdConsProvider, wszID, 128 );
    CopyOrConvert( szID, wszID, 128 );

    dwRet = RegOpenKey( HKEY_LOCAL_MACHINE, 
                        TEXT("SOFTWARE\\Classes\\APPID"), 
                        &hKey );

    if( dwRet == NO_ERROR )
    {
        RegDeleteKey( hKey,szID );
        RegCloseKey( hKey );
    } 
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updprov.cpp ===
#include "precomp.h"
#include "updprov.h"
#include "updcons.h"
#include "updmain.h"

const LPCWSTR g_wszNamespace = L"__Namespace";
const LPCWSTR g_wszUpdConsClass = L"MSFT_UpdatingConsumer";

STDMETHODIMP CUpdConsProvider::FindConsumer( IWbemClassObject* pCons,
                                             IWbemUnboundObjectSink** ppSink )
{
    HRESULT hr;

    ENTER_API_CALL

    *ppSink = NULL;

    //
    // workaround for bogus context object left on thread by wmi.
    // just remove it. shouldn't leak because this call doesn't addref it.
    //
    IUnknown* pCtx;
    CoSwitchCallContext( NULL, &pCtx ); 

    // 
    // use the namespace prop on the consumer to find our namespace obj
    // 
    
    CPropVar vNamespace;
    hr = pCons->Get( g_wszNamespace, 0, &vNamespace, NULL, NULL);
    
    if ( FAILED(hr) || FAILED(hr=vNamespace.CheckType( VT_BSTR)) )
    {
        return hr;
    }

    CWbemPtr<CUpdConsNamespace> pNamespace;

    hr = CUpdConsProviderServer::GetNamespace( V_BSTR(&vNamespace), 
                                               &pNamespace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the appropriate sink depending on the type of consumer.
    // 

    if ( pCons->InheritsFrom( g_wszUpdConsClass ) == WBEM_S_NO_ERROR )
    {
        hr = pNamespace->GetUpdCons( pCons, ppSink );
    }
    else
    {
        hr = pNamespace->GetScenarioControl( ppSink );
    }

    EXIT_API_CALL

    return hr;
}

HRESULT CUpdConsProvider::Init( LPCWSTR wszNamespace )
{
    ENTER_API_CALL

    HRESULT hr;

    CInCritSec ics(&m_csInit);

    if ( m_bInit )
    {
        return WBEM_S_NO_ERROR;
    }

    // 
    // we need to obtain the 'default' svc pointer.  This is used for 
    // obtaining class objects necessary for the updating consumers.  
    // This logic relies on the fact that wszNamespace is relative and 
    // does not contain the name of the server.  We always want the local
    // server's namespace pointer.  This is because the process that 
    // serves as the context for the remote execution of an updating consumer
    // (currently the standard surrogate) always runs with a restricted 
    // process token (because it has an identity of 'launching user' ). 
    // This token is the same as an impersonation token in that you cannot 
    // call off the box.  
    //

    CWbemPtr<IWbemServices> pSvc;

    hr = CUpdConsProviderServer::GetService( wszNamespace, &pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_bInit = TRUE;

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}


CUpdConsProvider::CUpdConsProvider( CLifeControl* pCtl ) : m_bInit(FALSE),
 CUnkBase<IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider>( pCtl )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updnspc.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include "updnspc.h"
#include "updcons.h"
#include "updmain.h"

const LPCWSTR g_wszIdProp = L"Id";
const LPCWSTR g_wszScenarioProp = L"Scenario";
const LPCWSTR g_wszScenarioClass = L"MSFT_UCScenario";
const LPCWSTR g_wszTargetInstance = L"TargetInstance";
const LPCWSTR g_wszTraceClass = L"MSFT_UCExecutedTraceEvent";
const LPCWSTR g_wszInsertCmdTraceClass = L"MSFT_UCInsertCommandTraceEvent";
const LPCWSTR g_wszUpdateCmdTraceClass = L"MSFT_UCUpdateCommandTraceEvent";
const LPCWSTR g_wszDeleteCmdTraceClass = L"MSFT_UCDeleteCommandTraceEvent";
const LPCWSTR g_wszInsertInstTraceClass = L"MSFT_UCInsertInstanceTraceEvent";
const LPCWSTR g_wszUpdateInstTraceClass = L"MSFT_UCUpdateInstanceTraceEvent";
const LPCWSTR g_wszDeleteInstTraceClass = L"MSFT_UCDeleteInstanceTraceEvent";
const LPCWSTR g_wszEvProvName = L"Microsoft WMI Updating Consumer Event Provider";
                                                          
HRESULT CUpdConsNamespace::GetScenario( LPCWSTR wszScenario, 
                                        CUpdConsScenario** ppScenario)
{
    HRESULT hr;
    *ppScenario = NULL;

    CInCritSec ics(&m_cs);

    CWbemPtr<CUpdConsScenario> pScenario = m_ScenarioCache[wszScenario];

    if ( pScenario != NULL )
    {
        pScenario->AddRef();
        *ppScenario = pScenario;
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}

HRESULT CUpdConsNamespace::ActivateScenario( LPCWSTR wszScenario )
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    //
    // if the scenario is not there then create one.
    //

    if ( m_ScenarioCache[wszScenario] != NULL )
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        CWbemPtr<CUpdConsScenario> pScenario;

        hr = CUpdConsScenario::Create( wszScenario, this, &pScenario );

        if ( SUCCEEDED(hr) )
        {
            m_ScenarioCache[wszScenario] = pScenario;
        }
    }

    return hr;
}

HRESULT CUpdConsNamespace::DeactivateScenario( LPCWSTR wszScenario )
{
    CInCritSec ics(&m_cs);

    //
    // remove the scenario from our list.
    //

    CWbemPtr<CUpdConsScenario> pScenario;

    ScenarioMap::iterator it = m_ScenarioCache.find( wszScenario );

    //
    // deactivate it.
    //

    if ( it != m_ScenarioCache.end() )
    {
        it->second->Deactivate();
        m_ScenarioCache.erase( it );
    }

    return WBEM_S_NO_ERROR;
}
   
CUpdConsNamespace::~CUpdConsNamespace()
{
    if ( m_pDES != NULL )
    {
        m_pDES->UnRegister();
    }
}

HRESULT CUpdConsNamespace::GetUpdCons( IWbemClassObject* pCons, 
                                       IWbemUnboundObjectSink** ppSink )
{
    HRESULT hr;
    
    //
    // Get Scenario Name from the consumer object. Then use it to
    // obtain the Scenario object.
    //

    CPropVar vScenario;

    hr = pCons->Get( g_wszScenarioProp, 0, &vScenario, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<CUpdConsScenario> pScenario;

    if ( V_VT(&vScenario) != VT_NULL )
    {
        if ( FAILED(hr=vScenario.CheckType( VT_BSTR ) ) ) 
        {
            return hr;
        }
  
        hr = GetScenario( V_BSTR(&vScenario), &pScenario );

        if ( hr == WBEM_S_FALSE )
        {
            //
            // no active scenario exists for this consumer.  We do have to 
            // pass something to the consumer though, so create a deactived 
            // scenario. 
            //

            hr = CUpdConsScenario::Create( V_BSTR(&vScenario), 
                                           this, 
                                           &pScenario );

            if ( SUCCEEDED(hr) )
            {
                pScenario->Deactivate();
            }
        }
    }
    else
    {
        //
        // no scenario name, create a 'default' scenario object.
        // 

        hr = CUpdConsScenario::Create( NULL, this, &pScenario );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return CUpdCons::Create( pScenario, ppSink ); 
}

HRESULT CUpdConsNamespace::Initialize( LPCWSTR wszNamespace )
{
    HRESULT hr;

    //
    // register our decoupled event provider 
    //

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Register( 0,
                           NULL,
                           NULL,
                           NULL,
                           wszNamespace,
                           g_wszEvProvName,
                           NULL );
     
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the service pointer for out namespace
    //

    hr = m_pDES->GetService( 0, NULL, &m_pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the decoupled event sink
    //

    hr = m_pDES->GetSink( 0, NULL, &m_pEventSink );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get event classes from namespace
    //

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszTraceClass), 
                            0, 
                            NULL, 
                            &m_pTraceClass, 
                            NULL );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszInsertCmdTraceClass), 
                            0, 
                            NULL, 
                            &m_pInsertCmdTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszUpdateCmdTraceClass), 
                            0, 
                            NULL, 
                            &m_pUpdateCmdTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszDeleteCmdTraceClass), 
                            0, 
                            NULL, 
                            &m_pDeleteCmdTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszInsertInstTraceClass), 
                            0, 
                            NULL, 
                            &m_pInsertInstTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszUpdateInstTraceClass), 
                            0, 
                            NULL, 
                            &m_pUpdateInstTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( CWbemBSTR(g_wszDeleteInstTraceClass), 
                            0, 
                            NULL, 
                            &m_pDeleteInstTraceClass, 
                            NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // process the list of active scenarios.
    // 

    CWbemPtr<IEnumWbemClassObject> pEnum;

    long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;

    hr = m_pSvc->CreateInstanceEnum( CWbemBSTR(g_wszScenarioClass),
                                     lFlags,
                                     NULL,
                                     &pEnum );
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pObj;
    
    hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs == 1 );

        CPropVar vId;

        hr = pObj->Get( g_wszIdProp, 0, &vId, NULL, NULL );

        if ( FAILED(hr) || FAILED(hr=vId.CheckType(VT_BSTR)) )
        {
            return hr;
        }
         
        ActivateScenario( V_BSTR(&vId) );

        pObj.Release();
        hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsNamespace::GetScenarioControl( 
                                     IWbemUnboundObjectSink** ppControl )
{
    CLifeControl* pCtl = CUpdConsProviderServer::GetGlobalLifeControl();

    CWbemPtr<CUpdConsNamespaceSink> pSink;
   
    pSink = new CUpdConsNamespaceSink( pCtl, this );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return pSink->QueryInterface( IID_IWbemUnboundObjectSink, 
                                  (void**)ppControl );
}

STDMETHODIMP CUpdConsNamespaceSink::IndicateToConsumer(
                                                   IWbemClassObject* pCons,
                                                   long cObjs, 
                                                   IWbemClassObject** ppObjs )
{
    HRESULT hr;

    for( int i=0; i < cObjs; i++ )
    {
        DEBUGTRACE((LOG_ESS,"UPDCONS: Handling scenario change notification"));

        hr = m_pNamespace->NotifyScenarioChange( ppObjs[i] );

        if ( FAILED(hr) )
        {
            ERRORTRACE((LOG_ESS, "UPDCONS: Could not process a scenario "
                         "change notification. HR=0x%x\n", hr ));
        }
    }    

    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsNamespace::NotifyScenarioChange( IWbemClassObject* pEvent)
{
    HRESULT hr;

    CPropVar vTarget;

    hr = pEvent->Get( L"TargetInstance", 0, &vTarget, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vTarget.CheckType( VT_UNKNOWN)) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pTarget;
    hr = V_UNKNOWN(&vTarget)->QueryInterface( IID_IWbemClassObject,
                                              (void**)&pTarget );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CPropVar vId;

    hr = pTarget->Get( g_wszIdProp, 0, &vId, NULL, NULL );
    
    if ( FAILED(hr) || FAILED(hr=vId.CheckType( VT_BSTR )) )
    {
        return hr;
    }

    if ( pEvent->InheritsFrom(L"__InstanceCreationEvent") == WBEM_S_NO_ERROR )
    {
        hr = ActivateScenario( V_BSTR(&vId) );
    }
    else if ( pEvent->InheritsFrom( L"__InstanceDeletionEvent" )
             == WBEM_S_NO_ERROR )
    {
        hr = DeactivateScenario( V_BSTR(&vId) );
    }

    return hr;
}

HRESULT CUpdConsNamespace::Create( LPCWSTR wszNamespace,
                                   CUpdConsNamespace** ppNamespace )
{
    HRESULT hr;
    *ppNamespace = NULL;

    CWbemPtr<CUpdConsNamespace> pNamespace;

    pNamespace = new CUpdConsNamespace;

    if ( pNamespace == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    hr = pNamespace->Initialize( wszNamespace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pNamespace->AddRef();
    *ppNamespace = pNamespace;
    
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updprov.h ===
#ifndef __UPDPROV_H__
#define __UPDPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>
#include <comutl.h>
#include "updnspc.h"

/*************************************************************************
  CUpdConsProvider
**************************************************************************/
class CUpdConsProvider 
: public CUnkBase<IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider>
{
    BOOL m_bInit;
    CCritSec m_csInit;
    CWbemPtr<CUpdConsNamespace> m_pNamespace;    
    
    HRESULT Init( LPCWSTR wszNamespace );

public:
    
    CUpdConsProvider( CLifeControl* pCtl );

    STDMETHOD(FindConsumer)( IWbemClassObject* pLogicalConsumer,
                             IWbemUnboundObjectSink** ppConsumer );
};


#endif // __UPDPROV__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updscen.cpp ===
#include "precomp.h"
#include <arrtempl.h>
#include <wbemutil.h>
#include "updscen.h"
#include "updnspc.h"
#include "updcons.h"
#include "updstat.h"

LPCWSTR g_wszTraceSuccessQuery = 
 L"SELECT * FROM MSFT_UCTraceEventBase WHERE StatusCode <= 1 "
 L"AND Consumer.Scenario = \""; 

LPCWSTR g_wszTraceFailureQuery = 
 L"SELECT * FROM MSFT_UCTraceEventBase WHERE StatusCode > 1 "
 L"AND Consumer.Scenario = \""; 

HRESULT CUpdConsScenario::Create( LPCWSTR wszScenario, 
                                  CUpdConsNamespace* pNamespace,
                                  CUpdConsScenario** ppScenario )
{
    HRESULT hr;

    CWbemPtr<CUpdConsScenario> pScenario = new CUpdConsScenario;

    if ( pScenario == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pScenario->m_pNamespace = pNamespace;

    if ( wszScenario != NULL )
    {
        pScenario->m_wsName = wszScenario;
    }

    //
    // get tracing sink from namespace.
    // 

    CWbemPtr<IWbemObjectSink> pSink = pNamespace->GetEventSink();

    _DBG_ASSERT( pSink != NULL );

    //
    // if the sink supports IWbemEventSink, then we'll get a restricted sink
    // from it based on our scenario.
    //
 
    CWbemPtr<IWbemEventSink> pNewSink;

    hr = pSink->QueryInterface( IID_IWbemEventSink, (void**)&pNewSink );
    
    if ( SUCCEEDED(hr) && wszScenario != NULL )
    {
        //
        // construct restricted query for successes.
        //
        
        WString wsQuery = g_wszTraceSuccessQuery;
        wsQuery += wszScenario;
        wsQuery += L"\"";
        
        LPCWSTR wszQuery = wsQuery;
        
        hr = pNewSink->GetRestrictedSink( 1, 
                                          &wszQuery, 
                                          NULL, 
                                          &pScenario->m_pTraceSuccessSink );
        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // construct restricted query for failures.
        //

        wsQuery = g_wszTraceFailureQuery;
        wsQuery += wszScenario;
        wsQuery += L"\"";
        
        wszQuery = wsQuery;
        
        hr = pNewSink->GetRestrictedSink( 1, 
                                          &wszQuery, 
                                          NULL, 
                                       &pScenario->m_pTraceFailureSink );
        if ( FAILED(hr) )
        {
            return hr;
        }
    
        DEBUGTRACE(( LOG_ESS,
                     "UPDPROV: Tracing Optimized for scenario %s.\n",
                     wszScenario ));
    }
    else
    {
        //
        // this is o.k. we're on an older platform.  tracing just won't 
        // be optimized.
        //

        DEBUGTRACE(( LOG_ESS,
                     "UPDPROV: Tracing Not Optimized for scenario %s.\n",
                     wszScenario ));        
    }

    pScenario->AddRef();
    *ppScenario = pScenario;
   
    return WBEM_S_NO_ERROR;
}

HRESULT CUpdConsScenario::FireTraceEvent( IWbemClassObject* pTraceClass,
                                          CUpdConsState& rState,
                                          HRESULT hrStatus )
{
    HRESULT hr;

    CWbemPtr<IWbemObjectSink> pTraceSink;

    if ( m_pTraceSuccessSink != NULL && m_pTraceFailureSink != NULL )
    {
        if ( SUCCEEDED(hrStatus) )
        {
            if ( m_pTraceSuccessSink->IsActive() == WBEM_S_FALSE )
            {
                return WBEM_S_NO_ERROR;
            }
            else
            {
                pTraceSink = m_pTraceSuccessSink.m_pObj;
            }
        }
        else if ( m_pTraceFailureSink->IsActive() == WBEM_S_FALSE )
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pTraceSink = m_pTraceFailureSink.m_pObj;
        }
    }
    else
    {
        pTraceSink = m_pNamespace->GetEventSink();
    }

    CWbemPtr<IWbemClassObject> pTraceObj;

    hr = pTraceClass->SpawnInstance( 0, &pTraceObj );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = rState.SetStateOnTraceObject( pTraceObj, hrStatus );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pTraceSink->Indicate( 1, &pTraceObj );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updscen.h ===
#ifndef __UPDSCEN_H__
#define __UPDSCEN_H__

#include <wstring.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>
#include <sync.h>
#include <comutl.h>

class CUpdCons;
class CUpdConsState;
class CUpdConsNamespace;

/*************************************************************************
  CUpdConsScenario
**************************************************************************/

class CUpdConsScenario : public CUnk
{
    CCritSec m_cs;
    WString m_wsName;
    BOOL m_bActive;
    CWbemPtr<IWbemEventSink> m_pTraceSuccessSink;
    CWbemPtr<IWbemEventSink> m_pTraceFailureSink;

    CUpdConsNamespace* m_pNamespace; // No AddRef because Circular Ref.
    
    CUpdConsScenario() : m_pNamespace(NULL), m_bActive(TRUE) {} 

public:
    
    void* GetInterface( REFIID ) { return NULL; }

    CRITICAL_SECTION* GetLock() { return &m_cs; }

    BOOL IsActive() { return m_bActive; }
    void Deactivate() { m_bActive = FALSE; }
    LPCWSTR GetName() { return m_wsName; }

    CUpdConsNamespace* GetNamespace() { return m_pNamespace; }

    HRESULT FireTraceEvent( IWbemClassObject* pTraceClass,
                            CUpdConsState& rStatus,
                            HRESULT hrStatus );
                            
    HRESULT GetUpdCons( IWbemClassObject* pObj, CUpdCons** ppSink );

    static HRESULT Create( LPCWSTR wszScenario, 
                           CUpdConsNamespace* pNamespace,
                           CUpdConsScenario** ppScenario );
};

#endif //  __UPDSCEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updnspc.h ===
#ifndef __UPDNSPC_H__
#define __UPDNSPC_H__

#include <arrtempl.h>
#include <wstring.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <wstring.h>
#include <unk.h>
#include <sync.h>
#include <map>
#include <wstlallc.h>
#include "updscen.h"
#include "updstat.h"

/*****************************************************************************
  CUpdConsNamespace - holds per namespace information for the updating 
  consumer provider.  
******************************************************************************/

class CUpdConsNamespace : public CUnk 
{
    CCritSec m_cs;

    typedef CWbemPtr<CUpdConsScenario> UpdConsScenarioP;
    typedef std::map< WString,
                      UpdConsScenarioP,
                      WSiless,
                      wbem_allocator<UpdConsScenarioP> > ScenarioMap;
    //
    // list of ACTIVE scenarios.
    //
    ScenarioMap m_ScenarioCache;

    //
    // Default Service Ptr
    //

    CWbemPtr<IWbemServices> m_pSvc;

    //
    // tracing class info.
    //
    
    CWbemPtr<IWbemClassObject> m_pTraceClass;
    CWbemPtr<IWbemClassObject> m_pDeleteCmdTraceClass;
    CWbemPtr<IWbemClassObject> m_pInsertCmdTraceClass;
    CWbemPtr<IWbemClassObject> m_pUpdateCmdTraceClass;
    CWbemPtr<IWbemClassObject> m_pDeleteInstTraceClass;
    CWbemPtr<IWbemClassObject> m_pInsertInstTraceClass;
    CWbemPtr<IWbemClassObject> m_pUpdateInstTraceClass;
    
    //
    // sink for update driven event generation.  also is used for 
    // trace event generation if there are subscribers.
    //

    CWbemPtr<IWbemObjectSink> m_pEventSink;     

    //
    // need to hold onto this while holding sinks obtained from it.
    //

    CWbemPtr<IWbemDecoupledBasicEventProvider> m_pDES;

    void* GetInterface( REFIID ) { return NULL; }

    HRESULT Initialize( LPCWSTR wszNamespace );
    HRESULT ActivateScenario( LPCWSTR wszScenario ); 
    HRESULT DeactivateScenario( LPCWSTR wszScenario ); 

public:

    ~CUpdConsNamespace();

    IWbemServices* GetDefaultService() { return m_pSvc; }
    IWbemClassObject* GetTraceClass() { return m_pTraceClass; }
    
    IWbemClassObject* GetDeleteCmdTraceClass() 
    { 
        return m_pDeleteCmdTraceClass; 
    }
    IWbemClassObject* GetInsertCmdTraceClass() 
    { 
        return m_pInsertCmdTraceClass; 
    }
    IWbemClassObject* GetUpdateCmdTraceClass() 
    { 
        return m_pUpdateCmdTraceClass; 
    }
    IWbemClassObject* GetDeleteInstTraceClass()
    { 
        return m_pDeleteInstTraceClass;
    }
    IWbemClassObject* GetInsertInstTraceClass()
    {
        return m_pInsertInstTraceClass;
    }
    IWbemClassObject* GetUpdateInstTraceClass()
    {
        return m_pUpdateInstTraceClass;
    }
   
    IWbemObjectSink* GetEventSink() { return m_pEventSink; }

    static HRESULT Create( LPCWSTR wszNamespace,
                           CUpdConsNamespace** ppNamespace );

    //
    // called by Consumer Sink when it's current scenario obj is deactivated.
    // 
    HRESULT GetScenario( LPCWSTR wszScenario, CUpdConsScenario** ppScenario );

    //
    // called by FindConsumer()
    //
    HRESULT GetUpdCons( IWbemClassObject* pObj, 
                        IWbemUnboundObjectSink** ppSink );

    HRESULT GetScenarioControl( IWbemUnboundObjectSink** ppSink );

    HRESULT NotifyScenarioChange( IWbemClassObject* pEvent );
};

/*****************************************************************************
  CUpdConsNamespaceSink - Used for notification of a change in a scenario's 
  state. We need to use permanent consumer mechanism because the notification 
  of the change MUST be handled synchronously. Ideally, we should use the 
  temporary subscription mechanism, subscribing/unsubscribing when the 
  namespace is initialized/uninitialized, however we cannot get sync delivery
  with it.  Should be changed when ess supports sync temp subscriptions.
******************************************************************************/

class CUpdConsNamespaceSink 
: public CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink >
{
    CWbemPtr<CUpdConsNamespace> m_pNamespace;

public:

    CUpdConsNamespaceSink( CLifeControl* pCtl, CUpdConsNamespace* pNamespace ) 
    : CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink > ( pCtl ),
      m_pNamespace( pNamespace ) { } 
                           
    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pCons, 
                                   long cObjs, 
                                   IWbemClassObject** ppObjs );
};


#endif // __UPDNSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsink.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include <cimval.h>
#include <arrtempl.h>
#include <stack>
#include <pathutl.h>
#include <txttempl.h>
#include "updsink.h"
#include "updcmd.h"
#include "updstat.h"

const LPCWSTR g_wszNowAlias = L"__NOW";
const LPCWSTR g_wszServerAlias = L"__SERVER";
const LPCWSTR g_wszSubType = L"SubType";
const LPCWSTR g_wszRelPath = L"__RelPath";
const LPCWSTR g_wszInterval = L"Interval";
const LPCWSTR g_wszQueryLang = L"WQL";

extern BOOL FileTimeToDateTime( FILETIME* pft, LPWSTR wszText );

HRESULT EvaluateExpression( SQLAssignmentToken& rAssignTok, 
                            IWmiObjectAccess* pAccess, 
                            CCimValue& rValue );

HRESULT EvaluateToken( IWmiObjectAccess* pAccess, QL_LEVEL_1_TOKEN& Tok );

HRESULT GetTokenValue( SQLExpressionToken& rTok, 
                       IWmiObjectAccess* pAccess, 
                       ULONG& rulCimType,
                       VARIANT& vValue );

static LPCWSTR FastGetComputerName()
{
    static CCritSec cs;
    static WCHAR awchBuff[MAX_COMPUTERNAME_LENGTH+1];
    static BOOL bThere = FALSE;

    CInCritSec ics(&cs);
    
    if ( bThere )
    {
        ;
    }
    else
    {
        DWORD dwMax = MAX_COMPUTERNAME_LENGTH+1;
        TCHAR atchBuff[MAX_COMPUTERNAME_LENGTH+1];
        GetComputerName( atchBuff, &dwMax );
        dwMax = MAX_COMPUTERNAME_LENGTH+1;
        tsz2wsz( atchBuff, awchBuff, &dwMax );
        bThere = TRUE;
    }

    return awchBuff;
}

/*
//
// This function will return the embedded object identified by 
// pObj.(PropName-lastelement). If PropName only contains one element, 
// then pObj will be returned.
//
HRESULT GetInnerMostObject( CPropertyName& PropName,
                            IWbemClassObject* pObj,
                            IWbemClassObject** ppInnerObj )
{
    HRESULT hr;
    VARIANT var;

    long lElements = PropName.GetNumElements();
    
    CWbemPtr<IWbemClassObject> pInnerObj = pObj;
    
    for( long i=0; i < lElements-1; i++ )
    {
        LPCWSTR wszElement = PropName.GetStringAt(i);

        CClearMe cmvar( &var );
 
        hr = pInnerObj->Get( wszElement, 0, &var, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&var) != VT_UNKNOWN )
        {
            return WBEM_E_NOT_FOUND;
        }
        
        pInnerObj.Release();

        hr = V_UNKNOWN(&var)->QueryInterface( IID_IWbemClassObject, 
                                              (void**)&pInnerObj );
        _DBG_ASSERT( SUCCEEDED(hr) );
    }

    pInnerObj->AddRef();
    *ppInnerObj = pInnerObj;
    
    return WBEM_S_NO_ERROR;
}

*/

// This method handles embedded object properties.
HRESULT GetValue( CPropertyName& rPropName,
                  IWmiObjectAccess* pAccess,
                  ULONG& rulCimType, 
                  VARIANT* pvarRet )
{
    HRESULT hr;
    long lElements = rPropName.GetNumElements();
    
    if ( lElements == 0 ) 
    {
        rulCimType = CIM_OBJECT;
        
        if ( pvarRet != NULL )
        {
            CWbemPtr<IWbemClassObject> pObj;

            hr = pAccess->GetObject( &pObj );

            if ( FAILED(hr) )
            {
                return hr;
            }

            //
            // then the caller really want this object ...
            //
            V_VT(pvarRet) = VT_UNKNOWN;
            V_UNKNOWN(pvarRet) = pObj;
            pObj->AddRef();
        }
        
        return WBEM_S_NO_ERROR;
    }

    _DBG_ASSERT( lElements > 0 );

    //
    // check for __NOW alias.
    //         

    if ( _wcsicmp( rPropName.GetStringAt(0), g_wszNowAlias ) == 0 )
    {
        FILETIME ft;
        WCHAR achBuff[64];
        GetSystemTimeAsFileTime(&ft);
        FileTimeToDateTime(&ft,achBuff);
        rulCimType = CIM_DATETIME;
        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(achBuff);

        if ( V_BSTR(pvarRet) == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        return WBEM_S_NO_ERROR;
    }

    //
    // check for __SERVER alias
    //

    if ( _wcsicmp( rPropName.GetStringAt(0), g_wszServerAlias ) == 0 )
    {        
        rulCimType = CIM_STRING;
        V_VT(pvarRet) = VT_BSTR;
        V_BSTR(pvarRet) = SysAllocString(FastGetComputerName());
        
        if ( V_BSTR(pvarRet) == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        return WBEM_S_NO_ERROR;
    }

    LPVOID pvPropHdl = rPropName.GetHandle();
    _DBG_ASSERT( pvPropHdl != NULL );

    CIMTYPE ct;

    hr = pAccess->GetProp( pvPropHdl, 0, pvarRet, &ct );

    if ( FAILED(hr) )
    {
        return hr;
    }

    rulCimType = ct;

    return hr;

/*        
    HRESULT hr = GetInnerMostObject( PropName, pObj, &pInnerObj );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemBSTR bstrElement = PropName.GetStringAt( lElements-1 );
        
    hr = pInnerObj->Get( bstrElement, 0, pvarRet, (long*)&rulCimType, NULL );

    if ( rulCimType == CIM_DATETIME )
    {
        //
        // have to know if the datetime is really an interval or not.
        //

        CWbemPtr<IWbemQualifierSet> pQualSet;
        hr = pInnerObj->GetPropertyQualifierSet( bstrElement, &pQualSet );

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        VARIANT vSubType;
        hr = pQualSet->Get( g_wszSubType, 0, &vSubType, NULL );

        if ( SUCCEEDED(hr) )
        {
            if ( V_VT(&vSubType) == VT_BSTR && 
                 _wcsicmp( V_BSTR(&vSubType), g_wszInterval ) == 0 )
            {
                rulCimType = CIM_INTERVAL; // non standard type !!!!
            }
            VariantClear(&vSubType);
        }
        else if ( hr == WBEM_E_NOT_FOUND )
        {
            hr = WBEM_S_NO_ERROR;
        }
    }

    return hr;
*/

}

//
// this method handles embedded object properties. 
//

HRESULT SetValue( CPropertyName& rPropName,
                  IWmiObjectAccess* pAccess,
                  VARIANT vVal,
                  ULONG ulCimType )
{
    HRESULT hr;

    long lElements = rPropName.GetNumElements();

    _DBG_ASSERT( lElements > 0 );

    LPCWSTR wszElement = rPropName.GetStringAt(lElements-1);

    if ( wszElement == NULL )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    LPVOID pvPropHdl = rPropName.GetHandle();

    _DBG_ASSERT( pvPropHdl != NULL );

    if ( _wcsicmp( wszElement, L"__this" ) != 0 )
    {
        //
        // first get the type of the property we are going to set
        //
 
        CIMTYPE ctProp;

        hr = pAccess->GetProp( pvPropHdl, 0, NULL, &ctProp );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // now convert our type to the expected type if necessary.
        // currently, the put will do most conversion, however we run into
        // a problem with conversion when the variant type doesn't correctly
        // describe the type that it holds.  to complicate this further, 
        // specifying the cim type on the put doesn't do the job.  The only
        // conversion we have to worry about is an unsigned val to a string. 
        // (because variant will say it is a signed type).
        // 

        WCHAR awchBuff[64]; // used for conversion from unsigned to string 

        if ( ctProp == CIM_STRING )
        {            
            if ( ulCimType == CIM_UINT32 || 
                 ulCimType == CIM_UINT16 ||
                 ulCimType == CIM_UINT8 )
            {
                hr = VariantChangeType( &vVal, &vVal, 0, VT_UI4 );
                
                if ( FAILED(hr) )
                {
                    return WBEM_E_TYPE_MISMATCH;
                }
                
                _ultow( V_UI4(&vVal), awchBuff, 10 );

                V_VT(&vVal) = VT_BSTR;
                V_BSTR(&vVal) = awchBuff;
            }
        }

        return pAccess->PutProp( pvPropHdl, 0, &vVal, 0 );
    }

    return WBEM_E_NOT_SUPPORTED;
}
/*
    //
    // we need to copy the entire object. first check that the 
    // variant is of the correct type.
    //

    if ( V_VT(&vVal) != VT_UNKNOWN )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    CWbemPtr<IWbemClassObject> pOther;
    
    hr = V_UNKNOWN(&vVal)->QueryInterface( IID_IWbemClassObject,
                                           (void**)&pOther );
    if ( FAILED(hr) )
    {
        return WBEM_E_TYPE_MISMATCH;
    }

    //
    // we don't do a clone here because the target object might not be of 
    // the same class as the source object, although it must have the same 
    // properties. ( this might be going a bit too far ).
    // 

    hr = pOther->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BSTR bstrOther;
    VARIANT vOther;
    CIMTYPE ctOther;

    VariantInit( &vOther );
    CClearMe cmvOther( &vOther );

    hr = pOther->Next( 0, &bstrOther, &vOther, &ctOther, NULL ); 

    while( hr == WBEM_S_NO_ERROR )
    {
        hr = pInnerObj->Put( bstrOther, 0, &vOther, ctOther );

        SysFreeString( bstrOther );
        VariantClear( &vOther );

        if ( FAILED(hr) )
        {
            return hr;
        }
                         
        hr = pOther->Next( 0, &bstrOther, &vOther, &ctOther, NULL ); 
    }       

    return hr;
}

*/

inline void GetAssignmentTokenText( SQLAssignmentToken& rToken, 
                                    CWbemBSTR& rbstrText )
{
    for( int i=0; i < rToken.size(); i++ )
    {
        LPWSTR wszTokenText = rToken[i].GetText();
        rbstrText += wszTokenText;
        delete wszTokenText;
    }
}
    

/***************************************************************************
  CResolverSink
****************************************************************************/

HRESULT CResolverSink::ResolveAliases( IWmiObjectAccess* pAccess,
                                       AliasInfo& rInfo,
                                       CUpdConsState& rState )
{
    int i, j, k;
    HRESULT hr = S_OK;
    VARIANT* pvarTgt;

    SQLCommand* pCmd = rState.GetSqlCmd();

    if ( rInfo.m_WhereOffsets.size() + rInfo.m_AssignOffsets.size() > 0 
         && pAccess == NULL )
    {
        return WBEM_E_INVALID_QUERY;
    }

    for( i=0; i < rInfo.m_AssignOffsets.size(); i++ )
    {
        j = rInfo.m_AssignOffsets[i] >> 16;
        k = rInfo.m_AssignOffsets[i] & 0xffff;
        
        SQLExpressionToken& rExprTok = pCmd->m_AssignmentTokens[j][k];
        
        ULONG& rulCimType = rExprTok.m_ulCimType;
        pvarTgt = &rExprTok.m_vValue;
        
        VariantClear( pvarTgt );
        
        hr = GetValue( rExprTok.m_PropName, pAccess, rulCimType, pvarTgt );

        if ( FAILED(hr) )
        {
            LPWSTR wszErrStr = rExprTok.m_PropName.GetText();
            rState.SetErrStr( wszErrStr );
            delete wszErrStr;
            return hr;
        }
    }

    for( i=0; i < rInfo.m_WhereOffsets.size(); i++ )
    {
        j = rInfo.m_WhereOffsets[i];
        pvarTgt = &pCmd->pArrayOfTokens[j].vConstValue;

        VariantClear( pvarTgt );

        // Property to resolve is always property 2 ..
        CPropertyName& rTgtProp = pCmd->pArrayOfTokens[j].PropertyName2;

        ULONG ulCimType;
        hr = GetValue( rTgtProp, pAccess, ulCimType, pvarTgt );

        if ( FAILED(hr) )
        {
            LPWSTR wszErrStr = rTgtProp.GetText();
            rState.SetErrStr( wszErrStr );
            delete wszErrStr;
            return hr;
        }
    }

    return hr;
}

HRESULT CResolverSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // resolve any event aliases. 
    // 

    hr = ResolveAliases( rState.GetEventAccess(), m_rEventAliasInfo, rState );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // resolve ant data aliases
    // 

    hr = ResolveAliases( rState.GetDataAccess(), m_rDataAliasInfo, rState );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pNext->Execute( rState );
}

/***************************************************************************
  CFetchDataSink
****************************************************************************/

HRESULT CFetchDataSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // execute the query here.  for each object returned, call resolve 
    // and continue with the execute.
    //

    long lFlags = WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY;
        
    //
    // first, we must resolve any Event Aliases in the data query.
    //
        
    CTextTemplate TextTmpl( m_wsDataQuery );
        
    BSTR bsNewQuery = TextTmpl.Apply( rState.GetEvent() );

    if ( bsNewQuery == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CSysFreeMe sfm( bsNewQuery );  
    
    //
    // execute the data query.
    // 
    
    CWbemPtr<IEnumWbemClassObject> pEnum;

    hr = m_pDataSvc->ExecQuery( CWbemBSTR(g_wszQueryLang), 
                                bsNewQuery,
                                lFlags, 
                                NULL, 
                                &pEnum );    
    if ( FAILED(hr) )
    {
        rState.SetErrStr( bsNewQuery );
        return hr;
    }

    ULONG cRetObjs;
    CWbemPtr<IWbemClassObject> pData;
        
    //
    // for each data object returned, call execute on next sink.
    //
    
    hr = pEnum->Next( WBEM_INFINITE, 1, &pData, &cRetObjs );

    if ( FAILED(hr) )
    {
        //
        // only need to check on the first next to see if the query was 
        // invalid ( since we're using 'return immediately' we don't catch it
        // on the exec query - kind of inconvienent )
        // 
        rState.SetErrStr( bsNewQuery );
        return hr;
    }

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cRetObjs == 1 );

        rState.SetData( pData );

        hr = m_pNext->Execute( rState );

        if ( FAILED(hr) )
        {
            break;
        }

        pData.Release();
        
        hr = pEnum->Next( WBEM_INFINITE, 1, &pData, &cRetObjs );
    }

    if ( hr != WBEM_S_FALSE )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

/***************************************************************************
  CFetchTargetObjectsAsync
****************************************************************************/

HRESULT CFetchTargetObjectsAsync::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // set the next item in the chain on the state, then pass the 
    // state object as the object sink. 
    //

    CUpdConsSink* pOldNext = rState.GetNext();

    rState.SetNext( m_pNext );

    SQLCommand* pCmd = rState.GetSqlCmd();

    hr = m_pSvc->CreateInstanceEnumAsync( pCmd->bsClassName,
                                          WBEM_FLAG_DEEP,
                                          NULL, 
                                          &rState );
    rState.SetNext( pOldNext );

    return hr;
};

/***************************************************************************
  CFetchTargetObjectsSync
****************************************************************************/

HRESULT CFetchTargetObjectsSync::Execute( CUpdConsState& rState )
{
    HRESULT hr;
    ULONG cObjs;
    CWbemPtr<IWbemClassObject> pObj;
    CWbemPtr<IEnumWbemClassObject> pEnum;

    long lFlags = WBEM_FLAG_DEEP | 
                  WBEM_FLAG_FORWARD_ONLY | 
                  WBEM_FLAG_RETURN_IMMEDIATELY;

    SQLCommand* pCmd = rState.GetSqlCmd();

    hr = m_pSvc->CreateInstanceEnum( pCmd->bsClassName,
                                     lFlags,
                                     NULL,
                                     &pEnum );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );

    while( hr == WBEM_S_NO_ERROR )
    {
        _DBG_ASSERT( cObjs == 1 );
        
        rState.SetInst( pObj );

        hr = m_pNext->Execute( rState );

        if ( FAILED(hr) )
        {
            break;
        }

        pObj.Release();
        hr = pEnum->Next( WBEM_INFINITE, 1, &pObj, &cObjs );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return WBEM_S_NO_ERROR;
};

/***************************************************************************
  CNoFetchTargetObjects
****************************************************************************/

HRESULT CNoFetchTargetObjects::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    CWbemPtr<IWbemClassObject> pObj;
    hr = m_pClassObj->SpawnInstance( 0, &pObj );
    
    if ( FAILED(hr) ) 
    {
        return hr;
    }    

    rState.SetInst( pObj );

    return m_pNext->Execute( rState );
}                           

/***************************************************************************
  CTraceSink 
****************************************************************************/
 
HRESULT CTraceSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    //
    // execute the next object and then generate a trace event.
    //

    if ( m_pNext != NULL )
    {
        hr = m_pNext->Execute( rState );
    }
    else
    {
        hr = S_OK;
    }

    m_pScenario->FireTraceEvent( m_pTraceClass, rState, hr );

    return hr;
}

/****************************************************************************
  CFilterSink
*****************************************************************************/

HRESULT CFilterSink::Execute( CUpdConsState& rState )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    char achStack[256];
    UCHAR chTop = 0;
    BOOL bA,bB;
    LPWSTR wszErrStr;
    QL_LEVEL_1_TOKEN* pToken;

    SQLCommand* pCmd = rState.GetSqlCmd();
    IWmiObjectAccess* pAccess = rState.GetInstAccess();

    if ( pCmd->nNumTokens == 0 )
    {
        // nothing to filter ...
        return m_pNext->Execute( rState );
    }

    chTop = 0;
    for( int j=0; j < pCmd->nNumTokens; j++ )
    {
        pToken = &pCmd->pArrayOfTokens[j];

        switch( pToken->nTokenType )
        {
            
        case QL_LEVEL_1_TOKEN::OP_EXPRESSION:
            hr = EvaluateToken( pAccess, *pToken );
            if ( FAILED(hr) )
            {
                wszErrStr = pToken->GetText();
                rState.SetErrStr( wszErrStr );
                delete wszErrStr;
                return hr;
            }
            achStack[chTop++] = hr != S_FALSE;
            break;
            
        case QL_LEVEL_1_TOKEN::TOKEN_AND:
            bA = achStack[--chTop];
            bB = achStack[--chTop];
            achStack[chTop++] = bA && bB;
            break;
            
        case QL_LEVEL_1_TOKEN::TOKEN_OR:
            bA = achStack[--chTop];
            bB = achStack[--chTop];
            achStack[chTop++] = bA || bB;
            break;
            
        case QL_LEVEL_1_TOKEN::TOKEN_NOT:
            achStack[chTop-1] = achStack[chTop-1] == 0;
            break;
        }
    }

    // now we should be left with one token on the stack - or 
    // something is wrong with our parser .. 
    _DBG_ASSERT( chTop == 1 );
    
    if ( achStack[0] )
    {
        hr = m_pNext->Execute( rState );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    
    return WBEM_S_NO_ERROR;
}

/***************************************************************************
  CAssignmentSink
****************************************************************************/

//
// The purpose of this function is to smooth out differences in 
// PutInstance() semantics between the Transient and other Providers.  
// Transient provider is different than other providers because it treats
// properties that are NULL as ignore. 
//

HRESULT CAssignmentSink::NormalizeObject( IWbemClassObject* pObj,
                                          IWbemClassObject** ppNormObj )
{
    HRESULT hr;
    *ppNormObj = NULL;

    if ( m_eCommandType == SQLCommand::e_Insert )
    {
        //
        // if its an insert, we don't need to do anything.
        //

        pObj->AddRef();
        *ppNormObj = pObj;
        
        return WBEM_S_NO_ERROR;
    }

    //
    // We always need to update a copy because the we need to keep 
    // the original state of the object to maintain the update semantics.
    // Whether we clone or spawn a new instance depends on the transient 
    // semantics.
    //

    if ( !m_bTransSemantics )
    {
        return pObj->Clone( ppNormObj );
    }

    //
    // for transient semantics, we spawn a new instance and set the 
    // key props.
    //

    CWbemPtr<IWbemClassObject> pNormObj;

    hr = m_pClassObj->SpawnInstance( 0, &pNormObj );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    hr = pObj->BeginEnumeration( WBEM_FLAG_KEYS_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BSTR bstrProp;
    VARIANT varProp;
    
    hr = pObj->Next( NULL, &bstrProp, &varProp, NULL, NULL);

    while( hr == WBEM_S_NO_ERROR )
    {
        hr = pNormObj->Put( bstrProp, NULL, &varProp, 0 );

        SysFreeString( bstrProp );
        VariantClear( &varProp );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pObj->Next( NULL, &bstrProp, &varProp, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    pObj->EndEnumeration();
    
    pNormObj->AddRef();
    *ppNormObj = pNormObj.m_pObj;
    
    return WBEM_S_NO_ERROR;
}

HRESULT CAssignmentSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    _DBG_ASSERT( rState.GetSqlCmd()->nNumberOfProperties == 
                 rState.GetSqlCmd()->m_AssignmentTokens.size() );

    SQLCommand* pCmd = rState.GetSqlCmd();    
    IWbemClassObject* pOrig = rState.GetInst();

    CWbemPtr<IWbemClassObject> pObj;
        
    hr = NormalizeObject( pOrig, &pObj );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // move our current inst to original inst and set the new obj as inst.
    //
    rState.SetInst( pObj );
    rState.SetOrigInst( pOrig ); 

    IWmiObjectAccess* pInstAccess = rState.GetInstAccess();
    IWmiObjectAccess* pOrigInstAccess = rState.GetOrigInstAccess();

    _DBG_ASSERT( pInstAccess != NULL && pOrigInstAccess != NULL );

    for( int j=0; j < pCmd->m_AssignmentTokens.size(); j++ )
    {            
        SQLAssignmentToken& rAssignTok = pCmd->m_AssignmentTokens[j];
        VARIANT varAssign;
        ULONG ulCimType;

        if ( rAssignTok.size() == 1 )
        {
            // 
            // bypass Evaluation of the expression.  This is because 
            // it does not handle strings, objects, etc ...
            //
            
            hr = GetTokenValue( rAssignTok[0], 
                                pOrigInstAccess, 
                                ulCimType, 
                                varAssign );
        }
        else
        {   
            CCimValue Value;

            hr = EvaluateExpression( rAssignTok, pOrigInstAccess, Value );

            if ( FAILED(hr) )
            {
                CWbemBSTR bsErrStr;
                GetAssignmentTokenText( rAssignTok, bsErrStr );      
                rState.SetErrStr( bsErrStr );
                break;
            }

            // 
            // now must get the cimtype of the property.
            //

            hr = GetValue( pCmd->pRequestedPropertyNames[j],
                           pOrigInstAccess,
                           ulCimType, 
                           NULL );
            
            if ( FAILED(hr) )
            {
                LPWSTR wszErrStr = pCmd->pRequestedPropertyNames[j].GetText();
                rState.SetErrStr( wszErrStr);
                delete wszErrStr;
                return hr;
            }

            // 
            // Get the final value from the CCimValue object. 
            //

            hr = Value.GetValue( varAssign, ulCimType );
        }

        if ( FAILED(hr) )
        {
            CWbemBSTR bsErrStr;
            GetAssignmentTokenText( rAssignTok, bsErrStr );      
            rState.SetErrStr( bsErrStr );
            break;
        }
        
        hr = SetValue( pCmd->pRequestedPropertyNames[j], 
                       pInstAccess,
                       varAssign,
                       ulCimType );

        VariantClear( &varAssign );

        if ( FAILED(hr) )
        {
            LPWSTR wszErrorStr = pCmd->pRequestedPropertyNames[j].GetText();
            rState.SetErrStr( wszErrorStr );
            delete wszErrorStr;
            return hr;
        }
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pNext->Execute( rState );
}

/*************************************************************************
  CPutSink
**************************************************************************/

HRESULT CPutSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    long lFlags = m_lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;
    
    IWbemClassObject* pObj = rState.GetInst();

    if ( m_lFlags & WBEM_FLAG_RETURN_IMMEDIATELY )
    {
        CUpdConsSink* pOldNext = rState.GetNext();

        rState.SetNext( NULL );  // use state obj as a null sink.
        
        hr = m_pSvc->PutInstanceAsync( pObj, lFlags, NULL, &rState );
    
        rState.SetNext( pOldNext );
    }
    else
    {
        hr = m_pSvc->PutInstance( pObj, lFlags, NULL, NULL );
    }
        
    if ( (hr == WBEM_E_ALREADY_EXISTS && m_lFlags & WBEM_FLAG_CREATE_ONLY) || 
         (hr == WBEM_E_NOT_FOUND && m_lFlags & WBEM_FLAG_UPDATE_ONLY) )
    {
        hr = WBEM_S_FALSE;
    }
    else if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_pNext != NULL )
    {
        HRESULT hr2;

        hr2 = m_pNext->Execute( rState );

        if ( FAILED(hr2) )
        {
            return hr2;
        }
    }

    //
    // make sure that if the Put was not executed, but also did not execute 
    // that we return WBEM_S_FALSE
    //

    return hr;
}

/*************************************************************************
  CDeleteSink
**************************************************************************/

HRESULT CDeleteSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;
    CPropVar vRelPath;

    IWbemClassObject* pObj = rState.GetInst();

    hr = pObj->Get( g_wszRelPath, 0, &vRelPath, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vRelPath.CheckType(VT_BSTR)) ) 
    {
        return hr;
    }

    long lFlags = m_lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;
    
    if ( m_lFlags & WBEM_FLAG_RETURN_IMMEDIATELY )
    {
        CUpdConsSink* pOldNext = rState.GetNext();

        rState.SetNext( NULL );
        
        hr = m_pSvc->DeleteInstanceAsync( V_BSTR(&vRelPath), 
                                          lFlags, 
                                          NULL, 
                                          &rState );            
        rState.SetNext( pOldNext );
    }
    else
    {
        hr = m_pSvc->DeleteInstance( V_BSTR(&vRelPath), lFlags, NULL, NULL );
    }

    if ( FAILED(hr) )
    {
        rState.SetErrStr( V_BSTR(&vRelPath) );
        return hr;
    }
    
    if ( m_pNext != NULL )
    {
        return m_pNext->Execute( rState );
    }

    return WBEM_S_NO_ERROR;
}

/*************************************************************************
  CBranchIndicateSink
**************************************************************************/

HRESULT CBranchIndicateSink::Execute( CUpdConsState& rState )
{
    HRESULT hr;

    IWbemClassObject* pInst = rState.GetInst();
       
    hr = m_pSink->Indicate( 1, &pInst );
        
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_pNext != NULL )
    {
        return m_pNext->Execute( rState );
    }

    return WBEM_S_NO_ERROR;
}

HRESULT EvaluateToken( IWmiObjectAccess* pObj, QL_LEVEL_1_TOKEN& Tok )
{
    VARIANT PropVal, CompVal;
    VariantInit(&PropVal);
    VariantInit(&CompVal);
    
    CClearMe clv(&PropVal);
    CClearMe clv2(&CompVal);

    HRESULT hr;

    if( Tok.nOperator == QL1_OPERATOR_ISA ||
        Tok.nOperator == QL1_OPERATOR_ISNOTA ||
        Tok.nOperator == QL1_OPERATOR_INV_ISA ||
        Tok.nOperator == QL1_OPERATOR_INV_ISNOTA)
    {
        return WBEM_E_INVALID_QUERY;
    }

    ULONG ulCimType1, ulCimType2 = CIM_EMPTY;

    hr = GetValue( Tok.PropertyName, pObj, ulCimType1, &PropVal );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Handle a property-to-property comparisons

    if ( Tok.m_bPropComp != FALSE && V_VT(&Tok.vConstValue) == VT_EMPTY )
    {
        hr = GetValue( Tok.PropertyName2, pObj, ulCimType2, &CompVal );
       
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        hr = VariantCopy( &CompVal, &Tok.vConstValue );

        if ( FAILED(hr) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
    }

    // now propval and compval are both set ...

    //
    // if either CimType1 or CimType2 are of type relpath, we must normalize
    // the relpaths of both and then compare
    // 

    if ( ulCimType1 == CIM_REFERENCE || ulCimType2 == CIM_REFERENCE )
    {
        // This is a reference. The only operators allowed are = and !=
        // ============================================================
        
        if ( V_VT(&CompVal) != VT_BSTR || V_VT(&PropVal) != VT_BSTR )
        {
            return WBEM_E_TYPE_MISMATCH;
        }

        CRelativeObjectPath PathA;
        CRelativeObjectPath PathB;

        if ( !PathA.Parse( V_BSTR(&CompVal) ) ||
            !PathB.Parse( V_BSTR(&PropVal) ) )
        {
            return WBEM_E_INVALID_OBJECT_PATH;
        }
        
        if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL )
        {
            return PathA == PathB ? S_OK : S_FALSE;
        }
        else if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL )
        {
            return PathA == PathB ? S_FALSE : S_OK;
        }
        return WBEM_E_INVALID_QUERY;
    }

    // Handle NULLs
    // ============

    if( V_VT(&PropVal) == VT_NULL)
    {
        if ( V_VT(&CompVal) == VT_NULL)
        {
            if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_EQUAL )
                return S_OK;
            return S_FALSE;
        }
        else
        {
            if ( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL )
                return S_OK;
            return S_FALSE;
        }
    }
    else if ( V_VT(&CompVal) == VT_NULL )
    {
        if( Tok.nOperator == QL_LEVEL_1_TOKEN::OP_NOT_EQUAL )
            return S_OK;
        return S_FALSE;
    }

    // Coerce types to match.
    // ======================

    if(V_VT(&CompVal) != VT_NULL && V_VT(&PropVal) != VT_NULL)
    {
        hr = VariantChangeType(&CompVal, &CompVal, 0, V_VT(&PropVal));
        if(FAILED(hr))
        {
            return WBEM_E_INVALID_QUERY;
        }
    }

    switch (V_VT(&CompVal))
    {
    case VT_NULL:
        return WBEM_E_INVALID_QUERY; // handled above

    case VT_I4:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            LONG va = V_I4(&PropVal);
            LONG vb = V_I4(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_I2:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            short va = V_I2(&PropVal);
            short vb = V_I2(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_UI1:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            BYTE va = V_I1(&PropVal);
            BYTE vb = V_I1(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_BSTR:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }
            LPWSTR va = (LPWSTR) V_BSTR(&PropVal);
            LPWSTR vb = (LPWSTR) V_BSTR(&CompVal);

            int retCode = 0;
            BOOL bDidIt = TRUE;

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL:
                retCode = ( _wcsicmp(va,vb) == 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL:
                retCode = (_wcsicmp(va, vb) != 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN:
                retCode = (_wcsicmp(va, vb) >= 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN:
                retCode = (_wcsicmp(va, vb) <= 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_LESSTHAN:
                retCode = (_wcsicmp(va, vb) < 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN:
                retCode = (_wcsicmp(va, vb) > 0);
                break;
            case QL_LEVEL_1_TOKEN::OP_LIKE:
                retCode = (_wcsicmp(va,vb) == 0);
                break;
            default:
                bDidIt = FALSE;
                break;
            }
            VariantClear(&CompVal);
            if (bDidIt)
            {
                return retCode ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_R8:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }
            
            double va = V_R8(&PropVal);
            double vb = V_R8(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_R4:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            float va = V_R4(&PropVal);
            float vb = V_R4(&CompVal);

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: //return !(va >= vb);
                return ( va >= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: //return !(va <= vb);
                return ( va <= vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: //return !(va < vb);
                return ( va < vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: //return !(va > vb);
                return ( va > vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_LIKE: //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;

    case VT_BOOL:
        {
            if(V_VT(&PropVal) == VT_NULL)
            {
                return WBEM_E_INVALID_QUERY;
            }

            VARIANT_BOOL va = V_BOOL(&PropVal);
            if(va != VARIANT_FALSE) va = VARIANT_TRUE;
            VARIANT_BOOL vb = V_BOOL(&CompVal);
            if(vb != VARIANT_FALSE) vb = VARIANT_TRUE;

            switch (Tok.nOperator)
            {
            case QL_LEVEL_1_TOKEN::OP_EQUAL: 
                //return !(va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_NOT_EQUAL: 
                //return !(va != vb);
                return ( va != vb ) ? S_OK : S_FALSE;

            case QL_LEVEL_1_TOKEN::OP_EQUALorGREATERTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_EQUALorLESSTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_LESSTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_GREATERTHAN: 
                return WBEM_E_INVALID_QUERY;

            case QL_LEVEL_1_TOKEN::OP_LIKE: 
                //return (va == vb);
                return ( va == vb ) ? S_OK : S_FALSE;
            }
        }
        break;
    }

    return S_FALSE;
}

HRESULT GetTokenValue( SQLExpressionToken& rExprTok, 
                       IWmiObjectAccess* pAccess,
                       ULONG& rulCimType,
                       VARIANT& rvValue )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VariantInit( &rvValue );

    if ( V_VT(&rExprTok.m_vValue) == VT_EMPTY )
    {
        _DBG_ASSERT( rExprTok.m_PropName.GetNumElements() > 0 );
        
        hr = GetValue( rExprTok.m_PropName, 
                       pAccess, 
                       rulCimType,
                       &rvValue );        
    }
    else
    {
        hr = VariantCopy( &rvValue, &rExprTok.m_vValue );
        
        if ( FAILED(hr) )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }
        
        rulCimType = rExprTok.m_ulCimType;
    }
    
    return hr;
}

HRESULT EvaluateExpression( SQLAssignmentToken& rAssignTok, 
                            IWmiObjectAccess* pAccess,
                            CCimValue& rValue )
{
    CCimValue ValA, ValB, ValC, ValZero;

    HRESULT hr = S_OK;
    std::stack<CCimValue> Stack;

    try 
    {
       for( int i=0; i < rAssignTok.size(); i++ )
       {
           SQLExpressionToken& rExprTok = rAssignTok[i];
           
           if ( rExprTok.m_eTokenType == SQLExpressionToken::e_Operand )
           {                
               VARIANT vValue;
               ULONG ulCimType;

               hr = GetTokenValue( rExprTok, pAccess, ulCimType, vValue );
               
               if ( FAILED(hr) )
               {
                   return hr;
               }
               
               hr = ValA.SetValue( vValue, ulCimType );
               
               VariantClear( &vValue );

               if ( FAILED(hr) )
               {                    
                   return hr;
               }
               
               Stack.push( ValA );
               
               continue;
           }
           
           _DBG_ASSERT( !Stack.empty() );

           if ( rExprTok.m_eTokenType == SQLExpressionToken::e_UnaryMinus )
           {
               ValA = Stack.top();
               Stack.pop();
               Stack.push( ValZero - ValA );
               continue;
           }

           if ( rExprTok.m_eTokenType == SQLExpressionToken::e_UnaryPlus )
           {
               continue;
           }
           
           ValB = Stack.top();
           Stack.pop();
           _DBG_ASSERT( !Stack.empty() );
           ValA = Stack.top();
           Stack.pop();

           switch( rExprTok.m_eTokenType )
           {
           case SQLExpressionToken::e_Plus :
               ValC = ValA + ValB;
               break;

           case SQLExpressionToken::e_Minus :
               ValC = ValA - ValB;
               break;

           case SQLExpressionToken::e_Mult :
               ValC = ValA * ValB;
               break;

           case SQLExpressionToken::e_Div :
               ValC = ValA / ValB;
               break;

           case SQLExpressionToken::e_Mod :
               ValC = ValA % ValB;
               break;
           };

           Stack.push( ValC );
       }

       _DBG_ASSERT( !Stack.empty() );
       rValue = Stack.top();
       Stack.pop();
    }
    catch ( ... )
    {
        hr = DISP_E_DIVBYZERO;
    }
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\localloc.cpp ===
#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsink.h ===
#ifndef __UPDSINK_H__
#define __UPDSINK_H__

#include <assert.h>
#include <wbemcli.h>
#include <wstring.h>
#include <unk.h>
#include <comutl.h>
#include <vector>
#include <wstlallc.h>
#include <wmimsg.h>
#include "updsql.h"
#include "updscen.h"

typedef std::vector<DWORD,wbem_allocator<DWORD> > AliasOffsetVector;
typedef std::vector<CWbemPtr<IWbemClassObject>, wbem_allocator< CWbemPtr<IWbemClassObject> > > ClassObjectVector;

/***********************************************************************
  AliasInfo - structure describing alias offsets in the assign and 
  where tokens of the SQLCommand. In the case of the assign offsets, the
  first two bytes are the offset of the assign token and second two bytes are 
  the offset of the expression token.
************************************************************************/
struct AliasInfo
{
    AliasOffsetVector m_AssignOffsets;
    AliasOffsetVector m_WhereOffsets;

    void AddAssignOffset( int iAssignTok, int iExprTok )
    {
        DWORD dwOffset = iAssignTok;
        dwOffset <<= 16;
        dwOffset |= iExprTok;

        m_AssignOffsets.insert( m_AssignOffsets.end(), dwOffset );
    }
        
    void AddWhereOffset( int i )
    {
        m_WhereOffsets.insert( m_WhereOffsets.end(), i );
    }
};

/********************************************************************
  CUpdConsSink
*********************************************************************/

class CUpdConsSink : public CUnk
{
protected:

    CWbemPtr<CUpdConsSink> m_pNext;

    void* GetInterface( REFIID ) { return NULL; }

    CUpdConsSink( CUpdConsSink* pNext ) : m_pNext( pNext ) {}

public:

    CUpdConsSink* GetNext() { return m_pNext; }
    void SetNext( CUpdConsSink* pSink ) { m_pNext = pSink; }

    virtual HRESULT Execute( CUpdConsState& rState ) = 0;
    
    virtual ~CUpdConsSink() {}
};
 
/*************************************************************************
  CResolverSink - this sink fixes up the unresolved props in the sql cmd
  with the values from the data and event objects.
**************************************************************************/

class CResolverSink : public CUpdConsSink
{
    AliasInfo& m_rEventAliasInfo;
    AliasInfo& m_rDataAliasInfo;

    HRESULT ResolveAliases( IWmiObjectAccess* pAccess,
                            AliasInfo& rInfo,
                            CUpdConsState& rState );

public:

    CResolverSink( AliasInfo& rEventAliasInfo, 
                   AliasInfo& rDataAliasInfo,
                   CUpdConsSink* pNext )
    : m_rEventAliasInfo(rEventAliasInfo), 
      m_rDataAliasInfo(rDataAliasInfo),
      CUpdConsSink( pNext ) {}

    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFetchDataSink 
**************************************************************************/

class CFetchDataSink : public CUpdConsSink
{
    WString m_wsDataQuery;
    CWbemPtr<IWbemServices> m_pDataSvc;

public:

    CFetchDataSink( LPCWSTR wszDataQuery,
                    IWbemServices* pDataSvc,
                    CUpdConsSink* pNext )
    : CUpdConsSink(pNext), m_wsDataQuery(wszDataQuery), m_pDataSvc(pDataSvc){}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFetchTargetObjectsAsync
**************************************************************************/

class CFetchTargetObjectsAsync : public CUpdConsSink
{
    CWbemPtr<IWbemServices> m_pSvc;
    
public:

    CFetchTargetObjectsAsync( IWbemServices* pSvc, CUpdConsSink* pNext ) 
    : CUpdConsSink(pNext), m_pSvc(pSvc)  {}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFetchTargetObjectsSync
**************************************************************************/

class CFetchTargetObjectsSync : public CUpdConsSink
{
    CWbemPtr<IWbemServices> m_pSvc;
    
public:

    CFetchTargetObjectsSync( IWbemServices* pSvc, CUpdConsSink* pNext ) 
    : CUpdConsSink( pNext ), m_pSvc( pSvc)  {}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CNoFetchTargetObjects
**************************************************************************/

class CNoFetchTargetObjects : public CUpdConsSink
{
    CWbemPtr<IWbemClassObject> m_pClassObj;
    
public:

    CNoFetchTargetObjects( IWbemClassObject* pClassObj, CUpdConsSink* pNext ) 
    : CUpdConsSink(pNext), m_pClassObj(pClassObj)  {}
    
    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CTraceSink
**************************************************************************/
    
class CTraceSink : public CUpdConsSink
{    
    CWbemPtr<CUpdConsScenario> m_pScenario;
    CWbemPtr<IWbemClassObject> m_pTraceClass;

public:

    CTraceSink( CUpdConsScenario* pScenario,
                IWbemClassObject* pTraceClass,
                CUpdConsSink* pNext ) 
    : CUpdConsSink(pNext), m_pTraceClass(pTraceClass), m_pScenario(pScenario){}

    HRESULT Execute( CUpdConsState& rState );
};

/*************************************************************************
  CFilterSink
**************************************************************************/

class CFilterSink : public CUpdConsSink
{
public:

    CFilterSink(CUpdConsSink* pNext) : CUpdConsSink(pNext) {}

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CAssignmentSink
**************************************************************************/

class CAssignmentSink : public CUpdConsSink
{
    
    BOOL m_bTransSemantics;
    CWbemPtr<IWbemClassObject> m_pClassObj;
    SQLCommand::CommandType m_eCommandType;

    HRESULT NormalizeObject( IWbemClassObject* pObj,
                             IWbemClassObject** ppNormObj );
public:

    CAssignmentSink( BOOL bTransSemantics,
                     IWbemClassObject* pClassObj,
                     SQLCommand::CommandType eCommandType,
                     CUpdConsSink* pNext )
    : m_bTransSemantics(bTransSemantics), m_pClassObj(pClassObj),
      CUpdConsSink(pNext), m_eCommandType(eCommandType) { }

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CPutSink
**************************************************************************/

class CPutSink : public CUpdConsSink
{
    CWbemPtr<IWbemServices> m_pSvc;
    long m_lFlags;
    
public: 

    CPutSink( IWbemServices* pSvc, long lFlags, CUpdConsSink* pNext )
    : CUpdConsSink(pNext), m_pSvc(pSvc), m_lFlags(lFlags) {}

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CDeleteSink
**************************************************************************/

class CDeleteSink : public CUpdConsSink
{
    long m_lFlags;
    CWbemPtr<IWbemServices> m_pSvc;
    
public: 

    CDeleteSink( IWbemServices* pSvc, long lFlags, CUpdConsSink* pNext) 
    : CUpdConsSink(pNext), m_pSvc(pSvc), m_lFlags(lFlags) {}

    HRESULT Execute(CUpdConsState& rState);
};

/*************************************************************************
  CBranchIndicateSink
**************************************************************************/

class CBranchIndicateSink : public CUpdConsSink
{
    CWbemPtr<IWbemObjectSink> m_pSink;

public:

    CBranchIndicateSink( IWbemObjectSink* pSink, CUpdConsSink* pNext )
    : CUpdConsSink(pNext), m_pSink(pSink) { }

    HRESULT Execute( CUpdConsState& rState );
};
    
#endif // __UPDSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updstat.h ===
#ifndef __UPDSTAT_H__
#define __UPDSTAT_H__

#include <wbemcli.h>
#include <comutl.h>
#include <wmimsg.h>
#include <updsql.h>
#include <updsink.h>

/**************************************************************************
  CUpdConsState - contains all of the mutable state for execution of 
  an Updating Consumer command.  This object is passed through the sink
  chain.

  The state object can be used as an wbem object sink.  The reason for this
  is that if we had to we could support asynchronous execution of a 
  sink chain we could do so without having to allocate a new sink object
  on the heap.  This sink object would have to be allocated on the fly
  because it would need to contain the state object since it would need
  it to continue the execution of the sink chain and there is no way
  to pass the state object through the wbem interfaces.  We get around 
  this by making the state object implement IWbemObjectSink and simply
  delegating calls to the next sink in the chain.

***************************************************************************/

class CUpdConsState : public CUnkBase<IWbemObjectSink,&IID_IWbemObjectSink>
{
    //
    // an execution id generated each time the Updating Consumer executes.
    // 
    GUID m_guidExec;
    
    //
    // this is used for tracing to tell us which command is being executed
    // by the Updating Consumer. It is zero based.
    //
    int m_iCommand;
    
    //
    // Contains extra information when we wncounter errors during execution.  
    // 
    CWbemBSTR m_bsErrStr;
    
    //
    // the consumer object that the command corresponds to.  Is only 
    // used for tracing.
    // 
    CWbemPtr<IWbemClassObject> m_pCons;

    //
    // the data object used for resolving aliases in the command. 
    //
    CWbemPtr<IWbemClassObject> m_pData;
    
    //
    // the event responsible for the execution of the command.  Is used for
    // resolving aliases in the command
    //
    CWbemPtr<IWbemClassObject> m_pEvent;

    //
    // the current instance.  Always contains the most recent change
    // when used by assignment sink. 
    //
    CWbemPtr<IWbemClassObject> m_pInst;

    //
    // the original instance. This is the instance before any
    // modifications were performed on it.
    // 
    CWbemPtr<IWbemClassObject> m_pOrigInst;

    //
    // efficient object accessors for data, event, and inst objects.
    // 
    CWbemPtr<IWmiObjectAccess> m_pEventAccess;
    CWbemPtr<IWmiObjectAccess> m_pDataAccess;
    CWbemPtr<IWmiObjectAccess> m_pInstAccess;
    CWbemPtr<IWmiObjectAccess> m_pOrigInstAccess;
    
    //
    // the parsed uql query.  It is updated as we resolve aliases.
    //

    BOOL m_bOwnCmd;
    SQLCommand* m_pCmd;
    
    //
    // Only used when the State object is used as a sink.  Each time 
    // Indicate() is called on the State object, Execute() will be called 
    // on the next sink.
    //
    CWbemPtr<CUpdConsSink> m_pNext;

public:

    CUpdConsState();
    CUpdConsState( const CUpdConsState& );
    CUpdConsState& operator= ( const CUpdConsState& );
 
    GUID& GetExecutionId() { return m_guidExec; }
    void SetExecutionId( GUID& rguidExec ) { m_guidExec = rguidExec; }

    int GetCommandIndex() { return m_iCommand; }
    void SetCommandIndex( int iCommand ) { m_iCommand = iCommand; }

    BSTR GetErrStr() { return m_bsErrStr; }
    void SetErrStr( LPCWSTR wszErrStr ) { m_bsErrStr = wszErrStr; }

    IWbemClassObject* GetCons() { return m_pCons; }
    void SetCons( IWbemClassObject* pCons ) { m_pCons = pCons; }

    IWbemClassObject* GetEvent() { return m_pEvent; }
    HRESULT SetEvent( IWbemClassObject* pEvent );

    IWbemClassObject* GetData() { return m_pData; }
    HRESULT SetData( IWbemClassObject* pData );

    IWbemClassObject* GetInst() { return m_pInst; }
    HRESULT SetInst( IWbemClassObject* pInst );

    IWbemClassObject* GetOrigInst() { return m_pOrigInst; }
    HRESULT SetOrigInst( IWbemClassObject* pOrigInst );

    IWmiObjectAccess* GetEventAccess() { return m_pEventAccess; }
    HRESULT SetEventAccess( IWmiObjectAccess* pEventAccess ); 

    IWmiObjectAccess* GetDataAccess() { return m_pDataAccess; }
    HRESULT SetDataAccess( IWmiObjectAccess* pDataAccess ); 

    IWmiObjectAccess* GetInstAccess() { return m_pInstAccess; }
    HRESULT SetInstAccess( IWmiObjectAccess* pInstAccess ); 

    IWmiObjectAccess* GetOrigInstAccess() { return m_pOrigInstAccess; }
    HRESULT SetOrigInstAccess( IWmiObjectAccess* pOrigInstAccess ); 

    CUpdConsSink* GetNext() { return m_pNext; }
    void SetNext( CUpdConsSink* pSink ) { m_pNext = pSink; }
    
    SQLCommand* GetSqlCmd() { return m_pCmd; }

    void SetSqlCmd( SQLCommand* pCmd, BOOL bAssumeOwnership )
    {
        if ( m_bOwnCmd )
        {
            delete m_pCmd;
        }
        m_pCmd = pCmd;
        m_bOwnCmd = bAssumeOwnership;
    }

    STDMETHOD(Indicate)( long cObjs, IWbemClassObject** ppObjs );
    STDMETHOD(SetStatus)( long, HRESULT, BSTR, IWbemClassObject* );
 
    HRESULT SetStateOnTraceObject( IWbemClassObject* pTraceObj, HRESULT hr );
};

#endif __UPDSTAT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsql.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <qllex.h>
#include <wstring.h>
#include <genutils.h>
#include <corex.h>
#include <wbemutil.h>
#include "updsql.h"

typedef SQLCommand* PCOMMAND;
LexEl Ql_1_ModifiedLexTable[];

inline void CSQLParser::SetNewAssignmentToken()
{
    SQLAssignmentTokenList& rTokens = PCOMMAND(m_pSink)->m_AssignmentTokens;
    rTokens.insert( rTokens.end() );
    m_pCurrAssignmentToken = &rTokens.back();
}

inline void CSQLParser::AddExpressionToken(SQLExpressionToken::TokenType eType)
{
    _DBG_ASSERT( m_pCurrAssignmentToken != NULL );
    m_pCurrAssignmentToken->insert( m_pCurrAssignmentToken->end() ); 
    
    SQLExpressionToken& rExprTok = m_pCurrAssignmentToken->back();
    
    rExprTok.m_eTokenType = eType;
    
    if ( eType != SQLExpressionToken::e_Operand )
    {
        return;
    }

    rExprTok.m_PropName = m_PropertyName2;
    
    if ( FAILED(VariantCopy(&rExprTok.m_vValue,&m_vTypedConst) ) )
    {
        throw CX_MemoryException();
    }

    // reset everything ... 
    VariantClear(&m_vTypedConst);
    m_PropertyName.Empty();
    m_PropertyName2.Empty();
    m_bPropComp = FALSE;
}


//***************************************************************************
//
//  Next()
//
//  Extends CAbstractQl1Parser's Next() by checking for additional keywords.
//
//***************************************************************************
BOOL CSQLParser::Next( int nFlags )
{
    BOOL bRetval = CAbstractQl1Parser::Next( nFlags );

    // check new keywords ...
    if (m_nCurrentToken == QL_1_TOK_IDENT)
    {
        if (_wcsicmp(m_pTokenText, L"update") == 0)
        {
            m_nCurrentToken = QL_1_TOK_UPDATE;
        }
        else if (_wcsicmp(m_pTokenText, L"delete") == 0)
        {
            m_nCurrentToken = QL_1_TOK_DELETE;
        }
        else if (_wcsicmp(m_pTokenText, L"insert") == 0)
        {
            m_nCurrentToken = QL_1_TOK_INSERT;
        }
        else if (_wcsicmp(m_pTokenText, L"set") == 0)
        {
            m_nCurrentToken = QL_1_TOK_SET;
        }
        else if (_wcsicmp(m_pTokenText, L"values") == 0)
        {
            m_nCurrentToken = QL_1_TOK_VALUES;
        }
        else if (_wcsicmp(m_pTokenText, L"into") == 0)
        {
            m_nCurrentToken = QL_1_TOK_INTO;
        }
    }

    return bRetval;
}

//***************************************************************************
//
// <parse> ::= SELECT <select_statement>
// <parse> ::= UPDATE <update_statement>
// <parse> ::= DELETE <delete_statement>
// <parse> ::= INSERT <insert_statement>
//
//***************************************************************************
int CSQLParser::parse2()
{
    int nRes;

    int nLastToken = m_nCurrentToken;
    m_bInAggregation = FALSE;
    
    if ( nLastToken == QL_1_TOK_SELECT )
    {
        return parse(0); // should be select_statement().
    }

    if ( nLastToken == QL_1_TOK_UPDATE )
    {
        if ( !Next() )
            return LEXICAL_ERROR;
        nRes = update_statement();
    }
    else if ( nLastToken == QL_1_TOK_DELETE )
    {
        if ( !Next() )
            return LEXICAL_ERROR;
        nRes = delete_statement();
    }
    else if ( nLastToken == QL_1_TOK_INSERT )
    {
        if ( !Next() )
            return LEXICAL_ERROR;
        nRes = insert_statement();
    }
    else
    {
        nRes = SYNTAX_ERROR;
    }

    return nRes;
}

//***************************************************************************
//
// <update_statement> ::= <class_name> SET <assign_list> <opt_where>;
//
//***************************************************************************
int CSQLParser::update_statement()
{
    int nRes;

    PCOMMAND(m_pSink)->m_eCommandType = SQLCommand::e_Update;

    // <classsname>
    // ===========
    if (nRes = class_name())
    {
        return nRes;
    }
    
    if ( m_nCurrentToken != QL_1_TOK_SET )
    {
        return SYNTAX_ERROR;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    // <assign_list>
    // ====

    // this is a hack, but it'll do for now.  I need a slightly 
    // different lexer state table for arithmetic.  Since I'm using 
    // the ql_1 parser implementation, I do not have access to the 
    // table its lexer is using, so I have to sneak in the table, use
    // the lexer for the arithmetic, and then switch it back before 
    // anyone knows - pkenny .. 

    LexEl** ppLexTbl = (LexEl**)(((char*)m_pLexer) + 
                                 sizeof(CGenLexer) - sizeof(LexEl*));
    LexEl* pOld = *ppLexTbl;
    *ppLexTbl = Ql_1_ModifiedLexTable;

    if ( nRes = assign_list() )
    {
        return nRes;
    }

    *ppLexTbl = pOld;
    
    // <opt_where>
    // ==========
    return opt_where();
}

//***************************************************************************
//
// <delete_statement> ::= FROM <class_name> <opt_where>;
// <delete_statement> ::= <class_name> <opt_where>;
//
//***************************************************************************
int CSQLParser::delete_statement()
{
    int nRes;
    
    PCOMMAND(m_pSink)->m_eCommandType = SQLCommand::e_Delete;
    
    if ( m_nCurrentToken == QL_1_TOK_FROM )
    {
        if ( !Next() )
        {
            return LEXICAL_ERROR;
        }
    }
    
    // <classsname>
    // ===========
    if ( nRes = class_name() )
    {
        return nRes;
    }

    // WHERE clause.
    // =============
    return opt_where();
}

//***************************************************************************
//
// <insert_statement> ::= INTO <class_name> <prop_spec> <value_spec>;
// <insert_statement> ::= <class_name> <prop_spec> <value_spec>;
//
//***************************************************************************
int CSQLParser::insert_statement()
{
    int nRes;

    PCOMMAND(m_pSink)->m_eCommandType = SQLCommand::e_Insert;

    if ( m_nCurrentToken == QL_1_TOK_INTO )
    {
        if ( !Next() )
        {
            return LEXICAL_ERROR;
        }
    }

    // <classsname>
    // ===========
    if (nRes = class_name())
    {
        return nRes;
    }

    // <prop_spec>
    if ( nRes = prop_spec() )
    {
        return nRes;
    }

    // this is a hack, but it'll do for now.  I need a slightly 
    // different lexer state table for arithmetic.  Since I'm using 
    // the ql_1 parser implementation, I do not have access to the 
    // table its lexer is using, so I have to sneak in the table, use
    // the lexer for the arithmetic, and then switch it back before 
    // anyone knows - pkenny .. 

    LexEl** ppLexTbl = (LexEl**)(((char*)m_pLexer) + 
                                 sizeof(CGenLexer) - sizeof(LexEl*));
    LexEl* pOld = *ppLexTbl;
    *ppLexTbl = Ql_1_ModifiedLexTable;

    // <value_spec>
    if ( nRes = value_spec() )
    {
        return nRes;
    }

    *ppLexTbl = pOld;
        
    return SUCCESS;
}

//**********************************************************************
//
// <prop_spec> ::= OPEN_PAREN <prop_list> CLOSE_PAREN
//
//**********************************************************************
int CSQLParser::prop_spec()
{
    int nRes;

    if ( m_nCurrentToken != QL_1_TOK_OPEN_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( m_nCurrentToken == QL_1_TOK_ASTERISK )
    {
        return SYNTAX_ERROR;
    }

    if ( nRes = prop_list() )
    {
        return nRes;
    }

    if ( m_nCurrentToken != QL_1_TOK_CLOSE_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return SUCCESS;
}

    
//**********************************************************************
//
// <value_spec> ::= OPEN_PAREN <value_list> CLOSE_PAREN
//
//**********************************************************************
int CSQLParser::value_spec()
{
    int nRes;

    if ( m_nCurrentToken != QL_1_TOK_OPEN_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = value_list() )
    {
        return nRes;
    }

    if ( PCOMMAND(m_pSink)->m_AssignmentTokens.size() < 
         PCOMMAND(m_pSink)->nNumberOfProperties )
    {
        // too few values specified ... 
        return SYNTAX_ERROR;
    }

    if ( m_nCurrentToken != QL_1_TOK_CLOSE_PAREN )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return SUCCESS;
}

//**********************************************************************
//
// <value_list> ::= <assign_expr> <value_list2>
//
//**********************************************************************
int CSQLParser::value_list()
{
    int nRes;

    if ( PCOMMAND(m_pSink)->m_AssignmentTokens.size() >= 
         PCOMMAND(m_pSink)->nNumberOfProperties )
    {
        // too many values specified ... 
        return SYNTAX_ERROR;
    }

    if ( nRes = assign_expr() )
    {
        return nRes;
    }
/*
    SetNewAssignmentToken();
    AddExpressionToken( SQLExpressionToken::e_Operand );
*/
    if ( nRes = value_list2() )
    {
        return nRes;
    }

    return SUCCESS;
}

//**********************************************************************
//
// <value_list2> ::= COMMA <value_list>
// <value_list2> ::= <>
//
//**********************************************************************
int CSQLParser::value_list2()
{
    if ( m_nCurrentToken != QL_1_TOK_COMMA )
    {
        return SUCCESS;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return value_list();
}

//**********************************************************************
//
// <assign_list> ::= <property_name> EQUALS <assign_expr> <assign_list2>
//
//**********************************************************************
int CSQLParser::assign_list()
{
    int nRes;

    if ( m_nCurrentToken == QL_1_TOK_ASTERISK )
    {
        return SYNTAX_ERROR;
    }

    if ( nRes = property_name() )
    {
        return nRes;
    }

    if ( m_nCurrentToken != QL_1_TOK_EQ )
    {
        return SYNTAX_ERROR;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = assign_expr() )
    {
        return nRes;
    }

    return assign_list2();
}

//**********************************************************************
//
// <assign_list2> ::= COMMA <assign_list>
// <assign_list2> ::= <>
//
//**********************************************************************
int CSQLParser::assign_list2()
{
    if ( m_nCurrentToken != QL_1_TOK_COMMA )
    {
        return SUCCESS;
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return assign_list();
}

//**************************************************************************
//
// <assign_expr> ::= NULL
// <assign_expr> ::= <add_expr>
//
//***************************************************************************
int CSQLParser::assign_expr()
{
    int nRes;

    SetNewAssignmentToken();

    if ( m_nCurrentToken == QL_1_TOK_NULL )
    {
        if ( !Next() )
        {
            return LEXICAL_ERROR;
        }
        
        V_VT(&m_vTypedConst) = VT_NULL;
        AddExpressionToken( SQLExpressionToken::e_Operand );
    }
    else
    {
        if ( nRes = add_expr() )
        {
            return SYNTAX_ERROR;
        }
    }

    return SUCCESS;
}

//***************************************************************************
//
// <add_expr> ::= <mult_expr> <add_expr2>
//
//***************************************************************************
int CSQLParser::add_expr()
{
    int nRes;
    if ( nRes = mult_expr() )
    {
        return nRes;
    }

    return add_expr2();
}

//***************************************************************************
//
// <add_expr2> ::= <PLUS> <mult_expr> <add_expr2>
// <add_expr2> ::= <MINUS> <mult_expr> <add_expr2>
// <add_expr2> ::= <>
//
//***************************************************************************
int CSQLParser::add_expr2()
{
    int nRes;

    SQLExpressionToken::TokenType eTokType;

    if ( m_nCurrentToken == QL_1_TOK_PLUS )
    {
        eTokType = SQLExpressionToken::e_Plus;
    }
    else if ( m_nCurrentToken == QL_1_TOK_MINUS )
    {
        eTokType = SQLExpressionToken::e_Minus;
    }
    else
    {
        return SUCCESS;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = mult_expr() )
    {
        return SYNTAX_ERROR;
    }

    AddExpressionToken( eTokType );

    return add_expr2();
}


//***************************************************************************
//
// <mult_expr> ::= <secondary_expr> <mult_expr2>
//
//***************************************************************************
int CSQLParser::mult_expr()
{
    int nRes;
    if ( nRes = secondary_expr() )
    {
        return nRes;
    }

    return mult_expr2();
}


//***************************************************************************
//
// <mult_expr2> ::= <MULT> <secondary_expr> <mult_expr2>
// <mult_expr2> ::= <DIV> <secondary_expr> <mult_expr2>
// <mult_expr2> ::= <>
//
//***************************************************************************
int CSQLParser::mult_expr2()
{
    int nRes;
    SQLExpressionToken::TokenType eTokType;

    if ( m_nCurrentToken == QL_1_TOK_MULT )
    {
        eTokType = SQLExpressionToken::e_Mult;
    }
    else if ( m_nCurrentToken == QL_1_TOK_DIV )
    {
        eTokType = SQLExpressionToken::e_Div;
    }
    else if ( m_nCurrentToken == QL_1_TOK_MOD )
    {
        eTokType = SQLExpressionToken::e_Mod;
    }
    else
    {
        return SUCCESS;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = secondary_expr() )
    {
        return SYNTAX_ERROR;
    }

    AddExpressionToken( eTokType );
    return mult_expr2();
}
        
//***************************************************************************
//
//  <secondary_expr> ::= PLUS <primary_expr> 
//  <secondary_expr> ::= MINUS <primary_expr>
//  <secondary_expr> ::= <primary_expr> 
//
//***************************************************************************
int CSQLParser::secondary_expr()
{
    int nRes;

    SQLExpressionToken::TokenType eTokType;

    if ( m_nCurrentToken == QL_1_TOK_PLUS )
    {
        eTokType = SQLExpressionToken::e_UnaryPlus;
    }
    else if ( m_nCurrentToken == QL_1_TOK_MINUS )
    {
        eTokType = SQLExpressionToken::e_UnaryMinus;
    }
    else
    {
        return primary_expr();
    }

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    if ( nRes = primary_expr() )
    {
        return nRes;
    }

    AddExpressionToken( eTokType );

    return SUCCESS;
}

//***************************************************************************
//
//  <primary_expr> ::= <trailing_const_expr>
//  <primary_expr> ::= OPEN_PAREN <add_expr> CLOSE_PAREN
//
//***************************************************************************
int CSQLParser::primary_expr()
{
    int nRes;
    if ( m_nCurrentToken != QL_1_TOK_OPEN_PAREN )
    {
        if ( nRes = trailing_const_expr() )
        {
            return nRes;
        }

        AddExpressionToken( SQLExpressionToken::e_Operand );
        return SUCCESS;
    }

    if ( !Next() ) 
    {
        return LEXICAL_ERROR;
    }
    
    if ( nRes = add_expr() ) 
    {
        return nRes;
    }
    
    if ( m_nCurrentToken != QL_1_TOK_CLOSE_PAREN )
    {
        return SYNTAX_ERROR;
    }
    
    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }
    
    return SUCCESS;
}


int CSQLParser::GetClassName( LPWSTR pDestBuf, int nBufLen )
{
    m_nCurrentToken = m_pLexer->NextToken();

    if (m_nCurrentToken != QL_1_TOK_IDENT)
    {
        m_pLexer->Reset();
        return FAILED;
    }

    if ( _wcsicmp( m_pLexer->GetTokenText(), L"delete" ) == 0 )
    {
        m_nCurrentToken = m_pLexer->NextToken();
        
        if ( m_nCurrentToken == QL_1_TOK_IDENT &&
            _wcsicmp( m_pLexer->GetTokenText(), L"from" ) == 0 )
        {
            m_nCurrentToken = m_pLexer->NextToken();
        }
    }
    else if ( _wcsicmp( m_pLexer->GetTokenText(), L"insert" ) == 0 )
    {
        m_nCurrentToken = m_pLexer->NextToken();
        
        if ( m_nCurrentToken == QL_1_TOK_IDENT && 
            _wcsicmp( m_pLexer->GetTokenText(), L"into" ) == 0 )
        {
            m_nCurrentToken = m_pLexer->NextToken();
        }
    }
    else if ( _wcsicmp( m_pLexer->GetTokenText(), L"select" ) == 0 )
    {
        // scan until from ... 
        // Scan until 'FROM' and then get the class name.
        // ==============================================

        for (;;)
        {
            m_nCurrentToken = m_pLexer->NextToken();

            if (m_nCurrentToken == QL_1_TOK_EOF)
            {
                m_pLexer->Reset();
                return FAILED;
            }

            if (m_nCurrentToken == QL_1_TOK_IDENT)
            {
                if (_wcsicmp(m_pLexer->GetTokenText(),L"from") == 0 )
                {
                    break;
                }
            }
        }

        m_nCurrentToken = m_pLexer->NextToken();
    }
    else if ( _wcsicmp( m_pLexer->GetTokenText(), L"update" ) == 0 )
    {
        m_nCurrentToken = m_pLexer->NextToken();
    }
    else 
    {
        m_pLexer->Reset();
        return FAILED;
    }

    if ( m_nCurrentToken != QL_1_TOK_IDENT )
    {
        m_pLexer->Reset();
        return FAILED;
    }

    // If here, we have the class name.
    // ================================
    if (wcslen(m_pLexer->GetTokenText()) >= (size_t)nBufLen )
    {
        m_pLexer->Reset();
        return BUFFER_TOO_SMALL;
    }

    wcscpy(pDestBuf, m_pLexer->GetTokenText());

    // Reset the scanner.
    // ==================
    m_pLexer->Reset();

    return SUCCESS;
}

CSQLParser::CSQLParser( CGenLexSource& rSrc )
: CAbstractQl1Parser( &rSrc ) 
{

} 

CSQLParser::~CSQLParser( )
{

}

int CSQLParser::Parse( SQLCommand& rCommand )
{
    m_pSink = &rCommand;

    if ( !Next() )
    {
        return LEXICAL_ERROR;
    }

    return parse2();
}

LPWSTR _GetText( SQLAssignmentToken& rToken )
{
    WString wsText;

    for( int i=0; i < rToken.size(); i++ )
    {
        SQLExpressionToken& rExprTok = rToken[i];
        LPWSTR wszTokenText = rExprTok.GetText();
        if ( wszTokenText == NULL )
            return NULL;
        wsText += wszTokenText;
        delete wszTokenText;
    }

    return wsText.UnbindPtr();
}

LPWSTR SQLCommand::GetTextEx()
{
    WString wsText;
    
    switch ( m_eCommandType )
    {
      case e_Select :
        {
            wsText += L"select ";
            if ( nNumberOfProperties > 0 )
            {
                for(int i = 0; i < nNumberOfProperties; i++)
                {
                    if(i != 0) wsText += L", ";
                    wsText+=(LPWSTR)pRequestedPropertyNames[i].GetStringAt(0);
                }
            }
            else   
            {
                wsText += L"*";
            }

            wsText += L" from ";
            wsText += bsClassName;
        }
        break;

      case e_Update :
        {
            wsText += L"update ";
            wsText += bsClassName;
            wsText += L" set ";
            
            for(int i = 0; i < nNumberOfProperties; i++)
            {
                if ( i != 0 ) wsText += L", ";
                LPWSTR wszPropName = pRequestedPropertyNames[i].GetText();
                if ( wszPropName == NULL ) 
                    return NULL;
                wsText += wszPropName;
                delete wszPropName;

                wsText += " = ";
                
                LPWSTR wszPropVal = _GetText(m_AssignmentTokens[i]);
                if ( wszPropVal == NULL )
                    return NULL;
                wsText += wszPropVal;
                delete wszPropVal;
            }
        }
        break;

      case e_Delete :
        {
            wsText += L"delete ";
            wsText += bsClassName;
        }
        break;

      case e_Insert :
        {
            wsText += L"insert ";
            wsText += bsClassName;
            wsText += L" ( ";
            
            for(int i = 0; i < nNumberOfProperties; i++)
            {
                if ( i != 0 ) wsText += L", ";
                LPWSTR wszPropName = pRequestedPropertyNames[i].GetText();
                if ( wszPropName == NULL )
                    return NULL;
                wsText += wszPropName;
                delete wszPropName;
            }

            wsText += L" ) ( ";

            for ( i=0; i < nNumberOfProperties; i++ )
            {
                if ( i != 0 ) wsText += ", ";
                LPWSTR wszPropVal = m_AssignmentTokens[i][0].GetText();
                if ( wszPropVal == NULL )
                    return NULL;
                wsText += wszPropVal;
                delete wszPropVal;
            }

            wsText += L" )";
        }
        break;
    };

    if ( nNumTokens > 0 )
    {
        wsText += L" where ";

        for(int i = 0; i < nNumTokens; i++)
        {
            QL_LEVEL_1_TOKEN& Token = pArrayOfTokens[i];
            LPWSTR wszTokenText = Token.GetText();
            if ( wszTokenText == NULL )
                return NULL;
            wsText += wszTokenText;
            delete wszTokenText;
/*
            if(Token.nTokenType == QL1_OP_EXPRESSION)
            {
                awsStack.Add(wszTokenText);
                delete [] wszTokenText;
            }
            else if(Token.nTokenType == QL1_NOT)
            {
                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                WString wsNew;
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" (";
                wsNew += wszLast;
                wsNew += L")";
                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.Add(wsNew);
            }
            else
            {
                if(awsStack.Size() < 2) return NULL;

                LPWSTR wszLast = awsStack[awsStack.Size()-1];
                LPWSTR wszPrev = awsStack[awsStack.Size()-2];

                WString wsNew;
                wsNew += L"(";
                wsNew += wszPrev;
                wsNew += L" ";
                wsNew += wszTokenText;
                delete [] wszTokenText;
                wsNew += L" ";
                wsNew += wszLast;
                wsNew += L")";

                awsStack.RemoveAt(awsStack.Size()-1); //pop
                awsStack.RemoveAt(awsStack.Size()-1); //pop

                awsStack.Add(wsNew);
            }

*/
        }

//        if(awsStack.Size() != 1) return NULL;
//        wsText += awsStack[0];
    }
         
    return wsText.UnbindPtr();
}

LPWSTR SQLExpressionToken::GetText()
{
    WString wsText;
    switch( m_eTokenType )
    {
    case SQLExpressionToken::e_Operand :
        {
            if ( V_VT(&m_vValue) == VT_EMPTY )
            {
                LPWSTR wszAlias = m_PropName.GetText();
                if ( wszAlias == NULL )
                    return NULL;
                wsText += wszAlias;
                delete wszAlias;
                return wsText.UnbindPtr();
            }

            if ( V_VT(&m_vValue) == VT_NULL )
            {
                wsText += L"NULL";
                return wsText.UnbindPtr();
            }
            
            VARIANT var;
            VariantInit( &var );

            if ( FAILED(VariantChangeType( &var, &m_vValue, NULL, VT_BSTR )) )
            {
                throw CX_MemoryException();
            }

            wsText += V_BSTR(&var);
            VariantClear( &var );
        }
        break;
        
    case SQLExpressionToken::e_Minus :
        wsText += L" - ";
        break;
        
    case SQLExpressionToken::e_Plus :
        wsText += L" + ";
        break;
        
    case SQLExpressionToken::e_UnaryMinus :
        wsText += L"|-|";
        break;
        
    case SQLExpressionToken::e_UnaryPlus :
        wsText += L"+";
        break;
        
    case SQLExpressionToken::e_Mult :
        wsText += L" * ";
        break;
        
    case SQLExpressionToken::e_Div :
        wsText += L" / ";
        break;
        
    case SQLExpressionToken::e_Mod :
        wsText += L" % ";
        break;
    };

    return wsText.UnbindPtr();
}

SQLExpressionToken::SQLExpressionToken() : m_ulCimType( CIM_EMPTY )
{
    VariantInit( &m_vValue );
}

SQLExpressionToken::~SQLExpressionToken()
{
    VariantClear( &m_vValue );
}
SQLExpressionToken::SQLExpressionToken( const SQLExpressionToken& rOther )
{
    VariantInit( &m_vValue );
    *this = rOther;
}
SQLExpressionToken& SQLExpressionToken::operator=( const SQLExpressionToken& rOther )
{
    m_ulCimType = rOther.m_ulCimType;
    m_eTokenType = rOther.m_eTokenType;
    m_PropName = rOther.m_PropName;
    
    if ( FAILED(VariantCopy( &m_vValue, (VARIANT*)&rOther.m_vValue )))
    {
        throw CX_MemoryException();
    }
    
    return *this;
}


#define ST_STRING       26
#define ST_IDENT        31
#define ST_GE           37
#define ST_LE           39
#define ST_NE           42
#define ST_NUMERIC      44
#define ST_REAL         49
#define ST_STRING2      55
#define ST_STRING_ESC   60
#define ST_STRING2_ESC  63   
#define ST_DOT          66
#define ST_NEGATIVE_NUM 68
#define ST_POSITIVE_NUM 71

// DFA State Table for QL Level 1 lexical symbols.
// ================================================

LexEl Ql_1_ModifiedLexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  0x80,  0xfffd,     ST_IDENT,    0,               GLEX_ACCEPT,

/* 4 */  L'(',   GLEX_EMPTY, 0,          QL_1_TOK_OPEN_PAREN,  GLEX_ACCEPT,
/* 5 */  L')',   GLEX_EMPTY, 0,          QL_1_TOK_CLOSE_PAREN, GLEX_ACCEPT,
/* 6 */  L'.',   GLEX_EMPTY, ST_DOT,     0,         GLEX_ACCEPT,
/* 7 */  L'*',   GLEX_EMPTY, 0,          QL_1_TOK_MULT,    GLEX_ACCEPT,
/* 8 */  L'=',   GLEX_EMPTY, 0,          QL_1_TOK_EQ,          GLEX_ACCEPT,

/* 9 */  L'>',   GLEX_EMPTY, ST_GE,      0,               GLEX_ACCEPT,
/* 10 */  L'<',  GLEX_EMPTY, ST_LE,      0,               GLEX_ACCEPT,
/* 11 */ L'0',   L'9',       ST_NUMERIC, 0,               GLEX_ACCEPT,
/* 12 */ L'"',   GLEX_EMPTY, ST_STRING,  0,               GLEX_CONSUME,
/* 13 */ L'\'',  GLEX_EMPTY, ST_STRING2, 0,               GLEX_CONSUME,
/* 14 */ L'!',   GLEX_EMPTY, ST_NE,      0,               GLEX_ACCEPT,
/* 15 */ L'-',   GLEX_EMPTY, 0,      QL_1_TOK_MINUS,               GLEX_ACCEPT,

    // Whitespace, newlines, etc.
/* 16 */ L' ',   GLEX_EMPTY, 0,          0,               GLEX_CONSUME,
/* 17 */ L'\t',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 18 */ L'\n',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME|GLEX_LINEFEED,
/* 19 */ L'\r',  GLEX_EMPTY, 0,  0,               GLEX_CONSUME,
/* 20 */ 0,      GLEX_EMPTY, 0,  QL_1_TOK_EOF,    GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 21 */ L',',   GLEX_EMPTY, 0,  QL_1_TOK_COMMA,  GLEX_ACCEPT,
/* 22 */ L'+',   GLEX_EMPTY, 0,  QL_1_TOK_PLUS,   GLEX_ACCEPT,

/* 23 */ L'/',   GLEX_EMPTY, 0,     QL_1_TOK_DIV,               GLEX_ACCEPT,
/* 24 */ L'%',   GLEX_EMPTY, 0,     QL_1_TOK_MOD,               GLEX_ACCEPT,

    // Unknown characters

/* 25 */ GLEX_ANY, GLEX_EMPTY, 0,        QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING
/* 26 */   L'\n', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 27 */   L'\r', GLEX_EMPTY, 0,  QL_1_TOK_ERROR,    GLEX_ACCEPT|GLEX_LINEFEED,
/* 28 */   L'"',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,  GLEX_CONSUME,
/* 29 */   L'\\',  GLEX_EMPTY, ST_STRING_ESC,  0,     GLEX_CONSUME,
/* 30 */   GLEX_ANY, GLEX_EMPTY, ST_STRING, 0,        GLEX_ACCEPT,
                                                      
// ST_IDENT

/* 31 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 32 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 33 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 34 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 35 */  0x80,  0xfffd,     ST_IDENT,   0,          GLEX_ACCEPT,
/* 36 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_GE
/* 37 */  L'=',   GLEX_EMPTY,  0,  QL_1_TOK_GE,  GLEX_ACCEPT,
/* 38 */  GLEX_ANY, GLEX_EMPTY,  0,       QL_1_TOK_GT,   GLEX_PUSHBACK|GLEX_RETURN,

// ST_LE
/* 39 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_LE,  GLEX_ACCEPT,
/* 40 */  L'>',   GLEX_EMPTY,      0,  QL_1_TOK_NE,  GLEX_ACCEPT,
/* 41 */  GLEX_ANY, GLEX_EMPTY,    0,  QL_1_TOK_LT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_NE
/* 42 */  L'=',   GLEX_EMPTY,      0,  QL_1_TOK_NE,     GLEX_ACCEPT,
/* 43 */  GLEX_ANY,  GLEX_EMPTY,   0,  QL_1_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,

// ST_NUMERIC
/* 44 */  L'0',   L'9',         ST_NUMERIC, 0,          GLEX_ACCEPT,
/* 45 */  L'.',   GLEX_EMPTY,   ST_REAL,    0,          GLEX_ACCEPT,
/* 46 */  L'E',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 47 */  L'e',   GLEX_EMPTY,   ST_REAL, 0,      GLEX_ACCEPT,
/* 48 */  GLEX_ANY, GLEX_EMPTY, 0,          QL_1_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

// ST_REAL
/* 49 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 50 */  L'E',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 51 */  L'e',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 52 */  L'+',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 53 */  L'-',   GLEX_EMPTY, ST_REAL, 0,      GLEX_ACCEPT,
/* 54 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_REAL, GLEX_PUSHBACK|GLEX_RETURN,

// ST_STRING2
/* 55 */   L'\n',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 56 */   L'\r',  GLEX_EMPTY, 0,  QL_1_TOK_ERROR,     GLEX_ACCEPT|GLEX_LINEFEED,
/* 57 */   L'\'',  GLEX_EMPTY, 0,  QL_1_TOK_QSTRING,   GLEX_CONSUME,
/* 58 */   L'\\',  GLEX_EMPTY, ST_STRING2_ESC,  0,      GLEX_CONSUME,
/* 59 */   GLEX_ANY, GLEX_EMPTY, ST_STRING2, 0,        GLEX_ACCEPT,

// ST_STRING_ESC
/* 60 */   L'"', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 61 */   L'\\', GLEX_EMPTY, ST_STRING, 0, GLEX_ACCEPT,
/* 62 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_STRING2_ESC
/* 63 */   L'\'', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 64 */   L'\\', GLEX_EMPTY, ST_STRING2, 0, GLEX_ACCEPT,
/* 65 */   GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_DOT
/* 66 */  L'0',   L'9',   ST_REAL, 0,          GLEX_ACCEPT,
/* 67 */  GLEX_ANY,       GLEX_EMPTY,   0,     QL_1_TOK_DOT, GLEX_PUSHBACK|GLEX_RETURN,


// ST_NEGATIVE_NUM - Strips whitespace after '-'
/* 68 */ L' ', GLEX_EMPTY, ST_NEGATIVE_NUM, 0, GLEX_CONSUME,
/* 69 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 70 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

// ST_POSITIVE_NUM - Strips whitespace after '+'
/* 71 */ L' ', GLEX_EMPTY, ST_POSITIVE_NUM, 0, GLEX_CONSUME,
/* 72 */ L'0', L'9',       ST_NUMERIC, 0, GLEX_ACCEPT,
/* 73 */ GLEX_ANY, GLEX_EMPTY, 0, QL_1_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updsql.h ===
#ifndef __SQLPARSE_H__
#define __SQLPARSE_H__

#include <stdio.h>
#include <vector>
#include <wstlallc.h>
#include "ql.h"

#define QL_1_TOK_UPDATE        140
#define QL_1_TOK_INSERT        141
#define QL_1_TOK_DELETE        142
#define QL_1_TOK_SET           143
#define QL_1_TOK_VALUES        144
#define QL_1_TOK_INTO          145
#define QL_1_TOK_PLUS          146
#define QL_1_TOK_MINUS         147
#define QL_1_TOK_MULT          148
#define QL_1_TOK_DIV           149
#define QL_1_TOK_MOD           150

struct SQLExpressionToken
{
    enum TokenType { e_Operand, 
                     e_Plus, 
                     e_Minus, 
                     e_Div, 
                     e_Mult, 
                     e_Mod, 
                     e_UnaryMinus, 
                     e_UnaryPlus } m_eTokenType;

    CPropertyName m_PropName;
    VARIANT m_vValue;
    ULONG m_ulCimType; 

    SQLExpressionToken();
    ~SQLExpressionToken();
    SQLExpressionToken( const SQLExpressionToken& );
    SQLExpressionToken& operator=( const SQLExpressionToken& );

    LPWSTR GetText();
};

typedef std::vector<SQLExpressionToken,wbem_allocator<SQLExpressionToken> > SQLExpressionTokenList;
typedef SQLExpressionTokenList SQLAssignmentToken; 
typedef std::vector<SQLAssignmentToken,wbem_allocator<SQLAssignmentToken> > SQLAssignmentTokenList;

struct SQLCommand : QL_LEVEL_1_RPN_EXPRESSION
{
    enum CommandType { e_Select, 
                       e_Update, 
                       e_Delete, 
                       e_Insert } m_eCommandType; 
    
    QL_LEVEL_1_RPN_EXPRESSION m_ConditionTokens;
    SQLAssignmentTokenList m_AssignmentTokens;
    
    LPWSTR GetTextEx();
};


class CSQLParser : public CAbstractQl1Parser
{
    virtual BOOL Next( int nFlags = ALL_KEYWORDS );

    int parse2();
   
    int update_statement();
    int delete_statement();
    int insert_statement();
   
    int prop_spec();
    int value_spec();

    int value_list();
    int value_list2();

    int assign_list();
    int assign_list2();

    int assign_expr();
    
    int add_expr();
    int add_expr2();

    int mult_expr();
    int mult_expr2();

    int secondary_expr();
    int primary_expr();

    void SetNewAssignmentToken();
    void AddExpressionToken( SQLExpressionToken::TokenType eTokenType ); 
    SQLAssignmentToken* m_pCurrAssignmentToken;

    CSQLParser( const CSQLParser& );
    CSQLParser& operator=( const CSQLParser& );

public:

    CSQLParser( CGenLexSource& rSrc );
    ~CSQLParser( );
    
    int Parse( SQLCommand& rUpdate );
    int GetClassName( LPWSTR wszClassBuff, int cSize );
};

#endif __SQLPARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\precomp.h ===
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\correlation\updprov\updstat.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include "updstat.h"

static GUID g_guidNull = {0,0,0,{0,0,0,0,0,0,0,0}};

LPCWSTR g_wszCmdIndex = L"CommandIndex";
LPCWSTR g_wszErrStr = L"ErrorStr";
LPCWSTR g_wszConsumer = L"Consumer";
LPCWSTR g_wszResult = L"StatusCode";
LPCWSTR g_wszGuid = L"ExecutionId";
LPCWSTR g_wszData = L"Data";
LPCWSTR g_wszEvent = L"Event";
LPCWSTR g_wszInstance = L"Inst";
LPCWSTR g_wszOriginalInstance = L"OriginalInst";

CUpdConsState::CUpdConsState( const CUpdConsState& rOther )
: m_pCmd(NULL), m_bOwnCmd(FALSE)
{
    *this = rOther;
}

HRESULT CUpdConsState::SetEvent( IWbemClassObject* pEvent )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pEvent = pEvent;

    if ( m_pEventAccess != NULL )
    {
        hr = m_pEventAccess->SetObject( m_pEvent );
    }

    return hr;
}

HRESULT CUpdConsState::SetEventAccess( IWmiObjectAccess* pEventAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pEventAccess = pEventAccess;

    if ( m_pEventAccess != NULL )
    {
        hr = m_pEventAccess->SetObject( m_pEvent );
    }

    return hr;
}

HRESULT CUpdConsState::SetData( IWbemClassObject* pData )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pData = pData;

    if ( m_pDataAccess != NULL )
    {
        hr = m_pDataAccess->SetObject( m_pData );
    }

    return hr;
}

HRESULT CUpdConsState::SetDataAccess( IWmiObjectAccess* pDataAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pDataAccess = pDataAccess;

    if ( m_pDataAccess != NULL )
    {
        hr = m_pDataAccess->SetObject( m_pData );
    }

    return hr;
}

HRESULT CUpdConsState::SetInst( IWbemClassObject* pInst )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pInst = pInst;

    if ( m_pInstAccess != NULL )
    {
        hr = m_pInstAccess->SetObject( m_pInst );
    }

    return hr;
}

HRESULT CUpdConsState::SetInstAccess( IWmiObjectAccess* pInstAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pInstAccess = pInstAccess;

    if ( m_pInstAccess != NULL )
    {
        hr = m_pInstAccess->SetObject( m_pInst );
    }

    return hr;
}

HRESULT CUpdConsState::SetOrigInst( IWbemClassObject* pOrigInst )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pOrigInst = pOrigInst;

    if ( m_pOrigInstAccess != NULL )
    {
        hr = m_pOrigInstAccess->SetObject( m_pOrigInst );
    }

    return hr;
}

HRESULT CUpdConsState::SetOrigInstAccess( IWmiObjectAccess* pOrigInstAccess )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    m_pOrigInstAccess = pOrigInstAccess;

    if ( m_pOrigInstAccess != NULL )
    {
        hr = m_pOrigInstAccess->SetObject( m_pOrigInst );
    }

    return hr;
}

CUpdConsState& CUpdConsState::operator= ( const CUpdConsState& rOther )
{
    m_iCommand = rOther.m_iCommand;
    m_guidExec = rOther.m_guidExec;
    m_bsErrStr = rOther.m_bsErrStr;
    m_pCons = rOther.m_pCons;
    
    m_pEvent = rOther.m_pEvent;
    m_pData = rOther.m_pData;
    m_pInst = rOther.m_pInst;
    m_pOrigInst = rOther.m_pOrigInst;
   
    m_pEventAccess = rOther.m_pEventAccess;
    m_pDataAccess = rOther.m_pDataAccess;
    m_pInstAccess = rOther.m_pInstAccess;
    m_pOrigInstAccess = rOther.m_pOrigInstAccess;
    
    if ( m_bOwnCmd )
    {
        delete m_pCmd;
    }

    m_pCmd = new SQLCommand( *rOther.m_pCmd );

    if ( m_pCmd == NULL )
    {
        throw CX_MemoryException();
    }

    m_pNext = rOther.m_pNext;

    return *this;
}

CUpdConsState::CUpdConsState() 
: m_iCommand(-1), m_pCmd(NULL), m_bOwnCmd(FALSE)
{
    memset( &m_guidExec, 0, sizeof(GUID) );
}

//
// TODO: Could optimize this to use Property handles instead of strings.
// but since we're tracing anyways - does it matter ?
// 

HRESULT CUpdConsState::SetStateOnTraceObject( IWbemClassObject* pObj,
                                                HRESULT hrStatus )
{
    HRESULT hr;
    VARIANT var;

    //
    // consumer object
    //

    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = m_pCons;

    hr = pObj->Put( g_wszConsumer, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // execution id.  may be null if we failed when initializing cons
    //

    if ( g_guidNull != m_guidExec )
    {
        WCHAR achBuff[256];
        int cch = StringFromGUID2( m_guidExec, achBuff, 256 );
        _DBG_ASSERT( cch > 0 );
        
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = achBuff;
    
        hr = pObj->Put( g_wszGuid, 0, &var, NULL );
    
        if ( FAILED(hr) )
        {
            return hr;
        }
    }   

    //
    // error string. only use it when status specifies failure.
    // 

    if ( (!(!m_bsErrStr)) && FAILED(hrStatus) )
    {
        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = m_bsErrStr;
        
        hr = pObj->Put( g_wszErrStr, 0, &var, NULL );
   
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // command index - zero based.  will be -1 if trace event isn't 
    // specific to a particular command ( e.g overall success )
    //

    if ( m_iCommand != -1 )
    {
        V_VT(&var) = VT_I4;
        V_I4(&var) = m_iCommand;
        
        hr = pObj->Put( g_wszCmdIndex, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Status Code
    //

    V_VT(&var) = VT_I4;
    V_I4(&var) = hrStatus;

    hr = pObj->Put( g_wszResult, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // the event that triggered the updating consumer.
    // 

    if ( m_pEvent != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pEvent;
        
        hr = pObj->Put( g_wszEvent, 0, &var, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // we've set all the base properties.  now try to set the command 
    // trace and instance event properties.  This may fail depending on
    // the type of event class.  
    //

    if ( m_pData != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pData;        
        hr = pObj->Put( g_wszData, 0, &var, NULL );
    }  

    if ( m_pInst != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pInst;
        hr = pObj->Put( g_wszInstance, 0, &var, NULL );
    }  

    if ( m_pOrigInst != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = m_pOrigInst;        
        hr = pObj->Put( g_wszOriginalInstance, 0, &var, NULL );
    }  

    return WBEM_S_NO_ERROR;
}


STDMETHODIMP CUpdConsState::Indicate( long cObjs, IWbemClassObject** ppObjs )
{
    HRESULT hr;

    if ( m_pNext == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    for( long i=0; i < cObjs; i++ )
    {
        hr = SetInst( ppObjs[i] );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = m_pNext->Execute( *this );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CUpdConsState::SetStatus( long, HRESULT, BSTR, IWbemClassObject* )
{
    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\normlnsp.cpp ===
#include "precomp.h"
#include <WbemCli.h>
#include <GenUtils.h>
#include "NormlNSp.h"

// eleiminate warning about a performance hit changing an int to a bool
#pragma warning(4:4800)

// replace all slashes and backslashes with exclamation points
// no NULL checks, blithely assuming it's already been done
void BangWhacks(LPWSTR pStr)
{
    do
        if ((*pStr == L'\\') || (*pStr == L'/'))
            *pStr = L'!';
    while (*++pStr);
}

HRESULT NormalizeNamespace(LPCWSTR pNonNormalName, LPWSTR* ppNormalName)
{
    HRESULT hr = WBEM_E_FAILED;
    
    if (pNonNormalName == NULL || (wcslen(pNonNormalName) == 0))
        return WBEM_E_INVALID_PARAMETER;

    // first used as comparison buffer, will eventually be the normalized Name
    WCHAR* pBuf = NULL;

    WCHAR computerName[MAX_COMPUTERNAME_LENGTH +1];
    WCHAR whackWhackDotWhack[] = L"\\\\.\\";
    DWORD dNameSize = MAX_COMPUTERNAME_LENGTH +1;

    bool bGotName = false;

    if (IsNT())                                  
        bGotName = GetComputerNameW(computerName, &dNameSize);
    else
    {
        char computerNameA[2*(MAX_COMPUTERNAME_LENGTH +1)];
        if (GetComputerNameA(computerNameA, &dNameSize))
            bGotName = (-1 != mbstowcs( computerName, computerNameA,  MAX_COMPUTERNAME_LENGTH +1));
    }


    if (bGotName)
    {
        // length calculated to hold:
        //      computername. pNonNormalName, two leading whacks, one separating whack
        //      a NULL terminator and one extra in case I can't count.
        if (pBuf = new WCHAR[wcslen(computerName) +wcslen(pNonNormalName) +5])
        {
            // construct prefix: "\\computername\"
            wcscpy(pBuf, L"\\\\");
            wcscat(pBuf, computerName);
            wcscat(pBuf, L"\\");

            if (0 == _wcsnicmp(pBuf, pNonNormalName, wcslen(pBuf)))
            {
                // input already contains normalized name - do it
                wcscpy(pBuf, pNonNormalName);
                hr = WBEM_S_NO_ERROR;
            }
            else if (0 == _wcsnicmp(whackWhackDotWhack, pNonNormalName, wcslen(whackWhackDotWhack)))
            {
                // input contains a relative name, replace
                WCHAR* pInterestingPart = (WCHAR*)pNonNormalName + wcslen(whackWhackDotWhack);
                wcscat(pBuf, pInterestingPart);
                hr = WBEM_S_NO_ERROR;
            }
            else if (pNonNormalName[0] != L'\\')
            {
                // probably contains a naked name "root\default"
                wcscat(pBuf, pNonNormalName);
                hr = WBEM_S_NO_ERROR;
            }
            else
                hr = WBEM_E_INVALID_PARAMETER;
        }
        else
            // buffer allocation failed
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (SUCCEEDED(hr))
        *ppNormalName = pBuf;
    else
        delete pBuf;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\normlnsp.h ===
#ifndef __NORMALIZE_NAMESPACE_COMPILED_
#define __NORMALIZE_NAMESPACE_COMPILED_

// returns "Normalized" namespace name
//  ie, eg, and to wit: it will take a name of the form "root\default"
// and return one of the form "\\MyComputer\root\default"
// allowable input:
//      root\default
//      \\.\root\default
//      \\MyServer\root\default
// anything else should result in an error
// ppNormalName is newed - callers responsibility to delete
HRESULT NormalizeNamespace(LPCWSTR pNonNormalName, LPWSTR* ppNormalName);

// replace all slashes and backslashes with exclamation points
// no NULL checks, blithely assuming it's already been done
void BangWhacks(LPWSTR pStr);

#endif // __NORMALIZE_NAMESPACE_COMPILED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\startupmutex.cpp ===
#include "precomp.h"
#include <ppDefs.h>
#include <StartupMutex.h>
#include <WbemUtil.h>

HANDLE MarshalMutex::m_hMutex = INVALID_HANDLE_VALUE;

// provider name allows us to get a different mutex for each provider
PseudoProvMutex::PseudoProvMutex(const WCHAR* pProviderName)
{
#ifdef HOWARDS_DEBUG_CODE 
    cookie = rand();
    DEBUGTRACE((LOG_ESS, "PSEU: Entering Mutex (%08X), thread: %08X [%S] \n",cookie, GetCurrentThreadId(), pProviderName));
#else
    DEBUGTRACE((LOG_ESS, "PSEU: Entering Mutex thread: %08X [%S] \n", GetCurrentThreadId(), pProviderName));
#endif

    try
    {
        WCHAR mutexName[MAX_PATH +1];

        if (pProviderName && ((wcslen(PseudoProviderDef::StartupMutexName) + wcslen(pProviderName)) < MAX_PATH))
        {
            wcscpy(mutexName, PseudoProviderDef::StartupMutexName);
            wcscat(mutexName, pProviderName);
        }
        else
            wcscpy(mutexName, PseudoProviderDef::StartupMutexName);
            
        m_hMutex = CreateMutexW(NULL, FALSE, mutexName);
        if (m_hMutex)
            while ((WAIT_OBJECT_0 +1) == MsgWaitForMultipleObjects(1, &m_hMutex, FALSE, 
                                                              INFINITE, QS_ALLINPUT))
            {
                MSG msg;
                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    DispatchMessage(&msg);
            }

    }
    catch (...)
    {
#ifdef HOWARDS_DEBUG_CODE        
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside startup mutex (%08X), thread: %08X [%S]\n", cookie, GetCurrentThreadId(), pProviderName));
#else
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside startup mutex, thread: %08X [%S]\n", GetCurrentThreadId(), pProviderName));
#endif

        throw;
    }

}

PseudoProvMutex::~PseudoProvMutex()
{
#ifdef HOWARDS_DEBUG_CODE
    DEBUGTRACE((LOG_ESS, "PSEU:  Leaving Mutex (%08X), thread: %08X\n", cookie, GetCurrentThreadId()));
#else
    DEBUGTRACE((LOG_ESS, "PSEU:  Leaving Mutex, thread: %08X\n", GetCurrentThreadId()));
#endif

    try
    {
        if (m_hMutex)
        {
            ReleaseMutex(m_hMutex);
            CloseHandle(m_hMutex);
        }
    }
    catch (...)
    {
#ifdef HOWARDS_DEBUG_CODE        
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside startup mutex dtor(%08X), thread: %08X\n", cookie, GetCurrentThreadId()));
#else
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside startup mutex dtor, thread: %08X\n", GetCurrentThreadId()));
#endif
        throw;
    }
}

MarshalMutex::MarshalMutex()
{
#ifdef HOWARDS_DEBUG_CODE 
    cookie = rand();
    DEBUGTRACE((LOG_ESS, "PSEU: Entering Mutex (%08X), thread: %08X\n",cookie, GetCurrentThreadId()));
#else
    DEBUGTRACE((LOG_ESS, "PSEU: Entering Mutex thread: %08X \n", GetCurrentThreadId()));
#endif

    try
    {               
        if (m_hMutex == INVALID_HANDLE_VALUE)
            m_hMutex = CreateMutexW(NULL, FALSE, L"PseudoProvider Marshal Mutex");

        if (m_hMutex)
        {
            // allow OLE style messages to get through
            while ((WAIT_OBJECT_0 +1) == MsgWaitForMultipleObjects(1, &m_hMutex, FALSE, 
                                                              INFINITE, QS_ALLINPUT))
            {
                MSG msg;
                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    DispatchMessage(&msg);
            }
        }
    }
    catch (...)
    {
#ifdef HOWARDS_DEBUG_CODE        
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside marshal mutex (%08X), thread: %08X\n", cookie, GetCurrentThreadId()));
#else
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside marshal mutex, thread: %08X\n", GetCurrentThreadId()));
#endif

        throw;
    }

}

MarshalMutex::~MarshalMutex()
{
#ifdef HOWARDS_DEBUG_CODE
    DEBUGTRACE((LOG_ESS, "PSEU:  Leaving Marshal Mutex (%08X), thread: %08X\n", cookie, GetCurrentThreadId()));
#else
    DEBUGTRACE((LOG_ESS, "PSEU:  Leaving Marshal Mutex, thread: %08X\n", GetCurrentThreadId()));
#endif

    try
    {
        if (m_hMutex && (m_hMutex != INVALID_HANDLE_VALUE))
            ReleaseMutex(m_hMutex);
    }
    catch (...)
    {
#ifdef HOWARDS_DEBUG_CODE        
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside marshal mutex dtor(%08X), thread: %08X\n", cookie, GetCurrentThreadId()));
#else
        ERRORTRACE((LOG_ESS, "PSEU: exception thrown inside marshal mutex dtor, thread: %08X\n", GetCurrentThreadId()));
#endif
        throw;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\startupmutex.h ===
#ifndef _STARTUP_MUTEX_COMPILED_
#define _STARTUP_MUTEX_COMPILED_

// a simple class for using the startup mutex
// shared by the pseudo provider & pseudo sink
// Mutex is acquired upon construction and released upon destruction

// TODO: 
// allow sharing the handle 'behind the scenes'
//      right now we just do a CreateMutex

class PseudoProvMutex
{
public:
    PseudoProvMutex(const WCHAR* pProviderName);
    ~PseudoProvMutex();

protected:
    HANDLE m_hMutex;

#ifdef HOWARDS_DEBUG_CODE
    int cookie;
#endif // HOWARDS_DEBUG_CODE
};

// CoMarshalInterface sometimes seems to decide
// that it is operating inside a single threaded apartment
// it then blocks.  This mutex includes a message pump
// to allow OLE style messages to get through, unblocking the blockage.
class MarshalMutex
{
public:
    MarshalMutex();
    ~MarshalMutex();

protected:
    static HANDLE m_hMutex;

#ifdef HOWARDS_DEBUG_CODE
    int cookie;
#endif // HOWARDS_DEBUG_CODE
};


#endif // #ifndef _STARTUP_MUTEX_COMPILED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\ppdefs.cpp ===
#include "precomp.h"
#include <ppDefs.h>
#include <stdio.h>  
#include <wbemcomn.h>
#include <WbemUtil.h>
#include <genUtils.h>
#include <WinntSec.h>
#include <NormlNSp.h>
#include <StartupMutex.h>

const LARGE_INTEGER BigFreakingZero = {0,0};

// internal use only - not in header
HRESULT BitzToRegistry(const WCHAR* pTopKeyName, const WCHAR* pKeyName, BYTE* pBitz, DWORD dwSize);
HRESULT BitzToRegistryNT(HKEY hTopKey, const WCHAR* pKeyName, BYTE* pBitz, DWORD dwSize);
HRESULT BitzToRegistry9X(HKEY hTopKey, const WCHAR* pKeyName, BYTE* pBitz, DWORD dwSize);
HRESULT RegistryToInterface(HKEY hKey, IUnknown** ppUnk);

void ReleaseRegistryInterfaceCommon(HKEY hKey);
void ReleaseRegistryInterfaceNT(const WCHAR* pKeyName);
void ReleaseRegistryInterface9X(const WCHAR* pKeyName);

// used to build monikers for the ROT
const WCHAR* PseudoProviderDef::SinkPrefix = L"WMIPseudoSink!";
const WCHAR* PseudoProviderDef::ProviderPrefix = L"WMIPseudoProvider!";

// Sink Moniker is of the form WMIPseudoSink!name\space!class!<number>
// Provider Moniker is WMIPseudoProvider!name\space!class
//      where <number> is a hex digit 0 <= number < NumbDupsAllowed
const WCHAR* PseudoProviderDef::SinkMonikerTemplate = L"WMIPseudoSink!%s!%s!%02X";
const WCHAR* PseudoProviderDef::ProviderMonikerTemplate = L"WMIPseudoProvider!%s!%s";
// for use if you've already got the mangled name
const WCHAR* PseudoProviderDef::SinkMonikerShortTemplate = L"WMIPseudoSink!%s!%02X";

// Mutex to protect the Registry entries & assumptions made therefrom
// should be used during any sequence that writes to or reads from the Registry
// basically, once one side has decided it's the first up we don't want the world changing
const WCHAR* PseudoProviderDef::StartupMutexName = L"WBEMPseudoProviderStartup";
const char* PseudoProviderDef::StartupMutexNameA =  "WBEMPseudoProviderStartup";

const WCHAR* MarshallMutexName = L"Marshall";

const WCHAR*  PseudoProviderDef::ProviderStreamName  = L"binhex";
const char*   PseudoProviderDef::ProviderStreamNameA =  "binhex";

const WCHAR* PseudoProviderDef::PsProvRegKey  = L"Software\\Microsoft\\WMIPseudoProvider";
const char*  PseudoProviderDef::PsProvRegKeyA =  "Software\\Microsoft\\WMIPseudoProvider";



WCHAR* GetProviderKey(const WCHAR* pNamespace, const WCHAR* pProvider)
{
    WCHAR *p = NULL;
    if (pNamespace && pProvider)    
        if (p = new WCHAR[  wcslen(PseudoProviderDef::ProviderMonikerTemplate)
                                 + wcslen(pNamespace)
                                 + wcslen(pProvider)])
        {
            swprintf(p, PseudoProviderDef::ProviderMonikerTemplate, pNamespace, pProvider);
            BangWhacks(p);
        }

    return p;
}

// caller may supply buffer
// caller may wish to iterate through a whole bunch of these guys
// and so the first call can allocate buffer, subsequent calls will reuse same buffer
WCHAR* GetPsinkKey(const WCHAR* pNamespace, const WCHAR* pProvider, DWORD dwIndex, WCHAR* pBuffer)
{
    WCHAR *p = NULL;
    if (pNamespace && pProvider)    
    {
        if (pBuffer)
            p = pBuffer;
        else
            p = new WCHAR[  wcslen(PseudoProviderDef::SinkMonikerTemplate)
                                 + wcslen(pNamespace)
                                 + wcslen(pProvider)
                                 + 4];
    }

    if (p)
    {     
        swprintf(p, PseudoProviderDef::SinkMonikerTemplate, pNamespace, pProvider, dwIndex);
        BangWhacks(p);
    }

    return p;
}

HRESULT BitzToRegistryNT(HKEY hTopKey, const WCHAR* pKeyName, BYTE* pBitz, DWORD dwSize)
{
    HRESULT hr = WBEM_E_FAILED;

    CNtSid sidSystem(L"System");
    CNtSid sidOwner(CNtSid::CURRENT_USER);
    CNtSid sidWorld(L"Everyone");

    CNtAce aceSystem(FULL_CONTROL, ACCESS_ALLOWED_ACE_TYPE, 0, sidSystem);
    CNtAce aceOwner(FULL_CONTROL, ACCESS_ALLOWED_ACE_TYPE, 0, sidOwner);
    CNtAce aceWorld(KEY_READ, ACCESS_ALLOWED_ACE_TYPE, 0, sidWorld);
    
    CNtAcl ackl;
    ackl.AddAce(&aceSystem);
    ackl.AddAce(&aceOwner);
    ackl.AddAce(&aceWorld);
    ackl.Resize(CNtAcl::MinimumSize);

    CNtSecurityDescriptor sd;
    sd.SetDacl(&ackl);
    sd.SetOwner(&sidOwner);

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = sd.GetPtr();
    sa.bInheritHandle = FALSE;

    // just to make sure we don't have any old ones lying around
    // with a different owner than we had imagined:
    RegDeleteKeyW(hTopKey, pKeyName);
    
    HKEY hKey;
    LONG ret;
    ret = RegCreateKeyExW(hTopKey, pKeyName, 0, NULL, REG_OPTION_VOLATILE, 
                          KEY_ALL_ACCESS, &sa, &hKey, NULL);
    if (ERROR_SUCCESS == ret)
    {
        ret =  RegSetValueExW(hKey, PseudoProviderDef::ProviderStreamName, 0, REG_BINARY, pBitz, dwSize);
        if (ERROR_SUCCESS == ret)
            hr = WBEM_S_NO_ERROR;
        else
            ERRORTRACE((LOG_ESS, "RegSetValueExW failed, 0x%08X\n", ret)); 

                                      
        RegCloseKey(hKey);
    }
    else
        ERRORTRACE((LOG_ESS, "RegCreateKeyExW failed, 0x%08X\n", ret)); 


    return hr;
}

HRESULT BitzToRegistry9X(HKEY hTopKey, const WCHAR* pKeyName, BYTE* pBitz, DWORD dwSize)
{
    HRESULT hr = WBEM_E_FAILED;
    size_t kount  = 2* (wcslen(pKeyName) +1); 
    char* pKeyNameA = new char[kount];

    if (!pKeyNameA)
        hr = WBEM_E_OUT_OF_MEMORY;
    else
    {
        wcstombs(pKeyNameA, pKeyName, kount);        

        HKEY hKey;
        LONG ret;
        ret = RegCreateKeyExA(hTopKey, pKeyNameA, 0, NULL, REG_OPTION_VOLATILE, 
                              KEY_ALL_ACCESS, NULL, &hKey, NULL);
        if (ERROR_SUCCESS == ret)
        {
            ret =  RegSetValueExA(hKey, PseudoProviderDef::ProviderStreamNameA, 0, REG_BINARY, pBitz, dwSize);
            if (ERROR_SUCCESS == ret)
                hr = WBEM_S_NO_ERROR;
                                      
            RegCloseKey(hKey);
        }
    }

    return hr;
}

// helper for Register, creates reg key, puts bits into place
HRESULT BitzToRegistry(const WCHAR* pKeyName, BYTE* pBitz, DWORD dwSize)
{
    HRESULT hr = WBEM_E_FAILED;
    long lRes;

    HKEY hTopKey;        
    if (ERROR_SUCCESS != (lRes = RegCreateKeyExA(HKEY_LOCAL_MACHINE, PseudoProviderDef::PsProvRegKeyA, 0, NULL, 0, 
                         KEY_READ | KEY_CREATE_SUB_KEY, NULL, &hTopKey, NULL)))
    {
        if (lRes == 5)
            hr = WBEM_E_ACCESS_DENIED;
        else
            hr = WBEM_E_FAILED;

        ERRORTRACE((LOG_ESS, "RegCreateKeyExA failed, 0x%08X\n", lRes)); 
    }
    else
    {
        if (IsNT())
            hr = BitzToRegistryNT(hTopKey, pKeyName, pBitz, dwSize);
        else
            hr = BitzToRegistry9X(hTopKey, pKeyName, pBitz, dwSize);

        RegCloseKey(hTopKey);
    }

    return hr;
}

// TODO: upon failure, stuff bits back into stream & free marshall data...
HRESULT InterfaceToRegistry(const WCHAR* pKeyName, IUnknown* pUnk)
{
    HRESULT hr = WBEM_E_FAILED;
    
    // get a stream
    IStream* pStream = NULL;
    if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
    {
        CReleaseMe releaseStream(pStream);
        
        // marshall ptr into stream
        {
            PseudoProvMutex marsh(MarshallMutexName);
            hr = CoMarshalInterface(pStream, IID_IUnknown, pUnk, MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_TABLESTRONG);
        }

        if (SUCCEEDED(hr))
        {
            STATSTG statStg;
            if (SUCCEEDED(hr = pStream->Stat(&statStg, STATFLAG_NONAME)))
            {
                BYTE* pBitz = new BYTE[statStg.cbSize.LowPart];   

                if (!pBitz)
                    hr = WBEM_E_OUT_OF_MEMORY;
                else
                {
                    CDeleteMe<BYTE>  delBitz(pBitz);

                    // fish the gunk out of the stream & put it into the registry                    
                    pStream->Seek(BigFreakingZero, STREAM_SEEK_SET, NULL);
                    if (SUCCEEDED(hr = pStream->Read(pBitz, statStg.cbSize.LowPart, NULL)))
                        hr = BitzToRegistry(pKeyName, pBitz, statStg.cbSize.LowPart);
                }    
            }

            if (FAILED(hr))
            {
                PseudoProvMutex marsh(MarshallMutexName);
                pStream->Seek(BigFreakingZero, STREAM_SEEK_SET, NULL);
                CoReleaseMarshalData(pStream);
            }
        }
    }

    return hr;
}

void ReleaseRegistryInterfaceCommon(HKEY hKey)
{
    LONG ret;
    DWORD bufSize = 0;
    ret = RegQueryValueExA(hKey, PseudoProviderDef::ProviderStreamNameA,
                           0, NULL, NULL, &bufSize);
    if ((ERROR_MORE_DATA == ret) || (ERROR_SUCCESS == ret))
    {
        BYTE* pBitz;
        if (pBitz = new BYTE[bufSize])
        {
            CDeleteMe<BYTE> pByteMe(pBitz);
            if (ERROR_SUCCESS == RegQueryValueExA(hKey, PseudoProviderDef::ProviderStreamNameA,
                                 0, NULL, pBitz, &bufSize))
            {
                // create a stream to put the interface bits into
                IStream* pStream = NULL;
                if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
                {
                    // bits go in, pointer comes out
                    CReleaseMe releaseStream(pStream);
                    if (SUCCEEDED(pStream->Write(pBitz, bufSize, NULL)))
                    {
                        PseudoProvMutex marsh(MarshallMutexName);
                        pStream->Seek(BigFreakingZero, STREAM_SEEK_SET, NULL);                     
                        CoReleaseMarshalData(pStream);
                    }
                }
            }
        }
    }
}

void ReleaseRegistryInterfaceNT(const WCHAR* pKeyName)
{
    HKEY hTopKey;
    if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, PseudoProviderDef::PsProvRegKey, 
                                   0, KEY_READ, &hTopKey))
    {
        HKEY hKey;
        if (ERROR_SUCCESS == RegOpenKeyExW(hTopKey, pKeyName, 0, KEY_ALL_ACCESS, &hKey))
        {
            ReleaseRegistryInterfaceCommon(hKey);
            RegCloseKey(hKey);
        }

        RegDeleteKeyW(hTopKey, pKeyName);
        RegCloseKey(hTopKey);
    }
}

void ReleaseRegistryInterface9X(const WCHAR* pKeyName)
{
    size_t kount = 2* (wcslen(pKeyName) +1);
    char* pMBCSName = new char[kount];
    if (pMBCSName)
    {
        CDeleteMe<char> delName(pMBCSName);
        wcstombs(pMBCSName, pKeyName, kount);

        HKEY hTopKey;
        if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, PseudoProviderDef::PsProvRegKeyA, 
                                       0, KEY_READ, &hTopKey))
        {
            HKEY hKey;
            if (ERROR_SUCCESS == RegOpenKeyExA(hTopKey, pMBCSName, 0, KEY_ALL_ACCESS, &hKey))
            {
                ReleaseRegistryInterfaceCommon(hKey);
                RegCloseKey(hKey);
            }

            RegDeleteKeyA(hTopKey, pMBCSName);
            RegCloseKey(hTopKey);
        }
    }
}

void ReleaseRegistryInterface(const WCHAR* pKeyName)
{
    if (IsNT())
        ReleaseRegistryInterfaceNT(pKeyName);
    else
        ReleaseRegistryInterface9X(pKeyName);
}

// given an open regkey, will retrieve pointer from binary representaion of stream
// reads bytes from registry, stuffs 'em into a stream, unmarshalls pointer therefrom.
// Theoretically.
HRESULT RegistryToInterface(HKEY hKey, IUnknown** ppUnk)
{
    HRESULT hr = WBEM_E_FAILED;
    DWORD bufSize = 0;

    // call once with null buffer to determine buffer size
    LONG ret;
    ret = RegQueryValueExA(hKey, PseudoProviderDef::ProviderStreamNameA,
                           0, NULL, NULL, &bufSize);
    if ((ERROR_MORE_DATA == ret) || (ERROR_SUCCESS == ret))
    {
        BYTE* pBitz;
        if (pBitz = new BYTE[bufSize])
        {
            CDeleteMe<BYTE> pByteMe(pBitz);
            if (ERROR_SUCCESS == (ret = RegQueryValueExA(hKey, PseudoProviderDef::ProviderStreamNameA,
                                 0, NULL, pBitz, &bufSize)))
            {
                // create a stream to put the interface bits into
                IStream* pStream = NULL;
                if (SUCCEEDED(hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream)))
                {
                    // bits go in, pointer comes out
                    CReleaseMe releaseStream(pStream);
                    if (SUCCEEDED(hr = pStream->Write(pBitz, bufSize, NULL)))
                    {
                        PseudoProvMutex marsh(MarshallMutexName);
                        pStream->Seek(BigFreakingZero, STREAM_SEEK_SET, NULL);                     
                        hr = CoUnmarshalInterface(pStream, IID_IUnknown, (void**)ppUnk);
                    }
                }
            }
            else
            {
                ERRORTRACE((LOG_ESS, "FAILED RegQueryValueExA, 0x%08X\n", ret));
                // couldn't get value that exists
                hr = WBEM_E_FAILED;
            }
        }
        else
            // allocation failed
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
    {
        ERRORTRACE((LOG_ESS, "FAILED RegQueryValueExA, 0x%08X\n", ret));
        // couldn't get value info
        hr = WBEM_E_FAILED;
    }

    return hr;
}

// returns WBEM_S_FALSE if interface is not found
HRESULT RegistryToInterface(const WCHAR* pKeyName, IUnknown** ppUnk)
{
    HKEY hTopKey, hProviderKey;

    // proper return if it's not found, but we encounter no errors along the way.
    HRESULT hr = WBEM_S_FALSE;

    // it's not an error if it's not there
    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, PseudoProviderDef::PsProvRegKeyA, 
                                       0, KEY_READ, &hTopKey))
    {
        LONG ret;
        if (IsNT())
            ret = RegOpenKeyExW(hTopKey, pKeyName, 0, KEY_READ, &hProviderKey);
        else
        {
            size_t kount = 2* (wcslen(pKeyName) +1);
            char* pKeyNameA = new char[kount];

            if (pKeyNameA)
            {
                CDeleteMe<char> delAName(pKeyNameA);
                wcstombs(pKeyNameA, pKeyName, kount);
                ret = RegOpenKeyExA(hTopKey, pKeyNameA, 0, KEY_READ, &hProviderKey);
            }
            else
            {
                ret = -1;
                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }

        // again, it's not an error if it's not there
        if (ERROR_SUCCESS == ret)
        {
            hr = RegistryToInterface(hProviderKey, ppUnk);            
            RegCloseKey(hProviderKey);
        }

        RegCloseKey(hTopKey);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\ppdefs.h ===
#ifndef _PP_DEFS_COMPILED_
#define _PP_DEFS_COMPILED_

// contains definitions common to the Passive provider project

namespace PseudoProviderDef 
{
    // used to build monikers for the ROT
    extern const WCHAR* SinkPrefix;

    extern const WCHAR*  ProviderPrefix;

    // Sink Moniker is of the form WMIPseudoSink!name\space!class!<number>
    //      where <number> is a hex digit 0 <= number < NumbDupsAllowed
    // Provider Moniker is WMIPseudoProvider!name\space!class
    extern const WCHAR* SinkMonikerTemplate;
    extern const WCHAR*  ProviderMonikerTemplate;
    // for use if you've already got the mangled name
    extern const WCHAR*  SinkMonikerShortTemplate;

    // name used for the registry value the goodies are stored in
    extern const WCHAR*  ProviderStreamName;
    extern const char*   ProviderStreamNameA;

    // number of duplicate PseudoPsinks allowed
    enum {NumbDupsAllowed = 256};

    // Mutex to protect the Registry & assumptions made therefrom
    // should be used during any sequence that writes to or reads from the Registry
    // basically, once one side has decided it's the first up we don't want the world changing
    extern const WCHAR*  StartupMutexName;
    extern const char*   StartupMutexNameA;
    
    // marker for invalid index in the Sink Manager
    enum {InvalidIndex = 0xFFFFFFFF};

    extern const WCHAR*  PsProvRegKey;
    extern const char*   PsProvRegKeyA;
}

// creates proper registry key for either, caller must delete returned pointer.
WCHAR* GetProviderKey(const WCHAR* pNamespace, const WCHAR* pProvider);
// caller may supply buffer
// caller may wish to iterate through a whole bunch of these guys
// and so the first call can allocate buffer, subsequent calls will reuse same buffer
WCHAR* GetPsinkKey(const WCHAR* pNamespace, const WCHAR* pProvider, DWORD dwIndex, WCHAR* pBuffer);

HRESULT InterfaceToRegistry(const WCHAR* pKeyName, IUnknown* pUnk);

// returns WBEM_S_FALSE if interface is not found
HRESULT RegistryToInterface(const WCHAR* pKeyName, IUnknown** ppUnk);

// CoFreeMarshalData, remove registry entry
void ReleaseRegistryInterface(const WCHAR* pKeyName);

#endif // #ifndef _PP_DEFS_COMPILED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\provider\holdermgr.cpp ===
#include "precomp.h"
#include <wbemidl.h>
#include <WbemDCpl.h>
#include <DCplPriv.h>
#include <commain.h>
#include <wbemcomn.h>
#include <WbemUtil.h>
//#include <cntserv.h>
#include <genUtils.h>
#include <StartupMutex.h>
#include <WinntSec.h>
#include <NormlNSp.h>
#include "HolderMgr.h"
#include <mbstring.h> 

// the one, the only, the Sink Manager!!
CSinkHolderManager sinkManager;

CSinkHolderManager::~CSinkHolderManager()
{
    // at shutdown time, there really shouldn't be any of these left around
    // but we'll make sure...
    int nEntries = m_entries.Size();

    CEventSinkHolder* pHolder;
    for (int i = 0; (i < nEntries); i++)
    {
        pHolder =(CEventSinkHolder*)m_entries[i];
        pHolder->Release();
    }

    m_entries.Empty();
}

void CSinkHolderManager::EnumExistingPsinks9X(LPCWSTR pNamespace, LPCWSTR pName, void* pUserData, EnumCallback callback)
{
    // need one to test against
    LPWSTR pSinkKeyTemplate = GetPsinkKey(pNamespace, pName, 0, NULL);
    if (pSinkKeyTemplate)
    {
        CDeleteMe<WCHAR> delTemplate(pSinkKeyTemplate);

        char sinkKeyTemplateA[(MAX_PATH+1) *2];
        wcstombs(sinkKeyTemplateA, pSinkKeyTemplate, MAX_PATH +1);

        // only want to compare 'prefix' minus the index #
        int nCompare = _mbsrchr((const unsigned char *)&sinkKeyTemplateA, '!') -(const unsigned char *)&sinkKeyTemplateA +1;

        char sinkKeyBuffer[(MAX_PATH +1) *2];
        DWORD dwIndex = 0;
        HKEY hTopKey;

        if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, PseudoProviderDef::PsProvRegKeyA, 
                                           0, KEY_READ, &hTopKey))
        {
            while (ERROR_SUCCESS == RegEnumKeyA(hTopKey, dwIndex, sinkKeyBuffer, MAX_PATH))
            {
                if (_mbsnicmp((const unsigned char *)&sinkKeyTemplateA, (const unsigned char *)&sinkKeyBuffer, nCompare) == 0)
                {
                    IUnknown* imASink = NULL;
                    HRESULT hr;
                    
                    WCHAR sinkKeyBufferW[MAX_PATH +1];
                    mbstowcs(sinkKeyBufferW, sinkKeyBuffer, MAX_PATH+1);

                    if (SUCCEEDED(hr = RegistryToInterface(sinkKeyBufferW, &imASink)) && (hr != WBEM_S_FALSE))
                    {
                        CReleaseMe relSink(imASink);            
                        IWbemDecoupledEventSinkLocator* pLocator = NULL;                    

                        if (SUCCEEDED(imASink->QueryInterface(IID_IWbemDecoupledEventSinkLocator, (void**)&pLocator)))
                        {
                            CReleaseMe relLocator(pLocator);
                            callback(pLocator, pUserData);
                        }
                    } // if (SUCCEEDED(RegistryToInterface
                } // if stringcompare worked
                dwIndex++;
            } // while enumming
            RegCloseKey(hTopKey);
        } // if open top key
    } // if pSinkKeyTemplate
}                                     
         
void CSinkHolderManager::EnumExistingPsinksNT(LPCWSTR pNamespace, LPCWSTR pName, void* pUserData, EnumCallback callback)
{
    // need one to test against
    LPWSTR pSinkKeyTemplate = GetPsinkKey(pNamespace, pName, 0, NULL);
    if (pSinkKeyTemplate)
    {
        CDeleteMe<WCHAR> delTemplate(pSinkKeyTemplate);

        // only want to compare 'prefix' minus the index #
        int nCompare = wcsrchr(pSinkKeyTemplate, L'!' ) - pSinkKeyTemplate +1;

        WCHAR  sinkKeyBuffer[MAX_PATH + 1];
        DWORD dwIndex = 0;
        HKEY hTopKey;

        if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE, PseudoProviderDef::PsProvRegKeyA, 
                                           0, KEY_READ, &hTopKey))
        {
            while (ERROR_SUCCESS == RegEnumKeyW(hTopKey, dwIndex, sinkKeyBuffer, MAX_PATH))
            {
                if (_wcsnicmp(pSinkKeyTemplate, sinkKeyBuffer, nCompare) == 0)
                {
                    IUnknown* imASink = NULL;
                    HRESULT hr;
            
                    if (SUCCEEDED(hr = RegistryToInterface(sinkKeyBuffer, &imASink)) && (hr != WBEM_S_FALSE))
                    {
                        CReleaseMe relSink(imASink);            
                        IWbemDecoupledEventSinkLocator* pLocator = NULL;                    

                        if (SUCCEEDED(imASink->QueryInterface(IID_IWbemDecoupledEventSinkLocator, (void**)&pLocator)))
                        {
                            CReleaseMe relLocator(pLocator);
                            callback(pLocator, pUserData);
                        }
                    } // if (SUCCEEDED(RegistryToInterface
                } // if stringcompare worked
                dwIndex++;
            } // while enumming
            RegCloseKey(hTopKey);
        } // if open top key
    } // if pSinkKeyTemplate
}

// find all existing psinks, call back the callback with each one
void CSinkHolderManager::EnumExistingPsinks(LPCWSTR pNamespace, LPCWSTR pName, void* pUserData, EnumCallback callback)
{
    if (IsNT())
        EnumExistingPsinksNT(pNamespace, pName, pUserData, callback);
    else
        EnumExistingPsinks9X(pNamespace, pName, pUserData, callback);

} // function


// if provider is already up & running
// we'll let him know we're here for him
// pUserData - IUnk to pass off to provider we found
//             Should be a SinkHolder, but this function really couldn't care less
void CSinkHolderManager::ConnectCallback(IWbemDecoupledEventSinkLocator* pLocator, void* pUserData)
{
    IUnknown* iDunno = (IUnknown*)pUserData;

    iDunno->AddRef();
    pLocator->Connect(iDunno);
}

// callback for notifying all existing psinks that we're going away
// pUserData is unused: must be an eleven digit prime number.
void CSinkHolderManager::DisconnectCallback(IWbemDecoupledEventSinkLocator* pLocator, void* pUserData) 
{
   pLocator->Disconnect();
}

// add SinkHolder to list - does not addref
// also publishes availability in registry
HRESULT CSinkHolderManager::Add(CEventSinkHolder* pHolder)
{
    DEBUGTRACE((LOG_ESS, "PsProv: Adding Sink '%S'\n", pHolder->GetProviderName()));    
    HRESULT hr = WBEM_E_FAILED;

    if (pHolder)
    {
        {
            PseudoProvMutex mutex(pHolder->GetProviderName());

            IUnknown* iDunno;
            pHolder->QueryInterface(IID_IUnknown, (void**)&iDunno);

            EnumExistingPsinks(pHolder->GetNamespaceName(), pHolder->GetProviderName(), iDunno, ConnectCallback);

            iDunno->Release();

            hr = Register(pHolder);
        }

        // got all the pieces, register him
        if (SUCCEEDED(hr))
        {         
            CInCritSec lock(&m_CS);
            if (CFlexArray::no_error == m_entries.Add(pHolder))
                hr = WBEM_S_NO_ERROR;
            else
                hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}


// places sink holder into registry
HRESULT CSinkHolderManager::Register(CEventSinkHolder* pHolder)
{
    HRESULT hr = WBEM_E_FAILED;

    WCHAR* pKeyName = GetProviderKey(pHolder->GetNamespaceName(), pHolder->GetProviderName());
    if (!pKeyName)
        hr = WBEM_E_OUT_OF_MEMORY;
    else
    {
        CDeleteMe<WCHAR> delName(pKeyName);                    

        // want to publish an IUnknown
        IUnknown* iDunno;
        if (SUCCEEDED(hr = pHolder->QueryInterface(IID_IUnknown, (void**)&iDunno)))
        {
            CReleaseMe releaseDunno(iDunno);
            hr = InterfaceToRegistry(pKeyName, iDunno);
        }
    }

    return hr;
}

// remove SinkHolder from list
// remove the entry in the Registry
// let the PsuedoPsink know we're gone while we're at it
void CSinkHolderManager::Remove(CEventSinkHolder* pHolder)
{
    {
        CInCritSec lock(&m_CS);
 
        int nIndex = Find(pHolder);
    
        if (nIndex != -1)
        {
            m_entries.RemoveAt(nIndex);
            m_entries.Trim();
        }
    }
            
    PseudoProvMutex mutex(pHolder->GetProviderName());

    // Remove Registry Entry...
    LPWSTR pKeyName = GetProviderKey(pHolder->GetNamespaceName(), pHolder->GetProviderName());
    if (pKeyName)
    {
        CDeleteMe<WCHAR> dingDongDelKey(pKeyName);
        ReleaseRegistryInterface(pKeyName);
    }

    // tell any sinks out there that we're going away
    EnumExistingPsinks(pHolder->GetNamespaceName(), pHolder->GetProviderName(), NULL, DisconnectCallback);
}

// find index of holder in list - FIND, not retrieve: no addref.
// woefully inefficient, hoping that the list is short
//
// !NOTE: expects caller to obtain critical section 
// (so that they have a window in which they can addref the pointer)
//
// returns -1 if entry is not found.
int CSinkHolderManager::Find(CEventSinkHolder* pHolder)
{
    int nRet = -1;
    int nEntries = m_entries.Size();

    for (int i = 0; (i < nEntries) && (nRet == -1); i++)
        if (pHolder == (CEventSinkHolder*)m_entries[i])
            nRet = i;        

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\provider\holdermgr.h ===
#ifndef _HOLDER_MUGGER_COMPILED_ALREADY_FOOL_
#define _HOLDER_MUGGER_COMPILED_ALREADY_FOOL_

#include <Sync.h>
#include "SinkHolder.h"
#include <ppDefs.h>
#include <ArrTempl.h>
                              

// there can be only one
extern class CSinkHolderManager sinkManager;


// just like CDeleteMe, except allows setting the pointer value
template<class T>
class CChangeableDeleteMe : public CDeleteMe<T>
{
public:
    CChangeableDeleteMe(T* p = NULL) : CDeleteMe<T>(p)
    {}

    //  overwrites the previous pointer, does NOT delete it
    CChangeableDeleteMe<T>& operator = (T* p)
    {
        m_p = p;
        return *this;
    }
};

// this class exists 
//      to provide a container for the CEventSinkHolders
//      to publish them when received
//      to hand them out when asked
//      to un-publish them when removed
//
// NOTE: this class does NOT AddRef & Release the SinkHolders
//       the intent is that the class lifetime is controlled by the client
//       and that the SinkHolder will remove itself on Final Release
class CSinkHolderManager
{
public:
    /* CONSTRUCTION & DESTRUCTION */
    CSinkHolderManager() : m_entries(8) {} 
    ~CSinkHolderManager();

    /* ADD AND REMOVE */
    // add SinkHolder to list - remember no addref
    HRESULT Add(CEventSinkHolder* pHolder);
    // remove SinkHolder from list
    void Remove(CEventSinkHolder* pHolder);

    /* Enumeration callbacks */
    
    // callback function for use by EnumExistingProvider
    // Don't hold on to the pointer: release it ASAP.
    // (so that we avoid problems with holding pointers to objects that are holding pointers to us)
    typedef void (* EnumCallback)(IWbemDecoupledEventSinkLocator* pLocator, void* pUserData);


protected:
    /* CRITICAL SECTION */
    void Lock(void)     { m_CS.Enter();}
    void Unlock(void)   { m_CS.Leave();}


    /* PSEUDO PSINKS COMMUNICATION */
    
    // find all existing psinks, call the callback with each one
    void EnumExistingPsinks(LPCWSTR pNamespace, LPCWSTR pName, void* pUserData, EnumCallback callback);
    void EnumExistingPsinksNT(LPCWSTR pNamespace, LPCWSTR pName, void* pUserData, EnumCallback callback);
    void EnumExistingPsinks9X(LPCWSTR pNamespace, LPCWSTR pName, void* pUserData, EnumCallback callback);

    // if pseudo psink is already up & running
    // we'll let him know we're here for him
    void CheckForExistingPsinks(LPCWSTR pName, IRunningObjectTable* pTable, IUnknown* iDunno);

    // callback for connecting to psinks that are up & running before we are
    // pUserData is an IUnknown in this case, supposedly a ROTentry.
    static void ConnectCallback(IWbemDecoupledEventSinkLocator* pLocator, void* pUserData); 

    // callback for notifying all existing psinks that we're going away
    // pUserData is unused: must be an eleven digit prime number.
    static void DisconnectCallback(IWbemDecoupledEventSinkLocator* pLocator, void* pUserData); 

    
    /* HOLDER HOLDING */

    // locator - does not addref pointer
    // returns index of item, -1 on error;
    int Find(CEventSinkHolder* pHolder);

    /* REGISTRY COMMUNICATION */

    // places sink holder into registry
    HRESULT Register(CEventSinkHolder* pHolder);
    
    // array of all SinkHolders we've been told about
    CFlexArray m_entries;

private:
    // mostly to protect the array
    CCritSec m_CS;    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\provider\makefile.inc ===
$(O)\PseuProv.mof $(O)\PseuProv.mfl: ..\PseuProv.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\PseuProv.mof -MFL:$(O)\PseuProv.mfl ..\PseuProv.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\provider\main.cpp ===
#include "precomp.h"
#include <wbemidl.h>
#include <WbemDCpl.h>
#include <DCplPriv.h>
#include <stdio.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <time.h>
#include "SinkHolder.h"
#include "HolderMgr.h"
#include "dcplpriv_i.c"

#include <tchar.h>

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_PseudoProvider, 
            new CClassFactory<CEventSinkHolder>(GetLifeControl()), 
            _T("Pseudo Event Provider"), TRUE);
    
        return S_OK;
    }
    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\provider\sinkholder.h ===
#ifndef __SINK_HOLDER_COMPILED_ALREADY_
#define __SINK_HOLDER_COMPILED_ALREADY_

#include <unk.h>

struct ProviderInfo
{
    ProviderInfo(IUnknown *pProvider, long lFlags) : 
        m_pProvider(pProvider), m_lFlags(lFlags) {}
    
    IUnknown* m_pProvider;
    long      m_lFlags;
};

template <class TInterface, class TObject>
class CImplSharedRef : public CImpl<TInterface, TObject>
{
public:
    CImplSharedRef(long& lSharedRef, TObject* pObject) : m_lSharedRef(lSharedRef), 
                                                         CImpl<TInterface, TObject>(pObject)
    {}
    
    // per-interface refcount.  this way we can remove our pointer from the table
    // when WinMgmt is no longer interested in our services.
    STDMETHOD_(ULONG, AddRef)()
    {
        InterlockedIncrement(&m_lSharedRef);

        return m_pObject->GetUnknown()->AddRef();
    }


    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lSharedRef);

        if (lRef <= 0)
            sinkManager.Remove(m_pObject);

        return m_pObject->GetUnknown()->Release();
    }

protected:
    long& m_lSharedRef;
};

// this class is pretty much the heart of the Pseudo Provider
// it holds the sink & services pointer for the real provider 
// for whenever he decides to show himself
//
// you get one of these for each namespace/provider pair                     
// EVEN THOUGH we support multiple providers 
class CEventSinkHolder : public CUnk
{
public:
    CEventSinkHolder(CLifeControl* pControl, IUnknown* pOuter = NULL) :
        CUnk(pControl, NULL), m_lEventsRef(0), m_XProv(m_lEventsRef, this), 
        m_XInit(m_lEventsRef, this), m_XQuery(m_lEventsRef, this), m_XIdentity(m_lEventsRef, this), 
        m_XDecoupledProvider(this),  m_strProviderName(NULL), m_strNamespace(NULL),
        m_pNamespace(NULL), m_pSink(NULL), m_XSecurity(m_lEventsRef, this),
        m_XProviderLocator(this)
    {}

    ~CEventSinkHolder();

    // overrides from base class
    void* GetInterface(REFIID riid);
    virtual BOOL OnInitialize();

    // constructs name of the form namespace\class
    // returns true iff both pieces have been initialized
    // function new's name, caller's responsibility to delete it
    bool GetMangledName(LPWSTR* mangledName);

    LPCWSTR GetProviderName() 
        { return m_strProviderName; }

    LPCWSTR GetNamespaceName()
        { return m_strNamespace; }

protected:

    /** EVENT PROVIDER INTERFACES **/

    class XProv : public CImplSharedRef<IWbemEventProvider, CEventSinkHolder>
    {
    public:
        XProv(long& lSharedRef, CEventSinkHolder* pObj) : CImplSharedRef<IWbemEventProvider, CEventSinkHolder>(lSharedRef, pObj) {}

        STDMETHOD(ProvideEvents)(IWbemObjectSink* pSink, long lFlags);
    } m_XProv;
    friend XProv;

    class XInit : public CImplSharedRef<IWbemProviderInit, CEventSinkHolder>
    {
    public:
        XInit(long& lSharedRef, CEventSinkHolder* pObj) : CImplSharedRef<IWbemProviderInit, CEventSinkHolder>(lSharedRef, pObj){}

        STDMETHOD(Initialize)(LPWSTR wszUser, LONG lFlags, LPWSTR wszNamespace,
                                LPWSTR wszLocale, IWbemServices* pNamespace,
                                IWbemContext* pContext, 
                                IWbemProviderInitSink* pInitSink);
    } m_XInit;
    friend XInit;

    class XQuery : public CImplSharedRef<IWbemEventProviderQuerySink, CEventSinkHolder>
    {
    public:
        XQuery(long& lSharedRef, CEventSinkHolder* pObj) : CImplSharedRef<IWbemEventProviderQuerySink, CEventSinkHolder>(lSharedRef, pObj){}

        STDMETHOD(NewQuery)(DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery);
        STDMETHOD(CancelQuery)(DWORD dwId);
    } m_XQuery;
    friend XQuery;

    class XSecurity : public CImplSharedRef<IWbemEventProviderSecurity, CEventSinkHolder>
    {
    public:
        XSecurity(long& lSharedRef, CEventSinkHolder* pObj) : CImplSharedRef<IWbemEventProviderSecurity, CEventSinkHolder>(lSharedRef, pObj){}

        STDMETHOD(AccessCheck)(WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery,
                               long lSidLength, const BYTE __RPC_FAR *pSid);

    } m_XSecurity;
    friend XSecurity;

    class XIdentity : public CImplSharedRef<IWbemProviderIdentity, CEventSinkHolder>
    {
    public:
        XIdentity(long& lSharedRef, CEventSinkHolder* pObj) : CImplSharedRef<IWbemProviderIdentity, CEventSinkHolder>(lSharedRef, pObj){}
        STDMETHOD(SetRegistrationObject)(long lFlags, IWbemClassObject* pProvReg);

    } m_XIdentity;
    friend XIdentity;

    /** PSEUDO PROVIDER INTERFACES **/

    class XDecoupledProvider : public CImpl<IWbemDecoupledEventProvider, CEventSinkHolder>
    {
    public:
        XDecoupledProvider(CEventSinkHolder* pObj) : CImpl<IWbemDecoupledEventProvider, CEventSinkHolder>(pObj){}

        STDMETHOD(Connect)(long lFlags, IUnknown* pPseudoSink,
		                   IWbemObjectSink** ppSink, IWbemServices** ppNamespace);

        STDMETHOD(SetProviderServices)(IUnknown* pProviderServices, long lFlags, DWORD* dwID);

        STDMETHOD(Disconnect)(DWORD dwID);

    } m_XDecoupledProvider;
    friend XDecoupledProvider;


    class XProviderLocator  : public CImpl<IWbemDecoupledEventProviderLocator, CEventSinkHolder>
    {
    public:
        XProviderLocator(CEventSinkHolder* pObj) : CImpl<IWbemDecoupledEventProviderLocator, CEventSinkHolder>(pObj){}
        
        STDMETHOD(GetProvider)(IWbemDecoupledEventProvider** pDecoupledProvider);

    } m_XProviderLocator;


    HRESULT AccessCheck(PACL pDacl);
    HRESULT GetProviderDacl(BYTE** pDacl);

    // strings which identify who we are pretending to be
    LPWSTR m_strProviderName;
    LPWSTR m_strNamespace;

    // the actual object sink to winmgmt
    IWbemObjectSink* m_pSink;
    // namespace pointer provided by WinMgmt
    IWbemServices* m_pNamespace;

    // critical section to protect our array.
    CCritSec m_csArray;
    // any providers which have provided us with
    // cached as ProviderInfos.
    CFlexArray m_providerInfos;

    // refcount for the event provider interfaces
    long m_lEventsRef;
private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\sink\pseudosink.cpp ===
#include "precomp.h"
#include <wbemidl.h>
#include <stdio.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <ql.h>
#include <sync.h>
#include <time.h>
#include <WbemDCpl.h>
#include <DCplPriv.h>
#include <ppDefs.h>
#include "PseudoSink.h"
#include <StartupMutex.h>
#include <NormlNSp.h>
#include <dcplpriv_i.c>

#include <tchar.h>

const LARGE_INTEGER BigFreakingZero = {0,0};
// coupla error defines that SHOULD be in some dang header somewhere....
#define HH_RPC_E_INVALID_OXID 0x80070776
#define HH_RPC_E_SERVER_UNAVAILABLE 0x0800706BA

CPseudoPsink::~CPseudoPsink()
{
    ReleaseEveryThing();
}


/////////////////////////////////////////////////////////////////////////////
// CObjectSink

CObjectSink::CObjectSink(CPseudoPsink *pSink, BOOL bMainSink) :
    m_pPseudoSink(pSink),
    m_bMainSink(bMainSink),
    m_pSink(NULL),
    m_pBetterSink(NULL),
    m_pSD(NULL),
    m_dwSDLen(0),
    m_punkCallback(NULL),
    m_lRef(1),
    m_bSDSet(FALSE),
    m_bBatchingSet(FALSE)
{
}

CObjectSink::~CObjectSink()
{
    if (m_punkCallback)
        m_punkCallback->Release();

    FreeSD();

    FreeStrings();
}

void CObjectSink::FreeSD()
{
    if (m_pSD)
    {
        delete [] m_pSD;
        m_pSD = NULL;
        m_dwSDLen = 0;
    }
}

void CObjectSink::FreeStrings()
{
    BSTR *pStrs = (BSTR*) m_listQueries.GetArrayPtr();

    for (int i = 0; i < m_listQueries.Size(); i++)
    {
        if (pStrs[i])
        {
            SysFreeString(pStrs[i]);
            pStrs[i] = NULL;
        }
    }
}

void CObjectSink::ReleaseEverything()
{
    CInCritSec inCS(&m_CS);

    if (m_pSink) 
    {
        m_pSink->Release();
        m_pSink = NULL;
    }
    
    if (m_pBetterSink)
    {
        m_pBetterSink->Release();
        m_pBetterSink = NULL;
    }
}

STDMETHODIMP CObjectSink::QueryInterface(REFIID riid, void** ppv)
{
    if (m_bMainSink)
        return m_pPseudoSink->QueryInterface(riid, ppv);
    else
    {
        HRESULT hr;

        if (riid == IID_IUnknown || riid == IID_IWbemObjectSink || 
            riid == IID_IWbemEventSink)
        {
            *ppv = this;
            AddRef();

            hr = S_OK;
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }
}

ULONG CObjectSink::AddRef()
{
    if (m_bMainSink)
        return m_pPseudoSink->AddRef();
    else
        return InterlockedIncrement(&m_lRef);
}

ULONG CObjectSink::Release()
{
    if (m_bMainSink)
        return m_pPseudoSink->Release();
    else
    {
        long lRef = InterlockedDecrement(&m_lRef);

        // Get rid of our pointer kept in m_pPseudoSink.
        if (lRef == 1)
            m_pPseudoSink->RemoveRestrictedSink(this);
        else if (lRef == 0)
            delete this;

        return lRef;
    }
}

void* CPseudoPsink::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemObjectSink || riid == IID_IWbemEventSink)
        return &m_XCoupledSink;
    if(riid == IID_IWbemDecoupledEventSink)
        return &m_XDecoupledSink;
    if(riid == IID_IWbemDecoupledEventSinkLocator)
        return &m_XDecoupledSinkLocator;

    return NULL;
}

// if we're connected to the real sink, pass it along
HRESULT CObjectSink::Indicate(long lObjectCount, IWbemClassObject** pObjArray)
{
    DEBUGTRACE((LOG_ESS, "PsSink: Indicate\n"));
    
    HRESULT hr = WBEM_S_NO_ERROR;
    {
        CInCritSec inCS(&m_CS);

        if (m_pSink)
            hr = m_pSink->Indicate(lObjectCount, pObjArray);
        else
            hr = WBEM_S_FALSE;
    }

    // the proxy returns WBEM_S_FALSE if it's still alive but
    // WinMgmt is no longer interested in our events.  s'cool.
    // pointer test so I can remove logging from the CS
    if (m_pSink && (hr == WBEM_S_FALSE))
    {
        DEBUGTRACE((LOG_ESS, "PsSink:m_pSink->Indicate returned WBEM_S_FALSE\n"));
        hr = WBEM_S_NO_ERROR;
    }

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: Indicate FAILED, 0x%08X\n", hr));

    return hr;
}

// if we're connected to the real sink, pass it along
HRESULT CObjectSink::IndicateWithSD(long lObjectCount, 
                    IUnknown** pObjArray,
                    long lSDLength, BYTE* pSD)
{
    DEBUGTRACE((LOG_ESS, "PsSink: Indicate\n"));
    
    HRESULT hr = WBEM_S_NO_ERROR;
    {
        CInCritSec inCS(&m_CS);

        if (m_pBetterSink)
            hr = m_pBetterSink->IndicateWithSD(lObjectCount, 
                    pObjArray, lSDLength, pSD);
        else if (m_pSink)
            return WBEM_E_MARSHAL_VERSION_MISMATCH;
    }

    // the proxy returns WBEM_S_FALSE if it's still alive but
    // WinMgmt is no longer interested in our events.  s'cool.
    // pointer test so I can remove logging from the CS
    if (m_pSink && (hr == WBEM_S_FALSE))
    {
        DEBUGTRACE((LOG_ESS, "PsSink:m_pSink->Indicate returned WBEM_S_FALSE\n"));
        hr = WBEM_S_NO_ERROR;
    }

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: Indicate FAILED, 0x%08X\n", hr));

    return hr;
}

// if we're connected to the real sink, pass it along
HRESULT CObjectSink::SetStatus(long lFlags, long lParam, BSTR strParam,         
                                IWbemClassObject* pObjPAram)
{
    DEBUGTRACE((LOG_ESS, "PsSink: SetStatus\n"));
    
    HRESULT hr = WBEM_S_NO_ERROR;

    {
        CInCritSec inCS(&m_CS);

        if (m_pSink)
            hr = m_pSink->SetStatus(lFlags, lParam, strParam, pObjPAram);
    }

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: SetStatus FAILED, 0x%08X\n", hr));

    return hr;
}


HRESULT CObjectSink::IsActive()
{
    CInCritSec inCS(&m_CS);
    HRESULT    hr;

    if (m_pBetterSink)
        hr = m_pBetterSink->IsActive();
    else
        hr = WBEM_S_FALSE;

    return hr;
}

HRESULT CObjectSink::SetSinkSecurity(
                    long lSDLength, BYTE* pSD)
{
    CInCritSec inCS(&m_CS);
    HRESULT    hr = S_OK;
    
    if (m_pSD)
    {
        delete [] m_pSD;
        m_pSD = NULL;
        m_dwSDLen = 0;
    }

    if (pSD)
    {
        m_pSD = new BYTE[lSDLength];

        if (m_pSD)
        {
            m_bSDSet = TRUE;

            memcpy(m_pSD, pSD, lSDLength);
            m_dwSDLen = lSDLength;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (SUCCEEDED(hr))
    {
        if (m_pBetterSink)
            hr = m_pBetterSink->SetSinkSecurity(lSDLength, m_pSD);
    }

    return hr;
}

HRESULT CObjectSink::GetRestrictedSink(
    long nQueries, 
    const LPCWSTR* pszQueries,
    IUnknown *pCallback, 
    IWbemEventSink **ppSink)
{
    CObjectSink *pSink = new CObjectSink(m_pPseudoSink, FALSE);
    HRESULT     hr = S_OK;

    if (pSink && pSink->m_listQueries.EnsureExtent(nQueries) == 0)
    {
        pSink->m_listQueries.SetSize(nQueries);
        for (int i = 0; i < nQueries; i++)
        {
            pSink->m_listQueries[i] = SysAllocString(pszQueries[i]);
            if (!pSink->m_listQueries[i])
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }
        }
        
        if (SUCCEEDED(hr))
        {
            CInCritSec inCS(&m_pPseudoSink->m_CS);
                
            m_bBatchingSet = TRUE;

            // Save the callback.
            if (pCallback)
            {
                pSink->m_punkCallback = pCallback;
                    
                pCallback->AddRef();
            }

            // Try to get the restricted sink.
            pSink->OnConnect();

            // Save this new sink in the main object.
            m_pPseudoSink->m_listSinks.Add(pSink);
            
            // Since we're holding onto this sink, AddRef it.
            pSink->AddRef();

            *ppSink = pSink;
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    if (FAILED(hr) && pSink)
        delete pSink;

    return hr;
}
    
HRESULT CObjectSink::OnConnect()
{
    HRESULT hr = S_OK;

    // Stuff only done for restricted sinks.
    if (!m_bMainSink)
    {
        CInCritSec inMainCS(&m_pPseudoSink->m_CS);
                
        if (m_pPseudoSink->m_XCoupledSink.m_pBetterSink)
        {
            CInCritSec inSubCS(&m_CS);
            int        nQueries = m_listQueries.Size();
            BSTR       *pstrQueries = (BSTR*) m_listQueries.GetArrayPtr();

            ReleaseEverything();

            hr = 
                m_pPseudoSink->m_XCoupledSink.m_pBetterSink->GetRestrictedSink(
                    nQueries,
                    pstrQueries,
                    m_punkCallback,
                    &m_pBetterSink);

            if (m_pBetterSink)
                m_pBetterSink->QueryInterface(IID_IWbemObjectSink, (LPVOID*) &m_pSink);
        }
        else
            hr = S_OK;
    }

    // Stuff done for all sinks.
    CInCritSec inSubCS(&m_CS);

    if (m_pBetterSink)
    {
        if (m_bSDSet)
            hr = SetSinkSecurity(m_dwSDLen, m_pSD);

        if (m_bBatchingSet)
            hr = SetBatchingParameters(m_lFlags, m_dwMaxBufferSize, m_dwMaxSendLatency);
    }

    return hr;
}

HRESULT CObjectSink::SetBatchingParameters(
    LONG lFlags,
    DWORD dwMaxBufferSize, 
    DWORD dwMaxSendLatency)
{
    CInCritSec inSubCS(&m_CS);
    HRESULT    hr;

    m_bBatchingSet = TRUE;
    m_lFlags = lFlags;
    m_dwMaxBufferSize = dwMaxBufferSize;
    m_dwMaxSendLatency = dwMaxSendLatency;

    if (m_pBetterSink)
        hr = m_pBetterSink->SetBatchingParameters(
                lFlags, 
                dwMaxBufferSize, 
                dwMaxSendLatency);
    else
        hr = S_OK;
        
    return hr;
}

// pre requisite:m_strProviderName && m_strNamespace must be filled
// establishes connection with WMI, fills m_pNamespace and m_pSink
// (m_pSink may well be NULL after this call; no problem - just means no one wants our events)
HRESULT CPseudoPsink::ConnectToWMI(void)
{
    DEBUGTRACE((LOG_ESS, "PsSink: ConnectToWMI\n"));
    
    HRESULT hr = ConnectViaRegistry();
    
    if (hr == WBEM_S_FALSE)
    {
        CInCritSec inCS(&m_CS);
        IWbemLocator* pLocator;
        if (SUCCEEDED(hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_ALL, 
                                              IID_IWbemLocator, (void**)&pLocator)))
        {
            CReleaseMe releaseLocator(pLocator);

            BSTR bstr;
            bstr = SysAllocString(m_strNamespace);
            
            if (bstr)
            {
                CSysFreeMe freeBstr(bstr);
                hr = pLocator->ConnectServer(bstr,  NULL, NULL, NULL, 0, NULL, NULL, &m_pNamespace);
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;

        }
    }
    
    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: FAILED ConnectToWMI, 0x%08X\n", hr));

    return hr;
}

/*****************

  taken out when we removed ROT dependency
  leaving code in just in case

// walks through all the entries in the ROT, looking for a good one
// there may be leftovers due to crashes along the way
// pMonikerBuffer is assumed long enough
HRESULT CPseudoPsink::FindRoseAmongstThorns(WCHAR* pMonikerBuffer, IRunningObjectTable* pTable, IWbemDecoupledEventProvider*& pProvider)
{
    HRESULT hr = WBEM_E_FAILED;
    pProvider = NULL;
    int n = 0;

    do
    {
        swprintf(pMonikerBuffer, PseudoProviderDef::ProviderMonikerTemplate, PseudoProviderDef::ProviderPrefix, m_strNamespace, m_strProviderName, n);

        IMoniker* pLewinsky;
        if (SUCCEEDED(CreateItemMoniker(L"!", pMonikerBuffer, &pLewinsky)))
        {
            IUnknown* pUnk;
            CReleaseMe releaseMoniker(pLewinsky);
            if (SUCCEEDED(pTable->GetObject(pLewinsky, &pUnk)))
            {
                CReleaseMe releaseUnk(pUnk);
                IWbemDecoupledEventProviderLocator* pLocator;
                if (SUCCEEDED(hr = pUnk->QueryInterface(IID_IWbemDecoupledEventProviderLocator, (void**)&pLocator)))
                {
                    CReleaseMe releaseLocator(pLocator);
                    hr = pLocator->GetProvider(&pProvider);
                }                        
                else
                    DEBUGTRACE((LOG_ESS, "PsSink: QI for IWbemDecoupledEventProviderLocator failed, trying again\n"));
            }  // if (SUCCEEDED(pTable->GetObject                 
            // else
            //    DEBUGTRACE((LOG_ESS, "PsSink: GetObject FAILED\n"));
        }  //  if (SUCCEEDED(CreateItemMoniker
        else
            ERRORTRACE((LOG_ESS, "PsSink: CreateMoniker FAILED\n"));
    }
    while ((FAILED(hr)) && (pProvider == NULL) && (++n < PseudoProviderDef::NumbDupsAllowed));

    return hr;
}
********************************/

// looks up entry in Registry, retrieves decoupled Provider
// returned pointer is properly addref'd
// pre requisite:m_strProviderName && m_strNamespace must be filled
// expects caller to protect instance vars via CS
HRESULT CPseudoPsink::GetProvider(IWbemDecoupledEventProvider** ppProvider)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DEBUGTRACE((LOG_ESS, "PsSink: CPseudoPsink::GetProvider\n"));
    IWbemDecoupledEventProvider* pProvider = NULL;

    if (m_strProviderName && m_strNamespace)
    {
        WCHAR* pKeyString;
        if (pKeyString = GetProviderKey(m_strNamespace, m_strProviderName))
        {
            CDeleteMe<WCHAR> delStr(pKeyString);
            IUnknown* pUnk;

            if (SUCCEEDED(hr = RegistryToInterface(pKeyString, &pUnk))
                && (hr != WBEM_S_FALSE))
            {
                CReleaseMe relUnk(pUnk);
                hr = pUnk->QueryInterface(IID_IWbemDecoupledEventProvider, (void**)&pProvider);
            }
        } //if (GetProviderKey
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }
    else
        hr = WBEM_E_UNEXPECTED;

    if (SUCCEEDED(hr))
        *ppProvider = pProvider;
    // stale pointer cases - no problem.
    else if ((hr == CO_E_OBJNOTCONNECTED) || (hr == WBEM_S_FALSE) ||
             (hr == HH_RPC_E_INVALID_OXID) ||(hr == HH_RPC_E_SERVER_UNAVAILABLE) ||
             (hr == REGDB_E_CLASSNOTREG))

        hr = WBEM_S_FALSE;
    else
        ERRORTRACE((LOG_ESS, "PsSink: CPseudoPsink::GetProvider FAILED, 0x%08X\n", hr));    

    return hr;
}

// pre requisite:m_strProviderName && m_strNamespace must be filled
// looks up entry in Registry, if found initializes our pointers
// returns WBEM_S_FALSE if PseudoProvider is not in the Registry
HRESULT CPseudoPsink::ConnectViaRegistry(void)
{
    DEBUGTRACE((LOG_ESS, "PsSink: CPseudoPsink::ConnectViaRegistry\n"));
    HRESULT hr = WBEM_S_FALSE;

    CInCritSec inCS(&m_CS);

    IWbemDecoupledEventProvider* pDecoupledProvider;
    if (SUCCEEDED(hr = GetProvider(&pDecoupledProvider)) && (hr != WBEM_S_FALSE))
    {
        CReleaseMe releaseProv(pDecoupledProvider);
        hr = pDecoupledProvider->Connect(0, (IUnknown*)this, 
                &m_XCoupledSink.m_pSink, &m_pNamespace);
        if(m_XCoupledSink.m_pSink)
        {
            m_XCoupledSink.m_pSink->QueryInterface(
                IID_IWbemEventSink, (void**)&m_XCoupledSink.m_pBetterSink);

            if (m_XCoupledSink.m_pBetterSink)
                OnMainConnect();
        }
    }

    if (SUCCEEDED(hr))
        CallProvideEvents(WBEM_FLAG_START_PROVIDING);
    else
        ERRORTRACE((LOG_ESS, "PsSink: FAILED CPseudoPsink::ConnectViaRegistry, 0x%08X\n", hr));

    return hr;
}

// stash the services pointer
// check to see if provider supports security and queries
// if so, ask WinMgmt to resend items pertaining thereto
HRESULT CPseudoPsink::XDecoupledSink::SetProviderServices(IUnknown* pProviderServices, long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DEBUGTRACE((LOG_ESS, "PsSink: SetProviderServices\n"));


    // check flags first, see if we even support them    
    long badFlags = ~(WBEM_FLAG_NOTIFY_START_STOP | WBEM_FLAG_NOTIFY_QUERY_CHANGE | WBEM_FLAG_CHECK_SECURITY);
    if (lFlags & badFlags)
        hr = WBEM_E_INVALID_PARAMETER;
    else
    {
        {
            CInCritSec inCS(&m_pObject->m_CS);    
        
            m_pObject->m_providerFlags = lFlags;

            if (m_pObject->m_pRealProvider)
                m_pObject->m_pRealProvider->Release();

            m_pObject->m_pRealProvider = pProviderServices;
            if (pProviderServices)
                m_pObject->m_pRealProvider->AddRef();
        }
    
        if (pProviderServices)
        {
            bool bTellMeAboutIt = false;
        
            IWbemEventProviderQuerySink* pQuerySink;
            if (SUCCEEDED(pProviderServices->QueryInterface(IID_IWbemEventProviderQuerySink, (void**)&pQuerySink)))
            {
                pQuerySink->Release();
                bTellMeAboutIt = true;
            }

            // only check security if we didn't find the query sink
            // since we only send one message anyway
            if (!bTellMeAboutIt)
            {
                IWbemEventProviderSecurity* pSecurity;
                if (SUCCEEDED(pProviderServices->QueryInterface(IID_IWbemEventProviderSecurity, (void**)&pSecurity)))
                {
                    pSecurity->Release();
                    bTellMeAboutIt = true;            
                }
            }
                    
            IWbemDecoupledEventProvider* pProvider = NULL;
            {
                PseudoProvMutex mutex(m_pObject->GetProviderName());        
                m_pObject->GetProvider(&pProvider);
            }
        
            if (pProvider)
            {
                CReleaseMe relProv(pProvider);
                hr = pProvider->SetProviderServices(pProviderServices, lFlags, &m_pObject->m_dwIndex);
            }

            {
                CInCritSec inCS(&m_pObject->m_CS);    

                if (bTellMeAboutIt && m_pObject->m_XCoupledSink.m_pSink)
                    hr = m_pObject->m_XCoupledSink.m_pSink->SetStatus(
                            WBEM_STATUS_REQUIREMENTS, 
                            WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
                            NULL, 
                            NULL);

                if (m_pObject->m_XCoupledSink.m_pSink)
                    m_pObject->CallProvideEvents(WBEM_FLAG_START_PROVIDING);
            }
        } 
    }

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: FAILED SetProviderServices, 0x%08X\n", hr));
        
    return hr;
}

// Real provider is connecting to us, we got lotsa connecting to do here
//   gotta glue together the various sources & sinks
//   gotta connect to WinMgmt for the "real" provider
// namespace may be of form:
//      "root\default"
//      "\\.\root\default"
//      "\\machinename\root\default"
HRESULT CPseudoPsink::XDecoupledSink::Connect(LPCWSTR wszNamespace, LPCWSTR wszProviderName,
		                   long lFlags, 
		                   IWbemObjectSink** ppSink, IWbemServices** ppNamespace)
{
    HRESULT hr = WBEM_E_FAILED;
    DEBUGTRACE((LOG_ESS, "PsSink: IWbemDecoupledSink::Connect\n"));
    
    WCHAR* pNormlNamespace;
    hr = NormalizeNamespace(wszNamespace, &pNormlNamespace);
	IWbemObjectSink* pSink = NULL;

    if (SUCCEEDED(hr))
    {
        CDeleteMe<WCHAR> delName(pNormlNamespace);
        if (lFlags != 0)
            hr = WBEM_E_INVALID_PARAMETER;
        else
        {
            if (wszProviderName)
            {
                CInCritSec inCS(&m_pObject->m_CS);

                // just to make sure...
                delete m_pObject->m_strNamespace;
                delete m_pObject->m_strProviderName;

                // store strings
                if (m_pObject->m_strNamespace = new WCHAR[wcslen(pNormlNamespace) +1])
                {
                    wcscpy(m_pObject->m_strNamespace, pNormlNamespace);
                    if (m_pObject->m_strProviderName = new WCHAR[wcslen(wszProviderName) +1])
                    {
                        hr = WBEM_S_NO_ERROR;
                        wcscpy(m_pObject->m_strProviderName, wszProviderName);
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;
                }
                else
                    hr = WBEM_E_OUT_OF_MEMORY;

                {
                    PseudoProvMutex mutex(wszProviderName);        

                    if (SUCCEEDED(hr)) 
                        hr = m_pObject->LetTheWorldKnowWeExist();

                    if (SUCCEEDED(hr)
                        && (SUCCEEDED(hr = QueryInterface(IID_IWbemObjectSink, (void**)&pSink))))
							hr = m_pObject->ConnectToWMI();
                }
            } // if namespace & provider    
        }
    } // if SUCCEEDED(hr) (namespace normalization)

    if (SUCCEEDED(hr))
	{
		*ppSink = pSink;
        *ppNamespace = m_pObject->m_pNamespace;
        (*ppNamespace)->AddRef();
	}
	else
	{	
		if (pSink)
			pSink->Release();

		ERRORTRACE((LOG_ESS, "PsSink: FAILED IWbemDecoupledSink::Connect, 0x%08X\n", hr));
		Disconnect();
	}

    return hr;
}

// namespace name and provider name must be initialized prior to invocation
HRESULT CPseudoPsink::LetTheWorldKnowWeExist()
{
    DEBUGTRACE((LOG_ESS, "PsSink: CPseudoPsink::LetTheWorldKnowWeExist\n"));
    
    HRESULT hr = WBEM_S_NO_ERROR;
    bool bFound = false;
    
    IUnknown* pUnkUs = NULL;
    QueryInterface(IID_IUnknown, (void**)&pUnkUs);
    CReleaseMe releaseUs(pUnkUs);
    
    if (m_strProviderName && m_strNamespace)
    {
        // iterate through all possible Monikers, try to find an unused one
        // WARNING: Spaghetti ahead, we can jump out of this loop in the middle in case of error.
        for (DWORD i = 0; (i < PseudoProviderDef::NumbDupsAllowed) && !bFound; i++)
        {
            WCHAR* pMonikerString = NULL;

            if (pMonikerString = GetPsinkKey(m_strNamespace, m_strProviderName, i, pMonikerString))
            {
                IUnknown* pUnk = NULL;
                hr = RegistryToInterface(pMonikerString, &pUnk);
            
                // found a hole or a 'stale' pointer value
                // use stale value iff we're allowed to overwrite it (might not be (security))
                if ((hr == CO_E_OBJNOTCONNECTED) || (hr == WBEM_S_FALSE) ||
                    (hr == HH_RPC_E_INVALID_OXID) ||(hr == HH_RPC_E_SERVER_UNAVAILABLE) ||
                    (hr == REGDB_E_CLASSNOTREG))
                {
                    if (SUCCEEDED(hr = InterfaceToRegistry(pMonikerString, pUnkUs)))
                    {
                        bFound = true;
                        m_dwRegIndex = i;
                    }
                }
                else if (SUCCEEDED(hr))
                {
                    // found one in this slot - can't use it.
                    pUnk->Release();
                    pUnk = NULL;
                }
                else
                {
                    ERRORTRACE((LOG_ESS, "PsSink: FAILED CPseudoPsink::LetTheWorldKnowWeExist (RegistryToInterface), 0x%08X\n", hr));
                    delete[] pMonikerString;
                    return hr;
                }
                delete[] pMonikerString;        
            }
            else
                return WBEM_E_OUT_OF_MEMORY;

        }
    }
    if (bFound && SUCCEEDED(hr))
        hr = WBEM_S_NO_ERROR;
    else if (!bFound && SUCCEEDED(hr))
        hr = WBEM_E_ALREADY_EXISTS; // ran out of Moniker IDs

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: FAILED CPseudoPsink::LetTheWorldKnowWeExist, 0x%08X\n", hr));

    return hr;

}

void CPseudoPsink::ReleaseEveryThing()
{

    IUnknown* pRealProvider = NULL;
    DWORD dwIndex;
    {
        CInCritSec inCS(&m_CS);

/*
        if (m_pSink) 
        {
            m_pSink->Release();
            m_pSink = NULL;
        }
        if (m_pBetterSink)
        {
            m_pBetterSink->Release();
            m_pBetterSink = NULL;
        }
*/
        m_XCoupledSink.ReleaseEverything();

        if (m_pNamespace)
        {
            m_pNamespace->Release();
            m_pNamespace = NULL;
        }

        // hand off instance vars to locals
        // now the locals "own" the refcount
        pRealProvider = m_pRealProvider;
        m_pRealProvider = NULL;

        dwIndex = m_dwIndex;
        m_dwIndex = PseudoProviderDef::InvalidIndex;

    }

    if (pRealProvider)
    {
        // let the pseudo provider know we're gone
        if (dwIndex != PseudoProviderDef::InvalidIndex)
        {
            IWbemDecoupledEventProvider* pPseudoProvider = NULL;
            {
                PseudoProvMutex mutex(GetProviderName());                    
                GetProvider(&pPseudoProvider);
            }

            if (pPseudoProvider)
            {
                CReleaseMe relProv(pPseudoProvider);
                pPseudoProvider->Disconnect(dwIndex);                
            }
        }

        pRealProvider->Release();        
    }

    // end - destroy the strings
    {
        CInCritSec inCS(&m_CS);

        delete[] m_strProviderName;
        delete[] m_strNamespace;   

        m_strProviderName = NULL;
        m_strNamespace    = NULL;
    }
}

// the "real" provider is going away, or doesn't feel like providing events any more
// we can't say for certain whether he might want to talk to us again
// we need to shut down & release but be ready for reinitialization
HRESULT CPseudoPsink::XDecoupledSink::Disconnect(void)
{
    DEBUGTRACE((LOG_ESS, "PsSink: IWbemDecoupledSink::Disconnect\n"));
    HRESULT hr = WBEM_S_NO_ERROR;
        
    WCHAR* pMonikerString = NULL;
        
    if (pMonikerString = GetPsinkKey(m_pObject->GetNamespaceName(), m_pObject->GetProviderName(), m_pObject->m_dwRegIndex, NULL))
    {
        PseudoProvMutex mutex(m_pObject->GetProviderName());            
        CDeleteMe<WCHAR> delMoniker(pMonikerString);

        ReleaseRegistryInterface(pMonikerString);
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;
    
    m_pObject->ReleaseEveryThing();

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: FAILED IWbemDecoupledEventSink::Disonnect, 0x%08X\n", hr)); 
    
    return hr;    
}

// the pseudo provider has been initialized after we were alive
// letting us know that there is a call for our events
// CAVEAT: the PseudoProvider has obtained the startup mutex at this point.
HRESULT CPseudoPsink::XDecoupledSinkLocator::Connect(IUnknown __RPC_FAR *pUnknown)
{
    DEBUGTRACE((LOG_ESS, "PsSink: DecoupledSinkLocator::Connect\n"));    

    HRESULT hr = WBEM_E_FAILED;
    IWbemDecoupledEventProviderLocator* pLocator;

    if (SUCCEEDED(hr = pUnknown->QueryInterface(IID_IWbemDecoupledEventProviderLocator, (void**)&pLocator)))
    {
        CReleaseMe releaseLocator(pLocator);

        IWbemDecoupledEventProvider* pDecoupledProvider;
        if (SUCCEEDED(hr = pLocator->GetProvider(&pDecoupledProvider)))
        {
            CInCritSec inCS(&m_pObject->m_CS);
            CReleaseMe releaseProv(pDecoupledProvider);
    
/*
            if (m_pObject->m_pSink)
            {
                m_pObject->m_pSink->Release();
                m_pObject->m_pSink = NULL;
            }

            if (m_pObject->m_pBetterSink)
            {
                m_pObject->m_pBetterSink->Release();
                m_pObject->m_pBetterSink = NULL;
            }
*/
            m_pObject->m_XCoupledSink.ReleaseEverything();

            if (m_pObject->m_pNamespace)
            {
                m_pObject->m_pNamespace->Release();
                m_pObject->m_pNamespace = NULL;
            }

            IUnknown *iDunno;
            QueryInterface(IID_IUnknown, (void**)&iDunno);
            hr = 
                pDecoupledProvider->Connect(
                    0, 
                    iDunno, 
                    &m_pObject->m_XCoupledSink.m_pSink, 
                    &m_pObject->m_pNamespace);
            iDunno->Release();

            if (m_pObject->m_XCoupledSink.m_pSink)
            {
                m_pObject->m_XCoupledSink.m_pSink->QueryInterface(
                    IID_IWbemEventSink, 
                    (void**)&m_pObject->m_XCoupledSink.m_pBetterSink);

                if (m_pObject->m_XCoupledSink.m_pBetterSink)
                    m_pObject->OnMainConnect();
            }

            if (SUCCEEDED(hr)&& (m_pObject->m_pRealProvider))
            {
                pDecoupledProvider->SetProviderServices(m_pObject->m_pRealProvider, m_pObject->m_providerFlags, &m_pObject->m_dwIndex);

                m_pObject->m_XCoupledSink.m_pSink->SetStatus(
                    WBEM_STATUS_REQUIREMENTS, 
                    WBEM_REQUIREMENTS_RECHECK_SUBSCRIPTIONS, 
                    NULL, 
                    NULL);
                
                m_pObject->CallProvideEvents(WBEM_FLAG_START_PROVIDING);
            }
        }
    }                        
    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsSink: FAILED DecoupledSinkLocator::Connect, 0x%08X\n", hr));
    return hr;
}

// either WinMgmt's going away or He doesn't care about us any more.
// sink is no good from now on
HRESULT CPseudoPsink::XDecoupledSinkLocator::Disconnect(void)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DEBUGTRACE((LOG_ESS, "PsSink: DecoupledSinkLocator::Disconnect\n"));

/*
    {
        CInCritSec inCS(&m_pObject->m_CS);

        if (m_pObject->m_pSink) 
        {
            m_pObject->m_pSink->Release();
            m_pObject->m_pSink = NULL;
        }

        if (m_pObject->m_pBetterSink) 
        {
            m_pObject->m_pBetterSink->Release();
            m_pObject->m_pBetterSink = NULL;
        }
    }
*/
    m_pObject->m_XCoupledSink.ReleaseEverything();

    m_pObject->CallProvideEvents(WBEM_FLAG_STOP_PROVIDING);

    return hr;
}

// constructs name of the form namespace!provider
// returns true iff both pieces have been initialized
// function new's name, caller's responsibility to delete it
bool CPseudoPsink::GetMangledName(LPWSTR* pMangledName)
{
    bool bRet = false;

    CInCritSec inCS(&m_CS);

    if (m_strProviderName && m_strNamespace)
    {
        *pMangledName = new WCHAR[wcslen(m_strProviderName) + wcslen(m_strNamespace) + 2];
        if (*pMangledName)
        {
            bRet = true;
            wcscpy(*pMangledName, m_strNamespace);
            wcscat(*pMangledName, L"!");
            wcscat(*pMangledName, m_strProviderName);
        }
    }

    return bRet;
}


void CPseudoPsink::CallProvideEvents(long lFlags)
{
    if (m_pRealProvider && (m_providerFlags & WBEM_FLAG_NOTIFY_START_STOP))
    {
        IWbemEventProvider* pProvider;
        if (SUCCEEDED(m_pRealProvider->QueryInterface(IID_IWbemEventProvider, (void**)&pProvider)))
        {
            CReleaseMe relProv(pProvider);

            IWbemObjectSink* pSink;
            if (SUCCEEDED(QueryInterface(IID_IWbemObjectSink, (void**)&pSink)))
            {
                CReleaseMe relSink(pSink);
                pProvider->ProvideEvents(pSink, lFlags);
            }
        }
    }
}

void CPseudoPsink::RemoveRestrictedSink(CObjectSink *pSink)
{
    CInCritSec inCS(&m_CS);
    int        nSinks = m_listSinks.Size();

    CObjectSink **pSinks = (CObjectSink**) m_listSinks.GetArrayPtr();

    for (int i = 0; i < nSinks; i++)
    {
        if (pSinks[i] == pSink)
        {
            pSink->Release();
            pSinks[i] = NULL;
            break;
        }
    }

    m_listSinks.Compress();
}

// Called when we get our hands on the real IWbemEventSink.
void CPseudoPsink::OnMainConnect()
{
    CInCritSec inCS(&m_CS);
    int        nSinks = m_listSinks.Size();

    CObjectSink **pSinks = (CObjectSink**) m_listSinks.GetArrayPtr();

    for (int i = 0; i < nSinks; i++)
        pSinks[i]->OnConnect();
}

class CMyServer : public CComServer
{
public:
    HRESULT Initialize()
    {
        AddClassInfo(CLSID_PseudoSink, 
            new CClassFactory<CPseudoPsink>(GetLifeControl()), 
            _T("Pseudo Event Sink"), TRUE);
        return S_OK;
    }
    HRESULT InitializeCom()
    {
        return CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
} Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\sink\pseudosink.h ===
#ifndef __PSEUDO_PSINK_COMPILED_ALREADY__                         
#define __PSEUDO_PSINK_COMPILED_ALREADY__

class CPseudoPsink;

class CObjectSink : public IWbemEventSink
{
public:
    IWbemObjectSink *m_pSink;          // may be NULL if no one wants our objects
    IWbemEventSink  *m_pBetterSink;    // Same as m_pSink, but Whistler interface
    CCritSec        m_CS;

    CObjectSink(CPseudoPsink *pObj, BOOL bMainSink);
    ~CObjectSink();
    
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    STDMETHOD(Indicate)(long lObjectCount, IWbemClassObject** pObjArray);
    STDMETHOD(SetStatus)(long lFlags, long lParam, BSTR strParam,
        IWbemClassObject* pObjParam);
    STDMETHOD(IndicateWithSD)(long lNumObjects, IUnknown** apObjects,
        long lSDLength, BYTE* pSD);
    
    STDMETHOD(IsActive)();
    STDMETHOD(SetSinkSecurity)(long lSDLength, BYTE* pSD);
    STDMETHOD(GetRestrictedSink)(
        long lNumQueries, 
        const LPCWSTR* awszQueries,
        IUnknown* pCallback, IWbemEventSink** ppSink);
    
    STDMETHOD(SetBatchingParameters)(LONG lFlags,
        DWORD dwMaxBufferSize, DWORD dwMaxSendLatency);

    // Once we're connected for real, do stuff like getting the real sink, 
    // setting our SD, etc.
    HRESULT OnConnect();

    /* Critical Section access */
    void Lock(void)     { m_CS.Enter();}
    void Unlock(void)   { m_CS.Leave();}

    void ReleaseEverything();

protected:
    // Restricted sink properties
    CFlexArray   m_listQueries;
    IUnknown     *m_punkCallback;
    
    // SD properties
    BOOL         m_bSDSet;
    BYTE         *m_pSD;
    DWORD        m_dwSDLen;
    
    // Batching properties
    BOOL         m_bBatchingSet;
    LONG         m_lFlags;
    DWORD        m_dwMaxBufferSize,
                 m_dwMaxSendLatency;
                 
    CPseudoPsink *m_pPseudoSink;
    BOOL         m_bMainSink;
    LONG         m_lRef;

    void FreeSD();
    void FreeStrings();
};


// This is Psue the Pseudo Psink
// She pretends to be the sink for events objects that WinMgmt hasn't asked for,
// unless WinMgmt HAS asked for them, in which case she passes them along unmolested
class CPseudoPsink : public CUnk
{
public:
    CPseudoPsink(CLifeControl* pControl, IUnknown* pOuter = NULL) :
        CUnk(pControl, NULL),  m_XCoupledSink(this, TRUE),
        m_XDecoupledSink(this),  m_XDecoupledSinkLocator(this),
        m_strProviderName(NULL), m_strNamespace(NULL),
        m_pNamespace(NULL), m_pRealProvider(NULL),
        m_dwIndex(PseudoProviderDef::InvalidIndex), m_providerFlags(0),
        m_dwRegIndex(PseudoProviderDef::InvalidIndex)
    {}

    ~CPseudoPsink();

    void* GetInterface(REFIID riid);

    // constructs name of the form namespace!provider
    // returns true iff both pieces have been initialized
    // function new's name, caller's responsibility to delete it
    bool GetMangledName(LPWSTR* mangledName);

    LPCWSTR GetProviderName() 
        { return m_strProviderName; }

    LPCWSTR GetNamespaceName()
        { return m_strNamespace; }

protected:
    friend CObjectSink;

    class XDecoupledSink : public CImpl<IWbemDecoupledEventSink, CPseudoPsink>
    {
    public:
        XDecoupledSink(CPseudoPsink* pObj) : CImpl<IWbemDecoupledEventSink, CPseudoPsink>(pObj){}

        STDMETHOD(Connect)(LPCWSTR wszNamespace, LPCWSTR wszProviderName,
		                   long lFlags,
		                   IWbemObjectSink** ppSink, IWbemServices** ppNamespace);

        STDMETHOD(SetProviderServices)(IUnknown* pProviderServices, long lFlags);

        STDMETHOD(Disconnect)(void);

    } m_XDecoupledSink;
    friend XDecoupledSink;

    class XDecoupledSinkLocator : public CImpl<IWbemDecoupledEventSinkLocator, CPseudoPsink>
    {
    public:
        XDecoupledSinkLocator(CPseudoPsink* pObj) : 
            CImpl<IWbemDecoupledEventSinkLocator, CPseudoPsink>(pObj){}

        STDMETHOD(Connect)(IUnknown __RPC_FAR *pDecoupledProvider);
        
        STDMETHOD(Disconnect)(void);
        
    } m_XDecoupledSinkLocator;
    friend XDecoupledSinkLocator;

    // strings that tell us who we are
    // they must be initialized before we are useful
    LPWSTR m_strProviderName;
    LPWSTR m_strNamespace;

    IWbemServices*   m_pNamespace;     // back into MinMgmt

    IUnknown*        m_pRealProvider;  // May be NULL if provider doesn't want to implement
    DWORD            m_dwIndex;        // index returned to us by PseudoProvider
    DWORD            m_dwRegIndex;     // index of which entry we are in the registry

    CFlexArray       m_listSinks;      // List of restricted sinks.

    CObjectSink      m_XCoupledSink;   // Holds the 'real' sinks.

    // critical section to protect our member variables
    // we'll only use one: don't have many members 
    // don't expect to be called on very many threads
    CCritSec m_CS;

    long m_providerFlags; // flags passed to SetProviderServices

    /* Critical Section access */
    void Lock(void)     { m_CS.Enter();}
    void Unlock(void)   { m_CS.Leave();}

    void ReleaseEveryThing();
    HRESULT GetProvider(IWbemDecoupledEventProvider** ppProvider);

    void RemoveRestrictedSink(CObjectSink *pSink);

    // Called when we get our hands on the real IWbemEventSink.
    void OnMainConnect();

private:
    HRESULT ConnectToWMI(void);
    HRESULT ConnectViaRegistry(void);
    HRESULT LetTheWorldKnowWeExist(void);
    // HRESULT FindRoseAmongstThorns(WCHAR* pMonikerBuffer, IRunningObjectTable* pTable, IWbemDecoupledEventProvider*& pProvider);

    void CallProvideEvents(long lFlags);
};

#endif // __PSEUDO_PSINK_COMPILED_ALREADY__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\decoupled\provider\sinkholder.cpp ===
#include "precomp.h"
#include <wbemidl.h>
#include <WbemDCpl.h>
#include <DCplPriv.h>
#include <stdio.h>
#include <commain.h>
#include <clsfac.h>
#include <wbemcomn.h>
#include <WbemUtil.h>
#include <ql.h>
#include <sync.h>
#include <time.h>
#include <GenUtils.h>
#include <ArrTempl.h>
#include <NormlNSp.h>

// switch to allow us to turn off ACL checking
// #define NO_DACL_CHECK


#include "SinkHolder.h"
#include "HolderMgr.h"

// dtor - releases sinks, removes this sink holder from manager
CEventSinkHolder::~CEventSinkHolder()
{
    if (m_pSink)
        m_pSink->Release();

    if (m_pNamespace)
        m_pNamespace->Release();

    if (m_strProviderName)
        delete m_strProviderName;

    if (m_strNamespace)
        delete m_strNamespace;

    {
        CInCritSec lock(&m_csArray);

        if (m_providerInfos.Size() > 0)
        {
            for (int i = 0; i < m_providerInfos.Size(); i++)
                if  (m_providerInfos[i] != NULL)
                {
                    ProviderInfo* pProviderInfo = (ProviderInfo*)m_providerInfos[i]; 
                    (pProviderInfo->m_pProvider)->Release();
                    delete pProviderInfo;
                }
            m_providerInfos.Empty();
        }
    }
}


void* CEventSinkHolder::GetInterface(REFIID riid)
{
    if(riid == IID_IWbemEventProvider)
        return &m_XProv;
    else if(riid == IID_IWbemProviderInit)
        return &m_XInit;
    else if(riid == IID_IWbemEventProviderQuerySink)
        return &m_XQuery;
    else if(riid == IID_IWbemProviderIdentity)
        return &m_XIdentity;
    else if(riid == IID_IWbemDecoupledEventProvider)
        return &m_XDecoupledProvider;
    else if(riid == IID_IWbemDecoupledEventProviderLocator)
        return &m_XProviderLocator;
    else if(riid == IID_IWbemEventProviderSecurity)
        return &m_XSecurity;
    return NULL;
}

// return pointer to decoupled provider
HRESULT CEventSinkHolder::XProviderLocator::GetProvider(IWbemDecoupledEventProvider** pDecoupledProvider)
{
    return m_pObject->QueryInterface(IID_IWbemDecoupledEventProvider, (void**)pDecoupledProvider);
}


// saves sink, namespace, and namespace name
STDMETHODIMP CEventSinkHolder::XInit::Initialize(LPWSTR wszUser, LONG lFlags, 
                                LPWSTR wszNamespace,
                                LPWSTR wszLocale, IWbemServices* pNamespace,
                                IWbemContext* pContext, 
                                IWbemProviderInitSink* pInitSink)
{
    HRESULT hRet = WBEM_S_NO_ERROR;

    DEBUGTRACE((LOG_ESS, "PsProv: IWbemProviderInit::Initialize\n"));

    WCHAR* pNormlNamespace;

    hRet = NormalizeNamespace(wszNamespace, &pNormlNamespace);

    if (SUCCEEDED(hRet))
    {
        CDeleteMe<WCHAR> delName(pNormlNamespace);

        // hold namespace name
        if (m_pObject->m_strNamespace = new WCHAR[wcslen(pNormlNamespace) +1] )
        {
            wcscpy(m_pObject->m_strNamespace, pNormlNamespace);
        
            // hold onto the namespace for the eventual real provider
            m_pObject->m_pNamespace = pNamespace;
            m_pObject->m_pNamespace->AddRef();
    
            pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
        }
        else
            hRet = WBEM_E_OUT_OF_MEMORY;
    }
    
    return hRet;
}

// route this call to all providers
STDMETHODIMP CEventSinkHolder::XSecurity::AccessCheck(WBEM_CWSTR wszQueryLanguage, WBEM_CWSTR wszQuery,
                                                      long lSidLength, const BYTE __RPC_FAR *pSid)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemEventProviderSecurity::AccessCheck\n"));

    CInCritSec lock(&m_pObject->m_csArray);

    if (m_pObject->m_providerInfos.Size() > 0)
    {
        IWbemEventProviderSecurity* pSecurity;
        for (int i = 0; i < m_pObject->m_providerInfos.Size(); i++)
            if (m_pObject->m_providerInfos[i] != NULL)
            {
                ProviderInfo* pProviderInfo = (ProviderInfo*)m_pObject->m_providerInfos[i]; 
                if ((pProviderInfo->m_lFlags & WBEM_FLAG_CHECK_SECURITY) &&
                    SUCCEEDED(pProviderInfo->m_pProvider->QueryInterface(IID_IWbemEventProviderSecurity, (void**)&pSecurity)))
                {
                    CReleaseMe relSec(pSecurity);
                    if (FAILED(hr = pSecurity->AccessCheck(wszQueryLanguage, wszQuery, lSidLength, pSid)))
                    {
                        ERRORTRACE((LOG_ESS, "PsProv: Failed Access Check 0x%08X\n", hr));
                    }
                }
            }
    }
    
    return hr;
}



// route this call to all providers
STDMETHODIMP CEventSinkHolder::XQuery::NewQuery(DWORD dwId, LPWSTR wszLanguage,
                                            LPWSTR wszQuery)
{
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemEventProviderQuerySink::NewQuery '%S'\n", wszQuery));

    CInCritSec lock(&m_pObject->m_csArray);

    if (m_pObject->m_providerInfos.Size() > 0)
    {
        IWbemEventProviderQuerySink* pSink;
        for (int i = 0; i < m_pObject->m_providerInfos.Size(); i++)
            if  (m_pObject->m_providerInfos[i] != NULL)
            {             
                ProviderInfo* pProviderInfo = (ProviderInfo*)m_pObject->m_providerInfos[i]; 
                if (SUCCEEDED((pProviderInfo->m_pProvider)->QueryInterface(IID_IWbemEventProviderQuerySink, (void**)&pSink)))
                {
                    pSink->NewQuery(dwId, wszLanguage, wszQuery);
                    pSink->Release();
                }
            }
    }
    
    // okeefine
    return S_OK;
}
            
// route this call to all providers
STDMETHODIMP CEventSinkHolder::XQuery::CancelQuery(DWORD dwId)
{
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemEventProviderQuerySink::CancelQuery\n"));

    CInCritSec lock(&m_pObject->m_csArray);

    if (m_pObject->m_providerInfos.Size() > 0)
    {
        IWbemEventProviderQuerySink* pSink;
        for (int i = 0; i < m_pObject->m_providerInfos.Size(); i++)
            if  (m_pObject->m_providerInfos[i] != NULL)
            {
                ProviderInfo* pProviderInfo = (ProviderInfo*)m_pObject->m_providerInfos[i]; 
                if (SUCCEEDED((pProviderInfo->m_pProvider)->QueryInterface(IID_IWbemEventProviderQuerySink, (void**)&pSink)))
                {
                    pSink->CancelQuery(dwId);
                    pSink->Release();
                }
            }
    }

    // yashoor, hubetcha
    return S_OK;
}

// check to make sure current client is allowed by the dacl in the mof
HRESULT CEventSinkHolder::AccessCheck(PACL pDacl)
{
    BOOL ian;
    HRESULT hr = WBEM_E_ACCESS_DENIED;

    if (IsNT() && (pDacl != NULL))
    {
#ifdef NO_DACL_CHECK
        hr = WBEM_S_NO_ERROR;
#else
        // Just in case we're already impersonating
        CoRevertToSelf();

        // djinn up a descriptor to use
        SECURITY_DESCRIPTOR sd;    
        ian =  InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

        // find our token & sid
        HANDLE hToken = INVALID_HANDLE_VALUE;
        SID_AND_ATTRIBUTES* pSidAndAttr;
        DWORD sizeRequired;

        DWORD err;
        ian = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        err = GetLastError();

        // call once & see how much room we need
        ian = GetTokenInformation(hToken, TokenUser, NULL, 0, &sizeRequired);
        err = GetLastError();

        pSidAndAttr = (SID_AND_ATTRIBUTES*) new BYTE[sizeRequired];
        CDeleteMe<SID_AND_ATTRIBUTES> freeSid(pSidAndAttr);

        if (pSidAndAttr && 
            GetTokenInformation(hToken, TokenUser, (LPVOID)pSidAndAttr, sizeRequired, &sizeRequired))
        {
            // set sd's sids
            PSID pSid = pSidAndAttr->Sid;
            ian = SetSecurityDescriptorOwner(&sd, pSid, TRUE);
            ian = SetSecurityDescriptorGroup(&sd, pSid, TRUE);
            
            // dangle the ding-donged dacl
            ian = SetSecurityDescriptorDacl(&sd, TRUE, pDacl, TRUE);

            // all the goodies accessCheck needs to fly
            GENERIC_MAPPING map;
            map.GenericRead = 0;
            map.GenericWrite = 1;
            map.GenericExecute = 0;
            map.GenericAll = 0;

            PRIVILEGE_SET ps[10];
            DWORD size = 10 * sizeof(PRIVILEGE_SET);

            DWORD dwGranted = 0;
            BOOL bResult;

            DWORD musk = GENERIC_ALL | GENERIC_WRITE;
                        
            if SUCCEEDED(hr = CoImpersonateClient())
            {    
                HANDLE hUserToken;
                OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hUserToken);

                ian = ::AccessCheck(&sd, hUserToken, MAXIMUM_ALLOWED, &map, &ps[0], &size, &dwGranted, &bResult);              
                
                if (ian && (dwGranted & musk))
                    hr = WBEM_S_NO_ERROR;
                else
                    hr = WBEM_E_ACCESS_DENIED;

				CloseHandle(hUserToken);
				CoRevertToSelf();
            }
			// this happens if we've been called by someone in proc
            else if (hr == RPC_E_CALL_COMPLETE)
			{
				if (ImpersonateSelf(SecurityImpersonation))
				{
					HANDLE hUserToken;
					OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hUserToken);

					ian = ::AccessCheck(&sd, hUserToken, MAXIMUM_ALLOWED, &map, &ps[0], &size, &dwGranted, &bResult);              
                
					if (ian && (dwGranted & musk))
						hr = WBEM_S_NO_ERROR;
					else
						hr = WBEM_E_ACCESS_DENIED;    

					CloseHandle(hUserToken);
					RevertToSelf();
				}
				else
				{
					ERRORTRACE((LOG_ESS, "PsProv: FAILED ImpersonateSelf(), 0x%08X\n", GetLastError()));				 
					hr = WBEM_E_FAILED;
				}
			}
			else
			{
             	ERRORTRACE((LOG_ESS, "PsProv: FAILED CoImpersonateClient(), 0x%08X\n", hr));
				DWORD err = GetLastError();
			}
        }
#endif // NO_DACL_CHECK
        if (hToken != INVALID_HANDLE_VALUE)
			CloseHandle(hToken);
    }
    else
        // we're on Win9X, no prob - let's do it!
        // same diff if we've got a NULL dacl
        hr = WBEM_S_NO_ERROR;

    return hr;
}

// retrieve the acl from the provider registration
// upon success, *pDacl points to a byte array containing the dacl
// will be NULL if dacl is NULL
// caller's responsibility to delete memory
HRESULT CEventSinkHolder::GetProviderDacl(BYTE** pDacl)
{
    HRESULT hr = WBEM_E_INVALID_PROVIDER_REGISTRATION;
    
#ifdef NO_DACL_CHECK
    hr = WBEM_S_NO_ERROR;
#else

    WCHAR templ[] = L"Win32PseudoProvider.Name=\"%s\"";
    WCHAR* pBuf = new WCHAR[wcslen(templ) + wcslen(GetProviderName()) + 3];
    if (pBuf)
    {
        CDeleteMe<WCHAR> delBuf(pBuf);
        swprintf(pBuf, templ, GetProviderName());
        IWbemClassObject *pRegistration;
        if (SUCCEEDED(hr = m_pNamespace->GetObject(pBuf, 0, NULL, &pRegistration, NULL)))
        {
            CReleaseMe relReg(pRegistration);
            VARIANT v;
            VariantInit(&v);
            if (SUCCEEDED(pRegistration->Get(L"DACL", 0, &v, NULL, NULL)))
            {
                if (v.vt == VT_NULL)
                {
                    hr = WBEM_S_NO_ERROR;
                    *pDacl = NULL;
                }
                else
                {
                    HRESULT hDebug;
                    
                    // okay, look, from now on, I'm assuming that the class def is correct.
                    // if it isn't, something is sure to blow...
                    long ubound;
                    hDebug = SafeArrayGetUBound(V_ARRAY(&v), 1, &ubound);

                    PVOID pVoid;
                    hDebug = SafeArrayAccessData(V_ARRAY(&v), &pVoid);

                    *pDacl = new BYTE[ubound +1];
                    if (*pDacl)
                    {
                        memcpy(*pDacl, pVoid, ubound + 1);
                        hr = WBEM_S_NO_ERROR;
                    }
                    else
                        hr = WBEM_E_OUT_OF_MEMORY;

                    SafeArrayUnaccessData(V_ARRAY(&v));
                }
            }
            VariantClear(&v);
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

#endif // NO_DACL_CHECK


    return hr;
}

// transfer the sink & namespace
STDMETHODIMP CEventSinkHolder::XDecoupledProvider::Connect(long lFlags, 
                                                           IUnknown* pPseudoSink,
		                                                   IWbemObjectSink** ppSink, 
                                                           IWbemServices** ppNamespace)
{
    HRESULT hr = WBEM_E_FAILED;
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemDecoupledEventProvider::Connect\n"));
    
    BYTE* pDaclBits = NULL;
    if (SUCCEEDED(hr = m_pObject->GetProviderDacl(&pDaclBits)))
    {            
        CDeleteMe<BYTE> deleteThemBits(pDaclBits);
        if (SUCCEEDED(hr = m_pObject->AccessCheck((PACL)pDaclBits)))
        {
            m_pObject->m_pSink->AddRef();
            *ppSink = m_pObject->m_pSink;

            if (ppNamespace)
            {
                m_pObject->m_pNamespace->AddRef();
                *ppNamespace = m_pObject->m_pNamespace;
            }
        }
    }

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsProv: FAILED IWbemDecoupledEventProvider::Connect, 0x%08X\n", hr));

    return hr;
}

// provider is telling us who he is
// we return the index of where we put him in the array so that we can delete him when needed
STDMETHODIMP CEventSinkHolder::XDecoupledProvider::SetProviderServices(IUnknown* pProviderServices, long lFlags, DWORD* dwID)
{
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemDecoupledEventProvider::SetProviderServices\n"));
    
    // just in case something goes wrong...
    *dwID = PseudoProviderDef::InvalidIndex;
    HRESULT hr = WBEM_E_FAILED;

    if (pProviderServices)
    {
        CInCritSec lock(&m_pObject->m_csArray);

        ProviderInfo* pProviderInfo = new ProviderInfo(pProviderServices, lFlags);
        if (pProviderInfo)
        {
            int nRet = m_pObject->m_providerInfos.Add(pProviderInfo);
            if (nRet == CFlexArray::no_error)
            {        
                pProviderServices->AddRef();
                *dwID = m_pObject->m_providerInfos.Size() -1;
                hr = WBEM_S_NO_ERROR;
            }
            else if ((nRet == CFlexArray::out_of_memory)  || (nRet == CFlexArray::array_full))
                hr = WBEM_E_OUT_OF_MEMORY;
        }
        else
            hr = WBEM_E_OUT_OF_MEMORY;
    }

    if (FAILED(hr))
        ERRORTRACE((LOG_ESS, "PsProv: FAILED SetProviderServices, 0x%08X\n", hr));

    return hr;
}


STDMETHODIMP CEventSinkHolder::XDecoupledProvider::Disconnect(DWORD dwID)
{
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemDecoupledEventProvider::Disconnect\n"));
    HRESULT hr = WBEM_E_NOT_FOUND;                             

    CInCritSec lock(&m_pObject->m_csArray);

    if ((dwID < m_pObject->m_providerInfos.Size()) && (m_pObject->m_providerInfos[dwID] != NULL))
    {
        ProviderInfo* pProviderInfo = (ProviderInfo*)m_pObject->m_providerInfos[dwID];   
        pProviderInfo->m_pProvider->Release();
        delete pProviderInfo;

        // can't resize the array other folks could be using it.
        m_pObject->m_providerInfos[dwID] = NULL;
        m_pObject->m_providerInfos.Trim();

        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}
    
// constructs name of the form namespace!class
// returns true iff both pieces have been initialized
// function new's name, caller's responsibility to delete it
bool CEventSinkHolder::GetMangledName(LPWSTR* pMangledName)
{
    bool bRet = false;
    if (m_strProviderName && m_strNamespace)
    {
        *pMangledName = new WCHAR[wcslen(m_strProviderName) + wcslen(m_strNamespace) + 2];
        if (*pMangledName)
        {
            bRet = true;
            wcscpy(*pMangledName, m_strNamespace);
            wcscat(*pMangledName, L"!");
            wcscat(*pMangledName, m_strProviderName);
        }
    }

    return bRet;
}

STDMETHODIMP CEventSinkHolder::XIdentity::SetRegistrationObject(long lFlags, IWbemClassObject* pProvReg)
{
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemProviderIdentity::SetRegistrationObject\n"));
    HRESULT hr = WBEM_E_FAILED;

    if (pProvReg)
    {
        VARIANT v;
        VariantInit(&v);

        hr = pProvReg->Get(L"Name", 0, &v, NULL, NULL);

        // BSTR b; testing...
        // pProvReg->GetObjectText(0, &b);

        if (SUCCEEDED(hr) && (v.vt == VT_BSTR) && (v.bstrVal != NULL))
        {
            if (m_pObject->m_strProviderName = new WCHAR[wcslen(v.bstrVal) +1])
            {
                wcscpy(m_pObject->m_strProviderName, v.bstrVal);
                hr = WBEM_S_NO_ERROR;
            }
            else
                hr = WBEM_E_OUT_OF_MEMORY;

        }  // if (SUCCEEDED(hr) && (v.vt...
    } // if pProvReg

    return hr;
}
    
// we're not actually providing events here, but we'll hold onto the sink
// also - we've got all our parts, we'll reveal our existance to the holder manager.
STDMETHODIMP CEventSinkHolder::XProv::ProvideEvents(IWbemObjectSink* pSink,long lFlags)
{
    DEBUGTRACE((LOG_ESS, "PsProv: IWbemEventProvider::ProvideEvents\n")); 
    pSink->AddRef();

    // just in case we've got an old one laying around
    // shouldn't ever happen, but well, you know...
    if (m_pObject->m_pSink)
         m_pObject->m_pSink->Release();

    m_pObject->m_pSink = pSink;   

    // register thyself
 // register thyself
    HRESULT hr = sinkManager.Add(m_pObject);

    CInCritSec lock(&m_pObject->m_csArray);

    if (SUCCEEDED(hr) && (m_pObject->m_providerInfos.Size() > 0))
    {
        IWbemEventProvider* pProvider;
        for (int i = 0; i < m_pObject->m_providerInfos.Size(); i++)
            if  (m_pObject->m_providerInfos[i] != NULL)
            {             
                ProviderInfo* pProviderInfo = (ProviderInfo*)m_pObject->m_providerInfos[i]; 
                if (SUCCEEDED((pProviderInfo->m_pProvider)->QueryInterface(IID_IWbemEventProvider, (void**)&pProvider)))
                {
                    pProvider->ProvideEvents(pSink, lFlags);
                    pProvider->Release();
                }
            }
    }

    return hr;

}

BOOL CEventSinkHolder::OnInitialize()
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ESST.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\bin2mof\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	EventDmp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\bin2mof\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__77FB3DAE_752C_432D_8980_FF71096F65BB__INCLUDED_)
#define AFX_STDAFX_H__77FB3DAE_752C_432D_8980_FF71096F65BB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _WIN32_WINNT 0x0500

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__77FB3DAE_752C_432D_8980_FF71096F65BB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\bin2mof\bin2mof.cpp ===
// EventDmp.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Args:
// Namespace
// Query
// Timeout

void PrintUsage()
{
    printf(
        "Prints out the MOF version of a file created by a MSFT_WmiMofConsumer.\n"
        "\n"
        "BIN2MOF filename\n"
    );
}

#define DEF_NAMESPACE   L"root\\default"

int __cdecl main(int argc, char* argv[])
{
    if (argc != 2)
    {
        PrintUsage();

        return 1;
    }
            
    FILE *pFile = fopen(argv[1], "rb");

    if (!pFile)
    {
        printf("Unable to open file.\n");

        return 1;
    }
    

    HRESULT      hr;
	IWbemLocator *pLocator = NULL;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pLocator)) == S_OK)
    {
        IWbemServices *pNamespace = NULL;
        _bstr_t       strNamespace = DEF_NAMESPACE;

        if ((hr = pLocator->ConnectServer(
            strNamespace,
			NULL,    // username
			NULL,	 // password
			NULL,    // locale
			0L,		 // securityFlags
			NULL,	 // authority (domain for NTLM)
			NULL,	 // context
			&pNamespace)) == S_OK) 
        {	
            pLocator->Release();

            _bstr_t          strClass = L"__EventFilter";
            IWbemClassObject *pClass = NULL;
            _IWmiObject      *pObj = NULL;
            HRESULT          hr;
            DWORD            dwSize;
            BYTE             cBuffer[64000];

            hr = 
                pNamespace->GetObject(
                    strClass,
                    0,
                    NULL,
                    &pClass,
                    NULL);
            
            // Yes, I'm naughty and I know it!
            hr = pClass->SpawnInstance(0, (IWbemClassObject**) &pObj);

            DWORD dwMsg,
                  dwRead;

            while((dwMsg = fread(&dwSize, 1, 4, pFile)) == 4 &&
                (dwRead = fread(cBuffer, 1, dwSize, pFile)) == dwSize)
            {
                BSTR   bstrObj = NULL;
                LPVOID pMem = CoTaskMemAlloc(dwSize);

                memcpy(pMem, cBuffer, dwSize);
                hr = pObj->SetObjectMemory(pMem, dwSize);

                if (SUCCEEDED(hr = pObj->GetObjectText(0, &bstrObj)))
                {
                    printf("%S", bstrObj);
                
                    SysFreeString(bstrObj);
                }
                else
                    printf(
                        "\n// IWbemClassObject::GetObjectText failed : 0x%X\n", hr);
            }

            long lWhere = ftell(pFile);

            pObj->Release();

            pNamespace->Release();
        }
        else
        {
            printf("IWbemLocator::ConnectServer failed: 0x%X\n", hr);
            
            pLocator->Release();
        }
    }
    else
        printf("CoCreateInstance for CLSID_WbemLocator failed: 0x%X\n", hr);

    CoUninitialize();

	if (pFile)
        fclose(pFile);

    return 0;
}

/*
HRESULT STDMETHODCALLTYPE CMofSink::Indicate(
    LONG nEvents,
    IWbemClassObject **ppEvents)
{
    // Stop us from timing out.
    SetEvent(heventReceived);

    for (int i = 0; i < nEvents; i++)
    {
        BSTR    bstrObj = NULL;
        HRESULT hr;

        if (SUCCEEDED(hr = ppEvents[i]->GetObjectText(0, &bstrObj)))
        {
            printf("%S", bstrObj);
                
            SysFreeString(bstrObj);
        }
        else
            printf(
                "\n// IWbemClassObject::GetObjectText failed : 0x%X\n", hr);
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBinSink::Indicate(
    LONG nEvents,
    IWbemClassObject **ppEvents)
{
    // Stop us from timing out.
    SetEvent(heventReceived);

    for (int i = 0; i < nEvents; i++)
    {
        HRESULT     hr;
        _IWmiObject *pObj = NULL;

        if (SUCCEEDED(hr = ppEvents[i]->QueryInterface(
            IID__IWmiObject, (LPVOID*) &pObj)))
        {
            DWORD dwRead;

            if (SUCCEEDED(hr = pObj->GetObjectMemory(
                m_pBuffer, MAX_OBJ_SIZE, &dwRead)))
            {
                fwrite(&dwRead, sizeof(dwRead), 1, m_pFile);
                fwrite(m_pBuffer, dwRead, 1, m_pFile);
            }

            pObj->Release();
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CObjSink::SetStatus(
    LONG lFlags,
    HRESULT hResult, 
    BSTR strParam, 
    IWbemClassObject *pObjParam)
{
    return S_OK;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B1E03C71_92B6_4B6E_82B3_E10D946969AD__INCLUDED_)
#define AFX_STDAFX_H__B1E03C71_92B6_4B6E_82B3_E10D946969AD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define _WIN32_WINNT 0x0500

#pragma warning( disable : 4786 )  

#include <windows.h>
#include <objbase.h>        // COM
#include <comdef.h>         // _bstr_t, _variant_t
#include <wbemcli.h>        // duh

_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B1E03C71_92B6_4B6E_82B3_E10D946969AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\esst.cpp ===
// ESST.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "EssTest.h"

void PrintUsage()
{
    printf(

"Tests the Event Subsystem of WMI.\n"
"\n"
"ESST [/O<level>] [/K] [/STOP]\n"
"\n"
"/O<level> 'Level' indicates the amount of status information ESST should \n"
"          display: \n"
"             0 - Only display final results. \n"
"             1 - Display only errors and final results (default). \n"
"             2 - Display all status messages. \n"
"/K        Keep consumer logs (these are deleted by default).\n"
"/STOP     Stops any currently running instance of ESST.\n"

    );
}

int __cdecl main(int argc, char* argv[])
{
    for (int i = 1; i < argc; i++)
    {
        LPSTR szArg = argv[i];

        if (szArg[0] == '/' || szArg[0] == '-')
        {
            switch(toupper(szArg[1]))
            {
                case 'K':
                    g_essTest.SetKeepLogs(TRUE);
                    break;

                case 'O':
                    g_essTest.SetLoggingLevel(atoi(&szArg[2]));
                    break;

                default:
                    PrintUsage();
                    return 1;
            }
        }
        else
        {
            PrintUsage();
            return 1;
        }
    }                    

	g_essTest.Run();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\esstest.h ===
// EssTest.h

#ifndef _ESSTEST_H
#define _ESSTEST_H

#include <stdarg.h>
#include <list>
#include <map>
#include "WorkItem.h"

enum LOG_LEVEL
{
    LOGLEVEL_RESULTS_ONLY,
    LOGLEVEL_RESULTS_AND_ERRORS,
    LOGLEVEL_ALL
};

#define DEF_NAMESPACE   L"ROOT\\CIMV2"

class CEssTest
{
public:
    CEssTest();
    ~CEssTest();

    void Run();
    void Pause();
    void Stop();

    void SetLoggingLevel(DWORD dwLevel)
    {
        if (dwLevel > LOGLEVEL_ALL)
            dwLevel = LOGLEVEL_ALL;

        m_logLevel = (LOG_LEVEL) dwLevel;
    }

    void SetKeepLogs(BOOL bKeep)
    {
        m_bKeepLogs = bKeep;
    }

    //IWbemServices *GetNamespace() { return m_pNamespace; }

    void PrintResult(LPSTR szFormat, ...);
    void PrintError(LPSTR szFormat, ...);
    void PrintStatus(LPSTR szFormat, ...);
    void Printf(LOG_LEVEL level, LPSTR szFormat, ...);
    void Vprintf(LOG_LEVEL level, LPSTR szFormat, va_list arglist);

    void LockOutput()
    {
        EnterCriticalSection(&m_csOutput);
    }

    void UnlockOutput()
    {
        LeaveCriticalSection(&m_csOutput);
    }

    HRESULT SpawnInstance(LPCWSTR szClass, IWbemClassObject **ppObj);
    HRESULT DeleteReferences(LPCWSTR szPath);
    HRESULT GetNamespace(LPCWSTR szNamespace, IWbemServices **ppNamespace);
    IWbemServices *GetDefNamespace() { return m_pDefNamespace; }

    BOOL KeepLogs() { return m_bKeepLogs; }

protected:
    typedef std::list<CWorkItem*> CWorkItemList;
    typedef CWorkItemList::iterator CWorkItemListIterator;

    typedef std::map<_bstr_t, IWbemServicesPtr> CNamespaceMap;
    typedef CNamespaceMap::iterator CNamespaceMapItor;

    LOG_LEVEL        m_logLevel;
    BOOL             m_bKeepLogs;
    IWbemLocatorPtr  m_pLocator;
    IWbemServicesPtr m_pDefNamespace;
    CWorkItemList    m_listItems;
    CRITICAL_SECTION m_csOutput;
    CNamespaceMap    m_mapNamespace;
    
    HRESULT Init();
    HRESULT LoadWorkItems();
    void Cleanup();
    void RemoveBindings();

    static DWORD WINAPI RunItemProc(CWorkItem *pItem);
};

extern CEssTest g_essTest;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\eventdmp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	EventDmp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\esstest.cpp ===
// EssTest.cpp

#include "stdafx.h"
#include "EssTest.h"

// Our single global instance.
CEssTest g_essTest;

CEssTest::CEssTest() :
    m_logLevel(LOGLEVEL_RESULTS_AND_ERRORS),
    m_bKeepLogs(FALSE)
{
    InitializeCriticalSection(&m_csOutput);
}

CEssTest::~CEssTest()
{
    Cleanup();
}

DWORD WINAPI CEssTest::RunItemProc(CWorkItem *pItem)
{
    pItem->Run();

    return 0;
}

void CEssTest::Run()
{
    if (SUCCEEDED(Init()))
    {
        int    nItems = m_listItems.size(),
               i = 0;
        HANDLE *phthreadItems = new HANDLE[nItems];

        for (CWorkItemListIterator item = m_listItems.begin();
            item != m_listItems.end();
            item++)
        {
            DWORD dwID;

            phthreadItems[i++] = 
                CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) RunItemProc,
                    *item,
                    0,
                    &dwID);
        }

        WaitForMultipleObjects(nItems, phthreadItems, TRUE, INFINITE);

        for (i = 0; i < nItems; i++)
            CloseHandle(phthreadItems[i]);

        delete phthreadItems;
    }
}

void CEssTest::Pause()
{
}

void CEssTest::Stop()
{
}

HRESULT CEssTest::LoadWorkItems()
{
    IEnumWbemClassObject *pEnum = NULL;
    _bstr_t              strClass = L"MSFT_EssTestWorkItem";
    HRESULT              hr;

    hr = 
        m_pDefNamespace->CreateInstanceEnum(
            strClass,
            WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY | 
                WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObject *pObj = NULL;
        DWORD            nCount,
                         dwID = 0;

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            _variant_t vEnabled(false);
            _variant_t vName(L"???");

            pObj->Get(L"Name", 0, &vName, NULL, NULL);
            pObj->Get(L"Enabled", 0, &vEnabled, NULL, NULL);

            if ((bool) vEnabled == true)
            {
                CWorkItem *pItem = new CWorkItem;
                HRESULT   hr;

                if (SUCCEEDED(hr = pItem->Init(pObj, dwID)))
                {
                    m_listItems.push_back(pItem);

                    PrintStatus("Loaded enabled work item '%S'.", V_BSTR(&vName));

                    dwID++;
                }
                else
                {
                    PrintError(
                        "Failed to init work item '%S': 0x%X", 
                        V_BSTR(&vName),
                        hr);
                }
                
                pObj->Release();
            }
            else
            {
                PrintStatus("Skipping disabled work item '%S'.", V_BSTR(&vName));
            }
        }

        pEnum->Release();
    }
    else
        PrintError("Failed to enumerate work items: 0x%X", hr);

    return hr;
}

HRESULT CEssTest::DeleteReferences(LPCWSTR szPath)
{
    HRESULT              hr;
    WCHAR                szQuery[MAX_PATH * 2];
    IEnumWbemClassObject *pEnum = NULL;

    // Find the association so we can nuke it.
    swprintf(
        szQuery,
        L"references of {%s}",
        szPath);

    _bstr_t strWQL = L"WQL",
            strQuery = szQuery;

    hr = 
        m_pDefNamespace->ExecQuery(
            strWQL,
            strQuery,
            WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObjectPtr pObj;
        DWORD               nCount;

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            _variant_t vPath;

            pObj->Get(L"__PATH", 0, &vPath, NULL, NULL);

            hr = m_pDefNamespace->DeleteInstance(
                    V_BSTR(&vPath), 0, NULL, NULL);
        }

        pEnum->Release();
    }
    
    return hr;
}

HRESULT CEssTest::Init()
{
    HRESULT hr;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &m_pLocator)) == S_OK)
    {
        hr = GetNamespace(DEF_NAMESPACE, &m_pDefNamespace);

        // Get rid of stuff that may have been left around from an aborted
        // instance of ESST.
        RemoveBindings();

        if (SUCCEEDED(hr))
            hr = LoadWorkItems();
    }
    else
        PrintError("CoCreateInstance for CLSID_WbemLocator failed: 0x%X\n", hr);

    return hr;
}

void CEssTest::RemoveBindings()
{
    IEnumWbemClassObject *pEnum = NULL;
    _bstr_t              strClass;
    HRESULT              hr;

    // Get rid of MSFT_WmiMofConsumer instances.
    strClass = L"MSFT_WmiMofConsumer";
    hr = 
        m_pDefNamespace->CreateInstanceEnum(
            strClass,
            WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY | 
                WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObjectPtr pObj;
        DWORD               nCount;
        BOOL                bDisplayed = FALSE;

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            _variant_t vPath;

            if (!bDisplayed)
            {
                PrintStatus("Cleaning up previous consumers...");
                bDisplayed = TRUE;
            }

            pObj->Get(L"__PATH", 0, &vPath, NULL, NULL);

            // Get rid of all the bindings using this consumer.
            hr = DeleteReferences(V_BSTR(&vPath));

            hr = m_pDefNamespace->DeleteInstance(
                    V_BSTR(&vPath), 0, NULL, NULL);
        }

        pEnum->Release();
    }
    else
        PrintError("Failed to enumerate MSFT_WmiMofConsumer: 0x%X", hr);


    // Get rid of MSFT_EssTestEventFilterToTestFilter instances.
    strClass = L"MSFT_EssTestEventFilterToTestFilter";
    hr = 
        m_pDefNamespace->CreateInstanceEnum(
            strClass,
            WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY | 
                WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObjectPtr pObj;
        DWORD               nCount;
        BOOL                bDisplayed = FALSE;

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            _variant_t vPath;

            if (!bDisplayed)
            {
                PrintStatus("Cleaning up previous filters...");
                bDisplayed = TRUE;
            }

            // Nuke the actual __EventFilter.
            pObj->Get(L"EventFilter", 0, &vPath, NULL, NULL);
            hr = m_pDefNamespace->DeleteInstance(
                    V_BSTR(&vPath), 0, NULL, NULL);
            
            // Nuke the association.
            pObj->Get(L"__PATH", 0, &vPath, NULL, NULL);
            hr = m_pDefNamespace->DeleteInstance(
                    V_BSTR(&vPath), 0, NULL, NULL);
        }

        pEnum->Release();
    }
    else
        PrintError("Failed to enumerate MSFT_EssTestEventFilterToTestFilter: 0x%X", hr);
}

void CEssTest::Cleanup()
{
    for (CWorkItemListIterator i = m_listItems.begin(); 
        i != m_listItems.end(); 
        i++)
    {
        delete (*i);
    }

    DeleteCriticalSection(&m_csOutput);

    CoUninitialize();
}

void CEssTest::PrintResult(LPSTR szFormat, ...)
{
    va_list arglist;
    
    va_start(arglist, szFormat);

    Vprintf(LOGLEVEL_RESULTS_ONLY, szFormat, arglist);
}

void CEssTest::PrintError(LPSTR szFormat, ...)
{
    va_list arglist;
            
    va_start(arglist, szFormat);

    Vprintf(LOGLEVEL_RESULTS_AND_ERRORS, szFormat, arglist);
}

void CEssTest::PrintStatus(LPSTR szFormat, ...)
{
    va_list arglist;
            
    va_start(arglist, szFormat);

    Vprintf(LOGLEVEL_ALL, szFormat, arglist);
}

void CEssTest::Printf(LOG_LEVEL level, LPSTR szFormat, ...)
{
    va_list arglist;
            
    va_start(arglist, szFormat);

    Vprintf(level, szFormat, arglist);
}

void CEssTest::Vprintf(LOG_LEVEL level, LPSTR szFormat, va_list arglist)
{
    if (level <= m_logLevel)
    {
        vprintf(szFormat, arglist);
        printf("\n");
    }
}

HRESULT CEssTest::SpawnInstance(LPCWSTR szClass, IWbemClassObject **ppObj)
{
    HRESULT          hr;
    IWbemClassObject *pClass = NULL;
    _bstr_t          strClass = szClass;

    if (SUCCEEDED(hr = m_pDefNamespace->GetObject(
        strClass,
        0,
        NULL,
        &pClass,
        NULL)))
    {
        if (FAILED(hr = pClass->SpawnInstance(
            0,
            ppObj)))
        {
            g_essTest.PrintError(
                "Unable to spawn an instance of %S: 0x%X", szClass, hr);
        }

        pClass->Release();
    }
    else
        g_essTest.PrintError(
            "Unable to get the %S class: 0x%X", szClass, hr);
        
    return hr;
}

HRESULT CEssTest::GetNamespace(LPCWSTR szNamespace, IWbemServices **ppNamespace)
{
    _bstr_t           strNamespace = szNamespace;
    CNamespaceMapItor item;
    HRESULT           hr;
    
    wcsupr(strNamespace);
    item = m_mapNamespace.find(strNamespace);

    if (item != m_mapNamespace.end())
    {
        *ppNamespace = (*item).second;
        (*ppNamespace)->AddRef();

        hr = S_OK;
    }
    else
    {
        hr = 
            m_pLocator->ConnectServer(
                strNamespace,
			    NULL,    // username
			    NULL,	 // password
			    NULL,    // locale
			    0L,		 // securityFlags
			    NULL,	 // authority (domain for NTLM)
			    NULL,	 // context
			    ppNamespace);

        if (SUCCEEDED(hr))
            m_mapNamespace[strNamespace] = *ppNamespace;
        else
            PrintError(
                "IWbemLocator::ConnectServer to %S failed: 0x%X\n", 
                (LPWSTR) strNamespace,
                hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\eventdmp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__77FB3DAE_752C_432D_8980_FF71096F65BB__INCLUDED_)
#define AFX_STDAFX_H__77FB3DAE_752C_432D_8980_FF71096F65BB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _WIN32_WINNT 0x0500

#include <windows.h>
#include <stdio.h>
#include <wbemcli.h>
#include <wbemint.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__77FB3DAE_752C_432D_8980_FF71096F65BB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\workitem.cpp ===
// WorkItem.cpp

#include "stdafx.h"
#include "EssTest.h"
#include "WorkItem.h"
#include <flexarry.h>
#include <wbemint.h>
#include <share.h>

#define DEF_EVENTS      1000
#define DEF_REPEAT      1
#define DEF_PERM_CONS   10
#define DEF_TEMP_CONS   1
#define DEF_SLOW_DOWN   FALSE

/////////////////////////////////////////////////////////////////////////////
// CWorkItem

CWorkItem::CWorkItem() :
    m_bFullCompare(TRUE)
{
}

CWorkItem::~CWorkItem()
{
    for (CPConsumerListIterator perm = m_listPermConsumers.begin(); 
        perm != m_listPermConsumers.end(); 
        perm++)
    {
        delete (*perm);
    }

    for (CTConsumerListIterator temp = m_listTempConsumers.begin(); 
        temp != m_listTempConsumers.end(); 
        temp++)
    {
        delete (*temp);
    }

    for (CWorkFilterListIterator filter = m_listFilters.begin(); 
        filter != m_listFilters.end(); 
        filter++)
    {
        delete (*filter);
    }

    if (!g_essTest.KeepLogs() && m_strEventGenFile.length())
        DeleteFileW(m_strEventGenFile);
}

HRESULT CWorkItem::Init(IWbemClassObject *pObj, DWORD dwID)
{
    HRESULT    hr;
    _variant_t vTemp;

    m_dwID = dwID;

    // Load the work item's properties.
    if (SUCCEEDED(hr = pObj->Get(L"Name", 0, &vTemp, NULL, NULL)))
    {
        m_strName = V_BSTR(&vTemp);

        if (SUCCEEDED(pObj->Get(L"NumEvents", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_I4)
            m_nEvents = (long) vTemp;
        else
            m_nEvents = DEF_EVENTS;

        if (SUCCEEDED(pObj->Get(L"TimesToExecute", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_I4)
            m_nTimesToRepeat = (long) vTemp;
        else
            m_nTimesToRepeat = DEF_REPEAT;

        if (SUCCEEDED(pObj->Get(L"MaxPermConsumers", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_I4)
            m_nPermConsumers = (long) vTemp;
        else
            m_nPermConsumers = DEF_PERM_CONS;

        if (SUCCEEDED(pObj->Get(L"MaxTempConsumers", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_I4)
            m_nTempConsumers = (long) vTemp;
        else
            m_nTempConsumers = DEF_TEMP_CONS;

        if (SUCCEEDED(pObj->Get(L"SlowDownProviders", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_BOOL)
            m_bSlowDownProviders = (bool) vTemp;
        else
            m_bSlowDownProviders = DEF_SLOW_DOWN;

        if (SUCCEEDED(pObj->Get(L"SlowDownProviders", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_BOOL)
            m_bSlowDownProviders = (bool) vTemp;
        else
            m_bSlowDownProviders = DEF_SLOW_DOWN;

        


        // Load the item's event generator.    
        IWbemClassObjectPtr pGenerator;

        if (SUCCEEDED(hr = pObj->Get(L"EventGenerator", 0, &vTemp, NULL, NULL)) &&
            SUCCEEDED(hr = g_essTest.GetDefNamespace()->GetObject(
                V_BSTR(&vTemp),
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pGenerator,
                NULL)))
        {
            m_strGeneratorName = V_BSTR(&vTemp);

            if (SUCCEEDED(pGenerator->Get(L"EventNamespace", 0, &vTemp, NULL, NULL)) &&
                vTemp.vt == VT_BSTR)
            {
                if (FAILED(g_essTest.GetNamespace(V_BSTR(&vTemp), &m_pNamespace)))
                    return WBEM_E_FAILED;
            }
            else
                m_pNamespace = g_essTest.GetDefNamespace();

            if (SUCCEEDED(pGenerator->Get(L"Script", 0, &vTemp, NULL, NULL)) &&
                vTemp.vt == VT_BSTR)
            {
                m_strRawScript = V_BSTR(&vTemp);

                if (!CreateScriptResultsFile(L"1", m_strEventGenFile))
                    return WBEM_E_FAILED;
            }

            if (SUCCEEDED(pGenerator->Get(L"FullCompare", 0, &vTemp, NULL, NULL)) &&
                vTemp.vt == VT_BOOL)
            {
                m_bFullCompare = (bool) vTemp;
            }

            if (SUCCEEDED(hr = 
                pGenerator->Get(L"CommandLine", 0, &vTemp, NULL, NULL)))
            {
                m_strCommandLine = V_BSTR(&vTemp);
                
                if (m_strEventGenFile.length())
                    ReplaceString(m_strCommandLine, L"%ResultsFile%", m_strEventGenFile);

                hr = InsertReplacementStrings(m_strCommandLine, pObj);               
            }
        }
    }

    return hr;
}

void ChangeFileExt(LPWSTR szPath, LPCWSTR szNewExt)
{
    WCHAR szOldPath[MAX_PATH],
          szDrive[MAX_PATH],
          szDir[MAX_PATH],
          szName[MAX_PATH],
          szExt[MAX_PATH];

    wcscpy(szOldPath, szPath);
    _wsplitpath(szPath, szDrive, szDir, szName, szExt);
    _wmakepath(szPath, szDrive, szDir, szName, szNewExt);

    // Make sure the file doesn't already exit.
    DeleteFileW(szPath);

    MoveFileW(szOldPath, szPath);
}

BOOL CWorkItem::CreateScriptResultsFile(LPCWSTR szRule, _bstr_t &strFileName)
{
    _bstr_t strScriptContents = (LPWSTR) m_strRawScript;
    WCHAR   szScriptFile[MAX_PATH * 2] = L"",
            szResultFile[MAX_PATH * 2] = L"";

    ReplaceString(strScriptContents, L"%ScriptRule%", szRule);

    GetTempFileNameW(L".", L"SRC", 0, szScriptFile);
    GetTempFileNameW(L".", L"DST", 0, szResultFile);
    ChangeFileExt(szScriptFile, L".js");
    
    FILE *pFile = _wfopen(szScriptFile, L"w");
    BOOL bRet = FALSE;

    if (pFile)
    {
        fputs((LPSTR) strScriptContents, pFile);
        bRet = TRUE;
        fclose(pFile);

        WCHAR szCmdLine[MAX_PATH * 3];

        swprintf(
            szCmdLine,
            L"cmd /c \"cscript %s //Nologo %d > %s\"",
            szScriptFile,
            m_nEvents,
            szResultFile);

        STARTUPINFOW        startinfo = { sizeof(startinfo) };
        PROCESS_INFORMATION procinfo;

        GetStartupInfoW(&startinfo);

        // Get out base timestamp.
        m_dwBaseTimestamp = GetTickCount();

        if (CreateProcessW(
            NULL,
            szCmdLine,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,
            &startinfo,
            &procinfo))
        {
            CloseHandle(procinfo.hThread);

            WaitForSingleObject(procinfo.hProcess, INFINITE);

            CloseHandle(procinfo.hProcess);

            strFileName = szResultFile;

            bRet = TRUE;
        }
        else
        {
            g_essTest.PrintError(
                "Failed to create script results file '%S': error %d",
                szResultFile,
                GetLastError());
        }

        // Get rid of the source script file.
        if (!g_essTest.KeepLogs())        
            DeleteFileW(szScriptFile);
    }
    else
    {
        g_essTest.PrintError(
            "Failed to create script file '%S'.",
            szScriptFile);
    }

    return bRet;
}

HRESULT CWorkItem::InitFilters()
{
    IEnumWbemClassObject *pEnum = NULL;
    WCHAR                szQuery[512];
    HRESULT              hr;
    IWbemClassObjectPtr  pobjAssoc,
                         pobjFilter;
    IWbemServices        *pDefNamespace = g_essTest.GetDefNamespace();

    if (FAILED(hr =
        g_essTest.SpawnInstance(
            L"MSFT_EssTestEventFilterToTestFilter",
            &pobjAssoc)) ||
        FAILED(hr =
        g_essTest.SpawnInstance(
            L"__EventFilter",
            &pobjFilter)))
    {
        return hr;
    }

    _variant_t vTemp = L"WQL";
    _bstr_t    strName = (LPWSTR) m_strGeneratorName;

    pobjFilter->Put(L"QueryLanguage", 0, &vTemp, 0);
    pobjFilter->Put(L"ConditionLanguage", 0, &vTemp, 0);

    EscapeQuotedString(strName);

    swprintf(
        szQuery,
        L"select * from MSFT_EssTestFilter where "
        L"EventGenerator=\"%s\"",
        (LPWSTR) strName);

    _bstr_t strWQL = L"WQL",
            strQuery = szQuery;

    hr = 
        pDefNamespace->ExecQuery(
            strWQL,
            strQuery,
            WBEM_FLAG_FORWARD_ONLY,
            NULL,
            &pEnum);

    if (SUCCEEDED(hr))
    {
        IWbemClassObjectPtr pObj;
        DWORD               nCount;

        while(SUCCEEDED(hr = pEnum->Next(WBEM_INFINITE, 1, &pObj, &nCount)) &&
            nCount > 0)
        {
            _variant_t vName(L"???");
            _variant_t vBehavior((long) 0);

            pObj->Get(L"Name", 0, &vName, NULL, NULL);
            pObj->Get(L"Behavior", 0, &vBehavior, NULL, NULL);

            if ((long) vBehavior != 0)
            {
                CWorkFilter *pFilter = new CWorkFilter;
                HRESULT     hr;

                if (SUCCEEDED(hr = pFilter->Init(pObj, this)))
                {
                    // Create an __EventFilter intance.
                    _variant_t vTemp;
                    
                    vTemp = pFilter->m_strQuery;
                    pobjFilter->Put(L"Query", 0, &vTemp, 0);

                    vTemp = pFilter->m_strName;
                    pobjFilter->Put(L"Name", 0, &vTemp, 0);
                    
                    pObj->Get(L"ConditionNamespace", 0, &vTemp, NULL, NULL);
                    pobjFilter->Put(L"ConditionNamespace", 0, &vTemp, 0);

                    pObj->Get(L"Condition", 0, &vTemp, NULL, NULL);
                    pobjFilter->Put(L"Condition", 0, &vTemp, 0);

                    hr = pDefNamespace->PutInstance(
                            pobjFilter, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

                    if (SUCCEEDED(hr))
                    {
                        g_essTest.PrintStatus(
                            "Created __EventFilter=\"%S\"", 
                            (BSTR) pFilter->m_strName);
                    }
                    else
                    {
                        g_essTest.PrintError(
                            "Failed to put __EventFilter '%S' for item '%S': 0x%X", 
                            V_BSTR(&vTemp),
                            (BSTR) m_strName,
                            hr);

                        continue;
                    }

                    // Create a MSFT_EssTestEventFilterToTestFilter intance.
                    pobjFilter->Get(L"__RELPATH", 0, &vTemp, NULL, NULL);
                    pobjAssoc->Put(L"EventFilter", 0, &vTemp, 0);

                    pObj->Get(L"__RELPATH", 0, &vTemp, NULL, NULL);
                    pobjAssoc->Put(L"TestFilter", 0, &vTemp, 0);

                    hr = pDefNamespace->PutInstance(
                            pobjAssoc, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

                    if (FAILED(hr))
                    {
                        g_essTest.PrintError(
                            "Failed to put MSFT_EssTestEventFilterToTestFilter '%S' for item '%S': 0x%X", 
                            V_BSTR(&vTemp),
                            (BSTR) m_strName,
                            hr);

                        continue;
                    }

                    m_listFilters.push_back(pFilter);

                    // Keep a separate list of non-guarded filters for our
                    // temporary consumers.
                    if (pFilter->m_strCondition.length() == 0)
                        m_listNonGuardedFilters.push_back(pFilter);

                    g_essTest.PrintStatus(
                        "Loaded work filter '%S' for item '%S'.", 
                        V_BSTR(&vName),
                        (BSTR) m_strName);
                }
                else
                {
                    g_essTest.PrintError(
                        "Failed to init work filter '%S' for item '%S': 0x%X", 
                        V_BSTR(&vName),
                        (BSTR) m_strName,
                        hr);
                }
            }
            else
            {
                g_essTest.PrintStatus(
                    "Skipping disabled work filter '%S' for item '%S'.", 
                    V_BSTR(&vName),
                    (BSTR) m_strName);
            }
        }

        pEnum->Release();
    }
    else
    {
        g_essTest.PrintError(
            "Failed to enumerate work filters for item '%S': 0x%X", 
            (BSTR) m_strName,
            hr);
    }
    
    return hr;
}

HRESULT CWorkItem::InitConsumers()
{
    // Build up the consumers.
    HRESULT             hr;
    IWbemClassObjectPtr pConsumer;
    WCHAR               szDir[MAX_PATH * 2],
                        *pszLast;

    GetModuleFileNameW(NULL, szDir, sizeof(szDir));
    if ((pszLast = wcsrchr(szDir, '\\')) != NULL)
        *(pszLast + 1) = 0;
    else
        *szDir = 0;

    // Do the permanent consumers.
    if (SUCCEEDED(hr = 
        g_essTest.SpawnInstance(L"MSFT_WmiMofConsumer", &pConsumer)))
    {
        IWbemServices *pNamespace = g_essTest.GetDefNamespace();
        _variant_t    vBlobs(true);

        // Tell the consumer to save output as blobs instead of mofs.
        pConsumer->Put(L"SaveAsBlobs", 0, &vBlobs, 0);

        for (DWORD i = 0; i < m_nPermConsumers; i++)
        {
            WCHAR szName[100],
                  szFile[MAX_PATH * 2];

            swprintf(szName, L"I%02d_PC%03d.bin", m_dwID, i);
            wcscpy(szFile, szDir);
            wcscat(szFile, szName);

            // Get rid of any file with the same name.
            DeleteFileW(szFile);

            _variant_t vName = szName,
                       vFile = szFile;

            pConsumer->Put(L"Name", 0, &vName, 0);
            pConsumer->Put(L"MofFile", 0, &vFile, 0);

            hr = pNamespace->PutInstance(
                    pConsumer, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                CPermConsumer *pConsumer = new CPermConsumer;
                
                pConsumer->m_strName = szName;
                pConsumer->m_strFile = szFile;

                m_listPermConsumers.push_back(pConsumer);

                g_essTest.PrintStatus(
                    "Created MSFT_WmiMofConsumer=\"%S\"", 
                    szName);
            }
            else
            {
                g_essTest.PrintError(
                    "Failed to put MSFT_WmiMofConsumer=\"%S\" for item '%S': 0x%X", 
                    V_BSTR(&vName),
                    (BSTR) m_strName,
                    hr);
            }
        }
    }


    // Do the temporary consumers.
    for (DWORD i = 0; i < m_nTempConsumers; i++)
    {
        WCHAR szName[100],
              szFile[MAX_PATH * 2];

        swprintf(szName, L"I%02d_TC%03d.bin", m_dwID, i);
        wcscpy(szFile, szDir);
        wcscat(szFile, szName);

        // Get rid of any file with the same name.
        DeleteFileW(szFile);

        CTempConsumer *pConsumer = new CTempConsumer;
                
        pConsumer->m_strName = szName;
        pConsumer->m_strFile = szFile;

        m_listTempConsumers.push_back(pConsumer);

        g_essTest.PrintStatus(
            "Created temp consumer = \"%S\"", 
            szName);
    }

    return hr;
}

#define EXTRA_WAIT_TIME  7000
#define CYCLE_TIME       1000

void CWorkItem::AddFilterToAllConsumers(CWorkFilter *pFilter, DWORD dwTimestamp)
{
    for (CPConsumerListIterator perm = m_listPermConsumers.begin(); 
        perm != m_listPermConsumers.end(); 
        perm++)
    {
        CPermConsumer *pPerm = *perm;

        pPerm->AddFilter(pFilter, dwTimestamp);
    }
}

void CWorkItem::RemoveFilterFromAllConsumers(CWorkFilter *pFilter, DWORD dwTimestamp)
{
    for (CPConsumerListIterator perm = m_listPermConsumers.begin(); 
        perm != m_listPermConsumers.end(); 
        perm++)
    {
        CPermConsumer *pPerm = *perm;

        pPerm->RemoveFilter(pFilter, dwTimestamp);
    }
}

void CWorkItem::Run()
{
    HRESULT hr;

    if (FAILED(hr = InitFilters()))
    {
        g_essTest.PrintError(
            "Unable to init filters: 0x%X", hr);

        return;
    }

    if (FAILED(hr = InitConsumers()))
    {
        g_essTest.PrintError(
            "Unable to init consumers: 0x%X", hr);

        return;
    }

    // Add the full-time filters to the consumers.
    for (CWorkFilterListIterator filter = m_listFilters.begin();
        filter != m_listFilters.end();
        filter++)
    {
        CWorkFilter *pFilter = *filter;

        if (pFilter->m_type == FILTER_FULLTIME)
            AddFilterToAllConsumers(pFilter, 0);
    }

    for (DWORD iTime = 0; iTime < m_nTimesToRepeat; iTime++)
    {
        g_essTest.PrintStatus(
            "Work item '%S' execution #%d...", (BSTR) m_strName, iTime + 1);
        
        // Reset our permanent consumers.
        for (CPConsumerListIterator perm = m_listPermConsumers.begin(); 
            perm != m_listPermConsumers.end(); 
            perm++)
        {
            CPermConsumer *pPerm = *perm;

            // Remove all filters except for the full-time ones.
            pPerm->ResetFilterItems(TRUE);
        }

        // Start our temporary consumers.
        int nFilters = m_listNonGuardedFilters.size();

        for (int i = 0; i < m_listTempConsumers.size(); i++)
        {
            CTempConsumer *pTemp = m_listTempConsumers[i];

            // Add a filter to the temporary consumer.
            pTemp->SetFilter(m_listNonGuardedFilters[i % nFilters], 0);

            // Start the temporary consumer.
            pTemp->Start();
        }

        // Reset the on at/off at filters to waiting.
        for (CWorkFilterListIterator filter = m_listFilters.begin();
            filter != m_listFilters.end();
            filter++)
        {
            CWorkFilter *pFilter = *filter;

            if (pFilter->m_type == FILTER_ONAT_OFFAT)
                pFilter->m_state = FILTER_WAITING_TO_RUN;
        }


        Sleep(3000);

        // Launch the work item's command-line to generate the events.
        STARTUPINFO         startinfo = { sizeof(startinfo) };
        PROCESS_INFORMATION procinfo;

        GetStartupInfo(&startinfo);

        // Get out base timestamp.
        m_dwBaseTimestamp = GetTickCount();

        if (CreateProcess(
            NULL,
            m_strCommandLine,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,
            &startinfo,
            &procinfo))
        {
            CloseHandle(procinfo.hThread);
            
            // Wait for a second (or until our event process is done), then do
            // some work for the filters that come and go.
            while (WaitForSingleObject(procinfo.hProcess, CYCLE_TIME) == WAIT_TIMEOUT)
                CycleFilters();

            CloseHandle(procinfo.hProcess);

            // Wait a little to make sure all the events got through.
            Sleep(EXTRA_WAIT_TIME);
            
            g_essTest.LockOutput();

            g_essTest.PrintResult(
                "\n*** Work Item Results for '%S' (execution #%d) ***",
                (BSTR) m_strName,
                iTime + 1);

            for (CPConsumerListIterator perm = m_listPermConsumers.begin(); 
                perm != m_listPermConsumers.end(); 
                perm++)
            {
                CPermConsumer *pPerm = *perm;

                // Validate our results.
                pPerm->ValidateResults();
            }

            for (CTConsumerListIterator temp = m_listTempConsumers.begin(); 
                temp != m_listTempConsumers.end(); 
                temp++)
            {
                CTempConsumer *pTemp = *temp;

                // Validate our results.
                pTemp->ValidateResults();
            }

            g_essTest.UnlockOutput();
        }
        else
        {
            g_essTest.PrintStatus(
                "Work item '%S' failed to execute: %d\n" 
                "   Command-line: %S",
                (BSTR) m_strName, 
                GetLastError(),
                (BSTR) m_strCommandLine);
        }
    }
}

#define random(x)   (rand() % x)
#define NUM_CHANCES 10

void CWorkItem::CycleFilters()
{
    DWORD dwTimestamp = GetTickCount(),
          nElapsedSeconds = (dwTimestamp - m_dwBaseTimestamp) / 1000;

    for (CWorkFilterListIterator filter = m_listFilters.begin();
        filter != m_listFilters.end();
        filter++)
    {
        CWorkFilter *pFilter = *filter;

        if (pFilter->m_type == FILTER_ONAT_OFFAT)
        {
            if (pFilter->m_state == FILTER_WAITING_TO_RUN &&
                pFilter->m_dwOnAt <= nElapsedSeconds)
            {
                pFilter->m_state = FILTER_RUNNING;
                AddFilterToAllConsumers(pFilter, dwTimestamp);
            }
            else if (pFilter->m_state == FILTER_RUNNING &&
                pFilter->m_dwOffAt <= nElapsedSeconds)
            {
                pFilter->m_state = FILTER_DONE;
                RemoveFilterFromAllConsumers(pFilter, dwTimestamp);
            }
        }
        else if (pFilter->m_type == FILTER_RANDOM)
        {
            for (CPConsumerListIterator perm = m_listPermConsumers.begin(); 
                perm != m_listPermConsumers.end(); 
                perm++)
            {
                CPermConsumer *pPerm = *perm;
                DWORD         dwAction = random(NUM_CHANCES);

                if (dwAction == 0)
                    pPerm->AddFilter(pFilter, dwTimestamp);
                else if (dwAction == 1)
                    pPerm->RemoveFilter(pFilter, dwTimestamp);
            }
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// CConsumer

#define MAX_TRIES   30

CConsumer::~CConsumer()
{
    if (!g_essTest.KeepLogs() && m_strFile.length())
        DeleteFileW(m_strFile);
}

BOOL CConsumer::FileToObjs(CFlexArray &listEvents, IWbemServices *pNamespace)
{
    FILE *pFile;

    // Wait for the file to be readable.
    for (int i = 0; i <= MAX_TRIES; i++)
    {
        pFile = _wfsopen(m_strFile, L"rb", _SH_DENYWR);

        if (pFile)
            break;

        if (i < MAX_TRIES)
            Sleep(1000);
        else
        {
            g_essTest.PrintError(
                "Unable to open results file '%S': %d",
                (BSTR) m_strFile,
                GetLastError());

            return FALSE;
        }
    }
    
    // Build an array of _IWmiObjects from the events the consumer
    // received.
    _bstr_t          strClass = L"__EventFilter";
    IWbemClassObject *pClass = NULL;
    _IWmiObject      *pObj = NULL;
    HRESULT          hr;
    DWORD            dwSize;
    BYTE             cBuffer[64000];

    hr = 
        pNamespace->GetObject(
            strClass,
            0,
            NULL,
            &pClass,
            NULL);
            
    while(fread(&dwSize, 1, 4, pFile) == 4 &&
        fread(cBuffer, 1, dwSize, pFile) == dwSize)
    {
        BSTR   bstrObj = NULL;
        LPVOID pMem = CoTaskMemAlloc(dwSize);

        // Yes, I'm naughty and I know it!
        hr = pClass->SpawnInstance(0, (IWbemClassObject**) &pObj);

        memcpy(pMem, cBuffer, dwSize);
        hr = pObj->SetObjectMemory(pMem, dwSize);

        listEvents.Add(pObj);
    }

    pClass->Release();

	// We don't need this file anymore.
    fclose(pFile);

    return TRUE;
}

BOOL CConsumer::ValidatePermFilter(CFlexArray &listEvents, CFilterItem &item)
{
    _IWmiObject **ppEvents = (_IWmiObject**) listEvents.GetArrayPtr();
    DWORD       nEvents = listEvents.Size();

    for (DWORD i = 0; i < nEvents; i++)
    {
        if (ppEvents[i] != NULL && 
            item.m_table.FindInstance(
                ppEvents[i], TRUE, item.m_pFilter->m_pWorkItem->m_bFullCompare))
        {
            ppEvents[i]->Release();
            ppEvents[i] = NULL;
        }
    }

    if (item.m_table.GetNumMatched() == item.m_table.GetSize())
    {
        g_essTest.PrintResult(
            "SUCCESS: All events received for consumer '%S'<-->FTF '%S'.",
            (BSTR) m_strName,
            (BSTR) item.m_pFilter->m_strName);
    }
    else
    {
        g_essTest.PrintResult(
            "FAILURE: The following events were not received for consumer '%S'<-->FTF'%S':",
            (BSTR) m_strName,
            (BSTR) item.m_pFilter->m_strName);

        item.m_table.PrintUnmatchedObjMofs();
    }

    return TRUE;
}

BOOL CConsumer::ReportUnmatchedEvents(CFlexArray &listEvents, DWORD nMatched)
{
    DWORD nEvents = listEvents.Size();

    if (nMatched == nEvents)
    {
/* This seems like kind of a meaningless message...
        g_essTest.PrintResult(
            "SUCCESS: All events received by '%S' matched to filters.",
            (BSTR) m_strName);
*/
    }
    else
    {
        _IWmiObject **ppEvents = (_IWmiObject**) listEvents.GetArrayPtr();

        g_essTest.PrintResult(
            "FAILURE: The following events received by '%S' were not matched "
            "to any filters:",
            (BSTR) m_strName);

        for (DWORD i = 0; i < nEvents; i++)
        {
            if (ppEvents[i] != NULL)
            {
                HRESULT hr;
                BSTR    bstrObj = NULL;

                if (SUCCEEDED(hr = ppEvents[i]->GetObjectText(0, &bstrObj)))
                {
                    g_essTest.PrintResult("%S", bstrObj);
                
                    SysFreeString(bstrObj);
                }
                else
                    g_essTest.PrintResult(
                        "\n// IWbemClassObject::GetObjectText failed : 0x%X\n", hr);

                ppEvents[i]->Release();
            }
        }
    }        

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CPermConsumer

CPermConsumer::~CPermConsumer()
{
    _bstr_t    strPath;
    _variant_t vPath;
    HRESULT    hr;

    // Get rid of all bindings.
    ResetFilterItems(FALSE);
    
    GetPath(strPath);
    vPath = strPath;
    
    hr = g_essTest.GetDefNamespace()->DeleteInstance(
            V_BSTR(&vPath), 0, NULL, NULL);
}

BOOL CPermConsumer::ValidateResults()
{
    CFlexArray listEvents;
    IWbemServices *pNamespace = (*m_listFilters.begin()).m_pFilter->
                                    m_pWorkItem->m_pNamespace;

    if (!FileToObjs(listEvents, pNamespace))
        return FALSE;


    _IWmiObject **ppEvents = (_IWmiObject**) listEvents.GetArrayPtr();
    DWORD       nEvents = listEvents.Size(),
                nMatched = 0;

    /////////////////////////////////////////////////////////////////////////
    // Validation Step 1:
    // See if the full-time consumers got all of their expected events.

    for (CFilterItemListIterator filter = m_listFilters.begin();
        filter != m_listFilters.end();
        filter++)
    {
        CFilterItem &item = *filter;

        if (item.m_pFilter->m_type == FILTER_FULLTIME)
        {
            ValidatePermFilter(listEvents, item);
            nMatched += item.m_table.GetNumMatched();
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Validation Step 2:
    // Check the non-full-time filters.

    for (filter = m_listFilters.begin();
        filter != m_listFilters.end();
        filter++)
    {
        CFilterItem &item = *filter;

        if (item.m_pFilter->m_type != FILTER_FULLTIME)
        {
            for (DWORD i = 0; i < nEvents; i++)
            {
                if (ppEvents[i] != NULL && 
                    item.m_table.FindInstance(
                        ppEvents[i], FALSE, item.m_pFilter->m_pWorkItem->m_bFullCompare))
                {
                    ppEvents[i]->Release();
                    ppEvents[i] = NULL;
                    nMatched++;
                }
            }

            g_essTest.PrintStatus(
                "%d events received for consumer '%S'<-->PTF '%S'.",
                item.m_table.GetNumMatched(),
                (BSTR) m_strName,
                (BSTR) item.m_pFilter->m_strName);
        }
    }

    /////////////////////////////////////////////////////////////////////////
    // Validation Step 3:
    // Report any unmatched events left over as an error.

    ReportUnmatchedEvents(listEvents, nMatched);

    return TRUE;
}

void CPermConsumer::GetPath(_bstr_t &strPath)
{
    WCHAR szPath[MAX_PATH * 2];

    swprintf(szPath, L"MSFT_WmiMofConsumer=\"%s\"", (BSTR) m_strName);

    strPath = szPath;
}

HRESULT CPermConsumer::GetBindingObj(CWorkFilter *pFilter, IWbemClassObject **ppBinding)
{
    HRESULT hr;
            
    if (SUCCEEDED(hr = 
        g_essTest.SpawnInstance(L"__FilterToConsumerBinding", ppBinding)))
    {
        _bstr_t strConsumerPath,
                strFilterPath;
        
        GetPath(strConsumerPath);
        pFilter->GetPath(strFilterPath);

        _variant_t vTemp;

        vTemp = strConsumerPath;
        hr = (*ppBinding)->Put(L"Consumer", 0, &vTemp, 0);

        if (SUCCEEDED(hr))
        {
            vTemp = strFilterPath;
            hr = (*ppBinding)->Put(L"Filter", 0, &vTemp, 0);

            vTemp = true;
            hr = (*ppBinding)->Put(L"SlowDownProviders", 0, &vTemp, 0);
        }
    }

    return hr;
}

void CPermConsumer::AddFilter(CWorkFilter *pFilter, DWORD dwTimestamp)
{
    HRESULT             hr;
    IWbemClassObjectPtr pBinding;
            
    // See if we already have an active filter of this type.  We can
    // tell by looking in our list for an item where m_pFilter ==
    // pFilter && m_dwEnd == 0.
    for (CFilterItemListIterator filter = m_listFilters.begin();
        filter != m_listFilters.end();
        filter++)
    {
        CFilterItem &item = *filter;

        if (item.m_pFilter == pFilter && item.m_dwEnd == 0)
            return;
    }

    if (SUCCEEDED(hr = 
        GetBindingObj(pFilter, &pBinding)))
    {
        _variant_t vPath;

        hr = g_essTest.GetDefNamespace()->PutInstance(
                pBinding, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL);

        pBinding->Get(L"__RELPATH", 0, &vPath, NULL, NULL);

        if (SUCCEEDED(hr))
        {
            CFilterItem item(dwTimestamp);

            item.m_dwBegin = dwTimestamp;
            item.m_pFilter = pFilter;

            m_listFilters.push_back(item);

            // Make the newly inserted item share the filter's table.
            CFilterItem &itemNew = m_listFilters.back();

            itemNew.m_table = pFilter->m_table;

            g_essTest.PrintStatus(
                "Created %S", 
                V_BSTR(&vPath));
        }
        else
        {
            g_essTest.PrintError(
                "Failed to put '%S': 0x%X", 
                V_BSTR(&vPath),
                hr);
        }
    }
    else
    {
        g_essTest.PrintError(
            "Failed to get instance of __FilterToConsumerBinding: 0x%X",
            hr);
    }
}

HRESULT CPermConsumer::RemoveBinding(CWorkFilter *pFilter)
{
    IWbemClassObjectPtr pBinding;
    HRESULT             hr;

    if (SUCCEEDED(hr = 
        GetBindingObj(pFilter, &pBinding)))
    {
        _variant_t vPath;

        pBinding->Get(L"__RELPATH", 0, &vPath, NULL, NULL);

        hr = g_essTest.GetDefNamespace()->DeleteInstance(
                V_BSTR(&vPath), 0, NULL, NULL);

        if (FAILED(hr))
        {
            g_essTest.PrintError(
                "Failed to delete '%S': 0x%X", 
                V_BSTR(&vPath),
                hr);
        }
    }
    else
    {
        g_essTest.PrintError(
            "Failed to get instance of __FilterToConsumerBinding: 0x%X",
            hr);
    }

    return hr;
}

void CPermConsumer::RemoveFilter(CWorkFilter *pFilter, DWORD dwTimestamp)
{
    // See if we have an active filter of this type.  If not, get out.
    for (CFilterItemListIterator filter = m_listFilters.begin();
        filter != m_listFilters.end();
        filter++)
    {
        CFilterItem &item = *filter;

        if (item.m_pFilter == pFilter && item.m_dwEnd == 0)
            break;
    }

    if (filter == m_listFilters.end())
        return;
    
    (*filter).m_dwEnd = dwTimestamp;

    RemoveBinding(pFilter);
}

void CPermConsumer::ResetFilterItems(BOOL bKeepFulltime)
{
    // See if we have an active filter of this type.  If not, get out.
    for (CFilterItemListIterator filter = m_listFilters.begin();
        filter != m_listFilters.end();
        )
    {
        CFilterItem &item = *filter;

        if (bKeepFulltime && item.m_pFilter->m_type == FILTER_FULLTIME)
        {
            filter++;
            continue;
        }

        if (item.m_dwEnd == 0)
        {
            RemoveBinding(item.m_pFilter);
            filter = m_listFilters.erase(filter);
        }
        else
            filter++;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CTempConsumer

CTempConsumer::CTempConsumer() :
    m_hProcess(NULL),
    m_itemFilter(0)
{
}

CTempConsumer::~CTempConsumer()
{
    if (m_hProcess)
        CloseHandle(m_hProcess);
}

#define MAX_TEMP_WAIT   30000

BOOL CTempConsumer::ValidateResults()
{
    // Wait for the file to be readable.
    DWORD dwWait = WaitForSingleObject(m_hProcess, MAX_TEMP_WAIT);

    if (dwWait == WAIT_TIMEOUT)
    {
        g_essTest.PrintError(
            "Temporary subscriber '%S' never terminated.\n",
            (BSTR) m_strName);

        return FALSE;
    }
        
    CFlexArray    listEvents;
    IWbemServices *pNamespace;

    pNamespace = m_itemFilter.m_pFilter->m_pWorkItem->m_pNamespace;

    if (!FileToObjs(listEvents, pNamespace))
        return FALSE;


    _IWmiObject **ppEvents = (_IWmiObject**) listEvents.GetArrayPtr();
    DWORD       nEvents = listEvents.Size(),
                nMatched = 0;

    /////////////////////////////////////////////////////////////////////////
    // Validation Step 1:
    // See if the full-time consumer got all of their expected events.

    ValidatePermFilter(listEvents, m_itemFilter);
    nMatched += m_itemFilter.m_table.GetNumMatched();


    /////////////////////////////////////////////////////////////////////////
    // Validation Step 2:
    // Report any unmatched events left over as an error.

    ReportUnmatchedEvents(listEvents, nMatched);

    return TRUE;
}

void CTempConsumer::SetFilter(CWorkFilter *pFilter, DWORD dwTimestamp)
{
    m_itemFilter.m_dwBegin = dwTimestamp;
    m_itemFilter.m_pFilter = pFilter;

    m_itemFilter.m_table = pFilter->m_table;

    g_essTest.PrintStatus(
        "Created temp consumer, query = \"%S\"", 
        (BSTR) pFilter->m_strQuery);
}

void CTempConsumer::Start()
{
    WCHAR *szCmd = new WCHAR[wcslen(m_itemFilter.m_pFilter->m_strQuery) + 
                    wcslen(m_strFile) + 100];

    swprintf(
        szCmd,
        L"EventDmp /Nroot\\cimv2 /T30 \"/B%s\" \"%s\"",
        (BSTR) m_strFile,
        (BSTR) m_itemFilter.m_pFilter->m_strQuery);

    // Launch the work item's command-line to generate the events.
    STARTUPINFOW        startinfo = { sizeof(startinfo) };
    PROCESS_INFORMATION procinfo;

    GetStartupInfoW(&startinfo);

    if (CreateProcessW(
        NULL,
        szCmd,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &startinfo,
        &procinfo))
    {
        CloseHandle(procinfo.hThread);

        m_hProcess = procinfo.hProcess;

        g_essTest.PrintStatus(
            "Temp consumer '%S' started.\n" 
            "   Command-line: %S",
            (BSTR) m_strName, 
            szCmd);
    }
    else
    {
        g_essTest.PrintError(
            "Temp consumer '%S' failed to execute: %d\n" 
            "   Command-line: %S",
            (BSTR) m_strName, 
            GetLastError(),
            szCmd);
    }

    delete [] szCmd;
}

/////////////////////////////////////////////////////////////////////////////
// CWorkFilter

CWorkFilter::~CWorkFilter()
{
    _bstr_t              strPath;
    _variant_t           vPath;
    HRESULT              hr;

    GetPath(strPath);
    vPath = strPath;
    
    // Kill everything referencing our path.
    g_essTest.DeleteReferences(strPath);

    hr = g_essTest.GetDefNamespace()->DeleteInstance(
            V_BSTR(&vPath), 0, NULL, NULL);
}

void CWorkFilter::GetPath(_bstr_t &strPath)
{
    WCHAR szPath[MAX_PATH * 2];

    swprintf(szPath, L"__EventFilter=\"%s\"", (BSTR) m_strName);

    strPath = szPath;
}

void CWorkFilter::GetAssocPath(_bstr_t &strPath)
{
    WCHAR szPath[MAX_PATH * 2];

    swprintf(szPath, L"__EventFilter=\"%s\"", (BSTR) m_strName);

    strPath = szPath;
}

HRESULT CWorkFilter::Init(IWbemClassObject *pTestFilter, CWorkItem *pItem)
{
    HRESULT    hr;
    _variant_t vTemp;

    m_pWorkItem = pItem;

    // Load the work item's properties.
    if (SUCCEEDED(hr = pTestFilter->Get(L"Name", 0, &vTemp, NULL, NULL)))
    {
        m_strName = V_BSTR(&vTemp);

        if (SUCCEEDED(hr = pTestFilter->Get(L"Query", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_BSTR)
            m_strQuery = V_BSTR(&vTemp);
        else
            return hr;

        if (SUCCEEDED(hr = pTestFilter->Get(L"Condition", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_BSTR)
            m_strCondition = V_BSTR(&vTemp);

        if (SUCCEEDED(hr = pTestFilter->Get(L"ConditionNamespace", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_BSTR)
            m_strConditionNamespace = V_BSTR(&vTemp);

        if (SUCCEEDED(hr = pTestFilter->Get(L"Behavior", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_I4)
        {
            m_type = (FILTER_BEHAVIOR) (long) vTemp;
            if (m_type > FILTER_RANDOM)
                m_type = FILTER_RANDOM;

            if (m_type == FILTER_ONAT_OFFAT)
            {
                if (SUCCEEDED(hr = pTestFilter->Get(L"OnAt", 0, &vTemp, NULL, NULL)) &&
                    vTemp.vt == VT_I4)
                    m_dwOnAt = (long) vTemp;

                if (SUCCEEDED(hr = pTestFilter->Get(L"OffAt", 0, &vTemp, NULL, NULL)) &&
                    vTemp.vt == VT_I4)
                    m_dwOffAt = (long) vTemp;
            }
        }
        else
            return hr;

        if (SUCCEEDED(hr = pTestFilter->Get(L"ScriptRule", 0, &vTemp, NULL, NULL)) &&
            vTemp.vt == VT_BSTR)
        {
            _bstr_t strFileName;

            if (pItem->CreateScriptResultsFile(V_BSTR(&vTemp), strFileName))
            {
                BOOL bRet = m_table.BuildFromMofFile(
                                pItem->m_pNamespace, 
                                strFileName);

                if (!bRet)
                {
                    g_essTest.PrintError(
                        "Unable to create instance table from rule '%S'.",
                        V_BSTR(&vTemp));

                    hr = WBEM_E_FAILED;
                }

                if (!g_essTest.KeepLogs() && strFileName.length())
                    DeleteFileW(strFileName);
            }
        }
        else
            return hr;

    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Utility functions

void ReplaceString(_bstr_t &strSrc, LPCWSTR szFind, LPCWSTR szReplace)
{
    _bstr_t strTemp = (LPWSTR) strSrc;
    LPWSTR  szFound = wcsstr((LPWSTR) strTemp, szFind);

    if (szFound)
    {
        *szFound = 0;
        szFound += wcslen(szFind);

        strSrc = (LPWSTR) strTemp;
        strSrc += szReplace;
        strSrc += szFound;
    }
}

HRESULT InsertReplacementStrings(_bstr_t &str, IWbemClassObject *pObj)
{
    HRESULT hr = S_OK;
    LPWSTR  szFirst,
            szSecond;

    do
    {
        _bstr_t strTemp = (LPWSTR) str;
        
        szFirst = wcschr((LPWSTR) strTemp, '%');
    
        if (szFirst)
        {
            szSecond = wcschr(szFirst + 1, '%');
    
            if (szSecond)
            {
                *szFirst = 0;
                *szSecond = 0;

                _variant_t vValue;
                WCHAR      szValue[512];
                CIMTYPE    type;
            
                if (SUCCEEDED(hr = pObj->Get(szFirst + 1, 0, &vValue, &type, NULL)))
                {
                    if (vValue.vt == VT_BSTR)
                        wcscpy(szValue, V_BSTR(&vValue));
                    else if (type == CIM_UINT32)
                        swprintf(szValue, L"%u", (long) vValue);
                    else if (type == CIM_SINT32)
                        swprintf(szValue, L"%d", (long) vValue);
                    else
                        // TODO: Do we need more types than this?
                        *szValue = 0;

                    str = (LPWSTR) strTemp;
                    str += szValue;
                    str += szSecond + 1;
                }
            }
        }
    
    } while (szFirst && szSecond && SUCCEEDED(hr));

    return hr;
}

void EscapeQuotedString(_bstr_t &str)
{
    WCHAR  *pszTemp = (WCHAR*) malloc(str.length() * 2 * sizeof(WCHAR));
    LPWSTR szSrc,
           szDest = pszTemp;

    for (szSrc = str; *szSrc; szSrc++)
    {
        switch(*szSrc)
        {
            case '\\':
            case '\"':
                *szDest = '\\';
                szDest++;
                break;
        }

        *szDest = *szSrc;
        szDest++;
    }

    *szDest = 0;

    str = pszTemp;
    free(pszTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\validate.h ===
// Validate.h

#ifndef _VALIDATE_H
#define _VALIDATE_H

#include <list>
#include <flexarry.h>

/*
class CInstance;

class CProperty
{
public:
    _bstr_t   m_strName;
    CIMTYPE   m_type;
    DWORD     m_dwValue;
    _bstr_t   m_strValue;
    CInstance *m_pValue;

    
    CProperty();
    ~CProperty();

    BOOL ObjHasProperty(IWbemClassObject *pObj);
    void Print();
};

class CInstance
{
public:
    _bstr_t    m_strName;
    CFlexArray m_listProps;
    
    ~CInstance();

    BOOL DoesMatchObject(IWbemClassObject *pObj);
    void Print();
};
*/

class CIntRange
{
public:
    DWORD m_iBegin,
          m_iEnd;
};

typedef std::list<CIntRange> CIntRangeList;
typedef std::list<CIntRange>::iterator CIntRangeListItor;

class CInstTable
{
public:
    CInstTable();
    ~CInstTable();

    BOOL BuildFromRule(IWbemServices *pNamespace, LPCWSTR szRule);
    BOOL BuildFromMofFile(IWbemServices *pNamespace, LPCWSTR szMofFile);

    BOOL FindInstance(
        IWbemClassObject *pObj, 
        BOOL bTrySkipping,
        BOOL bFullCompare);

    BOOL GetNumMatched() { return m_nMatched; }
    BOOL GetSize() { return m_pListEvents->Size(); }

    // Used to get a copy that uses other's CInstance*'s.
    const CInstTable& operator=(const CInstTable &other);

    void PrintUnmatchedObjMofs();

protected:
    DWORD      m_dwLastFoundIndex,
               m_nMatched;
    CFlexArray *m_pListEvents;
    BOOL       m_bAllocated;
    CIntRangeList m_listMissed;

    BOOL AddScalarInstances(
        IWbemServices *pNamespace, 
        LPCWSTR szClassName, 
        LPCWSTR szPropName, 
        DWORD dwBegin, 
        DWORD dwEnd);

    HRESULT AltCompareTo(IWbemClassObject *pSrc, IWbemClassObject *pDest);
    BOOL CompareTo(VARIANT *pvarSrc, VARIANT *pvarDest);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\eventdmp\eventdmp.cpp ===
// EventDmp.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Args:
// Namespace
// Query
// Timeout

void PrintUsage()
{
    printf(
        "Subscribes to a WMI event query and prints received events.\n"
        "\n"
        "EVENTDMP [/Nnamespace] [/Ttimeout] [/Bfilename] [/M] query\n"
        "\n"
        "/N   Namespace to use (root\\default used by default).                 \n"
        "/T   Specifies the number of seconds EVENTDMP should wait to terminate \n"
        "     after getting an event.  When another event is received the count-\n"
        "     down starts over.  -1 (the default value) indicates there is no   \n"
        "     timeout.\n"
        "/B   Write _IWmiObject blobs to filename instead of printing MOFs to   \n"
        "     stdout.\n"
        "/M   Perform the query as a monitor query.\n"
    );
}

HANDLE heventReceived;

class CObjSink : public IWbemObjectSink
{
public:
    CObjSink() :
        m_lRef(0)
    { 
    }

public:
    STDMETHODIMP QueryInterface(REFIID refid, PVOID *ppThis)
    { 
        if (refid == IID_IUnknown)
            *ppThis = (IUnknown*) this;
        else if (refid == IID_IWbemObjectSink)
            *ppThis = (IWbemObjectSink*) this;
        else
            return E_NOINTERFACE;

        AddRef();

        return S_OK;
    }

    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&m_lRef);
    }

    STDMETHODIMP_(ULONG) Release(void)
    {
        LONG lRet = InterlockedDecrement(&m_lRef);

        if (lRet == 0)
            delete this;

        return lRet; 
    }

    HRESULT STDMETHODCALLTYPE SetStatus(
        LONG lFlags,
        HRESULT hResult, 
        BSTR strParam, 
        IWbemClassObject *pObjParam);

protected:
    LONG m_lRef;
};

class CMofSink : public CObjSink
{
public:
    // IWbemObjectSink
    HRESULT STDMETHODCALLTYPE Indicate(
        LONG lObjectCount,
        IWbemClassObject **ppObjArray);
};

#define MAX_OBJ_SIZE    32000

class CBinSink : public CObjSink
{
public:
    CBinSink() :
        m_pFile(NULL)
    {
    }

    BOOL Init(LPSTR szFilename)
    {
        m_pFile = fopen(szFilename, "wb");

        return m_pFile != NULL;
    }

    ~CBinSink()
    {
        if (m_pFile)
            fclose(m_pFile);
    }

public:
    // IWbemObjectSink
    HRESULT STDMETHODCALLTYPE Indicate(
        LONG lObjectCount,
        IWbemClassObject **ppObjArray);

protected:
    FILE *m_pFile;
    BYTE m_pBuffer[MAX_OBJ_SIZE];
};

int __cdecl main(int argc, char* argv[])
{
	IWbemLocator *pLocator = NULL;
    DWORD        dwTimeout = INFINITE;
    LPSTR        szNamespace = "root\\default",
                 szBinFilename = NULL,
                 szQuery = NULL;
    DWORD        dwFlags = 0;

    for (int i = 1; i < argc; i++)
    {
        LPSTR szArg = argv[i];

        if (szArg[0] == '/' || szArg[0] == '-')
        {
            switch(toupper(szArg[1]))
            {
                case 'N':
                    szNamespace = &szArg[2];
                    break;

                case 'B':
                    szBinFilename = &szArg[2];
                    break;

                case 'T':
                    dwTimeout = atoi(&szArg[2]) * 1000;
                    break;

                case 'M':
                    dwFlags = WBEM_FLAG_MONITOR;
                    break;

                default:
                    PrintUsage();
                    return 1;
            }
        }
        else
            szQuery = szArg;
    }                    
            
    if (!szQuery)
    {
        PrintUsage();
        return 1;
    }


    HRESULT hr;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if ((hr = CoCreateInstance(
        CLSID_WbemLocator,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator,
		(LPVOID *) &pLocator)) == S_OK)
    {
        IWbemServices *pNamespace = NULL;
        _bstr_t       strNamespace = szNamespace;

        if ((hr = pLocator->ConnectServer(
            strNamespace,
			NULL,    // username
			NULL,	 // password
			NULL,    // locale
			0L,		 // securityFlags
			NULL,	 // authority (domain for NTLM)
			NULL,	 // context
			&pNamespace)) == S_OK) 
        {	
            _bstr_t  strWQL = L"WQL",
                     strQuery = szQuery;
            CObjSink *pSink;

            pLocator->Release();

            if (!szBinFilename)
                pSink = new CMofSink;
            else
            {
                CBinSink *pBinSink = new CBinSink;

                if (pBinSink->Init(szBinFilename))
                    pSink = pBinSink;
                else
                {
                    printf("Unable to open '%s'.\n", szBinFilename);
                    pNamespace->Release();
                    return 1;
                }
            }

            heventReceived = CreateEvent(NULL, FALSE, FALSE, NULL);
            
            if (SUCCEEDED(hr = 
                pNamespace->ExecNotificationQueryAsync(
                    strWQL,
                    strQuery,
                    dwFlags,
                    NULL,
                    pSink)))
            {
                while (WaitForSingleObject(heventReceived, dwTimeout) != WAIT_TIMEOUT)
                {
                }

                pNamespace->CancelAsyncCall(pSink);
            }
            else
                printf("ExecNotificationQueryAsync failed: 0x%X\n", hr);

            pNamespace->Release();

            CloseHandle(heventReceived);
        }
        else
        {
            printf("IWbemLocator::ConnectServer failed: 0x%X\n", hr);
            
            pLocator->Release();
        }
    }
    else
        printf("CoCreateInstance for CLSID_WbemLocator failed: 0x%X\n", hr);

    CoUninitialize();

	return 0;
}

HRESULT STDMETHODCALLTYPE CMofSink::Indicate(
    LONG nEvents,
    IWbemClassObject **ppEvents)
{
    // Stop us from timing out.
    SetEvent(heventReceived);

    for (int i = 0; i < nEvents; i++)
    {
        BSTR    bstrObj = NULL;
        HRESULT hr;

        if (SUCCEEDED(hr = ppEvents[i]->GetObjectText(0, &bstrObj)))
        {
            printf("%S", bstrObj);
                
            SysFreeString(bstrObj);
        }
        else
            printf(
                "\n// IWbemClassObject::GetObjectText failed : 0x%X\n", hr);
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CBinSink::Indicate(
    LONG nEvents,
    IWbemClassObject **ppEvents)
{
    // Stop us from timing out.
    SetEvent(heventReceived);

    for (int i = 0; i < nEvents; i++)
    {
        HRESULT     hr;
        _IWmiObject *pObj = NULL;

        if (SUCCEEDED(hr = ppEvents[i]->QueryInterface(
            IID__IWmiObject, (LPVOID*) &pObj)))
        {
            DWORD dwRead;

            hr = 
                pObj->GetObjectParts(
                    m_pBuffer, 
                    MAX_OBJ_SIZE, 
                    WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                        WBEM_OBJ_CLASS_PART,
                    &dwRead);

            if (SUCCEEDED(hr))
            {
                fwrite(&dwRead, 1, sizeof(dwRead), m_pFile);
                fwrite(m_pBuffer, 1, dwRead, m_pFile);
            }

            pObj->Release();
        }
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CObjSink::SetStatus(
    LONG lFlags,
    HRESULT hResult, 
    BSTR strParam, 
    IWbemClassObject *pObjParam)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\workitem.h ===
// WorkItem.h

#ifndef _WORKITEM_H
#define _WORKITEM_H

#include "Validate.h"
#include <vector>

enum FILTER_BEHAVIOR
{
    FILTER_DISABLED,
    FILTER_FULLTIME,
    FILTER_ONAT_OFFAT,
    FILTER_RANDOM
};

enum FILTER_STATE
{
    FILTER_WAITING_TO_RUN,
    FILTER_RUNNING,
    FILTER_DONE
};

class CWorkItem;

class CWorkFilter
{
public:
    _bstr_t         m_strName,
                    m_strQuery,
                    m_strCondition,
                    m_strConditionNamespace;
    FILTER_STATE    m_state;
    DWORD           m_dwOnAt,
                    m_dwOffAt;
    FILTER_BEHAVIOR m_type;
    CInstTable      m_table;
    CWorkItem       *m_pWorkItem;

    ~CWorkFilter();

    HRESULT Init(IWbemClassObject *pTestFilter, CWorkItem *pItem);

    void GetPath(_bstr_t &strPath);
    void GetAssocPath(_bstr_t &strPath);
};

class CFilterItem
{
public:
    CFilterItem(DWORD dwBeginTimestamp) :
        m_dwBegin(dwBeginTimestamp),
        m_dwEnd(0),
        m_pFilter(NULL)
    {
    }

    DWORD       m_dwBegin,
                m_dwEnd;
    CWorkFilter *m_pFilter;
    CInstTable  m_table;
};

class CConsumer
{
public:
    _bstr_t m_strName,
            m_strFile;

    CConsumer() {}
    virtual ~CConsumer();

    virtual BOOL ValidateResults() = 0;

    BOOL FileToObjs(CFlexArray &listEvents, IWbemServices *pNamespace);
    BOOL ValidatePermFilter(CFlexArray &listEvents, CFilterItem &item);
    BOOL ReportUnmatchedEvents(CFlexArray &listEvents, DWORD nMatched);
};

class CPermConsumer : public CConsumer
{
public:
    typedef std::list<CFilterItem> CFilterItemList;
    typedef std::list<CFilterItem>::iterator CFilterItemListIterator;

    CFilterItemList m_listFilters;

    CPermConsumer() {}
    virtual ~CPermConsumer();
    BOOL ValidateResults();

    void AddFilter(CWorkFilter *pFilter, DWORD dwTimestamp);
    void RemoveFilter(CWorkFilter *pFilter, DWORD dwTimestamp);

    void ResetFilterItems(BOOL bKeepFulltime);

    HRESULT GetBindingObj(CWorkFilter *pFilter, IWbemClassObject **ppBinding);

    void GetPath(_bstr_t &strPath);

protected:
    HRESULT RemoveBinding(CWorkFilter *pFilter);
};

class CTempConsumer : public CConsumer
{
public:
    CFilterItem m_itemFilter;
    HANDLE      m_hProcess;

    CTempConsumer();
    virtual ~CTempConsumer();

    virtual BOOL ValidateResults();
    void SetFilter(CWorkFilter *pFilter, DWORD dwTimestamp);
    void Start();
};

class CWorkItem
{
public:
    typedef std::vector<CWorkFilter*> CWorkFilterList;
    typedef std::vector<CWorkFilter*>::iterator CWorkFilterListIterator;

    typedef std::vector<CPermConsumer*> CPConsumerList;
    typedef std::vector<CPermConsumer*>::iterator CPConsumerListIterator;

    typedef std::vector<CTempConsumer*> CTConsumerList;
    typedef std::vector<CTempConsumer*>::iterator CTConsumerListIterator;

    _bstr_t m_strName,
            m_strGeneratorName,
            m_strCommandLine,
            m_strRawScript,
            m_strEventGenFile;
    DWORD   m_nEvents,
            m_nTimesToRepeat,
            m_nPermConsumers,
            m_nTempConsumers,
            m_dwBaseTimestamp;
    BOOL    m_bSlowDownProviders,
            m_bFullCompare;
    IWbemServicesPtr m_pNamespace;

    CWorkItem();
    ~CWorkItem();

    HRESULT Init(IWbemClassObject *pObj, DWORD dwID);
    void Run();

    void CycleFilters();

    BOOL CreateScriptResultsFile(LPCWSTR szRule, _bstr_t &strFileName);

protected:
    CPConsumerList  m_listPermConsumers;
    CTConsumerList  m_listTempConsumers;
    CWorkFilterList m_listFilters,
                    m_listNonGuardedFilters;
    DWORD           m_dwID;
    
    HRESULT InitFilters();
    HRESULT InitConsumers();
    
    void AddFilterToAllConsumers(CWorkFilter *pFilter, DWORD dwTimestamp);
    void RemoveFilterFromAllConsumers(CWorkFilter *pFilter, DWORD dwTimestamp);
};

/////////////////////////////////////////////////////////////////////////////
// Utility functions

void ReplaceString(_bstr_t &strSrc, LPCWSTR szFind, LPCWSTR szReplace);
HRESULT InsertReplacementStrings(_bstr_t &str, IWbemClassObject *pObj);

void EscapeQuotedString(_bstr_t &str);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\esst\validate.cpp ===
// Validate.cpp

#include "stdafx.h"
#include "Validate.h"
#include "..\utils\Mof2Inst.h"

/////////////////////////////////////////////////////////////////////////////
// CProperty

/*
CProperty::CProperty() :
    m_pValue(NULL)
{
}                                   

CProperty::~CProperty()
{
    if (m_pValue)
        delete m_pValue;
}

BOOL CProperty::ObjHasProperty(IWbemClassObject *pObj)
{
    _variant_t vValue;
    BOOL       bRet = FALSE;

    if (SUCCEEDED(pObj->Get(m_strName, 0, &vValue, NULL, NULL)))
    {
        if (m_type == CIM_UINT32)
        {
            switch(vValue.vt)
            {
                case VT_I4:
                    bRet = (long) m_dwValue == (long) vValue;
                    break;

                case VT_UI1:
                    bRet = (BYTE) m_dwValue == (BYTE) vValue;
                    break;

                case VT_I2:
                    bRet = (short) m_dwValue == (short) vValue;
                    break;

                default:
                    break;
            }
        }
        else if (m_type == CIM_STRING && vValue.vt == VT_BSTR)
            bRet = !_wcsicmp(m_strValue, V_BSTR(&vValue));
        else if (m_type == CIM_OBJECT)
            bRet = m_pValue->DoesMatchObject((IWbemClassObject*) (IUnknown*) vValue);
    }
    
    return bRet;        
}

void CProperty::Print()
{
    printf("    %S = ", (BSTR) m_strName);

    if (m_type == CIM_UINT32)
        printf("%u;\n", m_dwValue);
    else if (m_type == CIM_STRING)
        printf("\"%S\";\n", m_strValue);
    else if (m_type == CIM_OBJECT)
        m_pValue->Print();
}
*/

/////////////////////////////////////////////////////////////////////////////
// CInstance

/*
CInstance::~CInstance()
{
    DWORD     nCount = m_listProps.Size();
    CProperty **ppProps = (CProperty**) m_listProps.GetArrayPtr();

    for (DWORD i = 0; i < nCount; i++)
        delete ppProps[i];
}

BOOL CInstance::DoesMatchObject(IWbemClassObject *pObj)
{
    _variant_t vClass;
    HRESULT    hr;
    BOOL       bRet;

    hr = pObj->Get(L"__CLASS", 0, &vClass, NULL, NULL);

    if (SUCCEEDED(hr) && !_wcsicmp(m_strName, V_BSTR(&vClass)))
    {
        DWORD     nCount = m_listProps.Size();
        CProperty **ppProps = (CProperty**) m_listProps.GetArrayPtr();

        bRet = TRUE;
        for (DWORD i = 0; i < nCount && bRet; i++)
            bRet = ppProps[i]->ObjHasProperty(pObj);
    }
    else
        bRet = FALSE;

    return bRet;
}

void CInstance::Print()
{
    printf(
        "instance of %S\n"
        "{\n",
        (BSTR) m_strName);

    DWORD     nCount = m_listProps.Size();
    CProperty **ppProps = (CProperty**) m_listProps.GetArrayPtr();

    for (DWORD i = 0; i < nCount; i++)
        ppProps[i]->Print();

    printf("};\n\n");
}
*/

/////////////////////////////////////////////////////////////////////////////
// CInstTable

CInstTable::CInstTable() :
    m_dwLastFoundIndex((DWORD) -1),
    m_nMatched(0),
    m_bAllocated(FALSE),
    m_pListEvents(NULL)
{                      
}

const CInstTable& CInstTable::operator=(const CInstTable &other)
{
    m_pListEvents = other.m_pListEvents;
    m_nMatched = 0;
    m_bAllocated = FALSE;
    m_dwLastFoundIndex = -1;

    return *this;    
}

CInstTable::~CInstTable()
{
    if (m_pListEvents && m_bAllocated)
    {
        DWORD            nCount = m_pListEvents->Size();
        IWbemClassObject **ppInst = (IWbemClassObject**) m_pListEvents->GetArrayPtr();

        for (DWORD i = 0; i < nCount; i++)
            ppInst[i]->Release();

        delete m_pListEvents;
    }
}

BOOL CInstTable::BuildFromRule(IWbemServices *pNamespace, LPCWSTR szRule)
{
    LPWSTR szTemp = _wcsdup(szRule),
           szRuleName = wcstok(szTemp, L"("),
           szClassName = wcstok(NULL, L"."),
           szVar = wcstok(NULL, L"):"),
           szNext;
    BOOL   bRet = TRUE;
    
    m_bAllocated = TRUE;
    m_pListEvents = new CFlexArray;

    if (!_wcsicmp(szRuleName, L"RANGES"))
    {
        for (szNext = wcstok(NULL, L":,"); 
            szNext != NULL && bRet; 
            szNext = wcstok(NULL, L","))
        {
            LPWSTR szEnd = wcschr(szNext, '-');

            if (szEnd)
            {
                bRet = 
                    AddScalarInstances(
                        pNamespace,
                        szClassName, 
                        szVar, 
                        _wtoi(szNext), 
                        _wtoi(szEnd + 1));
            }
            else
                bRet = FALSE;
        }
    }
    else if (!_wcsicmp(szRuleName, L"INCLUDES"))
    {
        for (szNext = wcstok(NULL, L":,"); 
            szNext != NULL && bRet; 
            szNext = wcstok(NULL, L","))
        {
            int iValue = _wtoi(szNext);

            bRet = 
                AddScalarInstances(pNamespace, szClassName, szVar, iValue, iValue);
        }
    }
    else
        bRet = FALSE;

    free(szTemp);
    
    return bRet;
}

BOOL CInstTable::BuildFromMofFile(IWbemServices *pNamespace, LPCWSTR szMofFile)
{
    CMof2Inst mofParse(pNamespace);
    _bstr_t   strFile = szMofFile;

    if (!mofParse.InitFromFile(strFile))
    {
        printf(
            "Unable to open '%S': error %d\n", 
            szMofFile,
            GetLastError());

        return 1;
    }

    IWbemClassObject *pObj = NULL;
    HRESULT          hr;

    m_bAllocated = TRUE;
    m_pListEvents = new CFlexArray;

    while ((hr = mofParse.GetNextInstance(&pObj)) == S_OK)
        m_pListEvents->Add(pObj);

    return SUCCEEDED(hr);
}

BOOL CInstTable::FindInstance(
    IWbemClassObject *pObj, 
    BOOL bTrySkipping,
    BOOL bFullCompare)
{
    BOOL             bRet;
    DWORD            nCount = m_pListEvents->Size();
    IWbemClassObject **ppInst;

    // Check to see if we already hit the end of the list.
    if (m_dwLastFoundIndex == nCount - 1)
        return FALSE;
    
    bRet = FALSE;
    ppInst = (IWbemClassObject**) m_pListEvents->GetArrayPtr();

    if (m_dwLastFoundIndex == (DWORD) -1)
    {
        for (DWORD i = 0; i < nCount; i++)
        {
            HRESULT hr;

            if (bFullCompare)
                hr = ppInst[i]->CompareTo(WBEM_FLAG_IGNORE_QUALIFIERS, pObj);
            else
                hr = AltCompareTo(ppInst[i], pObj);

            if (hr == WBEM_S_SAME)
            {
                m_dwLastFoundIndex = i;
                m_nMatched = 1;
                bRet = TRUE;
                break;
            }
        }
    }
    else
    {
        HRESULT hr;

        if (bFullCompare)
            hr = 
                ppInst[m_dwLastFoundIndex + 1]->CompareTo(
                    WBEM_FLAG_IGNORE_QUALIFIERS, 
                    pObj);
        else
            hr = AltCompareTo(ppInst[m_dwLastFoundIndex + 1], pObj);

        if (hr == WBEM_S_SAME)
        {
            m_dwLastFoundIndex++;
            m_nMatched++;
            bRet = TRUE;
        }
        else if (bTrySkipping)
        {
            for (DWORD i = m_dwLastFoundIndex + 2; i < nCount; i++)
            {
                if (bFullCompare)
                    hr = ppInst[i]->CompareTo(WBEM_FLAG_IGNORE_QUALIFIERS, pObj);
                else
                    hr = AltCompareTo(ppInst[i], pObj);

                if (hr == WBEM_S_SAME)
                {
                    CIntRange missed = {m_dwLastFoundIndex + 1, i - 1};

                    m_listMissed.push_back(missed);

                    m_dwLastFoundIndex = i;
                    m_nMatched = 1;
                    bRet = TRUE;
                    break;
                }
            }
        }
    }

    return bRet;
}

BOOL CInstTable::AddScalarInstances(
    IWbemServices *pNamespace,
    LPCWSTR szClassName,
    LPCWSTR szPropName, 
    DWORD dwBegin, 
    DWORD dwEnd)
{
    IWbemClassObject *pClass = NULL;
    HRESULT          hr = S_OK;
    _bstr_t          strClassName = szClassName;

    if (FAILED(hr = pNamespace->GetObject(
        strClassName,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        NULL,
        &pClass,
        NULL)))
    {
        printf(
            "Unable to get class definition of '%S': 0%X\n",
            (BSTR) strClassName,
            hr);
    }

    _variant_t vValue;

    for (DWORD i = dwBegin; i <= dwEnd; i++)
    {
        //CInstance *pInst = new CInstance;
        //CProperty *pProp = new CProperty;

        //pInst->m_strName = szClassName;
        //pProp->m_strName = szPropName;
        //pProp->m_type = CIM_UINT32;
        //pProp->m_dwValue = i;

        //pInst->m_listProps.Add(pProp);

        IWbemClassObject *pObj = NULL;

        if (SUCCEEDED(hr = pClass->SpawnInstance(0, &pObj)))
        {
            vValue = (long) i;

            pObj->Put(szPropName, 0, &vValue, 0);

            m_pListEvents->Add(pObj);
        }
        else
        {
            printf(
                "Unable to get instance of '%S': 0%X\n",
                (BSTR) strClassName,
                hr);

            break;
        }
    }    

    return SUCCEEDED(hr);
}

void CInstTable::PrintUnmatchedObjMofs()
{
    DWORD            nCount = m_pListEvents->Size();
    IWbemClassObject **ppInst = (IWbemClassObject**) m_pListEvents->GetArrayPtr();

    // Print the ones from the missed list.
    for (CIntRangeListItor item = m_listMissed.begin(); 
        item != m_listMissed.end(); 
        item++)
    {
        CIntRange &range = *item;

        for (DWORD i = range.m_iBegin; i <= range.m_iEnd; i++)
        {
            BSTR strText = NULL;
            
            ppInst[i]->GetObjectText(0, &strText);

            printf("%S", strText);

            SysFreeString(strText);
        }
    }

    for (DWORD i = m_dwLastFoundIndex + 1; i < nCount; i++)
    {
        BSTR strText = NULL;
            
        ppInst[i]->GetObjectText(0, &strText);

        printf("%S", strText);

        SysFreeString(strText);
    }
}

HRESULT CInstTable::AltCompareTo(
    IWbemClassObject *pSrc, 
    IWbemClassObject *pDest)
{
    HRESULT hr;
    BOOL    bSame = FALSE;
    
    if (SUCCEEDED(hr = pSrc->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY)))
    {
        BSTR       strName = NULL;
        _variant_t vSrcValue;

        hr = WBEM_S_SAME;

        while(hr == WBEM_S_SAME &&
            pSrc->Next(0, &strName, &vSrcValue, NULL, NULL) == WBEM_S_NO_ERROR)
        {
            // We skip source properties that are null.
            if (vSrcValue.vt != VT_NULL)
            {
                _variant_t vDestValue;

                if (SUCCEEDED(pDest->Get(strName, 0, &vDestValue, NULL, NULL)))
                {
                    if (!CompareTo(&vSrcValue, &vDestValue))
                        hr = WBEM_S_DIFFERENT;
                }
                else
                    hr = WBEM_S_DIFFERENT;
            }
        }
        
        pSrc->EndEnumeration();
    }
    
    return hr;
}

BOOL CInstTable::CompareTo(VARIANT *pvarSrc, VARIANT *pvarDest)
{
    BOOL bRet;

    if (pvarSrc->vt == pvarDest->vt)
    {
        switch (pvarSrc->vt) 
        {
            case VT_BSTR:
                bRet = wcsicmp(V_BSTR(pvarSrc), V_BSTR(pvarDest)) == 0;
                break;

            case VT_I1: 
                bRet = pvarSrc->cVal == pvarDest->cVal;
                break;

            case VT_UI1:
                bRet = pvarSrc->bVal == pvarDest->bVal;
                break;

            case VT_I2:
                bRet = pvarSrc->iVal == pvarDest->iVal;
                break;

            case VT_I4:
                bRet = pvarSrc->lVal == pvarDest->lVal;
                break;

            case VT_BOOL:
                bRet = pvarSrc->boolVal == pvarDest->boolVal;
                break;

            case VT_R8:
                bRet = pvarSrc->dblVal == pvarDest->dblVal;
                break;

            case VT_R4:
                bRet = pvarSrc->fltVal == pvarDest->fltVal;
                break;

            case VT_UNKNOWN:
                // Note: no proper comparison of embedded objects.
                bRet = AltCompareTo((IWbemClassObject*) pvarSrc->punkVal,
                        (IWbemClassObject*) pvarDest->punkVal) == WBEM_S_SAME;
                break;

            case VT_NULL:
                bRet = TRUE;
                break;

            default:
                bRet = FALSE;
                break;
        }
    }
    else
        bRet = FALSE;

    return bRet;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofcons\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\js2mof\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	Js2Mof.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\js2mof\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__523C4A52_9093_45AE_8112_5A8C351B25B5__INCLUDED_)
#define AFX_STDAFX_H__523C4A52_9093_45AE_8112_5A8C351B25B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#include <windows.h>
#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__523C4A52_9093_45AE_8112_5A8C351B25B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\js2mof\js2mof.cpp ===
// Js2Mof.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"


void PrintUsage()
{
    printf(
        "Converts a text script into text read for a MOF.\n"
        "\n"
        "JS2MOF filename\n"
    );
}

int __cdecl main(int argc, char* argv[])
{
	if (argc != 2)
    {
        PrintUsage();
        return 0;
    }

    FILE *pFile = fopen(argv[1], "r");

    if (!pFile)
    {
        printf("Unable to open file.\n");

        return 1;
    }
    
    printf("\"");

    for (int c = fgetc(pFile); c && feof(pFile) == 0; c = fgetc(pFile))
    {
        switch(c)
        {
            case '\"':
                printf("\\\"");
                break;

            case '\\':
                printf("\\\\");
                break;

            case '\n':
                printf("\\n\"\n\"");
                break;

            default:
                printf("%c", c);
                break;
        }
    }
                   
    printf("\"");

    fclose(pFile);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofcons\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MofCons.rc
//
#define IDS_PROJNAME                    100
#define IDR_MOFCONSUMER                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofcons\mofcons.cpp ===
// MofCons.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MofConsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MofCons.h"

#include "MofCons_i.c"
#include "MofConsumer.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MofConsumer, CMofConsumer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MOFCONSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofcons\mofconsumer.h ===
// MofConsumer.h : Declaration of the CMofConsumer

#ifndef __MOFCONSUMER_H_
#define __MOFCONSUMER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEventSink

class CEventSink  : public IWbemUnboundObjectSink
{
public:
    CEventSink();
    ~CEventSink();

    HRESULT Init(IWbemClassObject *pLogicalConsumer);

public:
    STDMETHODIMP QueryInterface(REFIID refid, PVOID *ppThis)
    { 
        if (refid == IID_IUnknown)
            *ppThis = (IUnknown*) this;
        else if (refid == IID_IWbemUnboundObjectSink)
            *ppThis = (IWbemUnboundObjectSink*) this;
        else
            return E_NOINTERFACE;

        AddRef();

        return S_OK;
    }

    STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&m_lRef);
    }

    STDMETHODIMP_(ULONG) Release(void)
    { 
        LONG lRet = InterlockedDecrement(&m_lRef);

        if (lRet == 0)
            delete this;

        return lRet; 
    }

protected:
    LONG m_lRef;
    FILE *m_pFile;
};

class CMofEventSink : public CEventSink
{
public:
    HRESULT Init(IWbemClassObject *pLogicalConsumer);

// IWbemUnboundObjectSink
public:
    HRESULT WINAPI IndicateToConsumer(
        IWbemClassObject *pLogicalConsumer,
	    long nEvents,
	    IWbemClassObject **ppEvents);
};

#define MAX_OBJ_SIZE    32000

class CBlobEventSink : public CEventSink
{
public:
    HRESULT Init(IWbemClassObject *pLogicalConsumer);

// IWbemUnboundObjectSink
public:
    HRESULT WINAPI IndicateToConsumer(
        IWbemClassObject *pLogicalConsumer,
	    long nEvents,
	    IWbemClassObject **ppEvents);

protected:
    BYTE m_pBuffer[MAX_OBJ_SIZE];
};

/////////////////////////////////////////////////////////////////////////////
// CMofConsumer

class ATL_NO_VTABLE CMofConsumer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMofConsumer, &CLSID_MofConsumer>,
	public IWbemEventConsumerProvider
{
public:
	CMofConsumer() {}

DECLARE_REGISTRY_RESOURCEID(IDR_MOFCONSUMER)
DECLARE_NOT_AGGREGATABLE(CMofConsumer)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMofConsumer)
	COM_INTERFACE_ENTRY(IWbemEventConsumerProvider)
END_COM_MAP()


// IWbemEventConsumerProvider
public:
    HRESULT WINAPI FindConsumer(
        IWbemClassObject* pLogicalConsumer,
        IWbemUnboundObjectSink** ppConsumer);

// Implementation
protected:
};

#endif //__MOFCONSUMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofcons\mofconsumer.cpp ===
// MofConsumer.cpp : Implementation of CMofConsumer
#include "stdafx.h"
#include "MofCons.h"
#include "MofConsumer.h"
#include <wbemint.h>

/////////////////////////////////////////////////////////////////////////////
// CEventSink

CEventSink::CEventSink() :
    m_lRef(0),
    m_pFile(NULL)
{
}

CEventSink::~CEventSink()
{
    if (m_pFile)
        fclose(m_pFile);

    OutputDebugString("Closing the file!\n");
}

HRESULT CEventSink::Init(IWbemClassObject *pLogicalConsumer)
{
    _variant_t vFile;
    HRESULT    hr;

    if (SUCCEEDED(hr = pLogicalConsumer->Get(L"MofFile", 0, &vFile, NULL, NULL)))
    {
        m_pFile = _wfopen(V_BSTR(&vFile), L"a+b");

        OutputDebugString("Opened the file!\n");

        if (!m_pFile)
            hr = WBEM_E_PROVIDER_FAILURE;
    }

    return hr;
}

HRESULT WINAPI CMofEventSink::IndicateToConsumer(
    IWbemClassObject *pLogicalConsumer,
	long nEvents,
	IWbemClassObject **ppEvents)
{
    for (int i = 0; i < nEvents; i++)
    {
        BSTR    bstrObj = NULL;
        HRESULT hr;
        _variant_t vTemp;

        char szMsg[100];
        ppEvents[i]->Get(L"Index", 0, &vTemp, NULL, NULL);
        sprintf(szMsg, "Index = %d\n", (long) vTemp);
        OutputDebugString(szMsg);

        if (SUCCEEDED(hr = ppEvents[i]->GetObjectText(0, &bstrObj)))
        {
            fprintf(m_pFile, "%S", bstrObj);
                
            SysFreeString(bstrObj);
        }
        else
            fprintf(
                m_pFile,
                "\n// IWbemClassObject::GetObjectText failed : 0x%X\n", hr);
    }

    return S_OK;
}

HRESULT WINAPI CBlobEventSink::IndicateToConsumer(
    IWbemClassObject *pLogicalConsumer,
	long nEvents,
	IWbemClassObject **ppEvents)
{
    for (int i = 0; i < nEvents; i++)
    {
        HRESULT     hr;
        _IWmiObject *pObj = NULL;

        _variant_t vTemp;

        char szMsg[100];
        ppEvents[i]->Get(L"Index", 0, &vTemp, NULL, NULL);
        sprintf(szMsg, "Index = %d\n", (long) vTemp);
        OutputDebugString(szMsg);

        if (SUCCEEDED(hr = ppEvents[i]->QueryInterface(
            IID__IWmiObject, (LPVOID*) &pObj)))
        {
            DWORD dwRead;

            hr = 
                pObj->GetObjectParts(
                    m_pBuffer, 
                    MAX_OBJ_SIZE, 
                    WBEM_OBJ_DECORATION_PART | WBEM_OBJ_INSTANCE_PART | 
                        WBEM_OBJ_CLASS_PART,
                    &dwRead);
            
            //if (SUCCEEDED(hr = pObj->GetObjectMemory(
            //    m_pBuffer, MAX_OBJ_SIZE, &dwRead)))
            if (SUCCEEDED(hr))
            {
                if (fwrite(&dwRead, 1, sizeof(dwRead), m_pFile) != 
                    sizeof(dwRead) ||
                    fwrite(m_pBuffer, 1, dwRead, m_pFile) != dwRead)
                {
                    OutputDebugString("Failed to write data!\n");
                }

                fflush(m_pFile);
            }
            else
                OutputDebugString("Failed to get memory!\n");


/*
        BSTR bstrObj = NULL;

        if (SUCCEEDED(hr = pObj->GetObjectText(0, &bstrObj)))
        {
            OutputDebugStringW(bstrObj);
                
            SysFreeString(bstrObj);
        }
        else
        {
            WCHAR szTemp[256];

            swprintf(
                szTemp, 
                L"\n// IWbemClassObject::GetObjectText failed : 0x%X\n",
                hr);

            OutputDebugStringW(szTemp);
        }

            LPVOID pMem = CoTaskMemAlloc(dwRead);

            memcpy(pMem, m_pBuffer, dwRead);
            hr = pObj->SetObjectMemory(pMem, dwRead);
*/

            pObj->Release();
        }
        else
            OutputDebugString("Failed to get _IWmiObject!\n");
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMofConsumer

HRESULT WINAPI CMofConsumer::FindConsumer(
    IWbemClassObject* pLogicalConsumer,
    IWbemUnboundObjectSink** ppConsumer)
{
    _variant_t vBlobs;
    BOOL       bBlobs;

    if (SUCCEEDED(pLogicalConsumer->Get(
        L"SaveAsBlobs", 0, &vBlobs, NULL, NULL)))
    {
        bBlobs = V_BOOL(&vBlobs);
    }
    else
        bBlobs = FALSE;


    CEventSink *pSink = bBlobs ? (CEventSink*) new CBlobEventSink : 
                            (CEventSink*) new CMofEventSink;
    HRESULT    hr;
    
    if (pSink)
    {
        hr = pSink->Init(pLogicalConsumer);
        
        if (SUCCEEDED(hr))
        {
            hr = 
                pSink->QueryInterface(
                    IID_IWbemUnboundObjectSink, 
                    (LPVOID*) ppConsumer);
        }
        else
        {
            delete pSink;
            *ppConsumer = NULL;
        }
    }
    else
        hr = WBEM_E_OUT_OF_MEMORY;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofcons\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__10EA4A7F_090B_4362_9547_930DF1B089B6__INCLUDED_)
#define AFX_STDAFX_H__10EA4A7F_090B_4362_9547_930DF1B089B6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>

#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__10EA4A7F_090B_4362_9547_930DF1B089B6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	IndexPrv.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofprov\mofprov.cpp ===
// IndexPrv.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "..\utils\Mof2Inst.h"
#include <wbemcomn.h>
#include <winntsec.h>
#include <map>

void PrintUsage()
{
    printf(
        
"Sends instances in a MOF as WMI events.\n"
"\n"
"MOFPROV /Pprovname /Ffilename [/Nnamespace] [/Ee_per_sec] [/Bbuffsize]\n"
"        [/Llatency] [/R] [/V] [/Oowner /Ggroup [/Aallowed] [/Ddenied]]\n"
"\n"
"namespace  The namespace to use (default is root\\cimv2).\n"
"provname   The name of the provider of the events as previously registered.\n"
"           The provider must be registered as a decoupled provider.\n"
"filename   The name of the mof that contains the events.\n"
"e_per_sec  The number of events per second to send (default = unlimited).\n"
"buffsize   The size of the buffer to be used when batching events.  The\n"
"           default is 64000.  Use 0 to turn off batching.\n"
"latency    The maximum number of seconds before an event is sent to WMI.  The\n"
"           default is 1000.\n"
"/R         Use a different restricted sink for each event type.\n"
"/V         Run in verbose mode.\n"
"owner      Owner of the security descriptor to place on events.\n"
"group      Group of the security descriptor to place on events.\n"
"allowed    User name allowed to access events.\n"
"denied     User name denied access events.\n"

    );
}

#define SD_PROP_NAME    L"__SD"

_COM_SMARTPTR_TYPEDEF(IWbemEventSink, __uuidof(IWbemEventSink));

typedef std::map<_bstr_t, IWbemEventSinkPtr> CSinkMap;
typedef CSinkMap::iterator CSinkMapItor;

LPSTR g_szNamespace = "root\\cimv2",
      g_szProvName,
      g_szFilename;
BOOL  g_bVerbose = FALSE,
      g_bRestricted = FALSE,
      g_bSD = FALSE;

CNtSecurityDescriptor   g_sd;
CNtAcl                  g_dacl;
BYTE                    *g_pSD = NULL;
DWORD                   g_dwSDLen = 0;
IWbemDecoupledEventSink *g_pConnection = NULL;
IWbemServices           *g_pNamespace = NULL;
IWbemObjectSink         *g_pSink = NULL;
IWbemEventSink          *g_pBetterSink = NULL;
CSinkMap                g_mapSinks;

BOOL InitDecoupled();
//void FireDecoupledEvent(DWORD dwWhich, DWORD dwIndex);
void DeinitDecoupled();
IWbemEventSink *GetRestrictedSink(_bstr_t &strClass);

#define DEF_BUFF_SIZE   64000
#define DEF_LATENCY     1000

DWORD g_dwLatency = DEF_LATENCY,
      g_dwBuffSize = DEF_BUFF_SIZE;

int __cdecl main(int argc, char* argv[])
{
    int iRet = 0,
        nPerSec = -1;

    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != '/' && argv[i][0] != '-')
        {
            PrintUsage();
            return 1;
        }

        LPSTR szValue = &argv[i][2];
        switch(toupper(argv[i][1]))
        {
            case 'N':
                g_szNamespace = szValue;
                break;

            case 'P':
                g_szProvName = szValue;
                break;

            case 'F':
                g_szFilename = szValue;
                break;
            
            case 'E':
                nPerSec = atoi(szValue);
                break;

            case 'B':
                g_dwBuffSize = atoi(szValue);
                break;

            case 'L':
                g_dwLatency = atoi(szValue);
                break;

            case 'R':
                g_bRestricted = TRUE;
                break;

            case 'V':
                g_bVerbose = TRUE;
                break;

            case 'O':
            {
                _bstr_t strName = szValue;
                CNtSid  sid(strName);

                g_bSD = TRUE;
                g_sd.SetOwner(&sid);
                break;
            }

            case 'G':
            {
                _bstr_t strName = szValue;
                CNtSid  sid(strName);

                g_bSD = TRUE;
                g_sd.SetGroup(&sid);
                break;
            }

            case 'A':
            {
                _bstr_t strName = szValue;
                CNtSid  sid(strName);

                g_bSD = TRUE;
                g_dacl.AddAce(
                    &CNtAce(WBEM_RIGHT_SUBSCRIBE, ACCESS_ALLOWED_ACE_TYPE, 0, sid));

                break;
            }

            case 'D':
            {
                _bstr_t strName = szValue;
                CNtSid  sid(strName);

                g_bSD = TRUE;
                g_dacl.AddAce(
                    &CNtAce(WBEM_RIGHT_SUBSCRIBE, ACCESS_DENIED_ACE_TYPE, 0, sid));

                break;
            }

            default:
                PrintUsage();
                return 1;
        }
    }

    if (!g_szProvName || !g_szFilename)
    {
        PrintUsage();

        return 1;
    }

    if (!InitDecoupled())
        return 1;

    if (g_bSD)
    {
        g_sd.SetDacl(&g_dacl);
        g_pSD = (LPBYTE) g_sd.GetPtr();
        g_dwSDLen = g_sd.GetSize();
    }
        
    CMof2Inst mofParse(g_pNamespace);

    if (!mofParse.InitFromFile(g_szFilename))
    {
        printf(
            "Unable to open '%s': error %d\n", 
            g_szFilename,
            GetLastError());

        return 1;
    }

    DWORD            dwBeginTimestamp = GetTickCount(),
                     dwTimestamp = dwBeginTimestamp;
    int              nSent = 0,
                     nTotal = 0;
    IWbemClassObject *pObj = NULL;
    HRESULT          hr;

    while ((hr = mofParse.GetNextInstance(&pObj)) == S_OK)
    {
        if (g_pSD)
        {
            _IWmiObject *pWmiObj = (_IWmiObject*) pObj;
            HRESULT     hr;
            long        handleSD = 0;

            if (SUCCEEDED(hr = pWmiObj->GetPropertyHandleEx(
                SD_PROP_NAME,
                0,
                NULL,
                &handleSD)))
            {
                if (FAILED(hr = pWmiObj->SetArrayPropRangeByHandle(
                    handleSD,
                    WMIARRAY_FLAG_ALLELEMENTS, // flags
                    0,                         // start index
                    g_dwSDLen,                 // # items
                    g_dwSDLen,                 // buffer size
                    g_pSD)))                   // data buffer
                {
                    printf("Failed to set __SD property: %x\n", hr);
                }
            }
            else
                printf("Failed to get __SD handle: %x\n", hr);
        }

        if (!g_bRestricted)
            g_pSink->Indicate(1, &pObj);
        else
        {
            _variant_t     vClass;
            IWbemEventSink *pSink = NULL;

            pObj->Get(L"__CLASS", 0, &vClass, NULL, NULL);

            if ((pSink = GetRestrictedSink((_bstr_t) vClass)) != NULL)
                pSink->Indicate(1, &pObj);
        }

        pObj->Release();

        nSent++;
        nTotal++;

        if (nPerSec > 0 && nSent > nPerSec)
        {
            DWORD dwCurrent = GetTickCount();

            if (dwCurrent - dwTimestamp < 1000)
                Sleep(1000 - (dwCurrent - dwTimestamp));

            dwTimestamp = GetTickCount();
            nSent = 0;
        }
    }

    if (FAILED(hr))
    {
        printf("Error parsing file: %S at line %d\n", 
            (BSTR) mofParse.m_strError,
            mofParse.GetLineNum());
    }

    DWORD dwDiff = GetTickCount() - dwBeginTimestamp;

    if (!dwDiff)
        dwDiff = 1;

    if (g_bVerbose)
    {
        printf(
            "%u events sent (%u events/s)\n",
            nTotal,
            nTotal * 1000 / dwDiff);
    }

    // Wait some.
    //Sleep(3000);

    DeinitDecoupled();

    return iRet;
}

class CCallback : 
    public IWbemEventProviderSecurity, 
    public IWbemEventProviderQuerySink, 
    public IWbemEventProvider
{
public:
    LPCWSTR m_szName;

    CCallback(LPCWSTR szName) :
        m_szName(szName)
    {
    }

    ~CCallback(){}

    ULONG STDMETHODCALLTYPE AddRef() {return 1;}
    ULONG STDMETHODCALLTYPE Release() {return 1;}
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv) 
    {
        if(riid == IID_IUnknown || riid == IID_IWbemEventProviderSecurity)
        {
            *ppv = (IWbemEventProviderSecurity*)this;
            return S_OK;
        }
        if(riid == IID_IWbemEventProvider)
        {
            *ppv = (IWbemEventProvider*)this;
            return S_OK;
        }
        if(riid == IID_IWbemEventProviderQuerySink)
        {
            *ppv = (IWbemEventProviderQuerySink*)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD(AccessCheck)(LPCWSTR, LPCWSTR, long, const BYTE*)
    {
        if (g_bVerbose)
            printf("%S: AccessCheck\n", m_szName);

        return WBEM_S_SUBJECT_TO_SDS;
    }

    STDMETHOD(NewQuery)(DWORD, LPWSTR, LPWSTR)
    {
        if (g_bVerbose)
            printf("%S: New query\n", m_szName);

        return WBEM_S_SUBJECT_TO_SDS;
    }

    STDMETHOD(CancelQuery)(DWORD)
    {
        if (g_bVerbose)
            printf("%S: Cancel query\n", m_szName);

        return WBEM_S_SUBJECT_TO_SDS;
    }

    STDMETHOD(ProvideEvents)(IWbemObjectSink*, long)
    {
        if (g_bVerbose)
            printf("%S: Provide\n", m_szName);

        return S_OK;
    }
};

CCallback callbackMain(L"Main");

#define CHECKERROR(HRES) if(FAILED(hres)) {printf("Error: 0x%x\n", hres); return FALSE;}

BOOL InitDecoupled()
{
    HRESULT         hres;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    hres = CoCreateInstance(CLSID_PseudoSink, NULL, CLSCTX_SERVER, 
                            IID_IWbemDecoupledEventSink, (void**)&g_pConnection);
    CHECKERROR(hres);
    
    if (g_bVerbose)
        printf("CoCreated\n");

    // Connect and announce provider name (as in MOF)

    _bstr_t strNamespace = g_szNamespace,
            strProvName = g_szProvName;

    hres = 
        g_pConnection->Connect(
            strNamespace, 
            strProvName, 
            0, 
            &g_pSink, 
            &g_pNamespace);

    CHECKERROR(hres);
    
    if (g_bVerbose)
        printf("Connected\n");

    hres = 
        g_pConnection->SetProviderServices(
            (IWbemEventProvider*) &callbackMain, 
            WBEM_FLAG_NOTIFY_START_STOP);

    hres = g_pSink->QueryInterface(IID_IWbemEventSink, (void**)&g_pBetterSink);
    CHECKERROR(hres);
    
    if (g_dwBuffSize)
    {
        g_pBetterSink->SetBatchingParameters(
            WBEM_FLAG_MUST_BATCH, 
            g_dwBuffSize, 
            g_dwLatency);
    }

    return TRUE;
}

void DeinitDecoupled()
{
    g_mapSinks.erase(g_mapSinks.begin(), g_mapSinks.end());

    if (g_pSink)
        g_pSink->Release();
    
    if (g_pBetterSink)
        g_pBetterSink->Release();

    if (g_pNamespace)
        g_pNamespace->Release();

    if (g_pConnection)
    {
        g_pConnection->Disconnect();
        g_pConnection->Release();
    }
}

IWbemEventSink *GetRestrictedSink(_bstr_t &strClass)
{
    CSinkMapItor   item;
    HRESULT        hr;
    IWbemEventSink *pSink = NULL;
    
    wcsupr(strClass);
    item = g_mapSinks.find(strClass);

    if (item != g_mapSinks.end())
        pSink = (*item).second;
    else
    {
        WCHAR   szTemp[1024];
        LPCWSTR szQuery = (LPCWSTR) szTemp;

        swprintf(szTemp, L"select * from %s", (LPWSTR) strClass);

        hr = 
            g_pBetterSink->GetRestrictedSink(
                1,
                &szQuery, 
			    NULL,
                &pSink);

        if (SUCCEEDED(hr))
        {
            g_mapSinks[strClass] = pSink;
            
            if (g_dwBuffSize)
            {
                pSink->SetBatchingParameters(
                    WBEM_FLAG_MUST_BATCH, 
                    g_dwBuffSize, 
                    g_dwLatency);
            }

            // Becaue the map now has the ref.
            pSink->Release();
        }
        else
            printf(
                "IWbemEventSink::GetRestrictedSink(%S) failed: 0x%X\n", 
                (LPWSTR) strClass,
                hr);
    }

    return pSink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\mofprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__CC97B8A6_BBB7_49DC_A1C5_9F7D23849B9D__INCLUDED_)
#define AFX_STDAFX_H__CC97B8A6_BBB7_49DC_A1C5_9F7D23849B9D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _WIN32_WINNT 0x0500

#pragma warning( disable : 4786 )  

#include <windows.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemdcpl.h>
#include <ncobjapi.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CC97B8A6_BBB7_49DC_A1C5_9F7D23849B9D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\utils\mof2inst.h ===
// Mof2Inst.h

#ifndef MOF2INST_H
#define MOF2INST_H

#include <wbemidl.h>
#include <genlex.h>
#include <map>

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

class CMof2Inst
{
public:
    _bstr_t m_strError;
    
    CMof2Inst(IWbemServices *pNamespace);
    ~CMof2Inst();
    
    BOOL InitFromFile(LPCSTR szFile);
    BOOL InitFromBuffer(LPCSTR szBuffer);
    HRESULT GetNextInstance(IWbemClassObject **ppObj);
    int GetLineNum() { return m_pLex->GetLineNum(); }

protected:
    typedef std::map<_bstr_t, IWbemClassObjectPtr> CClassMap;
    typedef CClassMap::iterator CClassMapItor;

    IWbemServices  *m_pNamespace;
    BOOL           m_bFree;
    LPWSTR         m_szBuffer;
    CTextLexSource *m_pSrc;
    CGenLexer      *m_pLex;
    CClassMap      m_mapClasses;

    HRESULT GetInstanceAtOf(IWbemClassObject **ppObj);
    HRESULT ValueToVariant(int iToken, CIMTYPE type, _variant_t &vVal);
    HRESULT SpawnInstance(_bstr_t &strClass, IWbemClassObject **ppObj); 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\utils\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B1E03C71_92B6_4B6E_82B3_E10D946969AD__INCLUDED_)
#define AFX_STDAFX_H__B1E03C71_92B6_4B6E_82B3_E10D946969AD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define _WIN32_WINNT 0x0500

#pragma warning( disable : 4786 )  

#include <windows.h>
#include <objbase.h>        // COM
#include <comdef.h>         // _bstr_t, _variant_t
#include <wbemcli.h>        // duh

_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));

#include <stdio.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B1E03C71_92B6_4B6E_82B3_E10D946969AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\esstest\utils\mof2inst.cpp ===
// Mof2Inst.cpp

#include "stdafx.h"
#include "Mof2Inst.h"
#include "buffer.h"
#include <wbemint.h>


void RemoveEscapes(_bstr_t &str);

#define TOK_STRING       101
#define TOK_IDENT        102
#define TOK_EQU          104
#define TOK_SCOLON       105
#define TOK_DOT          106
#define TOK_LBRACE       107
#define TOK_RBRACE       108
#define TOK_NUMERIC      109
#define TOK_COMMA        110

#define TOK_ERROR        1
#define TOK_EOF          0

#define ST_NUMERIC       18
#define ST_IDENT         20
#define ST_STRING        25
#define ST_STRING_ML     30
#define ST_BEG_COM       37
#define ST_IN_LCOM       40
#define ST_IN_COM        43
#define ST_TRY_DONEC     47


//#define ST_QSTRING       28
//#define ST_QSTRING_ESC   32

LexEl g_lexTable[] =
{

// State First     Last        New state   Return tok     Instructions
// =======================================================================
/* 0 */  L'A',     L'Z',       ST_IDENT,   0,             GLEX_ACCEPT,
/* 1 */  L'a',     L'z',       ST_IDENT,   0,             GLEX_ACCEPT,
/* 2 */  L'_',     GLEX_EMPTY, ST_IDENT,   0,             GLEX_ACCEPT,

/* 3 */  L'-',     GLEX_EMPTY, ST_NUMERIC, 0,             GLEX_ACCEPT,
/* 4 */  L'0',     L'9',       ST_NUMERIC, 0,             GLEX_ACCEPT,

/* 5 */  L'/',     GLEX_EMPTY, ST_BEG_COM, 0,             GLEX_CONSUME,

/* 6 */  L'{',     GLEX_EMPTY, 0,          TOK_LBRACE,    GLEX_ACCEPT|GLEX_RETURN,
/* 7 */  L'=',     GLEX_EMPTY, 0,          TOK_EQU,       GLEX_ACCEPT|GLEX_RETURN,
/* 8 */  L'}',     GLEX_EMPTY, 0,          TOK_RBRACE,    GLEX_ACCEPT|GLEX_RETURN,
/* 9 */  L';',     GLEX_EMPTY, 0,          TOK_SCOLON,    GLEX_ACCEPT|GLEX_RETURN,
/* 10 */ L',',     GLEX_EMPTY, 0,          TOK_COMMA,     GLEX_ACCEPT|GLEX_RETURN,

/* 11 */ L' ',     GLEX_EMPTY, 0,          0,             GLEX_CONSUME,
/* 12 */ L'\t',    GLEX_EMPTY, 0,          0,             GLEX_CONSUME,
/* 13 */ L'\n',    GLEX_EMPTY, 0,          0,             GLEX_CONSUME|GLEX_LINEFEED,
/* 14 */ L'\r',    GLEX_EMPTY, 0,          0,             GLEX_CONSUME,
/* 15 */ L'"',     GLEX_EMPTY, ST_STRING,  0,             GLEX_CONSUME,
/* 16 */ 0,        GLEX_EMPTY, 0,          TOK_EOF,       GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 17 */ GLEX_ANY, GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,

/* ST_NUMERIC */
/* 18 */ L'0',     L'9',       ST_NUMERIC, 0,             GLEX_ACCEPT,
/* 19 */ GLEX_ANY, GLEX_EMPTY, 0,          TOK_NUMERIC,   GLEX_PUSHBACK|GLEX_RETURN,

/* ST_IDENT */
/* 20 */ L'a',     L'z',       ST_IDENT,   0,             GLEX_ACCEPT,
/* 21 */ L'A',     L'Z',       ST_IDENT,   0,             GLEX_ACCEPT,
/* 22 */ L'_',     GLEX_EMPTY, ST_IDENT,   0,             GLEX_ACCEPT,
/* 23 */ L'0',     L'9',       ST_IDENT,   0,             GLEX_ACCEPT,
/* 24 */ GLEX_ANY, GLEX_EMPTY, 0,          TOK_IDENT,     GLEX_PUSHBACK|GLEX_RETURN,

/* ST_STRING */
/* 25 */ L'"',     GLEX_EMPTY, ST_STRING_ML, 0,           GLEX_CONSUME,
/* 26 */ GLEX_ANY, GLEX_EMPTY, ST_STRING,  0,             GLEX_ACCEPT,
/* 27 */ 0,        GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,
/* 28 */ L'\n',    GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,
/* 29 */ L'\r',    GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,

/* ST_STRING_ML */
/* 30 */ 0,        GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,
/* 31 */ L' ',     GLEX_EMPTY, ST_STRING_ML,0,            GLEX_CONSUME,
/* 32 */ L'\t',    GLEX_EMPTY, ST_STRING_ML,0,            GLEX_CONSUME,
/* 33 */ L'\n',    GLEX_EMPTY, ST_STRING_ML,0,            GLEX_CONSUME|GLEX_LINEFEED,
/* 34 */ L'\r',    GLEX_EMPTY, ST_STRING_ML,0,            GLEX_CONSUME,
/* 35 */ L'"',     GLEX_EMPTY, ST_STRING,  0,             GLEX_CONSUME,
/* 36 */ GLEX_ANY, GLEX_EMPTY, 0,          TOK_STRING,    GLEX_PUSHBACK|GLEX_RETURN,

/* ST_BEG_COM */
/* 37 */ L'/',     GLEX_EMPTY, ST_IN_LCOM, 0,             GLEX_CONSUME,
/* 38 */ L'*',     GLEX_EMPTY, ST_IN_COM,  0,             GLEX_CONSUME,
/* 39 */ GLEX_ANY, GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,

/* ST_IN_LCOM */
/* 40 */ 0,        GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,
/* 41 */ L'\n',    GLEX_EMPTY, 0,          0,             GLEX_CONSUME|GLEX_LINEFEED,
/* 42 */ GLEX_ANY, GLEX_EMPTY, ST_IN_LCOM, 0,             GLEX_CONSUME,

/* ST_IN_COM */
/* 43 */ 0,        GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,
/* 44 */ L'\n',    GLEX_EMPTY, ST_IN_COM,  0,             GLEX_CONSUME|GLEX_LINEFEED,
/* 45 */ L'*',     GLEX_EMPTY, ST_TRY_DONEC,0,            GLEX_CONSUME,
/* 46 */ GLEX_ANY, GLEX_EMPTY, ST_IN_COM,  0,             GLEX_CONSUME,

/* ST_TRY_DONEC */
/* 47 */ L'/',     GLEX_EMPTY, 0,          0,             GLEX_CONSUME,
/* 48 */ GLEX_ANY, GLEX_EMPTY, ST_IN_COM,  0,             GLEX_CONSUME|GLEX_PUSHBACK,
 
};

#if 0
/* 30 */ L'\\',    GLEX_EMPTY, ST_STRING_ESC, 0,         GLEX_ACCEPT,

/* ST_QSTRING */
/* 28 */ 0,        GLEX_EMPTY, 0,          TOK_ERROR,     GLEX_ACCEPT|GLEX_RETURN,
/* 29 */ L'"',     GLEX_EMPTY, ST_STRING,  0,             GLEX_ACCEPT,
/* 30 */ L'\\',    GLEX_EMPTY, ST_QSTRING_ESC, 0,         GLEX_ACCEPT,
/* 31 */ GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0,             GLEX_ACCEPT,

/* ST_STRING_ESC */
/* 32 */ GLEX_ANY, GLEX_EMPTY, ST_QSTRING, 0, GLEX_ACCEPT,
#endif

CMof2Inst::CMof2Inst(IWbemServices *pNamespace) :
    m_pSrc(NULL),
    m_pLex(NULL),
    m_szBuffer(NULL)
{
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
}

CMof2Inst::~CMof2Inst()
{
    if (m_pLex)
        delete m_pLex;

    if (m_pSrc)
        delete m_pSrc;

    if (m_szBuffer)
        delete m_szBuffer;

    m_pNamespace->Release();
}

BOOL CMof2Inst::InitFromFile(LPCSTR szFile)
{
    HANDLE hFile;

    hFile =
        CreateFile(
            szFile,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            0,
            NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    DWORD dwSize = GetFileSize(hFile, NULL);
    LPSTR szBuffer = new char[dwSize + 1];

    if (!szBuffer)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    DWORD dwRead;

    if (!ReadFile(
        hFile,
        szBuffer,
        dwSize,
        &dwRead,
        NULL))
        return FALSE;

    CloseHandle(hFile);

    szBuffer[dwSize] = 0;
    
    BOOL bRet = InitFromBuffer(szBuffer);

    delete szBuffer;

    return bRet;
}

BOOL CMof2Inst::InitFromBuffer(LPCSTR szBuffer)
{
    DWORD dwLen = strlen(szBuffer) + 1;

    m_szBuffer = new WCHAR[dwLen];

    mbstowcs(m_szBuffer, szBuffer, dwLen);

    m_pSrc = new CTextLexSource(m_szBuffer);
    if (!m_pSrc)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    m_pLex = new CGenLexer(g_lexTable, m_pSrc);
    if (!m_pLex)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    return TRUE;
}

HRESULT CMof2Inst::GetNextInstance(IWbemClassObject **ppObj)
{
    int iToken = m_pLex->NextToken();

    if (iToken == TOK_EOF)
        return WBEM_S_FALSE;

    // INSTANCE
    if (iToken != TOK_IDENT || 
        _wcsicmp(m_pLex->GetTokenText(), L"INSTANCE"))
    {
        m_strError = L"'instance' expected";
        return WBEM_E_INVALID_SYNTAX;
    }

    HRESULT hr = GetInstanceAtOf(ppObj);

    if (SUCCEEDED(hr))
    {
        if (m_pLex->NextToken() != TOK_SCOLON)
        {
            m_strError = L"';' expected";
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    return hr;
}

HRESULT CMof2Inst::ValueToVariant(int iToken, CIMTYPE type, _variant_t &vVal)
{
    HRESULT hr = S_OK;

    // Value
    switch(iToken)
    {
        // Numeric value
        case TOK_NUMERIC:
        {
            long lValue = _wtoi(m_pLex->GetTokenText());

            vVal.lVal = lValue;
            if (type == CIM_UINT32 || type == CIM_SINT32)
                vVal.vt = VT_I4;
            else if (type == CIM_UINT16 || type == CIM_SINT16)
                vVal.vt = VT_I2;
            else if (type == CIM_UINT8 || type == CIM_SINT8)
                vVal.vt = VT_UI1;
            else
            {
                m_strError = L"invalid value";
                hr = WBEM_E_INVALID_SYNTAX;
            }

            break;
        }

        // String value
        case TOK_STRING:
        {
            _bstr_t strValue = m_pLex->GetTokenText();

            RemoveEscapes(strValue);
            vVal = strValue;
            
            break;
        }

        // Identifier
        case TOK_IDENT:
        {
            // Embedded object
            if (!_wcsicmp(m_pLex->GetTokenText(), L"INSTANCE"))
            {
                IWbemClassObject *pObj = NULL;

                if (FAILED(hr = GetInstanceAtOf(&pObj)))
                    return hr;

                vVal = (IUnknown*) pObj;
                
                // vVal has it reffed, so let go of our hold on it.
                pObj->Release();
            }
            // true
            else if (!_wcsicmp(m_pLex->GetTokenText(), L"TRUE"))
                vVal = true;
            // false
            else if (!_wcsicmp(m_pLex->GetTokenText(), L"FALSE"))
                vVal = false;
            else
            {
                m_strError = L"invalid indentifier";
                hr = WBEM_E_INVALID_SYNTAX;
            }

            break;
        }

        default:
        {
            m_strError = L"expected string, number, or identifier";
            hr = WBEM_E_INVALID_SYNTAX;
            break;
        }
    }

    return hr;
}

#define DEF_SIZE 1024

HRESULT CMof2Inst::SpawnInstance(_bstr_t &strClassName, IWbemClassObject **ppObj)
{
    CClassMapItor    item;
    HRESULT          hr;
    IWbemClassObject *pClass = NULL;

    if ((item = m_mapClasses.find(strClassName)) != m_mapClasses.end())
    {
        pClass = (*item).second;
    }
    else
    {
        if (FAILED(hr = m_pNamespace->GetObject(
            strClassName,
            WBEM_FLAG_RETURN_WBEM_COMPLETE,
            NULL,
            &pClass,
            NULL)))
        {
            WCHAR szError[MAX_PATH * 2];

            swprintf(
                szError,
                L"unable to get class definition for '%s': 0x%X",
                (BSTR) strClassName,
                hr);

            m_strError = szError;

            return hr;
        }

        m_mapClasses[strClassName] = pClass;
        pClass->Release();
    }

    if (FAILED(hr = pClass->SpawnInstance(0, ppObj)))
    {
        WCHAR szError[MAX_PATH * 2];

        swprintf(
            szError,
            L"unable to spawn instance for '%s': 0x%X",
            (BSTR) strClassName,
            hr);

        m_strError = szError;

        return hr;
    }

    return hr;
}

HRESULT CMof2Inst::GetInstanceAtOf(IWbemClassObject **ppObj)
{
    // OF
    if (m_pLex->NextToken() != TOK_IDENT || 
        _wcsicmp(m_pLex->GetTokenText(), L"OF"))
    {
        m_strError = L"'of' expected";
        return WBEM_E_INVALID_SYNTAX;
    }

    // <classname>
    if (m_pLex->NextToken() != TOK_IDENT)
    {
        m_strError = L"class name expected";
        return WBEM_E_INVALID_SYNTAX;
    }

    // GetObject on the classname
    _bstr_t strClassName = m_pLex->GetTokenText();
    HRESULT hr;
    CBuffer bufferValues(NULL, DEF_SIZE);

    if (FAILED(hr = SpawnInstance(strClassName, ppObj)))
        return hr;

    //pClass->Release();

    // {
    if (m_pLex->NextToken() != TOK_LBRACE)
    {
        m_strError = L"'{' expected";
        return WBEM_E_INVALID_SYNTAX;
    }

    _IWmiObject *pObj = (_IWmiObject*) *ppObj;

    // Loop through the properties.
    int iToken;
    while((iToken = m_pLex->NextToken()) == TOK_IDENT)
    {
        // Property name
        _bstr_t strPropName = m_pLex->GetTokenText();
        CIMTYPE type;
        long    handle;

        // =
        if (m_pLex->NextToken() != TOK_EQU)
        {
            m_strError = L"'=' expected";
            return WBEM_E_INVALID_SYNTAX;
        }

        if (FAILED(hr =
            (*ppObj)->Get(strPropName, 0, NULL, &type, NULL)))
        {
            m_strError = L"Get() failed";
            return hr;
        }

        if (FAILED(hr = pObj->GetPropertyHandleEx(
            strPropName,
            0,
            &type,
            &handle)))
        {
            m_strError = L"GetPropertyHandleEx failed";
            return hr;
        }

        iToken = m_pLex->NextToken();

        // Is this an array?
        if (iToken == TOK_LBRACE)
        {
            if ((type & CIM_FLAG_ARRAY) == 0)
            {
                m_strError = L"value expected";
                return WBEM_E_INVALID_SYNTAX;
            }

            // Clear the array flag.
            type &= ~CIM_FLAG_ARRAY;

            bufferValues.Reset();

            int nItems = 0;

            if (type == CIM_STRING || type == CIM_DATETIME || type == CIM_REFERENCE)
            {
                do
                {
                    if (m_pLex->NextToken() != TOK_STRING)
                    {
                        m_strError = L"string expected";
                        return WBEM_E_INVALID_SYNTAX;
                    }

                    bufferValues.Write(m_pLex->GetTokenText());
                    nItems++;

                    iToken = m_pLex->NextToken();

                } while (iToken == TOK_COMMA);
            }
            else if (type == CIM_OBJECT)
            {
                do
                {
                    if (m_pLex->NextToken() != TOK_IDENT || 
                        _wcsicmp(L"INSTANCE", m_pLex->GetTokenText()))
                    {
                        m_strError = L"'instance' expected";
                        return WBEM_E_INVALID_SYNTAX;
                    }

                    IWbemClassObject *pInst = NULL;

                    if (FAILED(hr = GetInstanceAtOf(&pInst)))
                        return hr;

                    bufferValues.Write(&pInst, sizeof(pInst));
                    nItems++;

                    iToken = m_pLex->NextToken();

                } while (iToken == TOK_COMMA);
            }
            else if (type == CIM_BOOLEAN)
            {
                do
                {
                    short val;
                    
                    if (m_pLex->NextToken() != TOK_IDENT)
                    {
                        m_strError = L"string expected";
                        return WBEM_E_INVALID_SYNTAX;
                    }

                    if (!_wcsicmp(m_pLex->GetTokenText(), L"TRUE"))
                        val = -1;
                    else
                        val = 0;

                    bufferValues.Write(&val, sizeof(val));
                    nItems++;

                    iToken = m_pLex->NextToken();

                } while (iToken == TOK_COMMA);
            }
            else
            {
                int  iSize;
                BOOL bSigned;

                switch(type)
                {
                    case CIM_UINT32:
                        bSigned = FALSE;
                        iSize = 4;
                        break;

                    case CIM_SINT32:
                        bSigned = TRUE;
                        iSize = 4;
                        break;

                    case CIM_CHAR16:
                    case CIM_UINT16:
                        bSigned = FALSE;
                        iSize = 2;
                        break;

                    case CIM_SINT16:
                        bSigned = TRUE;
                        iSize = 2;
                        break;

                    case CIM_UINT8:
                        bSigned = FALSE;
                        iSize = 1;
                        break;

                    case CIM_SINT8:
                        bSigned = TRUE;
                        iSize = 1;
                        break;

                    case CIM_UINT64:
                        bSigned = FALSE;
                        iSize = 8;
                        break;

                    case CIM_SINT64:
                        bSigned = TRUE;
                        iSize = 8;
                        break;

                    default:
                        m_strError = L"unsupported property type";
                        return WBEM_E_FAILED;
                }

                do
                {
                    if (m_pLex->NextToken() != TOK_NUMERIC)
                    {
                        m_strError = L"numeric value expected";
                        return WBEM_E_INVALID_SYNTAX;
                    }

                    if (iSize == 8)
                    {
                        DWORD64 dwVal = _wtoi64(m_pLex->GetTokenText());
                                    
                        bufferValues.Write(dwVal);
                    }
                    else
                    {
                        DWORD dwVal;
                        WCHAR *szBad;

                        dwVal = bSigned ? _wtoi(m_pLex->GetTokenText()) :
                                    wcstoul(m_pLex->GetTokenText(), &szBad, 10);

                        bufferValues.Write(&dwVal, iSize);
                    }

                    nItems++;

                    iToken = m_pLex->NextToken();

                } while (iToken == TOK_COMMA);
            }

            if (iToken != TOK_RBRACE)
            {
                m_strError = L"'}' expected";
                return WBEM_E_INVALID_SYNTAX;
            }

            if (type != CIM_OBJECT)
            {
                hr =
                    pObj->SetArrayPropRangeByHandle(
                        handle,
                        WMIARRAY_FLAG_ALLELEMENTS,  // flags
                        0,                          // start index
                        nItems,                     // # items
                        bufferValues.GetUsedSize(), // buffer size
                        bufferValues.m_pBuffer);    // data buffer

                if (FAILED(hr))
                {
                    m_strError = L"failed to set property";
                    return hr;
                }
            }
            else
            {
                CIMTYPE type;

                hr = (*ppObj)->Get(L"IntArray", 0, NULL, &type, NULL);
    
                hr =
                    pObj->SetArrayPropRangeByHandle(
                        handle,
                        WMIARRAY_FLAG_ALLELEMENTS,  // flags
                        0,                          // start index
                        nItems,                     // # items
                        bufferValues.GetUsedSize(), // buffer size
                        bufferValues.m_pBuffer);    // data buffer

                if (FAILED(hr))
                {
                    m_strError = L"failed to set property";
                    return hr;
                }

                hr = (*ppObj)->Get(L"IntArray", 0, NULL, &type, NULL);
            }

            // If we got an array of instances, clean them up now.
            if (type == CIM_OBJECT)
            {
                _IWmiObject **ppObjs = (_IWmiObject**) bufferValues.m_pBuffer;

                for (int i = 0; i < nItems; i++)
                    ppObjs[i]->Release();
            }
        }
        // Must be a single value.
        else
        {
            _variant_t vValue;

            if (FAILED(hr = ValueToVariant(iToken, type, vValue)))
                return hr;

            if (FAILED(hr = (*ppObj)->Put(strPropName, 0, &vValue, 0)))
            {
                m_strError = L"Put() failed";
                return hr;
            }
        }

        if (m_pLex->NextToken() != TOK_SCOLON)
        {
            m_strError = L"';' expected";
            return WBEM_E_INVALID_SYNTAX;
        }
    }

    if (iToken != TOK_RBRACE)
    {
        m_strError = L"'}' expected";
        return WBEM_E_INVALID_SYNTAX;
    }

    return S_OK;
}

void RemoveEscapes(_bstr_t &str)
{
    WCHAR  *pszTemp = (WCHAR*) malloc((str.length() + 1) * sizeof(WCHAR));
    LPWSTR szSrc,
           szDest = pszTemp;

    for (szSrc = str; *szSrc; szSrc++, szDest++)
    {
        if (*szSrc == '\\')
        {
            szSrc++;
            switch(*szSrc)
            {
                case 'n':
                    *szDest = '\n';
                    break;
                case 'r':
                    *szDest = '\r';
                    break;
                case 't':
                    *szDest = '\t';
                    break;
                default:
                    *szDest = *szSrc;
            }
        }
        else
            *szDest = *szSrc;
    }

    *szDest = 0;

    str = pszTemp;
    free(pszTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\faevprov.h ===
#ifndef __FAEVPROV_H__
#define __FAEVPROV_H__

#include <unk.h>
#include <comutl.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <wmimsg.h>
#include "fwdhdr.h"

class CFwdAckEventProv : public CUnk
{
    class XProv : public CImpl< IWbemEventProvider, CFwdAckEventProv >
    { 
    public:

        STDMETHOD(ProvideEvents)( IWbemObjectSink* pSink, long lFlags )
 	{
	    return m_pObject->ProvideEvents( pSink, lFlags );
	}

        XProv( CFwdAckEventProv* pObj )
	 : CImpl<IWbemEventProvider, CFwdAckEventProv> ( pObj ) {}

    } m_XProv;

    class XQuery : public CImpl<IWbemEventProviderQuerySink, CFwdAckEventProv>
    {
    public:
        
        STDMETHOD(NewQuery)( DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery )
	{
	    return m_pObject->NewQuery( dwId, wszQuery );
	}

        STDMETHOD(CancelQuery)( DWORD dwId )
	{
	    return m_pObject->CancelQuery( dwId );
	}

        XQuery( CFwdAckEventProv* pObj) 
	 : CImpl<IWbemEventProviderQuerySink, CFwdAckEventProv> ( pObj ) {}

    } m_XQuery;

    class XInit : public CImpl<IWbemProviderInit, CFwdAckEventProv>
    {
    public:

        STDMETHOD(Initialize)( LPWSTR wszUser, 
                               LONG lFlags, 
                               LPWSTR wszNamespace,
                               LPWSTR wszLocale, 
                               IWbemServices* pNamespace,
                               IWbemContext* pContext,
                               IWbemProviderInitSink* pInitSink )
        {
            return m_pObject->Init( pNamespace, pInitSink );
        }

        XInit( CFwdAckEventProv* pObj) 
         : CImpl<IWbemProviderInit, CFwdAckEventProv>(pObj) { }

    } m_XInit;


    //
    // the next two interface impls are not associated with this objects's 
    // identity.  Reasons is there would be a circular ref problem if they 
    // were because we hold onto the receiver, which in turn holds on to
    // the send/recv and error sink objects.
    //

    class XSendReceive : public IWmiMessageSendReceive
    {
        CFwdAckEventProv* m_pOwner; // no add-ref or circular reference.

        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if ( riid == IID_IUnknown || riid == IID_IWmiMessageSendReceive )
            {
                *ppv = this;
                return S_OK;
            }
            return E_NOINTERFACE;
        }
            
        STDMETHOD_(ULONG, AddRef)() { return 1; }
        STDMETHOD_(ULONG, Release)() { return 1; }

    public:

        STDMETHOD(SendReceive)( PBYTE pData, 
                                ULONG cData,
                                PBYTE pAuxData,
                                ULONG cAuxData,
                                DWORD dwFlagStatus,
                                IUnknown* pCtx )
 	{
	    return m_pOwner->Receive( pData, 
                                      cData, 
                                      pAuxData,
                                      cAuxData,
                                      dwFlagStatus,
                                      pCtx );
	}

        XSendReceive( CFwdAckEventProv* pOwner ) : m_pOwner( pOwner ) { }

    } m_XSendReceive;

    class XErrorSink : public IWmiMessageTraceSink
    { 
        CFwdAckEventProv* m_pOwner; // no add-ref or circular reference.

        STDMETHOD(QueryInterface)(REFIID riid, void** ppv)
        {
            if ( riid == IID_IUnknown || riid == IID_IWmiMessageTraceSink )
            {
                *ppv = this;
                return S_OK;
            }
            return E_NOINTERFACE;
        }
            
        STDMETHOD_(ULONG, AddRef)() { return 1; }
        STDMETHOD_(ULONG, Release)() { return 1; }

    public:

	STDMETHOD(Notify)( HRESULT hRes, 
                           GUID guidSource, 
                           LPCWSTR wszError, 
                           IUnknown* pCtx )
	{
	    return m_pOwner->HandleRecvError( hRes, wszError );
	}

        XErrorSink( CFwdAckEventProv* pOwner ) : m_pOwner( pOwner ) { }

    } m_XErrorSink;

    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemObjectSink> m_pEventSink;
    CWbemPtr<IWbemClassObject> m_pEventClass;
    CWbemPtr<IWmiMessageReceiver> m_pRcvr;
    CWbemPtr<IWmiObjectMarshal> m_pMrsh;

    HRESULT InitializeQueues();
    HRESULT InitializeReceivers();

    HRESULT FireAckEvent( IWbemClassObject* pOrigEvent,
                           IWmiMessageReceiverContext* pCtx,
                           CFwdMsgHeader& rFwdHdr,
                           HRESULT hr );
                           
    void* GetInterface( REFIID riid );

public:

    CFwdAckEventProv( CLifeControl* pCtl, IUnknown* pUnk = NULL );
    virtual ~CFwdAckEventProv();

    HRESULT Init( IWbemServices* pSvc, IWbemProviderInitSink* pInitSink );
    HRESULT ProvideEvents( IWbemObjectSink* pSink, long lFlags );
    HRESULT NewQuery( DWORD dwId, LPWSTR wszQuery );
    HRESULT CancelQuery( DWORD dwId );	
    HRESULT HandleRecvError( HRESULT hRes, LPCWSTR wszError );
    HRESULT Receive( PBYTE pData, 
                     ULONG cData, 
                     PBYTE pAuxData,
                     ULONG cAuxData,
                     DWORD dwFlagStatus,
                     IUnknown* pCtx );
};

#endif // __FAEVPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\faevprov.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <buffer.h>
#include <wbemutil.h>
#include "faevprov.h"

static LPWSTR g_wszAckEventClass = L"MSFT_ForwardedAckEvent";
static LPWSTR g_wszTimeProp = L"Time";
static LPWSTR g_wszMachineProp = L"Machine";
static LPWSTR g_wszEventProp = L"Event";
static LPWSTR g_wszStatusProp = L"Status";
static LPWSTR g_wszTargetProp = L"Target";
static LPWSTR g_wszQosProp = L"Qos";
static LPWSTR g_wszAuthenticationProp = L"Authentication";
static LPWSTR g_wszEncryptionProp = L"Encryption";
static LPWSTR g_wszConsumerProp = L"Consumer";
static LPWSTR g_wszNamespaceProp = L"Namespace";
static LPWSTR g_wszExecutionIdProp = L"ExecutionId";

LPCWSTR g_wszAckQueueName = L".\\private$\\WMIFwdAck";

// {0F3162C5-7B5A-469f-955C-79603B7EB5A6}
static const GUID g_guidAckQueueType = 
{ 0xF3162c5, 0x7b5a, 0x469f, {0x95, 0x5c, 0x79, 0x60, 0x3b, 0x7e, 0xb5, 0xa6}};

/**************************************************************************
  CFwdAckEventProv
***************************************************************************/

CFwdAckEventProv::CFwdAckEventProv( CLifeControl* pCtl, IUnknown* pUnk )
: CUnk( pCtl, pUnk ), m_XErrorSink( this ), m_XSendReceive( this ), 
  m_XProv( this ), m_XQuery( this ), m_XInit( this )
{

}

CFwdAckEventProv::~CFwdAckEventProv()
{

}

void* CFwdAckEventProv::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemEventProvider )
    {
        return &m_XProv;
    }
    else if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInit;
    }
    else if ( riid == IID_IWmiMessageTraceSink )
    {
        return &m_XErrorSink;
    }
    else if ( riid == IID_IWmiMessageSendReceive )
    {
        return &m_XSendReceive;
    }
    else if ( riid == IID_IWbemEventProviderQuerySink )
    {
        return &m_XQuery;
    }
    return NULL;
}

HRESULT CFwdAckEventProv::Init( IWbemServices* pSvc, 
                                IWbemProviderInitSink* pInitSink )
{
    HRESULT hr;

    m_pSvc = pSvc;

    hr = pSvc->GetObject( g_wszAckEventClass, 
                          0, 
                          NULL,
                          &m_pEventClass, 
                          NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = CoCreateInstance( CLSID_WmiSmartObjectUnmarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&m_pMrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
}

HRESULT CFwdAckEventProv::FireAckEvent( IWbemClassObject* pOrigEvent,
                                        IWmiMessageReceiverContext* pRcvCtx,
                                        CFwdMsgHeader& rFwdHdr,
                                        HRESULT hrStatus )
{
    HRESULT hr;
    VARIANT var;

    ULONG cBuff;
    WCHAR awchBuff[1024];
    
    CWbemPtr<IWbemClassObject> pEvent;

    hr = m_pEventClass->SpawnInstance( 0, &pEvent );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // we may not be able to obtain the original event.
    // 

    if ( pOrigEvent != NULL )
    {
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = pOrigEvent;

        hr = pEvent->Put( g_wszEventProp, 0, &var, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
           
    //
    // set time the message was orginally sent.
    // 

    SYSTEMTIME st;
    
    hr = pRcvCtx->GetTimeSent( &st );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    swprintf( awchBuff,
              L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d+000",
              st.wYear, st.wMonth, st.wDay, st.wHour,
              st.wMinute, st.wSecond, 0 );

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = awchBuff;

    hr = pEvent->Put( g_wszTimeProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // set the machine property.  This is always ours.
    // 

    hr = pRcvCtx->GetSendingMachine( awchBuff, 1024, &cBuff );

    if ( FAILED(hr) )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = awchBuff;

    hr = pEvent->Put( g_wszMachineProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now get the target queue that we failed sending to.
    //

    hr = pRcvCtx->GetTarget( awchBuff, 1024, &cBuff );

    if ( FAILED(hr) )
    {
        return hr;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = awchBuff;

    hr = pEvent->Put( g_wszTargetProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the original execution id.
    // 

    if ( StringFromGUID2( rFwdHdr.GetExecutionId(), awchBuff, 1024 ) == 0 )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = awchBuff;

    hr = pEvent->Put( g_wszExecutionIdProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // was auth specified when sending ?
    //

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = rFwdHdr.GetAuthentication() ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = pEvent->Put( g_wszAuthenticationProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // was encryption specified when sending ?
    //

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = rFwdHdr.GetEncryption() ? VARIANT_TRUE : VARIANT_FALSE;
    
    hr = pEvent->Put( g_wszEncryptionProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // what was the Qos used when sending ? 
    //

    V_VT(&var) = VT_I4;
    V_I4(&var) = rFwdHdr.GetQos();

    hr = pEvent->Put( g_wszQosProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // which forwarding consumer was the original sender
    //

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (LPWSTR)rFwdHdr.GetConsumer();

    hr = pEvent->Put( g_wszConsumerProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // which namespace was the original sender in
    //

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = (LPWSTR)rFwdHdr.GetNamespace();

    hr = pEvent->Put( g_wszNamespaceProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // set the reason why this message was returned.
    // 

    V_VT(&var) = VT_I4;
    V_I4(&var) = hrStatus;

    hr = pEvent->Put( g_wszStatusProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return m_pEventSink->Indicate( 1, &pEvent );
}
    
HRESULT CFwdAckEventProv::ProvideEvents( IWbemObjectSink* pSink, long lFlags )
{
    //
    // we were waiting to obtain the sink before starting up the 
    // receivers.
    //

    HRESULT hr = InitializeQueues();

    if ( FAILED(hr) )
    {
        //
        // we logged  the error already, return success though 
        //
        return WBEM_S_FALSE;
    }
    
    hr = InitializeReceivers();

    if ( FAILED(hr) )
    {
        //
        // we logged  the error already, return success though 
        //
        return WBEM_S_FALSE;
    }

    m_pEventSink = pSink;

    return WBEM_S_NO_ERROR;
}

HRESULT CFwdAckEventProv::InitializeQueues()
{
    HRESULT hr;

    //
    // we need to ensure that we have an ack queue created.  The ack 
    // queue accepts messages which could not be delivered to their 
    // destinations. 
    //

    DWORD dwQuota = 0xffffffff;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = CoCreateInstance( CLSID_WmiMessageQueueManager,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageQueueManager,
                           (void**)&pQueueMgr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // always use guaranteed for Acks ( for now anyways )
    // 

    hr = pQueueMgr->Create( g_wszAckQueueName, 
                            g_guidAckQueueType, 
                            FALSE,
                            WMIMSG_FLAG_QOS_GUARANTEED,
                            dwQuota, 
                            pSecDesc );

    if ( FAILED(hr) && hr != WBEM_E_ALREADY_EXISTS )
    {
        ERRORTRACE((LOG_ESS,"FAEVPROV: Could not create/open queue %S, "
                    "HR=0x%x\n", g_wszAckQueueName, hr ));
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFwdAckEventProv::InitializeReceivers()
{
    HRESULT hr;

    //
    // make sure that we verify that any message that is delivered to this 
    // queue originated from this machine.
    //
    DWORD dwFlags = WMIMSG_FLAG_QOS_GUARANTEED | WMIMSG_FLAG_RCVR_PRIV_VERIFY;

    hr = CoCreateInstance( CLSID_WmiMessageMsmqReceiver,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageReceiver,
                           (void**)&m_pRcvr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pRcvr->Open( g_wszAckQueueName,
                        dwFlags,
                        NULL,
                        &m_XSendReceive );
 
    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS,"FAEVPROV: Could not open rcvr for queue %S, "
                    "HR=0x%x\n", g_wszAckQueueName, hr ));
        return hr;
    }
 
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdAckEventProv::NewQuery( DWORD dwId, LPWSTR wszQuery )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdAckEventProv::CancelQuery( DWORD dwId )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdAckEventProv::Receive( PBYTE pData, 
                                    ULONG cData,
                                    PBYTE pAuxData,
                                    ULONG cAuxData,
                                    DWORD dwStatus,
                                    IUnknown* pCtx )
{
    HRESULT hr;

    CBuffer DataStrm( pData, cData, FALSE );
    CBuffer HdrStrm( pAuxData, cAuxData, FALSE );

    if ( pCtx == NULL )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    CWbemPtr<IWmiMessageReceiverContext> pRcvCtx;
    
    hr = pCtx->QueryInterface( IID_IWmiMessageReceiverContext, 
                               (void**)&pRcvCtx );

    if ( FAILED(hr) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    CFwdMsgHeader FwdHdr;

    hr = FwdHdr.Unpersist( HdrStrm );

    if ( FAILED(hr) )
    {
        return hr;
    }

    ULONG iData = DataStrm.GetIndex();

    for( ULONG i=0; i < FwdHdr.GetNumObjects(); i++ )
    {
        ULONG cUsed;
        CWbemPtr<IWbemClassObject> pObj;
        
        hr = m_pMrsh->Unpack( cData-iData, pData+iData, 0, &pObj, &cUsed );

        //
        // sometimes, such as when encryption is used, we cannot obtain the 
        // event object.  so ignore the return from unmarshal,
        // its ok if pObj is NULL.
        //

        if ( SUCCEEDED(hr) )
        {
            iData += cUsed;
        }

        FireAckEvent( pObj, pRcvCtx, FwdHdr, dwStatus );
    }

    return hr;
}   

HRESULT CFwdAckEventProv::HandleRecvError( HRESULT hr, LPCWSTR wszError )
{
    //
    // right now just log to ESS log.
    //
    ERRORTRACE((LOG_ESS,"FAEVPROV: RECV Error, ErrorString=%S, HR=0x%x\n",
                wszError, hr ));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconnspc.h ===
#ifndef __FCONNSPC_H__
#define __FCONNSPC_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <comutl.h>
#include <unk.h>
#include <wmimsg.h>
#include <wstring.h>

/*****************************************************************************
  CFwdContext - we use this context object to thread information through 
  the senders.
****************************************************************************/ 

struct CFwdContext : public CUnk
{
    //
    // is true when a successful send has been performed by an msmq sender.
    //
    BOOL m_bQueued; 
     
    //
    // contains the name of the sender that performed a successful send.
    // is empty if no senders succeed.
    //
    WString m_wsTarget;

    //
    // contains the events that are indicated to the consumer.  Used for 
    // tracing.
    //
    ULONG m_cEvents;
    IWbemClassObject** m_apEvents;
    
    //
    // for each execution of a fwding consumer a new guid is created. this
    // allows us to correlate target trace events with a given execution.
    //
    GUID m_guidExecution;

    CWbemPtr<IWbemClassObject> m_pCons;

    CFwdContext( GUID& guidExecution, 
                 IWbemClassObject* pCons,
                 ULONG cEvents,
                 IWbemClassObject** apEvents ) 
     : m_guidExecution( guidExecution ), m_pCons(pCons), 
       m_bQueued(FALSE), m_cEvents(cEvents), m_apEvents(apEvents) {}
 
    void* GetInterface( REFIID riid ) { return NULL; }
};

/*************************************************************************
  CFwdConsNamespace
**************************************************************************/
 
class CFwdConsNamespace 
: public CUnkBase<IWmiMessageTraceSink,&IID_IWmiMessageTraceSink>
{
    CWbemPtr<IWbemDecoupledBasicEventProvider> m_pDES;
    CWbemPtr<IWbemServices> m_pSvc;
    CWbemPtr<IWbemEventSink> m_pTraceSuccessSink;
    CWbemPtr<IWbemEventSink> m_pTraceFailureSink;
    CWbemPtr<IWbemClassObject> m_pTargetTraceClass;
    CWbemPtr<IWbemClassObject> m_pTraceClass;
    WString m_wsName;
    long m_lTrace;

    ~CFwdConsNamespace();

    HRESULT InitializeTraceEventBase( IWbemClassObject* pTrace,
                                      HRESULT hres,
                                      CFwdContext* pCtx );
public:

    HRESULT Initialize( LPCWSTR wszNamespace );
  
    IWbemServices* GetSvc() { return m_pSvc; } 
    LPCWSTR GetName() { return m_wsName; } 

    CFwdConsNamespace() 
    : CUnkBase<IWmiMessageTraceSink,&IID_IWmiMessageTraceSink>(NULL), 
      m_lTrace(0) {}

    void* GetInterface( REFIID riid );

    HRESULT NewQuery( DWORD dwId, LPWSTR wszQuery ) 
    { 
        InterlockedIncrement(&m_lTrace);
        return WBEM_S_NO_ERROR;
    }

    HRESULT CancelQuery( DWORD dwId )
    {
        InterlockedDecrement( &m_lTrace );
        return WBEM_S_NO_ERROR;
    }

    HRESULT HandleTrace( HRESULT hres, CFwdContext* pCtx );

    STDMETHOD(Notify)( HRESULT hRes,
                       GUID guidSource,
                       LPCWSTR wszTrace,
                       IUnknown* pContext );
};

#endif // __FCONNSPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconprov.cpp ===
#include "precomp.h"
#include <assert.h>
#include <sync.h>
#include <arrtempl.h>
#include <wstring.h>
#include <comutl.h>
#include <map>
#include <wstlallc.h>
#include "fconprov.h"
#include "fconnspc.h"
#include "fconsink.h"

LPCWSTR g_wszNamespace = L"__NAMESPACE";
LPCWSTR g_wszClass = L"__CLASS";
LPCWSTR g_wszEventFwdCons = L"MSFT_EventForwardingConsumer";
LPCWSTR g_wszDataFwdCons = L"MSFT_DataForwardingConsumer";

static CCritSec g_cs;
typedef CWbemPtr<CFwdConsNamespace> CFwdConsNamespaceP;
typedef std::map<WString,CFwdConsNamespaceP,WSiless,wbem_allocator<CFwdConsNamespaceP> > NamespaceMap; 
NamespaceMap* g_pNamespaces;
 
HRESULT CFwdConsProv::InitializeModule()
{
    g_pNamespaces = new NamespaceMap;
    
    if ( g_pNamespaces == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return WBEM_S_NO_ERROR;
}

void CFwdConsProv::UninitializeModule()
{
    delete g_pNamespaces;
}

HRESULT CFwdConsProv::FindConsumer( IWbemClassObject* pCons,
                                    IWbemUnboundObjectSink** ppSink )
{
    ENTER_API_CALL

    HRESULT hr;

    //
    // workaround for bogus context object left on thread by wmi.
    // just remove it. shouldn't leak because this call doesn't addref it.
    //
    IUnknown* pCtx;
    CoSwitchCallContext( NULL, &pCtx ); 

    //
    // first obtain the namespace object. we derive the namespace from 
    // the consumer object.  If no namespace obj is there, create one.
    //

    CPropVar vNamespace;

    hr = pCons->Get( g_wszNamespace, 0, &vNamespace, NULL, NULL );

    if ( FAILED(hr) || FAILED(hr=vNamespace.SetType(VT_BSTR)) )
    {
        return hr;
    }

    CInCritSec ics( &g_cs );

    CWbemPtr<CFwdConsNamespace> pNspc = (*g_pNamespaces)[V_BSTR(&vNamespace)];

    if ( pNspc == NULL )
    {
        pNspc = new CFwdConsNamespace;

        if ( pNspc == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = pNspc->Initialize( V_BSTR(&vNamespace) );

        if ( FAILED(hr) )
        {
            return hr;
        }

        (*g_pNamespaces)[V_BSTR(&vNamespace)] = pNspc;
    }

    return CFwdConsSink::Create( m_pControl, pNspc, pCons, ppSink );

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconnspc.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include "fconnspc.h"

LPCWSTR g_wszConsumer = L"Consumer";
LPWSTR g_wszTarget = L"Target";
LPWSTR g_wszQueued = L"Queued";
LPWSTR g_wszTargetUsed = L"TargetUsed";
LPCWSTR g_wszStatusCode = L"StatusCode";
LPCWSTR g_wszExecutionId = L"ExecutionId";
LPWSTR g_wszTraceClass = L"MSFT_FCExecutedTraceEvent";
LPWSTR g_wszTargetTraceClass = L"MSFT_FCTargetTraceEvent";
LPWSTR g_wszEvents = L"Events";
LPCWSTR g_wszTraceProvider
 = L"Microsoft WMI Forwarding Consumer Trace Event Provider";

LPCWSTR g_wszTraceSuccessQuery = 
 L"SELECT * FROM MSFT_FCTraceEventBase WHERE StatusCode <= 1"; 

LPCWSTR g_wszTraceFailureQuery = 
 L"SELECT * FROM MSFT_FCTraceEventBase WHERE StatusCode > 1";

/**************************************************************************
  CFwdConsQuerySink - this implements the ProviderQuerySink.  This would 
  normally be implemented by CFwdConsNamespace, but we'd end up with a 
  circular reference on the DES.
****************************************************************************/
class CFwdConsQuerySink 
: public CUnkBase<IWbemEventProviderQuerySink,&IID_IWbemEventProviderQuerySink>
{
    CFwdConsNamespace* m_pNspc; // doesn't hold ref.

public:
    
    STDMETHOD(NewQuery)( DWORD dwId, LPWSTR wszLanguage, LPWSTR wszQuery )
    {
        return m_pNspc->NewQuery( dwId, wszQuery );
    }
        
    STDMETHOD(CancelQuery)( DWORD dwId )
    {
        return m_pNspc->CancelQuery( dwId );
    }

    CFwdConsQuerySink( CFwdConsNamespace* pNspc ) 
    : CUnkBase< IWbemEventProviderQuerySink,
                &IID_IWbemEventProviderQuerySink>(NULL), m_pNspc( pNspc ) {} 
public:

    static HRESULT Create( CFwdConsNamespace* pNspc, 
                           IWbemEventProviderQuerySink** ppSink )
    {
        CWbemPtr<IWbemEventProviderQuerySink> pSink;

        pSink = new CFwdConsQuerySink( pNspc );

        if ( pSink == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        pSink->AddRef();
        *ppSink = pSink;

        return WBEM_S_NO_ERROR;
    }
};

CFwdConsNamespace::~CFwdConsNamespace()
{
    if ( m_pDES != NULL )
    {
        m_pDES->UnRegister();
    }
}

HRESULT CFwdConsNamespace::InitializeTraceEventBase( IWbemClassObject* pTrace, 
                                                     HRESULT hres,
                                                     CFwdContext* pCtx )
{
    HRESULT hr;
    VARIANT var;
    
    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pCtx->m_pCons;

    hr = pTrace->Put( g_wszConsumer, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    WCHAR achExecutionId[64];
    
    if ( StringFromGUID2( pCtx->m_guidExecution, achExecutionId, 64 ) == 0 )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = achExecutionId;

    hr = pTrace->Put( g_wszExecutionId, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    V_VT(&var) = VT_I4;
    V_I4(&var) = hres;
    
    return pTrace->Put( g_wszStatusCode, 0, &var, NULL );
}    

//
// called after each execution of a forwarding consumer.
//

HRESULT CFwdConsNamespace::HandleTrace( HRESULT hres, CFwdContext* pCtx )
{
    HRESULT hr;

    CWbemPtr<IWbemEventSink> pTraceSink;

    if ( SUCCEEDED(hres) )
    {
        if ( m_pTraceSuccessSink->IsActive() == WBEM_S_FALSE )
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pTraceSink = m_pTraceSuccessSink;
        }
    }
    else if ( m_pTraceFailureSink->IsActive() == WBEM_S_FALSE )
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        pTraceSink = m_pTraceFailureSink;
    }
            
    CWbemPtr<IWbemClassObject> pTrace;

    hr = m_pTraceClass->SpawnInstance( 0, &pTrace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = InitializeTraceEventBase( pTrace, hres, pCtx );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // set the events that were indicated in the trace event 
    // 

    VARIANT var;
    V_VT(&var) = VT_ARRAY | VT_UNKNOWN;
    V_ARRAY(&var) = SafeArrayCreateVector( VT_UNKNOWN, 0, pCtx->m_cEvents );
    
    if ( V_ARRAY(&var) == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    {
        CPropSafeArray<IUnknown*> apEvents(V_ARRAY(&var));

        for( ULONG i=0; i < pCtx->m_cEvents; i++ )
        {
            apEvents[i] = pCtx->m_apEvents[i];
            apEvents[i]->AddRef();
        }    
    }
     
    hr = pTrace->Put( g_wszEvents, 0, &var, NULL );

    VariantClear( &var );

    if ( FAILED(hr) )
    {
        return hr;
    }
        
    //
    // don't set other props on failure.
    //

    if ( FAILED(hres) )
    {
        return pTraceSink->Indicate( 1, &pTrace );
    }

    //
    // it is possible that there may be not target.
    //

    if ( pCtx->m_wsTarget.Length() > 0 )
    {
        LPWSTR wszTarget = pCtx->m_wsTarget;

        V_VT(&var) = VT_BSTR;
        V_BSTR(&var) = wszTarget;
    
        hr = pTrace->Put( g_wszTargetUsed, 0, &var, NULL );
    
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = pCtx->m_bQueued ? VARIANT_TRUE : VARIANT_FALSE;

    hr = pTrace->Put( g_wszQueued, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return pTraceSink->Indicate( 1, &pTrace );
}

//
// This is called by Senders when their SendReceive() method is called for
// both error and success states.  In both cases the wszTrace string will 
// be the name of the sender.  Senders, such as the multisender or fwdsender
// can call the sink multiple times since they can represent multiple 
// connections.  Since all Senders initialize themselves lazily, we don't
// have to worry about generating trace events when Open() calls fail.
// 
STDMETHODIMP CFwdConsNamespace::Notify( HRESULT hres, 
                                        GUID guidSource,
                                        LPCWSTR wszTrace, 
                                        IUnknown* pContext )
{
    HRESULT hr;

    //
    // since we are the ones who created the context, we can safely cast.
    //

    CFwdContext* pCtx = (CFwdContext*)pContext;
    
    if ( SUCCEEDED(hres) )
    {
        //
        // save any state with the context about the successful send.
        //

        if ( guidSource == CLSID_WmiMessageMsmqSender )
        {
            pCtx->m_bQueued = TRUE;
        }

        pCtx->m_wsTarget = wszTrace;
    }

    CWbemPtr<IWbemEventSink> pTraceSink;

    if ( SUCCEEDED(hres) )
    {
        if ( m_pTraceSuccessSink->IsActive() == WBEM_S_FALSE )
        {
            return WBEM_S_NO_ERROR;
        }
        else
        {
            pTraceSink = m_pTraceSuccessSink;
        }
    }
    else if ( m_pTraceFailureSink->IsActive() == WBEM_S_FALSE )
    {
        return WBEM_S_NO_ERROR;
    }
    else
    {
        pTraceSink = m_pTraceFailureSink;
    }

    CWbemPtr<IWbemClassObject> pTrace;

    hr = m_pTargetTraceClass->SpawnInstance( 0, &pTrace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = InitializeTraceEventBase( pTrace, hres, pCtx );

    if ( FAILED(hr) )
    {
        return hr;
    }

    LPWSTR wszTmp = LPWSTR(wszTrace);
 
    VARIANT var;
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = wszTmp;
    
    hr = pTrace->Put( g_wszTarget, 0, &var, NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }
    
    return pTraceSink->Indicate( 1, &pTrace );
}

HRESULT CFwdConsNamespace::Initialize( LPCWSTR wszNamespace )
{
    HRESULT hr;

    m_wsName = wszNamespace;

    //
    // register our decoupled event provider 
    //

    hr = CoCreateInstance( CLSID_WbemDecoupledBasicEventProvider, 
                           NULL, 
       			   CLSCTX_INPROC_SERVER, 
       			   IID_IWbemDecoupledBasicEventProvider,
       			   (void**)&m_pDES );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pDES->Register( 0,
                         NULL,
                         NULL,
                         NULL,
                         wszNamespace,
                         g_wszTraceProvider,
                         NULL );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the service pointer for out namespace
    //

    hr = m_pDES->GetService( 0, NULL, &m_pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get the decoupled event sink
    //

    CWbemPtr<IWbemObjectSink> pTraceObjectSink;

    hr = m_pDES->GetSink( 0, NULL, &pTraceObjectSink );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemEventSink> pTraceEventSink;

    hr = pTraceObjectSink->QueryInterface( IID_IWbemEventSink, 
                                           (void**)&pTraceEventSink);

    if ( FAILED(hr) )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // get restricted query for successes.
    //
    
    hr = pTraceEventSink->GetRestrictedSink( 1, 
                                             &g_wszTraceSuccessQuery,
                                             NULL, 
                                             &m_pTraceSuccessSink );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get restricted query for failures.
    //
    
    hr = pTraceEventSink->GetRestrictedSink( 1, 
                                             &g_wszTraceFailureQuery,
                                             NULL, 
                                             &m_pTraceFailureSink );
    if ( FAILED(hr) ) 
    {
        return hr;
    }

    //
    // more trace initialization
    //

    hr = m_pSvc->GetObject( g_wszTraceClass, 0, NULL, &m_pTraceClass, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = m_pSvc->GetObject( g_wszTargetTraceClass, 
                            0, 
                            NULL,
                            &m_pTargetTraceClass, 
                            NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconprov.h ===
#ifndef __FCONPROV_H__
#define __FCONPROV_H__

#include <wbemcli.h>
#include <wbemprov.h>
#include <unk.h>

/*************************************************************************
  CFwdConsProv
**************************************************************************/

class CFwdConsProv 
: public CUnkBase<IWbemEventConsumerProvider,&IID_IWbemEventConsumerProvider>
{
public:

    CFwdConsProv( CLifeControl* pCtl )
     : CUnkBase< IWbemEventConsumerProvider,
                 &IID_IWbemEventConsumerProvider>( pCtl ) {} 

    STDMETHOD(FindConsumer)( IWbemClassObject* pLogicalConsumer,
                             IWbemUnboundObjectSink** ppConsumer );

    static HRESULT InitializeModule();
    static void UninitializeModule();
};

#endif // __FCONPROV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fwdhdr.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <wmimsg.h>
#include "fwdhdr.h"

const DWORD g_dwSig = 0x66696d77;
const BYTE g_chVersionMajor = 1;
const BYTE g_chVersionMinor = 0;
const BYTE g_achPad[] = { 0, 0, 0 };

/**************************************************************************
  CFwdMsgHeader
***************************************************************************/


CFwdMsgHeader::CFwdMsgHeader()
{
    ZeroMemory( this, sizeof( CFwdMsgHeader ) );
}

CFwdMsgHeader::CFwdMsgHeader( DWORD dwNumObjs, 
                              DWORD dwQos,
                              BOOL bAuth,
                              BOOL bEncrypt,
                              GUID& rguidExecution,
                              LPCWSTR wszConsumer,
                              LPCWSTR wszNamespace,
                              PBYTE pTargetSD,
                              ULONG cTargetSD )
: m_dwNumObjs(dwNumObjs), m_chQos(char(dwQos)), 
  m_chEncrypt(char(bEncrypt)), m_wszConsumer( wszConsumer ), 
  m_guidExecution(rguidExecution), m_chAuth(char(bAuth)),
  m_pTargetSD( pTargetSD ), m_cTargetSD( cTargetSD ),
  m_wszNamespace( wszNamespace )
{

}

HRESULT CFwdMsgHeader::Persist( CBuffer& rStrm )
{
    HRESULT hr;

    //
    // write signature.
    //

    hr = rStrm.Write( &g_dwSig, 4, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write version major.
    //

    hr = rStrm.Write( &g_chVersionMajor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // write version minor.
    //

    hr = rStrm.Write( &g_chVersionMinor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write reserved flags ( currently not used ).
    //

    DWORD dwReserved = 0;
    
    hr = rStrm.Write( &dwReserved, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // write num events contained in data.
    //

    hr = rStrm.Write( &m_dwNumObjs, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write Qos used 
    //

    hr = rStrm.Write( &m_chQos, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write if Auth was used.
    //

    hr = rStrm.Write( &m_chAuth, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write if Encryption was used.
    //

    hr = rStrm.Write( &m_chEncrypt, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // pad so that subsequent strings will at least be on 2 byte boundaries
    //

    hr = rStrm.Write( g_achPad, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write execution id.
    //

    hr = rStrm.Write( &m_guidExecution, sizeof(GUID), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }    
    
    //
    // write name of forwarding consumer
    //

    hr = rStrm.WriteLPWSTR( m_wszConsumer );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write the namespace of the forwarding consumer
    // 

    hr = rStrm.WriteLPWSTR( m_wszNamespace );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write SD used for the event at Target. 
    //

    hr = rStrm.Write( &m_cTargetSD, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_cTargetSD > 0 )
    {
        hr = rStrm.Write( m_pTargetSD, m_cTargetSD, NULL );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CFwdMsgHeader::Unpersist( CBuffer& rStrm )
{
    HRESULT hr;
    DWORD dwSig;
    BYTE chVersionMajor, chVersionMinor;

    //
    // read and verify signature.
    //

    hr = rStrm.Read( &dwSig, 4, NULL );

    if ( hr != S_OK || dwSig != g_dwSig )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read and check version major (currently no check).
    //

    hr = rStrm.Read( &chVersionMajor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    // 
    // read and check version minor (currently no check).
    //

    hr = rStrm.Read( &chVersionMinor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read reserved
    //

    DWORD dwReserved;

    hr = rStrm.Read( &dwReserved, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    //
    // read num events contained in data.
    //

    hr = rStrm.Read( &m_dwNumObjs, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read Qos used 
    //

    hr = rStrm.Read( &m_chQos, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read if Auth was used.
    //

    hr = rStrm.Read( &m_chAuth, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read if Encryption was used.
    //

    hr = rStrm.Read( &m_chEncrypt, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read byte pad 
    //

    BYTE chPad;
    hr = rStrm.Read( &chPad, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read execution id.
    //

    hr = rStrm.Read( &m_guidExecution, sizeof(GUID), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }    

    //
    // read name of forwarding consumer
    //

    hr = rStrm.ReadLPWSTR( m_wszConsumer );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read namespace of forwarding consumer
    //

    hr = rStrm.ReadLPWSTR( m_wszNamespace );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read SD to use for signaling event
    //

    hr = rStrm.Read( &m_cTargetSD, sizeof(DWORD), NULL );

    if ( hr != S_OK || m_cTargetSD > rStrm.GetSize() - rStrm.GetIndex() )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    if ( m_cTargetSD > 0 )
    {
        m_pTargetSD = rStrm.GetRawData() + rStrm.GetIndex();
        rStrm.Advance( m_cTargetSD );
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsend.h ===
#ifndef __FCONSEND_H__
#define __FCONSEND_H__

#include <sync.h>
#include <unk.h>
#include <wbemcli.h>
#include <comutl.h>
#include <wstring.h>
#include "wmimsg.h"

/*********************************************************************
  CFwdConsSend - fwdcons senders handle issues with resolving logical 
  target names and also setting up alternate destinations - for 
  example, when sending using async qos, the it will try to use a 
  dcom sender and then resort to an msmq sender.
**********************************************************************/

class CFwdConsSend 
: public CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>
{
    CCritSec m_cs;
    WString m_wsTarget;
    DWORD m_dwFlags;
    BOOL m_bResolved;
    CWbemPtr<IWbemServices> m_pDefaultSvc;
    CWbemPtr<IWmiMessageMultiSendReceive> m_pMultiSend;
    CWbemPtr<IWmiMessageTraceSink> m_pTraceSink;

    CFwdConsSend( CLifeControl* pCtl ) 
     : CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>(pCtl), 
       m_bResolved(FALSE) { }

    void DeriveQueueLogicalName( WString& rwsPathName, BOOL bAuth );
    HRESULT HandleTrace( HRESULT hr, IUnknown* pCtx );
    HRESULT AddAsyncSender( LPCWSTR wszMachine );
    HRESULT AddPhysicalSender( LPCWSTR wszMachine );
    HRESULT AddMSMQSender( LPCWSTR wszFormatName );
    HRESULT AddSyncSender( LPCWSTR wszMachine );
    HRESULT AddLogicalSender( LPCWSTR wszTarget );
    HRESULT AddLogicalSender( LPCWSTR wszObjPath, LPCWSTR wszProp );
    HRESULT EnsureSender();

public:
    
    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pCtx );

    static HRESULT Create( CLifeControl* pCtl,
                           LPCWSTR wszTarget,
                           DWORD dwFlags,                    
                           IWbemServices* pDefaultSvc,
                           IWmiMessageTraceSink* pTraceSink,
                           IWmiMessageSendReceive** ppSend );
};

#endif // __FCONSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsink.h ===
#ifndef __FCONSINK_H__
#define __FCONSINK_H__

#include <comutl.h>
#include <unk.h>
#include <wmimsg.h>
#include <wstring.h>
#include "fconnspc.h"

/*************************************************************************
  CFwdConsSink
**************************************************************************/
 
class CFwdConsSink 
: public CUnkBase< IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink > 
{
    CFwdConsNamespace* m_pNamespace;
    CWbemPtr<IWmiMessageMultiSendReceive> m_pMultiSend;
    WString m_wsName;
    DWORD m_dwFlags;
    ULONG m_ulLastDataSize;
    ULONG m_cTargetSD;
    PSECURITY_DESCRIPTOR m_pTargetSD;
    DWORD m_dwCurrentMrshFlags;
    DWORD m_dwDisconnectedMrshFlags;

    CWbemPtr<IWmiObjectMarshal> m_pMrsh;

protected:
  
    CFwdConsSink( CLifeControl* pCtl ) : 
      CUnkBase<IWbemUnboundObjectSink, &IID_IWbemUnboundObjectSink>(pCtl),
      m_ulLastDataSize(0), m_pTargetSD(NULL), m_cTargetSD(0) { }

    ~CFwdConsSink();

    HRESULT Initialize( CFwdConsNamespace* pNspc, IWbemClassObject* pCons );
    
    HRESULT IndicateSome( IWbemClassObject* pLogicalConsumer, 
                          long cObjs, 
                          IWbemClassObject** ppObjs,
                          long* pcProcessed );
public:

    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pLogicalConsumer, 
                                   long cObjs, 
                                   IWbemClassObject** ppObjs );
 
    HRESULT Notify( HRESULT hRes,
                    GUID guidSource,
                    LPCWSTR wszTrace,
                    IUnknown* pContext );

    static HRESULT Create( CLifeControl* pCtl, 
                           CFwdConsNamespace* pNspc,
                           IWbemClassObject* pCons, 
                           IWbemUnboundObjectSink** ppSink );
};


#endif // __FCONSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fevprov.cpp ===
#include "precomp.h"
#include <sspi.h>
#include <secext.h>
#include <ntdsapi.h>
#include <stdio.h>
#include <buffer.h>
#include <winntsec.h>
#include <callsec.h>
#include <wbemint.h>
#include <wbemutil.h>
#include <arrtempl.h>
#include <tchar.h>
#include "fevprov.h"
#include "fwdhdr.h"

static LPWSTR g_wszEventClass = L"MSFT_ForwardedEvent";
static LPWSTR g_wszEventProp = L"Event";
static LPWSTR g_wszMachineProp = L"Machine";
static LPWSTR g_wszConsumerProp = L"Consumer";
static LPWSTR g_wszNamespaceProp = L"Namespace";
static LPWSTR g_wszAuthenticatedProp = L"Authenticated";
static LPWSTR g_wszAccountProp = L"Account";
static LPWSTR g_wszSDProp = L"SECURITY_DESCRIPTOR";
static LPWSTR g_wszTimeProp = L"Time";

// {0F3162C5-7B5A-469f-955C-79603B7EB5A6}
static const GUID g_guidQueueType = 
{ 0xf3162c5, 0x7b5a, 0x469f, {0x95, 0x5c, 0x79, 0x60, 0x3b, 0x7e, 0xb5, 0xa6}};

LPCWSTR g_awszQueueNames[] = { L".\\private$\\WMIFwdGuaranteed",
                               L".\\private$\\WMIFwdExpress",
                               L".\\private$\\WMIFwdGuaranteedAuth",      
                               L".\\private$\\WMIFwdExpressAuth",
                               L".\\WMIFwdGuaranteedEncrypt",
                               L".\\WMIFwdExpressEncrypt" }; 

BOOL g_adwQueueQos[] = { WMIMSG_FLAG_QOS_GUARANTEED,
                         WMIMSG_FLAG_QOS_EXPRESS,
                         WMIMSG_FLAG_QOS_GUARANTEED,
                         WMIMSG_FLAG_QOS_EXPRESS,
                         WMIMSG_FLAG_QOS_GUARANTEED,
                         WMIMSG_FLAG_QOS_EXPRESS };

BOOL g_abQueueAuth[] = { FALSE, FALSE, TRUE, TRUE, TRUE, TRUE };

extern BOOL AllowUnauthenticatedEvents();

DWORD GetWmiSPNs( CWStringArray& rawsSPNs )
{
    DWORD dwRes, cSpn, i;
    LPWSTR* pwszSpn;

    dwRes = DsGetSpn( DS_SPN_DNS_HOST, L"WMI", NULL, 0, 0,
                      NULL, NULL, &cSpn, &pwszSpn );

    if ( dwRes == NO_ERROR )
    {
        for( i=0; i < cSpn; i++ )
        {
            rawsSPNs.Add( pwszSpn[i] );
        }

        DsFreeSpnArray( cSpn, pwszSpn );

        dwRes = DsGetSpn( DS_SPN_NB_HOST, L"WMI", NULL, 0, 0,
                          NULL, NULL, &cSpn, &pwszSpn );

        if ( dwRes == NO_ERROR )
        {
            for( i=0; i < cSpn; i++ )
            {
                rawsSPNs.Add( pwszSpn[i] );
            }
            DsFreeSpnArray( cSpn, pwszSpn );
        }
    }

    return dwRes;
} 

//
// this function registers an SPN in AD for the WMI Service.  This is 
// necessary for clients that wish to communicate with the WMI Service using 
// kerberos.  The SPN registered is based on a DNS or Netbios hostname.
// Later, this function should be moved to WMI startup, but since this is 
// the only service within WMI that requires kerberos it is here.
// 

DWORD RegisterSPNs( LPCWSTR* pwszSPNs, ULONG cSPNs )
{
    DWORD dwRes;
    HANDLE hDS;        
    
    dwRes = DsBind( NULL, NULL, &hDS );

    if ( dwRes != NO_ERROR )
    {
        return dwRes;
    }

    DWORD cAccount = 0;
            
    GetUserNameExW( NameFullyQualifiedDN, NULL, &cAccount );
            
    if ( GetLastError() == ERROR_MORE_DATA )
    {
        LPWSTR wszAccount = new WCHAR[cAccount];
            
        if ( wszAccount != NULL )
        {
            if ( GetUserNameExW( NameFullyQualifiedDN, 
                                 wszAccount, 
                                 &cAccount ) )
            {
                dwRes = DsWriteAccountSpn( hDS, 
                                           DS_SPN_ADD_SPN_OP,
                                           wszAccount,
                                           cSPNs,
                                           pwszSPNs );                
            }
            else
            {
                dwRes = GetLastError();
            }

            delete [] wszAccount;
        }
        else
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwRes = GetLastError();
    }

    DsUnBind( &hDS );

    return dwRes;
}

/**************************************************************************
  CFwdEventProv
***************************************************************************/

CFwdEventProv::CFwdEventProv( CLifeControl* pCtl, IUnknown* pUnk )
: CUnk( pCtl, pUnk ), m_XErrorSink( this ), m_XSendReceive( this ), 
  m_XProv( this ), m_XQuery( this ), m_XInit( this ),
  m_lMachineProp(-1), m_lConsumerProp(-1), m_lNamespaceProp(-1), 
  m_lAuthProp(-1), m_lAccountProp(-1), m_lTimeProp(-1), m_lSDProp(-1)
{
}

CFwdEventProv::~CFwdEventProv()
{

}

void* CFwdEventProv::GetInterface( REFIID riid )
{
    if ( riid == IID_IWbemEventProvider )
    {
        return &m_XProv;
    }
    else if ( riid == IID_IWbemProviderInit )
    {
        return &m_XInit;
    }
    else if ( riid == IID_IWmiMessageTraceSink )
    {
        return &m_XErrorSink;
    }
    else if ( riid == IID_IWmiMessageSendReceive )
    {
        return &m_XSendReceive;
    }
    else if ( riid == IID_IWbemEventProviderQuerySink )
    {
        return &m_XQuery;
    }
    return NULL;
}

HRESULT CFwdEventProv::Init( IWbemServices* pSvc, 
                             IWbemProviderInitSink* pInitSink )
{
    ENTER_API_CALL

    HRESULT hr;

    m_pSvc = pSvc;

    hr = pSvc->GetObject( g_wszEventClass, 
                          0, 
                          NULL, 
                          &m_pEventClass, 
                          NULL );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get handles for all the properties in the event .
    //

    CWbemPtr<_IWmiObject> pWmiEventClass;

    hr = m_pEventClass->QueryInterface( IID__IWmiObject, 
                                        (void**)&pWmiEventClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszMachineProp,
                                              0, 
                                              NULL, 
                                              &m_lMachineProp );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszConsumerProp, 
                                              0, 
                                              NULL, 
                                              &m_lConsumerProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszNamespaceProp, 
                                              0, 
                                              NULL, 
                                              &m_lNamespaceProp );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszAuthenticatedProp, 
                                              0, 
                                              NULL, 
                                              &m_lAuthProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszSDProp, 
                                              0, 
                                              NULL, 
                                              &m_lSDProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszAccountProp, 
                                              0, 
                                              NULL, 
                                              &m_lAccountProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEventClass->GetPropertyHandleEx( g_wszTimeProp, 
                                              0, 
                                              NULL, 
                                              &m_lTimeProp );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = CoCreateInstance( CLSID_WmiSmartObjectUnmarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&m_pMrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    return pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );

    EXIT_API_CALL
}

HRESULT CFwdEventProv::InitializeEvent( IWbemClassObject* pOriginalEvent,
                                        IWmiMessageReceiverContext* pRecvCtx,
                                        LPCWSTR wszConsumer,
                                        LPCWSTR wszNamespace,
                                        PBYTE pSD,
                                        ULONG cSD,
                                        IWbemClassObject* pEvent ) 
{
    HRESULT hr;
    VARIANT var;

    CWbemPtr<_IWmiObject> pWmiEvent;
    hr = pEvent->QueryInterface( IID__IWmiObject, (void**)&pWmiEvent );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    SYSTEMTIME st;
    BYTE achBuff[256];
    CBuffer Buff( achBuff, 256, FALSE );

    WCHAR* pwchBuff = (WCHAR*)Buff.GetRawData();
    ULONG cBuff =  Buff.GetSize() / 2;

    //
    // Time Sent
    //

    hr = pRecvCtx->GetTimeSent( &st );

    if ( FAILED(hr) )
    {
        return hr;
    }

    swprintf( pwchBuff,
             L"%04.4d%02.2d%02.2d%02.2d%02.2d%02.2d.%06.6d+000",
             st.wYear, st.wMonth, st.wDay, st.wHour,
             st.wMinute, st.wSecond, 0 );

    hr = pWmiEvent->WritePropertyValue( m_lTimeProp, 
                                        (wcslen(pwchBuff)+1)*2,
                                        Buff.GetRawData() );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Sending Machine
    //

    pwchBuff = (WCHAR*)Buff.GetRawData();
    cBuff = Buff.GetSize() / 2;

    hr = pRecvCtx->GetSendingMachine( pwchBuff, cBuff, &cBuff );

    if ( hr == WBEM_S_FALSE )
    {
        hr = Buff.SetSize( cBuff*2 ); // note: size for wchars

        if ( FAILED(hr) )
        {
            return hr;
        }

        pwchBuff = (WCHAR*)Buff.GetRawData();
        cBuff = Buff.GetSize() / 2;
        
        hr = pRecvCtx->GetSendingMachine( pwchBuff, cBuff, &cBuff );
    }

    if ( SUCCEEDED(hr) && cBuff > 0 ) 
    {
        hr = pWmiEvent->WritePropertyValue( m_lMachineProp, 
                                            cBuff*2,
                                            Buff.GetRawData() ); 
                                           
    }

    //
    // Sender Authenticated
    //

    hr = pRecvCtx->IsSenderAuthenticated();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pWmiEvent->WriteDWORD( m_lAuthProp, hr == S_OK ? 1 : 0 );  

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Sender Identity
    //

    ULONG cSid;
    hr = pRecvCtx->GetSenderId( Buff.GetRawData(), Buff.GetSize(), &cSid );
    
    if ( hr == WBEM_S_FALSE )
    {
        hr = Buff.SetSize( cSid );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pRecvCtx->GetSenderId( Buff.GetRawData(), Buff.GetSize(), &cSid );
    }

    if ( SUCCEEDED(hr) && cSid > 0 )
    {
        hr = pWmiEvent->SetArrayPropRangeByHandle( m_lAccountProp,
                                                   WMIARRAY_FLAG_ALLELEMENTS,
                                                   0,
                                                   cSid,
                                                   cSid,
                                                   Buff.GetRawData() );
    }

    //
    // Original Event
    //

    V_VT(&var) = VT_UNKNOWN;
    V_UNKNOWN(&var) = pOriginalEvent;

    hr = pEvent->Put( g_wszEventProp, 0, &var, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Sending Consumer Name
    // 

    if ( wszConsumer != NULL )
    {
        hr = pWmiEvent->WritePropertyValue( m_lConsumerProp, 
                                            (wcslen(wszConsumer)+1)*2, 
                                            PBYTE(wszConsumer) );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // Sending Consumer Namespace
    // 

    if ( wszNamespace != NULL )
    {
        hr = pWmiEvent->WritePropertyValue( m_lNamespaceProp, 
                                            (wcslen(wszNamespace)+1)*2,
                                            PBYTE(wszNamespace) );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // set the security descriptor on the event if specified. 
    // 

    if ( cSD > 0 )
    {
        hr = pWmiEvent->SetArrayPropRangeByHandle( m_lSDProp,
                                                   WMIARRAY_FLAG_ALLELEMENTS,
                                                   0,
                                                   cSD,
                                                   cSD,
                                                   pSD );
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return WBEM_S_NO_ERROR;
}
    
HRESULT CFwdEventProv::ProvideEvents( IWbemObjectSink* pSink, long lFlags )
{
    ENTER_API_CALL

    m_pEventSink = pSink;

    //
    // we were waiting to obtain the sink before starting up the 
    // receivers.
    //

    DEBUGTRACE((LOG_ESS,"FEVPROV: Begin Initializing.\n"));

    BOOL bAllowUnauth = AllowUnauthenticatedEvents();

    HRESULT hr;
#ifdef __WHISTLER_UNCUT
    hr = InitializeQueues( bAllowUnauth );

    if ( FAILED(hr) )
    {
        return hr;
    }
#endif

    hr = InitializeReceivers( bAllowUnauth );

    DEBUGTRACE((LOG_ESS,"FEVPROV: End Initializing.\n"));

    return hr;

    EXIT_API_CALL
}

HRESULT CFwdEventProv::InitializeQueues( BOOL bAllowUnauth )
{
    HRESULT hr;

    DWORD dwQuota = 0xffffffff;
    PSECURITY_DESCRIPTOR pSecDesc = NULL;

    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = CoCreateInstance( CLSID_WmiMessageQueueManager,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageQueueManager,
                           (void**)&pQueueMgr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    for( int i=0 ; i < sizeof(g_adwQueueQos)/sizeof(DWORD); i++ )
    {
        if ( g_abQueueAuth[i] || (!g_abQueueAuth[i] && bAllowUnauth) )
        {
            hr = pQueueMgr->Create( g_awszQueueNames[i], 
                                    g_guidQueueType, 
                                    g_abQueueAuth[i], 
                                    g_adwQueueQos[i], 
                                    dwQuota, 
                                    pSecDesc );

            if ( FAILED(hr) && hr != WBEM_E_ALREADY_EXISTS )
            {
                ERRORTRACE((LOG_ESS,"FEVPROV: Could not create/open queue %S, "
                                    "HR=0x%x\n", g_awszQueueNames[i], hr ));
            }
        }
        else
        {
            //
            // since we're not going to allow unauthenticated queues, make 
            // sure that we delete any existing ones so that there's not an 
            // open unauthenticated entry point on the machine.  There will
            // only be a queue actually there to clean up if we're 
            // transitioning from unauthenticated allowed to not allowed.
            // 
            
            pQueueMgr->Destroy( g_awszQueueNames[i] );
        }
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::InitializeReceivers( BOOL bAllowUnauth )
{
    HRESULT hr;

    DWORD dwFlags = 0;

    if ( !bAllowUnauth )
    {
        dwFlags |= WMIMSG_FLAG_RCVR_SECURE_ONLY;
    }

    //
    // try to register an SPN for this service.  This will be used by the 
    // rpc client as a principal name for kerberos authentication.
    // 

    CWStringArray awsSPNs;

    DWORD dwRes = GetWmiSPNs( awsSPNs );

    if ( dwRes == NO_ERROR )
    {
        dwRes = RegisterSPNs( awsSPNs.GetArrayPtr(), awsSPNs.Size() );
    }

    if ( dwRes != NO_ERROR )
    {
        ERRORTRACE((LOG_ESS,
                    "FEVPROV: Could not register SPNs. Res=%d\n",
                    dwRes));
    }

    //
    // Initialize Sync DCOM Receiver.
    //

    hr = CoCreateInstance( CLSID_WmiMessageRpcReceiver,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageReceiver,
                           (void**)&m_pDcomRcvr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    WMIMSG_RCVR_AUTH_INFO AuthInfo;
    AuthInfo.awszPrincipal = awsSPNs.GetArrayPtr();
    AuthInfo.cwszPrincipal = awsSPNs.Size();

    hr = m_pDcomRcvr->Open( 
                   L"7879E40D-9FB5-450a-8A6D-00C89F349FCE@ncacn_ip_tcp:",
                   WMIMSG_FLAG_QOS_SYNCHRONOUS | dwFlags,
                   &AuthInfo,
                   &m_XSendReceive );

    if ( FAILED(hr) )
    {
        ERRORTRACE((LOG_ESS,"FEVPROV: Could not open dcom rcvr, "
                            "HR=0x%x\n", hr ));
        return hr;
    }

#ifdef __WHISTLER_UNCUT
    for( int i=0; i < sizeof(g_adwQueueQos)/sizeof(DWORD); i++ )
    {
        if ( g_abQueueAuth[i] || (!g_abQueueAuth[i] && bAllowUnauth) )
        {
            hr = CoCreateInstance( CLSID_WmiMessageMsmqReceiver,
                                   NULL,
                                   CLSCTX_INPROC,
                                   IID_IWmiMessageReceiver,
                                   (void**)&m_apQueueRcvr[i] );
            if ( FAILED(hr) )
            {
                return hr;
            }

            hr = m_apQueueRcvr[i]->Open( g_awszQueueNames[i],
                                         g_adwQueueQos[i] | dwFlags,
                                         NULL,
                                         &m_XSendReceive );
    
            if ( FAILED(hr) )
            {
                ERRORTRACE((LOG_ESS,"FEVPROV: Could not open rcvr for queue %S"
                            ", HR=0x%x\n", g_awszQueueNames[i], hr ));
            }
        }
    }
#endif

    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::NewQuery( DWORD dwId, LPWSTR wszQuery )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::CancelQuery( DWORD dwId )
{
    return WBEM_S_NO_ERROR;
}

HRESULT CFwdEventProv::Receive( PBYTE pData, 
                                ULONG cData,
                                PBYTE pAuxData,
                                ULONG cAuxData,
                                DWORD dwStatus,
                                IUnknown* pCtx )
{
    ENTER_API_CALL

    HRESULT hr;

    CBuffer DataStrm( pData, cData, FALSE );
    CBuffer HdrStrm( pAuxData, cAuxData, FALSE );

    //
    // read and verify msg hdr - don't do much with it though - it mostly
    // contains info for nack event prov.
    //

    CFwdMsgHeader FwdHdr;

    hr = FwdHdr.Unpersist( HdrStrm );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // read objects and generate event.
    //

    #define MAXEVENTS 256

    IWbemClassObject* apEvents[MAXEVENTS];
    
    DWORD i=0;
    hr = S_OK;
    
    CWbemPtr<IWmiMessageReceiverContext> pRecvCtx;

    if ( pCtx == NULL || pCtx->QueryInterface( IID_IWmiMessageReceiverContext, 
                                               (void**)&pRecvCtx ) != S_OK )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    //
    // if possible, convert our recv ctx to com context so that ess can 
    // impersonate the sender if necessary.  
    // 

    IWbemCallSecurity* pSec = NULL;

    hr = pRecvCtx->ImpersonateSender();

    if ( SUCCEEDED(hr) )
    {
        pSec = CWbemCallSecurity::CreateInst(); // ref is 1 on create.

        if ( pSec == NULL )
        {
            pRecvCtx->RevertToSelf();
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = pSec->CloneThreadContext( FALSE );

        pRecvCtx->RevertToSelf();

        IUnknown* pUnkSec = NULL;

        if ( SUCCEEDED(hr) )
        {
            hr = CoSwitchCallContext( pSec, &pUnkSec );
        }

        if ( FAILED(hr) )
        {
            pSec->Release();
            return hr;
        }

        _DBG_ASSERT( pUnkSec == NULL );
    }
    else if ( pRecvCtx->IsSenderAuthenticated() == S_FALSE )
    {
        //
        // it is expected that ImpersonateClient will fail if 
        // the sender is not authenticated.
        //
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        //
        // something else wrong here.
        //
        return WMIMSG_E_AUTHFAILURE;
    }

    const PSECURITY_DESCRIPTOR pSD = FwdHdr.GetTargetSD();
    ULONG cSD = FwdHdr.GetTargetSDLength();

    ULONG iData = DataStrm.GetIndex();

    while( i < FwdHdr.GetNumObjects() && SUCCEEDED(hr) )
    {
        for( DWORD j=0; j < MAXEVENTS && j+i < FwdHdr.GetNumObjects(); j++ )
        {
            ULONG cUsed;
            CWbemPtr<IWbemClassObject> pOriginalEvent;

            hr = m_pMrsh->Unpack( cData-iData, 
                                  pData+iData, 
                                  0, 
                                  &pOriginalEvent, 
                                  &cUsed );
            if ( FAILED(hr) )
            {
                break;
            }

            iData += cUsed;

            CWbemPtr<IWbemClassObject> pEvent;

            hr = m_pEventClass->SpawnInstance( NULL, &pEvent );

            if ( FAILED(hr) )
            {
                break;
            }

            hr = InitializeEvent( pOriginalEvent, 
                                  pRecvCtx, 
                                  FwdHdr.GetConsumer(), 
                                  FwdHdr.GetNamespace(),
                                  PBYTE(pSD),
                                  cSD,
                                  pEvent );

            if ( FAILED(hr) )
            {
                break;
            }

            pEvent->AddRef();
            apEvents[j] = pEvent;
        }

        i += j;

        if ( SUCCEEDED(hr) )
        {
            hr = m_pEventSink->Indicate( j, apEvents );
        }

        for( DWORD k=0; k < j; k++ )
        {
            apEvents[k]->Release();
        }
    }

    //
    // if we switched the com call context, then switch it back.
    //

    if ( pSec != NULL )
    {
        IUnknown* pDummy;
        
        if ( SUCCEEDED(CoSwitchCallContext( NULL, &pDummy ) ) )
        {
            _DBG_ASSERT( pDummy == pSec );
            pSec->Release();
        }
    }

    return hr;

    EXIT_API_CALL
}   

HRESULT CFwdEventProv::HandleRecvError( HRESULT hr, LPCWSTR wszError )
{
    //
    // right now just log to ESS log.
    //
    ERRORTRACE((LOG_ESS,"FEVPROV: RECV Error, ErrorString=%S, HR=0x%x\n",
                wszError, hr ));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\esscomp\forwarding\fconsink.cpp ===
#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include <buffer.h>
#include <wbemutil.h>
#include <tchar.h>
#include <sddl.h>
#include "fwdhdr.h"
#include "fconsink.h"
#include "fconsend.h"

LPCWSTR g_wszQos = L"ForwardingQos";
LPCWSTR g_wszAuth = L"Authenticate";
LPCWSTR g_wszEncrypt = L"Encryption";
LPCWSTR g_wszTargets = L"Targets";
LPCWSTR g_wszName = L"Name";
LPCWSTR g_wszTargetSD = L"TargetSD";
LPCWSTR g_wszSendSchema = L"IncludeSchema";

typedef BOOL (APIENTRY*PStringSDToSD)(
                                LPCWSTR StringSecurityDescriptor,
                                DWORD StringSDRevision,          
                                PSECURITY_DESCRIPTOR *SecurityDescriptor, 
                                PULONG SecurityDescriptorSize );

#define OPTIMAL_MESSAGE_SIZE 0x4000

class CTraceSink 
: public CUnkBase< IWmiMessageTraceSink, &IID_IWmiMessageTraceSink >
{
    CFwdConsSink* m_pOwner;

public:

    CTraceSink( CFwdConsSink* pOwner ) : m_pOwner( pOwner ) { }

    STDMETHOD(Notify)( HRESULT hRes,
                       GUID guidSource,
                       LPCWSTR wszTrace,
                       IUnknown* pContext )
    {
        return m_pOwner->Notify( hRes, guidSource, wszTrace, pContext );
    }
};

/****************************************************************************
  CFwdConsSink
*****************************************************************************/

CFwdConsSink::~CFwdConsSink()
{
    if ( m_pTargetSD != NULL )
    {
        LocalFree( m_pTargetSD );
    }
}

HRESULT CFwdConsSink::Initialize( CFwdConsNamespace* pNspc, 
                                  IWbemClassObject* pCons )
{
    HRESULT hr;
    CPropVar vQos, vAuth, vEncrypt, vTargets, vName, vSendSchema, vTargetSD;

    m_pNamespace = pNspc;

    //
    // initialize multi sender.  each forwarding consumer can
    // contain multiple targets. 
    //

    hr = CoCreateInstance( CLSID_WmiMessageMultiSendReceive,
	 		   NULL,
	 		   CLSCTX_INPROC,
	 		   IID_IWmiMessageMultiSendReceive,
	 		   (void**)&m_pMultiSend );
    if ( FAILED(hr) )
    {
	 return hr;
    }


    hr = CoCreateInstance( CLSID_WmiSmartObjectMarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&m_pMrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // initialize internal props from forwarding consumer props.
    //

    hr = pCons->Get( g_wszQos, 0, &vQos, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vQos.SetType(VT_UI4) ) )
    {
        return hr;
    } 

    if ( V_UI4(&vQos) != WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }

    hr = pCons->Get( g_wszName, 0, &vName, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vName.CheckType(VT_BSTR) ) )
    {
        return hr;
    }

    m_wsName = V_BSTR(&vName);

    hr = pCons->Get( g_wszTargetSD, 0, &vTargetSD, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    } 
  
    if ( V_VT(&vTargetSD) != VT_NULL )
    {
        if ( V_VT(&vTargetSD) != VT_BSTR )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        //
        // convert the SD string to a relative SD. The function to do this 
        // needs to be dynamically loaded because its w2k+ only.
        // 
        
        HMODULE hMod = LoadLibrary( _T("advapi32") );

        if ( hMod != NULL )
        {
            PStringSDToSD fpTextToSD;

            fpTextToSD = (PStringSDToSD)GetProcAddress( hMod, 
                   "ConvertStringSecurityDescriptorToSecurityDescriptorW" );
        
            if ( fpTextToSD != NULL )
            {
               if ( (*fpTextToSD)( V_BSTR(&vTargetSD), 
                                   SDDL_REVISION_1, 
                                   &m_pTargetSD, 
                                   &m_cTargetSD ) )
               {
                   hr = WBEM_S_NO_ERROR;
               }
               else
               {
                   hr = HRESULT_FROM_WIN32( GetLastError() );
               } 
            }
            else
            {
                hr = WBEM_E_NOT_SUPPORTED;
            }

            FreeLibrary( hMod );

            if ( FAILED(hr) )
            {
                return hr;
            }
        }
        else
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    }
    
    hr = pCons->Get( g_wszAuth, 0, &vAuth, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vAuth.SetType(VT_BOOL) ) )
    {
        return hr;
    }

    hr = pCons->Get( g_wszEncrypt, 0, &vEncrypt, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vEncrypt.SetType(VT_BOOL) ) )
    {
        return hr;
    }

    hr = pCons->Get( g_wszSendSchema, 0, &vSendSchema, NULL, NULL );

    if ( FAILED(hr) || FAILED( hr=vSendSchema.SetType(VT_BOOL) ) )
    {
        return hr;
    }

    m_dwFlags = V_UI4(&vQos);
    m_dwFlags |= V_BOOL(&vAuth)==VARIANT_TRUE ?WMIMSG_FLAG_SNDR_AUTHENTICATE:0;
    m_dwFlags |= V_BOOL(&vEncrypt)==VARIANT_TRUE ? WMIMSG_FLAG_SNDR_ENCRYPT:0;
  
    m_dwCurrentMrshFlags = WMIMSG_FLAG_MRSH_FULL_ONCE; 
    m_dwDisconnectedMrshFlags = V_BOOL(&vSendSchema) == VARIANT_TRUE ?
          WMIMSG_FLAG_MRSH_FULL : WMIMSG_FLAG_MRSH_PARTIAL;
    
    //
    // create a trace sink for receiving callbacks from wmimsg.  Note that
    // this sink's lifetime must be decoupled from this objects, else we'd 
    // end up with a circular ref.
    //
    CWbemPtr<CTraceSink> pInternalTraceSink = new CTraceSink( this );

    if ( pInternalTraceSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CWbemPtr<IWmiMessageTraceSink> pTraceSink;
    hr = pInternalTraceSink->QueryInterface( IID_IWmiMessageTraceSink, 
                                             (void**)&pTraceSink );
    _DBG_ASSERT( SUCCEEDED(hr) );

    //
    // targets array can be null, in which case we treat it as if the array
    // had one element, the empty string.
    //

    hr = pCons->Get( g_wszTargets, 0, &vTargets, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    } 

    if ( V_VT(&vTargets) != VT_NULL )
    {
        if ( FAILED(hr=vTargets.CheckType(VT_ARRAY|VT_BSTR) ) )
        {
            return WBEM_E_INVALID_OBJECT;
        }

        CPropSafeArray<BSTR> aTargets( V_ARRAY(&vTargets) );
    
        //
        // create all the fwd cons senders for the targets.  
        // 
        
        for( ULONG i=0; i < aTargets.Length(); i++ )
        {
            CWbemPtr<IWmiMessageSendReceive> pSend;
            
            hr = CFwdConsSend::Create( m_pControl, 
                                       aTargets[i],
                                       m_dwFlags,
                                       m_pNamespace->GetSvc(),
                                       pTraceSink,
                                       &pSend );
            if ( FAILED(hr) )
            {
                break;
            }

            hr = m_pMultiSend->Add( 0, pSend );
            
            if ( FAILED(hr) )
            { 
                break;
            }
        }
    }
    else
    {
        CWbemPtr<IWmiMessageSendReceive> pSend;

        hr = CFwdConsSend::Create( m_pControl,
                                   L"",
                                   m_dwFlags,
                                   m_pNamespace->GetSvc(),
                                   pTraceSink,
                                   &pSend );
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = m_pMultiSend->Add( 0, pSend );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;  
}

//
// this method handles all sending/marshaling errors internally and will 
// return either S_OK when all objects are processed or S_FALSE 
// if only some are processed.
//

HRESULT CFwdConsSink::IndicateSome( IWbemClassObject* pConsumer,
                                    long cObjs, 
                                    IWbemClassObject** ppObjs, 
                                    long* pcProcessed )
{
    HRESULT hr;

    _DBG_ASSERT( cObjs > 0 );
    
    //
    // create an execution id for this indicate.
    //

    GUID guidExecution;
    CoCreateGuid( &guidExecution );

    //
    // marshal the events. we will stop marshaling them when the buffer 
    // gets bigger than it should for an optimally sized message.
    //

    BYTE achData[512];
    BYTE achHdr[256];

    CBuffer DataStrm( achData, 512, FALSE );
    CBuffer HdrStrm( achHdr, 256, FALSE );

    //
    // we remembered our last buffer size, so set to that in the hopes that 
    // we can avoid a retry on the packing.
    //
    
    hr = DataStrm.SetSize( m_ulLastDataSize );
    m_ulLastDataSize = 0;

    ULONG i;

    for( i = 0; i < cObjs && SUCCEEDED(hr); i++ )
    {
        ULONG cUsed;
        PBYTE pData = DataStrm.GetRawData();
        ULONG cData = DataStrm.GetSize();
        ULONG iData = DataStrm.GetIndex();

        if ( iData < OPTIMAL_MESSAGE_SIZE )
        {
            hr = m_pMrsh->Pack( ppObjs[i], 
                                m_pNamespace->GetName(),
                                m_dwCurrentMrshFlags, 
                                cData-iData,
                                pData+iData,
                                &cUsed );

            if ( hr == WBEM_E_BUFFER_TOO_SMALL )
            {
                hr = DataStrm.SetSize( iData + cUsed );

                if ( SUCCEEDED(hr) )
                {
                    pData = DataStrm.GetRawData();
                    cData = DataStrm.GetSize();
                                        
                    hr = m_pMrsh->Pack( ppObjs[i], 
                                        m_pNamespace->GetName(),
                                        m_dwCurrentMrshFlags, 
                                        cData-iData, 
                                        pData+iData, 
                                        &cUsed);
                }
            }

            if ( SUCCEEDED(hr) )
            {
                DataStrm.Advance( cUsed );
            }
        }
        else
        {
            break;
        }
    }

    //
    // at this point, we know how many events we've actually processed
    // i will always be the number of objects successfully processed.  
    // we want to try to separate out the events that fail to be packed 
    // from ones that are packed.  For this reason, pretend we didn't event 
    // process the one that failed, unless it is the first one.
    // 
    
    *pcProcessed = i > 0 ? i : 1;

    //
    // create a context object for this indicate. This is used to  
    // thread information through to the trace functions 
    // which are invoked by the senders. 
    //

    CFwdContext Ctx( guidExecution, pConsumer, *pcProcessed, ppObjs );        
    
    if ( i > 0 ) // at least some were successfully processed.
    {
        m_ulLastDataSize = DataStrm.GetIndex();

        //
        // create and stream the msg header 
        //

        CFwdMsgHeader Hdr( *pcProcessed, 
                           m_dwFlags & WMIMSG_MASK_QOS, 
                           m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE,
                           m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT, 
                           guidExecution, 
                           m_wsName,
                           m_pNamespace->GetName(),
                           PBYTE(m_pTargetSD),
                           m_cTargetSD );

        hr = Hdr.Persist( HdrStrm );

        if ( SUCCEEDED(hr) )
        {
            //
            // send it and notify the tracing sink of the result.  Always try
            // once with return immediately set.  This will try all the 
            // primary senders first.
            //

            hr = m_pMultiSend->SendReceive( DataStrm.GetRawData(), 
                                            DataStrm.GetIndex(),
                                            HdrStrm.GetRawData(),
                                            HdrStrm.GetIndex(),
                                     WMIMSG_FLAG_MULTISEND_RETURN_IMMEDIATELY,
                                            &Ctx );

            if ( SUCCEEDED(hr) )
            {
                ;
            }
            else
            {
                //
                // o.k so all the primary ones failed, so now lets try all the 
                // senders.
                //
            
                hr = m_pMultiSend->SendReceive( DataStrm.GetRawData(),
                                                DataStrm.GetIndex(),
                                                HdrStrm.GetRawData(),
                                                HdrStrm.GetIndex(),
                                                0,
                                                &Ctx );
            }
        }
    }

    m_pNamespace->HandleTrace( hr, &Ctx );

    return *pcProcessed == cObjs ? S_OK : S_FALSE;
}

//
// this is where we get notified of every target send event.  here, we look 
// at the information and adjust our marshalers accordingly. we then pass the
// event onto the namespace sink for tracing purposes. NOTE: This solution of 
// adjusting our marshalers on callbacks means that we're assuming a couple 
// things about the send implementation .. 1 ) the notification of the send 
// must be on the same control path as the send call.  2 ) the sender will 
// use the same target when it has successfully sent to it previously (e.g it
// will not notify us that it sent to an rpc target, we then optimize our 
// marshalers for it, then it chooses to send to an msmq target ).  
//

HRESULT CFwdConsSink::Notify( HRESULT hRes,
                              GUID guidSource,
                              LPCWSTR wszTrace,
                              IUnknown* pContext )
{
    HRESULT hr;

    ENTER_API_CALL

    if ( FAILED(hRes) )
    {
        //
        // we failed sending to a target, flush any state the marshaler 
        // was keeping.
        //
        m_pMrsh->Flush();
    }

    //
    // check that current marshaling flags against the type of sender that 
    // was used.
    //

    if ( guidSource == CLSID_WmiMessageRpcSender )
    {
        if ( SUCCEEDED(hRes) &&
             m_dwCurrentMrshFlags != WMIMSG_FLAG_MRSH_FULL_ONCE )
        {
            //
            // lets give schema once-only a whirl..
            //
            m_dwCurrentMrshFlags = WMIMSG_FLAG_MRSH_FULL_ONCE;
        }
    }
    else // must be queueing
    {
        if ( m_dwCurrentMrshFlags == WMIMSG_FLAG_MRSH_FULL_ONCE )
        {
            //
            // once only is not for messaging !! Its o.k. though
            // because we are sure that we've only used it once
            // and it did send the schema.  Just don't use it again.
            //
            m_dwCurrentMrshFlags = m_dwDisconnectedMrshFlags;
        }
    }

    //
    // pass the call onto the namespace sink for tracing.
    //

    hr = m_pNamespace->Notify( hRes, guidSource, wszTrace, pContext );
    
    EXIT_API_CALL

    return hr;
}

HRESULT CFwdConsSink::IndicateToConsumer( IWbemClassObject* pConsumer,
                                          long cObjs, 
                                          IWbemClassObject** ppObjs )
{
    HRESULT hr;

    ENTER_API_CALL

    //
    // If the security context of the event provider is maintained then 
    // we will use it to send the forwarded event.
    // 

    CoImpersonateClient();
    
    long cProcessed = 0;
    
    //
    // IndicateSome() may send only a subset of the total indicated events.
    // This is to avoid sending potentially huge messages.  So we'll keep 
    // calling IndicateSome() until all messages are sent or there's an error.
    // 

    do
    {
        cObjs -= cProcessed;
        ppObjs += cProcessed;

        hr = IndicateSome( pConsumer, cObjs, ppObjs, &cProcessed );

        _DBG_ASSERT( FAILED(hr) || (SUCCEEDED(hr) && cProcessed > 0 )); 

    } while ( SUCCEEDED(hr) && cProcessed < cObjs );

    CoRevertToSelf();

    EXIT_API_CALL

    return hr;
}

HRESULT CFwdConsSink::Create( CLifeControl* pCtl, 
                              CFwdConsNamespace* pNspc,
                              IWbemClassObject* pCons, 
                              IWb